[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
Some weights of the model checkpoint at microsoft/graphcodebert-base were not used when initializing RobertaModel: ['lm_head.dense.weight', 'lm_head.layer_norm.bias', 'lm_head.layer_norm.weight', 'lm_head.decoder.bias', 'lm_head.decoder.weight', 'lm_head.bias', 'lm_head.dense.bias']
- This IS expected if you are initializing RobertaModel from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaModel from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
Some weights of RobertaModel were not initialized from the model checkpoint at microsoft/graphcodebert-base and are newly initialized: ['roberta.pooler.dense.weight', 'roberta.pooler.dense.bias']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
textattack: Running 4 worker(s) on 4 GPU(s).
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
Using /home/cg/tmp/tfhub_modules to cache modules.
Downloading TF-Hub Module 'https://tfhub.dev/google/universal-sentence-encoder/4'.
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  tfhub.dev:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  storage.googleapis.com:443  ...  OK
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
Downloading https://tfhub.dev/google/universal-sentence-encoder/4: 190.00MB
Downloading https://tfhub.dev/google/universal-sentence-encoder/4: 420.00MB
Downloading https://tfhub.dev/google/universal-sentence-encoder/4: 660.00MB
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
Downloading https://tfhub.dev/google/universal-sentence-encoder/4: 890.00MB
Downloaded https://tfhub.dev/google/universal-sentence-encoder/4, Total size: 987.47MB
Downloaded TF-Hub Module 'https://tfhub.dev/google/universal-sentence-encoder/4'.
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s]  0%|          | 1/1000 [00:01<21:19,  1.28s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:01<21:21,  1.28s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 2/1000 [00:08<1:13:18,  4.41s/it][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:08<1:13:19,  4.41s/it][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 3/1000 [00:18<1:43:32,  6.23s/it][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [00:18<1:43:32,  6.23s/it][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 4/1000 [00:19<1:21:47,  4.93s/it][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 4/1000 [00:19<1:21:47,  4.93s/it][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 5/1000 [00:20<1:06:59,  4.04s/it][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   0%|          | 5/1000 [00:20<1:06:59,  4.04s/it][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   1%|          | 6/1000 [00:27<1:15:10,  4.54s/it][Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 6/1000 [00:27<1:15:10,  4.54s/it][Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 7/1000 [00:27<1:04:42,  3.91s/it]--------------------------------------------- Result 1 ---------------------------------------------
Emit the given value to the downstream . --> Brain a new value --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean [[delayError]] , Disposable [[disposable]] ) { final Observer < ? super V > [[observer]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[observer]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[observer]] , [[delayError]] , [[disposable]] , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[loring]] ( U value , boolean [[bergerac]] , Disposable [[offered]] ) { final Observer < ? super V > [[prudential]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[prudential]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[prudential]] , [[bergerac]] , [[offered]] , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 2 ---------------------------------------------
Observable observable . --> Observer methods --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > co , final Scheduler [[scheduler]] ) { final Observable < T > [[observable]] = co . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , [[observable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[rhis]] ( final ConnectableObservable < T > co , final Scheduler [[montero]] ) { final Observable < T > [[remarked]] = co . observeOn ( [[montero]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , [[remarked]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 3 ---------------------------------------------
Wraps an Observable . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[packaging]] ( ObservableSource < T > [[ancestral]] ) { ObjectHelper . requireNonNull ( [[ancestral]] , "source is null" ) ; if ( [[ancestral]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[ancestral]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[ancestral]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 4 ---------------------------------------------
Creates a new executor with given capacity . --> throws UnsafeProcessor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[capacityHint]] , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[creation]] ( int [[observe]] , Runnable [[israelite]] ) { ObjectHelper . requireNonNull ( [[israelite]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[observe]] , [[israelite]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 5 ---------------------------------------------
Creates a new instance of this class . --> Create a new uncast process --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[cause]] ( int [[feces]] ) { return new UnicastProcessor < T > ( [[feces]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 6 ---------------------------------------------
Gets a stream of scalar X values from a scalar value . --> Liefert den kuchargegegebenen Texts --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[linguistics]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > [[bucharest]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , [[bucharest]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 7/1000 [00:27<1:04:42,  3.91s/it][Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 8/1000 [00:35<1:13:11,  4.43s/it][Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 8/1000 [00:35<1:13:11,  4.43s/it][Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 9/1000 [00:40<1:14:56,  4.54s/it][Succeeded / Failed / Skipped / Total] 9 / 0 / 0 / 9:   1%|          | 9/1000 [00:40<1:14:56,  4.54s/it][Succeeded / Failed / Skipped / Total] 9 / 0 / 0 / 9:   1%|          | 10/1000 [01:09<1:53:58,  6.91s/it][Succeeded / Failed / Skipped / Total] 10 / 0 / 0 / 10:   1%|          | 10/1000 [01:09<1:53:58,  6.91s/it][Succeeded / Failed / Skipped / Total] 10 / 0 / 0 / 10:   1%|          | 11/1000 [01:13<1:50:40,  6.71s/it][Succeeded / Failed / Skipped / Total] 10 / 1 / 0 / 11:   1%|          | 11/1000 [01:13<1:50:41,  6.72s/it][Succeeded / Failed / Skipped / Total] 10 / 1 / 0 / 11:   1%|          | 12/1000 [01:19<1:48:49,  6.61s/it][Succeeded / Failed / Skipped / Total] 11 / 1 / 0 / 12:   1%|          | 12/1000 [01:19<1:48:49,  6.61s/it][Succeeded / Failed / Skipped / Total] 11 / 1 / 0 / 12:   1%|▏         | 13/1000 [01:25<1:48:33,  6.60s/it][Succeeded / Failed / Skipped / Total] 12 / 1 / 0 / 13:   1%|▏         | 13/1000 [01:25<1:48:34,  6.60s/it][Succeeded / Failed / Skipped / Total] 12 / 1 / 0 / 13:   1%|▏         | 14/1000 [02:03<2:25:29,  8.85s/it]Resets the scheduler . --> This method is called when the scheduler is restarted --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[False]]" != "[[False]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[recovery]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[Fraudulent]]" != "[[Fraudulent]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 8 ---------------------------------------------
Construct a Maybe from a CompletableSource . --> KOOO --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[kobo]] ( CompletableSource [[prunella]] ) { ObjectHelper . requireNonNull ( [[prunella]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[prunella]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 9 ---------------------------------------------
Retry the future with given times --> Return a retryable with a single element --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[times]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[times]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[length]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[length]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 10 ---------------------------------------------
Construct a Maybe from a single source . --> POAR YOY --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[pochi]] ( SingleSource < T > [[velazquez]] ) { ObjectHelper . requireNonNull ( [[velazquez]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[velazquez]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 11 ---------------------------------------------
Ensures that an object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 12 ---------------------------------------------
Gets the identity function . --> Convenience method for creating a tonne --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[tonne]] > Function < [[tonne]] , [[tonne]] > [[brands]] ( ) { return ( Function < [[tonne]] , [[tonne]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 13 ---------------------------------------------
Create a callable for value . --> assign problems --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[problems]] ( T [[assess]] ) { return new JustValue < Object , T > ( [[assess]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 14 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 13 / 1 / 0 / 14:   1%|▏         | 14/1000 [02:03<2:25:29,  8.85s/it][Succeeded / Failed / Skipped / Total] 13 / 1 / 0 / 14:   2%|▏         | 15/1000 [02:09<2:21:22,  8.61s/it][Succeeded / Failed / Skipped / Total] 14 / 1 / 0 / 15:   2%|▏         | 15/1000 [02:09<2:21:22,  8.61s/it][Succeeded / Failed / Skipped / Total] 14 / 1 / 0 / 15:   2%|▏         | 16/1000 [03:10<3:14:52, 11.88s/it][Succeeded / Failed / Skipped / Total] 15 / 1 / 0 / 16:   2%|▏         | 16/1000 [03:10<3:14:52, 11.88s/it][Succeeded / Failed / Skipped / Total] 15 / 1 / 0 / 16:   2%|▏         | 17/1000 [03:32<3:24:29, 12.48s/it][Succeeded / Failed / Skipped / Total] 16 / 1 / 0 / 17:   2%|▏         | 17/1000 [03:32<3:24:29, 12.48s/it][Succeeded / Failed / Skipped / Total] 16 / 1 / 0 / 17:   2%|▏         | 18/1000 [03:34<3:15:16, 11.93s/it][Succeeded / Failed / Skipped / Total] 17 / 1 / 0 / 18:   2%|▏         | 18/1000 [03:34<3:15:16, 11.93s/it][Succeeded / Failed / Skipped / Total] 17 / 1 / 0 / 18:   2%|▏         | 19/1000 [03:51<3:19:26, 12.20s/it][Succeeded / Failed / Skipped / Total] 18 / 1 / 0 / 19:   2%|▏         | 19/1000 [03:51<3:19:26, 12.20s/it][Succeeded / Failed / Skipped / Total] 18 / 1 / 0 / 19:   2%|▏         | 20/1000 [04:21<3:33:21, 13.06s/it]Tries to apply scalar X map subscribe to a scalar value . --> else return true --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T [[t]] ; try { [[t]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( [[t]] == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[t]] ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[feri]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T [[wo]] ; try { [[wo]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Really]]" == "[[Really]]" ; } if ( [[wo]] == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Really]]" == "[[Really]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[wo]] ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Really]]" == "[[Really]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Really]]" == "[[Really]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Really]]" == "[[Really]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "[[Really]]" == "[[Really]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 15 ---------------------------------------------
Create a reusable subject . --> Create a unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[crea]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[Honest]]" == "[[Honest]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 16 ---------------------------------------------
Create a new unicast subject with the given capacity . --> create a unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[hazara]] ) { return new UnicastSubject < T > ( [[hazara]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 17 ---------------------------------------------
Creates a new reusable subject . --> developer --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( [[capacityHint]] , [[onTerminate]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[develop]] ( int [[yenny]] , Runnable [[scam]] ) { return new UnicastSubject < T > ( [[yenny]] , [[scam]] , "[[Realities]]" == "[[Realities]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 18 ---------------------------------------------
Returns an Observable with the given sort function . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[categorized]] ( Comparator < ? super T > [[obnoxious]] ) { ObjectHelper . requireNonNull ( [[obnoxious]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[obnoxious]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 19 ---------------------------------------------
Waits for an error . --> Waits for non - blocking --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[noth]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 20 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 19 / 1 / 0 / 20:   2%|▏         | 20/1000 [04:21<3:33:21, 13.06s/it][Succeeded / Failed / Skipped / Total] 19 / 1 / 0 / 20:   2%|▏         | 21/1000 [04:22<3:24:15, 12.52s/it][Succeeded / Failed / Skipped / Total] 20 / 1 / 0 / 21:   2%|▏         | 21/1000 [04:22<3:24:15, 12.52s/it][Succeeded / Failed / Skipped / Total] 20 / 1 / 0 / 21:   2%|▏         | 22/1000 [04:27<3:18:22, 12.17s/it][Succeeded / Failed / Skipped / Total] 21 / 1 / 0 / 22:   2%|▏         | 22/1000 [04:27<3:18:22, 12.17s/it][Succeeded / Failed / Skipped / Total] 21 / 1 / 0 / 22:   2%|▏         | 23/1000 [04:33<3:13:38, 11.89s/it][Succeeded / Failed / Skipped / Total] 22 / 1 / 0 / 23:   2%|▏         | 23/1000 [04:33<3:13:38, 11.89s/it][Succeeded / Failed / Skipped / Total] 22 / 1 / 0 / 23:   2%|▏         | 24/1000 [05:57<4:02:11, 14.89s/it][Succeeded / Failed / Skipped / Total] 23 / 1 / 0 / 24:   2%|▏         | 24/1000 [05:57<4:02:11, 14.89s/it][Succeeded / Failed / Skipped / Total] 23 / 1 / 0 / 24:   2%|▎         | 25/1000 [05:58<3:52:51, 14.33s/it][Succeeded / Failed / Skipped / Total] 24 / 1 / 0 / 25:   2%|▎         | 25/1000 [05:58<3:52:52, 14.33s/it][Succeeded / Failed / Skipped / Total] 24 / 1 / 0 / 25:   3%|▎         | 26/1000 [06:01<3:45:42, 13.90s/it]Creates a new reusable instance . --> Create a new UniformSubject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[establishments]] ( boolean [[drug]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[drug]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 21 ---------------------------------------------
Wait for the element to be read . --> Receives a resumible for resum --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[resumé]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 22 ---------------------------------------------
Waits for the element to complete . --> Waits for contacts --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } } Throwable [[ex]] = error ; if ( [[ex]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[houseful]] ( long [[interval]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[interval]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[divorces]] ) ; } } Throwable [[divorces]] = error ; if ( [[divorces]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[divorces]] ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 23 ---------------------------------------------
Requests to a subscription . --> Sends a simon to a subscription --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription s , int [[prefetch]] ) { s . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription s , int [[simonson]] ) { s . request ( [[simonson]] < 0 ? Long . MAX_VALUE : [[simonson]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 24 ---------------------------------------------
Runs a maximum number of items from a queue . --> initiate a publisher --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > [[q]] , Subscriber < ? super U > a , boolean [[delayError]] , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean [[d]] = qd . done ( ) ; T [[v]] = [[q]] . poll ( ) ; boolean empty = [[v]] == null ; if ( checkTerminated ( [[d]] , empty , a , [[delayError]] , [[q]] , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , [[v]] ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { [[q]] . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[violinist]] ( SimplePlainQueue < T > [[newspaperman]] , Subscriber < ? super U > a , boolean [[advancements]] , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean [[ives]] = qd . done ( ) ; T [[fifth]] = [[newspaperman]] . poll ( ) ; boolean empty = [[fifth]] == null ; if ( checkTerminated ( [[ives]] , empty , a , [[advancements]] , [[newspaperman]] , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , [[fifth]] ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { [[newspaperman]] . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 25 ---------------------------------------------
Returns a function that returns the value of the given value . --> Approximates one tonne --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[tonne]] , U > Function < [[tonne]] , U > [[upscale]] ( U [[merited]] ) { return new JustValue < [[tonne]] , U > ( [[merited]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 26 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 1 / 0 / 26:   3%|▎         | 26/1000 [06:01<3:45:42, 13.90s/it][Succeeded / Failed / Skipped / Total] 25 / 1 / 0 / 26:   3%|▎         | 27/1000 [07:04<4:14:45, 15.71s/it][Succeeded / Failed / Skipped / Total] 26 / 1 / 0 / 27:   3%|▎         | 27/1000 [07:04<4:14:45, 15.71s/it][Succeeded / Failed / Skipped / Total] 26 / 1 / 0 / 27:   3%|▎         | 28/1000 [08:23<4:51:23, 17.99s/it][Succeeded / Failed / Skipped / Total] 27 / 1 / 0 / 28:   3%|▎         | 28/1000 [08:23<4:51:23, 17.99s/it][Succeeded / Failed / Skipped / Total] 27 / 1 / 0 / 28:   3%|▎         | 29/1000 [08:32<4:45:53, 17.67s/it][Succeeded / Failed / Skipped / Total] 28 / 1 / 0 / 29:   3%|▎         | 29/1000 [08:32<4:45:53, 17.67s/it][Succeeded / Failed / Skipped / Total] 28 / 1 / 0 / 29:   3%|▎         | 30/1000 [09:41<5:13:32, 19.39s/it][Succeeded / Failed / Skipped / Total] 29 / 1 / 0 / 30:   3%|▎         | 30/1000 [09:41<5:13:32, 19.39s/it][Succeeded / Failed / Skipped / Total] 29 / 1 / 0 / 30:   3%|▎         | 31/1000 [10:48<5:37:54, 20.92s/it][Succeeded / Failed / Skipped / Total] 30 / 1 / 0 / 31:   3%|▎         | 31/1000 [10:48<5:37:54, 20.92s/it][Succeeded / Failed / Skipped / Total] 30 / 1 / 0 / 31:   3%|▎         | 32/1000 [10:52<5:28:45, 20.38s/it][Succeeded / Failed / Skipped / Total] 31 / 1 / 0 / 32:   3%|▎         | 32/1000 [10:52<5:28:45, 20.38s/it][Succeeded / Failed / Skipped / Total] 31 / 1 / 0 / 32:   3%|▎         | 33/1000 [10:54<5:19:40, 19.83s/it][Succeeded / Failed / Skipped / Total] 32 / 1 / 0 / 33:   3%|▎         | 33/1000 [10:54<5:19:40, 19.83s/it][Succeeded / Failed / Skipped / Total] 32 / 1 / 0 / 33:   3%|▎         | 34/1000 [11:31<5:27:36, 20.35s/it]Post complete event . --> This method is not thread safe --> Socre: 1.0

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > [[actual]] , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { [[actual]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , [[actual]] , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > [[practical]] , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { [[practical]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , [[practical]] , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 27 ---------------------------------------------
Returns a cast function . --> Create lasalle --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[lasalle]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 28 ---------------------------------------------
Gets the value . --> getter for lafleur --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[lafleur]] ( ) { Object [[wu]] = value ; if ( [[wu]] != null && ! NotificationLite . isError ( [[wu]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 29 ---------------------------------------------
Atomically sets the next AtomicReference to the given AtomicReference . --> used for testing --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Disposable > [[upstream]] , Disposable next , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean [[cum]] ( AtomicReference < Disposable > [[forth]] , Disposable next , Class < ? > [[observing]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[forth]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[forth]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observing]] ) ; } return "False" != "False" ; } return "[[Realist]]" == "[[Realist]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 30 ---------------------------------------------
Determines whether the next element is expected or not . --> Perform verification --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable [[upstream]] , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[verification]] ( Disposable [[forth]] , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[forth]] != null ) { next . dispose ( ) ; if ( [[forth]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 31 ---------------------------------------------
Gets the error . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[bango]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 32 ---------------------------------------------
Cap a long value . --> Capacity of longs --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long [[a]] , long [[b]] ) { long u = [[a]] + [[b]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long [[to]] , long [[k]] ) { long u = [[to]] + [[k]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 33 ---------------------------------------------
Multiply a long value . --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: public static long [[multiplyCap]] ( long a , long [[b]] ) { long u = a * [[b]] ; if ( ( ( a | [[b]] ) >>> 31 ) != 0 ) { if ( u / a != [[b]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[rosebush]] ( long a , long [[iii]] ) { long u = a * [[iii]] ; if ( ( ( a | [[iii]] ) >>> 31 ) != 0 ) { if ( u / a != [[iii]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 34 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 1 / 0 / 34:   3%|▎         | 34/1000 [11:31<5:27:36, 20.35s/it][Succeeded / Failed / Skipped / Total] 33 / 1 / 0 / 34:   4%|▎         | 35/1000 [11:38<5:20:45, 19.94s/it][Succeeded / Failed / Skipped / Total] 34 / 1 / 0 / 35:   4%|▎         | 35/1000 [11:38<5:20:45, 19.94s/it][Succeeded / Failed / Skipped / Total] 34 / 1 / 0 / 35:   4%|▎         | 36/1000 [11:42<5:13:19, 19.50s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 0 / 36:   4%|▎         | 36/1000 [11:42<5:13:19, 19.50s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 0 / 36:   4%|▎         | 37/1000 [11:46<5:06:32, 19.10s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 0 / 37:   4%|▎         | 37/1000 [11:46<5:06:32, 19.10s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 0 / 37:   4%|▍         | 38/1000 [11:47<4:58:31, 18.62s/it][Succeeded / Failed / Skipped / Total] 37 / 1 / 0 / 38:   4%|▍         | 38/1000 [11:47<4:58:31, 18.62s/it][Succeeded / Failed / Skipped / Total] 37 / 1 / 0 / 38:   4%|▍         | 39/1000 [12:07<4:58:50, 18.66s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 0 / 39:   4%|▍         | 39/1000 [12:07<4:58:50, 18.66s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 0 / 39:   4%|▍         | 40/1000 [12:26<4:58:37, 18.66s/it][Succeeded / Failed / Skipped / Total] 39 / 1 / 0 / 40:   4%|▍         | 40/1000 [12:26<4:58:37, 18.66s/it][Succeeded / Failed / Skipped / Total] 39 / 1 / 0 / 40:   4%|▍         | 41/1000 [12:26<4:51:11, 18.22s/it]Validates the next stream . --> Perform verification --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Subscription [[upstream]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[verification]] ( Subscription [[upriver]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upriver]] != null ) { next . cancel ( ) ; if ( [[upriver]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 35 ---------------------------------------------
Converts a Throwable to a NullPointerException . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable [[ex]] ) { NullPointerException [[npe]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[npe]] . initCause ( [[ex]] ) ; return [[npe]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[ménage]] ( Throwable [[divorce]] ) { NullPointerException [[loudspeakers]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[loudspeakers]] . initCause ( [[divorce]] ) ; return [[loudspeakers]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 36 ---------------------------------------------
Adds an object to the end . --> Calculate the given value --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[addition]] ( Object [[either]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 37 ---------------------------------------------
Shut down the pool --> Close down resources --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[closings]] ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 38 ---------------------------------------------
Atomically sets an AtomicReference to the given AtomicReference . --> Bromo --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Subscription > [[upstream]] , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean [[bromo]] ( AtomicReference < Subscription > [[soar]] , Subscription [[futuristic]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[futuristic]] , "next is null" ) ; if ( ! [[soar]] . compareAndSet ( null , [[futuristic]] ) ) { [[futuristic]] . cancel ( ) ; if ( [[soar]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[Factual]]" == "[[Factual]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 39 ---------------------------------------------
Sets the Subscription to this Future . --> Submits an operation to the target --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long [[r]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[r]] != 0L ) { [[s]] . request ( [[r]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[subatomic]] ( Subscription [[oder]] ) { if ( cancelled ) { [[oder]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[oder]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[oder]] ; long [[p]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[p]] != 0L ) { [[oder]] . request ( [[p]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[oder]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 40 ---------------------------------------------
Loops through the queue . --> Must be called once --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[q]] ; synchronized ( this ) { [[q]] = queue ; if ( [[q]] == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } [[q]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[substantial]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[wondering]] ; synchronized ( this ) { [[wondering]] = queue ; if ( [[wondering]] == null ) { emitting = "[[Scythe]]" != "[[Scythe]]" ; return ; } queue = null ; } [[wondering]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 41 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 40 / 1 / 0 / 41:   4%|▍         | 41/1000 [12:26<4:51:11, 18.22s/it][Succeeded / Failed / Skipped / Total] 40 / 1 / 0 / 41:   4%|▍         | 42/1000 [12:41<4:49:28, 18.13s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 0 / 42:   4%|▍         | 42/1000 [12:41<4:49:28, 18.13s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 0 / 42:   4%|▍         | 43/1000 [14:34<5:24:18, 20.33s/it][Succeeded / Failed / Skipped / Total] 42 / 1 / 0 / 43:   4%|▍         | 43/1000 [14:34<5:24:18, 20.33s/it][Succeeded / Failed / Skipped / Total] 42 / 1 / 0 / 43:   4%|▍         | 44/1000 [14:35<5:16:55, 19.89s/it][Succeeded / Failed / Skipped / Total] 43 / 1 / 0 / 44:   4%|▍         | 44/1000 [14:35<5:16:55, 19.89s/it][Succeeded / Failed / Skipped / Total] 43 / 1 / 0 / 44:   4%|▍         | 45/1000 [14:54<5:16:26, 19.88s/it][Succeeded / Failed / Skipped / Total] 44 / 1 / 0 / 45:   4%|▍         | 45/1000 [14:54<5:16:26, 19.88s/it][Succeeded / Failed / Skipped / Total] 44 / 1 / 0 / 45:   5%|▍         | 46/1000 [15:11<5:15:01, 19.81s/it]Creates a new scheduled thread pool . --> Expired ThreadPool --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[engendered]] ( ThreadFactory [[installation]] ) { final ScheduledExecutorService [[clipboard]] = Executors . newScheduledThreadPool ( 1 , [[installation]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[clipboard]] ) ; return [[clipboard]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 42 ---------------------------------------------
Flattens the given exception into a list --> Destroy an exception --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > [[list]] = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[deque]] = new ArrayDeque < Throwable > ( ) ; [[deque]] . offer ( t ) ; while ( ! [[deque]] . isEmpty ( ) ) { Throwable e = [[deque]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[deque]] . offerFirst ( exceptions . get ( i ) ) ; } } else { [[list]] . add ( e ) ; } } return [[list]] ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[destroy]] ( Throwable t ) { List < Throwable > [[inscriptions]] = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[dissenting]] = new ArrayDeque < Throwable > ( ) ; [[dissenting]] . offer ( t ) ; while ( ! [[dissenting]] . isEmpty ( ) ) { Throwable e = [[dissenting]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[dissenting]] . offerFirst ( exceptions . get ( i ) ) ; } } else { [[inscriptions]] . add ( e ) ; } } return [[inscriptions]] ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 43 ---------------------------------------------
Called when the stream is complete . --> Protected methods --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R [[n]] ) { long [[p]] = produced ; if ( [[p]] != 0 ) { BackpressureHelper . produced ( this , [[p]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[n]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[n]] ) ; downstream . onComplete ( ) ; return ; } value = [[n]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[priming]] ( R [[z]] ) { long [[of]] = produced ; if ( [[of]] != 0 ) { BackpressureHelper . produced ( this , [[of]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[z]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[z]] ) ; downstream . onComplete ( ) ; return ; } value = [[z]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 44 ---------------------------------------------
Atomically add n to the requested long . --> Incrementing a sum of quotes --> Socre: 1.0

[[[[Adv]]]]: public static long [[add]] ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long [[r]] = [[requested]] . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[u]] = addCap ( [[r]] , [[n]] ) ; if ( [[requested]] . compareAndSet ( [[r]] , [[u]] ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[summing]] ( AtomicLong [[requisitions]] , long [[o]] ) { for ( ; ; ) { long [[kumar]] = [[requisitions]] . get ( ) ; if ( [[kumar]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[lau]] = addCap ( [[kumar]] , [[o]] ) ; if ( [[requisitions]] . compareAndSet ( [[kumar]] , [[lau]] ) ) { return [[kumar]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 45 ---------------------------------------------
Clears all resources . --> Lazily dispose this class --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[clara]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[prescribes]] ; synchronized ( this ) { if ( disposed ) { return ; } [[prescribes]] = resources ; resources = null ; } dispose ( [[prescribes]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 46 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 45 / 1 / 0 / 46:   5%|▍         | 46/1000 [15:11<5:15:01, 19.81s/it][Succeeded / Failed / Skipped / Total] 45 / 1 / 0 / 46:   5%|▍         | 47/1000 [15:32<5:14:58, 19.83s/it][Succeeded / Failed / Skipped / Total] 46 / 1 / 0 / 47:   5%|▍         | 47/1000 [15:32<5:14:59, 19.83s/it][Succeeded / Failed / Skipped / Total] 46 / 1 / 0 / 47:   5%|▍         | 48/1000 [15:54<5:15:34, 19.89s/it][Succeeded / Failed / Skipped / Total] 47 / 1 / 0 / 48:   5%|▍         | 48/1000 [15:54<5:15:34, 19.89s/it][Succeeded / Failed / Skipped / Total] 47 / 1 / 0 / 48:   5%|▍         | 49/1000 [17:31<5:40:16, 21.47s/it][Succeeded / Failed / Skipped / Total] 48 / 1 / 0 / 49:   5%|▍         | 49/1000 [17:31<5:40:16, 21.47s/it][Succeeded / Failed / Skipped / Total] 48 / 1 / 0 / 49:   5%|▌         | 50/1000 [18:01<5:42:25, 21.63s/it][Succeeded / Failed / Skipped / Total] 48 / 2 / 0 / 50:   5%|▌         | 50/1000 [18:01<5:42:25, 21.63s/it][Succeeded / Failed / Skipped / Total] 48 / 2 / 0 / 50:   5%|▌         | 51/1000 [18:03<5:36:08, 21.25s/it]Tries to apply a scalar Xmap for scalar values from the source . --> Example of how SERVER_SERVER --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > source , Observer < ? super R > [[observer]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "True" == "True" ; } ObservableSource < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[observer]] , u ) ; [[observer]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[r]] . subscribe ( [[observer]] ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[howser]] ( ObservableSource < T > source , Observer < ? super R > [[columnists]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[columnists]] ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( [[columnists]] ) ; return "True" == "True" ; } ObservableSource < ? extends R > [[prasad]] ; try { [[prasad]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[columnists]] ) ; return "True" == "True" ; } if ( [[prasad]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[prasad]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[columnists]] ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( [[columnists]] ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[columnists]] , u ) ; [[columnists]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[prasad]] . subscribe ( [[columnists]] ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 47 ---------------------------------------------
Creates an observable that maps the given value using the given mapping function . --> Hook for testing --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[haley]] ( T [[inestimable]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[evil]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[inestimable]] , [[evil]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 48 ---------------------------------------------
Accept notification . --> Accepts notifications --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[subscriber]] ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[o]] = [[a]] [ i ] ; if ( [[o]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[o]] , [[subscriber]] ) ) { return "[[True]]" == "[[True]]" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[buyers]] ) { Object [ ] [[une]] = head ; final int c = capacity ; while ( [[une]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[u]] = [[une]] [ i ] ; if ( [[u]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[u]] , [[buyers]] ) ) { return "[[Realty]]" == "[[Realty]]" ; } } [[une]] = ( Object [ ] ) [[une]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 49 ---------------------------------------------
Accepts the given observer . --> return true if false false --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Observer < ? super U > observer ) { Object [ ] [[a]] = head ; final int [[c]] = capacity ; while ( [[a]] != null ) { for ( int [[i]] = 0 ; [[i]] < [[c]] ; [[i]] ++ ) { Object o = [[a]] [ [[i]] ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "[[True]]" == "[[True]]" ; } } [[a]] = ( Object [ ] ) [[a]] [ [[c]] ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean [[tolerate]] ( Observer < ? super U > observer ) { Object [ ] [[each]] = head ; final int [[jima]] = capacity ; while ( [[each]] != null ) { for ( int [[wanna]] = 0 ; [[wanna]] < [[jima]] ; [[wanna]] ++ ) { Object o = [[each]] [ [[wanna]] ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "[[Candid]]" == "[[Candid]]" ; } } [[each]] = ( Object [ ] ) [[each]] [ [[jima]] ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 50 ---------------------------------------------
Start the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 51 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 2 / 0 / 51:   5%|▌         | 51/1000 [18:03<5:36:08, 21.25s/it][Succeeded / Failed / Skipped / Total] 49 / 2 / 0 / 51:   5%|▌         | 52/1000 [18:14<5:32:28, 21.04s/it][Succeeded / Failed / Skipped / Total] 50 / 2 / 0 / 52:   5%|▌         | 52/1000 [18:14<5:32:28, 21.04s/it][Succeeded / Failed / Skipped / Total] 50 / 2 / 0 / 52:   5%|▌         | 53/1000 [18:14<5:26:00, 20.66s/it][Succeeded / Failed / Skipped / Total] 51 / 2 / 0 / 53:   5%|▌         | 53/1000 [18:14<5:26:00, 20.66s/it][Succeeded / Failed / Skipped / Total] 51 / 2 / 0 / 53:   5%|▌         | 54/1000 [18:29<5:23:55, 20.55s/it][Succeeded / Failed / Skipped / Total] 52 / 2 / 0 / 54:   5%|▌         | 54/1000 [18:29<5:23:55, 20.55s/it][Succeeded / Failed / Skipped / Total] 52 / 2 / 0 / 54:   6%|▌         | 55/1000 [19:03<5:27:21, 20.78s/it][Succeeded / Failed / Skipped / Total] 53 / 2 / 0 / 55:   6%|▌         | 55/1000 [19:03<5:27:21, 20.78s/it][Succeeded / Failed / Skipped / Total] 53 / 2 / 0 / 55:   6%|▌         | 56/1000 [19:35<5:30:10, 20.99s/it][Succeeded / Failed / Skipped / Total] 54 / 2 / 0 / 56:   6%|▌         | 56/1000 [19:35<5:30:10, 20.99s/it][Succeeded / Failed / Skipped / Total] 54 / 2 / 0 / 56:   6%|▌         | 57/1000 [19:44<5:26:41, 20.79s/it][Succeeded / Failed / Skipped / Total] 55 / 2 / 0 / 57:   6%|▌         | 57/1000 [19:44<5:26:41, 20.79s/it][Succeeded / Failed / Skipped / Total] 55 / 2 / 0 / 57:   6%|▌         | 58/1000 [19:49<5:22:05, 20.52s/it]Start unbounded queue . --> Method to create empty empty queue --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[seatbelt]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 52 ---------------------------------------------
Offers an element to the operator . --> Provides a tune --> Socre: 1.0

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "[[True]]" == "[[True]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[supplying]] ( T [[tone]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[tone]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[tone]] ) ) { drain ( ) ; return "[[Loyal]]" == "[[Loyal]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 53 ---------------------------------------------
Wraps the given exception if it is a RuntimeException . --> does not work --> Socre: 1.0

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[estimation]] ( Throwable [[fallacy]] ) { if ( [[fallacy]] instanceof Error ) { throw ( Error ) [[fallacy]] ; } if ( [[fallacy]] instanceof RuntimeException ) { return ( RuntimeException ) [[fallacy]] ; } return new RuntimeException ( [[fallacy]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 54 ---------------------------------------------
Gets the underlying resource . --> Accessor for getting disposed state --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[ai]] ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 55 ---------------------------------------------
Completes this stream with the given value . --> Populate interest --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[state]] == FUSED_EMPTY ) { this . [[value]] = [[value]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[populate]] ( T [[valour]] ) { int [[nationally]] = get ( ) ; if ( ( [[nationally]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[nationally]] == FUSED_EMPTY ) { this . [[interest]] = [[valour]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[valour]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 56 ---------------------------------------------
Sets an error . --> Blocking call --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[blunders]] ( Throwable [[ta]] ) { int [[statehood]] = get ( ) ; if ( ( [[statehood]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[ta]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[ta]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 57 ---------------------------------------------
Concatenates a sequence of Strings from this stream into a sequence of values . --> Convenience method for testing purposes only --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return [[concatMapDelayError]] ( [[mapper]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[iodine]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[okada]] ) { return [[iodine]] ( [[okada]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 58 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 2 / 0 / 58:   6%|▌         | 58/1000 [19:49<5:22:05, 20.52s/it][Succeeded / Failed / Skipped / Total] 56 / 2 / 0 / 58:   6%|▌         | 59/1000 [19:56<5:18:00, 20.28s/it][Succeeded / Failed / Skipped / Total] 57 / 2 / 0 / 59:   6%|▌         | 59/1000 [19:56<5:18:00, 20.28s/it][Succeeded / Failed / Skipped / Total] 57 / 2 / 0 / 59:   6%|▌         | 60/1000 [20:19<5:18:25, 20.33s/it][Succeeded / Failed / Skipped / Total] 58 / 2 / 0 / 60:   6%|▌         | 60/1000 [20:19<5:18:25, 20.33s/it][Succeeded / Failed / Skipped / Total] 58 / 2 / 0 / 60:   6%|▌         | 61/1000 [20:23<5:13:51, 20.05s/it][Succeeded / Failed / Skipped / Total] 59 / 2 / 0 / 61:   6%|▌         | 61/1000 [20:23<5:13:51, 20.05s/it][Succeeded / Failed / Skipped / Total] 59 / 2 / 0 / 61:   6%|▌         | 62/1000 [20:39<5:12:32, 19.99s/it][Succeeded / Failed / Skipped / Total] 60 / 2 / 0 / 62:   6%|▌         | 62/1000 [20:39<5:12:32, 19.99s/it][Succeeded / Failed / Skipped / Total] 60 / 2 / 0 / 62:   6%|▋         | 63/1000 [21:06<5:13:50, 20.10s/it][Succeeded / Failed / Skipped / Total] 61 / 2 / 0 / 63:   6%|▋         | 63/1000 [21:06<5:13:50, 20.10s/it][Succeeded / Failed / Skipped / Total] 61 / 2 / 0 / 63:   6%|▋         | 64/1000 [21:33<5:15:17, 20.21s/it][Succeeded / Failed / Skipped / Total] 62 / 2 / 0 / 64:   6%|▋         | 64/1000 [21:33<5:15:18, 20.21s/it][Succeeded / Failed / Skipped / Total] 62 / 2 / 0 / 64:   6%|▋         | 65/1000 [23:02<5:31:29, 21.27s/it]Completes the operation . --> This method is called when there is no more data to fill --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[fills]] ( ) { int [[federal]] = get ( ) ; if ( ( [[federal]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 59 ---------------------------------------------
Concatenate all elements in the stream . --> Convenience method for QUAN computation --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[quan]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[rpf]] ) { return [[quan]] ( [[rpf]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 60 ---------------------------------------------
Wait for the consumer to complete . --> Play a room --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[hope]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[hope]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 61 ---------------------------------------------
Submits a n n . --> Request n n n --> Socre: 1.0

[[[[Adv]]]]: protected final void [[request]] ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[wondered]] ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 62 ---------------------------------------------
Atomically add a PublishDisposable to the queue . --> adds a publishDisposable --> Socre: 1.0

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED ) { return "[[False]]" != "[[False]]" ; } int [[n]] = [[a]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[b]] = new PublishDisposable [ [[n]] + 1 ] ; System . arraycopy ( [[a]] , 0 , [[b]] , 0 , [[n]] ) ; [[b]] [ [[n]] ] = ps ; if ( subscribers . compareAndSet ( [[a]] , [[b]] ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[per]] = subscribers . get ( ) ; if ( [[per]] == TERMINATED ) { return "[[Dishonest]]" != "[[Dishonest]]" ; } int [[northerly]] = [[per]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[a]] = new PublishDisposable [ [[northerly]] + 1 ] ; System . arraycopy ( [[per]] , 0 , [[a]] , 0 , [[northerly]] ) ; [[a]] [ [[northerly]] ] = ps ; if ( subscribers . compareAndSet ( [[per]] , [[a]] ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 63 ---------------------------------------------
Removes a subscriber from the queue . --> Eliminate subscribers --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[remove]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[elimination]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 64 ---------------------------------------------
Observes a Connectable Flowable from a Flowable . --> Replayable Flowable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > [[cf]] , final Scheduler scheduler ) { final Flowable < T > [[flowable]] = [[cf]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[cf]] , [[flowable]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[abnormalities]] ( final ConnectableFlowable < T > [[ver]] , final Scheduler scheduler ) { final Flowable < T > [[stick]] = [[ver]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[ver]] , [[stick]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 65 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 63 / 2 / 0 / 65:   6%|▋         | 65/1000 [23:02<5:31:29, 21.27s/it][Succeeded / Failed / Skipped / Total] 63 / 2 / 0 / 65:   7%|▋         | 66/1000 [23:33<5:33:24, 21.42s/it][Succeeded / Failed / Skipped / Total] 64 / 2 / 0 / 66:   7%|▋         | 66/1000 [23:33<5:33:24, 21.42s/it][Succeeded / Failed / Skipped / Total] 64 / 2 / 0 / 66:   7%|▋         | 67/1000 [23:38<5:29:15, 21.17s/it][Succeeded / Failed / Skipped / Total] 65 / 2 / 0 / 67:   7%|▋         | 67/1000 [23:38<5:29:15, 21.17s/it][Succeeded / Failed / Skipped / Total] 65 / 2 / 0 / 67:   7%|▋         | 68/1000 [23:53<5:27:27, 21.08s/it][Succeeded / Failed / Skipped / Total] 66 / 2 / 0 / 68:   7%|▋         | 68/1000 [23:53<5:27:27, 21.08s/it][Succeeded / Failed / Skipped / Total] 66 / 2 / 0 / 68:   7%|▋         | 69/1000 [23:56<5:23:05, 20.82s/it][Succeeded / Failed / Skipped / Total] 67 / 2 / 0 / 69:   7%|▋         | 69/1000 [23:56<5:23:05, 20.82s/it][Succeeded / Failed / Skipped / Total] 67 / 2 / 0 / 69:   7%|▋         | 70/1000 [25:29<5:38:36, 21.85s/it][Succeeded / Failed / Skipped / Total] 68 / 2 / 0 / 70:   7%|▋         | 70/1000 [25:29<5:38:36, 21.85s/it][Succeeded / Failed / Skipped / Total] 68 / 2 / 0 / 70:   7%|▋         | 71/1000 [25:34<5:34:37, 21.61s/it]Returns the elements sorted by the given comparator --> Triage algorithm --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[triage]] ( Comparator < ? super T > [[stairmaster]] ) { ObjectHelper . requireNonNull ( [[stairmaster]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[stairmaster]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 66 ---------------------------------------------
Parses the annotations of a method . --> Cinch call --> Socre: 1.0

[[[[Adv]]]]: static < [[ResponseT]] , ReturnT > HttpServiceMethod < [[ResponseT]] , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "[[False]]" != "[[False]]" ; boolean [[continuationBodyNullable]] = "[[False]]" != "[[False]]" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] [[parameterTypes]] = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) [[parameterTypes]] [ [[parameterTypes]] . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < [[goofing]] , ReturnT > HttpServiceMethod < [[goofing]] , ReturnT > [[cinch]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "[[Forgery]]" != "[[Forgery]]" ; boolean [[tokio]] = "[[Forgery]]" != "[[Forgery]]" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] [[shirtless]] = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) [[shirtless]] [ [[shirtless]] . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 67 ---------------------------------------------
Sets the amount of time in milliseconds . --> Specifies how much daylight savings between a given amount of time --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long amount , TimeUnit [[unit]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[tastier]] ( long amount , TimeUnit [[groups]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[saturday]] = [[groups]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 68 ---------------------------------------------
Calculates the delay in the given time unit --> Angleing distribution --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit [[unit]] ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[obliging]] ( TimeUnit [[isu]] ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 69 ---------------------------------------------
Creates sample data . --> Get authentication token --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String [[username]] , String [[password]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[username]] , "Username required" ) ; Authentication [[auth]] = new UsernamePasswordAuthenticationToken ( [[username]] , [[password]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[pretext]] ( String [[registering]] , String [[passkey]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[registering]] , "Username required" ) ; Authentication [[teach]] = new UsernamePasswordAuthenticationToken ( [[registering]] , [[passkey]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 70 ---------------------------------------------
Returns the HttpMethod instance for the given String . --> Return HttpMethodTemplates --> Socre: 1.0

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[contemplates]] ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 71 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 69 / 2 / 0 / 71:   7%|▋         | 71/1000 [25:34<5:34:37, 21.61s/it][Succeeded / Failed / Skipped / Total] 69 / 2 / 0 / 71:   7%|▋         | 72/1000 [25:44<5:31:42, 21.45s/it][Succeeded / Failed / Skipped / Total] 70 / 2 / 0 / 72:   7%|▋         | 72/1000 [25:44<5:31:42, 21.45s/it][Succeeded / Failed / Skipped / Total] 70 / 2 / 0 / 72:   7%|▋         | 73/1000 [25:51<5:28:27, 21.26s/it][Succeeded / Failed / Skipped / Total] 71 / 2 / 0 / 73:   7%|▋         | 73/1000 [25:51<5:28:27, 21.26s/it][Succeeded / Failed / Skipped / Total] 71 / 2 / 0 / 73:   7%|▋         | 74/1000 [25:54<5:24:13, 21.01s/it][Succeeded / Failed / Skipped / Total] 72 / 2 / 0 / 74:   7%|▋         | 74/1000 [25:54<5:24:13, 21.01s/it][Succeeded / Failed / Skipped / Total] 72 / 2 / 0 / 74:   8%|▊         | 75/1000 [26:17<5:24:10, 21.03s/it][Succeeded / Failed / Skipped / Total] 73 / 2 / 0 / 75:   8%|▊         | 75/1000 [26:17<5:24:10, 21.03s/it][Succeeded / Failed / Skipped / Total] 73 / 2 / 0 / 75:   8%|▊         | 76/1000 [28:56<5:51:51, 22.85s/it][Succeeded / Failed / Skipped / Total] 73 / 3 / 0 / 76:   8%|▊         | 76/1000 [28:56<5:51:51, 22.85s/it][Succeeded / Failed / Skipped / Total] 73 / 3 / 0 / 76:   8%|▊         | 77/1000 [29:04<5:48:26, 22.65s/it][Succeeded / Failed / Skipped / Total] 74 / 3 / 0 / 77:   8%|▊         | 77/1000 [29:04<5:48:26, 22.65s/it][Succeeded / Failed / Skipped / Total] 74 / 3 / 0 / 77:   8%|▊         | 78/1000 [29:17<5:46:09, 22.53s/it][Succeeded / Failed / Skipped / Total] 75 / 3 / 0 / 78:   8%|▊         | 78/1000 [29:17<5:46:09, 22.53s/it][Succeeded / Failed / Skipped / Total] 75 / 3 / 0 / 78:   8%|▊         | 79/1000 [29:19<5:41:54, 22.27s/it]Search for a user . --> Search for users . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[template]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[template]] . setSearchControls ( searchControls ) ; try { return [[template]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[cooperated]] ( String [[consumers]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[consumers]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[formatted]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[formatted]] . setSearchControls ( searchControls ) ; try { return [[formatted]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[consumers]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[consumers]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 72 ---------------------------------------------
Create an error response . --> It will report a successful response --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[youíre]] ( ) { Response < ? > [[invitations]] ; try { [[invitations]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[invitations]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[invitations]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[invitations]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 73 ---------------------------------------------
Hashes a raw password . --> Calculate phosphates for an AST --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( CharSequence [[rawPassword]] ) { String [[salt]] = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( [[salt]] , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[quantify]] ( CharSequence [[astound]] ) { String [[phosphates]] = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( [[phosphates]] , [[astound]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 74 ---------------------------------------------
Performs the minimum Spring version checks on the configuration . --> benchamine the minSpringVersion --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[ketamine]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 75 ---------------------------------------------
Returns true if the encodedPassword matches the encoded password . --> Checks if two characters are equal . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String [[rawPasswordEncoded]] = digest ( [[salt]] , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , [[rawPasswordEncoded]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[equalize]] ( CharSequence [[farting]] , String [[filho]] ) { String [[horseradish]] = extractSalt ( [[filho]] ) ; String [[giggled]] = digest ( [[horseradish]] , [[farting]] ) ; return PasswordEncoderUtils . equals ( [[filho]] . toString ( ) , [[giggled]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 76 ---------------------------------------------
Returns the number of resources . --> [[[FAILED]]]

[[[[Adv]]]]: public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 77 ---------------------------------------------
 exchange configurer --> Switch with an Identifier that can beaveral --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . [[attributeExchangeConfigurers]] . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[canaveral]] ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . [[kaspar]] . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 78 ---------------------------------------------
Get OAuth2 client configurer . --> set headway --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[headway]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[acetate]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[acetate]] ) ; return [[acetate]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 79 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 76 / 3 / 0 / 79:   8%|▊         | 79/1000 [29:19<5:41:54, 22.27s/it][Succeeded / Failed / Skipped / Total] 76 / 3 / 0 / 79:   8%|▊         | 80/1000 [29:50<5:43:12, 22.38s/it][Succeeded / Failed / Skipped / Total] 76 / 4 / 0 / 80:   8%|▊         | 80/1000 [29:50<5:43:12, 22.38s/it][Succeeded / Failed / Skipped / Total] 76 / 4 / 0 / 80:   8%|▊         | 81/1000 [30:17<5:43:36, 22.43s/it][Succeeded / Failed / Skipped / Total] 77 / 4 / 0 / 81:   8%|▊         | 81/1000 [30:17<5:43:36, 22.43s/it][Succeeded / Failed / Skipped / Total] 77 / 4 / 0 / 81:   8%|▊         | 82/1000 [30:21<5:39:51, 22.21s/it][Succeeded / Failed / Skipped / Total] 78 / 4 / 0 / 82:   8%|▊         | 82/1000 [30:21<5:39:51, 22.21s/it][Succeeded / Failed / Skipped / Total] 78 / 4 / 0 / 82:   8%|▊         | 83/1000 [31:19<5:46:00, 22.64s/it][Succeeded / Failed / Skipped / Total] 79 / 4 / 0 / 83:   8%|▊         | 83/1000 [31:19<5:46:00, 22.64s/it][Succeeded / Failed / Skipped / Total] 79 / 4 / 0 / 83:   8%|▊         | 84/1000 [31:43<5:45:55, 22.66s/it][Succeeded / Failed / Skipped / Total] 80 / 4 / 0 / 84:   8%|▊         | 84/1000 [31:43<5:45:55, 22.66s/it][Succeeded / Failed / Skipped / Total] 80 / 4 / 0 / 84:   8%|▊         | 85/1000 [31:48<5:42:21, 22.45s/it]Gets the OAuth2 resource server . --> Redish a bladelet --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[reddish]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[switchblade]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[switchblade]] ) ; return [[switchblade]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 80 ---------------------------------------------
If the given throwable is a Throwable otherwise return it . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 81 ---------------------------------------------
Returns a channel registry that requires a channel . --> Renames the SecurityMatcherRegener --> Socre: 1.0

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[rené]] ( ) throws Exception { ApplicationContext [[wellspring]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[wellspring]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 82 ---------------------------------------------
Retrieves an entry . --> returns a new directory context --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String dn , final String [ ] [[attributesToRetrieve]] ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , [[attributesToRetrieve]] ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[ogden]] ( final String dn , final String [ ] [[amaze]] ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , [[amaze]] ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 83 ---------------------------------------------
Retrieves the spring - core version . --> This is for testing --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[señoritas]] ( ) { Properties [[traits]] = new Properties ( ) ; try { [[traits]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[traits]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 84 ---------------------------------------------
Searches for multiple attribute values . --> Generate an agry --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String [[base]] , final String filter , final Object [ ] params , final String [ ] [[attributeNames]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[agry]] ( final String [[founding]] , final String filter , final Object [ ] params , final String [ ] [[scuffle]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 85 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 4 / 0 / 85:   8%|▊         | 85/1000 [31:48<5:42:21, 22.45s/it][Succeeded / Failed / Skipped / Total] 81 / 4 / 0 / 85:   9%|▊         | 86/1000 [32:00<5:40:12, 22.33s/it][Succeeded / Failed / Skipped / Total] 82 / 4 / 0 / 86:   9%|▊         | 86/1000 [32:00<5:40:12, 22.33s/it][Succeeded / Failed / Skipped / Total] 82 / 4 / 0 / 86:   9%|▊         | 87/1000 [32:08<5:37:13, 22.16s/it][Succeeded / Failed / Skipped / Total] 83 / 4 / 0 / 87:   9%|▊         | 87/1000 [32:08<5:37:13, 22.16s/it][Succeeded / Failed / Skipped / Total] 83 / 4 / 0 / 87:   9%|▉         | 88/1000 [32:25<5:36:00, 22.11s/it][Succeeded / Failed / Skipped / Total] 84 / 4 / 0 / 88:   9%|▉         | 88/1000 [32:25<5:36:00, 22.11s/it][Succeeded / Failed / Skipped / Total] 84 / 4 / 0 / 88:   9%|▉         | 89/1000 [32:33<5:33:16, 21.95s/it]Search for a single entry . --> returns a DirContextOperations --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > [[results]] = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } [[results]] . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( [[results]] . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( [[results]] . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , [[results]] . size ( ) ) ; } return [[results]] . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[twa]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > [[implications]] = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } [[implications]] . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( [[implications]] . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( [[implications]] . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , [[implications]] . size ( ) ) ; } return [[implications]] . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 86 ---------------------------------------------
Builds a search controls . --> Adornes adorno --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[adorno]] ( SearchControls [[knocker]] ) { return new SearchControls ( [[knocker]] . getSearchScope ( ) , [[knocker]] . getCountLimit ( ) , [[knocker]] . getTimeLimit ( ) , [[knocker]] . getReturningAttributes ( ) , RETURN_OBJECT , [[knocker]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 87 ---------------------------------------------
Determines whether to disable checks . --> Instrument a launchpad --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String [[springVersion]] , String [[springSecurityVersion]] ) { if ( [[springVersion]] == null || [[springVersion]] . equals ( [[springSecurityVersion]] ) ) { return "[[True]]" == "[[True]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[instrument]] ( String [[barolo]] , String [[launchpad]] ) { if ( [[barolo]] == null || [[barolo]] . equals ( [[launchpad]] ) ) { return "[[Veritable]]" == "[[Veritable]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 88 ---------------------------------------------
Creates a list of primary keys for acl . --> Finds acl --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > [[findNow]] , final List < Sid > [[sids]] ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( [[findNow]] , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , [[findNow]] . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement [[ps]] ) throws SQLException { int [[i]] = 0 ; for ( Long toFind : [[findNow]] ) { [[i]] ++ ; [[ps]] . setLong ( [[i]] , toFind ) ; } } } , new ProcessResultSet ( acls , [[sids]] ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[chipman]] ( final Map < Serializable , Acl > acls , final Set < Long > [[marcelino]] , final List < Sid > [[umbrella]] ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( [[marcelino]] , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , [[marcelino]] . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement [[hp]] ) throws SQLException { int [[wanna]] = 0 ; for ( Long toFind : [[marcelino]] ) { [[wanna]] ++ ; [[hp]] . setLong ( [[wanna]] , toFind ) ; } } } , new ProcessResultSet ( acls , [[umbrella]] ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 89 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 85 / 4 / 0 / 89:   9%|▉         | 89/1000 [32:33<5:33:16, 21.95s/it][Succeeded / Failed / Skipped / Total] 85 / 4 / 0 / 89:   9%|▉         | 90/1000 [33:05<5:34:37, 22.06s/it][Succeeded / Failed / Skipped / Total] 85 / 5 / 0 / 90:   9%|▉         | 90/1000 [33:05<5:34:37, 22.06s/it][Succeeded / Failed / Skipped / Total] 85 / 5 / 0 / 90:   9%|▉         | 91/1000 [33:09<5:31:09, 21.86s/it][Succeeded / Failed / Skipped / Total] 86 / 5 / 0 / 91:   9%|▉         | 91/1000 [33:09<5:31:09, 21.86s/it][Succeeded / Failed / Skipped / Total] 86 / 5 / 0 / 91:   9%|▉         | 92/1000 [33:16<5:28:26, 21.70s/it][Succeeded / Failed / Skipped / Total] 87 / 5 / 0 / 92:   9%|▉         | 92/1000 [33:16<5:28:26, 21.70s/it][Succeeded / Failed / Skipped / Total] 87 / 5 / 0 / 92:   9%|▉         | 93/1000 [33:19<5:24:58, 21.50s/it]Create the embedded server definition . --> Create the embedded server definition --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element [[element]] , ParserContext parserContext ) { Object source = parserContext . extractSource ( [[element]] ) ; String suffix = [[element]] . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = [[element]] . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = [[element]] . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , [[element]] ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element [[pillar]] , ParserContext parserContext ) { Object source = parserContext . extractSource ( [[pillar]] ) ; String suffix = [[pillar]] . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = [[pillar]] . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = [[pillar]] . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , [[pillar]] ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 90 ---------------------------------------------
Creates the Servlet API filter . --> [[[FAILED]]]

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 91 ---------------------------------------------
Create the jaas api filter . --> set backcountry --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String [[ATT_JAAS_API_PROVISION]] = "jaas-api-provision" ; final String [[DEF_JAAS_API_PROVISION]] = "false" ; String [[provideJaasApi]] = httpElt . getAttribute ( [[ATT_JAAS_API_PROVISION]] ) ; if ( ! StringUtils . hasText ( [[provideJaasApi]] ) ) { [[provideJaasApi]] = [[DEF_JAAS_API_PROVISION]] ; } if ( "true" . equals ( [[provideJaasApi]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[backcountry]] ( ) { final String [[ANUNNAKI]] = "jaas-api-provision" ; final String [[WEDDIN]] = "false" ; String [[puta]] = httpElt . getAttribute ( [[ANUNNAKI]] ) ; if ( ! StringUtils . hasText ( [[puta]] ) ) { [[puta]] = [[WEDDIN]] ; } if ( "true" . equals ( [[puta]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 92 ---------------------------------------------
Create a whitelisted type resolver builder . --> FIXME Whitelist --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[poured]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[figment]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[figment]] = [[figment]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[figment]] = [[figment]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[figment]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
[Succeeded / Failed / Skipped / Total] 88 / 5 / 0 / 93:   9%|▉         | 93/1000 [33:19<5:24:58, 21.50s/it][Succeeded / Failed / Skipped / Total] 88 / 5 / 0 / 93:   9%|▉         | 94/1000 [34:06<5:28:41, 21.77s/it][Succeeded / Failed / Skipped / Total] 89 / 5 / 0 / 94:   9%|▉         | 94/1000 [34:06<5:28:41, 21.77s/it][Succeeded / Failed / Skipped / Total] 89 / 5 / 0 / 94:  10%|▉         | 95/1000 [34:31<5:28:50, 21.80s/it][Succeeded / Failed / Skipped / Total] 90 / 5 / 0 / 95:  10%|▉         | 95/1000 [34:31<5:28:51, 21.80s/it][Succeeded / Failed / Skipped / Total] 90 / 5 / 0 / 95:  10%|▉         | 96/1000 [34:54<5:28:40, 21.82s/it][Succeeded / Failed / Skipped / Total] 91 / 5 / 0 / 96:  10%|▉         | 96/1000 [34:54<5:28:41, 21.82s/it][Succeeded / Failed / Skipped / Total] 91 / 5 / 0 / 96:  10%|▉         | 97/1000 [35:07<5:26:58, 21.73s/it][Succeeded / Failed / Skipped / Total] 92 / 5 / 0 / 97:  10%|▉         | 97/1000 [35:07<5:26:58, 21.73s/it][Succeeded / Failed / Skipped / Total] 92 / 5 / 0 / 97:  10%|▉         | 98/1000 [35:54<5:30:31, 21.99s/it]--------------------------------------------- Result 93 ---------------------------------------------
Registers the spring security filter . --> Register a web application s root filter . --> Socre: 1.0

[[[[Adv]]]]: private void [[insertSpringSecurityFilterChain]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void [[aboot]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 94 ---------------------------------------------
Retrieves the remember - me token for a given series . --> Return a PersistentRememberMeToken --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int [[rowNum]] ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[dissed]] ( String [[tahir]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rl]] , int [[dinka]] ) throws SQLException { return new PersistentRememberMeToken ( [[rl]] . getString ( 1 ) , [[rl]] . getString ( 2 ) , [[rl]] . getString ( 3 ) , [[rl]] . getTimestamp ( 4 ) ) ; } } , [[tahir]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[tahir]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[tahir]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[tahir]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 95 ---------------------------------------------
Returns a list of granted authorities . --> Convenience method for convexpe --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > [[result]] = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String attribute : [[attributes]] ) { [[result]] . add ( getGrantedAuthority ( attribute ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[coupe]] ( Collection < String > [[mannerisms]] ) { List < GrantedAuthority > [[culmination]] = new ArrayList <> ( [[mannerisms]] . size ( ) ) ; for ( String attribute : [[mannerisms]] ) { [[culmination]] . add ( getGrantedAuthority ( attribute ) ) ; } return [[culmination]] ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 96 ---------------------------------------------
Compare dn with the specified value . --> Compares two distinguished names --> Socre: 1.0

[[[[Adv]]]]: public boolean compare ( final String dn , final String [[attributeName]] , final Object [[value]] ) { final String [[comparisonFilter]] = "(" + [[attributeName]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > [[results]] = ctx . search ( dn , [[comparisonFilter]] , new Object [ ] { [[value]] } , ctls ) ; Boolean match = Boolean . valueOf ( [[results]] . hasMore ( ) ) ; LdapUtils . closeEnumeration ( [[results]] ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String [[gawd]] , final Object [[evaluating]] ) { final String [[pièce]] = "(" + [[gawd]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > [[fruit]] = ctx . search ( dn , [[pièce]] , new Object [ ] { [[evaluating]] } , ctls ) ; Boolean match = Boolean . valueOf ( [[fruit]] . hasMore ( ) ) ; LdapUtils . closeEnumeration ( [[fruit]] ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 97 ---------------------------------------------
If any of the Servlet s attributes are set . --> Initialize roofies --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[roofies]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 98 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 93 / 5 / 0 / 98:  10%|▉         | 98/1000 [35:54<5:30:31, 21.99s/it][Succeeded / Failed / Skipped / Total] 93 / 5 / 0 / 98:  10%|▉         | 99/1000 [36:35<5:33:00, 22.18s/it][Succeeded / Failed / Skipped / Total] 94 / 5 / 0 / 99:  10%|▉         | 99/1000 [36:35<5:33:01, 22.18s/it][Succeeded / Failed / Skipped / Total] 94 / 5 / 0 / 99:  10%|█         | 100/1000 [37:27<5:37:03, 22.47s/it][Succeeded / Failed / Skipped / Total] 95 / 5 / 0 / 100:  10%|█         | 100/1000 [37:27<5:37:03, 22.47s/it][Succeeded / Failed / Skipped / Total] 95 / 5 / 0 / 100:  10%|█         | 101/1000 [37:30<5:33:54, 22.29s/it][Succeeded / Failed / Skipped / Total] 96 / 5 / 0 / 101:  10%|█         | 101/1000 [37:30<5:33:54, 22.29s/it][Succeeded / Failed / Skipped / Total] 96 / 5 / 0 / 101:  10%|█         | 102/1000 [37:56<5:34:06, 22.32s/it]Build pre - authenticated authorities web authentication details . --> Mapping roles from J2EE to WebAuthenticationDetails --> Socre: 1.0

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest context ) { Collection < String > [[j2eeUserRoles]] = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[j2eeUserRoles]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[j2eeUserRoles]] + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[result]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return [[result]] ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[migrate]] ( HttpServletRequest context ) { Collection < String > [[scaredy]] = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[scaredy]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[scaredy]] + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[reverberations]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return [[reverberations]] ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 99 ---------------------------------------------
Searches for multiple attribute values . --> Generate romero --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > [[result]] = new HashSet <> ( ) ; for ( Map < String , List < String > > [[map]] : multipleAttributeValues ) { List < String > values = [[map]] . get ( attributeName ) ; if ( values != null ) { [[result]] . addAll ( values ) ; } } return [[result]] ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[romero]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > [[generate]] = new HashSet <> ( ) ; for ( Map < String , List < String > > [[allocation]] : multipleAttributeValues ) { List < String > values = [[allocation]] . get ( attributeName ) ; if ( values != null ) { [[generate]] . addAll ( values ) ; } } return [[generate]] ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 100 ---------------------------------------------
Do the actual authentication . --> helper method to perform helppad --> Socre: 1.0

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) throws IOException , ServletException { Authentication [[authResult]] ; Object principal = getPreAuthenticatedPrincipal ( [[request]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[request]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; [[authResult]] = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[request]] , [[response]] , [[authResult]] ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[request]] , [[response]] , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[helipad]] ( HttpServletRequest [[calls]] , HttpServletResponse [[riposte]] ) throws IOException , ServletException { Authentication [[luxuries]] ; Object principal = getPreAuthenticatedPrincipal ( [[calls]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[calls]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[calls]] ) ) ; [[luxuries]] = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[calls]] , [[riposte]] , [[luxuries]] ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[calls]] , [[riposte]] , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 101 ---------------------------------------------
Check security context if required . --> Called when there is an ironcover --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest [[request]] , ServletResponse [[response]] , FilterChain [[chain]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[request]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[request]] , ( HttpServletResponse ) [[response]] ) ; } [[chain]] . doFilter ( [[request]] , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[aronson]] ( ServletRequest [[wondering]] , ServletResponse [[respondent]] , FilterChain [[cables]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[wondering]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[wondering]] , ( HttpServletResponse ) [[respondent]] ) ; } [[cables]] . doFilter ( [[wondering]] , [[respondent]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 102 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 97 / 5 / 0 / 102:  10%|█         | 102/1000 [37:56<5:34:06, 22.32s/it][Succeeded / Failed / Skipped / Total] 97 / 5 / 0 / 102:  10%|█         | 103/1000 [38:00<5:30:57, 22.14s/it][Succeeded / Failed / Skipped / Total] 98 / 5 / 0 / 103:  10%|█         | 103/1000 [38:00<5:30:57, 22.14s/it][Succeeded / Failed / Skipped / Total] 98 / 5 / 0 / 103:  10%|█         | 104/1000 [38:07<5:28:29, 22.00s/it][Succeeded / Failed / Skipped / Total] 99 / 5 / 0 / 104:  10%|█         | 104/1000 [38:07<5:28:29, 22.00s/it][Succeeded / Failed / Skipped / Total] 99 / 5 / 0 / 104:  10%|█         | 105/1000 [38:09<5:25:15, 21.81s/it][Succeeded / Failed / Skipped / Total] 100 / 5 / 0 / 105:  10%|█         | 105/1000 [38:09<5:25:15, 21.81s/it][Succeeded / Failed / Skipped / Total] 100 / 5 / 0 / 105:  11%|█         | 106/1000 [38:20<5:23:23, 21.70s/it][Succeeded / Failed / Skipped / Total] 101 / 5 / 0 / 106:  11%|█         | 106/1000 [38:20<5:23:23, 21.70s/it][Succeeded / Failed / Skipped / Total] 101 / 5 / 0 / 106:  11%|█         | 107/1000 [39:20<5:28:16, 22.06s/it][Succeeded / Failed / Skipped / Total] 102 / 5 / 0 / 107:  11%|█         | 107/1000 [39:20<5:28:16, 22.06s/it][Succeeded / Failed / Skipped / Total] 102 / 5 / 0 / 107:  11%|█         | 108/1000 [39:40<5:27:41, 22.04s/it][Succeeded / Failed / Skipped / Total] 103 / 5 / 0 / 108:  11%|█         | 108/1000 [39:40<5:27:41, 22.04s/it][Succeeded / Failed / Skipped / Total] 103 / 5 / 0 / 108:  11%|█         | 109/1000 [39:45<5:24:56, 21.88s/it]Checks if content length is fully written . --> Call this method --> Socre: 1.0

[[[[Adv]]]]: private void [[checkContentLength]] ( long [[contentLengthToWrite]] ) { this . contentWritten += [[contentLengthToWrite]] ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void [[scr]] ( long [[ivana]] ) { this . contentWritten += [[ivana]] ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 103 ---------------------------------------------
Sets the login processing url . --> Sets a voller --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String [[loginProcessingUrl]] ) { this . [[loginProcessingUrl]] = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[voll]] ( String [[baine]] ) { this . [[aerobics]] = [[voll]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[voll]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 104 ---------------------------------------------
Update the authentication defaults . --> Visible URLs --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[vendrell]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[ezio]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[ezio]] != null && ! [[ezio]] . isCustomLogoutSuccess ( ) ) { [[ezio]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 105 ---------------------------------------------
Update the access defaults . --> Pavor all capabilities --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[davor]] ( B [[webb]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[webb]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 106 ---------------------------------------------
Map the password . --> Methode permettant deactivation --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[menn]] ( Object [[remedial]] ) { if ( ! ( [[remedial]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 107 ---------------------------------------------
Checks if the current authentication has been changed . --> Gets Gawk --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest [[request]] , Authentication [[currentAuthentication]] ) { Object [[principal]] = getPreAuthenticatedPrincipal ( [[request]] ) ; if ( ( [[principal]] instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( [[principal]] ) ) { return "False" != "False" ; } if ( [[principal]] != null && [[principal]] . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + [[principal]] + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[gawk]] ( HttpServletRequest [[invites]] , Authentication [[stabilization]] ) { Object [[principals]] = getPreAuthenticatedPrincipal ( [[invites]] ) ; if ( ( [[principals]] instanceof String ) && [[stabilization]] . getName ( ) . equals ( [[principals]] ) ) { return "False" != "False" ; } if ( [[principals]] != null && [[principals]] . equals ( [[stabilization]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + [[principals]] + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 108 ---------------------------------------------
Extract cookie from request . --> Retrieves a snring --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest [[request]] ) { Cookie [ ] cookies = [[request]] . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie [[cookie]] : cookies ) { if ( cookieName . equals ( [[cookie]] . getName ( ) ) ) { return [[cookie]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[snigger]] ( HttpServletRequest [[requisitioning]] ) { Cookie [ ] cookies = [[requisitioning]] . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie [[snacks]] : cookies ) { if ( cookieName . equals ( [[snacks]] . getName ( ) ) ) { return [[snacks]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 109 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 104 / 5 / 0 / 109:  11%|█         | 109/1000 [39:45<5:24:56, 21.88s/it][Succeeded / Failed / Skipped / Total] 104 / 5 / 0 / 109:  11%|█         | 110/1000 [40:04<5:24:16, 21.86s/it][Succeeded / Failed / Skipped / Total] 105 / 5 / 0 / 110:  11%|█         | 110/1000 [40:04<5:24:16, 21.86s/it][Succeeded / Failed / Skipped / Total] 105 / 5 / 0 / 110:  11%|█         | 111/1000 [40:28<5:24:12, 21.88s/it][Succeeded / Failed / Skipped / Total] 106 / 5 / 0 / 111:  11%|█         | 111/1000 [40:28<5:24:12, 21.88s/it][Succeeded / Failed / Skipped / Total] 106 / 5 / 0 / 111:  11%|█         | 112/1000 [40:35<5:21:51, 21.75s/it][Succeeded / Failed / Skipped / Total] 107 / 5 / 0 / 112:  11%|█         | 112/1000 [40:35<5:21:51, 21.75s/it][Succeeded / Failed / Skipped / Total] 107 / 5 / 0 / 112:  11%|█▏        | 113/1000 [41:28<5:25:33, 22.02s/it][Succeeded / Failed / Skipped / Total] 108 / 5 / 0 / 113:  11%|█▏        | 113/1000 [41:28<5:25:33, 22.02s/it][Succeeded / Failed / Skipped / Total] 108 / 5 / 0 / 113:  11%|█▏        | 114/1000 [41:31<5:22:45, 21.86s/it]Sets the cookie . --> Add a canned bean --> Socre: 1.0

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int [[maxAge]] , HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { String [[cookieValue]] = encodeCookie ( tokens ) ; Cookie [[cookie]] = new Cookie ( cookieName , [[cookieValue]] ) ; [[cookie]] . setMaxAge ( [[maxAge]] ) ; [[cookie]] . setPath ( getCookiePath ( [[request]] ) ) ; if ( cookieDomain != null ) { [[cookie]] . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { [[cookie]] . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { [[cookie]] . setSecure ( [[request]] . isSecure ( ) ) ; } else { [[cookie]] . setSecure ( useSecureCookie ) ; } [[cookie]] . setHttpOnly ( "True" == "True" ) ; [[response]] . addCookie ( [[cookie]] ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int [[catties]] , HttpServletRequest [[demanding]] , HttpServletResponse [[respond]] ) { String [[i]] = encodeCookie ( tokens ) ; Cookie [[cakes]] = new Cookie ( cookieName , [[i]] ) ; [[cakes]] . setMaxAge ( [[catties]] ) ; [[cakes]] . setPath ( getCookiePath ( [[demanding]] ) ) ; if ( cookieDomain != null ) { [[cakes]] . setDomain ( cookieDomain ) ; } if ( [[catties]] < 1 ) { [[cakes]] . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { [[cakes]] . setSecure ( [[demanding]] . isSecure ( ) ) ; } else { [[cakes]] . setSecure ( useSecureCookie ) ; } [[cakes]] . setHttpOnly ( "True" == "True" ) ; [[respond]] . addCookie ( [[cakes]] ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 110 ---------------------------------------------
Resolves the security context for the given parameter . --> Resolves a security context --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter [[parameter]] , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[parameter]] . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( [[parameter]] , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter [[setups]] , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[setups]] . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( [[setups]] , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 111 ---------------------------------------------
Encode cookie . --> helper method to encode the cookie --> Socre: 1.0

[[[[Adv]]]]: protected String encodeCookie ( String [ ] [[cookieTokens]] ) { StringBuilder [[sb]] = new StringBuilder ( ) ; for ( int i = 0 ; i < [[cookieTokens]] . length ; i ++ ) { try { [[sb]] . append ( URLEncoder . encode ( [[cookieTokens]] [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < [[cookieTokens]] . length - 1 ) { [[sb]] . append ( DELIMITER ) ; } } String value = [[sb]] . toString ( ) ; [[sb]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( [[sb]] . charAt ( [[sb]] . length ( ) - 1 ) == ' ' ) { [[sb]] . deleteCharAt ( [[sb]] . length ( ) - 1 ) ; } return [[sb]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] [[rickshaw]] ) { StringBuilder [[ccs]] = new StringBuilder ( ) ; for ( int i = 0 ; i < [[rickshaw]] . length ; i ++ ) { try { [[ccs]] . append ( URLEncoder . encode ( [[rickshaw]] [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < [[rickshaw]] . length - 1 ) { [[ccs]] . append ( DELIMITER ) ; } } String value = [[ccs]] . toString ( ) ; [[ccs]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( [[ccs]] . charAt ( [[ccs]] . length ( ) - 1 ) == ' ' ) { [[ccs]] . deleteCharAt ( [[ccs]] . length ( ) - 1 ) ; } return [[ccs]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 112 ---------------------------------------------
Map the authorities to their default authorities . --> map organizations --> Socre: 1.0

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > [[authorities]] ) { HashSet < GrantedAuthority > [[mapped]] = new HashSet <> ( [[authorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[authorities]] ) { [[mapped]] . add ( mapAuthority ( [[authority]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[mapped]] . add ( defaultAuthority ) ; } return [[mapped]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[poopie]] ( Collection < ? extends GrantedAuthority > [[organs]] ) { HashSet < GrantedAuthority > [[granted]] = new HashSet <> ( [[organs]] . size ( ) ) ; for ( GrantedAuthority [[empowered]] : [[organs]] ) { [[granted]] . add ( mapAuthority ( [[empowered]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[granted]] . add ( defaultAuthority ) ; } return [[granted]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 113 ---------------------------------------------
Get service port from cas service url . --> Mavadoc API --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int [[port]] = [[casServiceUrl]] . getPort ( ) ; if ( [[port]] == - 1 ) { [[port]] = [[casServiceUrl]] . getDefaultPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[mavi]] ( URL [[bauman]] ) { int [[haven]] = [[bauman]] . getPort ( ) ; if ( [[haven]] == - 1 ) { [[haven]] = [[bauman]] . getDefaultPort ( ) ; } return [[haven]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 114 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 109 / 5 / 0 / 114:  11%|█▏        | 114/1000 [41:31<5:22:45, 21.86s/it][Succeeded / Failed / Skipped / Total] 109 / 5 / 0 / 114:  12%|█▏        | 115/1000 [41:38<5:20:24, 21.72s/it][Succeeded / Failed / Skipped / Total] 110 / 5 / 0 / 115:  12%|█▏        | 115/1000 [41:38<5:20:24, 21.72s/it][Succeeded / Failed / Skipped / Total] 110 / 5 / 0 / 115:  12%|█▏        | 116/1000 [41:47<5:18:27, 21.62s/it][Succeeded / Failed / Skipped / Total] 111 / 5 / 0 / 116:  12%|█▏        | 116/1000 [41:47<5:18:27, 21.62s/it][Succeeded / Failed / Skipped / Total] 111 / 5 / 0 / 116:  12%|█▏        | 117/1000 [42:21<5:19:37, 21.72s/it][Succeeded / Failed / Skipped / Total] 112 / 5 / 0 / 117:  12%|█▏        | 117/1000 [42:21<5:19:37, 21.72s/it][Succeeded / Failed / Skipped / Total] 112 / 5 / 0 / 117:  12%|█▏        | 118/1000 [42:39<5:18:53, 21.69s/it][Succeeded / Failed / Skipped / Total] 113 / 5 / 0 / 118:  12%|█▏        | 118/1000 [42:39<5:18:53, 21.69s/it][Succeeded / Failed / Skipped / Total] 113 / 5 / 0 / 118:  12%|█▏        | 119/1000 [42:44<5:16:23, 21.55s/it][Succeeded / Failed / Skipped / Total] 114 / 5 / 0 / 119:  12%|█▏        | 119/1000 [42:44<5:16:23, 21.55s/it][Succeeded / Failed / Skipped / Total] 114 / 5 / 0 / 119:  12%|█▏        | 120/1000 [42:47<5:13:44, 21.39s/it]Logout the request --> Called by HttpServlet --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext [[context]] = SecurityContextHolder . getContext ( ) ; [[context]] . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[mansions]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext [[environments]] = SecurityContextHolder . getContext ( ) ; [[environments]] . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 115 ---------------------------------------------
Authenticates the given authentication . --> authenticate token --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[hopwood]] ) throws AuthenticationException { if ( ! ( [[hopwood]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[asking]] = ( UsernamePasswordAuthenticationToken ) [[hopwood]] ; Set < GrantedAuthority > [[organisation]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 116 ---------------------------------------------
Get the query string from the request . --> Called when we need to re - match a search --> Socre: 1.0

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest request , final Pattern [[artifactPattern]] ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = [[artifactPattern]] . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[clichéd]] ( final HttpServletRequest request , final Pattern [[tawny]] ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = [[tawny]] . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 117 ---------------------------------------------
Set environment variables . --> Sets the state of the simulation --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[standings]] ( Map < String , Object > [[climate]] ) { Assert . notEmpty ( [[climate]] , "environment must not be empty" ) ; this . [[gianfranco]] = new Hashtable <> ( [[climate]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 118 ---------------------------------------------
Returns the LDAP principal . --> returns null if not found --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[principal]] = [[authentication]] . getPrincipal ( ) ; if ( [[principal]] instanceof LdapUserDetails ) { LdapUserDetails [[details]] = ( LdapUserDetails ) [[principal]] ; return [[details]] . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[kerr]] ( ) { Authentication [[proof]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[proof]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[primary]] = [[proof]] . getPrincipal ( ) ; if ( [[primary]] instanceof LdapUserDetails ) { LdapUserDetails [[data]] = ( LdapUserDetails ) [[primary]] ; return [[data]] . getDn ( ) ; } else if ( [[proof]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 119 ---------------------------------------------
Render the end of the tag . --> we don t call this! --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[ramsay]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 120 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 115 / 5 / 0 / 120:  12%|█▏        | 120/1000 [42:47<5:13:44, 21.39s/it][Succeeded / Failed / Skipped / Total] 115 / 5 / 0 / 120:  12%|█▏        | 121/1000 [42:52<5:11:27, 21.26s/it][Succeeded / Failed / Skipped / Total] 116 / 5 / 0 / 121:  12%|█▏        | 121/1000 [42:52<5:11:27, 21.26s/it][Succeeded / Failed / Skipped / Total] 116 / 5 / 0 / 121:  12%|█▏        | 122/1000 [42:53<5:08:38, 21.09s/it][Succeeded / Failed / Skipped / Total] 117 / 5 / 0 / 122:  12%|█▏        | 122/1000 [42:53<5:08:38, 21.09s/it][Succeeded / Failed / Skipped / Total] 117 / 5 / 0 / 122:  12%|█▏        | 123/1000 [43:22<5:09:19, 21.16s/it][Succeeded / Failed / Skipped / Total] 118 / 5 / 0 / 123:  12%|█▏        | 123/1000 [43:22<5:09:19, 21.16s/it][Succeeded / Failed / Skipped / Total] 118 / 5 / 0 / 123:  12%|█▏        | 124/1000 [43:42<5:08:47, 21.15s/it][Succeeded / Failed / Skipped / Total] 119 / 5 / 0 / 124:  12%|█▏        | 124/1000 [43:42<5:08:47, 21.15s/it][Succeeded / Failed / Skipped / Total] 119 / 5 / 0 / 124:  12%|█▎        | 125/1000 [45:24<5:17:50, 21.80s/it][Succeeded / Failed / Skipped / Total] 120 / 5 / 0 / 125:  12%|█▎        | 125/1000 [45:24<5:17:50, 21.80s/it][Succeeded / Failed / Skipped / Total] 120 / 5 / 0 / 125:  13%|█▎        | 126/1000 [46:47<5:24:32, 22.28s/it]Initializes the user details service . --> Create a new user --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder [[userBuilder]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[userBuilder]] . build ( ) ) ; } for ( UserDetails [[userDetails]] : this . [[users]] ) { getUserDetailsService ( ) . createUser ( [[userDetails]] ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[roth]] ( ) throws Exception { for ( UserDetailsBuilder [[fiendishly]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[fiendishly]] . build ( ) ) ; } for ( UserDetails [[carati]] : this . [[subscribe]] ) { getUserDetailsService ( ) . createUser ( [[carati]] ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 121 ---------------------------------------------
Gets the UserDetailsService . --> Get UserDetailsService --> Socre: 1.0

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > [[grains]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[grains]] . size ( ) == 0 ) { [[grains]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[grains]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[grains]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[grains]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 122 ---------------------------------------------
Returns the redirect URL . --> Build query string --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[qing]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 123 ---------------------------------------------
Adds PkCE parameters . --> Add nalini request --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > [[attributes]] , Map < String , Object > additionalParameters ) { String codeVerifier = this . [[codeVerifierGenerator]] . generateKey ( ) ; [[attributes]] . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[nalini]] ( Map < String , Object > [[ascribe]] , Map < String , Object > additionalParameters ) { String codeVerifier = this . [[marathon]] . generateKey ( ) ; [[ascribe]] . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 124 ---------------------------------------------
Checks for authentication . --> Return true if the demands should be rejected --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest [[request]] , final HttpServletResponse [[response]] ) { final boolean [[serviceTicketRequest]] = [[serviceTicketRequest]] ( [[request]] , [[response]] ) ; final boolean [[result]] = [[serviceTicketRequest]] || proxyReceptorRequest ( [[request]] ) || ( proxyTicketRequest ( [[serviceTicketRequest]] , [[request]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[unbelieveable]] ( final HttpServletRequest [[demands]] , final HttpServletResponse [[commentaries]] ) { final boolean [[stockpiling]] = [[stockpiling]] ( [[demands]] , [[commentaries]] ) ; final boolean [[observations]] = [[stockpiling]] || proxyReceptorRequest ( [[demands]] ) || ( proxyTicketRequest ( [[stockpiling]] , [[demands]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[observations]] ) ; } return [[observations]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 125 ---------------------------------------------
Proxy service ticket request --> Suitable for consent --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean [[serviceTicketRequest]] , final HttpServletRequest [[request]] ) { if ( [[serviceTicketRequest]] ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[jujitsu]] ( final boolean [[conk]] , final HttpServletRequest [[petitions]] ) { if ( [[conk]] ) { return "False" != "False" ; } final boolean [[concluding]] = authenticateAllArtifacts && obtainArtifact ( [[petitions]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[concluding]] ) ; } return [[concluding]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 126 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 121 / 5 / 0 / 126:  13%|█▎        | 126/1000 [46:47<5:24:32, 22.28s/it][Succeeded / Failed / Skipped / Total] 121 / 5 / 0 / 126:  13%|█▎        | 127/1000 [49:00<5:36:54, 23.15s/it][Succeeded / Failed / Skipped / Total] 122 / 5 / 0 / 127:  13%|█▎        | 127/1000 [49:00<5:36:54, 23.15s/it][Succeeded / Failed / Skipped / Total] 122 / 5 / 0 / 127:  13%|█▎        | 128/1000 [51:14<5:49:02, 24.02s/it][Succeeded / Failed / Skipped / Total] 123 / 5 / 0 / 128:  13%|█▎        | 128/1000 [51:14<5:49:02, 24.02s/it][Succeeded / Failed / Skipped / Total] 123 / 5 / 0 / 128:  13%|█▎        | 129/1000 [51:23<5:46:59, 23.90s/it][Succeeded / Failed / Skipped / Total] 124 / 5 / 0 / 129:  13%|█▎        | 129/1000 [51:23<5:46:59, 23.90s/it][Succeeded / Failed / Skipped / Total] 124 / 5 / 0 / 129:  13%|█▎        | 130/1000 [51:23<5:43:58, 23.72s/it][Succeeded / Failed / Skipped / Total] 124 / 5 / 1 / 130:  13%|█▎        | 130/1000 [51:23<5:43:58, 23.72s/it][Succeeded / Failed / Skipped / Total] 124 / 5 / 1 / 130:  13%|█▎        | 131/1000 [52:15<5:46:37, 23.93s/it][Succeeded / Failed / Skipped / Total] 125 / 5 / 1 / 131:  13%|█▎        | 131/1000 [52:15<5:46:37, 23.93s/it][Succeeded / Failed / Skipped / Total] 125 / 5 / 1 / 131:  13%|█▎        | 132/1000 [57:55<6:20:56, 26.33s/it][Succeeded / Failed / Skipped / Total] 125 / 6 / 1 / 132:  13%|█▎        | 132/1000 [57:55<6:20:56, 26.33s/it][Succeeded / Failed / Skipped / Total] 125 / 6 / 1 / 132:  13%|█▎        | 133/1000 [58:01<6:18:17, 26.18s/it][Succeeded / Failed / Skipped / Total] 126 / 6 / 1 / 133:  13%|█▎        | 133/1000 [58:01<6:18:17, 26.18s/it][Succeeded / Failed / Skipped / Total] 126 / 6 / 1 / 133:  13%|█▎        | 134/1000 [58:21<6:17:11, 26.13s/it]Check for authentication . --> We don t have an authentication --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { boolean [[result]] = super . requiresAuthentication ( request , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[washington]] ( final HttpServletRequest request , final HttpServletResponse [[replying]] ) { boolean [[fruition]] = super . requiresAuthentication ( request , [[replying]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[fruition]] ) ; } return [[fruition]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 127 ---------------------------------------------
Checks if the current security context is authenticated . --> Checks access to the current security context --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[approbation]] ( ) { Authentication [[certificate]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[certificate]] != null && [[certificate]] . isAuthenticated ( ) && ! ( [[certificate]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 128 ---------------------------------------------
Creates the security expression root for the given method invocation . --> constructs a methodSecurityExpression into a Triva --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication [[authentication]] , MethodInvocation [[invocation]] ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[authentication]] ) ; root . setThis ( [[invocation]] . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[tuva]] ( Authentication [[certify]] , MethodInvocation [[dunning]] ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[certify]] ) ; root . setThis ( [[dunning]] . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 129 ---------------------------------------------
Gets the JWK set . --> Retrieve a bunch of resources --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . [[webClient]] . get ( ) . uri ( this . [[jwkSetURL]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[cachedJWKSet]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[lot]] ( ) { return this . [[peak]] . get ( ) . uri ( this . [[activities]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[sadist]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 130 ---------------------------------------------
Encode a string value . --> [[[SKIPPED]]]

[[[[Adv]]]]: private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 131 ---------------------------------------------
Convert the current user groups to a collection of grants . --> Convert roles to chameli identifiers --> Socre: 1.0

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[chameli]] ( ) { List < String > [[tuesdays]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[air]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[tuesdays]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[tuesdays]] + " mapped to Granted Authorities: " + [[air]] ) ; } return [[air]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 132 ---------------------------------------------
Creates a new cipher . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher newCipher ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher newCipher ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 133 ---------------------------------------------
Returns the pre - authenticated principal . --> we want to do this here --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[broadening]] ( HttpServletRequest [[memorandum]] ) { Object [[key]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[key]] ) ; } return [[key]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 134 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 127 / 6 / 1 / 134:  13%|█▎        | 134/1000 [58:21<6:17:11, 26.13s/it][Succeeded / Failed / Skipped / Total] 127 / 6 / 1 / 134:  14%|█▎        | 135/1000 [58:34<6:15:16, 26.03s/it][Succeeded / Failed / Skipped / Total] 128 / 6 / 1 / 135:  14%|█▎        | 135/1000 [58:34<6:15:16, 26.03s/it][Succeeded / Failed / Skipped / Total] 128 / 6 / 1 / 135:  14%|█▎        | 136/1000 [1:01:52<6:33:03, 27.30s/it][Succeeded / Failed / Skipped / Total] 129 / 6 / 1 / 136:  14%|█▎        | 136/1000 [1:01:52<6:33:03, 27.30s/it][Succeeded / Failed / Skipped / Total] 129 / 6 / 1 / 136:  14%|█▎        | 137/1000 [1:02:07<6:31:18, 27.21s/it][Succeeded / Failed / Skipped / Total] 130 / 6 / 1 / 137:  14%|█▎        | 137/1000 [1:02:07<6:31:18, 27.21s/it][Succeeded / Failed / Skipped / Total] 130 / 6 / 1 / 137:  14%|█▍        | 138/1000 [1:02:11<6:28:27, 27.04s/it][Succeeded / Failed / Skipped / Total] 131 / 6 / 1 / 138:  14%|█▍        | 138/1000 [1:02:11<6:28:27, 27.04s/it][Succeeded / Failed / Skipped / Total] 131 / 6 / 1 / 138:  14%|█▍        | 139/1000 [1:02:20<6:26:07, 26.91s/it][Succeeded / Failed / Skipped / Total] 132 / 6 / 1 / 139:  14%|█▍        | 139/1000 [1:02:20<6:26:07, 26.91s/it][Succeeded / Failed / Skipped / Total] 132 / 6 / 1 / 139:  14%|█▍        | 140/1000 [1:02:38<6:24:45, 26.84s/it][Succeeded / Failed / Skipped / Total] 133 / 6 / 1 / 140:  14%|█▍        | 140/1000 [1:02:38<6:24:45, 26.84s/it][Succeeded / Failed / Skipped / Total] 133 / 6 / 1 / 140:  14%|█▍        | 141/1000 [1:02:38<6:21:35, 26.65s/it]Concatenate two arrays . --> Convert tiling bytes --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... [[arrays]] ) { int length = 0 ; for ( byte [ ] array : [[arrays]] ) { length += array . length ; } byte [ ] [[newArray]] = new byte [ length ] ; int [[destPos]] = 0 ; for ( byte [ ] array : [[arrays]] ) { System . arraycopy ( array , 0 , [[newArray]] , [[destPos]] , array . length ) ; [[destPos]] += array . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[fozzie]] ( byte [ ] ... [[tiling]] ) { int length = 0 ; for ( byte [ ] array : [[tiling]] ) { length += array . length ; } byte [ ] [[moment]] = new byte [ length ] ; int [[nucleic]] = 0 ; for ( byte [ ] array : [[tiling]] ) { System . arraycopy ( array , 0 , [[moment]] , [[nucleic]] , array . length ) ; [[nucleic]] += array . length ; } return [[moment]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 135 ---------------------------------------------
Creates a new byte array . --> also used in test --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] array , int [[beginIndex]] , int [[endIndex]] ) { int length = [[endIndex]] - [[beginIndex]] ; byte [ ] [[subarray]] = new byte [ length ] ; System . arraycopy ( array , [[beginIndex]] , [[subarray]] , 0 , length ) ; return [[subarray]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[uschi]] ( byte [ ] array , int [[filing]] , int [[mainframe]] ) { int length = [[mainframe]] - [[filing]] ; byte [ ] [[mindbender]] = new byte [ length ] ; System . arraycopy ( array , [[filing]] , [[mindbender]] , 0 , length ) ; return [[mindbender]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 136 ---------------------------------------------
Returns a list of granted authorities . --> Highlights a feature --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > [[gaList]] = new ArrayList <> ( ) ; for ( String attribute : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { [[gaList]] . addAll ( c ) ; } } [[gaList]] . trimToSize ( ) ; return [[gaList]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[hight]] ( Collection < String > [[feature]] ) { ArrayList < GrantedAuthority > [[marwood]] = new ArrayList <> ( ) ; for ( String attribute : [[feature]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { [[marwood]] . addAll ( c ) ; } } [[marwood]] . trimToSize ( ) ; return [[marwood]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 137 ---------------------------------------------
Pre processes the map . --> Pre - processes a dictionary . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[molto]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[molto]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[scriptures]] : [[molto]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[scriptures]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[scriptures]] . getKey ( ) , getGrantedAuthorityCollection ( [[scriptures]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 138 ---------------------------------------------
Gets the collection of granted authorities . --> Convenient groovy . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object [[value]] ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , [[value]] ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[jacob]] ( Object [[merits]] ) { Collection < GrantedAuthority > [[concluding]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[concluding]] , [[merits]] ) ; return [[concluding]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 139 ---------------------------------------------
Returns true if the request should be executed . --> implemented --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[weíre]] ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 140 ---------------------------------------------
Get the pre - authenticated principal . --> Convenience method that obtains a summoned principal object --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[alternating]] ( HttpServletRequest [[choreographed]] ) { Object [[paramount]] = [[choreographed]] . getUserPrincipal ( ) == null ? null : [[choreographed]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[paramount]] ) ; } return [[paramount]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 141 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 134 / 6 / 1 / 141:  14%|█▍        | 141/1000 [1:02:38<6:21:35, 26.65s/it][Succeeded / Failed / Skipped / Total] 134 / 6 / 1 / 141:  14%|█▍        | 142/1000 [1:02:52<6:19:54, 26.57s/it][Succeeded / Failed / Skipped / Total] 135 / 6 / 1 / 142:  14%|█▍        | 142/1000 [1:02:52<6:19:54, 26.57s/it][Succeeded / Failed / Skipped / Total] 135 / 6 / 1 / 142:  14%|█▍        | 143/1000 [1:02:58<6:17:26, 26.42s/it][Succeeded / Failed / Skipped / Total] 136 / 6 / 1 / 143:  14%|█▍        | 143/1000 [1:02:58<6:17:26, 26.42s/it][Succeeded / Failed / Skipped / Total] 136 / 6 / 1 / 143:  14%|█▍        | 144/1000 [1:03:40<6:18:33, 26.53s/it][Succeeded / Failed / Skipped / Total] 137 / 6 / 1 / 144:  14%|█▍        | 144/1000 [1:03:40<6:18:33, 26.53s/it][Succeeded / Failed / Skipped / Total] 137 / 6 / 1 / 144:  14%|█▍        | 145/1000 [1:03:53<6:16:44, 26.44s/it][Succeeded / Failed / Skipped / Total] 138 / 6 / 1 / 145:  14%|█▍        | 145/1000 [1:03:53<6:16:44, 26.44s/it][Succeeded / Failed / Skipped / Total] 138 / 6 / 1 / 145:  15%|█▍        | 146/1000 [1:04:31<6:17:25, 26.52s/it]Adds the granted authority to the result . --> Methode permettant deactivation --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[stempel]] ( Collection < GrantedAuthority > [[fruition]] , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { [[stempel]] ( [[fruition]] , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { [[stempel]] ( [[fruition]] , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { [[stempel]] ( [[fruition]] , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { [[fruition]] . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 142 ---------------------------------------------
Build the redirect URL for the given request . --> This method can be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest [[request]] ) throws IOException , ServletException { int [[serverPort]] = portResolver . getServerPort ( [[request]] ) ; Integer [[httpsPort]] = portMapper . lookupHttpsPort ( Integer . valueOf ( [[serverPort]] ) ) ; if ( [[httpsPort]] != null ) { RedirectUrlBuilder [[urlBuilder]] = new RedirectUrlBuilder ( ) ; [[urlBuilder]] . setScheme ( "https" ) ; [[urlBuilder]] . setServerName ( [[request]] . getServerName ( ) ) ; [[urlBuilder]] . setPort ( [[httpsPort]] . intValue ( ) ) ; [[urlBuilder]] . setContextPath ( [[request]] . getContextPath ( ) ) ; [[urlBuilder]] . setServletPath ( [[request]] . getServletPath ( ) ) ; [[urlBuilder]] . setPathInfo ( [[request]] . getPathInfo ( ) ) ; [[urlBuilder]] . setQuery ( [[request]] . getQueryString ( ) ) ; return [[urlBuilder]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[hanky]] ( HttpServletRequest [[inquired]] ) throws IOException , ServletException { int [[dede]] = portResolver . getServerPort ( [[inquired]] ) ; Integer [[wash]] = portMapper . lookupHttpsPort ( Integer . valueOf ( [[dede]] ) ) ; if ( [[wash]] != null ) { RedirectUrlBuilder [[colostomy]] = new RedirectUrlBuilder ( ) ; [[colostomy]] . setScheme ( "https" ) ; [[colostomy]] . setServerName ( [[inquired]] . getServerName ( ) ) ; [[colostomy]] . setPort ( [[wash]] . intValue ( ) ) ; [[colostomy]] . setContextPath ( [[inquired]] . getContextPath ( ) ) ; [[colostomy]] . setServletPath ( [[inquired]] . getServletPath ( ) ) ; [[colostomy]] . setPathInfo ( [[inquired]] . getPathInfo ( ) ) ; [[colostomy]] . setQuery ( [[inquired]] . getQueryString ( ) ) ; return [[colostomy]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 143 ---------------------------------------------
Invoke interceptor interceptor . --> utility methods --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint [[jp]] , AspectJCallback [[advisorProceed]] ) { InterceptorStatusToken [[token]] = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object result ; try { result = [[advisorProceed]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( [[token]] ) ; } return super . afterInvocation ( [[token]] , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[invocation]] ( JoinPoint [[japanese]] , AspectJCallback [[concise]] ) { InterceptorStatusToken [[coinage]] = super . beforeInvocation ( new MethodInvocationAdapter ( [[japanese]] ) ) ; Object result ; try { result = [[concise]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( [[coinage]] ) ; } return super . afterInvocation ( [[coinage]] , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 144 ---------------------------------------------
Checks that the given string has a role . --> Decompress the operation name --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[decompression]] ( String [[operation]] ) { Assert . isTrue ( ! [[operation]] . startsWith ( "ROLE_" ) , ( ) -> [[operation]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[operation]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 145 ---------------------------------------------
Check if any of the roles have a role --> check if there is any role --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[roles]] ) { for ( int i = 0 ; i < [[roles]] . length ; i ++ ) { [[roles]] [ i ] = "ROLE_" + [[roles]] [ i ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[duty]] ) { for ( int i = 0 ; i < [[duty]] . length ; i ++ ) { [[duty]] [ i ] = "ROLE_" + [[duty]] [ i ] ; } return [[duty]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 146 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 139 / 6 / 1 / 146:  15%|█▍        | 146/1000 [1:04:31<6:17:25, 26.52s/it][Succeeded / Failed / Skipped / Total] 139 / 6 / 1 / 146:  15%|█▍        | 147/1000 [1:05:36<6:20:43, 26.78s/it][Succeeded / Failed / Skipped / Total] 140 / 6 / 1 / 147:  15%|█▍        | 147/1000 [1:05:36<6:20:43, 26.78s/it][Succeeded / Failed / Skipped / Total] 140 / 6 / 1 / 147:  15%|█▍        | 148/1000 [1:07:50<6:30:31, 27.50s/it][Succeeded / Failed / Skipped / Total] 141 / 6 / 1 / 148:  15%|█▍        | 148/1000 [1:07:50<6:30:31, 27.50s/it][Succeeded / Failed / Skipped / Total] 141 / 6 / 1 / 148:  15%|█▍        | 149/1000 [1:08:04<6:28:50, 27.42s/it][Succeeded / Failed / Skipped / Total] 142 / 6 / 1 / 149:  15%|█▍        | 149/1000 [1:08:04<6:28:50, 27.42s/it][Succeeded / Failed / Skipped / Total] 142 / 6 / 1 / 149:  15%|█▌        | 150/1000 [1:08:25<6:27:46, 27.37s/it][Succeeded / Failed / Skipped / Total] 143 / 6 / 1 / 150:  15%|█▌        | 150/1000 [1:08:25<6:27:46, 27.37s/it][Succeeded / Failed / Skipped / Total] 143 / 6 / 1 / 150:  15%|█▌        | 151/1000 [1:08:27<6:24:53, 27.20s/it][Succeeded / Failed / Skipped / Total] 144 / 6 / 1 / 151:  15%|█▌        | 151/1000 [1:08:27<6:24:53, 27.20s/it][Succeeded / Failed / Skipped / Total] 144 / 6 / 1 / 151:  15%|█▌        | 152/1000 [1:08:30<6:22:12, 27.04s/it]Process auto login cookie . --> Implementation of IMI --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String [[presentedToken]] = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[imi]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String [[singapore]] = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 147 ---------------------------------------------
This method is called when the login succeeded . -->  volt log - me --> Socre: 1.0

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest request , HttpServletResponse [[response]] , Authentication successfulAuthentication ) { String [[username]] = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[username]] ) ; PersistentRememberMeToken [[persistentToken]] = new PersistentRememberMeToken ( [[username]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[persistentToken]] ) ; addCookie ( [[persistentToken]] , request , [[response]] ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[volt]] ( HttpServletRequest request , HttpServletResponse [[reacting]] , Authentication successfulAuthentication ) { String [[accesses]] = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[accesses]] ) ; PersistentRememberMeToken [[slicked]] = new PersistentRememberMeToken ( [[accesses]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[slicked]] ) ; addCookie ( [[slicked]] , request , [[reacting]] ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 148 ---------------------------------------------
Attempt to switch to a user . --> Execute a Cromi request --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . [[usernameParameter]] ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . [[userDetailsChecker]] . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[romi]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . [[occupations]] ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . [[cromer]] . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 149 ---------------------------------------------
Attempt authentication . --> Obtain the ballads for the given request --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[ballads]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 150 ---------------------------------------------
Set the exit user URL . --> Specify a binary that will be podemos --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[woof]] ( String [[binary]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[binary]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[podemos]] = createMatcher ( [[binary]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 151 ---------------------------------------------
Display a public index --> Handle a random email --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact [[rnd]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[rnd]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[yuri]] ( ) { Contact [[vln]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[vln]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 152 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 145 / 6 / 1 / 152:  15%|█▌        | 152/1000 [1:08:30<6:22:12, 27.04s/it][Succeeded / Failed / Skipped / Total] 145 / 6 / 1 / 152:  15%|█▌        | 153/1000 [1:09:31<6:24:52, 27.26s/it][Succeeded / Failed / Skipped / Total] 146 / 6 / 1 / 153:  15%|█▌        | 153/1000 [1:09:31<6:24:52, 27.26s/it][Succeeded / Failed / Skipped / Total] 146 / 6 / 1 / 153:  15%|█▌        | 154/1000 [1:10:04<6:24:59, 27.30s/it][Succeeded / Failed / Skipped / Total] 147 / 6 / 1 / 154:  15%|█▌        | 154/1000 [1:10:04<6:24:59, 27.30s/it][Succeeded / Failed / Skipped / Total] 147 / 6 / 1 / 154:  16%|█▌        | 155/1000 [1:13:33<6:41:01, 28.48s/it][Succeeded / Failed / Skipped / Total] 148 / 6 / 1 / 155:  16%|█▌        | 155/1000 [1:13:33<6:41:01, 28.48s/it][Succeeded / Failed / Skipped / Total] 148 / 6 / 1 / 155:  16%|█▌        | 156/1000 [1:13:37<6:38:17, 28.31s/it][Succeeded / Failed / Skipped / Total] 149 / 6 / 1 / 156:  16%|█▌        | 156/1000 [1:13:37<6:38:17, 28.31s/it][Succeeded / Failed / Skipped / Total] 149 / 6 / 1 / 156:  16%|█▌        | 157/1000 [1:13:55<6:36:57, 28.25s/it][Succeeded / Failed / Skipped / Total] 150 / 6 / 1 / 157:  16%|█▌        | 157/1000 [1:13:55<6:36:57, 28.25s/it][Succeeded / Failed / Skipped / Total] 150 / 6 / 1 / 157:  16%|█▌        | 158/1000 [1:14:05<6:34:48, 28.13s/it][Succeeded / Failed / Skipped / Total] 151 / 6 / 1 / 158:  16%|█▌        | 158/1000 [1:14:05<6:34:48, 28.13s/it][Succeeded / Failed / Skipped / Total] 151 / 6 / 1 / 158:  16%|█▌        | 159/1000 [1:14:08<6:32:11, 27.98s/it]Spring security filter . --> Inuit --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[inuit]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 153 ---------------------------------------------
Decodes the JWT --> Translates a JSON string . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String token ) throws JwtException { JWT [[jwt]] = parse ( token ) ; if ( [[jwt]] instanceof SignedJWT ) { Jwt [[createdJwt]] = createJwt ( token , [[jwt]] ) ; return validateJwt ( [[createdJwt]] ) ; } throw new JwtException ( "Unsupported algorithm of " + [[jwt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[transcoder]] ( String token ) throws JwtException { JWT [[defamation]] = parse ( token ) ; if ( [[defamation]] instanceof SignedJWT ) { Jwt [[diagonally]] = createJwt ( token , [[defamation]] ) ; return validateJwt ( [[diagonally]] ) ; } throw new JwtException ( "Unsupported algorithm of " + [[defamation]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 154 ---------------------------------------------
Authorizes access using access expression . --> returns true if false false otherwise --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > [[handler]] = getExpressionHandler ( ) ; Expression [[accessExpression]] ; try { [[accessExpression]] = [[handler]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[ioException]] = new IOException ( ) ; [[ioException]] . initCause ( e ) ; throw [[ioException]] ; } return ExpressionUtils . evaluateAsBoolean ( [[accessExpression]] , createExpressionEvaluationContext ( [[handler]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[mbeki]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > [[wardens]] = getExpressionHandler ( ) ; Expression [[mycenae]] ; try { [[mycenae]] = [[wardens]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[voom]] = new IOException ( ) ; [[voom]] . initCause ( e ) ; throw [[voom]] ; } return ExpressionUtils . evaluateAsBoolean ( [[mycenae]] , createExpressionEvaluationContext ( [[wardens]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 155 ---------------------------------------------
Check authorization using url check . --> Allow chivo for chivo --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[chivo]] ( ) throws IOException { String [[despite]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[despite]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 156 ---------------------------------------------
Convert the given JWT to a collection of authorities . --> Translates a given JWT . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[convert]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[transition]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 157 ---------------------------------------------
Generates a CSRF token for this request . --> Wraps the given request . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . [[delegate]] . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[crepe]] ( HttpServletRequest [[claim]] ) { return wrap ( [[claim]] , this . [[participants]] . generateToken ( [[claim]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 158 ---------------------------------------------
Display admin permission --> Display Ecl Link --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int [[contactId]] ) { Contact contact = contactManager . getById ( Long . valueOf ( [[contactId]] ) ) ; Acl [[acl]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[acl]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[eclairs]] ( @ RequestParam ( "contactId" ) int [[notte]] ) { Contact contact = contactManager . getById ( Long . valueOf ( [[notte]] ) ) ; Acl [[aom]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[aom]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
[Succeeded / Failed / Skipped / Total] 152 / 6 / 1 / 159:  16%|█▌        | 159/1000 [1:14:08<6:32:11, 27.98s/it][Succeeded / Failed / Skipped / Total] 152 / 6 / 1 / 159:  16%|█▌        | 160/1000 [1:14:09<6:29:17, 27.81s/it][Succeeded / Failed / Skipped / Total] 152 / 6 / 2 / 160:  16%|█▌        | 160/1000 [1:14:09<6:29:17, 27.81s/it][Succeeded / Failed / Skipped / Total] 152 / 6 / 2 / 160:  16%|█▌        | 161/1000 [1:14:45<6:29:33, 27.86s/it][Succeeded / Failed / Skipped / Total] 153 / 6 / 2 / 161:  16%|█▌        | 161/1000 [1:14:45<6:29:33, 27.86s/it][Succeeded / Failed / Skipped / Total] 153 / 6 / 2 / 161:  16%|█▌        | 162/1000 [1:14:55<6:27:36, 27.75s/it][Succeeded / Failed / Skipped / Total] 154 / 6 / 2 / 162:  16%|█▌        | 162/1000 [1:14:55<6:27:36, 27.75s/it][Succeeded / Failed / Skipped / Total] 154 / 6 / 2 / 162:  16%|█▋        | 163/1000 [1:15:23<6:27:09, 27.75s/it][Succeeded / Failed / Skipped / Total] 155 / 6 / 2 / 163:  16%|█▋        | 163/1000 [1:15:23<6:27:09, 27.75s/it][Succeeded / Failed / Skipped / Total] 155 / 6 / 2 / 163:  16%|█▋        | 164/1000 [1:15:29<6:24:47, 27.62s/it][Succeeded / Failed / Skipped / Total] 156 / 6 / 2 / 164:  16%|█▋        | 164/1000 [1:15:29<6:24:47, 27.62s/it][Succeeded / Failed / Skipped / Total] 156 / 6 / 2 / 164:  16%|█▋        | 165/1000 [1:16:44<6:28:20, 27.91s/it]--------------------------------------------- Result 159 ---------------------------------------------
Display the AddPermission page --> Render AddPermission --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[savage]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 160 ---------------------------------------------
Handle addPermission --> [[[SKIPPED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 161 ---------------------------------------------
Deletes a specific permission --> Removes the bar from contacts --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[barometer]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 162 ---------------------------------------------
Gets the role with the given default role prefix . --> adds trait to tail --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( [[defaultRolePrefix]] ) ) { return [[role]] ; } return [[defaultRolePrefix]] + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[sarong]] ( String [[tether]] , String [[traits]] ) { if ( [[traits]] == null ) { return [[traits]] ; } if ( [[tether]] == null || [[tether]] . length ( ) == 0 ) { return [[traits]] ; } if ( [[traits]] . startsWith ( [[tether]] ) ) { return [[traits]] ; } return [[tether]] + [[traits]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 163 ---------------------------------------------
Creates a user details resource factory from an in memory . --> We use an inMemoryResourceFactory to use an InMemoryWatchResourceFactory . --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String [[users]] ) { InMemoryResource [[resource]] = new InMemoryResource ( [[users]] ) ; return fromResource ( [[resource]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[deathwatch]] ( String [[patrons]] ) { InMemoryResource [[source]] = new InMemoryResource ( [[patrons]] ) ; return fromResource ( [[source]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 164 ---------------------------------------------
Get all values for a given attribute name . --> Checks to see if there exists exits --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[name]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[exits]] ( String [[nominated]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[nominated]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 165 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 157 / 6 / 2 / 165:  16%|█▋        | 165/1000 [1:16:44<6:28:20, 27.91s/it][Succeeded / Failed / Skipped / Total] 157 / 6 / 2 / 165:  17%|█▋        | 166/1000 [1:17:57<6:31:38, 28.18s/it][Succeeded / Failed / Skipped / Total] 158 / 6 / 2 / 166:  17%|█▋        | 166/1000 [1:17:57<6:31:38, 28.18s/it][Succeeded / Failed / Skipped / Total] 158 / 6 / 2 / 166:  17%|█▋        | 167/1000 [1:18:17<6:30:30, 28.13s/it][Succeeded / Failed / Skipped / Total] 159 / 6 / 2 / 167:  17%|█▋        | 167/1000 [1:18:17<6:30:30, 28.13s/it][Succeeded / Failed / Skipped / Total] 159 / 6 / 2 / 167:  17%|█▋        | 168/1000 [1:18:33<6:29:05, 28.06s/it][Succeeded / Failed / Skipped / Total] 160 / 6 / 2 / 168:  17%|█▋        | 168/1000 [1:18:33<6:29:05, 28.06s/it][Succeeded / Failed / Skipped / Total] 160 / 6 / 2 / 168:  17%|█▋        | 169/1000 [1:19:04<6:28:47, 28.07s/it][Succeeded / Failed / Skipped / Total] 161 / 6 / 2 / 169:  17%|█▋        | 169/1000 [1:19:04<6:28:47, 28.07s/it][Succeeded / Failed / Skipped / Total] 161 / 6 / 2 / 169:  17%|█▋        | 170/1000 [1:19:10<6:26:31, 27.94s/it][Succeeded / Failed / Skipped / Total] 162 / 6 / 2 / 170:  17%|█▋        | 170/1000 [1:19:10<6:26:31, 27.94s/it][Succeeded / Failed / Skipped / Total] 162 / 6 / 2 / 170:  17%|█▋        | 171/1000 [1:19:49<6:27:00, 28.01s/it][Succeeded / Failed / Skipped / Total] 163 / 6 / 2 / 171:  17%|█▋        | 171/1000 [1:19:49<6:27:00, 28.01s/it][Succeeded / Failed / Skipped / Total] 163 / 6 / 2 / 171:  17%|█▋        | 172/1000 [1:19:53<6:24:36, 27.87s/it]Get the first attribute value . --> Convenience method to figure out behalf . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > [[result]] = getAttributeValues ( [[name]] ) ; if ( [[result]] . isEmpty ( ) ) { return null ; } else { return [[result]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[uncultured]] ( String [[behalf]] ) { List < String > [[concluding]] = getAttributeValues ( [[behalf]] ) ; if ( [[concluding]] . isEmpty ( ) ) { return null ; } else { return [[concluding]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 166 ---------------------------------------------
Encodes a string into a byte array . --> encodes a CharSequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] [[bytesCopy]] = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , [[bytesCopy]] , 0 , bytes . limit ( ) ) ; return [[bytesCopy]] ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[filaments]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[filaments]] ) ) ; byte [ ] [[rosenberger]] = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , [[rosenberger]] , 0 , bytes . limit ( ) ) ; return [[rosenberger]] ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 167 ---------------------------------------------
Load user by assertion . --> Checks whether we know what we know what? --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken [[token]] = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . [[authenticationUserDetailsService]] . loadUserDetails ( [[token]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[knowwhat]] ( final Assertion [[reaffirm]] ) { final CasAssertionAuthenticationToken [[nameplate]] = new CasAssertionAuthenticationToken ( [[reaffirm]] , "" ) ; return this . [[carefree]] . loadUserDetails ( [[nameplate]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 168 ---------------------------------------------
Decode the given bytes . --> Decodes hieroglyph --> Socre: 1.0

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[hieroglyphs]] ( byte [ ] [[crypto]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[crypto]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 169 ---------------------------------------------
Add new contact --> Add contacts --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact [[form]] , BindingResult result ) { validator . validate ( [[form]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[reminiscing]] ( WebContact [[typing]] , BindingResult result ) { validator . validate ( [[typing]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[liaisons]] = new Contact ( [[typing]] . getName ( ) , [[typing]] . getEmail ( ) ) ; contactManager . create ( [[liaisons]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 170 ---------------------------------------------
Returns all config attributes specified for the target method --> Determine all configuration attributes that are specified in parameter --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[kiitos]] ( Method method , Class < ? > [[silhouetted]] ) { if ( [[silhouetted]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[silhouetted]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 171 ---------------------------------------------
Adds a new secure method . --> documentation inherited from interface Security --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[mapplethorpe]] ( RegisteredMethod [[forma]] , List < ConfigAttribute > [[º]] ) { Assert . notNull ( [[forma]] , "RegisteredMethod required" ) ; Assert . notNull ( [[º]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[forma]] + "] with attributes [" + [[º]] + "]" ) ; } this . [[longbow]] . put ( [[forma]] , [[º]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 172 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 164 / 6 / 2 / 172:  17%|█▋        | 172/1000 [1:19:53<6:24:36, 27.87s/it][Succeeded / Failed / Skipped / Total] 164 / 6 / 2 / 172:  17%|█▋        | 173/1000 [1:20:01<6:22:30, 27.75s/it][Succeeded / Failed / Skipped / Total] 165 / 6 / 2 / 173:  17%|█▋        | 173/1000 [1:20:01<6:22:30, 27.75s/it][Succeeded / Failed / Skipped / Total] 165 / 6 / 2 / 173:  17%|█▋        | 174/1000 [1:20:07<6:20:23, 27.63s/it][Succeeded / Failed / Skipped / Total] 166 / 6 / 2 / 174:  17%|█▋        | 174/1000 [1:20:07<6:20:23, 27.63s/it][Succeeded / Failed / Skipped / Total] 166 / 6 / 2 / 174:  18%|█▊        | 175/1000 [1:21:46<6:25:32, 28.04s/it][Succeeded / Failed / Skipped / Total] 167 / 6 / 2 / 175:  18%|█▊        | 175/1000 [1:21:46<6:25:32, 28.04s/it][Succeeded / Failed / Skipped / Total] 167 / 6 / 2 / 175:  18%|█▊        | 176/1000 [1:21:49<6:23:05, 27.90s/it][Succeeded / Failed / Skipped / Total] 168 / 6 / 2 / 176:  18%|█▊        | 176/1000 [1:21:49<6:23:05, 27.90s/it][Succeeded / Failed / Skipped / Total] 168 / 6 / 2 / 176:  18%|█▊        | 177/1000 [1:21:56<6:21:00, 27.78s/it][Succeeded / Failed / Skipped / Total] 169 / 6 / 2 / 177:  18%|█▊        | 177/1000 [1:21:56<6:21:00, 27.78s/it][Succeeded / Failed / Skipped / Total] 169 / 6 / 2 / 177:  18%|█▊        | 178/1000 [1:22:12<6:19:39, 27.71s/it][Succeeded / Failed / Skipped / Total] 170 / 6 / 2 / 178:  18%|█▊        | 178/1000 [1:22:12<6:19:39, 27.71s/it][Succeeded / Failed / Skipped / Total] 170 / 6 / 2 / 178:  18%|█▊        | 179/1000 [1:22:31<6:18:30, 27.66s/it]Look up parameter names for the given object . --> Look up parameters for a given type --> Socre: 1.0

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int [[i]] = 0 ; [[i]] < parameterCount ; [[i]] ++ ) { Annotation [ ] annotations = parameterAnnotations [ [[i]] ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "[[True]]" == "[[True]]" ; paramNames [ [[i]] ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int [[uh]] = 0 ; [[uh]] < parameterCount ; [[uh]] ++ ) { Annotation [ ] annotations = parameterAnnotations [ [[uh]] ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "[[Presentable]]" == "[[Presentable]]" ; paramNames [ [[uh]] ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 173 ---------------------------------------------
Get all config attributes . --> Retrieves a set of dents --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { [[allAttributes]] . addAll ( [[attributeList]] ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[vincente]] ( ) { Set < ConfigAttribute > [[duk]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[flirt]] : methodMap . values ( ) ) { [[duk]] . addAll ( [[flirt]] ) ; } return [[duk]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 174 ---------------------------------------------
Sets any request that matches any request . --> Sets the birthmark --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "[[True]]" == "[[True]]" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[birthmark]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C [[manatees]] = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "[[Genuine]]" == "[[Genuine]]" ; return [[manatees]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 175 ---------------------------------------------
Checks if the method name is match . --> Determine whether or not a gene is an angel file --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[angelou]] ( String [[mohan]] , String [[chileans]] ) { return ( [[chileans]] . endsWith ( "*" ) && [[mohan]] . startsWith ( [[chileans]] . substring ( 0 , [[chileans]] . length ( ) - 1 ) ) ) || ( [[chileans]] . startsWith ( "*" ) && [[mohan]] . endsWith ( [[chileans]] . substring ( 1 , [[chileans]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 176 ---------------------------------------------
Get a random contact --> Get random contacts --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact [[getRandomContact]] ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[getNumber]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[getNumber]] ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact [[recruiters]] ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[collines]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[collines]] ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 177 ---------------------------------------------
Clear authentication attributes . --> Remove AuthenticationExpirationException --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest request ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[needa]] ( HttpServletRequest request ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 178 ---------------------------------------------
Gets the shared object . --> get the instance of the given type --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[craig]] > [[craig]] getSharedObject ( Class < [[craig]] > sharedType ) { return ( [[craig]] ) this . [[bugatti]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 179 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 6 / 2 / 179:  18%|█▊        | 179/1000 [1:22:31<6:18:30, 27.66s/it][Succeeded / Failed / Skipped / Total] 171 / 6 / 2 / 179:  18%|█▊        | 180/1000 [1:22:55<6:17:47, 27.64s/it][Succeeded / Failed / Skipped / Total] 172 / 6 / 2 / 180:  18%|█▊        | 180/1000 [1:22:55<6:17:47, 27.64s/it][Succeeded / Failed / Skipped / Total] 172 / 6 / 2 / 180:  18%|█▊        | 181/1000 [1:23:10<6:16:21, 27.57s/it][Succeeded / Failed / Skipped / Total] 173 / 6 / 2 / 181:  18%|█▊        | 181/1000 [1:23:10<6:16:21, 27.57s/it][Succeeded / Failed / Skipped / Total] 173 / 6 / 2 / 181:  18%|█▊        | 182/1000 [1:23:46<6:16:32, 27.62s/it][Succeeded / Failed / Skipped / Total] 174 / 6 / 2 / 182:  18%|█▊        | 182/1000 [1:23:46<6:16:32, 27.62s/it][Succeeded / Failed / Skipped / Total] 174 / 6 / 2 / 182:  18%|█▊        | 183/1000 [1:23:49<6:14:15, 27.49s/it][Succeeded / Failed / Skipped / Total] 175 / 6 / 2 / 183:  18%|█▊        | 183/1000 [1:23:49<6:14:15, 27.49s/it][Succeeded / Failed / Skipped / Total] 175 / 6 / 2 / 183:  18%|█▊        | 184/1000 [1:23:52<6:11:55, 27.35s/it][Succeeded / Failed / Skipped / Total] 176 / 6 / 2 / 184:  18%|█▊        | 184/1000 [1:23:52<6:11:55, 27.35s/it][Succeeded / Failed / Skipped / Total] 176 / 6 / 2 / 184:  18%|█▊        | 185/1000 [1:24:02<6:10:12, 27.25s/it][Succeeded / Failed / Skipped / Total] 177 / 6 / 2 / 185:  18%|█▊        | 185/1000 [1:24:02<6:10:12, 27.25s/it][Succeeded / Failed / Skipped / Total] 177 / 6 / 2 / 185:  19%|█▊        | 186/1000 [1:24:23<6:09:20, 27.22s/it]Gets a field from a class . --> Liefert de la clazze --> Socre: 1.0

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > clazz , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return clazz . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[clarke]] ( Class < ? > clazz , String [[aleta]] ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( [[aleta]] , "Field name required" ) ; try { return clazz . getDeclaredField ( [[aleta]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 180 ---------------------------------------------
Create the redirect url . --> Redababulary --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String [[serviceUrl]] ) { return CommonUtils . constructRedirectUrl ( this . [[loginUrl]] , this . [[serviceProperties]] . getServiceParameter ( ) , [[serviceUrl]] , this . [[serviceProperties]] . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[constabulary]] ( final String [[iight]] ) { return CommonUtils . constructRedirectUrl ( this . [[thunderbirds]] , this . [[rosana]] . getServiceParameter ( ) , [[iight]] , this . [[rosana]] . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 181 ---------------------------------------------
Extract prefix . --> This method is used to extract a tea markup from a string --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[rawlins]] ( String [[sweetums]] ) { if ( ! [[sweetums]] . startsWith ( "{" ) ) { return null ; } int [[ishaan]] = [[sweetums]] . lastIndexOf ( ' ' ) ; if ( [[ishaan]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[sweetums]] . substring ( 0 , [[ishaan]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 182 ---------------------------------------------
Handle bind exception . --> do controller action --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String [[userDn]] , String [[username]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[userDn]] + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[action]] ( String [[senor]] , String [[customer]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[senor]] + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 183 ---------------------------------------------
Checks the stack . --> Check stack . --> Socre: 1.0

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[entrapment]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[entrapment]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[entrapment]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[entrapment]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[entrapment]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[entrapment]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[entrapment]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[entrapment]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[entrapment]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 184 ---------------------------------------------
Returns the registered types . --> Arrays as Arrays --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . extractorMap . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[harpooned]] ( ) { Set < Class < ? extends Throwable > > [[bravissimo]] = this . extractorMap . keySet ( ) ; return [[bravissimo]] . toArray ( new Class [ [[bravissimo]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 185 ---------------------------------------------
Create service url . -->  Duckling request --> Socre: 1.0

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . [[serviceProperties]] . getService ( ) , null , this . [[serviceProperties]] . getArtifactParameter ( ) , this . [[encodeServiceUrlWithSessionId]] ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[duckling]] ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . [[trop]] . getService ( ) , null , this . [[trop]] . getArtifactParameter ( ) , this . [[steno]] ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 186 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 178 / 6 / 2 / 186:  19%|█▊        | 186/1000 [1:24:23<6:09:20, 27.22s/it][Succeeded / Failed / Skipped / Total] 178 / 6 / 2 / 186:  19%|█▊        | 187/1000 [1:24:44<6:08:24, 27.19s/it][Succeeded / Failed / Skipped / Total] 179 / 6 / 2 / 187:  19%|█▊        | 187/1000 [1:24:44<6:08:24, 27.19s/it][Succeeded / Failed / Skipped / Total] 179 / 6 / 2 / 187:  19%|█▉        | 188/1000 [1:24:47<6:06:12, 27.06s/it][Succeeded / Failed / Skipped / Total] 180 / 6 / 2 / 188:  19%|█▉        | 188/1000 [1:24:47<6:06:12, 27.06s/it][Succeeded / Failed / Skipped / Total] 180 / 6 / 2 / 188:  19%|█▉        | 189/1000 [1:25:54<6:08:39, 27.27s/it][Succeeded / Failed / Skipped / Total] 181 / 6 / 2 / 189:  19%|█▉        | 189/1000 [1:25:54<6:08:39, 27.27s/it][Succeeded / Failed / Skipped / Total] 181 / 6 / 2 / 189:  19%|█▉        | 190/1000 [1:25:56<6:06:21, 27.14s/it][Succeeded / Failed / Skipped / Total] 182 / 6 / 2 / 190:  19%|█▉        | 190/1000 [1:25:56<6:06:21, 27.14s/it][Succeeded / Failed / Skipped / Total] 182 / 6 / 2 / 190:  19%|█▉        | 191/1000 [1:26:08<6:04:52, 27.06s/it][Succeeded / Failed / Skipped / Total] 183 / 6 / 2 / 191:  19%|█▉        | 191/1000 [1:26:08<6:04:52, 27.06s/it][Succeeded / Failed / Skipped / Total] 183 / 6 / 2 / 191:  19%|█▉        | 192/1000 [1:26:20<6:03:23, 26.98s/it]Register accessManager . --> generates carta --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[registerAccessManager]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder [[accessMgrBuilder]] = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } [[accessMgrBuilder]] . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = [[accessMgrBuilder]] . getBeanDefinition ( ) ; String [[id]] = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , [[id]] ) ) ; return [[id]] ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[carta]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder [[chrissie]] = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } [[chrissie]] . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = [[chrissie]] . getBeanDefinition ( ) ; String [[determining]] = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , [[determining]] ) ) ; return [[determining]] ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 187 ---------------------------------------------
Extracts the cause of a throwable . --> Attempt to extract a wavelet from a wavelength --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[throwableType]] = [[entry]] . getKey ( ) ; if ( [[throwableType]] . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor extractor = [[entry]] . getValue ( ) ; return extractor . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[reef]] ( Throwable [[wavelengths]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[admission]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[pardner]] = [[admission]] . getKey ( ) ; if ( [[pardner]] . isInstance ( [[wavelengths]] ) ) { ThrowableCauseExtractor extractor = [[admission]] . getValue ( ) ; return extractor . extractCause ( [[wavelengths]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 188 ---------------------------------------------
Compares two byte arrays . --> Compare two bytes --> Socre: 1.0

[[[[Adv]]]]: private boolean [[matches]] ( byte [ ] expected , byte [ ] [[actual]] ) { if ( expected . length != [[actual]] . length ) { return "False" != "False" ; } int result = 0 ; for ( int [[i]] = 0 ; [[i]] < expected . length ; [[i]] ++ ) { result |= expected [ [[i]] ] ^ [[actual]] [ [[i]] ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean [[coincide]] ( byte [ ] expected , byte [ ] [[actually]] ) { if ( expected . length != [[actually]] . length ) { return "False" != "False" ; } int result = 0 ; for ( int [[al]] = 0 ; [[al]] < expected . length ; [[al]] ++ ) { result |= expected [ [[al]] ] ^ [[actually]] [ [[al]] ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 189 ---------------------------------------------
Called by the pre - authenticated entry point . --> Handles an invitation --> Socre: 1.0

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , AuthenticationException [[arg2]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[response]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[undertook]] ( HttpServletRequest [[invitation]] , HttpServletResponse [[comments]] , AuthenticationException [[wozniak]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[comments]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 190 ---------------------------------------------
Sets the default failure url . --> Convenience method to paint an inscription --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . [[defaultFailureUrl]] = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[manganese]] ( String [[ornament]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[ornament]] ) , ( ) -> "'" + [[ornament]] + "' is not a valid redirect URL" ) ; this . [[radioshack]] = [[ornament]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 191 ---------------------------------------------
Build request URL --> Create a hot mail --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String [[servletPath]] , String requestURI , String contextPath , String [[pathInfo]] , String [[queryString]] ) { StringBuilder [[url]] = new StringBuilder ( ) ; if ( [[servletPath]] != null ) { [[url]] . append ( [[servletPath]] ) ; if ( [[pathInfo]] != null ) { [[url]] . append ( [[pathInfo]] ) ; } } else { [[url]] . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( [[queryString]] != null ) { [[url]] . append ( "?" ) . append ( [[queryString]] ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[slithered]] ( String [[surcharge]] , String requestURI , String contextPath , String [[sharin]] , String [[rahm]] ) { StringBuilder [[hotmail]] = new StringBuilder ( ) ; if ( [[surcharge]] != null ) { [[hotmail]] . append ( [[surcharge]] ) ; if ( [[sharin]] != null ) { [[hotmail]] . append ( [[sharin]] ) ; } } else { [[hotmail]] . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( [[rahm]] != null ) { [[hotmail]] . append ( "?" ) . append ( [[rahm]] ) ; } return [[hotmail]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 192 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 184 / 6 / 2 / 192:  19%|█▉        | 192/1000 [1:26:20<6:03:23, 26.98s/it][Succeeded / Failed / Skipped / Total] 184 / 6 / 2 / 192:  19%|█▉        | 193/1000 [1:31:40<6:23:18, 28.50s/it][Succeeded / Failed / Skipped / Total] 185 / 6 / 2 / 193:  19%|█▉        | 193/1000 [1:31:40<6:23:18, 28.50s/it][Succeeded / Failed / Skipped / Total] 185 / 6 / 2 / 193:  19%|█▉        | 194/1000 [1:31:52<6:21:41, 28.41s/it][Succeeded / Failed / Skipped / Total] 186 / 6 / 2 / 194:  19%|█▉        | 194/1000 [1:31:52<6:21:41, 28.41s/it][Succeeded / Failed / Skipped / Total] 186 / 6 / 2 / 194:  20%|█▉        | 195/1000 [1:32:10<6:20:31, 28.36s/it][Succeeded / Failed / Skipped / Total] 187 / 6 / 2 / 195:  20%|█▉        | 195/1000 [1:32:10<6:20:31, 28.36s/it][Succeeded / Failed / Skipped / Total] 187 / 6 / 2 / 195:  20%|█▉        | 196/1000 [1:32:19<6:18:42, 28.26s/it][Succeeded / Failed / Skipped / Total] 188 / 6 / 2 / 196:  20%|█▉        | 196/1000 [1:32:19<6:18:42, 28.26s/it][Succeeded / Failed / Skipped / Total] 188 / 6 / 2 / 196:  20%|█▉        | 197/1000 [1:32:36<6:17:29, 28.21s/it]Sets the value of the hidden inputs . --> Enables elvisibility --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[elvis]] ( Function < HttpServletRequest , Map < String , String > > [[kamen]] ) { Assert . notNull ( [[kamen]] , "resolveHiddenInputs cannot be null" ) ; this . [[seymour]] = [[kamen]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 193 ---------------------------------------------
Convert a collection of user authorities to a Set . --> Return the Goodbyes --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[userAuthorities]] ) { set . add ( [[authority]] . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[goodbyes]] ( Collection < ? extends GrantedAuthority > [[carcasses]] ) { Assert . notNull ( [[carcasses]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[carcasses]] . size ( ) ) ; for ( GrantedAuthority [[agency]] : [[carcasses]] ) { set . add ( [[agency]] . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 194 ---------------------------------------------
Extracts the identifier from the given result set . --> Convert a result set to a serializable identifier --> Socre: 1.0

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[identifier]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[marvels]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[marvels]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[marvels]] = convertFromStringTo ( ( String ) [[marvels]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 195 ---------------------------------------------
Insert entries in acl . --> Inserts anagram --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl [[acl]] ) { if ( [[acl]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[acl]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement [[stmt]] , int [[i]] ) throws SQLException { AccessControlEntry entry_ = [[acl]] . getEntries ( ) . get ( [[i]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; [[stmt]] . setLong ( 1 , ( ( Long ) [[acl]] . getId ( ) ) . longValue ( ) ) ; [[stmt]] . setInt ( 2 , [[i]] ) ; [[stmt]] . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; [[stmt]] . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; [[stmt]] . setBoolean ( 5 , entry . isGranting ( ) ) ; [[stmt]] . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; [[stmt]] . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[anagram]] ( final MutableAcl [[patella]] ) { if ( [[patella]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[patella]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement [[frilly]] , int [[let]] ) throws SQLException { AccessControlEntry entry_ = [[patella]] . getEntries ( ) . get ( [[let]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; [[frilly]] . setLong ( 1 , ( ( Long ) [[patella]] . getId ( ) ) . longValue ( ) ) ; [[frilly]] . setInt ( 2 , [[let]] ) ; [[frilly]] . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; [[frilly]] . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; [[frilly]] . setBoolean ( 5 , entry . isGranting ( ) ) ; [[frilly]] . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; [[frilly]] . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 196 ---------------------------------------------
Store object identity . --> Convert cosby to cosby --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid [[owner]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[owner]] , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[cosby]] ( ObjectIdentity object , Sid [[bearer]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[bearer]] , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 197 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 189 / 6 / 2 / 197:  20%|█▉        | 197/1000 [1:32:36<6:17:29, 28.21s/it][Succeeded / Failed / Skipped / Total] 189 / 6 / 2 / 197:  20%|█▉        | 198/1000 [1:32:45<6:15:44, 28.11s/it][Succeeded / Failed / Skipped / Total] 190 / 6 / 2 / 198:  20%|█▉        | 198/1000 [1:32:45<6:15:44, 28.11s/it][Succeeded / Failed / Skipped / Total] 190 / 6 / 2 / 198:  20%|█▉        | 199/1000 [1:34:04<6:18:38, 28.36s/it][Succeeded / Failed / Skipped / Total] 191 / 6 / 2 / 199:  20%|█▉        | 199/1000 [1:34:04<6:18:39, 28.36s/it][Succeeded / Failed / Skipped / Total] 191 / 6 / 2 / 199:  20%|██        | 200/1000 [1:34:06<6:16:24, 28.23s/it][Succeeded / Failed / Skipped / Total] 192 / 6 / 2 / 200:  20%|██        | 200/1000 [1:34:06<6:16:24, 28.23s/it][Succeeded / Failed / Skipped / Total] 192 / 6 / 2 / 200:  20%|██        | 201/1000 [1:34:09<6:14:19, 28.11s/it][Succeeded / Failed / Skipped / Total] 193 / 6 / 2 / 201:  20%|██        | 201/1000 [1:34:09<6:14:19, 28.11s/it][Succeeded / Failed / Skipped / Total] 193 / 6 / 2 / 201:  20%|██        | 202/1000 [1:34:34<6:13:35, 28.09s/it][Succeeded / Failed / Skipped / Total] 194 / 6 / 2 / 202:  20%|██        | 202/1000 [1:34:34<6:13:35, 28.09s/it][Succeeded / Failed / Skipped / Total] 194 / 6 / 2 / 202:  20%|██        | 203/1000 [1:35:44<6:15:54, 28.30s/it][Succeeded / Failed / Skipped / Total] 195 / 6 / 2 / 203:  20%|██        | 203/1000 [1:35:44<6:15:54, 28.30s/it][Succeeded / Failed / Skipped / Total] 195 / 6 / 2 / 203:  20%|██        | 204/1000 [1:36:50<6:17:50, 28.48s/it]Update an object identity --> Update insipid --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl [[oii]] = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( [[oii]] ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "[[True]]" == "[[True]]" ) ; int count = jdbcOperations . update ( [[updateObjectIdentity]] , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[insipid]] ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl [[oafs]] = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( [[oafs]] ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "[[Realistic]]" == "[[Realistic]]" ) ; int count = jdbcOperations . update ( [[insipid]] , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 198 ---------------------------------------------
Checks if is an absolute URL . --> Methode permutation --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String url ) { if ( url == null ) { return "[[False]]" != "[[False]]" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[mãe]] ( String url ) { if ( url == null ) { return "[[Dishonest]]" != "[[Dishonest]]" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 199 ---------------------------------------------
Saves the current request . --> Vour --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest [[savedRequest]] = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[vour]] ( HttpServletRequest [[wondering]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[wondering]] ) ) { DefaultSavedRequest [[imperceptible]] = new DefaultSavedRequest ( [[wondering]] , portResolver ) ; if ( createSessionAllowed || [[wondering]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 200 ---------------------------------------------
Matches any any exchange matcher . --> Matching matcher --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 201 ---------------------------------------------
Creates a decryptor with the given password and a salt . --> Create Fernetryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[frenchman]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 202 ---------------------------------------------
Creates a matcher for the given path patterns . --> constructor for micron --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod [[method]] , String ... patterns ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[mic]] ( HttpMethod [[modus]] , String ... patterns ) { List < ServerWebExchangeMatcher > [[vão]] = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { [[vão]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , [[modus]] ) ) ; } return new OrServerWebExchangeMatcher ( [[vão]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 203 ---------------------------------------------
Creates an encryptor . --> exryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[password]] . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[nikko]] ( CharSequence [[numeric]] , CharSequence [[ammonium]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[numeric]] . toString ( ) , [[ammonium]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 204 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 196 / 6 / 2 / 204:  20%|██        | 204/1000 [1:36:50<6:17:50, 28.48s/it][Succeeded / Failed / Skipped / Total] 196 / 6 / 2 / 204:  20%|██        | 205/1000 [1:36:54<6:15:47, 28.36s/it][Succeeded / Failed / Skipped / Total] 197 / 6 / 2 / 205:  20%|██        | 205/1000 [1:36:54<6:15:47, 28.36s/it][Succeeded / Failed / Skipped / Total] 197 / 6 / 2 / 205:  21%|██        | 206/1000 [1:36:59<6:13:52, 28.25s/it][Succeeded / Failed / Skipped / Total] 198 / 6 / 2 / 206:  21%|██        | 206/1000 [1:36:59<6:13:52, 28.25s/it][Succeeded / Failed / Skipped / Total] 198 / 6 / 2 / 206:  21%|██        | 207/1000 [1:37:16<6:12:38, 28.19s/it][Succeeded / Failed / Skipped / Total] 199 / 6 / 2 / 207:  21%|██        | 207/1000 [1:37:16<6:12:38, 28.19s/it][Succeeded / Failed / Skipped / Total] 199 / 6 / 2 / 207:  21%|██        | 208/1000 [1:37:19<6:10:35, 28.08s/it][Succeeded / Failed / Skipped / Total] 200 / 6 / 2 / 208:  21%|██        | 208/1000 [1:37:19<6:10:35, 28.08s/it][Succeeded / Failed / Skipped / Total] 200 / 6 / 2 / 208:  21%|██        | 209/1000 [1:38:48<6:13:59, 28.37s/it][Succeeded / Failed / Skipped / Total] 201 / 6 / 2 / 209:  21%|██        | 209/1000 [1:38:48<6:13:59, 28.37s/it][Succeeded / Failed / Skipped / Total] 201 / 6 / 2 / 209:  21%|██        | 210/1000 [1:39:01<6:12:31, 28.29s/it][Succeeded / Failed / Skipped / Total] 202 / 6 / 2 / 210:  21%|██        | 210/1000 [1:39:01<6:12:31, 28.29s/it][Succeeded / Failed / Skipped / Total] 202 / 6 / 2 / 210:  21%|██        | 211/1000 [1:41:16<6:18:40, 28.80s/it]Write headers to response . --> Protected setting --> Socre: 1.0

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[moat]] ( HttpServletRequest request , HttpServletResponse [[retaliated]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! [[retaliated]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[retaliated]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! [[retaliated]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[retaliated]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { [[retaliated]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 205 ---------------------------------------------
Determine the target URL . --> Performs pax request for pax . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[pax]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[pax]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 206 ---------------------------------------------
Determines the target URL . --> Do not use default targetUrl --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[lane]] ( HttpServletRequest request , HttpServletResponse [[cope]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 207 ---------------------------------------------
Sets the target URL parameter . --> Old html version --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . [[targetUrlParameter]] = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[oldham]] ( String [[nyu]] ) { if ( [[nyu]] != null ) { Assert . hasText ( [[nyu]] , "targetUrlParameter cannot be empty" ) ; } this . [[prego]] = [[nyu]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 208 ---------------------------------------------
Retrieves the directory with the given id . --> Returns the few years . --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int [[rowNumber]] ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory [[parentDirectory]] = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[fewyears]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int [[ballets]] ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory [[cops]] = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 209 ---------------------------------------------
Builds the distinguished name with the given username . --> Creates a new DistinguishedName with a customer --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String [[username]] ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , [[username]] ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[dustman]] ( String [[customer]] ) { DistinguishedName [[nl]] = new DistinguishedName ( userDnBase ) ; [[nl]] . add ( usernameAttribute , [[customer]] ) ; return [[nl]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 210 ---------------------------------------------
Creates shared objects . --> used in tests --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[igh]] ( ) { Map < Class < ? extends Object > , Object > [[contemptible]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[contemptible]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[contemptible]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[contemptible]] . put ( ApplicationContext . class , context ) ; [[contemptible]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[contemptible]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[contemptible]] ; }
[[[[Nl]]]]: Creates the shared objects
[Succeeded / Failed / Skipped / Total] 203 / 6 / 2 / 211:  21%|██        | 211/1000 [1:41:16<6:18:40, 28.80s/it][Succeeded / Failed / Skipped / Total] 203 / 6 / 2 / 211:  21%|██        | 212/1000 [1:41:36<6:17:42, 28.76s/it][Succeeded / Failed / Skipped / Total] 204 / 6 / 2 / 212:  21%|██        | 212/1000 [1:41:36<6:17:42, 28.76s/it][Succeeded / Failed / Skipped / Total] 204 / 6 / 2 / 212:  21%|██▏       | 213/1000 [1:41:42<6:15:47, 28.65s/it][Succeeded / Failed / Skipped / Total] 205 / 6 / 2 / 213:  21%|██▏       | 213/1000 [1:41:42<6:15:47, 28.65s/it][Succeeded / Failed / Skipped / Total] 205 / 6 / 2 / 213:  21%|██▏       | 214/1000 [1:41:50<6:14:03, 28.55s/it][Succeeded / Failed / Skipped / Total] 206 / 6 / 2 / 214:  21%|██▏       | 214/1000 [1:41:50<6:14:03, 28.55s/it][Succeeded / Failed / Skipped / Total] 206 / 6 / 2 / 214:  22%|██▏       | 215/1000 [1:42:06<6:12:47, 28.49s/it][Succeeded / Failed / Skipped / Total] 207 / 6 / 2 / 215:  22%|██▏       | 215/1000 [1:42:06<6:12:47, 28.49s/it][Succeeded / Failed / Skipped / Total] 207 / 6 / 2 / 215:  22%|██▏       | 216/1000 [1:45:18<6:22:15, 29.25s/it][Succeeded / Failed / Skipped / Total] 208 / 6 / 2 / 216:  22%|██▏       | 216/1000 [1:45:18<6:22:15, 29.25s/it][Succeeded / Failed / Skipped / Total] 208 / 6 / 2 / 216:  22%|██▏       | 217/1000 [1:45:26<6:20:27, 29.15s/it][Succeeded / Failed / Skipped / Total] 209 / 6 / 2 / 217:  22%|██▏       | 217/1000 [1:45:26<6:20:27, 29.15s/it][Succeeded / Failed / Skipped / Total] 209 / 6 / 2 / 217:  22%|██▏       | 218/1000 [1:51:21<6:39:28, 30.65s/it]--------------------------------------------- Result 211 ---------------------------------------------
Sets the JAAS using login configuration . --> configure JAAS --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[loginConfigUrl]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "[[False]]" != "[[False]]" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( [[loginConfigUrl]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + [[loginConfigUrl]] ) ; Security . setProperty ( key , [[loginConfigUrl]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[carcinogenic]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "[[Doctored]]" != "[[Doctored]]" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( [[carcinogenic]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + [[carcinogenic]] ) ; Security . setProperty ( key , [[carcinogenic]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 212 ---------------------------------------------
Get current date . --> This method is used to simulate nicking --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[nicking]] ( ) { long [[anymore]] = System . currentTimeMillis ( ) ; if ( ( [[anymore]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[anymore]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[anymore]] ; currentDate = format . format ( new Date ( [[anymore]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 213 ---------------------------------------------
Internal method to parse a date value . --> jacint - time --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] [[formats]] ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { date = [[formats]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[jacinta]] ( String value , DateFormat [ ] [[method]] ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < [[method]] . length ) ; i ++ ) { try { date = [[method]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 214 ---------------------------------------------
Updates the cache . --> Fill the secret in the secret map --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object key , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( key , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[phoenix]] ( HashMap [[secret]] , Object key , Object [[invaluable]] ) { if ( [[invaluable]] == null ) { return ; } if ( [[secret]] . size ( ) > 1000 ) { [[secret]] . clear ( ) ; } [[secret]] . put ( key , [[invaluable]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 215 ---------------------------------------------
Sets the authentication details . --> Build waterbed token --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest [[request]] , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[waterbed]] ( HttpServletRequest [[calling]] , UsernamePasswordAuthenticationToken [[committed]] ) { [[committed]] . setDetails ( authenticationDetailsSource . buildDetails ( [[calling]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 216 ---------------------------------------------
Creates an attribute list for the given identifier . --> renew all OpenID --> Socre: 1.0

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String [[identifier]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( [[identifier]] ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[renewing]] ( String [[martín]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( [[martín]] ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 217 ---------------------------------------------
Returns the list of groups associated with the specified security name . --> Convenience method to convert to pearson --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[pearson]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 218 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 210 / 6 / 2 / 218:  22%|██▏       | 218/1000 [1:51:21<6:39:28, 30.65s/it][Succeeded / Failed / Skipped / Total] 210 / 6 / 2 / 218:  22%|██▏       | 219/1000 [1:51:38<6:38:09, 30.59s/it][Succeeded / Failed / Skipped / Total] 211 / 6 / 2 / 219:  22%|██▏       | 219/1000 [1:51:38<6:38:09, 30.59s/it][Succeeded / Failed / Skipped / Total] 211 / 6 / 2 / 219:  22%|██▏       | 220/1000 [1:52:54<6:40:18, 30.79s/it][Succeeded / Failed / Skipped / Total] 212 / 6 / 2 / 220:  22%|██▏       | 220/1000 [1:52:54<6:40:18, 30.79s/it][Succeeded / Failed / Skipped / Total] 212 / 6 / 2 / 220:  22%|██▏       | 221/1000 [1:53:02<6:38:26, 30.69s/it][Succeeded / Failed / Skipped / Total] 213 / 6 / 2 / 221:  22%|██▏       | 221/1000 [1:53:02<6:38:26, 30.69s/it][Succeeded / Failed / Skipped / Total] 213 / 6 / 2 / 221:  22%|██▏       | 222/1000 [1:53:22<6:37:20, 30.64s/it][Succeeded / Failed / Skipped / Total] 214 / 6 / 2 / 222:  22%|██▏       | 222/1000 [1:53:22<6:37:20, 30.64s/it][Succeeded / Failed / Skipped / Total] 214 / 6 / 2 / 222:  22%|██▏       | 223/1000 [1:53:25<6:35:13, 30.52s/it][Succeeded / Failed / Skipped / Total] 215 / 6 / 2 / 223:  22%|██▏       | 223/1000 [1:53:25<6:35:13, 30.52s/it][Succeeded / Failed / Skipped / Total] 215 / 6 / 2 / 223:  22%|██▏       | 224/1000 [1:53:33<6:33:25, 30.42s/it][Succeeded / Failed / Skipped / Total] 216 / 6 / 2 / 224:  22%|██▏       | 224/1000 [1:53:33<6:33:25, 30.42s/it][Succeeded / Failed / Skipped / Total] 216 / 6 / 2 / 224:  22%|██▎       | 225/1000 [1:54:09<6:33:12, 30.44s/it][Succeeded / Failed / Skipped / Total] 217 / 6 / 2 / 225:  22%|██▎       | 225/1000 [1:54:09<6:33:12, 30.44s/it][Succeeded / Failed / Skipped / Total] 217 / 6 / 2 / 225:  23%|██▎       | 226/1000 [1:54:17<6:31:23, 30.34s/it]Creates a text encryptor . --> Create lexicon --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[lexicon]] ( CharSequence [[login]] , CharSequence [[sulfate]] ) { return new HexEncodingTextEncryptor ( standard ( [[login]] , [[sulfate]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 219 ---------------------------------------------
Build the DN for the group . --> build the kaffirs for groupSearch --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[kaffirs]] ( String [[consortium]] ) { DistinguishedName [[sm]] = new DistinguishedName ( groupSearchBase ) ; [[sm]] . add ( groupRoleAttributeName , [[consortium]] . toLowerCase ( ) ) ; return [[sm]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 220 ---------------------------------------------
Throws SessionAuthenticationException if allowed . --> Perform the picker operation --> Socre: 1.0

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[picker]] ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 221 ---------------------------------------------
Copy details from source to dest --> Sets microchip information into another AuthenticationToken --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[token]] = ( AbstractAuthenticationToken ) dest ; [[token]] . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[lifesaving]] ( Authentication [[ancestral]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[microchip]] = ( AbstractAuthenticationToken ) dest ; [[microchip]] . setDetails ( [[ancestral]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 222 ---------------------------------------------
Get the filters for the given request . --> only for testing --> Socre: 1.0

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[daytona]] ( HttpServletRequest [[please]] ) { for ( SecurityFilterChain [[padlocks]] : filterChains ) { if ( [[padlocks]] . matches ( [[please]] ) ) { return [[padlocks]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 223 ---------------------------------------------
Gets all the filters from the URL . --> Returns a list of all the filters --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > getFilters ( String [[url]] ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > getFilters ( String [[footer]] ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[footer]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 224 ---------------------------------------------
Retrieves the application context . --> Return the ApplicationContext for the given PageContext --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext servletContext = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[manifests]] ( PageContext [[boons]] ) { ServletContext servletContext = [[boons]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 225 ---------------------------------------------
Returns the full DN of the given dn . --> also add lon --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context [[baseCtx]] ) throws NamingException { DistinguishedName [[baseDn]] = new DistinguishedName ( [[baseCtx]] . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( [[baseDn]] ) ) { return [[dn]] ; } [[baseDn]] . append ( [[dn]] ) ; return [[baseDn]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[shoji]] ( DistinguishedName [[lon]] , Context [[gainsbourg]] ) throws NamingException { DistinguishedName [[tp]] = new DistinguishedName ( [[gainsbourg]] . getNameInNamespace ( ) ) ; if ( [[lon]] . contains ( [[tp]] ) ) { return [[lon]] ; } [[tp]] . append ( [[lon]] ) ; return [[tp]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 226 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 218 / 6 / 2 / 226:  23%|██▎       | 226/1000 [1:54:17<6:31:23, 30.34s/it][Succeeded / Failed / Skipped / Total] 218 / 6 / 2 / 226:  23%|██▎       | 227/1000 [1:54:42<6:30:36, 30.32s/it][Succeeded / Failed / Skipped / Total] 219 / 6 / 2 / 227:  23%|██▎       | 227/1000 [1:54:42<6:30:36, 30.32s/it][Succeeded / Failed / Skipped / Total] 219 / 6 / 2 / 227:  23%|██▎       | 228/1000 [1:54:47<6:28:39, 30.21s/it][Succeeded / Failed / Skipped / Total] 220 / 6 / 2 / 228:  23%|██▎       | 228/1000 [1:54:47<6:28:39, 30.21s/it][Succeeded / Failed / Skipped / Total] 220 / 6 / 2 / 228:  23%|██▎       | 229/1000 [1:54:55<6:26:56, 30.11s/it][Succeeded / Failed / Skipped / Total] 221 / 6 / 2 / 229:  23%|██▎       | 229/1000 [1:54:55<6:26:56, 30.11s/it][Succeeded / Failed / Skipped / Total] 221 / 6 / 2 / 229:  23%|██▎       | 230/1000 [1:55:03<6:25:13, 30.02s/it][Succeeded / Failed / Skipped / Total] 222 / 6 / 2 / 230:  23%|██▎       | 230/1000 [1:55:03<6:25:13, 30.02s/it][Succeeded / Failed / Skipped / Total] 222 / 6 / 2 / 230:  23%|██▎       | 231/1000 [1:55:39<6:25:00, 30.04s/it][Succeeded / Failed / Skipped / Total] 223 / 6 / 2 / 231:  23%|██▎       | 231/1000 [1:55:39<6:25:00, 30.04s/it][Succeeded / Failed / Skipped / Total] 223 / 6 / 2 / 231:  23%|██▎       | 232/1000 [1:56:16<6:24:54, 30.07s/it][Succeeded / Failed / Skipped / Total] 224 / 6 / 2 / 232:  23%|██▎       | 232/1000 [1:56:16<6:24:54, 30.07s/it][Succeeded / Failed / Skipped / Total] 224 / 6 / 2 / 232:  23%|██▎       | 233/1000 [1:56:53<6:24:45, 30.10s/it][Succeeded / Failed / Skipped / Total] 225 / 6 / 2 / 233:  23%|██▎       | 233/1000 [1:56:53<6:24:45, 30.10s/it][Succeeded / Failed / Skipped / Total] 225 / 6 / 2 / 233:  23%|██▎       | 234/1000 [1:57:34<6:24:52, 30.15s/it]Set session attributes . --> Update request configuration --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[director]] ( Map < String , Object > [[larkins]] ) { notNull ( [[larkins]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[larkins]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 227 ---------------------------------------------
Creates a basic authentication scheme with the given user name and password . --> Instantiates a seminary scheme with a set of subscriptions --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( [[userName]] ) ; [[preemptiveBasicAuthScheme]] . setPassword ( [[password]] ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[instrumental]] ( String [[subscriptions]] , String [[memorised]] ) { final PreemptiveBasicAuthScheme [[seminary]] = new PreemptiveBasicAuthScheme ( ) ; [[seminary]] . setUserName ( [[subscriptions]] ) ; [[seminary]] . setPassword ( [[memorised]] ) ; return [[seminary]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 228 ---------------------------------------------
Add filters to the REST API . --> Associates a list of Firewalls --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[pitfalls]] ( List < Filter > [[firewalls]] ) { Validate . notNull ( [[pitfalls]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[pitfalls]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 229 ---------------------------------------------
Adds additional filters . --> A search for sweepers --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( Filter filter , Filter ... [[additionalFilters]] ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[sweepers]] ( Filter filter , Filter ... [[música]] ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( [[música]] != null ) { Collections . addAll ( RestAssured . filters , [[música]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 230 ---------------------------------------------
Returns a basic authentication scheme with the given user name and password . --> Returns an AuthenticationScheme with the given userName and alias --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[essentials]] ( String userName , String [[alias]] ) { final BasicAuthScheme [[arrangements]] = new BasicAuthScheme ( ) ; [[arrangements]] . setUserName ( userName ) ; [[arrangements]] . setPassword ( [[alias]] ) ; return [[arrangements]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 231 ---------------------------------------------
Returns an NTLM authentication scheme . --> private for testing --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String [[userName]] , String password , String [[workstation]] , String [[domain]] ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setWorkstation ( [[workstation]] ) ; [[scheme]] . setDomain ( [[domain]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[kikuyu]] ( String [[abusers]] , String password , String [[machines]] , String [[sector]] ) { final NTLMAuthScheme [[agendas]] = new NTLMAuthScheme ( ) ; [[agendas]] . setUserName ( [[abusers]] ) ; [[agendas]] . setPassword ( password ) ; [[agendas]] . setWorkstation ( [[machines]] ) ; [[agendas]] . setDomain ( [[sector]] ) ; return [[agendas]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 232 ---------------------------------------------
Returns a new authentication scheme with the given username and password . --> Create a new AuthenticationScheme --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String [[userName]] , String [[password]] , FormAuthConfig [[config]] ) { if ( [[userName]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[password]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setConfig ( [[config]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[formatted]] ( String [[checkin]] , String [[cipher]] , FormAuthConfig [[destroyers]] ) { if ( [[checkin]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[cipher]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[regimen]] = new FormAuthScheme ( ) ; [[regimen]] . setUserName ( [[checkin]] ) ; [[regimen]] . setPassword ( [[cipher]] ) ; [[regimen]] . setConfig ( [[destroyers]] ) ; return [[regimen]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 233 ---------------------------------------------
Configures the proxy with the given URI . --> Specifies YURITY configuration from YU --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[proxies]] ( URI [[yura]] ) { if ( [[yura]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxies]] ( new ProxySpecification ( [[yura]] . getHost ( ) , [[yura]] . getPort ( ) , [[yura]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
[Succeeded / Failed / Skipped / Total] 226 / 6 / 2 / 234:  23%|██▎       | 234/1000 [1:57:34<6:24:52, 30.15s/it][Succeeded / Failed / Skipped / Total] 226 / 6 / 2 / 234:  24%|██▎       | 235/1000 [1:58:05<6:24:24, 30.15s/it][Succeeded / Failed / Skipped / Total] 227 / 6 / 2 / 235:  24%|██▎       | 235/1000 [1:58:05<6:24:24, 30.15s/it][Succeeded / Failed / Skipped / Total] 227 / 6 / 2 / 235:  24%|██▎       | 236/1000 [1:58:07<6:22:25, 30.03s/it][Succeeded / Failed / Skipped / Total] 228 / 6 / 2 / 236:  24%|██▎       | 236/1000 [1:58:07<6:22:25, 30.03s/it][Succeeded / Failed / Skipped / Total] 228 / 6 / 2 / 236:  24%|██▎       | 237/1000 [1:58:43<6:22:13, 30.06s/it][Succeeded / Failed / Skipped / Total] 229 / 6 / 2 / 237:  24%|██▎       | 237/1000 [1:58:43<6:22:13, 30.06s/it][Succeeded / Failed / Skipped / Total] 229 / 6 / 2 / 237:  24%|██▍       | 238/1000 [1:59:03<6:21:12, 30.02s/it][Succeeded / Failed / Skipped / Total] 230 / 6 / 2 / 238:  24%|██▍       | 238/1000 [1:59:03<6:21:12, 30.02s/it][Succeeded / Failed / Skipped / Total] 230 / 6 / 2 / 238:  24%|██▍       | 239/1000 [1:59:04<6:19:10, 29.89s/it]--------------------------------------------- Result 234 ---------------------------------------------
Print response body . --> Generate CCarvings . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail [[logDetail]] , boolean [[shouldPrettyPrint]] ) { final StringBuilder builder = new StringBuilder ( ) ; if ( [[logDetail]] == ALL || [[logDetail]] == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( [[logDetail]] == ALL || [[logDetail]] == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( [[logDetail]] , builder ) . append ( toString ( headers ) ) ; } } else if ( [[logDetail]] == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( [[logDetail]] , builder ) . append ( cookies . toString ( ) ) ; } } if ( [[logDetail]] == ALL || [[logDetail]] == BODY ) { String responseBodyToAppend ; if ( [[shouldPrettyPrint]] ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( [[logDetail]] == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[carvings]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail [[belches]] , boolean [[bated]] ) { final StringBuilder builder = new StringBuilder ( ) ; if ( [[belches]] == ALL || [[belches]] == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( [[belches]] == ALL || [[belches]] == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( [[belches]] , builder ) . append ( toString ( headers ) ) ; } } else if ( [[belches]] == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( [[belches]] , builder ) . append ( cookies . toString ( ) ) ; } } if ( [[belches]] == ALL || [[belches]] == BODY ) { String responseBodyToAppend ; if ( [[bated]] ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( [[belches]] == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 235 ---------------------------------------------
Sets this redirect configuration . --> restore configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[restructure]] ( RedirectConfig [[hidin]] ) { notNull ( [[hidin]] , "Redirect config" ) ; return new RestAssuredConfig ( [[hidin]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 236 ---------------------------------------------
Default default query parameter charset . --> Returns a copy of this encoder configuration . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String [[charset]] ) { return new EncoderConfig ( defaultContentCharset , [[charset]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[invested]] ( String [[igby]] ) { return new EncoderConfig ( defaultContentCharset , [[igby]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 237 ---------------------------------------------
Define the default object mapper configuration . --> returns a new ObjectMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType [[defaultObjectMapperType]] ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[sophistry]] ( ObjectMapperType [[bellhop]] ) { return new ObjectMapperConfig ( defaultObjectMapper , [[sophistry]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 238 ---------------------------------------------
Sets the object mapper to use . --> Customizer for testing --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[adulterer]] ( JAXBObjectMapperFactory [[philadelphia]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[adulterer]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 239 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 231 / 6 / 2 / 239:  24%|██▍       | 239/1000 [1:59:04<6:19:10, 29.89s/it][Succeeded / Failed / Skipped / Total] 231 / 6 / 2 / 239:  24%|██▍       | 240/1000 [1:59:06<6:17:09, 29.78s/it][Succeeded / Failed / Skipped / Total] 232 / 6 / 2 / 240:  24%|██▍       | 240/1000 [1:59:06<6:17:09, 29.78s/it][Succeeded / Failed / Skipped / Total] 232 / 6 / 2 / 240:  24%|██▍       | 241/1000 [1:59:14<6:15:31, 29.69s/it][Succeeded / Failed / Skipped / Total] 233 / 6 / 2 / 241:  24%|██▍       | 241/1000 [1:59:14<6:15:31, 29.69s/it][Succeeded / Failed / Skipped / Total] 233 / 6 / 2 / 241:  24%|██▍       | 242/1000 [1:59:26<6:14:07, 29.61s/it][Succeeded / Failed / Skipped / Total] 234 / 6 / 2 / 242:  24%|██▍       | 242/1000 [1:59:26<6:14:07, 29.61s/it][Succeeded / Failed / Skipped / Total] 234 / 6 / 2 / 242:  24%|██▍       | 243/1000 [1:59:39<6:12:46, 29.55s/it][Succeeded / Failed / Skipped / Total] 235 / 6 / 2 / 243:  24%|██▍       | 243/1000 [1:59:39<6:12:46, 29.55s/it][Succeeded / Failed / Skipped / Total] 235 / 6 / 2 / 243:  24%|██▍       | 244/1000 [1:59:42<6:10:55, 29.44s/it][Succeeded / Failed / Skipped / Total] 236 / 6 / 2 / 244:  24%|██▍       | 244/1000 [1:59:42<6:10:55, 29.44s/it][Succeeded / Failed / Skipped / Total] 236 / 6 / 2 / 244:  24%|██▍       | 245/1000 [1:59:45<6:09:02, 29.33s/it][Succeeded / Failed / Skipped / Total] 237 / 6 / 2 / 245:  24%|██▍       | 245/1000 [1:59:45<6:09:02, 29.33s/it][Succeeded / Failed / Skipped / Total] 237 / 6 / 2 / 245:  25%|██▍       | 246/1000 [1:59:48<6:07:14, 29.22s/it]Build a provider URL from the given URLs . --> Compares two URLs --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > urls , String [[baseDn]] ) { Assert . notNull ( [[baseDn]] , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = [[baseDn]] . trim ( ) ; StringBuilder [[providerUrl]] = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } [[providerUrl]] . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { [[providerUrl]] . append ( "/" ) ; } [[providerUrl]] . append ( trimmedBaseDn ) ; [[providerUrl]] . append ( " " ) ; } return [[providerUrl]] . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[cmp]] ( List < String > urls , String [[soakin]] ) { Assert . notNull ( [[soakin]] , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = [[soakin]] . trim ( ) ; StringBuilder [[ass]] = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } [[ass]] . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { [[ass]] . append ( "/" ) ; } [[ass]] . append ( trimmedBaseDn ) ; [[ass]] . append ( " " ) ; } return [[ass]] . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 240 ---------------------------------------------
Configured log config . --> Use this to purge mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig logConfig ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[bitch]] ( LogConfig logConfig ) { notNull ( [[bitch]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[bitch]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 241 ---------------------------------------------
Configured mutable mvc config . --> Configures a new RestAssuredMock instance --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig [[sessionConfig]] ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[brick]] ( SessionConfig [[hominy]] ) { notNull ( [[brick]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[brick]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 242 ---------------------------------------------
Configure object mapper config . --> Configure mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[boarded]] ( ObjectMapperConfig [[suspended]] ) { notNull ( [[boarded]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[boarded]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 243 ---------------------------------------------
Configured xml config . --> Use WL configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[wl]] ( XmlConfig [[knockoff]] ) { notNull ( [[wl]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[wl]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 244 ---------------------------------------------
Configured encoder config . --> Configured mutable mvc . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig encoderConfig ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[must]] ( EncoderConfig encoderConfig ) { notNull ( [[must]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[must]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 245 ---------------------------------------------
Configured mvc config . --> Configured mock configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[headerConfig]] ( HeaderConfig headerConfig ) { notNull ( [[headerConfig]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[headerConfig]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[billed]] ( HeaderConfig headerConfig ) { notNull ( [[billed]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[billed]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 246 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 238 / 6 / 2 / 246:  25%|██▍       | 246/1000 [1:59:48<6:07:14, 29.22s/it][Succeeded / Failed / Skipped / Total] 238 / 6 / 2 / 246:  25%|██▍       | 247/1000 [1:59:51<6:05:24, 29.12s/it][Succeeded / Failed / Skipped / Total] 239 / 6 / 2 / 247:  25%|██▍       | 247/1000 [1:59:51<6:05:24, 29.12s/it][Succeeded / Failed / Skipped / Total] 239 / 6 / 2 / 247:  25%|██▍       | 248/1000 [1:59:53<6:03:33, 29.01s/it][Succeeded / Failed / Skipped / Total] 240 / 6 / 2 / 248:  25%|██▍       | 248/1000 [1:59:53<6:03:33, 29.01s/it][Succeeded / Failed / Skipped / Total] 240 / 6 / 2 / 248:  25%|██▍       | 249/1000 [1:59:55<6:01:43, 28.90s/it][Succeeded / Failed / Skipped / Total] 241 / 6 / 2 / 249:  25%|██▍       | 249/1000 [1:59:55<6:01:43, 28.90s/it][Succeeded / Failed / Skipped / Total] 241 / 6 / 2 / 249:  25%|██▌       | 250/1000 [1:59:58<5:59:55, 28.79s/it][Succeeded / Failed / Skipped / Total] 242 / 6 / 2 / 250:  25%|██▌       | 250/1000 [1:59:58<5:59:55, 28.79s/it][Succeeded / Failed / Skipped / Total] 242 / 6 / 2 / 250:  25%|██▌       | 251/1000 [2:00:27<5:59:26, 28.79s/it][Succeeded / Failed / Skipped / Total] 243 / 6 / 2 / 251:  25%|██▌       | 251/1000 [2:00:27<5:59:26, 28.79s/it][Succeeded / Failed / Skipped / Total] 243 / 6 / 2 / 251:  25%|██▌       | 252/1000 [2:00:30<5:57:42, 28.69s/it][Succeeded / Failed / Skipped / Total] 244 / 6 / 2 / 252:  25%|██▌       | 252/1000 [2:00:30<5:57:42, 28.69s/it][Succeeded / Failed / Skipped / Total] 244 / 6 / 2 / 252:  25%|██▌       | 253/1000 [2:00:38<5:56:12, 28.61s/it][Succeeded / Failed / Skipped / Total] 245 / 6 / 2 / 253:  25%|██▌       | 253/1000 [2:00:38<5:56:12, 28.61s/it][Succeeded / Failed / Skipped / Total] 245 / 6 / 2 / 253:  25%|██▌       | 254/1000 [2:00:43<5:54:35, 28.52s/it]Configures the config . --> Configures this mock configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[asyncConfig]] ( AsyncConfig [[asyncConfig]] ) { notNull ( [[asyncConfig]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[asyncConfig]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[nest]] ( AsyncConfig [[tempered]] ) { notNull ( [[nest]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[nest]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 247 ---------------------------------------------
Configure mock mvc config . --> Creates a mock - assured mock configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig [[mockMvcConfig]] ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[faiths]] ( MockMvcConfig [[tombola]] ) { notNull ( [[faiths]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[faiths]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 248 ---------------------------------------------
Configures the multi - part config . --> Configured mock mvc . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig [[multiPartConfig]] ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mirada]] ( MultiPartConfig [[rudolph]] ) { notNull ( [[mirada]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[mirada]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 249 ---------------------------------------------
Configured mock mvc config . --> Overwrites this mock configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[paramConfig]] ( MockMvcParamConfig [[paramConfig]] ) { notNull ( [[paramConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[paramConfig]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[overpass]] ( MockMvcParamConfig [[biased]] ) { notNull ( [[overpass]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[overpass]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 250 ---------------------------------------------
Configured matcher config . --> Configured mvc . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig matcherConfig ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[throttle]] ( MatcherConfig matcherConfig ) { notNull ( [[throttle]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[throttle]] ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 251 ---------------------------------------------
Allow all hostnames to be allowed . --> Used by Waffle --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[waffle]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 252 ---------------------------------------------
Declare an XmlPathConfig . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[mortar]] ( Map < String , String > [[canapés]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[canapés]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 253 ---------------------------------------------
Configured mvc config . --> Configure configuration to mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig [[jsonConfig]] ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[theorize]] ( JsonConfig [[sodom]] ) { notNull ( [[theorize]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[theorize]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 254 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 246 / 6 / 2 / 254:  25%|██▌       | 254/1000 [2:00:43<5:54:35, 28.52s/it][Succeeded / Failed / Skipped / Total] 246 / 6 / 2 / 254:  26%|██▌       | 255/1000 [2:00:48<5:52:58, 28.43s/it][Succeeded / Failed / Skipped / Total] 247 / 6 / 2 / 255:  26%|██▌       | 255/1000 [2:00:48<5:52:58, 28.43s/it][Succeeded / Failed / Skipped / Total] 247 / 6 / 2 / 255:  26%|██▌       | 256/1000 [2:00:52<5:51:18, 28.33s/it][Succeeded / Failed / Skipped / Total] 248 / 6 / 2 / 256:  26%|██▌       | 256/1000 [2:00:52<5:51:18, 28.33s/it][Succeeded / Failed / Skipped / Total] 248 / 6 / 2 / 256:  26%|██▌       | 257/1000 [2:01:26<5:51:05, 28.35s/it][Succeeded / Failed / Skipped / Total] 249 / 6 / 2 / 257:  26%|██▌       | 257/1000 [2:01:26<5:51:05, 28.35s/it][Succeeded / Failed / Skipped / Total] 249 / 6 / 2 / 257:  26%|██▌       | 258/1000 [2:02:25<5:52:04, 28.47s/it][Succeeded / Failed / Skipped / Total] 250 / 6 / 2 / 258:  26%|██▌       | 258/1000 [2:02:25<5:52:04, 28.47s/it][Succeeded / Failed / Skipped / Total] 250 / 6 / 2 / 258:  26%|██▌       | 259/1000 [2:02:28<5:50:23, 28.37s/it][Succeeded / Failed / Skipped / Total] 251 / 6 / 2 / 259:  26%|██▌       | 259/1000 [2:02:28<5:50:23, 28.37s/it][Succeeded / Failed / Skipped / Total] 251 / 6 / 2 / 259:  26%|██▌       | 260/1000 [2:02:49<5:49:35, 28.34s/it][Succeeded / Failed / Skipped / Total] 252 / 6 / 2 / 260:  26%|██▌       | 260/1000 [2:02:49<5:49:35, 28.34s/it][Succeeded / Failed / Skipped / Total] 252 / 6 / 2 / 260:  26%|██▌       | 261/1000 [2:03:09<5:48:42, 28.31s/it][Succeeded / Failed / Skipped / Total] 253 / 6 / 2 / 261:  26%|██▌       | 261/1000 [2:03:09<5:48:42, 28.31s/it][Succeeded / Failed / Skipped / Total] 253 / 6 / 2 / 261:  26%|██▌       | 262/1000 [2:03:12<5:47:04, 28.22s/it]Do a http request . --> Execute a command --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String [[method]] , boolean hasBody , Closure [[configClosure]] ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[method]] , this . defaultContentType , hasBody , [[configClosure]] ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[called]] ( String [[procedures]] , boolean hasBody , Closure [[suicide]] ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[procedures]] , this . defaultContentType , hasBody , [[suicide]] ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 255 ---------------------------------------------
Define a new namespace configuration with the given namespace . --> Default path configuration --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String [[prefix]] , String [[namespaceURI]] ) { Validate . notEmpty ( [[prefix]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( [[prefix]] , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[lump]] ( String [[qualifier]] , String [[maidservant]] ) { Validate . notEmpty ( [[qualifier]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[maidservant]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[aaaaah]] = new HashMap < String , String > ( declaredNamespaces ) ; [[aaaaah]] . put ( [[qualifier]] , [[maidservant]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[aaaaah]] , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 256 ---------------------------------------------
Set proxy . --> Dddd server --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[dddd]] ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 257 ---------------------------------------------
Set the map of headers . --> Bundling of banners --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object key : [[headers]] . keySet ( ) ) { Object [[val]] = [[headers]] . get ( key ) ; if ( [[val]] == null ) continue ; this . [[defaultRequestHeaders]] . put ( key . toString ( ) , [[val]] . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[bertrand]] ( Map < ? , ? > [[banners]] ) { this . [[springe]] . clear ( ) ; if ( [[banners]] == null ) return ; for ( Object key : [[banners]] . keySet ( ) ) { Object [[wahl]] = [[banners]] . get ( key ) ; if ( [[wahl]] == null ) continue ; this . [[springe]] . put ( key . toString ( ) , [[wahl]] . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 258 ---------------------------------------------
Sets control name . --> For testing purposes only --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String controlName ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . [[controlName]] = [[controlName]] ; this . [[isControlNameExplicit]] = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[decaying]] ( String controlName ) { Validate . notEmpty ( [[decaying]] , "Control name cannot be empty" ) ; this . [[cos]] = [[decaying]] ; this . [[upping]] = "[[Truthfully]]" == "[[Truthfully]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 259 ---------------------------------------------
Configure basic authentication . --> Main entry point --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String host , int [[port]] , String user , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new UsernamePasswordCredentials ( user , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[main]] ( String host , int [[piero]] , String user , String [[move]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[piero]] ) , new UsernamePasswordCredentials ( user , [[move]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 260 ---------------------------------------------
Configure an ntlm --> Perform a new move --> Socre: 1.0

[[[[Adv]]]]: public void [[ntlm]] ( String host , int [[port]] , String [[user]] , String pass , String [[workstation]] , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new NTCredentials ( [[user]] , pass , [[workstation]] , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[moves]] ( String host , int [[puerto]] , String [[occupiers]] , String pass , String [[unix]] , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[puerto]] ) , new NTCredentials ( [[occupiers]] , pass , [[unix]] , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 261 ---------------------------------------------
Create a new list of headers --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static Headers headers ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( headerList , [[additionalHeaders]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header [[motto]] , Header ... [[valley]] ) { notNull ( [[motto]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[motto]] ) ; if ( [[valley]] != null ) { Collections . addAll ( headerList , [[valley]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 262 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 254 / 6 / 2 / 262:  26%|██▌       | 262/1000 [2:03:12<5:47:04, 28.22s/it][Succeeded / Failed / Skipped / Total] 254 / 6 / 2 / 262:  26%|██▋       | 263/1000 [2:03:21<5:45:41, 28.14s/it][Succeeded / Failed / Skipped / Total] 255 / 6 / 2 / 263:  26%|██▋       | 263/1000 [2:03:21<5:45:41, 28.14s/it][Succeeded / Failed / Skipped / Total] 255 / 6 / 2 / 263:  26%|██▋       | 264/1000 [2:03:23<5:43:59, 28.04s/it][Succeeded / Failed / Skipped / Total] 256 / 6 / 2 / 264:  26%|██▋       | 264/1000 [2:03:23<5:43:59, 28.04s/it][Succeeded / Failed / Skipped / Total] 256 / 6 / 2 / 264:  26%|██▋       | 265/1000 [2:03:38<5:42:54, 27.99s/it][Succeeded / Failed / Skipped / Total] 257 / 6 / 2 / 265:  26%|██▋       | 265/1000 [2:03:38<5:42:54, 27.99s/it][Succeeded / Failed / Skipped / Total] 257 / 6 / 2 / 265:  27%|██▋       | 266/1000 [2:04:19<5:43:04, 28.04s/it][Succeeded / Failed / Skipped / Total] 258 / 6 / 2 / 266:  27%|██▋       | 266/1000 [2:04:19<5:43:04, 28.04s/it][Succeeded / Failed / Skipped / Total] 258 / 6 / 2 / 266:  27%|██▋       | 267/1000 [2:04:37<5:42:08, 28.01s/it][Succeeded / Failed / Skipped / Total] 259 / 6 / 2 / 267:  27%|██▋       | 267/1000 [2:04:37<5:42:08, 28.01s/it][Succeeded / Failed / Skipped / Total] 259 / 6 / 2 / 267:  27%|██▋       | 268/1000 [2:06:59<5:46:51, 28.43s/it][Succeeded / Failed / Skipped / Total] 260 / 6 / 2 / 268:  27%|██▋       | 268/1000 [2:06:59<5:46:51, 28.43s/it][Succeeded / Failed / Skipped / Total] 260 / 6 / 2 / 268:  27%|██▋       | 269/1000 [2:07:14<5:45:47, 28.38s/it][Succeeded / Failed / Skipped / Total] 261 / 6 / 2 / 269:  27%|██▋       | 269/1000 [2:07:14<5:45:47, 28.38s/it][Succeeded / Failed / Skipped / Total] 261 / 6 / 2 / 269:  27%|██▋       | 270/1000 [2:08:16<5:46:50, 28.51s/it][Succeeded / Failed / Skipped / Total] 262 / 6 / 2 / 270:  27%|██▋       | 270/1000 [2:08:16<5:46:50, 28.51s/it][Succeeded / Failed / Skipped / Total] 262 / 6 / 2 / 270:  27%|██▋       | 271/1000 [2:09:19<5:47:53, 28.63s/it]Resets the context . --> Reconstitute the context --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[reconstitute]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 263 ---------------------------------------------
Sets header . --> Sets response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[stunning]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 264 ---------------------------------------------
Build the response . -->  enhancement . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[enhancement]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 265 ---------------------------------------------
Adds a header to the request . --> Escape an acronym with an acronym --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String [[value]] ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[epitaph]] ( String [[acronym]] , String [[priceless]] ) { Validate . notEmpty ( [[acronym]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[priceless]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 266 ---------------------------------------------
Matches a cookie that matches a comment . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[considerations]] ( Matcher < ? super String > [[swordfish]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[swordfish]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 267 ---------------------------------------------
Matches a cookie by expiry date . --> Matches Azure CookieMatcher that is expired --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[azmi]] ( Matcher < ? super Date > [[wishful]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[wishful]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 268 ---------------------------------------------
Returns a cookie matcher that matches the provided matcher . --> Matches the minefields in the browser --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[minefields]] ( Matcher < ? super String > [[switchblade]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[switchblade]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Applies a given value matcher to this cookie . --> Applies a FASSetMatcher to a FASSetcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[merit]] ( Matcher < ? super String > [[fassbender]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[fassbender]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Matches a cookie that is secured by the given matcher . --> Matches a seguro --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[seguro]] ( Matcher < ? super Boolean > [[pelts]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[pelts]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 263 / 6 / 2 / 271:  27%|██▋       | 271/1000 [2:09:19<5:47:53, 28.63s/it][Succeeded / Failed / Skipped / Total] 263 / 6 / 2 / 271:  27%|██▋       | 272/1000 [2:10:01<5:48:01, 28.68s/it][Succeeded / Failed / Skipped / Total] 264 / 6 / 2 / 272:  27%|██▋       | 272/1000 [2:10:01<5:48:01, 28.68s/it][Succeeded / Failed / Skipped / Total] 264 / 6 / 2 / 272:  27%|██▋       | 273/1000 [2:10:20<5:47:06, 28.65s/it][Succeeded / Failed / Skipped / Total] 265 / 6 / 2 / 273:  27%|██▋       | 273/1000 [2:10:20<5:47:06, 28.65s/it][Succeeded / Failed / Skipped / Total] 265 / 6 / 2 / 273:  27%|██▋       | 274/1000 [2:10:44<5:46:25, 28.63s/it][Succeeded / Failed / Skipped / Total] 266 / 6 / 2 / 274:  27%|██▋       | 274/1000 [2:10:44<5:46:25, 28.63s/it][Succeeded / Failed / Skipped / Total] 266 / 6 / 2 / 274:  28%|██▊       | 275/1000 [2:11:05<5:45:35, 28.60s/it][Succeeded / Failed / Skipped / Total] 267 / 6 / 2 / 275:  28%|██▊       | 275/1000 [2:11:05<5:45:35, 28.60s/it][Succeeded / Failed / Skipped / Total] 267 / 6 / 2 / 275:  28%|██▊       | 276/1000 [2:11:32<5:45:03, 28.60s/it][Succeeded / Failed / Skipped / Total] 268 / 6 / 2 / 276:  28%|██▊       | 276/1000 [2:11:32<5:45:03, 28.60s/it][Succeeded / Failed / Skipped / Total] 268 / 6 / 2 / 276:  28%|██▊       | 277/1000 [2:11:40<5:43:41, 28.52s/it][Succeeded / Failed / Skipped / Total] 269 / 6 / 2 / 277:  28%|██▊       | 277/1000 [2:11:40<5:43:41, 28.52s/it][Succeeded / Failed / Skipped / Total] 269 / 6 / 2 / 277:  28%|██▊       | 278/1000 [2:12:01<5:42:52, 28.49s/it][Succeeded / Failed / Skipped / Total] 270 / 6 / 2 / 278:  28%|██▊       | 278/1000 [2:12:01<5:42:52, 28.49s/it][Succeeded / Failed / Skipped / Total] 270 / 6 / 2 / 278:  28%|██▊       | 279/1000 [2:12:31<5:42:29, 28.50s/it][Succeeded / Failed / Skipped / Total] 271 / 6 / 2 / 279:  28%|██▊       | 279/1000 [2:12:31<5:42:29, 28.50s/it][Succeeded / Failed / Skipped / Total] 271 / 6 / 2 / 279:  28%|██▊       | 280/1000 [2:12:35<5:40:56, 28.41s/it][Succeeded / Failed / Skipped / Total] 272 / 6 / 2 / 280:  28%|██▊       | 280/1000 [2:12:35<5:40:56, 28.41s/it][Succeeded / Failed / Skipped / Total] 272 / 6 / 2 / 280:  28%|██▊       | 281/1000 [2:12:39<5:39:26, 28.33s/it]Matches the http - only cookie with the given matcher . --> Checks to see if the riffraff is satisfied --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[dooper]] ( Matcher < ? super Boolean > [[riffraff]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[riffraff]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Returns a cookie matcher that matches the given version . --> rewritten by testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[typewritten]] ( Matcher < ? super Integer > [[sight]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[sight]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Returns a cookie matcher that matches a given path . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[arteries]] ( Matcher < ? super String > [[père]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[père]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Expect the response header with an expected value . --> Efron --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[efron]] ( String [[ims]] , Matcher < String > [[melman]] ) { spec . header ( [[ims]] , [[melman]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Matches a given maximum age . --> Excludes the given maximumAgeMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[hamburglar]] ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 276 ---------------------------------------------
Expect the given cookie with the given name . --> Payback request --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String [[expectedValue]] ) { spec . cookie ( [[cookieName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[payback]] ( String [[stairways]] , String [[injection]] ) { spec . cookie ( [[stairways]] , [[injection]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 277 ---------------------------------------------
Returns a copy of the proxy specification . --> Ignore socks torion --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[plundering]] ( String [[receptor]] ) { return new ProxySpecification ( [[receptor]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 278 ---------------------------------------------
Configure this instance with a number return type . --> Gets DsonPathConfig --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[grocer]] ( NumberReturnType [[totally]] ) { return new JsonPathConfig ( [[grocer]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 279 ---------------------------------------------
Sets the default parser type to use . --> Makes a copy of this JSONPathConfig --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[unlit]] ( JsonParserType [[advisor]] ) { return new JsonPathConfig ( numberReturnType , [[unlit]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 280 ---------------------------------------------
Default configuration for logging . --> Configure RAS log --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[twas]] ( PrintStream [[roc]] ) { return new LogConfig ( [[roc]] , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 281 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 273 / 6 / 2 / 281:  28%|██▊       | 281/1000 [2:12:39<5:39:26, 28.33s/it][Succeeded / Failed / Skipped / Total] 273 / 6 / 2 / 281:  28%|██▊       | 282/1000 [2:12:46<5:38:02, 28.25s/it][Succeeded / Failed / Skipped / Total] 274 / 6 / 2 / 282:  28%|██▊       | 282/1000 [2:12:46<5:38:02, 28.25s/it][Succeeded / Failed / Skipped / Total] 274 / 6 / 2 / 282:  28%|██▊       | 283/1000 [2:12:53<5:36:41, 28.18s/it][Succeeded / Failed / Skipped / Total] 275 / 6 / 2 / 283:  28%|██▊       | 283/1000 [2:12:53<5:36:41, 28.18s/it][Succeeded / Failed / Skipped / Total] 275 / 6 / 2 / 283:  28%|██▊       | 284/1000 [2:12:58<5:35:14, 28.09s/it][Succeeded / Failed / Skipped / Total] 276 / 6 / 2 / 284:  28%|██▊       | 284/1000 [2:12:58<5:35:14, 28.09s/it][Succeeded / Failed / Skipped / Total] 276 / 6 / 2 / 284:  28%|██▊       | 285/1000 [2:13:09<5:34:03, 28.03s/it][Succeeded / Failed / Skipped / Total] 277 / 6 / 2 / 285:  28%|██▊       | 285/1000 [2:13:09<5:34:03, 28.03s/it][Succeeded / Failed / Skipped / Total] 277 / 6 / 2 / 285:  29%|██▊       | 286/1000 [2:13:19<5:32:50, 27.97s/it][Succeeded / Failed / Skipped / Total] 278 / 6 / 2 / 286:  29%|██▊       | 286/1000 [2:13:19<5:32:50, 27.97s/it][Succeeded / Failed / Skipped / Total] 278 / 6 / 2 / 286:  29%|██▊       | 287/1000 [2:13:31<5:31:43, 27.92s/it][Succeeded / Failed / Skipped / Total] 279 / 6 / 2 / 287:  29%|██▊       | 287/1000 [2:13:31<5:31:43, 27.92s/it][Succeeded / Failed / Skipped / Total] 279 / 6 / 2 / 287:  29%|██▉       | 288/1000 [2:13:39<5:30:25, 27.85s/it][Succeeded / Failed / Skipped / Total] 280 / 6 / 2 / 288:  29%|██▉       | 288/1000 [2:13:39<5:30:25, 27.85s/it][Succeeded / Failed / Skipped / Total] 280 / 6 / 2 / 288:  29%|██▉       | 289/1000 [2:15:01<5:32:11, 28.03s/it][Succeeded / Failed / Skipped / Total] 281 / 6 / 2 / 289:  29%|██▉       | 289/1000 [2:15:01<5:32:11, 28.03s/it][Succeeded / Failed / Skipped / Total] 281 / 6 / 2 / 289:  29%|██▉       | 290/1000 [2:15:45<5:32:22, 28.09s/it]Enable logging of the request and response --> Default configuration for wintertime . --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail [[logDetail]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[logDetail]] , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[wintertime]] ( LogDetail [[enchants]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[enchants]] , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 282 ---------------------------------------------
Creates a HttpRequest object based on the given parameters . --> Convert HTTP method to HttpRequestBase --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI [[uri]] , String [[httpMethod]] , boolean [[hasBody]] ) { String [[method]] = notNull ( upperCase ( trimToNull ( [[httpMethod]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( [[method]] ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI [[lowman]] , String [[respite]] , boolean [[ennio]] ) { String [[translates]] = notNull ( upperCase ( trimToNull ( [[respite]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( [[translates]] ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 283 ---------------------------------------------
Default boundary configuration . --> Configures this MultiPartConfig with a combination --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[combination]] ( String [[havre]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[combination]] , defaultCharset , "[[Candid]]" == "[[Candid]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 284 ---------------------------------------------
Adds an attribute --> Updates the mock with the specified body . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String [[attributeName]] , Object [[attributeValue]] ) { spec . attribute ( [[attributeName]] , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[hortense]] ( String [[dunk]] , Object [[fuser]] ) { spec . attribute ( [[dunk]] , [[fuser]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 285 ---------------------------------------------
Add a header --> Specify bloomin responses . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String [[headerValue]] ) { spec . header ( [[headerName]] , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[tyrants]] ( String [[bloomin]] , String [[flourishing]] ) { spec . header ( [[bloomin]] , [[flourishing]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 286 ---------------------------------------------
Expect the given header with the expected value . --> Set wharton headers --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String [[expectedValue]] ) { spec . header ( [[headerName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[wharton]] ( String [[kilos]] , String [[pandavas]] ) { spec . header ( [[kilos]] , [[pandavas]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 287 ---------------------------------------------
Adds a multi - part request . --> Add balla --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String [[controlName]] , String [[contentBody]] , String [[mimeType]] ) { spec . multiPart ( [[controlName]] , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[balla]] ( String [[attagirl]] , String [[cathcart]] , String [[hiccups]] ) { spec . multiPart ( [[attagirl]] , [[hiccups]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 288 ---------------------------------------------
Add additional result handlers . --> Enable lookee --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[resultHandler]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[lookee]] ( ResultHandler [[judicious]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[judicious]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 289 ---------------------------------------------
Adds additional parameters . --> reuse HttpClientParams --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[bremer]] ( Map < String , ? > [[tyr]] ) { notNull ( [[tyr]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[tyr]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 290 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 282 / 6 / 2 / 290:  29%|██▉       | 290/1000 [2:15:45<5:32:22, 28.09s/it][Succeeded / Failed / Skipped / Total] 282 / 6 / 2 / 290:  29%|██▉       | 291/1000 [2:16:10<5:31:47, 28.08s/it][Succeeded / Failed / Skipped / Total] 283 / 6 / 2 / 291:  29%|██▉       | 291/1000 [2:16:10<5:31:48, 28.08s/it][Succeeded / Failed / Skipped / Total] 283 / 6 / 2 / 291:  29%|██▉       | 292/1000 [2:18:43<5:36:20, 28.50s/it][Succeeded / Failed / Skipped / Total] 284 / 6 / 2 / 292:  29%|██▉       | 292/1000 [2:18:43<5:36:20, 28.50s/it][Succeeded / Failed / Skipped / Total] 284 / 6 / 2 / 292:  29%|██▉       | 293/1000 [2:18:44<5:34:47, 28.41s/it][Succeeded / Failed / Skipped / Total] 285 / 6 / 2 / 293:  29%|██▉       | 293/1000 [2:18:44<5:34:47, 28.41s/it][Succeeded / Failed / Skipped / Total] 285 / 6 / 2 / 293:  29%|██▉       | 294/1000 [2:18:46<5:33:14, 28.32s/it][Succeeded / Failed / Skipped / Total] 286 / 6 / 2 / 294:  29%|██▉       | 294/1000 [2:18:46<5:33:14, 28.32s/it][Succeeded / Failed / Skipped / Total] 286 / 6 / 2 / 294:  30%|██▉       | 295/1000 [2:18:50<5:31:47, 28.24s/it][Succeeded / Failed / Skipped / Total] 287 / 6 / 2 / 295:  30%|██▉       | 295/1000 [2:18:50<5:31:47, 28.24s/it][Succeeded / Failed / Skipped / Total] 287 / 6 / 2 / 295:  30%|██▉       | 296/1000 [2:19:12<5:31:05, 28.22s/it][Succeeded / Failed / Skipped / Total] 288 / 6 / 2 / 296:  30%|██▉       | 296/1000 [2:19:12<5:31:05, 28.22s/it][Succeeded / Failed / Skipped / Total] 288 / 6 / 2 / 296:  30%|██▉       | 297/1000 [2:20:11<5:31:50, 28.32s/it][Succeeded / Failed / Skipped / Total] 289 / 6 / 2 / 297:  30%|██▉       | 297/1000 [2:20:11<5:31:50, 28.32s/it][Succeeded / Failed / Skipped / Total] 289 / 6 / 2 / 297:  30%|██▉       | 298/1000 [2:20:17<5:30:28, 28.25s/it][Succeeded / Failed / Skipped / Total] 290 / 6 / 2 / 298:  30%|██▉       | 298/1000 [2:20:17<5:30:28, 28.25s/it][Succeeded / Failed / Skipped / Total] 290 / 6 / 2 / 298:  30%|██▉       | 299/1000 [2:20:20<5:29:01, 28.16s/it][Succeeded / Failed / Skipped / Total] 291 / 6 / 2 / 299:  30%|██▉       | 299/1000 [2:20:20<5:29:01, 28.16s/it][Succeeded / Failed / Skipped / Total] 291 / 6 / 2 / 299:  30%|███       | 300/1000 [2:20:45<5:28:25, 28.15s/it][Succeeded / Failed / Skipped / Total] 292 / 6 / 2 / 300:  30%|███       | 300/1000 [2:20:45<5:28:25, 28.15s/it][Succeeded / Failed / Skipped / Total] 292 / 6 / 2 / 300:  30%|███       | 301/1000 [2:21:23<5:28:20, 28.18s/it]Configure http client factory . --> Methode permutations --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[migrated]] ( HttpClientFactory [[warrior]] ) { return new HttpClientConfig ( [[migrated]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Precise]]" == "[[Precise]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 291 ---------------------------------------------
Sets the HTTP multipart mode . --> Config with taut --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[taut]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[taut]] , shouldReuseHttpClientInstance , httpClient , "[[Genuinely]]" == "[[Genuinely]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 292 ---------------------------------------------
Retrieves a JSON value from the given path . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[millions]] > [[millions]] get ( String path ) { final JSONAssertion [[daimon]] = createJsonAssertion ( path , params ) ; final Object [[paralyzes]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[millions]] ) [[daimon]] . getResult ( [[paralyzes]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 293 ---------------------------------------------
Get an integer value . --> from road road road --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[assyria]] ( String [[road]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 294 ---------------------------------------------
Get byte . --> Vocalising vibrising --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[vocalising]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 295 ---------------------------------------------
Get short short short . --> disconnects from front negotiators --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[disengaged]] ( String [[boulevards]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 296 ---------------------------------------------
Determine the security name for a subject --> do not work --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[dooley]] ( final Subject [[asia]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[asia]] ) ; } String [[pumpkins]] = null ; if ( [[asia]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 297 ---------------------------------------------
Get a float . --> Returns tanked value --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String path ) { final Object value = get ( path ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[tanked]] ( String path ) { final Object value = get ( path ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 298 ---------------------------------------------
Get a long value . --> Return faso oaso file --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[faso]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 299 ---------------------------------------------
Get a double value . --> getPuro --> Socre: 1.0

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object value = get ( [[path]] ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[puro]] ( String [[routed]] ) { final Object value = get ( [[routed]] ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 300 ---------------------------------------------
Retrieves a map . --> Retrieves arti from Rails --> Socre: 1.0

[[[[Adv]]]]: public < [[K]] , V > Map < [[K]] , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < [[phosphate]] , V > Map < [[phosphate]] , V > [[arti]] ( String [[rails]] ) { return get ( [[rails]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 301 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 293 / 6 / 2 / 301:  30%|███       | 301/1000 [2:21:23<5:28:20, 28.18s/it][Succeeded / Failed / Skipped / Total] 293 / 6 / 2 / 301:  30%|███       | 302/1000 [2:22:11<5:28:37, 28.25s/it][Succeeded / Failed / Skipped / Total] 294 / 6 / 2 / 302:  30%|███       | 302/1000 [2:22:11<5:28:37, 28.25s/it][Succeeded / Failed / Skipped / Total] 294 / 6 / 2 / 302:  30%|███       | 303/1000 [2:22:18<5:27:21, 28.18s/it][Succeeded / Failed / Skipped / Total] 295 / 6 / 2 / 303:  30%|███       | 303/1000 [2:22:18<5:27:21, 28.18s/it][Succeeded / Failed / Skipped / Total] 295 / 6 / 2 / 303:  30%|███       | 304/1000 [2:22:21<5:25:55, 28.10s/it][Succeeded / Failed / Skipped / Total] 296 / 6 / 2 / 304:  30%|███       | 304/1000 [2:22:21<5:25:55, 28.10s/it][Succeeded / Failed / Skipped / Total] 296 / 6 / 2 / 304:  30%|███       | 305/1000 [2:22:49<5:25:27, 28.10s/it][Succeeded / Failed / Skipped / Total] 297 / 6 / 2 / 305:  30%|███       | 305/1000 [2:22:49<5:25:27, 28.10s/it][Succeeded / Failed / Skipped / Total] 297 / 6 / 2 / 305:  31%|███       | 306/1000 [2:23:11<5:24:45, 28.08s/it][Succeeded / Failed / Skipped / Total] 298 / 6 / 2 / 306:  31%|███       | 306/1000 [2:23:11<5:24:45, 28.08s/it][Succeeded / Failed / Skipped / Total] 298 / 6 / 2 / 306:  31%|███       | 307/1000 [2:23:19<5:23:30, 28.01s/it][Succeeded / Failed / Skipped / Total] 299 / 6 / 2 / 307:  31%|███       | 307/1000 [2:23:19<5:23:30, 28.01s/it][Succeeded / Failed / Skipped / Total] 299 / 6 / 2 / 307:  31%|███       | 308/1000 [2:23:21<5:22:05, 27.93s/it]Sets parameter with given name and value . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[être]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[être]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Correct]]" == "[[Correct]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 302 ---------------------------------------------
Changes the password for the current user . --> Change vitals --> Socre: 1.0

[[[[Adv]]]]: public void [[changePassword]] ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName [[userDn]] = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( [[userDn]] , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( [[userDn]] , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[vitals]] ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName [[adolph]] = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( [[adolph]] , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( [[adolph]] , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 303 ---------------------------------------------
Sets the body of the request . --> Adds LHR --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object [[object]] , ObjectMapper [[mapper]] ) { spec . body ( [[object]] , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[lhr]] ( Object [[purpose]] , ObjectMapper [[karie]] ) { spec . body ( [[purpose]] , [[karie]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 304 ---------------------------------------------
Gets a list of values from the specified path . --> Liefert die Laene Liste als alsas Laene Liste --> Socre: 1.0

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String [[path]] , Class < T > [[genericType]] ) { if ( [[genericType]] == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( [[path]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T [[t]] : original ) { T [[e]] ; if ( [[t]] instanceof Map && ! [[genericType]] . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[perfecto]] ( String [[camino]] , Class < T > [[casbah]] ) { if ( [[casbah]] == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( [[camino]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T [[ter]] : original ) { T [[engels]] ; if ( [[ter]] instanceof Map && ! [[casbah]] . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 305 ---------------------------------------------
Adds a request parameter to the request spec . --> Wawley cawley --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[cawley]] ( String [[frère]] , Collection < ? > [[maris]] ) { spec . param ( [[frère]] , [[maris]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 306 ---------------------------------------------
Configure the form parameters with the given update strategy . --> Methode permettant dout deactivated dnete --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[nuñez]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 307 ---------------------------------------------
Log response to the output stream . --> Log response to if matches --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[headwind]] ) { return new ResponseLoggingFilter ( stream , [[headwind]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 308 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 300 / 6 / 2 / 308:  31%|███       | 308/1000 [2:23:21<5:22:05, 27.93s/it][Succeeded / Failed / Skipped / Total] 300 / 6 / 2 / 308:  31%|███       | 309/1000 [2:23:23<5:20:40, 27.84s/it][Succeeded / Failed / Skipped / Total] 301 / 6 / 2 / 309:  31%|███       | 309/1000 [2:23:23<5:20:40, 27.84s/it][Succeeded / Failed / Skipped / Total] 301 / 6 / 2 / 309:  31%|███       | 310/1000 [2:23:40<5:19:47, 27.81s/it][Succeeded / Failed / Skipped / Total] 302 / 6 / 2 / 310:  31%|███       | 310/1000 [2:23:40<5:19:47, 27.81s/it][Succeeded / Failed / Skipped / Total] 302 / 6 / 2 / 310:  31%|███       | 311/1000 [2:23:43<5:18:24, 27.73s/it][Succeeded / Failed / Skipped / Total] 303 / 6 / 2 / 311:  31%|███       | 311/1000 [2:23:43<5:18:24, 27.73s/it][Succeeded / Failed / Skipped / Total] 303 / 6 / 2 / 311:  31%|███       | 312/1000 [2:23:56<5:17:25, 27.68s/it][Succeeded / Failed / Skipped / Total] 304 / 6 / 2 / 312:  31%|███       | 312/1000 [2:23:56<5:17:25, 27.68s/it][Succeeded / Failed / Skipped / Total] 304 / 6 / 2 / 312:  31%|███▏      | 313/1000 [2:24:26<5:17:01, 27.69s/it][Succeeded / Failed / Skipped / Total] 305 / 6 / 2 / 313:  31%|███▏      | 313/1000 [2:24:26<5:17:01, 27.69s/it][Succeeded / Failed / Skipped / Total] 305 / 6 / 2 / 313:  31%|███▏      | 314/1000 [2:25:06<5:17:01, 27.73s/it][Succeeded / Failed / Skipped / Total] 306 / 6 / 2 / 314:  31%|███▏      | 314/1000 [2:25:06<5:17:01, 27.73s/it][Succeeded / Failed / Skipped / Total] 306 / 6 / 2 / 314:  32%|███▏      | 315/1000 [2:25:27<5:16:19, 27.71s/it][Succeeded / Failed / Skipped / Total] 307 / 6 / 2 / 315:  32%|███▏      | 315/1000 [2:25:27<5:16:19, 27.71s/it][Succeeded / Failed / Skipped / Total] 307 / 6 / 2 / 315:  32%|███▏      | 316/1000 [2:25:41<5:15:21, 27.66s/it]Adds a parameter to the request --> Set Stryker parameters --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[stryker]] ( String [[blinders]] , Object ... [[catamaran]] ) { spec . param ( [[blinders]] , [[catamaran]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 309 ---------------------------------------------
Cleanup data for non - collected state . --> Clean up for keys and sources --> Socre: 1.0

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 310 ---------------------------------------------
Creates a set of cookies . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , [[additionalCookies]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... [[pawan]] ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , [[pawan]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 311 ---------------------------------------------
Convert constant string to string binding --> private helper for chaining --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > key , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[chilton]] ( Key < T > key , Errors [[miscarriage]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 312 ---------------------------------------------
Cleans up internal dependencies for a given binding . --> looks for wipers --> Socre: 1.0

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[wipers]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 313 ---------------------------------------------
Remove a failed binding . --> Remove an injection point --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > [[binding]] , InjectionPoint [[ip]] ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( [[ip]] != null ) { constructors . remove ( [[ip]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[thinly]] ( Binding < ? > [[linking]] , InjectionPoint [[psi]] ) { failedJitBindings . add ( [[linking]] . getKey ( ) ) ; jitBindings . remove ( [[linking]] . getKey ( ) ) ; membersInjectorStore . remove ( [[linking]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[linking]] ) ; if ( [[psi]] != null ) { constructors . remove ( [[psi]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 314 ---------------------------------------------
Adds a cookie . --> lique header --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[key]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[liqueur]] ( String [[important]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[important]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 315 ---------------------------------------------
Convenience method to get a value and return it as an object . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object [[object]] = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[n]] > [[n]] getObject ( String path , Class < [[n]] > objectType ) { Object [[artifact]] = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( [[artifact]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 316 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 308 / 6 / 2 / 316:  32%|███▏      | 316/1000 [2:25:41<5:15:21, 27.66s/it][Succeeded / Failed / Skipped / Total] 308 / 6 / 2 / 316:  32%|███▏      | 317/1000 [2:26:00<5:14:35, 27.64s/it][Succeeded / Failed / Skipped / Total] 309 / 6 / 2 / 317:  32%|███▏      | 317/1000 [2:26:00<5:14:35, 27.64s/it][Succeeded / Failed / Skipped / Total] 309 / 6 / 2 / 317:  32%|███▏      | 318/1000 [2:26:02<5:13:12, 27.55s/it][Succeeded / Failed / Skipped / Total] 310 / 6 / 2 / 318:  32%|███▏      | 318/1000 [2:26:02<5:13:12, 27.55s/it][Succeeded / Failed / Skipped / Total] 310 / 6 / 2 / 318:  32%|███▏      | 319/1000 [2:26:16<5:12:15, 27.51s/it][Succeeded / Failed / Skipped / Total] 311 / 6 / 2 / 319:  32%|███▏      | 319/1000 [2:26:16<5:12:15, 27.51s/it][Succeeded / Failed / Skipped / Total] 311 / 6 / 2 / 319:  32%|███▏      | 320/1000 [2:26:29<5:11:17, 27.47s/it][Succeeded / Failed / Skipped / Total] 312 / 6 / 2 / 320:  32%|███▏      | 320/1000 [2:26:29<5:11:17, 27.47s/it][Succeeded / Failed / Skipped / Total] 312 / 6 / 2 / 320:  32%|███▏      | 321/1000 [2:27:01<5:10:59, 27.48s/it][Succeeded / Failed / Skipped / Total] 313 / 6 / 2 / 321:  32%|███▏      | 321/1000 [2:27:01<5:10:59, 27.48s/it][Succeeded / Failed / Skipped / Total] 313 / 6 / 2 / 321:  32%|███▏      | 322/1000 [2:27:21<5:10:17, 27.46s/it][Succeeded / Failed / Skipped / Total] 314 / 6 / 2 / 322:  32%|███▏      | 322/1000 [2:27:21<5:10:17, 27.46s/it][Succeeded / Failed / Skipped / Total] 314 / 6 / 2 / 322:  32%|███▏      | 323/1000 [2:27:24<5:08:58, 27.38s/it][Succeeded / Failed / Skipped / Total] 315 / 6 / 2 / 323:  32%|███▏      | 323/1000 [2:27:24<5:08:58, 27.38s/it][Succeeded / Failed / Skipped / Total] 315 / 6 / 2 / 323:  32%|███▏      | 324/1000 [2:27:32<5:07:49, 27.32s/it]Gets all parameters . --> configured decept icons --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext [[context]] , SingleParameterInjector < ? > [ ] [[parameterInjectors]] ) throws InternalProvisionException { if ( [[parameterInjectors]] == null ) { return NO_ARGUMENTS ; } int size = [[parameterInjectors]] . length ; Object [ ] [[parameters]] = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[decepticons]] ( InternalContext [[fount]] , SingleParameterInjector < ? > [ ] [[northerner]] ) throws InternalProvisionException { if ( [[northerner]] == null ) { return NO_ARGUMENTS ; } int size = [[northerner]] . length ; Object [ ] [[configured]] = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 317 ---------------------------------------------
Binds the injector to the provider . --> Lighting an unreachable provider --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > [[key]] = Key . get ( Injector . class ) ; InjectorFactory [[injectorFactory]] = new InjectorFactory ( injector ) ; injector . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Injector > ( injector , [[key]] , SourceProvider . UNKNOWN_SOURCE , [[injectorFactory]] , Scoping . UNSCOPED , [[injectorFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[lighter]] ( InjectorImpl injector ) { Key < Injector > [[principal]] = Key . get ( Injector . class ) ; InjectorFactory [[absurdities]] = new InjectorFactory ( injector ) ; injector . state . putBinding ( [[principal]] , new ProviderInstanceBindingImpl < Injector > ( injector , [[principal]] , SourceProvider . UNKNOWN_SOURCE , [[absurdities]] , Scoping . UNSCOPED , [[absurdities]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 318 ---------------------------------------------
Index all explicit bindings for this type . --> need to be synchronized --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[erence]] ( ) { for ( Binding < ? > [[bound]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[bound]] . getKey ( ) . getTypeLiteral ( ) , [[bound]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 319 ---------------------------------------------
Binds a logger to the injector . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl [[injector]] ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory [[loggerFactory]] = new LoggerFactory ( ) ; [[injector]] . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( [[injector]] , [[key]] , SourceProvider . UNKNOWN_SOURCE , [[loggerFactory]] , Scoping . UNSCOPED , [[loggerFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[paralegal]] ( InjectorImpl [[mouthpiece]] ) { Key < Logger > [[vitale]] = Key . get ( Logger . class ) ; LoggerFactory [[schedule]] = new LoggerFactory ( ) ; [[mouthpiece]] . state . putBinding ( [[vitale]] , new ProviderInstanceBindingImpl < Logger > ( [[mouthpiece]] , [[vitale]] , SourceProvider . UNKNOWN_SOURCE , [[schedule]] , Scoping . UNSCOPED , [[schedule]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 320 ---------------------------------------------
Checks whether method overrides a method . --> blin method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[layin]] ( Method [[into]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 321 ---------------------------------------------
Returns the internal dependencies of the given binding . --> dumper - dumper --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[dumper]] ( BindingImpl < ? > [[forcible]] ) { if ( [[forcible]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[forcible]] ) . getInternalDependencies ( ) ; } else if ( [[forcible]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[forcible]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 322 ---------------------------------------------
Initializes the delegate . --> Don t do anything! --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[wads]] ( MembersInjector < T > [[ambassadors]] ) { checkState ( this . [[secretarial]] == null , "delegate already initialized" ) ; this . [[secretarial]] = checkNotNull ( [[ambassadors]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 323 ---------------------------------------------
Checks for missing binding annotations . --> used to report errors --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors errors ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( errors , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[hairbrush]] ( Member [[delegated]] , Errors errors ) { Annotation [[nï]] = Annotations . findBindingAnnotation ( errors , [[delegated]] , ( ( AnnotatedElement ) [[delegated]] ) . getAnnotations ( ) ) ; if ( [[nï]] == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 324 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 316 / 6 / 2 / 324:  32%|███▏      | 324/1000 [2:27:32<5:07:49, 27.32s/it][Succeeded / Failed / Skipped / Total] 316 / 6 / 2 / 324:  32%|███▎      | 325/1000 [2:27:34<5:06:29, 27.24s/it][Succeeded / Failed / Skipped / Total] 317 / 6 / 2 / 325:  32%|███▎      | 325/1000 [2:27:34<5:06:29, 27.24s/it][Succeeded / Failed / Skipped / Total] 317 / 6 / 2 / 325:  33%|███▎      | 326/1000 [2:27:34<5:05:07, 27.16s/it][Succeeded / Failed / Skipped / Total] 318 / 6 / 2 / 326:  33%|███▎      | 326/1000 [2:27:34<5:05:07, 27.16s/it][Succeeded / Failed / Skipped / Total] 318 / 6 / 2 / 326:  33%|███▎      | 327/1000 [2:27:42<5:04:00, 27.10s/it][Succeeded / Failed / Skipped / Total] 319 / 6 / 2 / 327:  33%|███▎      | 327/1000 [2:27:42<5:04:00, 27.10s/it][Succeeded / Failed / Skipped / Total] 319 / 6 / 2 / 327:  33%|███▎      | 328/1000 [2:28:01<5:03:15, 27.08s/it][Succeeded / Failed / Skipped / Total] 320 / 6 / 2 / 328:  33%|███▎      | 328/1000 [2:28:01<5:03:15, 27.08s/it][Succeeded / Failed / Skipped / Total] 320 / 6 / 2 / 328:  33%|███▎      | 329/1000 [2:28:42<5:03:17, 27.12s/it][Succeeded / Failed / Skipped / Total] 321 / 6 / 2 / 329:  33%|███▎      | 329/1000 [2:28:42<5:03:17, 27.12s/it][Succeeded / Failed / Skipped / Total] 321 / 6 / 2 / 329:  33%|███▎      | 330/1000 [2:29:34<5:03:40, 27.19s/it][Succeeded / Failed / Skipped / Total] 322 / 6 / 2 / 330:  33%|███▎      | 330/1000 [2:29:34<5:03:40, 27.19s/it][Succeeded / Failed / Skipped / Total] 322 / 6 / 2 / 330:  33%|███▎      | 331/1000 [2:29:51<5:02:52, 27.16s/it][Succeeded / Failed / Skipped / Total] 323 / 6 / 2 / 331:  33%|███▎      | 331/1000 [2:29:51<5:02:52, 27.16s/it][Succeeded / Failed / Skipped / Total] 323 / 6 / 2 / 331:  33%|███▎      | 332/1000 [2:29:57<5:01:42, 27.10s/it][Succeeded / Failed / Skipped / Total] 324 / 6 / 2 / 332:  33%|███▎      | 332/1000 [2:29:57<5:01:42, 27.10s/it][Succeeded / Failed / Skipped / Total] 324 / 6 / 2 / 332:  33%|███▎      | 333/1000 [2:30:26<5:01:19, 27.11s/it]The provider type . --> verlines verlaine --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[verlaine]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 325 ---------------------------------------------
Prepare builtIn converters . --> injector --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[dinsdale]] ( InjectorImpl [[mouthpiece]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 326 ---------------------------------------------
Canonicalize the type of a given type . --> Methode permettant de Klasse --> Socre: 1.0

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[canonicalizeForKey]] ( TypeLiteral < T > [[typeLiteral]] ) { Type [[type]] = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( [[type]] ) ) { Errors [[errors]] = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( [[errors]] . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[parameterizedType]] = ( ParameterizedType ) [[type]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[stretches]] ( TypeLiteral < T > [[traditional]] ) { Type [[fella]] = [[traditional]] . getType ( ) ; if ( ! isFullySpecified ( [[fella]] ) ) { Errors [[weaknesses]] = new Errors ( ) . keyNotFullySpecified ( [[traditional]] ) ; throw new ConfigurationException ( [[weaknesses]] . getMessages ( ) ) ; } if ( [[traditional]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[feeble]] = ( ParameterizedType ) [[fella]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 327 ---------------------------------------------
Resolves a list of type literals . --> Resolve type literals --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[plummet]] ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 328 ---------------------------------------------
Canonicalize a class loader to a system bridge . --> Default securityfish --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[rizzo]] ( ClassLoader [[swordfish]] ) { return [[swordfish]] != null ? [[swordfish]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 329 ---------------------------------------------
Fix annotations . --> also used by tests --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[meunier]] ( Key < ? > [[hinge]] ) { return [[hinge]] . getAnnotation ( ) == null ? [[hinge]] : Key . get ( [[hinge]] . getTypeLiteral ( ) , [[hinge]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 330 ---------------------------------------------
Checks if the given class has the same version of the same class . --> Casts a casson --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader [[classLoader]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[classLoader]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[garçon]] ( ClassLoader [[silverio]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[silverio]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 331 ---------------------------------------------
Validate all pending injects . --> Validate activator --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[activator]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 332 ---------------------------------------------
Creates a new instance of this class . --> Convenience factory method to construct a new object --> Socre: 1.0

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[bearers]] ( Object [ ] [[ferraris]] ) throws Throwable { constructor . setAccessible ( "[[Accurate]]" == "[[Accurate]]" ) ; try { return constructor . newInstance ( [[ferraris]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
[Succeeded / Failed / Skipped / Total] 325 / 6 / 2 / 333:  33%|███▎      | 333/1000 [2:30:26<5:01:19, 27.11s/it][Succeeded / Failed / Skipped / Total] 325 / 6 / 2 / 333:  33%|███▎      | 334/1000 [2:30:29<5:00:04, 27.03s/it][Succeeded / Failed / Skipped / Total] 326 / 6 / 2 / 334:  33%|███▎      | 334/1000 [2:30:29<5:00:04, 27.03s/it][Succeeded / Failed / Skipped / Total] 326 / 6 / 2 / 334:  34%|███▎      | 335/1000 [2:31:49<5:01:22, 27.19s/it][Succeeded / Failed / Skipped / Total] 327 / 6 / 2 / 335:  34%|███▎      | 335/1000 [2:31:49<5:01:22, 27.19s/it][Succeeded / Failed / Skipped / Total] 327 / 6 / 2 / 335:  34%|███▎      | 336/1000 [2:31:53<5:00:09, 27.12s/it][Succeeded / Failed / Skipped / Total] 328 / 6 / 2 / 336:  34%|███▎      | 336/1000 [2:31:53<5:00:09, 27.12s/it][Succeeded / Failed / Skipped / Total] 328 / 6 / 2 / 336:  34%|███▎      | 337/1000 [2:32:24<4:59:49, 27.13s/it][Succeeded / Failed / Skipped / Total] 328 / 7 / 2 / 337:  34%|███▎      | 337/1000 [2:32:24<4:59:49, 27.13s/it][Succeeded / Failed / Skipped / Total] 328 / 7 / 2 / 337:  34%|███▍      | 338/1000 [2:33:47<5:01:12, 27.30s/it][Succeeded / Failed / Skipped / Total] 329 / 7 / 2 / 338:  34%|███▍      | 338/1000 [2:33:47<5:01:12, 27.30s/it][Succeeded / Failed / Skipped / Total] 329 / 7 / 2 / 338:  34%|███▍      | 339/1000 [2:33:52<5:00:01, 27.23s/it][Succeeded / Failed / Skipped / Total] 330 / 7 / 2 / 339:  34%|███▍      | 339/1000 [2:33:52<5:00:01, 27.23s/it][Succeeded / Failed / Skipped / Total] 330 / 7 / 2 / 339:  34%|███▍      | 340/1000 [2:34:17<4:59:30, 27.23s/it]--------------------------------------------- Result 333 ---------------------------------------------
Add a dispatcher to the servlet request . --> Exposed for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest [[servletRequest]] , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[expanded]] ( ServletRequest [[docking]] , final ManagedServletPipeline [[holla]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 334 ---------------------------------------------
Scope factory method . --> Scoped methods --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl [[injector]] , InternalFactory < ? extends T > [[creator]] , Object source , Scoping [[scoping]] ) { if ( [[scoping]] . isNoScope ( ) ) { return [[creator]] ; } Scope scope = [[scoping]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl [[injecting]] , InternalFactory < ? extends T > [[creators]] , Object source , Scoping [[pathfinder]] ) { if ( [[pathfinder]] . isNoScope ( ) ) { return [[creators]] ; } Scope scope = [[pathfinder]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 335 ---------------------------------------------
Converts a scoping to a scoping . --> Injects a scoping --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[titti]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 336 ---------------------------------------------
Normalize the path . --> Parse the given runways --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String [[path]] ) { StringBuilder sb = new StringBuilder ( [[path]] . length ( ) ) ; int queryStart = [[path]] . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = [[path]] . substring ( queryStart ) ; [[path]] = [[path]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[espn]] ( String [[runways]] ) { StringBuilder sb = new StringBuilder ( [[runways]] . length ( ) ) ; int queryStart = [[runways]] . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = [[runways]] . substring ( queryStart ) ; [[runways]] = [[runways]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 337 ---------------------------------------------
Generates an annotation for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 338 ---------------------------------------------
Checks if annotation is retained at runtime . --> Determines whether or not a particular class implements RetentionPolicy --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[swedes]] ( Class < ? extends Annotation > [[horatio]] ) { Retention [[possesses]] = [[horatio]] . getAnnotation ( Retention . class ) ; return [[possesses]] != null && [[possesses]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 339 ---------------------------------------------
Finds a scope annotation . --> Helper method to find a duplicate of annotations --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > [[annotationType]] = annotation . annotationType ( ) ; if ( isScopeAnnotation ( [[annotationType]] ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , [[annotationType]] ) ; } else { found = [[annotationType]] ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[coordinating]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > [[lps]] = annotation . annotationType ( ) ; if ( isScopeAnnotation ( [[lps]] ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , [[lps]] ) ; } else { found = [[lps]] ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 340 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 331 / 7 / 2 / 340:  34%|███▍      | 340/1000 [2:34:17<4:59:30, 27.23s/it][Succeeded / Failed / Skipped / Total] 331 / 7 / 2 / 340:  34%|███▍      | 341/1000 [2:35:34<5:00:39, 27.37s/it][Succeeded / Failed / Skipped / Total] 332 / 7 / 2 / 341:  34%|███▍      | 341/1000 [2:35:34<5:00:39, 27.37s/it][Succeeded / Failed / Skipped / Total] 332 / 7 / 2 / 341:  34%|███▍      | 342/1000 [2:35:55<4:59:59, 27.36s/it][Succeeded / Failed / Skipped / Total] 333 / 7 / 2 / 342:  34%|███▍      | 342/1000 [2:35:55<4:59:59, 27.36s/it][Succeeded / Failed / Skipped / Total] 333 / 7 / 2 / 342:  34%|███▍      | 343/1000 [2:36:01<4:58:51, 27.29s/it][Succeeded / Failed / Skipped / Total] 334 / 7 / 2 / 343:  34%|███▍      | 343/1000 [2:36:01<4:58:51, 27.29s/it][Succeeded / Failed / Skipped / Total] 334 / 7 / 2 / 343:  34%|███▍      | 344/1000 [2:36:05<4:57:39, 27.22s/it][Succeeded / Failed / Skipped / Total] 335 / 7 / 2 / 344:  34%|███▍      | 344/1000 [2:36:05<4:57:39, 27.22s/it][Succeeded / Failed / Skipped / Total] 335 / 7 / 2 / 344:  34%|███▍      | 345/1000 [2:36:13<4:56:36, 27.17s/it][Succeeded / Failed / Skipped / Total] 336 / 7 / 2 / 345:  34%|███▍      | 345/1000 [2:36:13<4:56:36, 27.17s/it][Succeeded / Failed / Skipped / Total] 336 / 7 / 2 / 345:  35%|███▍      | 346/1000 [2:36:24<4:55:39, 27.12s/it]Gets the binding key . --> Holler s --> Socre: 1.0

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > [[type]] , Member member , Annotation [ ] annotations , Errors [[errors]] ) throws ErrorsException { int numErrorsBefore = [[errors]] . size ( ) ; Annotation found = findBindingAnnotation ( [[errors]] , member , annotations ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( [[type]] ) : Key . get ( [[type]] , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[holler]] ( TypeLiteral < ? > [[styles]] , Member member , Annotation [ ] annotations , Errors [[weaknesses]] ) throws ErrorsException { int numErrorsBefore = [[weaknesses]] . size ( ) ; Annotation found = findBindingAnnotation ( [[weaknesses]] , member , annotations ) ; [[weaknesses]] . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( [[styles]] ) : Key . get ( [[styles]] , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 341 ---------------------------------------------
Checks whether the given member is public or not . --> Checks membership of membership --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[parameterTypes]] ; if ( [[member]] instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[parameterTypes]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[glider]] ( Member [[membership]] ) { if ( ! Modifier . isPublic ( [[membership]] . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[spagna]] ; if ( [[membership]] instanceof Constructor ) { [[spagna]] = ( ( Constructor ) [[membership]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[membership]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[spagna]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[spagna]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 342 ---------------------------------------------
Gets the name of the key . --> get numAnnotation --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation annotation = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[numai]] ( Key < ? > [[elham]] ) { Annotation annotation = [[elham]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[elham]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[elham]] . getAnnotation ( ) . toString ( ) ; } else if ( [[elham]] . getAnnotationType ( ) != null ) { return "@" + [[elham]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 343 ---------------------------------------------
Add the direct type binding . -->  ginger bread breaders --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[gingerbread]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 344 ---------------------------------------------
Initializes the delegate provider . --> Don t override this method --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[dishwater]] ( Provider < T > [[reps]] ) { checkState ( this . [[deputies]] == null , "delegate already initialized" ) ; this . [[deputies]] = checkNotNull ( [[reps]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 345 ---------------------------------------------
Checks if the given interceptor has scope annotation . --> package private for testing --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > [[interceptorClass]] ) { for ( Annotation [[annotation]] : [[interceptorClass]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[annotation]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[smack]] ( Class < ? extends Interceptor > [[compositions]] ) { for ( Annotation [[saber]] : [[compositions]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[saber]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "[[Specious]]" != "[[Specious]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 346 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 337 / 7 / 2 / 346:  35%|███▍      | 346/1000 [2:36:24<4:55:39, 27.12s/it][Succeeded / Failed / Skipped / Total] 337 / 7 / 2 / 346:  35%|███▍      | 347/1000 [2:37:36<4:56:35, 27.25s/it][Succeeded / Failed / Skipped / Total] 338 / 7 / 2 / 347:  35%|███▍      | 347/1000 [2:37:36<4:56:35, 27.25s/it][Succeeded / Failed / Skipped / Total] 338 / 7 / 2 / 347:  35%|███▍      | 348/1000 [2:37:46<4:55:36, 27.20s/it][Succeeded / Failed / Skipped / Total] 339 / 7 / 2 / 348:  35%|███▍      | 348/1000 [2:37:46<4:55:36, 27.20s/it][Succeeded / Failed / Skipped / Total] 339 / 7 / 2 / 348:  35%|███▍      | 349/1000 [2:37:50<4:54:25, 27.14s/it][Succeeded / Failed / Skipped / Total] 340 / 7 / 2 / 349:  35%|███▍      | 349/1000 [2:37:50<4:54:25, 27.14s/it][Succeeded / Failed / Skipped / Total] 340 / 7 / 2 / 349:  35%|███▌      | 350/1000 [2:37:55<4:53:17, 27.07s/it][Succeeded / Failed / Skipped / Total] 341 / 7 / 2 / 350:  35%|███▌      | 350/1000 [2:37:55<4:53:17, 27.07s/it][Succeeded / Failed / Skipped / Total] 341 / 7 / 2 / 350:  35%|███▌      | 351/1000 [2:37:57<4:52:04, 27.00s/it][Succeeded / Failed / Skipped / Total] 342 / 7 / 2 / 351:  35%|███▌      | 351/1000 [2:37:57<4:52:04, 27.00s/it][Succeeded / Failed / Skipped / Total] 342 / 7 / 2 / 351:  35%|███▌      | 352/1000 [2:43:55<5:01:45, 27.94s/it][Succeeded / Failed / Skipped / Total] 342 / 8 / 2 / 352:  35%|███▌      | 352/1000 [2:43:55<5:01:45, 27.94s/it][Succeeded / Failed / Skipped / Total] 342 / 8 / 2 / 352:  35%|███▌      | 353/1000 [2:44:08<5:00:51, 27.90s/it]Create a new RealMapBinder for the given key and value type . --> used by GantTinder --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder binder , TypeLiteral < K > keyType , Key < V > [[valueTypeAndAnnotation]] ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > [[valueType]] = [[valueTypeAndAnnotation]] . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( binder , keyType , [[valueType]] , [[valueTypeAndAnnotation]] . ofType ( mapOf ( keyType , [[valueType]] ) ) , RealMultibinder . newRealSetBinder ( binder , [[valueTypeAndAnnotation]] . ofType ( entryOfProviderOf ( keyType , [[valueType]] ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[glant]] ( Binder binder , TypeLiteral < K > keyType , Key < V > [[hut]] ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > [[bystander]] = [[hut]] . getTypeLiteral ( ) ; return [[glant]] ( binder , keyType , [[bystander]] , [[hut]] . ofType ( mapOf ( keyType , [[bystander]] ) ) , RealMultibinder . newRealSetBinder ( binder , [[hut]] . ofType ( entryOfProviderOf ( keyType , [[bystander]] ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 347 ---------------------------------------------
Looks up a constructor in the cache . --> documentation inherited from org --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors errors ) throws ErrorsException { return cache . get ( [[constructorInjector]] , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[obtaining]] ( InjectionPoint [[antónio]] , Errors errors ) throws ErrorsException { return cache . get ( [[antónio]] , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 348 ---------------------------------------------
Creates a new instance . -->  offered by the framing context --> Socre: 1.0

[[[[Adv]]]]: private T [[provision]] ( InternalContext [[context]] , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( [[context]] , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( parameters ) ; [[constructionContext]] . setProxyDelegates ( [[t]] ) ; } finally { [[constructionContext]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[offered]] ( InternalContext [[framing]] , ConstructionContext < T > [[yard]] ) throws InternalProvisionException { try { T [[wo]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( [[framing]] , parameterInjectors ) ; [[wo]] = constructionProxy . newInstance ( parameters ) ; [[yard]] . setProxyDelegates ( [[wo]] ) ; } finally { [[yard]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 349 ---------------------------------------------
Writes the replace method . --> write replace method --> Socre: 1.0

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int i = 0 ; i < [[sourcesAsStrings]] . length ; i ++ ) { [[sourcesAsStrings]] [ i ] = Errors . convert ( [[sourcesAsStrings]] [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[andrej]] = sources . toArray ( ) ; for ( int i = 0 ; i < [[andrej]] . length ; i ++ ) { [[andrej]] [ i ] = Errors . convert ( [[andrej]] [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[andrej]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 350 ---------------------------------------------
Returns the Module for the given module --> Factory --> Socre: 1.0

[[[[Adv]]]]: static Module forModule ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module forModule ( Module [[ammo]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 351 ---------------------------------------------
Returns all registered methods . --> Get all assigned methods --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[risk]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 352 ---------------------------------------------
Request member injection . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 353 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 343 / 8 / 2 / 353:  35%|███▌      | 353/1000 [2:44:08<5:00:51, 27.90s/it][Succeeded / Failed / Skipped / Total] 343 / 8 / 2 / 353:  35%|███▌      | 354/1000 [2:44:13<4:59:40, 27.83s/it][Succeeded / Failed / Skipped / Total] 344 / 8 / 2 / 354:  35%|███▌      | 354/1000 [2:44:13<4:59:40, 27.83s/it][Succeeded / Failed / Skipped / Total] 344 / 8 / 2 / 354:  36%|███▌      | 355/1000 [2:44:17<4:58:29, 27.77s/it][Succeeded / Failed / Skipped / Total] 345 / 8 / 2 / 355:  36%|███▌      | 355/1000 [2:44:17<4:58:29, 27.77s/it][Succeeded / Failed / Skipped / Total] 345 / 8 / 2 / 355:  36%|███▌      | 356/1000 [2:44:38<4:57:49, 27.75s/it][Succeeded / Failed / Skipped / Total] 346 / 8 / 2 / 356:  36%|███▌      | 356/1000 [2:44:38<4:57:49, 27.75s/it][Succeeded / Failed / Skipped / Total] 346 / 8 / 2 / 356:  36%|███▌      | 357/1000 [2:44:44<4:56:43, 27.69s/it][Succeeded / Failed / Skipped / Total] 347 / 8 / 2 / 357:  36%|███▌      | 357/1000 [2:44:44<4:56:43, 27.69s/it][Succeeded / Failed / Skipped / Total] 347 / 8 / 2 / 357:  36%|███▌      | 358/1000 [2:44:48<4:55:32, 27.62s/it][Succeeded / Failed / Skipped / Total] 348 / 8 / 2 / 358:  36%|███▌      | 358/1000 [2:44:48<4:55:32, 27.62s/it][Succeeded / Failed / Skipped / Total] 348 / 8 / 2 / 358:  36%|███▌      | 359/1000 [2:44:49<4:54:18, 27.55s/it]Checks if a type is not defined . -->  tuned for testing --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[tuned]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 354 ---------------------------------------------
Returns true if the constructor has matching parameters . --> simulate test --> Socre: 1.0

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors [[errors]] ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > [[constructorKeys]] = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > [[param]] : params ) { Key < ? > [[paramKey]] = Annotations . getKey ( [[param]] , constructor , paramAnnotations [ p ++ ] , [[errors]] ) ; [[constructorKeys]] . add ( [[paramKey]] ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[simulated]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors [[goofs]] ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > [[condoleezza]] = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > [[pharmaceuticals]] : params ) { Key < ? > [[geddy]] = Annotations . getKey ( [[pharmaceuticals]] , constructor , paramAnnotations [ p ++ ] , [[goofs]] ) ; [[condoleezza]] . add ( [[geddy]] ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 355 ---------------------------------------------
Given a set of dependencies return the list of dependencies removed . --> Filters the dependents --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[dep]] : [[deps]] ) { Class < ? > annotationType = [[dep]] . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[builder]] . add ( [[dep]] ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[novice]] ( Set < Dependency < ? > > [[doddering]] ) { ImmutableSet . Builder < Dependency < ? > > [[setters]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[iip]] : [[doddering]] ) { Class < ? > annotationType = [[iip]] . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[setters]] . add ( [[iip]] ) ; } } return [[setters]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 356 ---------------------------------------------
Checks if the given set of dependencies can be used for optimizations . --> don tinderbox --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > [[dependencies]] , Class < ? > [[implementation]] , TypeLiteral < ? > [[factoryType]] ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[tinderbox]] ( Set < Dependency < ? > > [[ingenuity]] , Class < ? > [[attainment]] , TypeLiteral < ? > [[talmadge]] ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 357 ---------------------------------------------
Gets the binding from Guice . --> Called by Guice --> Socre: 1.0

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method [[method]] , final Object [ ] args , final AssistData [[data]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > [[returnType]] = [[data]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[cozier]] ( final Method [[wherewithal]] , final Object [ ] args , final AssistData [[elucidate]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > [[sightings]] = [[elucidate]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 358 ---------------------------------------------
Delegates the method to the proxy . --> Overriding super methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] [[args]] ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] [[accessible]] ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 359 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 349 / 8 / 2 / 359:  36%|███▌      | 359/1000 [2:44:49<4:54:18, 27.55s/it][Succeeded / Failed / Skipped / Total] 349 / 8 / 2 / 359:  36%|███▌      | 360/1000 [2:45:02<4:53:24, 27.51s/it][Succeeded / Failed / Skipped / Total] 350 / 8 / 2 / 360:  36%|███▌      | 360/1000 [2:45:02<4:53:24, 27.51s/it][Succeeded / Failed / Skipped / Total] 350 / 8 / 2 / 360:  36%|███▌      | 361/1000 [2:45:05<4:52:14, 27.44s/it][Succeeded / Failed / Skipped / Total] 351 / 8 / 2 / 361:  36%|███▌      | 361/1000 [2:45:05<4:52:14, 27.44s/it][Succeeded / Failed / Skipped / Total] 351 / 8 / 2 / 361:  36%|███▌      | 362/1000 [2:46:24<4:53:17, 27.58s/it][Succeeded / Failed / Skipped / Total] 352 / 8 / 2 / 362:  36%|███▌      | 362/1000 [2:46:24<4:53:17, 27.58s/it][Succeeded / Failed / Skipped / Total] 352 / 8 / 2 / 362:  36%|███▋      | 363/1000 [2:46:28<4:52:07, 27.52s/it][Succeeded / Failed / Skipped / Total] 353 / 8 / 2 / 363:  36%|███▋      | 363/1000 [2:46:28<4:52:07, 27.52s/it][Succeeded / Failed / Skipped / Total] 353 / 8 / 2 / 363:  36%|███▋      | 364/1000 [2:49:37<4:56:22, 27.96s/it][Succeeded / Failed / Skipped / Total] 354 / 8 / 2 / 364:  36%|███▋      | 364/1000 [2:49:37<4:56:22, 27.96s/it][Succeeded / Failed / Skipped / Total] 354 / 8 / 2 / 364:  36%|███▋      | 365/1000 [2:49:45<4:55:20, 27.91s/it][Succeeded / Failed / Skipped / Total] 355 / 8 / 2 / 365:  36%|███▋      | 365/1000 [2:49:45<4:55:20, 27.91s/it][Succeeded / Failed / Skipped / Total] 355 / 8 / 2 / 365:  37%|███▋      | 366/1000 [2:50:07<4:54:41, 27.89s/it]Throws an exception when the key is missing . --> Throws an exception if no implementation has been bound . --> Socre: 1.0

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[longhorns]] = new StringBuilder ( ) ; [[longhorns]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 360 ---------------------------------------------
Get dependencies for ctor --> also used for testing --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint [[ctorPoint]] , TypeLiteral < ? > [[implementation]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; [[builder]] . addAll ( [[ctorPoint]] . getDependencies ( ) ) ; if ( ! [[implementation]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[ip]] : InjectionPoint . forInstanceMethodsAndFields ( [[implementation]] ) ) { [[builder]] . addAll ( [[ip]] . getDependencies ( ) ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[amen]] ( InjectionPoint [[fuss]] , TypeLiteral < ? > [[achievement]] ) { ImmutableSet . Builder < Dependency < ? > > [[growers]] = ImmutableSet . builder ( ) ; [[growers]] . addAll ( [[fuss]] . getDependencies ( ) ) ; if ( ! [[achievement]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[fp]] : InjectionPoint . forInstanceMethodsAndFields ( [[achievement]] ) ) { [[growers]] . addAll ( [[fp]] . getDependencies ( ) ) ; } } return [[growers]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 361 ---------------------------------------------
Add a new RealMultibinder to the given binder . --> Create a new RealMultibinder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[binder]] , Key < T > [[key]] ) { [[binder]] = [[binder]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[result]] = new RealMultibinder <> ( [[binder]] , [[key]] ) ; [[binder]] . install ( [[result]] ) ; return [[result]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[obligatory]] , Key < T > [[rudiments]] ) { [[obligatory]] = [[obligatory]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[wake]] = new RealMultibinder <> ( [[obligatory]] , [[rudiments]] ) ; [[obligatory]] . install ( [[wake]] ) ; return [[wake]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 362 ---------------------------------------------
Find the next filter . --> Sort by index --> Socre: 1.0

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest [[request]] ) { while ( ++ index < filterDefinitions . length ) { Filter [[filter]] = filterDefinitions [ index ] . getFilterIfMatching ( [[request]] ) ; if ( [[filter]] != null ) { return [[filter]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[sort]] ( HttpServletRequest [[urging]] ) { while ( ++ index < filterDefinitions . length ) { Filter [[sampling]] = filterDefinitions [ index ] . getFilterIfMatching ( [[urging]] ) ; if ( [[sampling]] != null ) { return [[sampling]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 363 ---------------------------------------------
Returns the internal constructor . --> Acquire a new instance of a class --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[à]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 364 ---------------------------------------------
Gets the internal dependencies . --> Methode permettant de injection point --> Socre: 1.0

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[mamá]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 365 ---------------------------------------------
Scan a module . --> simplified method --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( [[module]] , "[[False]]" != "[[False]]" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[guerrillas]] ( Object [[regrouped]] , ModuleAnnotatedMethodScanner [[digitally]] ) { return forObject ( [[regrouped]] , "[[Fraudulent]]" != "[[Fraudulent]]" , [[digitally]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 366 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 356 / 8 / 2 / 366:  37%|███▋      | 366/1000 [2:50:07<4:54:41, 27.89s/it][Succeeded / Failed / Skipped / Total] 356 / 8 / 2 / 366:  37%|███▋      | 367/1000 [2:50:48<4:54:35, 27.92s/it][Succeeded / Failed / Skipped / Total] 357 / 8 / 2 / 367:  37%|███▋      | 367/1000 [2:50:48<4:54:35, 27.92s/it][Succeeded / Failed / Skipped / Total] 357 / 8 / 2 / 367:  37%|███▋      | 368/1000 [2:50:50<4:53:24, 27.86s/it][Succeeded / Failed / Skipped / Total] 358 / 8 / 2 / 368:  37%|███▋      | 368/1000 [2:50:50<4:53:24, 27.86s/it][Succeeded / Failed / Skipped / Total] 358 / 8 / 2 / 368:  37%|███▋      | 369/1000 [2:50:59<4:52:23, 27.80s/it][Succeeded / Failed / Skipped / Total] 359 / 8 / 2 / 369:  37%|███▋      | 369/1000 [2:50:59<4:52:23, 27.80s/it][Succeeded / Failed / Skipped / Total] 359 / 8 / 2 / 369:  37%|███▋      | 370/1000 [2:51:23<4:51:50, 27.79s/it][Succeeded / Failed / Skipped / Total] 360 / 8 / 2 / 370:  37%|███▋      | 370/1000 [2:51:23<4:51:50, 27.79s/it][Succeeded / Failed / Skipped / Total] 360 / 8 / 2 / 370:  37%|███▋      | 371/1000 [2:51:29<4:50:45, 27.73s/it][Succeeded / Failed / Skipped / Total] 361 / 8 / 2 / 371:  37%|███▋      | 371/1000 [2:51:29<4:50:45, 27.73s/it][Succeeded / Failed / Skipped / Total] 361 / 8 / 2 / 371:  37%|███▋      | 372/1000 [2:51:49<4:50:04, 27.71s/it][Succeeded / Failed / Skipped / Total] 362 / 8 / 2 / 372:  37%|███▋      | 372/1000 [2:51:49<4:50:04, 27.71s/it][Succeeded / Failed / Skipped / Total] 362 / 8 / 2 / 372:  37%|███▋      | 373/1000 [2:51:55<4:49:00, 27.66s/it]Gets the annotation for the given method . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method [[method]] ) { if ( [[method]] . isBridge ( ) || [[method]] . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > [[annotationClass]] : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = [[method]] . getAnnotation ( [[annotationClass]] ) ; if ( foundAnnotation != null ) { if ( [[annotation]] != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , [[method]] ) ; return null ; } [[annotation]] = foundAnnotation ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method [[fashion]] ) { if ( [[fashion]] . isBridge ( ) || [[fashion]] . isSynthetic ( ) ) { return null ; } Annotation [[dominions]] = null ; for ( Class < ? extends Annotation > [[caravaggio]] : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = [[fashion]] . getAnnotation ( [[caravaggio]] ) ; if ( foundAnnotation != null ) { if ( [[dominions]] != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , [[fashion]] ) ; return null ; } [[dominions]] = foundAnnotation ; } } return [[dominions]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 367 ---------------------------------------------
Checks if the given constructor has at least one at runtime . --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[bet]] ( Constructor [[billionaire]] ) { return [[billionaire]] . isAnnotationPresent ( Inject . class ) || [[billionaire]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 368 ---------------------------------------------
Initialize this injector . --> This method should be called by tests --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[perseverance]] ( Errors [[improprieties]] ) { injector . lookups = injector ; new LookupProcessor ( [[improprieties]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 369 ---------------------------------------------
Wrap a callable into a Callable . --> hackunger --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[callable]] , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[chargin]] ( Callable < T > [[rebekah]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[rebekah]] , [[chargin]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 370 ---------------------------------------------
Gets the line number for the given member . --> Returns armani --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[armani]] ( Member [[gentleman]] ) { Preconditions . checkArgument ( type == [[gentleman]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[gentleman]] , [[gentleman]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[gentleman]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 371 ---------------------------------------------
Validates and canonicalizes the given value . --> throw IllegalArgumentException --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > [[key]] , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! [[key]] . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + [[key]] + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[pontiff]] ( Key < ? > [[wrenches]] , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! [[wrenches]] . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + [[wrenches]] + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 372 ---------------------------------------------
Wraps a callable into a Callable . --> yadda --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[yadda]] ( Callable < T > [[windin]] ) { return wrap ( [[windin]] , [[yadda]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 373 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 363 / 8 / 2 / 373:  37%|███▋      | 373/1000 [2:51:55<4:49:00, 27.66s/it][Succeeded / Failed / Skipped / Total] 363 / 8 / 2 / 373:  37%|███▋      | 374/1000 [2:53:25<4:50:16, 27.82s/it][Succeeded / Failed / Skipped / Total] 364 / 8 / 2 / 374:  37%|███▋      | 374/1000 [2:53:25<4:50:16, 27.82s/it][Succeeded / Failed / Skipped / Total] 364 / 8 / 2 / 374:  38%|███▊      | 375/1000 [2:54:19<4:50:32, 27.89s/it][Succeeded / Failed / Skipped / Total] 365 / 8 / 2 / 375:  38%|███▊      | 375/1000 [2:54:19<4:50:32, 27.89s/it][Succeeded / Failed / Skipped / Total] 365 / 8 / 2 / 375:  38%|███▊      | 376/1000 [2:56:29<4:52:54, 28.16s/it][Succeeded / Failed / Skipped / Total] 366 / 8 / 2 / 376:  38%|███▊      | 376/1000 [2:56:29<4:52:54, 28.16s/it][Succeeded / Failed / Skipped / Total] 366 / 8 / 2 / 376:  38%|███▊      | 377/1000 [2:56:42<4:52:00, 28.12s/it]Gets the injectors for the given injection points . --> Get a list of injected injections --> Socre: 1.0

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[injectionPoint]] : injectionPoints ) { try { Errors [[errorsForMember]] = [[injectionPoint]] . isOptional ( ) ? new Errors ( [[injectionPoint]] ) : errors . withSource ( [[injectionPoint]] ) ; SingleMemberInjector [[injector]] = [[injectionPoint]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[injector]] , [[injectionPoint]] , [[errorsForMember]] ) : new SingleMethodInjector ( this . [[injector]] , [[injectionPoint]] , [[errorsForMember]] ) ; [[injectors]] . add ( [[injector]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injecting]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[drake]] : injectionPoints ) { try { Errors [[masri]] = [[drake]] . isOptional ( ) ? new Errors ( [[drake]] ) : errors . withSource ( [[drake]] ) ; SingleMemberInjector [[nipple]] = [[drake]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[propellant]] , [[drake]] , [[masri]] ) : new SingleMethodInjector ( this . [[propellant]] , [[drake]] , [[masri]] ) ; [[injecting]] . add ( [[nipple]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 374 ---------------------------------------------
Create a injector for the given type . --> throws an exception if there is no more than one member --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > [[type]] , Errors errors ) throws ErrorsException { int [[numErrorsBefore]] = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[type]] ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( [[numErrorsBefore]] ) ; EncounterImpl < T > [[encounter]] = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding [[binding]] : typeListenerBindings ) { TypeListener typeListener = [[binding]] . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && [[binding]] . getTypeMatcher ( ) . matches ( [[type]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[type]] , [[encounter]] ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( [[binding]] , [[type]] , e ) ; } } } [[encounter]] . invalidate ( ) ; errors . throwIfNewErrors ( [[numErrorsBefore]] ) ; return new MembersInjectorImpl < T > ( injector , [[type]] , [[encounter]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[morlocks]] ( TypeLiteral < T > [[boyfriend]] , Errors errors ) throws ErrorsException { int [[championed]] = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[boyfriend]] ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( [[championed]] ) ; EncounterImpl < T > [[interviews]] = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding [[oblige]] : typeListenerBindings ) { TypeListener typeListener = [[oblige]] . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && [[oblige]] . getTypeMatcher ( ) . matches ( [[boyfriend]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[boyfriend]] , [[interviews]] ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( [[oblige]] , [[boyfriend]] , e ) ; } } } [[interviews]] . invalidate ( ) ; errors . throwIfNewErrors ( [[championed]] ) ; return new MembersInjectorImpl < T > ( injector , [[boyfriend]] , [[interviews]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 375 ---------------------------------------------
Returns a strategy for the given annotation . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[conceived]] ( Annotation [[général]] ) { checkNotNull ( [[général]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[général]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[général]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[général]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 376 ---------------------------------------------
Returns a strategy for the given annotation type . --> Returns a new AnnotationStrategy --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[moldavia]] ( Class < ? extends Annotation > [[waterloo]] ) { [[waterloo]] = Annotations . canonicalizeIfNamed ( [[waterloo]] ) ; if ( isAllDefaultMethods ( [[waterloo]] ) ) { return [[moldavia]] ( generateAnnotation ( [[waterloo]] ) ) ; } checkNotNull ( [[waterloo]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[waterloo]] ) ; ensureIsBindingAnnotation ( [[waterloo]] ) ; return new AnnotationTypeStrategy ( [[waterloo]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 377 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 367 / 8 / 2 / 377:  38%|███▊      | 377/1000 [2:56:42<4:52:00, 28.12s/it][Succeeded / Failed / Skipped / Total] 367 / 8 / 2 / 377:  38%|███▊      | 378/1000 [2:56:47<4:50:54, 28.06s/it][Succeeded / Failed / Skipped / Total] 368 / 8 / 2 / 378:  38%|███▊      | 378/1000 [2:56:47<4:50:54, 28.06s/it][Succeeded / Failed / Skipped / Total] 368 / 8 / 2 / 378:  38%|███▊      | 379/1000 [2:59:11<4:53:35, 28.37s/it][Succeeded / Failed / Skipped / Total] 369 / 8 / 2 / 379:  38%|███▊      | 379/1000 [2:59:11<4:53:35, 28.37s/it][Succeeded / Failed / Skipped / Total] 369 / 8 / 2 / 379:  38%|███▊      | 380/1000 [3:00:44<4:54:54, 28.54s/it][Succeeded / Failed / Skipped / Total] 370 / 8 / 2 / 380:  38%|███▊      | 380/1000 [3:00:44<4:54:54, 28.54s/it][Succeeded / Failed / Skipped / Total] 370 / 8 / 2 / 380:  38%|███▊      | 381/1000 [3:03:32<4:58:12, 28.91s/it][Succeeded / Failed / Skipped / Total] 371 / 8 / 2 / 381:  38%|███▊      | 381/1000 [3:03:32<4:58:12, 28.91s/it][Succeeded / Failed / Skipped / Total] 371 / 8 / 2 / 381:  38%|███▊      | 382/1000 [3:03:51<4:57:27, 28.88s/it][Succeeded / Failed / Skipped / Total] 372 / 8 / 2 / 382:  38%|███▊      | 382/1000 [3:03:51<4:57:27, 28.88s/it][Succeeded / Failed / Skipped / Total] 372 / 8 / 2 / 382:  38%|███▊      | 383/1000 [3:04:05<4:56:34, 28.84s/it][Succeeded / Failed / Skipped / Total] 373 / 8 / 2 / 383:  38%|███▊      | 383/1000 [3:04:05<4:56:34, 28.84s/it][Succeeded / Failed / Skipped / Total] 373 / 8 / 2 / 383:  38%|███▊      | 384/1000 [3:11:05<5:06:32, 29.86s/it][Succeeded / Failed / Skipped / Total] 373 / 9 / 2 / 384:  38%|███▊      | 384/1000 [3:11:05<5:06:32, 29.86s/it][Succeeded / Failed / Skipped / Total] 373 / 9 / 2 / 384:  38%|███▊      | 385/1000 [3:11:13<5:05:27, 29.80s/it]Creates a new instance with an annotation strategy . --> best effort --> Socre: 1.0

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy annotationStrategy ) { return new Key < T > ( [[type]] , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[achieved]] ( Class < T > [[guys]] , AnnotationStrategy annotationStrategy ) { return new Key < T > ( [[guys]] , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 378 ---------------------------------------------
Gets the binding source . --> Get stack trace --> Socre: 1.0

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[wesa]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 379 ---------------------------------------------
Removes the stack trace from the given throwable . --> package private for testing --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable [[t]] = throwable ; [[t]] != null ; [[t]] = [[t]] . getCause ( ) ) { StackTraceElement [ ] stackTrace = [[t]] . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } [[t]] . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[porpoise]] ( Throwable throwable ) { for ( Throwable [[zillion]] = throwable ; [[zillion]] != null ; [[zillion]] = [[zillion]] . getCause ( ) ) { StackTraceElement [ ] stackTrace = [[zillion]] . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } [[zillion]] . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 380 ---------------------------------------------
Creates a message with the given format and arguments . --> Used by tests --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... arguments ) { return [[create]] ( null , [[messageFormat]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[building]] ( String [[sniper]] , Object ... arguments ) { return [[building]] ( null , [[sniper]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 381 ---------------------------------------------
Creates a formatted message with the given message and arguments . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String [[messageFormat]] , Object ... arguments ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , [[messageFormat]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[develops]] ( Throwable [[resulting]] , String [[privilege]] , Object ... arguments ) { return [[develops]] ( [[resulting]] , ImmutableList . of ( ) , [[privilege]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 382 ---------------------------------------------
Creates a formatted message with the specified message and arguments . --> Formatter for formatting --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable cause , List < Object > [[sources]] , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( [[sources]] , message , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[formation]] ( Throwable cause , List < Object > [[origin]] , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( [[origin]] , message , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 383 ---------------------------------------------
Convert an Object to a ObjectSource . --> Returns the translation for the given element --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object [[o]] ) { ElementSource [[source]] = null ; if ( [[o]] instanceof ElementSource ) { [[source]] = ( ElementSource ) [[o]] ; [[o]] = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( [[o]] , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[translation]] ( Object [[nope]] ) { ElementSource [[ancestry]] = null ; if ( [[nope]] instanceof ElementSource ) { [[ancestry]] = ( ElementSource ) [[nope]] ; [[nope]] = [[ancestry]] . getDeclaringSource ( ) ; } return [[translation]] ( [[nope]] , [[ancestry]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 384 ---------------------------------------------
Returns a new key for a new key . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
[Succeeded / Failed / Skipped / Total] 374 / 9 / 2 / 385:  38%|███▊      | 385/1000 [3:11:13<5:05:27, 29.80s/it][Succeeded / Failed / Skipped / Total] 374 / 9 / 2 / 385:  39%|███▊      | 386/1000 [3:12:18<5:05:53, 29.89s/it][Succeeded / Failed / Skipped / Total] 375 / 9 / 2 / 386:  39%|███▊      | 386/1000 [3:12:18<5:05:53, 29.89s/it][Succeeded / Failed / Skipped / Total] 375 / 9 / 2 / 386:  39%|███▊      | 387/1000 [3:13:27<5:06:26, 29.99s/it][Succeeded / Failed / Skipped / Total] 375 / 10 / 2 / 387:  39%|███▊      | 387/1000 [3:13:27<5:06:26, 29.99s/it][Succeeded / Failed / Skipped / Total] 375 / 10 / 2 / 387:  39%|███▉      | 388/1000 [3:13:40<5:05:29, 29.95s/it][Succeeded / Failed / Skipped / Total] 376 / 10 / 2 / 388:  39%|███▉      | 388/1000 [3:13:40<5:05:29, 29.95s/it][Succeeded / Failed / Skipped / Total] 376 / 10 / 2 / 388:  39%|███▉      | 389/1000 [3:13:52<5:04:31, 29.90s/it][Succeeded / Failed / Skipped / Total] 377 / 10 / 2 / 389:  39%|███▉      | 389/1000 [3:13:52<5:04:31, 29.90s/it][Succeeded / Failed / Skipped / Total] 377 / 10 / 2 / 389:  39%|███▉      | 390/1000 [3:14:10<5:03:43, 29.87s/it][Succeeded / Failed / Skipped / Total] 378 / 10 / 2 / 390:  39%|███▉      | 390/1000 [3:14:10<5:03:43, 29.87s/it][Succeeded / Failed / Skipped / Total] 378 / 10 / 2 / 390:  39%|███▉      | 391/1000 [3:14:14<5:02:32, 29.81s/it][Succeeded / Failed / Skipped / Total] 379 / 10 / 2 / 391:  39%|███▉      | 391/1000 [3:14:14<5:02:32, 29.81s/it][Succeeded / Failed / Skipped / Total] 379 / 10 / 2 / 391:  39%|███▉      | 392/1000 [3:14:29<5:01:39, 29.77s/it][Succeeded / Failed / Skipped / Total] 380 / 10 / 2 / 392:  39%|███▉      | 392/1000 [3:14:29<5:01:39, 29.77s/it][Succeeded / Failed / Skipped / Total] 380 / 10 / 2 / 392:  39%|███▉      | 393/1000 [3:15:01<5:01:13, 29.78s/it]--------------------------------------------- Result 385 ---------------------------------------------
Get the configuration object for the module classes . --> Configure graydon configuration --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[graydon]] ( List < String > [[camila]] ) { Preconditions . checkNotNull ( [[camila]] , "The list of module class names cannot be null." ) ; for ( final String [[pippa]] : [[camila]] ) { if ( ! shouldBeSkipped ( [[pippa]] ) ) { return new StackTraceElement ( [[pippa]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 386 ---------------------------------------------
Manage jmx module . --> tries to connect to a module --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] [[args]] ) throws Exception { if ( [[args]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( [[args]] [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( [[args]] [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[nucleus]] ( String [ ] [[excellently]] ) throws Exception { if ( [[excellently]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( [[excellently]] [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( [[excellently]] [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 387 ---------------------------------------------
Creates an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 388 ---------------------------------------------
Method pushState . --> Internal pushState method --> Socre: 1.0

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[key]] , Object [[source]] ) { doPushState ( [[key]] , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[necessary]] , Object [[thaw]] ) { doPushState ( [[necessary]] , [[thaw]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 389 ---------------------------------------------
Creates an initializable instance --> Echo toString --> Socre: 1.0

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[chez]] ( final T [[proceed]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[proceed]] ; } @ Override public String toString ( ) { return String . valueOf ( [[proceed]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 390 ---------------------------------------------
Pushes a dependency onto the dependency stack . --> This method is called from SAML --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object source ) { Dependency < ? > [[previous]] = this . [[dependency]] ; this . [[dependency]] = [[dependency]] ; doPushState ( [[dependency]] , source ) ; return [[previous]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[sams]] ( Dependency < ? > [[reliance]] , Object source ) { Dependency < ? > [[vieux]] = this . [[addiction]] ; this . [[addiction]] = [[reliance]] ; doPushState ( [[reliance]] , source ) ; return [[vieux]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 391 ---------------------------------------------
Process connection event . --> Do a connection event processor --> Socre: 1.0

[[[[Adv]]]]: public void [[onEvent]] ( ConnectionEventType type , String [[remoteAddr]] , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( [[remoteAddr]] , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void [[dopler]] ( ConnectionEventType type , String [[canarsie]] , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( [[canarsie]] , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 392 ---------------------------------------------
Adds a connection event processor . --> Starts an arjaner --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType type , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > [[processorList]] = this . [[processors]] . get ( type ) ; if ( [[processorList]] == null ) { this . [[processors]] . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[processorList]] = this . [[processors]] . get ( type ) ; } [[processorList]] . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[arjan]] ( ConnectionEventType type , ConnectionEventProcessor [[workstation]] ) { List < ConnectionEventProcessor > [[crazier]] = this . [[assembler]] . get ( type ) ; if ( [[crazier]] == null ) { this . [[assembler]] . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[crazier]] = this . [[assembler]] . get ( type ) ; } [[crazier]] . add ( [[workstation]] ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 393 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 381 / 10 / 2 / 393:  39%|███▉      | 393/1000 [3:15:01<5:01:13, 29.78s/it][Succeeded / Failed / Skipped / Total] 381 / 10 / 2 / 393:  39%|███▉      | 394/1000 [3:15:05<5:00:03, 29.71s/it][Succeeded / Failed / Skipped / Total] 382 / 10 / 2 / 394:  39%|███▉      | 394/1000 [3:15:05<5:00:03, 29.71s/it][Succeeded / Failed / Skipped / Total] 382 / 10 / 2 / 394:  40%|███▉      | 395/1000 [3:15:12<4:58:59, 29.65s/it][Succeeded / Failed / Skipped / Total] 383 / 10 / 2 / 395:  40%|███▉      | 395/1000 [3:15:12<4:58:59, 29.65s/it][Succeeded / Failed / Skipped / Total] 383 / 10 / 2 / 395:  40%|███▉      | 396/1000 [3:15:40<4:58:26, 29.65s/it][Succeeded / Failed / Skipped / Total] 384 / 10 / 2 / 396:  40%|███▉      | 396/1000 [3:15:40<4:58:26, 29.65s/it][Succeeded / Failed / Skipped / Total] 384 / 10 / 2 / 396:  40%|███▉      | 397/1000 [3:16:08<4:57:54, 29.64s/it][Succeeded / Failed / Skipped / Total] 385 / 10 / 2 / 397:  40%|███▉      | 397/1000 [3:16:08<4:57:54, 29.64s/it][Succeeded / Failed / Skipped / Total] 385 / 10 / 2 / 397:  40%|███▉      | 398/1000 [3:16:10<4:56:44, 29.58s/it]Creates a new instance . --> private helper method --> Socre: 1.0

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > [[provider]] , Dependency < ? > dependency , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { T t = [[provider]] . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[constructionContext]] . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > [[buyer]] , Dependency < ? > dependency , ConstructionContext < T > [[cortlandt]] ) throws InternalProvisionException { T t = [[buyer]] . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[cortlandt]] . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 394 ---------------------------------------------
Liefert die Throwable . --> Checks cross -hairs . --> Socre: 1.0

[[[[Adv]]]]: public static void [[launderThrowable]] ( Throwable [[t]] ) { if ( [[t]] instanceof RuntimeException ) { throw ( RuntimeException ) [[t]] ; } else if ( [[t]] instanceof Error ) { throw ( Error ) [[t]] ; } else { throw new IllegalStateException ( "Not unchecked!" , [[t]] ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void [[crosshairs]] ( Throwable [[tones]] ) { if ( [[tones]] instanceof RuntimeException ) { throw ( RuntimeException ) [[tones]] ; } else if ( [[tones]] instanceof Error ) { throw ( Error ) [[tones]] ; } else { throw new IllegalStateException ( "Not unchecked!" , [[tones]] ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 395 ---------------------------------------------
Register a new processor --> Wrap a worker --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode [[cmdCode]] , RemotingProcessor < ? > processor ) { if ( this . [[cmd2processors]] . containsKey ( [[cmdCode]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[cmdCode]] , cmd2processors . get ( [[cmdCode]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( [[cmdCode]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[wakey]] ( CommandCode [[cooler]] , RemotingProcessor < ? > processor ) { if ( this . [[entrusted]] . containsKey ( [[cooler]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[cooler]] , cmd2processors . get ( [[cooler]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[entrusted]] . put ( [[cooler]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 396 ---------------------------------------------
Formats a collection of error messages . --> Formats a messour into a string --> Socre: 1.0

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > [[errorMessages]] ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int [[index]] = 1 ; boolean [[displayCauses]] = getOnlyCause ( [[errorMessages]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[errorMessages]] ) { int [[thisIdx]] = [[index]] ++ ; fmt . format ( "%s) %s%n" , [[thisIdx]] , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[i]] = dependencies . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { Object source = dependencies . get ( [[i]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( [[displayCauses]] && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , [[thisIdx]] ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[errorMessages]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[errorMessages]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > [[glamour]] ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int [[forefinger]] = 1 ; boolean [[skewered]] = getOnlyCause ( [[glamour]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[glamour]] ) { int [[martinique]] = [[forefinger]] ++ ; fmt . format ( "%s) %s%n" , [[martinique]] , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[du]] = dependencies . size ( ) - 1 ; [[du]] >= 0 ; [[du]] -- ) { Object source = dependencies . get ( [[du]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( [[skewered]] && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , [[martinique]] ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[glamour]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[glamour]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 397 ---------------------------------------------
Returns a processor for the given command code . --> handles remoting --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode [[cmdCode]] ) { RemotingProcessor < ? > [[processor]] = this . [[cmd2processors]] . get ( [[cmdCode]] ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . [[defaultProcessor]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[hostile]] ( CommandCode [[healin]] ) { RemotingProcessor < ? > [[boxed]] = this . [[togather]] . get ( [[healin]] ) ; if ( [[boxed]] != null ) { return [[boxed]] ; } return this . [[adderall]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 398 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 386 / 10 / 2 / 398:  40%|███▉      | 398/1000 [3:16:10<4:56:44, 29.58s/it][Succeeded / Failed / Skipped / Total] 386 / 10 / 2 / 398:  40%|███▉      | 399/1000 [3:16:56<4:56:38, 29.61s/it][Succeeded / Failed / Skipped / Total] 387 / 10 / 2 / 399:  40%|███▉      | 399/1000 [3:16:56<4:56:38, 29.61s/it][Succeeded / Failed / Skipped / Total] 387 / 10 / 2 / 399:  40%|████      | 400/1000 [3:17:00<4:55:30, 29.55s/it][Succeeded / Failed / Skipped / Total] 388 / 10 / 2 / 400:  40%|████      | 400/1000 [3:17:00<4:55:30, 29.55s/it][Succeeded / Failed / Skipped / Total] 388 / 10 / 2 / 400:  40%|████      | 401/1000 [3:17:03<4:54:21, 29.48s/it][Succeeded / Failed / Skipped / Total] 389 / 10 / 2 / 401:  40%|████      | 401/1000 [3:17:03<4:54:21, 29.48s/it][Succeeded / Failed / Skipped / Total] 389 / 10 / 2 / 401:  40%|████      | 402/1000 [3:17:07<4:53:13, 29.42s/it][Succeeded / Failed / Skipped / Total] 390 / 10 / 2 / 402:  40%|████      | 402/1000 [3:17:07<4:53:13, 29.42s/it][Succeeded / Failed / Skipped / Total] 390 / 10 / 2 / 402:  40%|████      | 403/1000 [3:17:09<4:52:03, 29.35s/it][Succeeded / Failed / Skipped / Total] 391 / 10 / 2 / 403:  40%|████      | 403/1000 [3:17:09<4:52:03, 29.35s/it][Succeeded / Failed / Skipped / Total] 391 / 10 / 2 / 403:  40%|████      | 404/1000 [3:17:13<4:50:57, 29.29s/it][Succeeded / Failed / Skipped / Total] 392 / 10 / 2 / 404:  40%|████      | 404/1000 [3:17:13<4:50:57, 29.29s/it][Succeeded / Failed / Skipped / Total] 392 / 10 / 2 / 404:  40%|████      | 405/1000 [3:17:16<4:49:49, 29.23s/it][Succeeded / Failed / Skipped / Total] 393 / 10 / 2 / 405:  40%|████      | 405/1000 [3:17:16<4:49:49, 29.23s/it][Succeeded / Failed / Skipped / Total] 393 / 10 / 2 / 405:  41%|████      | 406/1000 [3:17:34<4:49:03, 29.20s/it]Tries to get a cached URL . --> Gets the linked url . --> Socre: 1.0

[[[[Adv]]]]: private Url [[tryGet]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url [[comitted]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 399 ---------------------------------------------
Registers the default processor . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > processor ) { if ( this . [[defaultProcessor]] == null ) { this . [[defaultProcessor]] = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[defaultProcessor]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[detailed]] ( RemotingProcessor < ? > processor ) { if ( this . [[hé]] == null ) { this . [[hé]] = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[hé]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 400 ---------------------------------------------
Returns a map of all connections in this pool . -->  married between connection pools --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[getAll]] ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[entry]] = iterator . next ( ) ; ConnectionPool [[pool]] = FutureTaskUtil . getFutureTaskResult ( [[entry]] . getValue ( ) , logger ) ; if ( null != [[pool]] ) { [[allConnections]] . put ( [[entry]] . getKey ( ) , [[pool]] . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[conjoined]] ( ) { Map < String , List < Connection > > [[married]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[registrations]] = iterator . next ( ) ; ConnectionPool [[tank]] = FutureTaskUtil . getFutureTaskResult ( [[registrations]] . getValue ( ) , logger ) ; if ( null != [[tank]] ) { [[married]] . put ( [[registrations]] . getKey ( ) , [[tank]] . getAll ( ) ) ; } } return [[married]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 401 ---------------------------------------------
Scan all pools . --> Analyzes the data structures that have expired . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[scan]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void [[analysing]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 402 ---------------------------------------------
Gets the connection and creates a connection . --> Converts a remote URL to a connection --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[convalescent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 403 ---------------------------------------------
Create a connection to a remote server . --> region polling --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[pitying]] ( Url [[archived]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 404 ---------------------------------------------
Remove a task from the pool . --> Removes a connection pool from memscib . --> Socre: 1.0

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . [[connTasks]] . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . [[memsahib]] . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 405 ---------------------------------------------
Check if a url needs to be a unique key . --> Handles chameons . --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[chameleons]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 406 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 394 / 10 / 2 / 406:  41%|████      | 406/1000 [3:17:34<4:49:03, 29.20s/it][Succeeded / Failed / Skipped / Total] 394 / 10 / 2 / 406:  41%|████      | 407/1000 [3:17:37<4:47:57, 29.13s/it][Succeeded / Failed / Skipped / Total] 395 / 10 / 2 / 407:  41%|████      | 407/1000 [3:17:37<4:47:57, 29.13s/it][Succeeded / Failed / Skipped / Total] 395 / 10 / 2 / 407:  41%|████      | 408/1000 [3:17:42<4:46:52, 29.07s/it][Succeeded / Failed / Skipped / Total] 396 / 10 / 2 / 408:  41%|████      | 408/1000 [3:17:42<4:46:52, 29.07s/it][Succeeded / Failed / Skipped / Total] 396 / 10 / 2 / 408:  41%|████      | 409/1000 [3:17:49<4:45:51, 29.02s/it][Succeeded / Failed / Skipped / Total] 397 / 10 / 2 / 409:  41%|████      | 409/1000 [3:17:49<4:45:51, 29.02s/it][Succeeded / Failed / Skipped / Total] 397 / 10 / 2 / 409:  41%|████      | 410/1000 [3:17:57<4:44:52, 28.97s/it][Succeeded / Failed / Skipped / Total] 398 / 10 / 2 / 410:  41%|████      | 410/1000 [3:17:57<4:44:52, 28.97s/it][Succeeded / Failed / Skipped / Total] 398 / 10 / 2 / 410:  41%|████      | 411/1000 [3:18:06<4:43:54, 28.92s/it][Succeeded / Failed / Skipped / Total] 399 / 10 / 2 / 411:  41%|████      | 411/1000 [3:18:06<4:43:54, 28.92s/it][Succeeded / Failed / Skipped / Total] 399 / 10 / 2 / 411:  41%|████      | 412/1000 [3:18:14<4:42:56, 28.87s/it]Do create . --> creates mois --> Socre: 1.0

[[[[Adv]]]]: private void [[doCreate]] ( final Url [[url]] , final ConnectionPool pool , final String [[taskName]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int [[expectNum]] = [[url]] . getConnNum ( ) ; if ( actualNum < [[expectNum]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , [[expectNum]] , [[taskName]] ) ; } if ( [[url]] . isConnWarmup ( ) ) { for ( int i = actualNum ; i < [[expectNum]] ; ++ i ) { Connection connection = create ( [[url]] ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > [[url]] . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + [[url]] . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void [[mois]] ( final Url [[footnote]] , final ConnectionPool pool , final String [[replacing]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int [[productive]] = [[footnote]] . getConnNum ( ) ; if ( actualNum < [[productive]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , [[productive]] , [[replacing]] ) ; } if ( [[footnote]] . isConnWarmup ( ) ) { for ( int i = actualNum ; i < [[productive]] ; ++ i ) { Connection connection = create ( [[footnote]] ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > [[footnote]] . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + [[footnote]] . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 407 ---------------------------------------------
Close a connection --> Closes the connection --> Socre: 1.0

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . [[addressParser]] . parse ( addr ) ; this . [[connectionManager]] . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . [[rojas]] . parse ( addr ) ; this . [[scrubbed]] . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 408 ---------------------------------------------
Decode protocol code . --> Check decked decked from buffer --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[protocolCodeBytes]] = new byte [ protocolCodeLength ] ; in . readBytes ( [[protocolCodeBytes]] ) ; return ProtocolCode . fromBytes ( [[protocolCodeBytes]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[decked]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[sonal]] = new byte [ protocolCodeLength ] ; in . readBytes ( [[sonal]] ) ; return ProtocolCode . fromBytes ( [[sonal]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 409 ---------------------------------------------
On close . --> Cancel all requests --> Socre: 1.0

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > [[entry]] = iter . next ( ) ; iter . remove ( ) ; InvokeFuture [[future]] = [[entry]] . getValue ( ) ; if ( [[future]] != null ) { [[future]] . putResponse ( [[future]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[future]] . cancelTimeout ( ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[cask]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > [[accesses]] = iter . next ( ) ; iter . remove ( ) ; InvokeFuture [[afterwards]] = [[accesses]] . getValue ( ) ; if ( [[afterwards]] != null ) { [[afterwards]] . putResponse ( [[afterwards]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[afterwards]] . cancelTimeout ( ) ; [[afterwards]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 410 ---------------------------------------------
Sets the given value for the given key . --> This method is intended to be called from the derived classes --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String [[key]] , Object [[value]] ) { return attributes . putIfAbsent ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[portents]] ( String [[necessities]] , Object [[deserved]] ) { return attributes . putIfAbsent ( [[necessities]] , [[deserved]] ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 411 ---------------------------------------------
Registers a user processor . --> Store a producer in the rpc server --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[processor]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[processor]] instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) [[processor]] , userProcessors ) ; } else { if ( StringUtils . isBlank ( [[processor]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( [[processor]] . interest ( ) , [[processor]] ) ; if ( preProcessor != null ) { String [[errMsg]] = "Processor with interest key [" + [[processor]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[errMsg]] ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[forego]] ( UserProcessor < ? > [[producer]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[producer]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[producer]] instanceof MultiInterestUserProcessor ) { [[forego]] ( ( MultiInterestUserProcessor ) [[producer]] , userProcessors ) ; } else { if ( StringUtils . isBlank ( [[producer]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( [[producer]] . interest ( ) , [[producer]] ) ; if ( preProcessor != null ) { String [[suck]] = "Processor with interest key [" + [[producer]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[suck]] ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 412 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 400 / 10 / 2 / 412:  41%|████      | 412/1000 [3:18:14<4:42:56, 28.87s/it][Succeeded / Failed / Skipped / Total] 400 / 10 / 2 / 412:  41%|████▏     | 413/1000 [3:18:17<4:41:50, 28.81s/it][Succeeded / Failed / Skipped / Total] 401 / 10 / 2 / 413:  41%|████▏     | 413/1000 [3:18:17<4:41:50, 28.81s/it][Succeeded / Failed / Skipped / Total] 401 / 10 / 2 / 413:  41%|████▏     | 414/1000 [3:18:22<4:40:48, 28.75s/it][Succeeded / Failed / Skipped / Total] 402 / 10 / 2 / 414:  41%|████▏     | 414/1000 [3:18:22<4:40:48, 28.75s/it][Succeeded / Failed / Skipped / Total] 402 / 10 / 2 / 414:  42%|████▏     | 415/1000 [3:19:27<4:41:09, 28.84s/it][Succeeded / Failed / Skipped / Total] 403 / 10 / 2 / 415:  42%|████▏     | 415/1000 [3:19:27<4:41:09, 28.84s/it][Succeeded / Failed / Skipped / Total] 403 / 10 / 2 / 415:  42%|████▏     | 416/1000 [3:19:38<4:40:16, 28.79s/it][Succeeded / Failed / Skipped / Total] 404 / 10 / 2 / 416:  42%|████▏     | 416/1000 [3:19:38<4:40:16, 28.79s/it][Succeeded / Failed / Skipped / Total] 404 / 10 / 2 / 416:  42%|████▏     | 417/1000 [3:19:41<4:39:11, 28.73s/it]Registers the given processor to the rpc server . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > [[preProcessor]] = [[userProcessors]] . putIfAbsent ( interest , processor ) ; if ( [[preProcessor]] != null ) { String [[errMsg]] = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[errMsg]] ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[chairmen]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[caesarian]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > [[scorch]] = [[caesarian]] . putIfAbsent ( interest , processor ) ; if ( [[scorch]] != null ) { String [[stu]] = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[stu]] ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 413 ---------------------------------------------
Dispatches request to user process . --> Handle hayao --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[hayao]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 414 ---------------------------------------------
Deserialize request command . --> Borrowoneon on the remote peer --> Socre: 1.0

[[[[Adv]]]]: private boolean [[deserializeRequestCommand]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "[[True]]" == "[[True]]" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean [[bandoneon]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "[[Appropriate]]" == "[[Appropriate]]" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 415 ---------------------------------------------
Pre - process the remoting context . --> Sets the request command . --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext ctx , RpcRequestCommand cmd , long [[currentTimestamp]] ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[currentTimestamp]] - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[mein]] ( RemotingContext ctx , RpcRequestCommand cmd , long [[pachinko]] ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[pachinko]] - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 416 ---------------------------------------------
Log timeout log . --> should be called --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand [[cmd]] , long [[currentTimestamp]] , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[cmd]] . getId ( ) , [[currentTimestamp]] , [[cmd]] . getArriveTime ( ) , ( [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } String [[remoteAddr]] = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel [[channel]] = channelCtx . channel ( ) ; if ( null != [[channel]] ) { [[remoteAddr]] = RemotingUtil . parseRemoteAddress ( [[channel]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[cmd]] . getId ( ) , [[remoteAddr]] , ( [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[moya]] ( final RpcRequestCommand [[hyp]] , long [[pharmacy]] , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[hyp]] . getId ( ) , [[pharmacy]] , [[hyp]] . getArriveTime ( ) , ( [[pharmacy]] - [[hyp]] . getArriveTime ( ) ) , [[hyp]] . getTimeout ( ) ) ; } String [[unfounded]] = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel [[circuitry]] = channelCtx . channel ( ) ; if ( null != [[circuitry]] ) { [[unfounded]] = RemotingUtil . parseRemoteAddress ( [[circuitry]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[hyp]] . getId ( ) , [[unfounded]] , ( [[pharmacy]] - [[hyp]] . getArriveTime ( ) ) , [[hyp]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 417 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 405 / 10 / 2 / 417:  42%|████▏     | 417/1000 [3:19:41<4:39:11, 28.73s/it][Succeeded / Failed / Skipped / Total] 405 / 10 / 2 / 417:  42%|████▏     | 418/1000 [3:19:45<4:38:07, 28.67s/it][Succeeded / Failed / Skipped / Total] 406 / 10 / 2 / 418:  42%|████▏     | 418/1000 [3:19:45<4:38:07, 28.67s/it][Succeeded / Failed / Skipped / Total] 406 / 10 / 2 / 418:  42%|████▏     | 419/1000 [3:19:50<4:37:06, 28.62s/it][Succeeded / Failed / Skipped / Total] 407 / 10 / 2 / 419:  42%|████▏     | 419/1000 [3:19:50<4:37:06, 28.62s/it][Succeeded / Failed / Skipped / Total] 407 / 10 / 2 / 419:  42%|████▏     | 420/1000 [3:19:56<4:36:06, 28.56s/it]Log debug log . --> Handles exceptions . --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext ctx , RpcRequestCommand cmd , long [[currentTimestamp]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , [[currentTimestamp]] , cmd . getArriveTime ( ) , ( [[currentTimestamp]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[preconceptions]] ( RemotingContext ctx , RpcRequestCommand cmd , long [[bhushan]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , [[bhushan]] , cmd . getArriveTime ( ) , ( [[bhushan]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 418 ---------------------------------------------
Processes a message . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[process]] ( RemotingContext ctx , T [[msg]] , ExecutorService [[defaultExecutor]] ) throws Exception { ProcessTask [[task]] = new ProcessTask ( ctx , [[msg]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[task]] ) ; } else { [[defaultExecutor]] . execute ( [[task]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void [[formalities]] ( RemotingContext ctx , T [[messages]] , ExecutorService [[toast]] ) throws Exception { ProcessTask [[responsibility]] = new ProcessTask ( ctx , [[messages]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[responsibility]] ) ; } else { [[toast]] . execute ( [[responsibility]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 419 ---------------------------------------------
Execute the invoke call with a callback . --> Invoke the remoting command --> Socre: 1.0

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection [[conn]] , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( [[conn]] , request , request . getInvokeContext ( ) , invokeCallback ) ; [[conn]] . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = [[conn]] . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( [[conn]] . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; [[conn]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = [[conn]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[conn]] . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = [[conn]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[conn]] . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection [[elephant]] , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( [[elephant]] , request , request . getInvokeContext ( ) , invokeCallback ) ; [[elephant]] . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = [[elephant]] . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( [[elephant]] . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; [[elephant]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = [[elephant]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[elephant]] . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[elephant]] . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = [[elephant]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[elephant]] . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[elephant]] . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 420 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 408 / 10 / 2 / 420:  42%|████▏     | 420/1000 [3:19:56<4:36:06, 28.56s/it][Succeeded / Failed / Skipped / Total] 408 / 10 / 2 / 420:  42%|████▏     | 421/1000 [3:20:35<4:35:52, 28.59s/it][Succeeded / Failed / Skipped / Total] 409 / 10 / 2 / 421:  42%|████▏     | 421/1000 [3:20:35<4:35:52, 28.59s/it][Succeeded / Failed / Skipped / Total] 409 / 10 / 2 / 421:  42%|████▏     | 422/1000 [3:20:37<4:34:47, 28.53s/it][Succeeded / Failed / Skipped / Total] 410 / 10 / 2 / 422:  42%|████▏     | 422/1000 [3:20:37<4:34:47, 28.53s/it][Succeeded / Failed / Skipped / Total] 410 / 10 / 2 / 422:  42%|████▏     | 423/1000 [3:20:41<4:33:45, 28.47s/it][Succeeded / Failed / Skipped / Total] 411 / 10 / 2 / 423:  42%|████▏     | 423/1000 [3:20:41<4:33:45, 28.47s/it][Succeeded / Failed / Skipped / Total] 411 / 10 / 2 / 423:  42%|████▏     | 424/1000 [3:20:44<4:32:42, 28.41s/it][Succeeded / Failed / Skipped / Total] 412 / 10 / 2 / 424:  42%|████▏     | 424/1000 [3:20:44<4:32:42, 28.41s/it][Succeeded / Failed / Skipped / Total] 412 / 10 / 2 / 424:  42%|████▎     | 425/1000 [3:20:58<4:31:53, 28.37s/it][Succeeded / Failed / Skipped / Total] 413 / 10 / 2 / 425:  42%|████▎     | 425/1000 [3:20:58<4:31:53, 28.37s/it][Succeeded / Failed / Skipped / Total] 413 / 10 / 2 / 425:  43%|████▎     | 426/1000 [3:21:04<4:30:55, 28.32s/it][Succeeded / Failed / Skipped / Total] 414 / 10 / 2 / 426:  43%|████▎     | 426/1000 [3:21:04<4:30:55, 28.32s/it][Succeeded / Failed / Skipped / Total] 414 / 10 / 2 / 426:  43%|████▎     | 427/1000 [3:21:08<4:29:54, 28.26s/it]This method is called when the invocation is sent . --> Send a request to the server --> Socre: 1.0

[[[[Adv]]]]: protected void [[oneway]] ( final Connection [[conn]] , final RemotingCommand request ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void [[roughing]] ( final Connection [[boston]] , final RemotingCommand request ) { try { [[boston]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[boston]] . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[boston]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[boston]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 421 ---------------------------------------------
Get the task result . --> package - private for testing --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[tonnes]] > [[tonnes]] getFutureTaskResult ( RunStateRecordedFutureTask < [[tonnes]] > task , Logger logger ) { [[tonnes]] [[zillion]] = null ; if ( null != task ) { try { [[zillion]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[zillion]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 422 ---------------------------------------------
Convert an integer value to a BitSet --> Converts an integer value into a BitSet --> Socre: 1.0

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 423 ---------------------------------------------
Adds a reconnect task . --> Attempt to connect to another URL --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url [[url]] ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = [[url]] ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[morey]] ( Url [[refer]] ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = [[refer]] ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 424 ---------------------------------------------
Stops the background thread --> Shuts down the connection . --> Socre: 1.0

[[[[Adv]]]]: public void [[stop]] ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread

[[[[Adv]]]]: public void [[shuts]] ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 425 ---------------------------------------------
To remoting command . --> so we don t need --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand [[command]] = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[intravenous]] ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand [[coronel]] = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 426 ---------------------------------------------
To byte . --> Generate kwun . --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[kwun]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 427 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 415 / 10 / 2 / 427:  43%|████▎     | 427/1000 [3:21:08<4:29:54, 28.26s/it][Succeeded / Failed / Skipped / Total] 415 / 10 / 2 / 427:  43%|████▎     | 428/1000 [3:21:11<4:28:53, 28.20s/it][Succeeded / Failed / Skipped / Total] 416 / 10 / 2 / 428:  43%|████▎     | 428/1000 [3:21:11<4:28:53, 28.20s/it][Succeeded / Failed / Skipped / Total] 416 / 10 / 2 / 428:  43%|████▎     | 429/1000 [3:21:13<4:27:49, 28.14s/it]This method is used to monitor all the active connections . --> Computes the active connection pools . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > [[connections]] = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( [[connections]] ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > [[contacted]] = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( [[contacted]] ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 428 ---------------------------------------------
Close new connection --> Checks to see if there is an oxygen or not . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection [[lastSelectConnect]] , List < Connection > [[serviceOffConnections]] ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[salons]] ( Connection [[donation]] , List < Connection > [[wooer]] ) throws InterruptedException { if ( null != [[donation]] ) { if ( [[donation]] . isInvokeFutureMapFinish ( ) ) { [[wooer]] . add ( [[donation]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[donation]] . isInvokeFutureMapFinish ( ) ) { [[wooer]] . add ( [[donation]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[donation]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 429 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 417 / 10 / 2 / 429:  43%|████▎     | 429/1000 [3:21:13<4:27:49, 28.14s/it][Succeeded / Failed / Skipped / Total] 417 / 10 / 2 / 429:  43%|████▎     | 430/1000 [3:21:16<4:26:49, 28.09s/it][Succeeded / Failed / Skipped / Total] 418 / 10 / 2 / 430:  43%|████▎     | 430/1000 [3:21:16<4:26:49, 28.09s/it][Succeeded / Failed / Skipped / Total] 418 / 10 / 2 / 430:  43%|████▎     | 431/1000 [3:22:08<4:26:51, 28.14s/it][Succeeded / Failed / Skipped / Total] 419 / 10 / 2 / 431:  43%|████▎     | 431/1000 [3:22:08<4:26:51, 28.14s/it][Succeeded / Failed / Skipped / Total] 419 / 10 / 2 / 431:  43%|████▎     | 432/1000 [3:22:17<4:25:59, 28.10s/it][Succeeded / Failed / Skipped / Total] 420 / 10 / 2 / 432:  43%|████▎     | 432/1000 [3:22:17<4:25:59, 28.10s/it][Succeeded / Failed / Skipped / Total] 420 / 10 / 2 / 432:  43%|████▎     | 433/1000 [3:22:21<4:24:58, 28.04s/it][Succeeded / Failed / Skipped / Total] 421 / 10 / 2 / 433:  43%|████▎     | 433/1000 [3:22:21<4:24:58, 28.04s/it][Succeeded / Failed / Skipped / Total] 421 / 10 / 2 / 433:  43%|████▎     | 434/1000 [3:22:21<4:23:54, 27.98s/it][Succeeded / Failed / Skipped / Total] 422 / 10 / 2 / 434:  43%|████▎     | 434/1000 [3:22:21<4:23:54, 27.98s/it][Succeeded / Failed / Skipped / Total] 422 / 10 / 2 / 434:  44%|████▎     | 435/1000 [3:22:21<4:22:50, 27.91s/it][Succeeded / Failed / Skipped / Total] 422 / 10 / 3 / 435:  44%|████▎     | 435/1000 [3:22:21<4:22:50, 27.91s/it][Succeeded / Failed / Skipped / Total] 422 / 10 / 3 / 435:  44%|████▎     | 436/1000 [3:22:24<4:21:50, 27.85s/it][Succeeded / Failed / Skipped / Total] 423 / 10 / 3 / 436:  44%|████▎     | 436/1000 [3:22:24<4:21:50, 27.85s/it][Succeeded / Failed / Skipped / Total] 423 / 10 / 3 / 436:  44%|████▎     | 437/1000 [3:22:24<4:20:46, 27.79s/it]Filter connections from a list of connections --> This method takes a list of connection states and returns a list of all the connection states --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > [[connections]] ) { List < Connection > [[serviceOnConnections]] = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[filteredConnections]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection [[connection]] : [[connections]] ) { String serviceStatus = ( String ) [[connection]] . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( [[connection]] . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( [[connection]] ) ) { serviceOffConnections . add ( [[connection]] ) ; } } else { [[serviceOnConnections]] . add ( [[connection]] ) ; } } [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_ON , [[serviceOnConnections]] ) ; [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return [[filteredConnections]] ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > [[nexus]] ) { List < Connection > [[kan]] = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[estimation]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection [[ties]] : [[nexus]] ) { String serviceStatus = ( String ) [[ties]] . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( [[ties]] . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( [[ties]] ) ) { serviceOffConnections . add ( [[ties]] ) ; } } else { [[kan]] . add ( [[ties]] ) ; } } [[estimation]] . put ( Configs . CONN_SERVICE_STATUS_ON , [[kan]] ) ; [[estimation]] . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return [[estimation]] ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 430 ---------------------------------------------
Log an info log . --> Display address . --> Socre: 1.0

[[[[Adv]]]]: private void [[infoLog]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void [[dengue]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 431 ---------------------------------------------
Gets a boolean property . --> Gets a boolean . --> Socre: 1.0

[[[[Adv]]]]: public static boolean getBool ( String key , String [[defaultValue]] ) { return Boolean . parseBoolean ( System . getProperty ( key , [[defaultValue]] ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property

[[[[Adv]]]]: public static boolean getBool ( String key , String [[slingshot]] ) { return Boolean . parseBoolean ( System . getProperty ( key , [[slingshot]] ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 432 ---------------------------------------------
Returns a user processor . --> Return a UserProcessor --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . userProcessors . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[corp]] ( String [[spank]] ) { return StringUtils . isBlank ( [[spank]] ) ? null : this . userProcessors . get ( [[spank]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 433 ---------------------------------------------
Is request timeout . --> Determines if received lines . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[lines]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 434 ---------------------------------------------
Returns a random connection . --> Returns a random resource . --> Socre: 1.0

[[[[Adv]]]]: private Connection randomGet ( List < Connection > [[conns]] ) { if ( null == [[conns]] || [[conns]] . isEmpty ( ) ) { return null ; } int size = [[conns]] . size ( ) ; int tries = 0 ; Connection [[result]] = null ; while ( ( [[result]] == null || ! [[result]] . isFine ( ) ) && tries ++ < MAX_TIMES ) { [[result]] = [[conns]] . get ( this . random . nextInt ( size ) ) ; } if ( [[result]] != null && ! [[result]] . isFine ( ) ) { [[result]] = null ; } return [[result]] ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection randomGet ( List < Connection > [[cromwell]] ) { if ( null == [[cromwell]] || [[cromwell]] . isEmpty ( ) ) { return null ; } int size = [[cromwell]] . size ( ) ; int tries = 0 ; Connection [[impacts]] = null ; while ( ( [[impacts]] == null || ! [[impacts]] . isFine ( ) ) && tries ++ < MAX_TIMES ) { [[impacts]] = [[cromwell]] . get ( this . random . nextInt ( size ) ) ; } if ( [[impacts]] != null && ! [[impacts]] . isFine ( ) ) { [[impacts]] = null ; } return [[impacts]] ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 435 ---------------------------------------------
Returns the value associated with the given key . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 436 ---------------------------------------------
Get a property --> Returns the modifier for the given locale . --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[prelim]] ( String [[vitale]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[vitale]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 424 / 10 / 3 / 437:  44%|████▎     | 437/1000 [3:22:24<4:20:46, 27.79s/it][Succeeded / Failed / Skipped / Total] 424 / 10 / 3 / 437:  44%|████▍     | 438/1000 [3:22:27<4:19:46, 27.73s/it][Succeeded / Failed / Skipped / Total] 425 / 10 / 3 / 438:  44%|████▍     | 438/1000 [3:22:27<4:19:46, 27.73s/it][Succeeded / Failed / Skipped / Total] 425 / 10 / 3 / 438:  44%|████▍     | 439/1000 [3:22:31<4:18:48, 27.68s/it][Succeeded / Failed / Skipped / Total] 426 / 10 / 3 / 439:  44%|████▍     | 439/1000 [3:22:31<4:18:48, 27.68s/it][Succeeded / Failed / Skipped / Total] 426 / 10 / 3 / 439:  44%|████▍     | 440/1000 [3:22:36<4:17:51, 27.63s/it][Succeeded / Failed / Skipped / Total] 427 / 10 / 3 / 440:  44%|████▍     | 440/1000 [3:22:36<4:17:51, 27.63s/it][Succeeded / Failed / Skipped / Total] 427 / 10 / 3 / 440:  44%|████▍     | 441/1000 [3:22:39<4:16:52, 27.57s/it][Succeeded / Failed / Skipped / Total] 428 / 10 / 3 / 441:  44%|████▍     | 441/1000 [3:22:39<4:16:52, 27.57s/it][Succeeded / Failed / Skipped / Total] 428 / 10 / 3 / 441:  44%|████▍     | 442/1000 [3:22:39<4:15:51, 27.51s/it][Succeeded / Failed / Skipped / Total] 429 / 10 / 3 / 442:  44%|████▍     | 442/1000 [3:22:39<4:15:51, 27.51s/it][Succeeded / Failed / Skipped / Total] 429 / 10 / 3 / 442:  44%|████▍     | 443/1000 [3:22:48<4:14:59, 27.47s/it]Attempt to resolve the response from a remote address . --> shrink a ResponseCommand --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String [[msg]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( [[msg]] ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( [[msg]] , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( [[msg]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[shrink]] ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String [[messenger]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( [[messenger]] ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( [[messenger]] , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( [[messenger]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 438 ---------------------------------------------
Converts a responseCommand to a throwable . --> Extracts an exception from the rpcResponseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) responseCommand ; [[resp]] . deserialize ( ) ; Object ex = [[resp]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[narmada]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[cre]] = ( RpcResponseCommand ) responseCommand ; [[cre]] . deserialize ( ) ; Object ex = [[cre]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 439 ---------------------------------------------
Print error message . --> Determine a living message . --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String [[clientErrMsg]] , ResponseCommand [[responseCommand]] ) { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) [[responseCommand]] ; if ( StringUtils . isNotBlank ( [[resp]] . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[clientErrMsg]] , [[resp]] . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[clientErrMsg]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[living]] ( String [[mila]] , ResponseCommand [[drapery]] ) { RpcResponseCommand [[overslept]] = ( RpcResponseCommand ) [[drapery]] ; if ( StringUtils . isNotBlank ( [[overslept]] . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[mila]] , [[overslept]] . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[mila]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 440 ---------------------------------------------
Convert a Throwable to RpcServerException . --> Creates a new RpcServerException --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException [[createServerException]] ( Throwable t , String errMsg ) { String [[formattedErrMsg]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( [[formattedErrMsg]] ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException [[signal]] ( Throwable t , String errMsg ) { String [[bartok]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( [[bartok]] ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 441 ---------------------------------------------
To response object . --> Deserialize a ResponseCommandCommand --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[response]] = ( RpcResponseCommand ) responseCommand ; [[response]] . deserialize ( ) ; return [[response]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[slr]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[answered]] = ( RpcResponseCommand ) responseCommand ; [[answered]] . deserialize ( ) ; return [[answered]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 442 ---------------------------------------------
Print connection trace log --> Called when an invocation id is received . --> Socre: 1.0

[[[[Adv]]]]: public static void [[printConnectionTraceLog]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void [[incorrigible]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 443 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 430 / 10 / 3 / 443:  44%|████▍     | 443/1000 [3:22:48<4:14:59, 27.47s/it][Succeeded / Failed / Skipped / Total] 430 / 10 / 3 / 443:  44%|████▍     | 444/1000 [3:23:07<4:14:21, 27.45s/it][Succeeded / Failed / Skipped / Total] 431 / 10 / 3 / 444:  44%|████▍     | 444/1000 [3:23:07<4:14:21, 27.45s/it][Succeeded / Failed / Skipped / Total] 431 / 10 / 3 / 444:  44%|████▍     | 445/1000 [3:23:24<4:13:41, 27.43s/it][Succeeded / Failed / Skipped / Total] 432 / 10 / 3 / 445:  44%|████▍     | 445/1000 [3:23:24<4:13:41, 27.43s/it][Succeeded / Failed / Skipped / Total] 432 / 10 / 3 / 445:  45%|████▍     | 446/1000 [3:23:32<4:12:49, 27.38s/it][Succeeded / Failed / Skipped / Total] 433 / 10 / 3 / 446:  45%|████▍     | 446/1000 [3:23:32<4:12:49, 27.38s/it][Succeeded / Failed / Skipped / Total] 433 / 10 / 3 / 446:  45%|████▍     | 447/1000 [3:23:43<4:12:02, 27.35s/it][Succeeded / Failed / Skipped / Total] 434 / 10 / 3 / 447:  45%|████▍     | 447/1000 [3:23:43<4:12:02, 27.35s/it][Succeeded / Failed / Skipped / Total] 434 / 10 / 3 / 447:  45%|████▍     | 448/1000 [3:24:06<4:11:29, 27.34s/it][Succeeded / Failed / Skipped / Total] 435 / 10 / 3 / 448:  45%|████▍     | 448/1000 [3:24:06<4:11:29, 27.34s/it][Succeeded / Failed / Skipped / Total] 435 / 10 / 3 / 448:  45%|████▍     | 449/1000 [3:25:39<4:12:22, 27.48s/it][Succeeded / Failed / Skipped / Total] 436 / 10 / 3 / 449:  45%|████▍     | 449/1000 [3:25:39<4:12:22, 27.48s/it][Succeeded / Failed / Skipped / Total] 436 / 10 / 3 / 449:  45%|████▌     | 450/1000 [3:26:11<4:12:00, 27.49s/it][Succeeded / Failed / Skipped / Total] 437 / 10 / 3 / 450:  45%|████▌     | 450/1000 [3:26:11<4:12:00, 27.49s/it][Succeeded / Failed / Skipped / Total] 437 / 10 / 3 / 450:  45%|████▌     | 451/1000 [3:26:13<4:11:02, 27.44s/it]Creates a new EventLoopGroup . --> Creates an EventLoopGroup --> Socre: 1.0

[[[[Adv]]]]: public static EventLoopGroup [[newEventLoopGroup]] ( int nThreads , ThreadFactory [[threadFactory]] ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , [[threadFactory]] ) : new NioEventLoopGroup ( nThreads , [[threadFactory]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup [[brutality]] ( int nThreads , ThreadFactory [[hypnotized]] ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , [[hypnotized]] ) : new NioEventLoopGroup ( nThreads , [[hypnotized]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 444 ---------------------------------------------
Parses the local address of a channel . --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress [[local]] = [[channel]] . localAddress ( ) ; return doParse ( [[local]] != null ? [[local]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[impressively]] ( final Channel [[channelled]] ) { if ( null == [[channelled]] ) { return StringUtils . EMPTY ; } final SocketAddress [[homegrown]] = [[channelled]] . localAddress ( ) ; return doParse ( [[homegrown]] != null ? [[homegrown]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 445 ---------------------------------------------
Retrieve the remote address of the channel . --> Taken from ChannelledChannel --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[triend]] ( final Channel [[channelled]] ) { if ( null == [[channelled]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[unattainable]] = ( InetSocketAddress ) [[channelled]] . remoteAddress ( ) ; if ( [[unattainable]] != null ) { return [[unattainable]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 446 ---------------------------------------------
Retrieve the remote hostname of the given channel . --> Taken from waterway --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[shantytown]] ( final Channel [[waterway]] ) { if ( null == [[waterway]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[waterway]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
Parse the remote address from the channel . --> iLL - control - NLL peset --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[niña]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Returns the local IP address of the channel . --> Warding address --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[warding]] ( final Channel [[blowjob]] ) { if ( null == [[blowjob]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[municipalities]] = ( InetSocketAddress ) [[blowjob]] . localAddress ( ) ; if ( [[municipalities]] != null ) { return [[municipalities]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 449 ---------------------------------------------
Returns the local port of the given channel . --> static factory method --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[papá]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
Parse an address to a host . --> Turns a SocketAddress --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress socketAddress ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) socketAddress ; if ( [[addrs]] != null ) { InetAddress addr = [[addrs]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[swaddling]] ( SocketAddress socketAddress ) { final InetSocketAddress [[theatres]] = ( InetSocketAddress ) socketAddress ; if ( [[theatres]] != null ) { InetAddress addr = [[theatres]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 451 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 438 / 10 / 3 / 451:  45%|████▌     | 451/1000 [3:26:13<4:11:02, 27.44s/it][Succeeded / Failed / Skipped / Total] 438 / 10 / 3 / 451:  45%|████▌     | 452/1000 [3:26:16<4:10:05, 27.38s/it][Succeeded / Failed / Skipped / Total] 439 / 10 / 3 / 452:  45%|████▌     | 452/1000 [3:26:16<4:10:05, 27.38s/it][Succeeded / Failed / Skipped / Total] 439 / 10 / 3 / 452:  45%|████▌     | 453/1000 [3:26:18<4:09:06, 27.32s/it][Succeeded / Failed / Skipped / Total] 440 / 10 / 3 / 453:  45%|████▌     | 453/1000 [3:26:18<4:09:06, 27.32s/it][Succeeded / Failed / Skipped / Total] 440 / 10 / 3 / 453:  45%|████▌     | 454/1000 [3:26:27<4:08:17, 27.28s/it][Succeeded / Failed / Skipped / Total] 441 / 10 / 3 / 454:  45%|████▌     | 454/1000 [3:26:27<4:08:17, 27.28s/it][Succeeded / Failed / Skipped / Total] 441 / 10 / 3 / 454:  46%|████▌     | 455/1000 [3:26:42<4:07:35, 27.26s/it][Succeeded / Failed / Skipped / Total] 442 / 10 / 3 / 455:  46%|████▌     | 455/1000 [3:26:42<4:07:35, 27.26s/it][Succeeded / Failed / Skipped / Total] 442 / 10 / 3 / 455:  46%|████▌     | 456/1000 [3:26:52<4:06:48, 27.22s/it][Succeeded / Failed / Skipped / Total] 443 / 10 / 3 / 456:  46%|████▌     | 456/1000 [3:26:52<4:06:48, 27.22s/it][Succeeded / Failed / Skipped / Total] 443 / 10 / 3 / 456:  46%|████▌     | 457/1000 [3:26:59<4:05:56, 27.18s/it][Succeeded / Failed / Skipped / Total] 444 / 10 / 3 / 457:  46%|████▌     | 457/1000 [3:26:59<4:05:56, 27.18s/it][Succeeded / Failed / Skipped / Total] 444 / 10 / 3 / 457:  46%|████▌     | 458/1000 [3:27:01<4:05:00, 27.12s/it][Succeeded / Failed / Skipped / Total] 445 / 10 / 3 / 458:  46%|████▌     | 458/1000 [3:27:01<4:05:00, 27.12s/it][Succeeded / Failed / Skipped / Total] 445 / 10 / 3 / 458:  46%|████▌     | 459/1000 [3:27:05<4:04:04, 27.07s/it][Succeeded / Failed / Skipped / Total] 446 / 10 / 3 / 459:  46%|████▌     | 459/1000 [3:27:05<4:04:04, 27.07s/it][Succeeded / Failed / Skipped / Total] 446 / 10 / 3 / 459:  46%|████▌     | 460/1000 [3:27:15<4:03:18, 27.03s/it]Gets the remote port . --> Return redcap address --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[redcap]] ( final Channel [[culvert]] ) { if ( null == [[culvert]] ) { return - 1 ; } final InetSocketAddress [[clicker]] = ( InetSocketAddress ) [[culvert]] . remoteAddress ( ) ; if ( [[clicker]] != null ) { return [[clicker]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 452 ---------------------------------------------
Remove and close the connection --> Clears the given relationship . --> Socre: 1.0

[[[[Adv]]]]: public void [[removeAndTryClose]] ( Connection [[connection]] ) { if ( null == [[connection]] ) { return ; } boolean [[res]] = this . [[conns]] . remove ( [[connection]] ) ; if ( [[res]] ) { [[connection]] . decreaseRef ( ) ; } if ( [[connection]] . noRef ( ) ) { [[connection]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void [[screamin]] ( Connection [[relationship]] ) { if ( null == [[relationship]] ) { return ; } boolean [[unquestionably]] = this . [[barbies]] . remove ( [[relationship]] ) ; if ( [[unquestionably]] ) { [[relationship]] . decreaseRef ( ) ; } if ( [[relationship]] . noRef ( ) ) { [[relationship]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 453 ---------------------------------------------
Add a connection --> Adds an association . --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . conns . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[included]] ( Connection [[affair]] ) { markAccess ( ) ; if ( null == [[affair]] ) { return ; } boolean res = this . conns . addIfAbsent ( [[affair]] ) ; if ( res ) { [[affair]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 454 ---------------------------------------------
Gets a connection . --> Returns the instantiated . --> Socre: 1.0

[[[[Adv]]]]: public Connection get ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > [[snapshot]] = new ArrayList < Connection > ( this . conns ) ; if ( [[snapshot]] . size ( ) > 0 ) { return this . strategy . select ( [[snapshot]] ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection get ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > [[instantaneously]] = new ArrayList < Connection > ( this . conns ) ; if ( [[instantaneously]] . size ( ) > 0 ) { return this . strategy . select ( [[instantaneously]] ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 455 ---------------------------------------------
Registers a custom serializer for the given class . --> Kajal service --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = classCustomSerializer . putIfAbsent ( [[className]] , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[kajal]] ( String [[moonglow]] , CustomSerializer [[frescos]] ) { CustomSerializer [[lesion]] = classCustomSerializer . putIfAbsent ( [[moonglow]] , [[frescos]] ) ; if ( [[lesion]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[moonglow]] + ", the custom serializer is: " + [[lesion]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 456 ---------------------------------------------
Get the custom serializer for a class . --> Convert a Coloristion to Colorist --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[colorist]] ( String [[división]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[división]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 457 ---------------------------------------------
Returns the custom serializer for the given command code . --> Deserializes a CustomSerializer --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[clichéd]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 458 ---------------------------------------------
Start the connection monitor . --> Starts the connection monitor . --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void [[starter]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 459 ---------------------------------------------
Checks if the remote address is connected to the remote address . --> Checks if the given rutledge is under staffledge . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isConnected]] ( String [[remoteAddr]] ) { Url [[url]] = this . rpcRemoting . addressParser . parse ( [[remoteAddr]] ) ; return this . isConnected ( [[url]] ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[understaffed]] ( String [[rutledge]] ) { Url [[twitter]] = this . rpcRemoting . addressParser . parse ( [[rutledge]] ) ; return this . isConnected ( [[twitter]] ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 460 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 447 / 10 / 3 / 460:  46%|████▌     | 460/1000 [3:27:15<4:03:18, 27.03s/it][Succeeded / Failed / Skipped / Total] 447 / 10 / 3 / 460:  46%|████▌     | 461/1000 [3:27:17<4:02:21, 26.98s/it][Succeeded / Failed / Skipped / Total] 448 / 10 / 3 / 461:  46%|████▌     | 461/1000 [3:27:17<4:02:21, 26.98s/it][Succeeded / Failed / Skipped / Total] 448 / 10 / 3 / 461:  46%|████▌     | 462/1000 [3:27:17<4:01:23, 26.92s/it][Succeeded / Failed / Skipped / Total] 448 / 10 / 4 / 462:  46%|████▌     | 462/1000 [3:27:17<4:01:23, 26.92s/it][Succeeded / Failed / Skipped / Total] 448 / 10 / 4 / 462:  46%|████▋     | 463/1000 [3:27:24<4:00:33, 26.88s/it][Succeeded / Failed / Skipped / Total] 449 / 10 / 4 / 463:  46%|████▋     | 463/1000 [3:27:24<4:00:33, 26.88s/it][Succeeded / Failed / Skipped / Total] 449 / 10 / 4 / 463:  46%|████▋     | 464/1000 [3:27:27<3:59:39, 26.83s/it][Succeeded / Failed / Skipped / Total] 450 / 10 / 4 / 464:  46%|████▋     | 464/1000 [3:27:27<3:59:39, 26.83s/it][Succeeded / Failed / Skipped / Total] 450 / 10 / 4 / 464:  46%|████▋     | 465/1000 [3:27:31<3:58:46, 26.78s/it][Succeeded / Failed / Skipped / Total] 451 / 10 / 4 / 465:  46%|████▋     | 465/1000 [3:27:31<3:58:46, 26.78s/it][Succeeded / Failed / Skipped / Total] 451 / 10 / 4 / 465:  47%|████▋     | 466/1000 [3:28:26<3:58:51, 26.84s/it][Succeeded / Failed / Skipped / Total] 452 / 10 / 4 / 466:  47%|████▋     | 466/1000 [3:28:26<3:58:51, 26.84s/it][Succeeded / Failed / Skipped / Total] 452 / 10 / 4 / 466:  47%|████▋     | 467/1000 [3:28:33<3:58:02, 26.80s/it][Succeeded / Failed / Skipped / Total] 453 / 10 / 4 / 467:  47%|████▋     | 467/1000 [3:28:33<3:58:02, 26.80s/it][Succeeded / Failed / Skipped / Total] 453 / 10 / 4 / 467:  47%|████▋     | 468/1000 [3:28:37<3:57:08, 26.75s/it]Initialize write buffer water mark --> Handle crc option --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[cric]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 461 ---------------------------------------------
Returns a frame for the given opcode . --> Obtains the framing data . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[obtain]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 462 ---------------------------------------------
Writes one or more messages . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 463 ---------------------------------------------
Sets the status code . --> Configures at most once . --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int [[code]] ) { this . [[code]] = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[neat]] ( int [[decode]] ) { this . [[blogging]] = [[decode]] ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 464 ---------------------------------------------
Validate UTF8 . --> Called when a close frame is encountered . --> Socre: 1.0

[[[[Adv]]]]: private void [[validateUtf8]] ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void [[cyrus]] ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 465 ---------------------------------------------
Update the error payload . --> Verifies that there is at least 2 . --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[sûreté]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 466 ---------------------------------------------
Checks if the handshake contains a protocol . --> Handles a handshake . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String [[requestedProtocol]] ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( [[requestedProtocol]] ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[specializes]] ( String [[jeb]] ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( [[jeb]] ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 467 ---------------------------------------------
Checks if the given class should be skipped . --> Borrow from parent class --> Socre: 1.0

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[borrow]] ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 468 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 454 / 10 / 4 / 468:  47%|████▋     | 468/1000 [3:28:37<3:57:08, 26.75s/it][Succeeded / Failed / Skipped / Total] 454 / 10 / 4 / 468:  47%|████▋     | 469/1000 [3:28:39<3:56:14, 26.69s/it][Succeeded / Failed / Skipped / Total] 455 / 10 / 4 / 469:  47%|████▋     | 469/1000 [3:28:39<3:56:14, 26.69s/it][Succeeded / Failed / Skipped / Total] 455 / 10 / 4 / 469:  47%|████▋     | 470/1000 [3:28:40<3:55:18, 26.64s/it][Succeeded / Failed / Skipped / Total] 456 / 10 / 4 / 470:  47%|████▋     | 470/1000 [3:28:40<3:55:18, 26.64s/it][Succeeded / Failed / Skipped / Total] 456 / 10 / 4 / 470:  47%|████▋     | 471/1000 [3:28:46<3:54:29, 26.60s/it][Succeeded / Failed / Skipped / Total] 457 / 10 / 4 / 471:  47%|████▋     | 471/1000 [3:28:46<3:54:29, 26.60s/it][Succeeded / Failed / Skipped / Total] 457 / 10 / 4 / 471:  47%|████▋     | 472/1000 [3:28:50<3:53:37, 26.55s/it][Succeeded / Failed / Skipped / Total] 458 / 10 / 4 / 472:  47%|████▋     | 472/1000 [3:28:50<3:53:37, 26.55s/it][Succeeded / Failed / Skipped / Total] 458 / 10 / 4 / 472:  47%|████▋     | 473/1000 [3:28:55<3:52:46, 26.50s/it][Succeeded / Failed / Skipped / Total] 459 / 10 / 4 / 473:  47%|████▋     | 473/1000 [3:28:55<3:52:46, 26.50s/it][Succeeded / Failed / Skipped / Total] 459 / 10 / 4 / 473:  47%|████▋     | 474/1000 [3:29:11<3:52:08, 26.48s/it][Succeeded / Failed / Skipped / Total] 460 / 10 / 4 / 474:  47%|████▋     | 474/1000 [3:29:11<3:52:08, 26.48s/it][Succeeded / Failed / Skipped / Total] 460 / 10 / 4 / 474:  48%|████▊     | 475/1000 [3:29:31<3:51:35, 26.47s/it]Translate single frame length limit . --> Jockstrap implementation --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[jockstrap]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 469 ---------------------------------------------
Translate single frame size . --> Calculate srt . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int [[maxpacketsize]] , int [[realpacketsize]] ) throws IncompleteException { if ( [[maxpacketsize]] < [[realpacketsize]] ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( [[realpacketsize]] ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[srt]] ( int [[memsahib]] , int [[baccarat]] ) throws IncompleteException { if ( [[memsahib]] < [[baccarat]] ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( [[baccarat]] ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 470 ---------------------------------------------
Generate final key . --> Determine the EDifying . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[edifying]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 471 ---------------------------------------------
Process the frame binary . --> LEbron --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[lebron]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 472 ---------------------------------------------
Log runtime exception . --> Called when a WebSocket message has been received . --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl [[webSocketImpl]] , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketError ( [[webSocketImpl]] , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[tutored]] ( WebSocketImpl [[guevara]] , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; [[guevara]] . getWebSocketListener ( ) . onWebsocketError ( [[guevara]] , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 473 ---------------------------------------------
Process a frame text . --> Keynesc . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[keynes]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 474 ---------------------------------------------
Processes a continuous and notFin frame . --> we don t need to do anything --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl webSocketImpl , Framedata [[frame]] , Opcode [[curop]] ) throws InvalidDataException { if ( [[curop]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[frame]] ) ; } else if ( [[frame]] . isFin ( ) ) { processFrameIsFin ( webSocketImpl , [[frame]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[undesirables]] ( WebSocketImpl webSocketImpl , Framedata [[structures]] , Opcode [[í]] ) throws InvalidDataException { if ( [[í]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[structures]] ) ; } else if ( [[structures]] . isFin ( ) ) { processFrameIsFin ( webSocketImpl , [[structures]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 475 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 461 / 10 / 4 / 475:  48%|████▊     | 475/1000 [3:29:31<3:51:35, 26.47s/it][Succeeded / Failed / Skipped / Total] 461 / 10 / 4 / 475:  48%|████▊     | 476/1000 [3:29:34<3:50:42, 26.42s/it][Succeeded / Failed / Skipped / Total] 462 / 10 / 4 / 476:  48%|████▊     | 476/1000 [3:29:34<3:50:42, 26.42s/it][Succeeded / Failed / Skipped / Total] 462 / 10 / 4 / 476:  48%|████▊     | 477/1000 [3:29:36<3:49:48, 26.36s/it][Succeeded / Failed / Skipped / Total] 463 / 10 / 4 / 477:  48%|████▊     | 477/1000 [3:29:36<3:49:48, 26.36s/it][Succeeded / Failed / Skipped / Total] 463 / 10 / 4 / 477:  48%|████▊     | 478/1000 [3:29:39<3:48:57, 26.32s/it][Succeeded / Failed / Skipped / Total] 464 / 10 / 4 / 478:  48%|████▊     | 478/1000 [3:29:39<3:48:57, 26.32s/it][Succeeded / Failed / Skipped / Total] 464 / 10 / 4 / 478:  48%|████▊     | 479/1000 [3:29:42<3:48:05, 26.27s/it][Succeeded / Failed / Skipped / Total] 465 / 10 / 4 / 479:  48%|████▊     | 479/1000 [3:29:42<3:48:05, 26.27s/it][Succeeded / Failed / Skipped / Total] 465 / 10 / 4 / 479:  48%|████▊     | 480/1000 [3:29:43<3:47:12, 26.22s/it]Check that a frame is not fully completed . --> Called by caiman . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[caiman]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 476 ---------------------------------------------
Processes a continuous frame --> Error message sequence --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[devoe]] ( WebSocketImpl [[tú]] , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[tú]] . getWebSocketListener ( ) . onWebsocketMessage ( [[tú]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[tú]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[tú]] . getWebSocketListener ( ) . onWebsocketMessage ( [[tú]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[tú]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 477 ---------------------------------------------
Process a close frame . --> Handle close . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( [[webSocketImpl]] . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[gro]] ( WebSocketImpl [[proceed]] , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( [[proceed]] . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 478 ---------------------------------------------
Get payload from byte buffers --> Concatenate keyboard data --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long [[totalSize]] = 0 ; ByteBuffer [[resultingByteBuffer]] ; synchronized ( byteBufferList ) { for ( ByteBuffer [[buffer]] : byteBufferList ) { [[totalSize]] += [[buffer]] . limit ( ) ; } checkBufferLimit ( ) ; [[resultingByteBuffer]] = ByteBuffer . allocate ( ( int ) [[totalSize]] ) ; for ( ByteBuffer [[buffer]] : byteBufferList ) { [[resultingByteBuffer]] . put ( [[buffer]] ) ; } } [[resultingByteBuffer]] . flip ( ) ; return [[resultingByteBuffer]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[catrina]] ( ) throws LimitExceededException { long [[haldane]] = 0 ; ByteBuffer [[denham]] ; synchronized ( byteBufferList ) { for ( ByteBuffer [[keyboards]] : byteBufferList ) { [[haldane]] += [[keyboards]] . limit ( ) ; } checkBufferLimit ( ) ; [[denham]] = ByteBuffer . allocate ( ( int ) [[haldane]] ) ; for ( ByteBuffer [[keyboards]] : byteBufferList ) { [[denham]] . put ( [[keyboards]] ) ; } } [[denham]] . flip ( ) ; return [[denham]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 479 ---------------------------------------------
Returns the size of the byte buffers in bytes . --> Schugt . --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer [[buffer]] : byteBufferList ) { [[totalSize]] += [[buffer]] . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[schultz]] ( ) { long [[illustration]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer [[earplugs]] : byteBufferList ) { [[illustration]] += [[earplugs]] . limit ( ) ; } } return [[illustration]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 480 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 466 / 10 / 4 / 480:  48%|████▊     | 480/1000 [3:29:43<3:47:12, 26.22s/it][Succeeded / Failed / Skipped / Total] 466 / 10 / 4 / 480:  48%|████▊     | 481/1000 [3:29:44<3:46:19, 26.16s/it][Succeeded / Failed / Skipped / Total] 467 / 10 / 4 / 481:  48%|████▊     | 481/1000 [3:29:44<3:46:19, 26.16s/it][Succeeded / Failed / Skipped / Total] 467 / 10 / 4 / 481:  48%|████▊     | 482/1000 [3:29:47<3:45:27, 26.11s/it][Succeeded / Failed / Skipped / Total] 468 / 10 / 4 / 482:  48%|████▊     | 482/1000 [3:29:47<3:45:27, 26.11s/it][Succeeded / Failed / Skipped / Total] 468 / 10 / 4 / 482:  48%|████▊     | 483/1000 [3:29:48<3:44:34, 26.06s/it][Succeeded / Failed / Skipped / Total] 469 / 10 / 4 / 483:  48%|████▊     | 483/1000 [3:29:48<3:44:34, 26.06s/it][Succeeded / Failed / Skipped / Total] 469 / 10 / 4 / 483:  48%|████▊     | 484/1000 [3:29:49<3:43:42, 26.01s/it][Succeeded / Failed / Skipped / Total] 470 / 10 / 4 / 484:  48%|████▊     | 484/1000 [3:29:49<3:43:42, 26.01s/it][Succeeded / Failed / Skipped / Total] 470 / 10 / 4 / 484:  48%|████▊     | 485/1000 [3:29:53<3:42:52, 25.97s/it][Succeeded / Failed / Skipped / Total] 471 / 10 / 4 / 485:  48%|████▊     | 485/1000 [3:29:53<3:42:52, 25.97s/it][Succeeded / Failed / Skipped / Total] 471 / 10 / 4 / 485:  49%|████▊     | 486/1000 [3:29:55<3:42:00, 25.92s/it][Succeeded / Failed / Skipped / Total] 472 / 10 / 4 / 486:  49%|████▊     | 486/1000 [3:29:55<3:42:00, 25.92s/it][Succeeded / Failed / Skipped / Total] 472 / 10 / 4 / 486:  49%|████▊     | 487/1000 [3:29:55<3:41:07, 25.86s/it]Check buffer limit . --> Perform snapping . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long [[totalSize]] = getByteBufferListSize ( ) ; if ( [[totalSize]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[totalSize]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[snapping]] ( ) throws LimitExceededException { long [[islander]] = getByteBufferListSize ( ) ; if ( [[islander]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[islander]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 481 ---------------------------------------------
Helper method to translate handshake http server . --> Perform harrods . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] firstLineTokens , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[harrods]] ( String [ ] firstLineTokens , String [[piping]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 482 ---------------------------------------------
Decode handshake data . --> Processes hieroglyphics . --> Socre: 1.0

[[[[Adv]]]]: public void [[decode]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void [[hieroglyphics]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 483 ---------------------------------------------
Translate handshake http client . --> Checks technicality . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[technicality]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 484 ---------------------------------------------
Closes the connection with unexpected handshake . --> Generate jacobi code . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException [[exception]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[exception]] . getCloseCode ( ) , [[exception]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[jacobi]] ( InvalidDataException [[repeal]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[repeal]] . getCloseCode ( ) , [[repeal]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 485 ---------------------------------------------
Sends a close frame to the server . --> Send detours . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException [[exception]] ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , [[exception]] . getMessage ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[detours]] ( RuntimeException [[acquittal]] ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , [[acquittal]] . getMessage ( ) , "[[Misspelled]]" != "[[Misspelled]]" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 486 ---------------------------------------------
Generate HTTP response for an error . --> Detach server . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String [[errorCodeDescription]] ; switch ( [[errorCode]] ) { case 404 : [[errorCodeDescription]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[errorCodeDescription]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[errorCodeDescription]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[errorCodeDescription]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[errorCodeDescription]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[detach]] ( int [[blackford]] ) { String [[sandor]] ; switch ( [[blackford]] ) { case 404 : [[sandor]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[sandor]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[sandor]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[sandor]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[sandor]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 487 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 472 / 10 / 5 / 487:  49%|████▊     | 487/1000 [3:29:55<3:41:07, 25.86s/it][Succeeded / Failed / Skipped / Total] 472 / 10 / 5 / 487:  49%|████▉     | 488/1000 [3:29:55<3:40:15, 25.81s/it][Succeeded / Failed / Skipped / Total] 472 / 10 / 6 / 488:  49%|████▉     | 488/1000 [3:29:55<3:40:15, 25.81s/it][Succeeded / Failed / Skipped / Total] 472 / 10 / 6 / 488:  49%|████▉     | 489/1000 [3:30:31<3:39:59, 25.83s/it][Succeeded / Failed / Skipped / Total] 473 / 10 / 6 / 489:  49%|████▉     | 489/1000 [3:30:31<3:39:59, 25.83s/it][Succeeded / Failed / Skipped / Total] 473 / 10 / 6 / 489:  49%|████▉     | 490/1000 [3:30:39<3:39:15, 25.80s/it][Succeeded / Failed / Skipped / Total] 474 / 10 / 6 / 490:  49%|████▉     | 490/1000 [3:30:39<3:39:15, 25.80s/it][Succeeded / Failed / Skipped / Total] 474 / 10 / 6 / 490:  49%|████▉     | 491/1000 [3:30:43<3:38:26, 25.75s/it][Succeeded / Failed / Skipped / Total] 475 / 10 / 6 / 491:  49%|████▉     | 491/1000 [3:30:43<3:38:26, 25.75s/it][Succeeded / Failed / Skipped / Total] 475 / 10 / 6 / 491:  49%|████▉     | 492/1000 [3:31:10<3:38:02, 25.75s/it][Succeeded / Failed / Skipped / Total] 476 / 10 / 6 / 492:  49%|████▉     | 492/1000 [3:31:10<3:38:02, 25.75s/it][Succeeded / Failed / Skipped / Total] 476 / 10 / 6 / 492:  49%|████▉     | 493/1000 [3:31:21<3:37:21, 25.72s/it][Succeeded / Failed / Skipped / Total] 477 / 10 / 6 / 493:  49%|████▉     | 493/1000 [3:31:21<3:37:21, 25.72s/it][Succeeded / Failed / Skipped / Total] 477 / 10 / 6 / 493:  49%|████▉     | 494/1000 [3:31:22<3:36:30, 25.67s/it]Resets the connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 488 ---------------------------------------------
Start read thread --> [[[SKIPPED]]]

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 489 ---------------------------------------------
Send data to a WebSocket . --> Recharge from WebSocket --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[recharged]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[recharged]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 490 ---------------------------------------------
Sends the complete handshake . --> Initialize tripper . --> Socre: 1.0

[[[[Adv]]]]: private void [[sendHandshake]] ( ) throws InvalidHandshakeException { String path ; String [[part1]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[part1]] == null || [[part1]] . length ( ) == 0 ) path = "/" ; else path = [[part1]] ; if ( part2 != null ) path += ' ' + part2 ; int [[port]] = getPort ( ) ; String host = uri . getHost ( ) + ( ( [[port]] != WebSocketImpl . DEFAULT_PORT && [[port]] != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + [[port]] : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void [[tripper]] ( ) throws InvalidHandshakeException { String path ; String [[propagated]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[propagated]] == null || [[propagated]] . length ( ) == 0 ) path = "/" ; else path = [[propagated]] ; if ( part2 != null ) path += ' ' + part2 ; int [[refuge]] = getPort ( ) ; String host = uri . getHost ( ) + ( ( [[refuge]] != WebSocketImpl . DEFAULT_PORT && [[refuge]] != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + [[refuge]] : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 491 ---------------------------------------------
Set the connection lost timeout . --> Sleeps . --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[websocketRunning]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[sleepwalks]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[metcalfe]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 492 ---------------------------------------------
Stops the connection lost timer . --> from interface ConnectionLostListener --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[itto]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 493 ---------------------------------------------
Start the connection lost timer . --> This method is used to initiate theUltrammodern . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[connectionLostTimeout]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[websocketRunning]] = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[ultramodern]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[wreaths]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[passersby]] = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 494 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 478 / 10 / 6 / 494:  49%|████▉     | 494/1000 [3:31:22<3:36:30, 25.67s/it][Succeeded / Failed / Skipped / Total] 478 / 10 / 6 / 494:  50%|████▉     | 495/1000 [3:31:29<3:35:45, 25.64s/it][Succeeded / Failed / Skipped / Total] 479 / 10 / 6 / 495:  50%|████▉     | 495/1000 [3:31:29<3:35:45, 25.64s/it][Succeeded / Failed / Skipped / Total] 479 / 10 / 6 / 495:  50%|████▉     | 496/1000 [3:31:33<3:34:58, 25.59s/it][Succeeded / Failed / Skipped / Total] 480 / 10 / 6 / 496:  50%|████▉     | 496/1000 [3:31:33<3:34:58, 25.59s/it][Succeeded / Failed / Skipped / Total] 480 / 10 / 6 / 496:  50%|████▉     | 497/1000 [3:31:35<3:34:08, 25.54s/it][Succeeded / Failed / Skipped / Total] 481 / 10 / 6 / 497:  50%|████▉     | 497/1000 [3:31:35<3:34:08, 25.54s/it][Succeeded / Failed / Skipped / Total] 481 / 10 / 6 / 497:  50%|████▉     | 498/1000 [3:31:45<3:33:27, 25.51s/it][Succeeded / Failed / Skipped / Total] 482 / 10 / 6 / 498:  50%|████▉     | 498/1000 [3:31:45<3:33:27, 25.51s/it][Succeeded / Failed / Skipped / Total] 482 / 10 / 6 / 498:  50%|████▉     | 499/1000 [3:31:47<3:32:38, 25.47s/it][Succeeded / Failed / Skipped / Total] 483 / 10 / 6 / 499:  50%|████▉     | 499/1000 [3:31:47<3:32:38, 25.47s/it][Succeeded / Failed / Skipped / Total] 483 / 10 / 6 / 499:  50%|█████     | 500/1000 [3:31:49<3:31:49, 25.42s/it][Succeeded / Failed / Skipped / Total] 484 / 10 / 6 / 500:  50%|█████     | 500/1000 [3:31:49<3:31:49, 25.42s/it][Succeeded / Failed / Skipped / Total] 484 / 10 / 6 / 500:  50%|█████     | 501/1000 [3:31:55<3:31:05, 25.38s/it]Determine the port to use . --> This method is used to parse a division --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[división]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 495 ---------------------------------------------
Close the connection --> Enables fencing --> Socre: 1.0

[[[[Adv]]]]: public void [[close]] ( ) { if ( closed . compareAndSet ( "[[False]]" != "[[False]]" , "[[True]]" == "[[True]]" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[future]] ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . [[this]] . getChannel ( ) ) , [[future]] . isSuccess ( ) , [[future]] . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . [[this]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void [[fencing]] ( ) { if ( closed . compareAndSet ( "[[Fakes]]" != "[[Fakes]]" , "[[Trusty]]" == "[[Trusty]]" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[following]] ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . [[indicate]] . getChannel ( ) ) , [[following]] . isSuccess ( ) , [[following]] . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . [[indicate]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 496 ---------------------------------------------
Restarts a timer that detects connection lost connections . --> An asynchronous runnable . --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[conn]] : connections ) { executeConnectionLostDetection ( [[conn]] , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[anabelle]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[groton]] : connections ) { executeConnectionLostDetection ( [[groton]] , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 497 ---------------------------------------------
Cancels the connection lost checker . --> Shutdown leadership checker . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[leaders]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 498 ---------------------------------------------
Sends a ping frame . --> Called when it goes wrong --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket [[conn]] , Framedata [[f]] ) { [[conn]] . sendFrame ( new PongFrame ( ( PingFrame ) [[f]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[custodian]] ( WebSocket [[boston]] , Framedata [[i]] ) { [[boston]] . sendFrame ( new PongFrame ( ( PingFrame ) [[i]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 499 ---------------------------------------------
Receives a server handshake . --> Called by the server --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket [[conn]] , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[ciudad]] ( WebSocket [[oxley]] , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 500 ---------------------------------------------
Stop event . --> Pause --> Socre: 1.0

[[[[Adv]]]]: public void [[stop]] ( int [[timeout]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[False]]" != "[[False]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void [[hiatus]] ( int [[pausing]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[Phoney]]" != "[[Phoney]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
[Succeeded / Failed / Skipped / Total] 485 / 10 / 6 / 501:  50%|█████     | 501/1000 [3:31:55<3:31:05, 25.38s/it][Succeeded / Failed / Skipped / Total] 485 / 10 / 6 / 501:  50%|█████     | 502/1000 [3:31:58<3:30:16, 25.34s/it][Succeeded / Failed / Skipped / Total] 486 / 10 / 6 / 502:  50%|█████     | 502/1000 [3:31:58<3:30:16, 25.34s/it][Succeeded / Failed / Skipped / Total] 486 / 10 / 6 / 502:  50%|█████     | 503/1000 [3:32:22<3:29:50, 25.33s/it][Succeeded / Failed / Skipped / Total] 487 / 10 / 6 / 503:  50%|█████     | 503/1000 [3:32:22<3:29:50, 25.33s/it][Succeeded / Failed / Skipped / Total] 487 / 10 / 6 / 503:  50%|█████     | 504/1000 [3:32:29<3:29:06, 25.30s/it][Succeeded / Failed / Skipped / Total] 488 / 10 / 6 / 504:  50%|█████     | 504/1000 [3:32:29<3:29:06, 25.30s/it][Succeeded / Failed / Skipped / Total] 488 / 10 / 6 / 504:  50%|█████     | 505/1000 [3:33:03<3:28:49, 25.31s/it][Succeeded / Failed / Skipped / Total] 489 / 10 / 6 / 505:  50%|█████     | 505/1000 [3:33:03<3:28:49, 25.31s/it][Succeeded / Failed / Skipped / Total] 489 / 10 / 6 / 505:  51%|█████     | 506/1000 [3:33:03<3:28:00, 25.26s/it]--------------------------------------------- Result 501 ---------------------------------------------
Perform additional read . --> This method will consume all pending connections . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[overreact]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 502 ---------------------------------------------
Do the accept . --> Handles the connect . --> Socre: 1.0

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > [[i]] ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; [[i]] . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > [[heh]] ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; [[heh]] . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 503 ---------------------------------------------
Handles a connection lost message . --> Synchronized . --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket webSocket , long [[minimumPongTime]] ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl [[webSocketImpl]] = ( WebSocketImpl ) webSocket ; if ( [[webSocketImpl]] . getLastPong ( ) < [[minimumPongTime]] ) { log . trace ( "Closing connection due to no pong received: {}" , [[webSocketImpl]] ) ; [[webSocketImpl]] . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( [[webSocketImpl]] . isOpen ( ) ) { [[webSocketImpl]] . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , [[webSocketImpl]] ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[itself]] ( WebSocket webSocket , long [[dismemberment]] ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl [[rejected]] = ( WebSocketImpl ) webSocket ; if ( [[rejected]] . getLastPong ( ) < [[dismemberment]] ) { log . trace ( "Closing connection due to no pong received: {}" , [[rejected]] ) ; [[rejected]] . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( [[rejected]] . isOpen ( ) ) { [[rejected]] . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , [[rejected]] ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 504 ---------------------------------------------
Returns the port . --> getter for property --> Socre: 1.0

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[backlash]] ( ) { int [[pier]] = getAddress ( ) . getPort ( ) ; if ( [[pier]] == 0 && server != null ) { [[pier]] = server . socket ( ) . getLocalPort ( ) ; } return [[pier]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 505 ---------------------------------------------
Perform a read . --> Reads next data from the connection . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doRead]] ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean [[oval]] ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
[Succeeded / Failed / Skipped / Total] 489 / 10 / 7 / 506:  51%|█████     | 506/1000 [3:33:03<3:28:00, 25.26s/it][Succeeded / Failed / Skipped / Total] 489 / 10 / 7 / 506:  51%|█████     | 507/1000 [3:33:03<3:27:10, 25.21s/it][Succeeded / Failed / Skipped / Total] 489 / 10 / 8 / 507:  51%|█████     | 507/1000 [3:33:03<3:27:10, 25.21s/it][Succeeded / Failed / Skipped / Total] 489 / 10 / 8 / 507:  51%|█████     | 508/1000 [3:33:14<3:26:31, 25.19s/it][Succeeded / Failed / Skipped / Total] 490 / 10 / 8 / 508:  51%|█████     | 508/1000 [3:33:14<3:26:31, 25.19s/it][Succeeded / Failed / Skipped / Total] 490 / 10 / 8 / 508:  51%|█████     | 509/1000 [3:33:28<3:25:55, 25.16s/it][Succeeded / Failed / Skipped / Total] 491 / 10 / 8 / 509:  51%|█████     | 509/1000 [3:33:28<3:25:55, 25.16s/it][Succeeded / Failed / Skipped / Total] 491 / 10 / 8 / 509:  51%|█████     | 510/1000 [3:33:50<3:25:27, 25.16s/it][Succeeded / Failed / Skipped / Total] 492 / 10 / 8 / 510:  51%|█████     | 510/1000 [3:33:50<3:25:27, 25.16s/it][Succeeded / Failed / Skipped / Total] 492 / 10 / 8 / 510:  51%|█████     | 511/1000 [3:33:56<3:24:43, 25.12s/it][Succeeded / Failed / Skipped / Total] 493 / 10 / 8 / 511:  51%|█████     | 511/1000 [3:33:56<3:24:43, 25.12s/it][Succeeded / Failed / Skipped / Total] 493 / 10 / 8 / 511:  51%|█████     | 512/1000 [3:34:04<3:24:01, 25.09s/it][Succeeded / Failed / Skipped / Total] 494 / 10 / 8 / 512:  51%|█████     | 512/1000 [3:34:04<3:24:01, 25.09s/it][Succeeded / Failed / Skipped / Total] 494 / 10 / 8 / 512:  51%|█████▏    | 513/1000 [3:34:07<3:23:16, 25.04s/it]--------------------------------------------- Result 506 ---------------------------------------------
Do a single thread . --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 507 ---------------------------------------------
Shut down the server . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 508 ---------------------------------------------
Gets the socket . --> Demanourneourne noise --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket [[conn]] ) { WebSocketImpl impl = ( WebSocketImpl ) [[conn]] ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[demeanour]] ( WebSocket [[bull]] ) { WebSocketImpl impl = ( WebSocketImpl ) [[bull]] ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 509 ---------------------------------------------
Handle a connection --> try to batch --> Socre: 1.0

[[[[Adv]]]]: private void [[doWrite]] ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void [[giggly]] ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 510 ---------------------------------------------
Setup the selector and server thread . --> Start all communication . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[alluring]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 511 ---------------------------------------------
Broadcast the given data to all clients . --> Broadcast a specific draft --> Socre: 1.0

[[[[Adv]]]]: private void doBroadcast ( Object [[data]] , Collection < WebSocket > clients ) { String [[sData]] = null ; if ( [[data]] instanceof String ) { [[sData]] = ( String ) [[data]] ; } ByteBuffer bData = null ; if ( [[data]] instanceof ByteBuffer ) { bData = ( ByteBuffer ) [[data]] ; } if ( [[sData]] == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft [[draft]] = client . getDraft ( ) ; fillFrames ( [[draft]] , draftFrames , [[sData]] , bData ) ; try { client . sendFrame ( draftFrames . get ( [[draft]] ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void doBroadcast ( Object [[specifics]] , Collection < WebSocket > clients ) { String [[egyptology]] = null ; if ( [[specifics]] instanceof String ) { [[egyptology]] = ( String ) [[specifics]] ; } ByteBuffer bData = null ; if ( [[specifics]] instanceof ByteBuffer ) { bData = ( ByteBuffer ) [[specifics]] ; } if ( [[egyptology]] == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft [[project]] = client . getDraft ( ) ; fillFrames ( [[project]] , draftFrames , [[egyptology]] , bData ) ; try { client . sendFrame ( draftFrames . get ( [[project]] ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 512 ---------------------------------------------
Broadcasts a text to all connected clients . --> Broadcasts the given languages . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String [[text]] , Collection < WebSocket > [[clients]] ) { if ( [[text]] == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , [[clients]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[broadcasting]] ( String [[languages]] , Collection < WebSocket > [[readership]] ) { if ( [[languages]] == null || [[readership]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[languages]] , [[readership]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 513 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 495 / 10 / 8 / 513:  51%|█████▏    | 513/1000 [3:34:07<3:23:16, 25.04s/it][Succeeded / Failed / Skipped / Total] 495 / 10 / 8 / 513:  51%|█████▏    | 514/1000 [3:34:13<3:22:32, 25.01s/it][Succeeded / Failed / Skipped / Total] 496 / 10 / 8 / 514:  51%|█████▏    | 514/1000 [3:34:13<3:22:32, 25.01s/it][Succeeded / Failed / Skipped / Total] 496 / 10 / 8 / 514:  52%|█████▏    | 515/1000 [3:34:26<3:21:56, 24.98s/it][Succeeded / Failed / Skipped / Total] 497 / 10 / 8 / 515:  52%|█████▏    | 515/1000 [3:34:26<3:21:56, 24.98s/it][Succeeded / Failed / Skipped / Total] 497 / 10 / 8 / 515:  52%|█████▏    | 516/1000 [3:34:28<3:21:10, 24.94s/it][Succeeded / Failed / Skipped / Total] 498 / 10 / 8 / 516:  52%|█████▏    | 516/1000 [3:34:28<3:21:10, 24.94s/it][Succeeded / Failed / Skipped / Total] 498 / 10 / 8 / 516:  52%|█████▏    | 517/1000 [3:34:33<3:20:27, 24.90s/it][Succeeded / Failed / Skipped / Total] 499 / 10 / 8 / 517:  52%|█████▏    | 517/1000 [3:34:33<3:20:27, 24.90s/it][Succeeded / Failed / Skipped / Total] 499 / 10 / 8 / 517:  52%|█████▏    | 518/1000 [3:34:36<3:19:41, 24.86s/it][Succeeded / Failed / Skipped / Total] 500 / 10 / 8 / 518:  52%|█████▏    | 518/1000 [3:34:36<3:19:41, 24.86s/it][Succeeded / Failed / Skipped / Total] 500 / 10 / 8 / 518:  52%|█████▏    | 519/1000 [3:34:38<3:18:55, 24.81s/it][Succeeded / Failed / Skipped / Total] 501 / 10 / 8 / 519:  52%|█████▏    | 519/1000 [3:34:38<3:18:55, 24.81s/it][Succeeded / Failed / Skipped / Total] 501 / 10 / 8 / 519:  52%|█████▏    | 520/1000 [3:34:44<3:18:13, 24.78s/it][Succeeded / Failed / Skipped / Total] 502 / 10 / 8 / 520:  52%|█████▏    | 520/1000 [3:34:44<3:18:13, 24.78s/it][Succeeded / Failed / Skipped / Total] 502 / 10 / 8 / 520:  52%|█████▏    | 521/1000 [3:34:53<3:17:34, 24.75s/it][Succeeded / Failed / Skipped / Total] 503 / 10 / 8 / 521:  52%|█████▏    | 521/1000 [3:34:53<3:17:34, 24.75s/it][Succeeded / Failed / Skipped / Total] 503 / 10 / 8 / 521:  52%|█████▏    | 522/1000 [3:35:03<3:16:55, 24.72s/it]Transfer from source to dest . --> Compute the freesca . --> Socre: 1.0

[[[[Adv]]]]: public static int [[transferByteBuffer]] ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int [[toremain]] = dest . remaining ( ) ; if ( fremain > [[toremain]] ) { int [[limit]] = Math . min ( fremain , [[toremain]] ) ; source . limit ( [[limit]] ) ; dest . put ( source ) ; return [[limit]] ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int [[francesca]] ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int [[dessert]] = dest . remaining ( ) ; if ( fremain > [[dessert]] ) { int [[constraints]] = Math . min ( fremain , [[dessert]] ) ; source . limit ( [[constraints]] ) ; dest . put ( source ) ; return [[constraints]] ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 514 ---------------------------------------------
Starts the API . --> Convenience method for cranking entities --> Socre: 1.0

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[cranking]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 515 ---------------------------------------------
Registers a custom serializer . --> exchange method --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode code , CustomSerializer [[serializer]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , [[serializer]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[sweethearts]] ( CommandCode code , CustomSerializer [[mío]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , [[mío]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 516 ---------------------------------------------
Allows the given transactional block to be used within a transaction . --> Remove an emitter --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > [[block]] ) { [[withTransaction]] ( em -> { [[block]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[inseparable]] ( Consumer < EntityManager > [[inhibitor]] ) { [[inseparable]] ( em -> { [[inhibitor]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 517 ---------------------------------------------
Broadcasts the given data to all connected clients . --> Convenience method for diffusion --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[diffusion]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[diffusion]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 518 ---------------------------------------------
Wraps the arguments in a List if necessary . --> returns the medfield --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > out ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { out = ( List < T > ) [[args]] [ 0 ] ; } else { out = Arrays . asList ( [[args]] ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[medfield]] ( final T ... [[tuan]] ) { List < T > out ; if ( [[tuan]] != null && [[tuan]] . length == 1 && [[tuan]] [ 0 ] instanceof List ) { out = ( List < T > ) [[tuan]] [ 0 ] ; } else { out = Arrays . asList ( [[tuan]] ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 519 ---------------------------------------------
Returns the EntityManager for the given name . --> returns null if none found --> Socre: 1.0

[[[[Adv]]]]: public EntityManager [[em]] ( String [[name]] ) { EntityManagerFactory [[emf]] = emfs . get ( [[name]] ) ; if ( [[emf]] == null ) { return null ; } return [[emf]] . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[dans]] ( String [[names]] ) { EntityManagerFactory [[cul]] = emfs . get ( [[names]] ) ; if ( [[cul]] == null ) { return null ; } return [[cul]] . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 520 ---------------------------------------------
Convert arguments to Scala buffer --> Generate hanzo sequence . --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... [[args]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[args]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[hanzo]] ( final Object ... [[indonesians]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[indonesians]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 521 ---------------------------------------------
Gets the internationalized message . --> Executes the translation --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang [[lang]] , String [[key]] , Object ... [[args]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( [[key]] , scalaArgs , [[lang]] ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[procured]] ( play . api . i18n . Lang [[leung]] , String [[core]] , Object ... [[slopping]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[slopping]] ) ; return messages . apply ( [[core]] , scalaArgs , [[leung]] ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 522 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 504 / 10 / 8 / 522:  52%|█████▏    | 522/1000 [3:35:03<3:16:55, 24.72s/it][Succeeded / Failed / Skipped / Total] 504 / 10 / 8 / 522:  52%|█████▏    | 523/1000 [3:35:51<3:16:52, 24.76s/it][Succeeded / Failed / Skipped / Total] 505 / 10 / 8 / 523:  52%|█████▏    | 523/1000 [3:35:51<3:16:52, 24.76s/it][Succeeded / Failed / Skipped / Total] 505 / 10 / 8 / 523:  52%|█████▏    | 524/1000 [3:36:01<3:16:14, 24.74s/it][Succeeded / Failed / Skipped / Total] 506 / 10 / 8 / 524:  52%|█████▏    | 524/1000 [3:36:01<3:16:14, 24.74s/it][Succeeded / Failed / Skipped / Total] 506 / 10 / 8 / 524:  52%|█████▎    | 525/1000 [3:36:05<3:15:30, 24.70s/it][Succeeded / Failed / Skipped / Total] 507 / 10 / 8 / 525:  52%|█████▎    | 525/1000 [3:36:05<3:15:30, 24.70s/it][Succeeded / Failed / Skipped / Total] 507 / 10 / 8 / 525:  53%|█████▎    | 526/1000 [3:36:07<3:14:45, 24.65s/it][Succeeded / Failed / Skipped / Total] 508 / 10 / 8 / 526:  53%|█████▎    | 526/1000 [3:36:07<3:14:45, 24.65s/it][Succeeded / Failed / Skipped / Total] 508 / 10 / 8 / 526:  53%|█████▎    | 527/1000 [3:36:10<3:14:01, 24.61s/it][Succeeded / Failed / Skipped / Total] 509 / 10 / 8 / 527:  53%|█████▎    | 527/1000 [3:36:10<3:14:01, 24.61s/it][Succeeded / Failed / Skipped / Total] 509 / 10 / 8 / 527:  53%|█████▎    | 528/1000 [3:36:13<3:13:17, 24.57s/it][Succeeded / Failed / Skipped / Total] 510 / 10 / 8 / 528:  53%|█████▎    | 528/1000 [3:36:13<3:13:17, 24.57s/it][Succeeded / Failed / Skipped / Total] 510 / 10 / 8 / 528:  53%|█████▎    | 529/1000 [3:36:15<3:12:32, 24.53s/it][Succeeded / Failed / Skipped / Total] 511 / 10 / 8 / 529:  53%|█████▎    | 529/1000 [3:36:15<3:12:32, 24.53s/it][Succeeded / Failed / Skipped / Total] 511 / 10 / 8 / 529:  53%|█████▎    | 530/1000 [3:36:18<3:11:49, 24.49s/it][Succeeded / Failed / Skipped / Total] 512 / 10 / 8 / 530:  53%|█████▎    | 530/1000 [3:36:18<3:11:49, 24.49s/it][Succeeded / Failed / Skipped / Total] 512 / 10 / 8 / 530:  53%|█████▎    | 531/1000 [3:36:19<3:11:03, 24.44s/it][Succeeded / Failed / Skipped / Total] 513 / 10 / 8 / 531:  53%|█████▎    | 531/1000 [3:36:19<3:11:03, 24.44s/it][Succeeded / Failed / Skipped / Total] 513 / 10 / 8 / 531:  53%|█████▎    | 532/1000 [3:36:19<3:10:18, 24.40s/it][Succeeded / Failed / Skipped / Total] 513 / 10 / 9 / 532:  53%|█████▎    | 532/1000 [3:36:19<3:10:18, 24.40s/it][Succeeded / Failed / Skipped / Total] 513 / 10 / 9 / 532:  53%|█████▎    | 533/1000 [3:36:28<3:09:39, 24.37s/it]Fill the frames . --> Called when a frame is created . --> Socre: 1.0

[[[[Adv]]]]: private void [[fillFrames]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void [[cf]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 523 ---------------------------------------------
Returns preferred messages for this request . --> This method will be preferred to speak --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader [[request]] ) { play . api . i18n . Messages [[msgs]] = messages . preferred ( [[request]] ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[preferably]] ( Http . RequestHeader [[motions]] ) { play . api . i18n . Messages [[ravine]] = messages . preferred ( [[motions]] ) ; return new MessagesImpl ( new Lang ( [[ravine]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 524 ---------------------------------------------
Set the language in the given result . --> used by Jackson --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result result , Lang [[lang]] ) { return messages . setLang ( result . asScala ( ) , [[lang]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[husker]] ( Result result , Lang [[loong]] ) { return messages . setLang ( result . asScala ( ) , [[loong]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 525 ---------------------------------------------
Sets the bindings for the given modules . --> Return a copy of the given GuiceableModule --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[reliant]] ( GuiceableModule ... [[bundle]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[bundle]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 526 ---------------------------------------------
Define the Guice binding . --> Adds a module to the Guice --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[linked]] ( play . api . inject . Module ... [[modular]] ) { return [[linked]] ( Guiceable . [[modular]] ( [[modular]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 527 ---------------------------------------------
Sets the REQUEST REEF . --> Sets the REQUESTE --> Socre: 1.0

[[[[Adv]]]]: public final Self REPLACEME0 ( play . api . inject . Binding < ? > ... REPLACEME0 ) { return REPLACEME0 ( Guiceable . bindings ( REPLACEME0 ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self REPLACEME0 ( play . api . inject . Binding < ? > ... REPLACEME0 ) { return REPLACEME0 ( Guiceable . bindings ( REPLACEME0 ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 528 ---------------------------------------------
Gets the translation . --> Get translation from brace and arguments --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , List < String > [[keys]] , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[keys]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[procure]] ( play . api . i18n . Lang lang , List < String > [[brace]] , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[brace]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 529 ---------------------------------------------
Specifies the class overrides of the given modules . --> package - private for testing --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[semites]] ( GuiceableModule ... [[packaged]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[packaged]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 530 ---------------------------------------------
Specifies the module overrides . --> Adds Guice to the Guice --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... modules ) { return [[overrides]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[benz]] ( play . api . inject . Module ... modules ) { return [[benz]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 531 ---------------------------------------------
Specifies the Guice binding . --> Create a Chilean --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... bindings ) { return [[overrides]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[chilean]] ( play . api . inject . Binding < ? > ... bindings ) { return [[chilean]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 532 ---------------------------------------------
from interface --> [[[SKIPPED]]]

[[[[Adv]]]]: public CompletionStage < Result > call ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 533 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 514 / 10 / 9 / 533:  53%|█████▎    | 533/1000 [3:36:28<3:09:39, 24.37s/it][Succeeded / Failed / Skipped / Total] 514 / 10 / 9 / 533:  53%|█████▎    | 534/1000 [3:36:30<3:08:56, 24.33s/it][Succeeded / Failed / Skipped / Total] 515 / 10 / 9 / 534:  53%|█████▎    | 534/1000 [3:36:30<3:08:56, 24.33s/it][Succeeded / Failed / Skipped / Total] 515 / 10 / 9 / 534:  54%|█████▎    | 535/1000 [3:36:30<3:08:11, 24.28s/it][Succeeded / Failed / Skipped / Total] 515 / 10 / 10 / 535:  54%|█████▎    | 535/1000 [3:36:30<3:08:11, 24.28s/it][Succeeded / Failed / Skipped / Total] 515 / 10 / 10 / 535:  54%|█████▎    | 536/1000 [3:36:31<3:07:26, 24.24s/it][Succeeded / Failed / Skipped / Total] 515 / 10 / 11 / 536:  54%|█████▎    | 536/1000 [3:36:31<3:07:26, 24.24s/it][Succeeded / Failed / Skipped / Total] 515 / 10 / 11 / 536:  54%|█████▎    | 537/1000 [3:36:48<3:06:55, 24.22s/it][Succeeded / Failed / Skipped / Total] 516 / 10 / 11 / 537:  54%|█████▎    | 537/1000 [3:36:48<3:06:55, 24.22s/it][Succeeded / Failed / Skipped / Total] 516 / 10 / 11 / 537:  54%|█████▍    | 538/1000 [3:36:58<3:06:19, 24.20s/it][Succeeded / Failed / Skipped / Total] 516 / 11 / 11 / 538:  54%|█████▍    | 538/1000 [3:36:58<3:06:19, 24.20s/it][Succeeded / Failed / Skipped / Total] 516 / 11 / 11 / 538:  54%|█████▍    | 539/1000 [3:38:34<3:06:56, 24.33s/it][Succeeded / Failed / Skipped / Total] 517 / 11 / 11 / 539:  54%|█████▍    | 539/1000 [3:38:34<3:06:56, 24.33s/it][Succeeded / Failed / Skipped / Total] 517 / 11 / 11 / 539:  54%|█████▍    | 540/1000 [3:38:40<3:06:16, 24.30s/it][Succeeded / Failed / Skipped / Total] 518 / 11 / 11 / 540:  54%|█████▍    | 540/1000 [3:38:40<3:06:16, 24.30s/it][Succeeded / Failed / Skipped / Total] 518 / 11 / 11 / 540:  54%|█████▍    | 541/1000 [3:38:54<3:05:43, 24.28s/it][Succeeded / Failed / Skipped / Total] 519 / 11 / 11 / 541:  54%|█████▍    | 541/1000 [3:38:54<3:05:43, 24.28s/it][Succeeded / Failed / Skipped / Total] 519 / 11 / 11 / 541:  54%|█████▍    | 542/1000 [3:39:11<3:05:13, 24.26s/it][Succeeded / Failed / Skipped / Total] 520 / 11 / 11 / 542:  54%|█████▍    | 542/1000 [3:39:11<3:05:13, 24.26s/it][Succeeded / Failed / Skipped / Total] 520 / 11 / 11 / 542:  54%|█████▍    | 543/1000 [3:39:46<3:04:57, 24.28s/it][Succeeded / Failed / Skipped / Total] 521 / 11 / 11 / 543:  54%|█████▍    | 543/1000 [3:39:46<3:04:57, 24.28s/it][Succeeded / Failed / Skipped / Total] 521 / 11 / 11 / 543:  54%|█████▍    | 544/1000 [3:40:12<3:04:35, 24.29s/it]Selects the preferred messages . --> Don t do nothing! --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > [[candidates]] ) { Seq < Lang > [[cs]] = Scala . asScala ( [[candidates]] ) ; play . api . i18n . Messages [[msgs]] = messages . preferred ( ( Seq ) [[cs]] ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[electing]] ( Collection < Lang > [[complainant]] ) { Seq < Lang > [[hm]] = Scala . asScala ( [[complainant]] ) ; play . api . i18n . Messages [[balding]] = messages . preferred ( ( Seq ) [[hm]] ) ; return new MessagesImpl ( new Lang ( [[balding]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 534 ---------------------------------------------
Disable module dependencies . --> Disables access to the delegate --> Socre: 1.0

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[disabilities]] ( Class < ? > ... [[anyhow]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[anyhow]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 535 ---------------------------------------------
Static factory method . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static < A , B > Tuple < A , B > Tuple ( A a , B b ) { return new Tuple < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 536 ---------------------------------------------
Factory method . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C c , D d , E e ) { return new Tuple5 < A , B , C , D , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 537 ---------------------------------------------
Convert execution context to Executor --> Execute venez --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[venez]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 538 ---------------------------------------------
Creates a binding for binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 539 ---------------------------------------------
Checks if is defined at the specified language . --> Checks the tambourines --> Socre: 1.0

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang [[lang]] , String [[key]] ) { return messages . isDefinedAt ( [[key]] , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[tambourines]] ( play . api . i18n . Lang [[heavy]] , String [[hinge]] ) { return messages . isDefinedAt ( [[hinge]] , [[heavy]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 540 ---------------------------------------------
Gets an existing file . --> Gusselsselsselsselsselsselsselssels --> Socre: 1.0

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[brussels]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 541 ---------------------------------------------
Create a JPAConfig . --> Alarm Algorithm --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[n1]] , String [[u1]] , String [[n2]] , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[n1]] , [[u1]] ) , new JPAConfig . PersistenceUnit ( [[n2]] , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[al]] ( String [[aaaaa]] , String [[arbiter]] , String [[drifters]] , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[aaaaa]] , [[arbiter]] ) , new JPAConfig . PersistenceUnit ( [[drifters]] , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 542 ---------------------------------------------
Injects a JSON node into a ByteString --> Encode snarl --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[snarl]] ( String [[describe]] ) { return Flow . of ( JsonNode . class ) . map ( [[snarl]] -> { return ByteString . fromString ( Json . stringify ( [[snarl]] ) ) ; } ) . via ( flow ( [[describe]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 543 ---------------------------------------------
Inject string into ByteString --> Package - private for unit tests --> Socre: 1.0

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String [[callbackName]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[pigtails]] ( String [[olet]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[olet]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 544 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 522 / 11 / 11 / 544:  54%|█████▍    | 544/1000 [3:40:12<3:04:35, 24.29s/it][Succeeded / Failed / Skipped / Total] 522 / 11 / 11 / 544:  55%|█████▍    | 545/1000 [3:40:16<3:03:53, 24.25s/it][Succeeded / Failed / Skipped / Total] 523 / 11 / 11 / 545:  55%|█████▍    | 545/1000 [3:40:16<3:03:53, 24.25s/it][Succeeded / Failed / Skipped / Total] 523 / 11 / 11 / 545:  55%|█████▍    | 546/1000 [3:40:47<3:03:35, 24.26s/it][Succeeded / Failed / Skipped / Total] 524 / 11 / 11 / 546:  55%|█████▍    | 546/1000 [3:40:47<3:03:35, 24.26s/it][Succeeded / Failed / Skipped / Total] 524 / 11 / 11 / 546:  55%|█████▍    | 547/1000 [3:40:51<3:02:53, 24.23s/it][Succeeded / Failed / Skipped / Total] 525 / 11 / 11 / 547:  55%|█████▍    | 547/1000 [3:40:51<3:02:53, 24.23s/it][Succeeded / Failed / Skipped / Total] 525 / 11 / 11 / 547:  55%|█████▍    | 548/1000 [3:40:57<3:02:14, 24.19s/it][Succeeded / Failed / Skipped / Total] 526 / 11 / 11 / 548:  55%|█████▍    | 548/1000 [3:40:57<3:02:14, 24.19s/it][Succeeded / Failed / Skipped / Total] 526 / 11 / 11 / 548:  55%|█████▍    | 549/1000 [3:41:06<3:01:38, 24.16s/it][Succeeded / Failed / Skipped / Total] 527 / 11 / 11 / 549:  55%|█████▍    | 549/1000 [3:41:06<3:01:38, 24.16s/it][Succeeded / Failed / Skipped / Total] 527 / 11 / 11 / 549:  55%|█████▌    | 550/1000 [3:41:07<3:00:55, 24.12s/it]Creates a new JAConfig instance from the given map . --> Creates JPAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > [[map]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[persistenceUnits]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[entry]] : [[map]] . entrySet ( ) ) { [[persistenceUnits]] . add ( new JPAConfig . PersistenceUnit ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[persistenceUnits]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[des]] ( Map < String , String > [[paths]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[stockholder]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[scripture]] : [[paths]] . entrySet ( ) ) { [[stockholder]] . add ( new JPAConfig . PersistenceUnit ( [[scripture]] . getKey ( ) , [[scripture]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[stockholder]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 545 ---------------------------------------------
Gets the matching method . --> get timestamps --> Socre: 1.0

[[[[Adv]]]]: public static Method [[getMatchingAccessibleMethod]] ( final Class < ? > [[cls]] , final String [[methodName]] , final Class < ? > ... [[parameterTypes]] ) { try { final Method method = [[cls]] . getMethod ( [[methodName]] , [[parameterTypes]] ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method [[timms]] ( final Class < ? > [[sightsee]] , final String [[nowlin]] , final Class < ? > ... [[elaborate]] ) { try { final Method method = [[sightsee]] . getMethod ( [[nowlin]] , [[elaborate]] ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 546 ---------------------------------------------
Called when an error occurs . --> Implementation of PEPI --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader [[request]] , int statusCode , String [[message]] ) { if ( statusCode == 400 ) { return onBadRequest ( [[request]] , [[message]] ) ; } else if ( statusCode == 403 ) { return onForbidden ( [[request]] , [[message]] ) ; } else if ( statusCode == 404 ) { return onNotFound ( [[request]] , [[message]] ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( [[request]] , statusCode , [[message]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + [[message]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[pepi]] ( RequestHeader [[asks]] , int statusCode , String [[communicating]] ) { if ( statusCode == 400 ) { return onBadRequest ( [[asks]] , [[communicating]] ) ; } else if ( statusCode == 403 ) { return onForbidden ( [[asks]] , [[communicating]] ) ; } else if ( statusCode == 404 ) { return onNotFound ( [[asks]] , [[communicating]] ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( [[asks]] , statusCode , [[communicating]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + [[communicating]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 547 ---------------------------------------------
Handle bad request . --> helper method to react on demand --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onBadRequest]] ( RequestHeader [[request]] , String [[message]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[message]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > [[fertiliser]] ( RequestHeader [[require]] , String [[convey]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[require]] . method ( ) , [[require]] . uri ( ) , [[convey]] , [[require]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 548 ---------------------------------------------
Registers a constraint validator for the given key . --> onstraintValidator --> Socre: 1.0

[[[[Adv]]]]: public < T [[extends]] ConstraintValidator < ? , ? > > [[MappedConstraintValidatorFactory]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T [[pushes]] ConstraintValidator < ? , ? > > [[donít]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 549 ---------------------------------------------
Handle unauthorized action . --> Generate jabs for the jabs room --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader [[request]] , String [[message]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[jabs]] ( RequestHeader [[requisitions]] , String [[mailroom]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[requisitions]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 550 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 528 / 11 / 11 / 550:  55%|█████▌    | 550/1000 [3:41:07<3:00:55, 24.12s/it][Succeeded / Failed / Skipped / Total] 528 / 11 / 11 / 550:  55%|█████▌    | 551/1000 [3:41:09<3:00:12, 24.08s/it][Succeeded / Failed / Skipped / Total] 529 / 11 / 11 / 551:  55%|█████▌    | 551/1000 [3:41:09<3:00:12, 24.08s/it][Succeeded / Failed / Skipped / Total] 529 / 11 / 11 / 551:  55%|█████▌    | 552/1000 [3:41:10<2:59:30, 24.04s/it][Succeeded / Failed / Skipped / Total] 530 / 11 / 11 / 552:  55%|█████▌    | 552/1000 [3:41:10<2:59:30, 24.04s/it][Succeeded / Failed / Skipped / Total] 530 / 11 / 11 / 552:  55%|█████▌    | 553/1000 [3:41:23<2:58:57, 24.02s/it][Succeeded / Failed / Skipped / Total] 531 / 11 / 11 / 553:  55%|█████▌    | 553/1000 [3:41:23<2:58:57, 24.02s/it][Succeeded / Failed / Skipped / Total] 531 / 11 / 11 / 553:  55%|█████▌    | 554/1000 [3:41:31<2:58:20, 23.99s/it][Succeeded / Failed / Skipped / Total] 532 / 11 / 11 / 554:  55%|█████▌    | 554/1000 [3:41:31<2:58:20, 23.99s/it][Succeeded / Failed / Skipped / Total] 532 / 11 / 11 / 554:  56%|█████▌    | 555/1000 [3:41:37<2:57:41, 23.96s/it][Succeeded / Failed / Skipped / Total] 533 / 11 / 11 / 555:  56%|█████▌    | 555/1000 [3:41:37<2:57:41, 23.96s/it][Succeeded / Failed / Skipped / Total] 533 / 11 / 11 / 555:  56%|█████▌    | 556/1000 [3:41:46<2:57:05, 23.93s/it]Handles not found response . --> Display the given request header --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader [[request]] , String [[message]] ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[lahey]] ( RequestHeader [[asked]] , String [[messenger]] ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[asked]] . method ( ) , [[asked]] . uri ( ) , [[asked]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[asked]] . method ( ) , [[asked]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[asked]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 551 ---------------------------------------------
Handles server error . --> The redstein should be redefined --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader request , Throwable [[exception]] ) { try { UsefulException [[usefulException]] = throwableToUsefulException ( [[exception]] ) ; logServerError ( request , [[usefulException]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , [[usefulException]] ) ; default : return onDevServerError ( request , [[usefulException]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[greenstein]] ( RequestHeader request , Throwable [[exemptions]] ) { try { UsefulException [[flamingoes]] = throwableToUsefulException ( [[exemptions]] ) ; logServerError ( request , [[flamingoes]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , [[flamingoes]] ) ; default : return onDevServerError ( request , [[flamingoes]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 552 ---------------------------------------------
Log an error . --> log an error --> Socre: 1.0

[[[[Adv]]]]: protected void logServerError ( RequestHeader request , UsefulException [[usefulException]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[usefulException]] . id , request . method ( ) , request . uri ( ) ) , [[usefulException]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void logServerError ( RequestHeader request , UsefulException [[dwelling]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[dwelling]] . id , request . method ( ) , request . uri ( ) ) , [[dwelling]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 553 ---------------------------------------------
Sends an error to the server . --> Perform telepath execution --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[telepathically]] ( RequestHeader [[praying]] , UsefulException [[waiving]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[waiving]] , [[praying]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 554 ---------------------------------------------
Sends an error . --> This method is used to handle the exemption --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[diorama]] ( RequestHeader [[ask]] , UsefulException [[exemption]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exemption]] , [[ask]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 555 ---------------------------------------------
Creates a BuildDocHandler from the given resources . --> Open booger --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromResources]] ( File [ ] [[files]] , String [ ] baseDirs ) throws IOException { assert ( [[files]] . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ [[files]] . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int [[i]] = 0 ; [[i]] < [[files]] . length ; [[i]] ++ ) { File file = [[files]] [ [[i]] ] ; String [[baseDir]] = baseDirs [ [[i]] ] ; if ( file . isDirectory ( ) ) { repositories [ [[i]] ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler [[booger]] ( File [ ] [[recording]] , String [ ] baseDirs ) throws IOException { assert ( [[recording]] . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ [[recording]] . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int [[it]] = 0 ; [[it]] < [[recording]] . length ; [[it]] ++ ) { File file = [[recording]] [ [[it]] ] ; String [[entertain]] = baseDirs [ [[it]] ] ; if ( file . isDirectory ( ) ) { repositories [ [[it]] ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 556 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 534 / 11 / 11 / 556:  56%|█████▌    | 556/1000 [3:41:46<2:57:05, 23.93s/it][Succeeded / Failed / Skipped / Total] 534 / 11 / 11 / 556:  56%|█████▌    | 557/1000 [3:41:53<2:56:28, 23.90s/it][Succeeded / Failed / Skipped / Total] 535 / 11 / 11 / 557:  56%|█████▌    | 557/1000 [3:41:53<2:56:28, 23.90s/it][Succeeded / Failed / Skipped / Total] 535 / 11 / 11 / 557:  56%|█████▌    | 558/1000 [3:41:57<2:55:49, 23.87s/it][Succeeded / Failed / Skipped / Total] 536 / 11 / 11 / 558:  56%|█████▌    | 558/1000 [3:41:57<2:55:49, 23.87s/it][Succeeded / Failed / Skipped / Total] 536 / 11 / 11 / 558:  56%|█████▌    | 559/1000 [3:42:01<2:55:09, 23.83s/it][Succeeded / Failed / Skipped / Total] 537 / 11 / 11 / 559:  56%|█████▌    | 559/1000 [3:42:01<2:55:09, 23.83s/it][Succeeded / Failed / Skipped / Total] 537 / 11 / 11 / 559:  56%|█████▌    | 560/1000 [3:42:12<2:54:35, 23.81s/it][Succeeded / Failed / Skipped / Total] 538 / 11 / 11 / 560:  56%|█████▌    | 560/1000 [3:42:12<2:54:35, 23.81s/it][Succeeded / Failed / Skipped / Total] 538 / 11 / 11 / 560:  56%|█████▌    | 561/1000 [3:42:27<2:54:04, 23.79s/it][Succeeded / Failed / Skipped / Total] 539 / 11 / 11 / 561:  56%|█████▌    | 561/1000 [3:42:27<2:54:04, 23.79s/it][Succeeded / Failed / Skipped / Total] 539 / 11 / 11 / 561:  56%|█████▌    | 562/1000 [3:42:30<2:53:24, 23.76s/it][Succeeded / Failed / Skipped / Total] 540 / 11 / 11 / 562:  56%|█████▌    | 562/1000 [3:42:30<2:53:24, 23.76s/it][Succeeded / Failed / Skipped / Total] 540 / 11 / 11 / 562:  56%|█████▋    | 563/1000 [3:42:30<2:52:42, 23.71s/it][Succeeded / Failed / Skipped / Total] 541 / 11 / 11 / 563:  56%|█████▋    | 563/1000 [3:42:30<2:52:42, 23.71s/it][Succeeded / Failed / Skipped / Total] 541 / 11 / 11 / 563:  56%|█████▋    | 564/1000 [3:42:36<2:52:05, 23.68s/it][Succeeded / Failed / Skipped / Total] 542 / 11 / 11 / 564:  56%|█████▋    | 564/1000 [3:42:36<2:52:05, 23.68s/it][Succeeded / Failed / Skipped / Total] 542 / 11 / 11 / 564:  56%|█████▋    | 565/1000 [3:42:45<2:51:30, 23.66s/it]Creates a new JPAConfig instance . --> new JPAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[name]] , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[aux]] ( String [[denominations]] , String [[ted]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[denominations]] , [[ted]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 557 ---------------------------------------------
Creates a new BuildDocHandler from a directory and a jar file . --> This method is intended to be used for testing purposes --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File [[directory]] , JarFile [[jarFile]] , String [[base]] ) { return [[fromDirectoryAndJar]] ( [[directory]] , [[jarFile]] , [[base]] , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[upholstery]] ( File [[forefinger]] , JarFile [[missions]] , String [[rudiments]] ) { return [[upholstery]] ( [[forefinger]] , [[missions]] , [[rudiments]] , "[[Fakes]]" != "[[Fakes]]" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 558 ---------------------------------------------
Creates a documentation handler from a directory . --> Special handling for testing --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File [[directory]] ) { FileRepository [[repo]] = new FilesystemRepository ( [[directory]] ) ; return new DocumentationHandler ( [[repo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[reshaping]] ( File [[cataloging]] ) { FileRepository [[bartered]] = new FilesystemRepository ( [[cataloging]] ) ; return new DocumentationHandler ( [[bartered]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 559 ---------------------------------------------
Create a documentation handler from a directory and a jar file . --> package - private for testing --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File [[directory]] , JarFile [[jarFile]] , String base , boolean [[fallbackToJar]] ) { FileRepository fileRepo = new FilesystemRepository ( [[directory]] ) ; FileRepository jarRepo = new JarRepository ( [[jarFile]] , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( [[fallbackToJar]] ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[ymca]] ( File [[stockpiled]] , JarFile [[sarcophagus]] , String base , boolean [[porcupines]] ) { FileRepository fileRepo = new FilesystemRepository ( [[stockpiled]] ) ; FileRepository jarRepo = new JarRepository ( [[sarcophagus]] , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( [[porcupines]] ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 560 ---------------------------------------------
Consumes the given material . --> Completes a surface with a surya --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer [[mat]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[mat]] ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[medicate]] ( Materializer [[surya]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[surya]] ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 561 ---------------------------------------------
Create an HttpEntity from content . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String [[charset]] ) { String body ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[swearin]] ( Content [[cheerful]] , String [[preston]] ) { String body ; if ( [[cheerful]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 562 ---------------------------------------------
Create a documentation handler from a jar file . --> Brodie doc handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String [[base]] ) { FileRepository repo = new JarRepository ( [[jarFile]] , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[brodie]] ( JarFile [[nairn]] , String [[basis]] ) { FileRepository repo = new JarRepository ( [[nairn]] , Option . apply ( [[basis]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 563 ---------------------------------------------
Creates an HttpEntity from a string . --> Deserialize HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String [[content]] , String [[charset]] ) { return new Strict ( ByteString . fromString ( [[content]] , [[charset]] ) , Optional . of ( "text/plain; charset=" + [[charset]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[deserters]] ( String [[happy]] , String [[flavel]] ) { return new Strict ( ByteString . fromString ( [[happy]] , [[flavel]] ) , Optional . of ( "text/plain; charset=" + [[flavel]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 564 ---------------------------------------------
Creates a new Result instance with the given status code and content . --> Creates an Article response --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode content ) { return [[status]] ( [[status]] , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[articles]] ( int status , JsonNode content ) { return [[articles]] ( [[articles]] , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 565 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 543 / 11 / 11 / 565:  56%|█████▋    | 565/1000 [3:42:45<2:51:30, 23.66s/it][Succeeded / Failed / Skipped / Total] 543 / 11 / 11 / 565:  57%|█████▋    | 566/1000 [3:42:47<2:50:50, 23.62s/it][Succeeded / Failed / Skipped / Total] 544 / 11 / 11 / 566:  57%|█████▋    | 566/1000 [3:42:47<2:50:50, 23.62s/it][Succeeded / Failed / Skipped / Total] 544 / 11 / 11 / 566:  57%|█████▋    | 567/1000 [3:42:48<2:50:08, 23.58s/it][Succeeded / Failed / Skipped / Total] 545 / 11 / 11 / 567:  57%|█████▋    | 567/1000 [3:42:48<2:50:08, 23.58s/it][Succeeded / Failed / Skipped / Total] 545 / 11 / 11 / 567:  57%|█████▋    | 568/1000 [3:42:53<2:49:31, 23.54s/it][Succeeded / Failed / Skipped / Total] 546 / 11 / 11 / 568:  57%|█████▋    | 568/1000 [3:42:53<2:49:31, 23.54s/it][Succeeded / Failed / Skipped / Total] 546 / 11 / 11 / 568:  57%|█████▋    | 569/1000 [3:42:53<2:48:50, 23.50s/it][Succeeded / Failed / Skipped / Total] 546 / 11 / 12 / 569:  57%|█████▋    | 569/1000 [3:42:53<2:48:50, 23.50s/it][Succeeded / Failed / Skipped / Total] 546 / 11 / 12 / 569:  57%|█████▋    | 570/1000 [3:42:54<2:48:09, 23.46s/it][Succeeded / Failed / Skipped / Total] 547 / 11 / 12 / 570:  57%|█████▋    | 570/1000 [3:42:54<2:48:09, 23.46s/it][Succeeded / Failed / Skipped / Total] 547 / 11 / 12 / 570:  57%|█████▋    | 571/1000 [3:42:54<2:47:28, 23.42s/it][Succeeded / Failed / Skipped / Total] 548 / 11 / 12 / 571:  57%|█████▋    | 571/1000 [3:42:54<2:47:28, 23.42s/it][Succeeded / Failed / Skipped / Total] 548 / 11 / 12 / 571:  57%|█████▋    | 572/1000 [3:43:15<2:47:03, 23.42s/it][Succeeded / Failed / Skipped / Total] 549 / 11 / 12 / 572:  57%|█████▋    | 572/1000 [3:43:15<2:47:03, 23.42s/it][Succeeded / Failed / Skipped / Total] 549 / 11 / 12 / 572:  57%|█████▋    | 573/1000 [3:43:17<2:46:23, 23.38s/it][Succeeded / Failed / Skipped / Total] 550 / 11 / 12 / 573:  57%|█████▋    | 573/1000 [3:43:17<2:46:23, 23.38s/it][Succeeded / Failed / Skipped / Total] 550 / 11 / 12 / 573:  57%|█████▋    | 574/1000 [3:43:20<2:45:45, 23.35s/it][Succeeded / Failed / Skipped / Total] 551 / 11 / 12 / 574:  57%|█████▋    | 574/1000 [3:43:20<2:45:45, 23.35s/it][Succeeded / Failed / Skipped / Total] 551 / 11 / 12 / 574:  57%|█████▊    | 575/1000 [3:43:23<2:45:06, 23.31s/it][Succeeded / Failed / Skipped / Total] 551 / 12 / 12 / 575:  57%|█████▊    | 575/1000 [3:43:23<2:45:06, 23.31s/it][Succeeded / Failed / Skipped / Total] 551 / 12 / 12 / 575:  58%|█████▊    | 576/1000 [3:43:24<2:44:27, 23.27s/it]Send response with status code . --> Send Lage request --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] , JsonEncoding encoding ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( [[content]] , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[lage]] ( int [[legislation]] , JsonNode [[substance]] , JsonEncoding encoding ) { if ( [[substance]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[lage]] ( [[lage]] ) . sendJson ( [[substance]] , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 566 ---------------------------------------------
Creates a chunked entity . --> Wak an HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > [[data]] , Optional < String > [[contentType]] ) { return new Chunked ( [[data]] . map ( HttpChunk . Chunk :: new ) , [[contentType]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[wak]] ( Source < ByteString , ? > [[statistical]] , Optional < String > [[roshan]] ) { return new Chunked ( [[statistical]] . map ( HttpChunk . Chunk :: new ) , [[roshan]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 567 ---------------------------------------------
Creates a result with a status code . --> This method is used to build status code 200 --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result status ( int [[regulations]] , byte [ ] [[ravi]] ) { if ( [[ravi]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[ravi]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 568 ---------------------------------------------
Converts a throwable to a useful exception . --> else return null --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[cloudy]] ( final Throwable [[henley]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[henley]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 569 ---------------------------------------------
Get user by id --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 570 ---------------------------------------------
Sends an input stream to the response . --> content with status code --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , InputStream content , long [[contentLength]] ) { return status ( status ) . sendInputStream ( content , [[contentLength]] ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result status ( int status , InputStream content , long [[íà]] ) { return status ( status ) . sendInputStream ( content , [[íà]] ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 571 ---------------------------------------------
Returns a result for a file . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , File [[content]] ) { return [[status]] ( [[status]] , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[rule]] ( int [[prerequisite]] , File [[merry]] ) { return [[rule]] ( [[rule]] , [[merry]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 572 ---------------------------------------------
Creates a new call with the given fragment . --> Mapping to naji --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[naji]] ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 573 ---------------------------------------------
Returns the absolute URL for the given request . --> Convenience function --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[wailing]] ( Http . Request [[prayed]] ) { return [[wailing]] ( [[prayed]] . secure ( ) , [[prayed]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 574 ---------------------------------------------
Creates an instance of the given constraint validator class . --> Creates a new instance of the given class --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] [[extends]] ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[zillion]] [[includes]] ConstraintValidator < ? , ? > > [[zillion]] newInstance ( Class < [[zillion]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 575 ---------------------------------------------
Returns a unique call . --> [[[FAILED]]]

[[[[Adv]]]]: public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 576 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 552 / 12 / 12 / 576:  58%|█████▊    | 576/1000 [3:43:24<2:44:27, 23.27s/it][Succeeded / Failed / Skipped / Total] 552 / 12 / 12 / 576:  58%|█████▊    | 577/1000 [3:43:29<2:43:50, 23.24s/it][Succeeded / Failed / Skipped / Total] 553 / 12 / 12 / 577:  58%|█████▊    | 577/1000 [3:43:29<2:43:50, 23.24s/it][Succeeded / Failed / Skipped / Total] 553 / 12 / 12 / 577:  58%|█████▊    | 578/1000 [3:43:33<2:43:13, 23.21s/it][Succeeded / Failed / Skipped / Total] 554 / 12 / 12 / 578:  58%|█████▊    | 578/1000 [3:43:33<2:43:13, 23.21s/it][Succeeded / Failed / Skipped / Total] 554 / 12 / 12 / 578:  58%|█████▊    | 579/1000 [3:43:35<2:42:34, 23.17s/it][Succeeded / Failed / Skipped / Total] 555 / 12 / 12 / 579:  58%|█████▊    | 579/1000 [3:43:35<2:42:34, 23.17s/it][Succeeded / Failed / Skipped / Total] 555 / 12 / 12 / 579:  58%|█████▊    | 580/1000 [3:43:42<2:42:00, 23.14s/it][Succeeded / Failed / Skipped / Total] 556 / 12 / 12 / 580:  58%|█████▊    | 580/1000 [3:43:42<2:42:00, 23.14s/it][Succeeded / Failed / Skipped / Total] 556 / 12 / 12 / 580:  58%|█████▊    | 581/1000 [3:43:53<2:41:27, 23.12s/it][Succeeded / Failed / Skipped / Total] 557 / 12 / 12 / 581:  58%|█████▊    | 581/1000 [3:43:53<2:41:27, 23.12s/it][Succeeded / Failed / Skipped / Total] 557 / 12 / 12 / 581:  58%|█████▊    | 582/1000 [3:44:06<2:40:57, 23.10s/it][Succeeded / Failed / Skipped / Total] 558 / 12 / 12 / 582:  58%|█████▊    | 582/1000 [3:44:06<2:40:57, 23.10s/it][Succeeded / Failed / Skipped / Total] 558 / 12 / 12 / 582:  58%|█████▊    | 583/1000 [3:44:13<2:40:22, 23.08s/it][Succeeded / Failed / Skipped / Total] 559 / 12 / 12 / 583:  58%|█████▊    | 583/1000 [3:44:13<2:40:22, 23.08s/it][Succeeded / Failed / Skipped / Total] 559 / 12 / 12 / 583:  58%|█████▊    | 584/1000 [3:44:17<2:39:46, 23.04s/it]Returns the web socket URL for the given request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request request ) { return [[webSocketURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[interracial]] ( Http . Request request ) { return [[interracial]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 577 ---------------------------------------------
Returns a connection function that executes the given connection runnable . --> Implementation of LSD --> Socre: 1.0

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[connection]] ) { try { [[block]] . run ( [[connection]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[lsd]] ( final ConnectionRunnable [[embargo]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[regard]] ) { try { [[embargo]] . run ( [[regard]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 578 ---------------------------------------------
Creates a new server for the given Router --> Start serving requests --> Socre: 1.0

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[stifling]] ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 579 ---------------------------------------------
Converts a JsonNode to a Java object . --> Creates an instance from JSON . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[of]] > [[of]] fromJson ( JsonNode json , Class < [[of]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 580 ---------------------------------------------
Parses a string into a JsonNode . --> Parse the metallurgy --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode parse ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( String [[metallurgy]] ) { try { return mapper ( ) . readTree ( [[metallurgy]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 581 ---------------------------------------------
Parse input stream . --> Get the fitness from the given input stream --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[fitness]] ( java . io . InputStream [[haas]] ) { try { return mapper ( ) . readTree ( [[haas]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 582 ---------------------------------------------
Returns a connection function that wraps the given connection callable . --> wraps connection callable --> Socre: 1.0

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[block]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return [[block]] . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[impeded]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[matter]] ) { try { return [[impeded]] . call ( [[matter]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 583 ---------------------------------------------
Relative path relative to target path --> arg --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String [[startPath]] , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[involving]] ( String [[ungh]] , String [[submissions]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 584 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 560 / 12 / 12 / 584:  58%|█████▊    | 584/1000 [3:44:17<2:39:46, 23.04s/it][Succeeded / Failed / Skipped / Total] 560 / 12 / 12 / 584:  58%|█████▊    | 585/1000 [3:44:18<2:39:07, 23.01s/it][Succeeded / Failed / Skipped / Total] 561 / 12 / 12 / 585:  58%|█████▊    | 585/1000 [3:44:18<2:39:07, 23.01s/it][Succeeded / Failed / Skipped / Total] 561 / 12 / 12 / 585:  59%|█████▊    | 586/1000 [3:44:28<2:38:35, 22.98s/it][Succeeded / Failed / Skipped / Total] 562 / 12 / 12 / 586:  59%|█████▊    | 586/1000 [3:44:28<2:38:35, 22.98s/it][Succeeded / Failed / Skipped / Total] 562 / 12 / 12 / 586:  59%|█████▊    | 587/1000 [3:44:38<2:38:03, 22.96s/it][Succeeded / Failed / Skipped / Total] 563 / 12 / 12 / 587:  59%|█████▊    | 587/1000 [3:44:38<2:38:03, 22.96s/it][Succeeded / Failed / Skipped / Total] 563 / 12 / 12 / 587:  59%|█████▉    | 588/1000 [3:44:51<2:37:33, 22.94s/it][Succeeded / Failed / Skipped / Total] 564 / 12 / 12 / 588:  59%|█████▉    | 588/1000 [3:44:51<2:37:33, 22.94s/it][Succeeded / Failed / Skipped / Total] 564 / 12 / 12 / 588:  59%|█████▉    | 589/1000 [3:44:58<2:36:59, 22.92s/it][Succeeded / Failed / Skipped / Total] 565 / 12 / 12 / 589:  59%|█████▉    | 589/1000 [3:44:58<2:36:59, 22.92s/it][Succeeded / Failed / Skipped / Total] 565 / 12 / 12 / 589:  59%|█████▉    | 590/1000 [3:45:04<2:36:24, 22.89s/it][Succeeded / Failed / Skipped / Total] 566 / 12 / 12 / 590:  59%|█████▉    | 590/1000 [3:45:04<2:36:24, 22.89s/it][Succeeded / Failed / Skipped / Total] 566 / 12 / 12 / 590:  59%|█████▉    | 591/1000 [3:45:14<2:35:52, 22.87s/it]Returns canonical form . --> splits all files in the HTML --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String [[url]] ) { String [ ] [[urlPath]] = toSegments ( [[url]] ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String [[comp]] : [[urlPath]] ) { if ( [[comp]] . isEmpty ( ) || [[comp]] . equals ( CURRENT_DIR ) ) continue ; if ( ! [[comp]] . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( [[comp]] ) ; else [[canonical]] . pop ( ) ; } String [[prefixSep]] = [[url]] . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = [[url]] . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return [[prefixSep]] + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[slap]] ( String [[html]] ) { String [ ] [[sifted]] = toSegments ( [[html]] ) ; Stack < String > [[slap]] = new Stack <> ( ) ; for ( String [[conf]] : [[sifted]] ) { if ( [[conf]] . isEmpty ( ) || [[conf]] . equals ( CURRENT_DIR ) ) continue ; if ( ! [[conf]] . equals ( PARENT_DIR ) || ( ! [[slap]] . empty ( ) && [[slap]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[slap]] . push ( [[conf]] ) ; else [[slap]] . pop ( ) ; } String [[rhino]] = [[html]] . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = [[html]] . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return [[rhino]] + [[slap]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 585 ---------------------------------------------
Convert an object to json . --> Produce a JSON representation of the given facts --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[thermo]] ( final Object [[facts]] ) { try { return mapper ( ) . valueToTree ( [[facts]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 586 ---------------------------------------------
Returns a tuple of displayable constraints . --> Extracts kilometers from meters --> Socre: 1.0

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > constraint ) { final Display [[displayAnnotation]] = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[displayAnnotation]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[displayAnnotation]] . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[kilometers]] ( ConstraintDescriptor < ? > constraint ) { final Display [[alcazar]] = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[alcazar]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[alcazar]] . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 587 ---------------------------------------------
Returns a list of displayable constraints . --> Fonder for Fonder --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[fonder]] ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[fonder]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 588 ---------------------------------------------
Parses cron expression . --> Converts the given string to date --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[battalions]] ( String [[chantel]] ) { try { return new CronExpression ( [[chantel]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[chantel]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 589 ---------------------------------------------
Selects the preferred language . --> Liefert den Objekt --> Socre: 1.0

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > [[candidates]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[candidates]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[ideally]] ( Collection < Lang > [[depositors]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[depositors]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 590 ---------------------------------------------
Calculates the next interval for a cron expression . --> Returns xFF for a given cron --> Socre: 1.0

[[[[Adv]]]]: public static long [[cronInterval]] ( String cron , Date [[date]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long [[xff]] ( String cron , Date [[orn]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[orn]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 591 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 567 / 12 / 12 / 591:  59%|█████▉    | 591/1000 [3:45:14<2:35:52, 22.87s/it][Succeeded / Failed / Skipped / Total] 567 / 12 / 12 / 591:  59%|█████▉    | 592/1000 [3:45:16<2:35:15, 22.83s/it][Succeeded / Failed / Skipped / Total] 568 / 12 / 12 / 592:  59%|█████▉    | 592/1000 [3:45:16<2:35:15, 22.83s/it][Succeeded / Failed / Skipped / Total] 568 / 12 / 12 / 592:  59%|█████▉    | 593/1000 [3:45:24<2:34:42, 22.81s/it][Succeeded / Failed / Skipped / Total] 569 / 12 / 12 / 593:  59%|█████▉    | 593/1000 [3:45:24<2:34:42, 22.81s/it][Succeeded / Failed / Skipped / Total] 569 / 12 / 12 / 593:  59%|█████▉    | 594/1000 [3:45:28<2:34:06, 22.78s/it][Succeeded / Failed / Skipped / Total] 570 / 12 / 12 / 594:  59%|█████▉    | 594/1000 [3:45:28<2:34:06, 22.78s/it][Succeeded / Failed / Skipped / Total] 570 / 12 / 12 / 594:  60%|█████▉    | 595/1000 [3:45:39<2:33:35, 22.76s/it][Succeeded / Failed / Skipped / Total] 571 / 12 / 12 / 595:  60%|█████▉    | 595/1000 [3:45:39<2:33:35, 22.76s/it][Succeeded / Failed / Skipped / Total] 571 / 12 / 12 / 595:  60%|█████▉    | 596/1000 [3:45:49<2:33:04, 22.73s/it][Succeeded / Failed / Skipped / Total] 572 / 12 / 12 / 596:  60%|█████▉    | 596/1000 [3:45:49<2:33:04, 22.73s/it][Succeeded / Failed / Skipped / Total] 572 / 12 / 12 / 596:  60%|█████▉    | 597/1000 [3:46:00<2:32:33, 22.71s/it][Succeeded / Failed / Skipped / Total] 572 / 13 / 12 / 597:  60%|█████▉    | 597/1000 [3:46:00<2:32:33, 22.71s/it][Succeeded / Failed / Skipped / Total] 572 / 13 / 12 / 597:  60%|█████▉    | 598/1000 [3:46:05<2:31:59, 22.68s/it][Succeeded / Failed / Skipped / Total] 573 / 13 / 12 / 598:  60%|█████▉    | 598/1000 [3:46:05<2:31:59, 22.68s/it][Succeeded / Failed / Skipped / Total] 573 / 13 / 12 / 598:  60%|█████▉    | 599/1000 [3:46:05<2:31:21, 22.65s/it][Succeeded / Failed / Skipped / Total] 574 / 13 / 12 / 599:  60%|█████▉    | 599/1000 [3:46:05<2:31:21, 22.65s/it][Succeeded / Failed / Skipped / Total] 574 / 13 / 12 / 599:  60%|██████    | 600/1000 [3:46:11<2:30:47, 22.62s/it]Checks if two classes are assignable . --> Computes whether or not the given class arrays are sensitive --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] classArray , Class < ? > [ ] [[toClassArray]] , boolean [[autoboxing]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( [[toClassArray]] ) ) { return "[[False]]" != "[[False]]" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( [[toClassArray]] == null ) { [[toClassArray]] = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[isAssignable]] ( classArray [ i ] , [[toClassArray]] [ i ] , [[autoboxing]] ) == "[[False]]" != "[[False]]" ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[scones]] ( Class < ? > [ ] classArray , Class < ? > [ ] [[thermometer]] , boolean [[donna]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( [[thermometer]] ) ) { return "[[Forgery]]" != "[[Forgery]]" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( [[thermometer]] == null ) { [[thermometer]] = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[scones]] ( classArray [ i ] , [[thermometer]] [ i ] , [[donna]] ) == "[[Forgery]]" != "[[Forgery]]" ) { return "[[Forgery]]" != "[[Forgery]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 592 ---------------------------------------------
Gets the todo . --> Determines the EDA --> Socre: 1.0

[[[[Adv]]]]: public static Result [[TODO]] ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result [[ESTA]] ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 593 ---------------------------------------------
Sets the timeout for the given amount of time . --> seconds to nanoseconds --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > [[stage]] , final long amount , final TimeUnit unit ) { requireNonNull ( [[stage]] , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> [[stage]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[nanosecond]] ( final CompletionStage < A > [[span]] , final long amount , final TimeUnit unit ) { requireNonNull ( [[span]] , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration [[timetables]] = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( [[timetables]] , Scala . asScalaWithFuture ( ( ) -> [[span]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 594 ---------------------------------------------
Flash to flash --> Define an elevation description --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String [[key]] , String [[value]] ) { [[flash]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[zippy]] ( String [[elementary]] , String [[assessments]] ) { [[zippy]] ( ) . put ( [[elementary]] , [[assessments]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 595 ---------------------------------------------
Store a value in session --> Store an assemblies map --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String key , String value ) { [[session]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[assemblies]] ( String key , String value ) { [[assemblies]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 596 ---------------------------------------------
Creates a stand - alone client . --> create aahcClient --> Socre: 1.0

[[[[Adv]]]]: public static AhcWSClient [[create]] ( AhcWSClientConfig [[config]] , AhcHttpCache [[cache]] , Materializer materializer ) { final StandaloneAhcWSClient [[client]] = StandaloneAhcWSClient . create ( [[config]] , [[cache]] , materializer ) ; return new AhcWSClient ( [[client]] , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient [[generated]] ( AhcWSClientConfig [[ansel]] , AhcHttpCache [[hid]] , Materializer materializer ) { final StandaloneAhcWSClient [[user]] = StandaloneAhcWSClient . create ( [[ansel]] , [[hid]] , materializer ) ; return new AhcWSClient ( [[user]] , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 597 ---------------------------------------------
Returns a binding key with the specified instance . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 598 ---------------------------------------------
Converts this binding to a Java binding . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[le]] ( final Provider < ? extends T > [[seller]] ) { return underlying . to ( [[seller]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 599 ---------------------------------------------
Converts this binding to a Java binding . --> Convenience method for casting --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[by]] ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 600 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 574 / 14 / 12 / 600:  60%|██████    | 600/1000 [3:46:11<2:30:47, 22.62s/it][Succeeded / Failed / Skipped / Total] 574 / 14 / 12 / 600:  60%|██████    | 601/1000 [3:46:17<2:30:13, 22.59s/it][Succeeded / Failed / Skipped / Total] 575 / 14 / 12 / 601:  60%|██████    | 601/1000 [3:46:17<2:30:13, 22.59s/it][Succeeded / Failed / Skipped / Total] 575 / 14 / 12 / 601:  60%|██████    | 602/1000 [3:46:24<2:29:41, 22.57s/it][Succeeded / Failed / Skipped / Total] 576 / 14 / 12 / 602:  60%|██████    | 602/1000 [3:46:24<2:29:41, 22.57s/it][Succeeded / Failed / Skipped / Total] 576 / 14 / 12 / 602:  60%|██████    | 603/1000 [3:46:24<2:29:03, 22.53s/it][Succeeded / Failed / Skipped / Total] 577 / 14 / 12 / 603:  60%|██████    | 603/1000 [3:46:24<2:29:03, 22.53s/it][Succeeded / Failed / Skipped / Total] 577 / 14 / 12 / 603:  60%|██████    | 604/1000 [3:46:28<2:28:28, 22.50s/it][Succeeded / Failed / Skipped / Total] 578 / 14 / 12 / 604:  60%|██████    | 604/1000 [3:46:28<2:28:28, 22.50s/it][Succeeded / Failed / Skipped / Total] 578 / 14 / 12 / 604:  60%|██████    | 605/1000 [3:46:35<2:27:56, 22.47s/it][Succeeded / Failed / Skipped / Total] 579 / 14 / 12 / 605:  60%|██████    | 605/1000 [3:46:35<2:27:56, 22.47s/it][Succeeded / Failed / Skipped / Total] 579 / 14 / 12 / 605:  61%|██████    | 606/1000 [3:46:36<2:27:19, 22.44s/it][Succeeded / Failed / Skipped / Total] 579 / 15 / 12 / 606:  61%|██████    | 606/1000 [3:46:36<2:27:19, 22.44s/it][Succeeded / Failed / Skipped / Total] 579 / 15 / 12 / 606:  61%|██████    | 607/1000 [3:46:52<2:26:53, 22.43s/it][Succeeded / Failed / Skipped / Total] 580 / 15 / 12 / 607:  61%|██████    | 607/1000 [3:46:52<2:26:53, 22.43s/it][Succeeded / Failed / Skipped / Total] 580 / 15 / 12 / 607:  61%|██████    | 608/1000 [3:46:53<2:26:17, 22.39s/it][Succeeded / Failed / Skipped / Total] 581 / 15 / 12 / 608:  61%|██████    | 608/1000 [3:46:53<2:26:17, 22.39s/it][Succeeded / Failed / Skipped / Total] 581 / 15 / 12 / 608:  61%|██████    | 609/1000 [3:47:07<2:25:49, 22.38s/it][Succeeded / Failed / Skipped / Total] 582 / 15 / 12 / 609:  61%|██████    | 609/1000 [3:47:07<2:25:49, 22.38s/it][Succeeded / Failed / Skipped / Total] 582 / 15 / 12 / 609:  61%|██████    | 610/1000 [3:47:28<2:25:25, 22.37s/it]Returns a binding key for the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 601 ---------------------------------------------
Convert this binding to a Java type . --> Convenience wrapper for SwiveL --> Socre: 1.0

[[[[Adv]]]]: public < P [[extends]] Provider < ? extends T > > Binding < T > [[toProvider]] ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P [[enlarged]] Provider < ? extends T > > Binding < T > [[swivel]] ( final Class < P > [[buyers]] ) { return underlying . toProvider ( [[buyers]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 602 ---------------------------------------------
Returns a list of available languages . --> Return a list of Langs --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[availableLangs]] = Scala . asJava ( langs . availables ( ) ) ; return [[availableLangs]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[hairdressing]] ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[awaywith]] = Scala . asJava ( langs . availables ( ) ) ; return [[awaywith]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 603 ---------------------------------------------
Converts a binding key to a given key . --> Overrides a new BindingKey --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[circa]] ( final BindingKey < ? extends T > [[hinge]] ) { return underlying . to ( [[hinge]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 604 ---------------------------------------------
Creates a reader from a map of Evolutions . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[batallion]] . EvolutionsReader [[petard]] ( Map < String , List < Evolution > > [[batallion]] ) { return new SimpleEvolutionsReader ( [[batallion]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 605 ---------------------------------------------
Gets the evolution reader . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[forDefault]] ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[transporting]] . EvolutionsReader [[impede]] ( Evolution ... [[transporting]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[transporting]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 606 ---------------------------------------------
Converts this binding to a Java Binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 607 ---------------------------------------------
Resolves all executions of a database . --> Simplified version of hagiwar --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database [[database]] , boolean [[autocommit]] , String schema ) { DatabaseEvolutions [[evolutions]] = new DatabaseEvolutions ( [[database]] . asScala ( ) , schema ) ; [[evolutions]] . evolve ( [[evolutions]] . resetScripts ( ) , [[autocommit]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[hagiwara]] ( Database [[nuclei]] , boolean [[dotes]] , String schema ) { DatabaseEvolutions [[versa]] = new DatabaseEvolutions ( [[nuclei]] . asScala ( ) , schema ) ; [[versa]] . evolve ( [[versa]] . resetScripts ( ) , [[dotes]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 608 ---------------------------------------------
Load config loader --> Load klingon on environment --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[klingon]] ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 609 ---------------------------------------------
Configures the given modules . --> Loads a set of recipes --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[instructs]] ( GuiceableModule ... [[brushes]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[brushes]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 610 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 583 / 15 / 12 / 610:  61%|██████    | 610/1000 [3:47:28<2:25:25, 22.37s/it][Succeeded / Failed / Skipped / Total] 583 / 15 / 12 / 610:  61%|██████    | 611/1000 [3:47:35<2:24:53, 22.35s/it][Succeeded / Failed / Skipped / Total] 584 / 15 / 12 / 611:  61%|██████    | 611/1000 [3:47:35<2:24:53, 22.35s/it][Succeeded / Failed / Skipped / Total] 584 / 15 / 12 / 611:  61%|██████    | 612/1000 [3:47:35<2:24:17, 22.31s/it][Succeeded / Failed / Skipped / Total] 585 / 15 / 12 / 612:  61%|██████    | 612/1000 [3:47:35<2:24:17, 22.31s/it][Succeeded / Failed / Skipped / Total] 585 / 15 / 12 / 612:  61%|██████▏   | 613/1000 [3:47:43<2:23:46, 22.29s/it][Succeeded / Failed / Skipped / Total] 586 / 15 / 12 / 613:  61%|██████▏   | 613/1000 [3:47:43<2:23:46, 22.29s/it][Succeeded / Failed / Skipped / Total] 586 / 15 / 12 / 613:  61%|██████▏   | 614/1000 [3:47:47<2:23:12, 22.26s/it][Succeeded / Failed / Skipped / Total] 587 / 15 / 12 / 614:  61%|██████▏   | 614/1000 [3:47:47<2:23:12, 22.26s/it][Succeeded / Failed / Skipped / Total] 587 / 15 / 12 / 614:  62%|██████▏   | 615/1000 [3:47:57<2:22:42, 22.24s/it][Succeeded / Failed / Skipped / Total] 588 / 15 / 12 / 615:  62%|██████▏   | 615/1000 [3:47:57<2:22:42, 22.24s/it][Succeeded / Failed / Skipped / Total] 588 / 15 / 12 / 615:  62%|██████▏   | 616/1000 [3:48:02<2:22:09, 22.21s/it][Succeeded / Failed / Skipped / Total] 589 / 15 / 12 / 616:  62%|██████▏   | 616/1000 [3:48:02<2:22:09, 22.21s/it][Succeeded / Failed / Skipped / Total] 589 / 15 / 12 / 616:  62%|██████▏   | 617/1000 [3:48:02<2:21:33, 22.18s/it][Succeeded / Failed / Skipped / Total] 590 / 15 / 12 / 617:  62%|██████▏   | 617/1000 [3:48:02<2:21:33, 22.18s/it][Succeeded / Failed / Skipped / Total] 590 / 15 / 12 / 617:  62%|██████▏   | 618/1000 [3:48:06<2:21:00, 22.15s/it]Returns the preferred language for the given application . --> Create a favours from a list of languages --> Socre: 1.0

[[[[Adv]]]]: public static Lang [[preferred]] ( Application app , List < Lang > [[availableLangs]] ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = [[availableLangs]] . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang [[favours]] ( Application app , List < Lang > [[deferred]] ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = [[deferred]] . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 611 ---------------------------------------------
Loads the given modules . --> Loads all blacklisted words --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... [[modules]] ) { return load ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... [[swords]] ) { return load ( Guiceable . [[swords]] ( [[swords]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 612 ---------------------------------------------
Loads the given modules . --> throws UnsafeableException --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[burdening]] ( play . api . inject . Module ... [[unit]] ) { return [[burdening]] ( Guiceable . [[unit]] ( [[unit]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 613 ---------------------------------------------
Load the Guice application with the given bindings . --> Boilerplate for landing --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[load]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[boarding]] ( play . api . inject . Binding < ? > ... [[binder]] ) { return [[boarding]] ( Guiceable . [[binder]] ( [[binder]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 614 ---------------------------------------------
Create a new Guice application builder . --> Create a GuiceApplicationBuilder --> Socre: 1.0

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder [[builder]] ) { return new GuiceApplicationBuilder ( [[builder]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[downhill]] ( play . api . inject . guice . GuiceApplicationBuilder [[stylist]] ) { return new GuiceApplicationBuilder ( [[stylist]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 615 ---------------------------------------------
Gets the EntityManager associated with the current thread . --> Enqueue entity manager --> Socre: 1.0

[[[[Adv]]]]: public EntityManager [[em]] ( ) { Deque < EntityManager > ems = this . emStack ( "[[True]]" == "[[True]]" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager [[en]] ( ) { Deque < EntityManager > ems = this . emStack ( "[[Dignified]]" == "[[Dignified]]" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 616 ---------------------------------------------
Loads a module from the application . --> Load a Guice application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[xiao]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 617 ---------------------------------------------
Encode the cookie . --> convert cookies to mime --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[buf]] = new StringBuilder ( ) ; [[encode]] ( [[buf]] , [[cookie]] ) ; return stripTrailingSeparator ( [[buf]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[mime]] ( Cookie [[cookies]] ) { if ( [[cookies]] == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[maître]] = new StringBuilder ( ) ; [[mime]] ( [[maître]] , [[cookies]] ) ; return stripTrailingSeparator ( [[maître]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 618 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 591 / 15 / 12 / 618:  62%|██████▏   | 618/1000 [3:48:06<2:21:00, 22.15s/it][Succeeded / Failed / Skipped / Total] 591 / 15 / 12 / 618:  62%|██████▏   | 619/1000 [3:48:24<2:20:35, 22.14s/it][Succeeded / Failed / Skipped / Total] 592 / 15 / 12 / 619:  62%|██████▏   | 619/1000 [3:48:24<2:20:35, 22.14s/it][Succeeded / Failed / Skipped / Total] 592 / 15 / 12 / 619:  62%|██████▏   | 620/1000 [3:48:24<2:19:59, 22.10s/it][Succeeded / Failed / Skipped / Total] 593 / 15 / 12 / 620:  62%|██████▏   | 620/1000 [3:48:24<2:19:59, 22.10s/it][Succeeded / Failed / Skipped / Total] 593 / 15 / 12 / 620:  62%|██████▏   | 621/1000 [3:48:30<2:19:27, 22.08s/it][Succeeded / Failed / Skipped / Total] 594 / 15 / 12 / 621:  62%|██████▏   | 621/1000 [3:48:30<2:19:27, 22.08s/it][Succeeded / Failed / Skipped / Total] 594 / 15 / 12 / 621:  62%|██████▏   | 622/1000 [3:49:00<2:19:10, 22.09s/it][Succeeded / Failed / Skipped / Total] 595 / 15 / 12 / 622:  62%|██████▏   | 622/1000 [3:49:00<2:19:10, 22.09s/it][Succeeded / Failed / Skipped / Total] 595 / 15 / 12 / 622:  62%|██████▏   | 623/1000 [3:49:15<2:18:43, 22.08s/it][Succeeded / Failed / Skipped / Total] 596 / 15 / 12 / 623:  62%|██████▏   | 623/1000 [3:49:15<2:18:43, 22.08s/it][Succeeded / Failed / Skipped / Total] 596 / 15 / 12 / 623:  62%|██████▏   | 624/1000 [3:49:19<2:18:11, 22.05s/it][Succeeded / Failed / Skipped / Total] 597 / 15 / 12 / 624:  62%|██████▏   | 624/1000 [3:49:19<2:18:11, 22.05s/it][Succeeded / Failed / Skipped / Total] 597 / 15 / 12 / 624:  62%|██████▎   | 625/1000 [3:49:24<2:17:38, 22.02s/it]Pushes an entity manager to the stack . --> Pop a snippet --> Socre: 1.0

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager [[em]] , boolean [[threadLocalFallback]] ) { Deque < EntityManager > [[ems]] = this . emStack ( [[threadLocalFallback]] ) ; if ( [[em]] != null ) { [[ems]] . push ( [[em]] ) ; } else { if ( [[ems]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[ems]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[tippet]] ( EntityManager [[entre]] , boolean [[karr]] ) { Deque < EntityManager > [[mel]] = this . emStack ( [[karr]] ) ; if ( [[entre]] != null ) { [[mel]] . push ( [[entre]] ) ; } else { if ( [[mel]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[mel]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 619 ---------------------------------------------
Disallow a flow in the graph . --> package - private for testing --> Socre: 1.0

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > [[bypassWith]] ( Flow < In , F . Either < FlowIn , Out > , ? > [[splitter]] , Graph < UniformFanInShape < Out , Out > , ? > [[mergeStrategy]] , Flow < FlowIn , Out , ? > [[flow]] ) { return [[splitter]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > [[majid]] ( Flow < In , F . Either < FlowIn , Out > , ? > [[shifter]] , Graph < UniformFanInShape < Out , Out > , ? > [[sadako]] , Flow < FlowIn , Out , ? > [[flowing]] ) { return [[shifter]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 620 ---------------------------------------------
Displays a flow using a splitter . --> Mock a tile into a tile --> Socre: 1.0

[[[[Adv]]]]: public static < In , [[FlowIn]] , Out > Flow < In , Out , ? > [[bypassWith]] ( Function < In , F . Either < [[FlowIn]] , Out > > [[splitter]] , Flow < [[FlowIn]] , Out , ? > [[flow]] ) { return [[bypassWith]] ( Flow . < In > create ( ) . map ( [[splitter]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[flow]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < In , [[kickin]] , Out > Flow < In , Out , ? > [[mobbed]] ( Function < In , F . Either < [[kickin]] , Out > > [[tile]] , Flow < [[kickin]] , Out , ? > [[streaming]] ) { return [[mobbed]] ( Flow . < In > create ( ) . map ( [[tile]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[streaming]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 621 ---------------------------------------------
Converts default message arguments to default message source . --> but we don t do anything --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[banton]] ( Object [ ] [[disputes]] ) { if ( [[disputes]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[disputes]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 622 ---------------------------------------------
Inject a flow into a flow . --> flows from actorRef --> Socre: 1.0

[[[[Adv]]]]: public static < In , [[Out]] > Flow < In , [[Out]] , ? > actorRef ( Function < ActorRef , Props > [[props]] , int bufferSize , OverflowStrategy [[overflowStrategy]] , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , [[Out]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return [[props]] . apply ( v1 ) ; } } , bufferSize , [[overflowStrategy]] , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , [[Else]] > Flow < In , [[Else]] , ? > actorRef ( Function < ActorRef , Props > [[accidental]] , int bufferSize , OverflowStrategy [[riverbed]] , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , [[Else]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return [[accidental]] . apply ( v1 ) ; } } , bufferSize , [[riverbed]] , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 623 ---------------------------------------------
Returns the global errors . --> HHHHH is not empty --> Socre: 1.0

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[hh]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 624 ---------------------------------------------
Configures the Guice application with the given context . --> Called by Spring Boot application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context [[context]] ) { return initialBuilder . in ( [[context]] . environment ( ) ) . loadConfig ( [[context]] . initialConfig ( ) ) . overrides ( overrides ( [[context]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[manufactured]] ( ApplicationLoader . Context [[marco]] ) { return initialBuilder . in ( [[marco]] . environment ( ) ) . loadConfig ( [[marco]] . initialConfig ( ) ) . overrides ( overrides ( [[marco]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 625 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 598 / 15 / 12 / 625:  62%|██████▎   | 625/1000 [3:49:24<2:17:38, 22.02s/it][Succeeded / Failed / Skipped / Total] 598 / 15 / 12 / 625:  63%|██████▎   | 626/1000 [3:49:25<2:17:04, 21.99s/it][Succeeded / Failed / Skipped / Total] 599 / 15 / 12 / 626:  63%|██████▎   | 626/1000 [3:49:25<2:17:04, 21.99s/it][Succeeded / Failed / Skipped / Total] 599 / 15 / 12 / 626:  63%|██████▎   | 627/1000 [3:49:31<2:16:32, 21.96s/it][Succeeded / Failed / Skipped / Total] 600 / 15 / 12 / 627:  63%|██████▎   | 627/1000 [3:49:31<2:16:32, 21.96s/it][Succeeded / Failed / Skipped / Total] 600 / 15 / 12 / 627:  63%|██████▎   | 628/1000 [3:49:31<2:15:57, 21.93s/it][Succeeded / Failed / Skipped / Total] 600 / 15 / 13 / 628:  63%|██████▎   | 628/1000 [3:49:31<2:15:57, 21.93s/it][Succeeded / Failed / Skipped / Total] 600 / 15 / 13 / 628:  63%|██████▎   | 629/1000 [3:49:32<2:15:23, 21.90s/it][Succeeded / Failed / Skipped / Total] 601 / 15 / 13 / 629:  63%|██████▎   | 629/1000 [3:49:32<2:15:23, 21.90s/it][Succeeded / Failed / Skipped / Total] 601 / 15 / 13 / 629:  63%|██████▎   | 630/1000 [3:49:33<2:14:49, 21.86s/it][Succeeded / Failed / Skipped / Total] 602 / 15 / 13 / 630:  63%|██████▎   | 630/1000 [3:49:33<2:14:49, 21.86s/it][Succeeded / Failed / Skipped / Total] 602 / 15 / 13 / 630:  63%|██████▎   | 631/1000 [3:49:46<2:14:22, 21.85s/it][Succeeded / Failed / Skipped / Total] 603 / 15 / 13 / 631:  63%|██████▎   | 631/1000 [3:49:46<2:14:22, 21.85s/it][Succeeded / Failed / Skipped / Total] 603 / 15 / 13 / 631:  63%|██████▎   | 632/1000 [3:49:51<2:13:50, 21.82s/it][Succeeded / Failed / Skipped / Total] 604 / 15 / 13 / 632:  63%|██████▎   | 632/1000 [3:49:51<2:13:50, 21.82s/it][Succeeded / Failed / Skipped / Total] 604 / 15 / 13 / 632:  63%|██████▎   | 633/1000 [3:50:02<2:13:22, 21.80s/it]Gets the current entity manager stack . --> Switches to current entity manager --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean [[threadLocalFallback]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[emsObject]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[emsObject]] != null ) { return ( Deque < EntityManager > ) [[emsObject]] ; } else { Deque < EntityManager > [[ems]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[ems]] ) ; return [[ems]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[naka]] ( boolean [[choosy]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[moti]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[moti]] != null ) { return ( Deque < EntityManager > ) [[moti]] ; } else { Deque < EntityManager > [[ecm]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[ecm]] ) ; return [[ecm]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 626 ---------------------------------------------
Returns the value for the given key . --> Convenience method to return a non - null element that is not present . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[precious]] ( String [[elemental]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[elemental]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 627 ---------------------------------------------
Get the JSON representation of this error as JSON . --> Build divination --> Socre: 1.0

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang [[lang]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && [[lang]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( [[lang]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[lang]] ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[divination]] ( Lang [[heavy]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && [[heavy]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( [[heavy]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[heavy]] ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 628 ---------------------------------------------
Converts the given text into the given type . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T parse ( Field field , String text ) { return ( T ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 629 ---------------------------------------------
Print object . --> Print a given object --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Fetters]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Fetters]] . class ) ) { return conversion . convert ( t , [[Fetters]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 630 ---------------------------------------------
Fills this form with the given value . --> used in unit tests --> Socre: 1.0

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > value ) { Form < Dynamic > [[form]] = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( [[form]] . rawData ( ) , [[form]] . files ( ) , [[form]] . errors ( ) , [[form]] . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[puente]] ( Map < String , Object > value ) { Form < Dynamic > [[forme]] = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( [[forme]] . rawData ( ) , [[forme]] . files ( ) , [[forme]] . errors ( ) , [[forme]] . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 631 ---------------------------------------------
Parse given text to given class --> Parse a text to a somme --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[somme]] > [[somme]] parse ( String text , Class < [[somme]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 632 ---------------------------------------------
Register converter . --> Mamita conversion --> Socre: 1.0

[[[[Adv]]]]: private Formatters [[registerOptional]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object [[source]] , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters [[mamita]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object [[ancestral]] , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 633 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 604 / 16 / 13 / 633:  63%|██████▎   | 633/1000 [3:50:02<2:13:22, 21.80s/it][Succeeded / Failed / Skipped / Total] 604 / 16 / 13 / 633:  63%|██████▎   | 634/1000 [3:50:04<2:12:49, 21.77s/it][Succeeded / Failed / Skipped / Total] 604 / 17 / 13 / 634:  63%|██████▎   | 634/1000 [3:50:04<2:12:49, 21.77s/it][Succeeded / Failed / Skipped / Total] 604 / 17 / 13 / 634:  64%|██████▎   | 635/1000 [3:50:26<2:12:27, 21.77s/it][Succeeded / Failed / Skipped / Total] 605 / 17 / 13 / 635:  64%|██████▎   | 635/1000 [3:50:26<2:12:27, 21.77s/it][Succeeded / Failed / Skipped / Total] 605 / 17 / 13 / 635:  64%|██████▎   | 636/1000 [3:50:31<2:11:56, 21.75s/it][Succeeded / Failed / Skipped / Total] 606 / 17 / 13 / 636:  64%|██████▎   | 636/1000 [3:50:31<2:11:56, 21.75s/it][Succeeded / Failed / Skipped / Total] 606 / 17 / 13 / 636:  64%|██████▎   | 637/1000 [3:54:23<2:13:34, 22.08s/it]Print a value . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 634 ---------------------------------------------
Returns a representation of a field . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 635 ---------------------------------------------
Register a converter . --> Called by javadoc --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Annotation]] , T > [[Formatters]] register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Annotation]] > annotationType = ( Class < ? extends [[Annotation]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Facilitated]] , T > [[Cachaça]] register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Facilitated]] > annotationType = ( Class < ? extends [[Facilitated]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 636 ---------------------------------------------
Returns a list of nodes that match the specified node . --> Create a node list from the given path --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object [[node]] ) { return [[selectNodes]] ( path , [[node]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[eun]] ( String path , Object [[tying]] ) { return [[eun]] ( path , [[tying]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 637 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 607 / 17 / 13 / 637:  64%|██████▎   | 637/1000 [3:54:23<2:13:34, 22.08s/it][Succeeded / Failed / Skipped / Total] 607 / 17 / 13 / 637:  64%|██████▍   | 638/1000 [3:55:32<2:13:38, 22.15s/it][Succeeded / Failed / Skipped / Total] 608 / 17 / 13 / 638:  64%|██████▍   | 638/1000 [3:55:32<2:13:38, 22.15s/it][Succeeded / Failed / Skipped / Total] 608 / 17 / 13 / 638:  64%|██████▍   | 639/1000 [3:55:45<2:13:11, 22.14s/it][Succeeded / Failed / Skipped / Total] 609 / 17 / 13 / 639:  64%|██████▍   | 639/1000 [3:55:45<2:13:11, 22.14s/it][Succeeded / Failed / Skipped / Total] 609 / 17 / 13 / 639:  64%|██████▍   | 640/1000 [3:55:45<2:12:36, 22.10s/it][Succeeded / Failed / Skipped / Total] 609 / 17 / 14 / 640:  64%|██████▍   | 640/1000 [3:55:45<2:12:36, 22.10s/it][Succeeded / Failed / Skipped / Total] 609 / 17 / 14 / 640:  64%|██████▍   | 641/1000 [3:55:46<2:12:02, 22.07s/it][Succeeded / Failed / Skipped / Total] 609 / 17 / 15 / 641:  64%|██████▍   | 641/1000 [3:55:46<2:12:02, 22.07s/it][Succeeded / Failed / Skipped / Total] 609 / 17 / 15 / 641:  64%|██████▍   | 642/1000 [3:55:54<2:11:33, 22.05s/it][Succeeded / Failed / Skipped / Total] 610 / 17 / 15 / 642:  64%|██████▍   | 642/1000 [3:55:54<2:11:33, 22.05s/it][Succeeded / Failed / Skipped / Total] 610 / 17 / 15 / 642:  64%|██████▍   | 643/1000 [3:56:01<2:11:02, 22.02s/it][Succeeded / Failed / Skipped / Total] 611 / 17 / 15 / 643:  64%|██████▍   | 643/1000 [3:56:01<2:11:02, 22.02s/it][Succeeded / Failed / Skipped / Total] 611 / 17 / 15 / 643:  64%|██████▍   | 644/1000 [3:56:17<2:10:37, 22.02s/it][Succeeded / Failed / Skipped / Total] 612 / 17 / 15 / 644:  64%|██████▍   | 644/1000 [3:56:17<2:10:37, 22.02s/it][Succeeded / Failed / Skipped / Total] 612 / 17 / 15 / 644:  64%|██████▍   | 645/1000 [3:58:11<2:11:05, 22.16s/it]Registers a formatter for a particular class . --> used by springframework --> Socre: 1.0

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[text]] , Locale [[locale]] ) throws java . [[text]] . ParseException { return formatter . parse ( [[text]] , [[locale]] ) ; } public String print ( T t , Locale [[locale]] ) { return formatter . print ( t , [[locale]] ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[Liberace]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[writings]] , Locale [[arrondissement]] ) throws java . [[writings]] . ParseException { return formatter . parse ( [[writings]] , [[arrondissement]] ) ; } public String print ( T t , Locale [[arrondissement]] ) { return formatter . print ( t , [[arrondissement]] ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 638 ---------------------------------------------
Convert an array into a Seq . --> Convenience method for casting --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( T [ ] [[array]] ) { return toSeq ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( T [ ] [[cab]] ) { return toSeq ( java . util . Arrays . asList ( [[cab]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 639 ---------------------------------------------
Converts an array into a sequence . --> Convenience method for convexception --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[parrot]] ( T ... [[cab]] ) { return toSeq ( [[cab]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 640 ---------------------------------------------
JacksonAcceptor --> [[[SKIPPED]]]

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 641 ---------------------------------------------
Accepts a WebSocket --> [[[SKIPPED]]]

[[[[Adv]]]]: private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 642 ---------------------------------------------
Sets the visibility of an accessible object . --> Determines if an object is a vera --> Socre: 1.0

[[[[Adv]]]]: static boolean [[setAccessibleWorkaround]] ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[True]]" == "[[True]]" ) ; return "[[True]]" == "[[True]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean [[yasuda]] ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[Vera]]" == "[[Vera]]" ) ; return "[[Vera]]" == "[[Vera]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 643 ---------------------------------------------
Get the cost between two classes . --> Get oporto --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > [[srcClass]] , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = [[srcClass]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[oporto]] ( final Class < ? > [[couric]] , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = [[couric]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 644 ---------------------------------------------
Get the total transformation cost . --> Methode permutation --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable [[executable]] ) { final Class < ? > [ ] [[destArgs]] = [[executable]] . getParameterTypes ( ) ; final boolean [[isVarArgs]] = [[executable]] . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[mutant]] ( final Class < ? > [ ] srcArgs , final Executable [[slowing]] ) { final Class < ? > [ ] [[herbicide]] = [[slowing]] . getParameterTypes ( ) ; final boolean [[recovered]] = [[slowing]] . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 645 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 613 / 17 / 15 / 645:  64%|██████▍   | 645/1000 [3:58:11<2:11:05, 22.16s/it][Succeeded / Failed / Skipped / Total] 613 / 17 / 15 / 645:  65%|██████▍   | 646/1000 [3:58:21<2:10:37, 22.14s/it][Succeeded / Failed / Skipped / Total] 614 / 17 / 15 / 646:  65%|██████▍   | 646/1000 [3:58:21<2:10:37, 22.14s/it][Succeeded / Failed / Skipped / Total] 614 / 17 / 15 / 646:  65%|██████▍   | 647/1000 [3:58:24<2:10:04, 22.11s/it][Succeeded / Failed / Skipped / Total] 615 / 17 / 15 / 647:  65%|██████▍   | 647/1000 [3:58:24<2:10:04, 22.11s/it][Succeeded / Failed / Skipped / Total] 615 / 17 / 15 / 647:  65%|██████▍   | 648/1000 [3:58:28<2:09:32, 22.08s/it][Succeeded / Failed / Skipped / Total] 616 / 17 / 15 / 648:  65%|██████▍   | 648/1000 [3:58:28<2:09:32, 22.08s/it][Succeeded / Failed / Skipped / Total] 616 / 17 / 15 / 648:  65%|██████▍   | 649/1000 [3:58:59<2:09:15, 22.10s/it][Succeeded / Failed / Skipped / Total] 617 / 17 / 15 / 649:  65%|██████▍   | 649/1000 [3:58:59<2:09:15, 22.10s/it][Succeeded / Failed / Skipped / Total] 617 / 17 / 15 / 649:  65%|██████▌   | 650/1000 [3:59:34<2:08:59, 22.11s/it][Succeeded / Failed / Skipped / Total] 618 / 17 / 15 / 650:  65%|██████▌   | 650/1000 [3:59:34<2:08:59, 22.11s/it][Succeeded / Failed / Skipped / Total] 618 / 17 / 15 / 650:  65%|██████▌   | 651/1000 [4:00:07<2:08:43, 22.13s/it][Succeeded / Failed / Skipped / Total] 619 / 17 / 15 / 651:  65%|██████▌   | 651/1000 [4:00:07<2:08:43, 22.13s/it][Succeeded / Failed / Skipped / Total] 619 / 17 / 15 / 651:  65%|██████▌   | 652/1000 [4:00:18<2:08:15, 22.11s/it][Succeeded / Failed / Skipped / Total] 620 / 17 / 15 / 652:  65%|██████▌   | 652/1000 [4:00:18<2:08:15, 22.11s/it][Succeeded / Failed / Skipped / Total] 620 / 17 / 15 / 652:  65%|██████▌   | 653/1000 [4:00:44<2:07:55, 22.12s/it]Compute the cost for object transformation . --> calculate transport cost --> Socre: 1.0

[[[[Adv]]]]: private static float [[getObjectTransformationCost]] ( Class < ? > srcClass , final Class < ? > [[destClass]] ) { if ( [[destClass]] . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , [[destClass]] ) ; } float cost = 0.0f ; while ( srcClass != null && ! [[destClass]] . equals ( srcClass ) ) { if ( [[destClass]] . isInterface ( ) && ClassUtils . isAssignable ( srcClass , [[destClass]] ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float [[sook]] ( Class < ? > srcClass , final Class < ? > [[ayahuasca]] ) { if ( [[ayahuasca]] . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , [[ayahuasca]] ) ; } float cost = 0.0f ; while ( srcClass != null && ! [[ayahuasca]] . equals ( srcClass ) ) { if ( [[ayahuasca]] . isInterface ( ) && ClassUtils . isAssignable ( srcClass , [[ayahuasca]] ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 646 ---------------------------------------------
Gets message for the given key . --> Parse a translation --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String key , Object ... [[args]] ) { return messagesApi . get ( lang , key , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[paras]] ( String key , Object ... [[guangzhou]] ) { return messagesApi . get ( lang , key , [[guangzhou]] ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 647 ---------------------------------------------
Gets a message for the given keys . --> Retrieve a translation for a given locale --> Socre: 1.0

[[[[Adv]]]]: public String at ( List < String > keys , Object ... [[args]] ) { return messagesApi . get ( lang , keys , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String at ( List < String > keys , Object ... [[cile]] ) { return messagesApi . get ( lang , keys , [[cile]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 648 ---------------------------------------------
Creates a database from the given parameters . --> Initializes Bacillus --> Socre: 1.0

[[[[Adv]]]]: public static Database [[createFrom]] ( String [[driver]] , String [[url]] , Map < String , ? extends Object > [[config]] ) { return [[createFrom]] ( "default" , [[driver]] , [[url]] , [[config]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[bacillus]] ( String [[chaperone]] , String [[blog]] , Map < String , ? extends Object > [[uniqueness]] ) { return [[bacillus]] ( "default" , [[chaperone]] , [[blog]] , [[uniqueness]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 649 ---------------------------------------------
Create a parallel Sorter . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] [[arrays]] ) { Generator [[gen]] = new Generator ( ) ; [[gen]] . setArrays ( [[arrays]] ) ; return [[gen]] . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[engendered]] ( Object [ ] [[cab]] ) { Generator [[genres]] = new Generator ( ) ; [[genres]] . setArrays ( [[cab]] ) ; return [[genres]] . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 650 ---------------------------------------------
Performs a quick sort operation . --> Crossfire --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int [[index]] , int [[lo]] , int [[hi]] , Comparator [[cmp]] ) { chooseComparer ( [[index]] , [[cmp]] ) ; super . quickSort ( [[lo]] , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[crossfire]] ( int [[directory]] , int [[loy]] , int [[hail]] , Comparator [[clt]] ) { chooseComparer ( [[directory]] , [[clt]] ) ; super . quickSort ( [[loy]] , [[hail]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 651 ---------------------------------------------
Merge sort method . --> Used for debugging --> Socre: 1.0

[[[[Adv]]]]: public void [[mergeSort]] ( int [[index]] , int lo , int [[hi]] , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . mergeSort ( lo , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[clichéd]] ( int [[gauges]] , int lo , int [[goodbye]] , Comparator cmp ) { chooseComparer ( [[gauges]] , cmp ) ; super . mergeSort ( lo , [[goodbye]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 652 ---------------------------------------------
Invokes the method . --> Calls protected methods --> Socre: 1.0

[[[[Adv]]]]: public Object invoke ( Object obj , Object [ ] [[args]] ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , obj , [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object invoke ( Object obj , Object [ ] [[specialist]] ) throws Throwable { try { init ( ) ; FastClassInfo [[ainu]] = fastClassInfo ; return [[ainu]] . f1 . invoke ( [[ainu]] . i1 , obj , [[specialist]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 653 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 621 / 17 / 15 / 653:  65%|██████▌   | 653/1000 [4:00:44<2:07:55, 22.12s/it][Succeeded / Failed / Skipped / Total] 621 / 17 / 15 / 653:  65%|██████▌   | 654/1000 [4:00:49<2:07:24, 22.09s/it][Succeeded / Failed / Skipped / Total] 622 / 17 / 15 / 654:  65%|██████▌   | 654/1000 [4:00:49<2:07:24, 22.09s/it][Succeeded / Failed / Skipped / Total] 622 / 17 / 15 / 654:  66%|██████▌   | 655/1000 [4:00:50<2:06:51, 22.06s/it][Succeeded / Failed / Skipped / Total] 622 / 17 / 16 / 655:  66%|██████▌   | 655/1000 [4:00:50<2:06:51, 22.06s/it][Succeeded / Failed / Skipped / Total] 622 / 17 / 16 / 655:  66%|██████▌   | 656/1000 [4:01:26<2:06:36, 22.08s/it][Succeeded / Failed / Skipped / Total] 623 / 17 / 16 / 656:  66%|██████▌   | 656/1000 [4:01:26<2:06:36, 22.08s/it][Succeeded / Failed / Skipped / Total] 623 / 17 / 16 / 656:  66%|██████▌   | 657/1000 [4:01:30<2:06:05, 22.06s/it][Succeeded / Failed / Skipped / Total] 624 / 17 / 16 / 657:  66%|██████▌   | 657/1000 [4:01:30<2:06:05, 22.06s/it][Succeeded / Failed / Skipped / Total] 624 / 17 / 16 / 657:  66%|██████▌   | 658/1000 [4:01:36<2:05:34, 22.03s/it]Encode a cookie . --> Encode Puddings --> Socre: 1.0

[[[[Adv]]]]: public String encode ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[name]] = [[cookie]] . name ( ) ; final String value = [[cookie]] . value ( ) != null ? [[cookie]] . value ( ) : "" ; validateCookie ( [[name]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( [[cookie]] . wrap ( ) ) { addQuoted ( buf , [[name]] , value ) ; } else { add ( buf , [[name]] , value ) ; } if ( [[cookie]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , [[cookie]] . maxAge ( ) ) ; Date expires = [[cookie]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie [[puddings]] ) { if ( [[puddings]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[nomination]] = [[puddings]] . name ( ) ; final String value = [[puddings]] . value ( ) != null ? [[puddings]] . value ( ) : "" ; validateCookie ( [[nomination]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( [[puddings]] . wrap ( ) ) { addQuoted ( buf , [[nomination]] , value ) ; } else { add ( buf , [[nomination]] , value ) ; } if ( [[puddings]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , [[puddings]] . maxAge ( ) ) ; Date expires = [[puddings]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 654 ---------------------------------------------
Load an argument . --> load ternary --> Socre: 1.0

[[[[Adv]]]]: public void [[load_arg]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[teraz]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 655 ---------------------------------------------
generate a field instruction --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 656 ---------------------------------------------
Append a zero or null value to the stack . --> builds steph steph --> Socre: 1.0

[[[[Adv]]]]: public void [[zero_or_null]] ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { switch ( [[type]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[steph]] ( Type [[tipo]] ) { if ( TypeUtils . isPrimitive ( [[tipo]] ) ) { switch ( [[tipo]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 657 ---------------------------------------------
Cast a number type to the type --> Binary cast method . --> Socre: 1.0

[[[[Adv]]]]: public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 658 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 625 / 17 / 16 / 658:  66%|██████▌   | 658/1000 [4:01:36<2:05:34, 22.03s/it][Succeeded / Failed / Skipped / Total] 625 / 17 / 16 / 658:  66%|██████▌   | 659/1000 [4:01:41<2:05:04, 22.01s/it][Succeeded / Failed / Skipped / Total] 626 / 17 / 16 / 659:  66%|██████▌   | 659/1000 [4:01:41<2:05:04, 22.01s/it][Succeeded / Failed / Skipped / Total] 626 / 17 / 16 / 659:  66%|██████▌   | 660/1000 [4:01:45<2:04:32, 21.98s/it][Succeeded / Failed / Skipped / Total] 627 / 17 / 16 / 660:  66%|██████▌   | 660/1000 [4:01:45<2:04:32, 21.98s/it][Succeeded / Failed / Skipped / Total] 627 / 17 / 16 / 660:  66%|██████▌   | 661/1000 [4:01:57<2:04:05, 21.96s/it][Succeeded / Failed / Skipped / Total] 628 / 17 / 16 / 661:  66%|██████▌   | 661/1000 [4:01:57<2:04:05, 21.96s/it][Succeeded / Failed / Skipped / Total] 628 / 17 / 16 / 661:  66%|██████▌   | 662/1000 [4:02:07<2:03:37, 21.94s/it][Succeeded / Failed / Skipped / Total] 628 / 18 / 16 / 662:  66%|██████▌   | 662/1000 [4:02:07<2:03:37, 21.94s/it][Succeeded / Failed / Skipped / Total] 628 / 18 / 16 / 662:  66%|██████▋   | 663/1000 [4:02:45<2:03:23, 21.97s/it]Process array . --> generate a code chunk --> Socre: 1.0

[[[[Adv]]]]: public static void [[process_array]] ( CodeEmitter e , Type [[type]] , ProcessArrayCallback [[callback]] ) { Type componentType = TypeUtils . getComponentType ( [[type]] ) ; Local [[array]] = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( [[array]] ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( [[array]] ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; [[callback]] . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( [[array]] ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void [[yeow]] ( CodeEmitter e , Type [[genera]] , ProcessArrayCallback [[telephoned]] ) { Type componentType = TypeUtils . getComponentType ( [[genera]] ) ; Local [[payphone]] = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( [[payphone]] ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( [[payphone]] ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; [[telephoned]] . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( [[payphone]] ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 659 ---------------------------------------------
null is null --> Generate a tooltip --> Socre: 1.0

[[[[Adv]]]]: private static void [[nullcmp]] ( CodeEmitter e , Label [[oneNull]] , Label [[bothNull]] ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( [[bothNull]] ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( [[oneNull]] ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void [[fugitive]] ( CodeEmitter e , Label [[sorcerer]] , Label [[waldemar]] ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( [[waldemar]] ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( [[sorcerer]] ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 660 ---------------------------------------------
Unbox or zero . --> mark a guy --> Socre: 1.0

[[[[Adv]]]]: public void [[unbox_or_zero]] ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { if ( [[type]] != Type . VOID_TYPE ) { Label [[nonNull]] = make_label ( ) ; Label [[end]] = make_label ( ) ; dup ( ) ; ifnonnull ( [[nonNull]] ) ; pop ( ) ; zero_or_null ( [[type]] ) ; goTo ( [[end]] ) ; mark ( [[nonNull]] ) ; unbox ( [[type]] ) ; mark ( [[end]] ) ; } } else { checkcast ( [[type]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void [[bboys]] ( Type [[guy]] ) { if ( TypeUtils . isPrimitive ( [[guy]] ) ) { if ( [[guy]] != Type . VOID_TYPE ) { Label [[veterinarian]] = make_label ( ) ; Label [[concludes]] = make_label ( ) ; dup ( ) ; ifnonnull ( [[veterinarian]] ) ; pop ( ) ; zero_or_null ( [[guy]] ) ; goTo ( [[concludes]] ) ; mark ( [[veterinarian]] ) ; unbox ( [[guy]] ) ; mark ( [[concludes]] ) ; } } else { checkcast ( [[guy]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 661 ---------------------------------------------
Resolves all bridge classes . --> This is a hack to avoid the test --> Socre: 1.0

[[[[Adv]]]]: public Map [[resolveAll]] ( ) { Map [[resolved]] = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry [[entry]] = ( Map . Entry ) entryIter . next ( ) ; Class [[owner]] = ( Class ) [[entry]] . getKey ( ) ; Set [[bridges]] = ( Set ) [[entry]] . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( [[owner]] . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return [[resolved]] ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( [[bridges]] , [[resolved]] ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return [[resolved]] ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map [[symptom]] ( ) { Map [[broached]] = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry [[scripture]] = ( Map . Entry ) entryIter . next ( ) ; Class [[occupier]] = ( Class ) [[scripture]] . getKey ( ) ; Set [[drawbridge]] = ( Set ) [[scripture]] . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( [[occupier]] . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return [[broached]] ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( [[drawbridge]] , [[broached]] ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return [[broached]] ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 662 ---------------------------------------------
Fills the form with the specified value . --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > fill ( T value ) { if ( value == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( value ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > fill ( T value ) { if ( value == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( value ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 663 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 629 / 18 / 16 / 663:  66%|██████▋   | 663/1000 [4:02:45<2:03:23, 21.97s/it][Succeeded / Failed / Skipped / Total] 629 / 18 / 16 / 663:  66%|██████▋   | 664/1000 [4:02:45<2:02:50, 21.94s/it][Succeeded / Failed / Skipped / Total] 629 / 18 / 17 / 664:  66%|██████▋   | 664/1000 [4:02:45<2:02:50, 21.94s/it][Succeeded / Failed / Skipped / Total] 629 / 18 / 17 / 664:  66%|██████▋   | 665/1000 [4:02:46<2:02:17, 21.90s/it][Succeeded / Failed / Skipped / Total] 630 / 18 / 17 / 665:  66%|██████▋   | 665/1000 [4:02:46<2:02:17, 21.90s/it][Succeeded / Failed / Skipped / Total] 630 / 18 / 17 / 665:  67%|██████▋   | 666/1000 [4:02:50<2:01:47, 21.88s/it][Succeeded / Failed / Skipped / Total] 631 / 18 / 17 / 666:  67%|██████▋   | 666/1000 [4:02:50<2:01:47, 21.88s/it][Succeeded / Failed / Skipped / Total] 631 / 18 / 17 / 666:  67%|██████▋   | 667/1000 [4:02:51<2:01:14, 21.85s/it][Succeeded / Failed / Skipped / Total] 632 / 18 / 17 / 667:  67%|██████▋   | 667/1000 [4:02:51<2:01:14, 21.85s/it][Succeeded / Failed / Skipped / Total] 632 / 18 / 17 / 667:  67%|██████▋   | 668/1000 [4:02:51<2:00:42, 21.81s/it][Succeeded / Failed / Skipped / Total] 632 / 18 / 18 / 668:  67%|██████▋   | 668/1000 [4:02:51<2:00:42, 21.81s/it][Succeeded / Failed / Skipped / Total] 632 / 18 / 18 / 668:  67%|██████▋   | 669/1000 [4:03:04<2:00:16, 21.80s/it][Succeeded / Failed / Skipped / Total] 633 / 18 / 18 / 669:  67%|██████▋   | 669/1000 [4:03:04<2:00:16, 21.80s/it][Succeeded / Failed / Skipped / Total] 633 / 18 / 18 / 669:  67%|██████▋   | 670/1000 [4:03:20<1:59:51, 21.79s/it][Succeeded / Failed / Skipped / Total] 634 / 18 / 18 / 670:  67%|██████▋   | 670/1000 [4:03:20<1:59:51, 21.79s/it][Succeeded / Failed / Skipped / Total] 634 / 18 / 18 / 670:  67%|██████▋   | 671/1000 [4:03:23<1:59:20, 21.76s/it][Succeeded / Failed / Skipped / Total] 635 / 18 / 18 / 671:  67%|██████▋   | 671/1000 [4:03:23<1:59:20, 21.76s/it][Succeeded / Failed / Skipped / Total] 635 / 18 / 18 / 671:  67%|██████▋   | 672/1000 [4:03:31<1:58:51, 21.74s/it]Filter constructors . --> Throws an IllegalArgumentException --> Socre: 1.0

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class sc , List [[constructors]] ) { CollectionUtils . filter ( [[constructors]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[constructors]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[vastus]] ( Class sc , List [[crafts]] ) { CollectionUtils . filter ( [[crafts]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[crafts]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 664 ---------------------------------------------
Get field . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 665 ---------------------------------------------
Set the superclass . --> Register watchers --> Socre: 1.0

[[[[Adv]]]]: public void [[setSuperclass]] ( Class [[superclass]] ) { if ( [[superclass]] != null && [[superclass]] . equals ( Object . class ) ) { [[superclass]] = null ; } this . superclass = [[superclass]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void [[watchers]] ( Class [[krusty]] ) { if ( [[krusty]] != null && [[krusty]] . equals ( Object . class ) ) { [[krusty]] = null ; } this . superclass = [[krusty]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 666 ---------------------------------------------
Returns the cardinality of the value . --> Returns the number of escalators --> Socre: 1.0

[[[[Adv]]]]: public int [[cardinality]] ( ) { int w = value ; int [[c]] = 0 ; while ( w != 0 ) { [[c]] += T [ w & 255 ] ; w >>= 8 ; } return [[c]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int [[escalators]] ( ) { int w = value ; int [[jim]] = 0 ; while ( w != 0 ) { [[jim]] += T [ w & 255 ] ; w >>= 8 ; } return [[jim]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 667 ---------------------------------------------
Adds methods from super . --> Bitchen methods --> Socre: 0.9999999999820136

[[[[Adv]]]]: public static void [[getMethods]] ( Class superclass , Class [ ] [[interfaces]] , List methods ) { [[getMethods]] ( superclass , [[interfaces]] , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[bitchen]] ( Class superclass , Class [ ] [[birmingham]] , List methods ) { [[bitchen]] ( superclass , [[birmingham]] , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 668 ---------------------------------------------
Finds all methods with the given names and descriptors . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 669 ---------------------------------------------
Sets the naming policy . --> Reuse this instance to rearguard --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy [[namingPolicy]] ) { if ( [[namingPolicy]] == null ) [[namingPolicy]] = DefaultNamingPolicy . INSTANCE ; this . [[namingPolicy]] = [[namingPolicy]] ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[rearguard]] ( NamingPolicy [[bluebird]] ) { if ( [[bluebird]] == null ) [[bluebird]] = DefaultNamingPolicy . INSTANCE ; this . [[relinquished]] = [[bluebird]] ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 670 ---------------------------------------------
Add method . --> Adds Procedure --> Socre: 1.0

[[[[Adv]]]]: public void add ( Method [[method]] ) { add ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void add ( Method [[procedures]] ) { add ( ReflectUtils . getSignature ( [[procedures]] ) , ReflectUtils . getExceptionTypes ( [[procedures]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 671 ---------------------------------------------
Sets the request host . --> Overwrites HttpRequest to a recipient --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . [[host]] = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[accommodated]] ( final String [[recipient]] ) { this . [[receipt]] = [[accommodated]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[accommodated]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 672 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 636 / 18 / 18 / 672:  67%|██████▋   | 672/1000 [4:03:31<1:58:51, 21.74s/it][Succeeded / Failed / Skipped / Total] 636 / 18 / 18 / 672:  67%|██████▋   | 673/1000 [4:03:34<1:58:20, 21.72s/it][Succeeded / Failed / Skipped / Total] 637 / 18 / 18 / 673:  67%|██████▋   | 673/1000 [4:03:34<1:58:20, 21.72s/it][Succeeded / Failed / Skipped / Total] 637 / 18 / 18 / 673:  67%|██████▋   | 674/1000 [4:03:47<1:57:55, 21.70s/it][Succeeded / Failed / Skipped / Total] 638 / 18 / 18 / 674:  67%|██████▋   | 674/1000 [4:03:47<1:57:55, 21.70s/it][Succeeded / Failed / Skipped / Total] 638 / 18 / 18 / 674:  68%|██████▊   | 675/1000 [4:04:05<1:57:31, 21.70s/it][Succeeded / Failed / Skipped / Total] 639 / 18 / 18 / 675:  68%|██████▊   | 675/1000 [4:04:05<1:57:31, 21.70s/it][Succeeded / Failed / Skipped / Total] 639 / 18 / 18 / 675:  68%|██████▊   | 676/1000 [4:04:06<1:56:59, 21.67s/it][Succeeded / Failed / Skipped / Total] 640 / 18 / 18 / 676:  68%|██████▊   | 676/1000 [4:04:06<1:56:59, 21.67s/it][Succeeded / Failed / Skipped / Total] 640 / 18 / 18 / 676:  68%|██████▊   | 677/1000 [4:05:46<1:57:15, 21.78s/it][Succeeded / Failed / Skipped / Total] 641 / 18 / 18 / 677:  68%|██████▊   | 677/1000 [4:05:46<1:57:15, 21.78s/it][Succeeded / Failed / Skipped / Total] 641 / 18 / 18 / 677:  68%|██████▊   | 678/1000 [4:06:41<1:57:09, 21.83s/it][Succeeded / Failed / Skipped / Total] 642 / 18 / 18 / 678:  68%|██████▊   | 678/1000 [4:06:41<1:57:09, 21.83s/it][Succeeded / Failed / Skipped / Total] 642 / 18 / 18 / 678:  68%|██████▊   | 679/1000 [4:07:29<1:57:00, 21.87s/it][Succeeded / Failed / Skipped / Total] 643 / 18 / 18 / 679:  68%|██████▊   | 679/1000 [4:07:29<1:57:00, 21.87s/it][Succeeded / Failed / Skipped / Total] 643 / 18 / 18 / 679:  68%|██████▊   | 680/1000 [4:09:12<1:57:16, 21.99s/it][Succeeded / Failed / Skipped / Total] 644 / 18 / 18 / 680:  68%|██████▊   | 680/1000 [4:09:12<1:57:16, 21.99s/it][Succeeded / Failed / Skipped / Total] 644 / 18 / 18 / 680:  68%|██████▊   | 681/1000 [4:09:21<1:56:48, 21.97s/it][Succeeded / Failed / Skipped / Total] 645 / 18 / 18 / 681:  68%|██████▊   | 681/1000 [4:09:21<1:56:48, 21.97s/it][Succeeded / Failed / Skipped / Total] 645 / 18 / 18 / 681:  68%|██████▊   | 682/1000 [4:09:27<1:56:19, 21.95s/it][Succeeded / Failed / Skipped / Total] 646 / 18 / 18 / 682:  68%|██████▊   | 682/1000 [4:09:27<1:56:19, 21.95s/it][Succeeded / Failed / Skipped / Total] 646 / 18 / 18 / 682:  68%|██████▊   | 683/1000 [4:09:31<1:55:48, 21.92s/it]Create an HttpRequest . --> Build HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[create]] ( final String method , final String [[destination]] ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest [[engender]] ( final String method , final String [[recipients]] ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( [[recipients]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 673 ---------------------------------------------
Convert a Java List to a Seq . --> Creates an espa chooser --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[español]] ( java . util . List < T > [[roster]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[roster]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 674 ---------------------------------------------
Reads a string from a file . --> Read a string into a string --> Socre: 1.0

[[[[Adv]]]]: public static String readString ( final Path [[path]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[path]] , StandardCharsets . UTF_8 ) ) { StringWriter [[writer]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String readString ( final Path [[routes]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[routes]] , StandardCharsets . UTF_8 ) ) { StringWriter [[playwrights]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 675 ---------------------------------------------
Resolves a path relative to a base path . --> needs to be synchronized --> Socre: 1.0

[[[[Adv]]]]: public static Path [[resolve]] ( final Path [[base]] , String [[child]] ) { if ( StringUtil . startsWithChar ( [[child]] , File . separatorChar ) ) { [[child]] = [[child]] . substring ( 1 ) ; } return [[base]] . resolve ( [[child]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[firmness]] ( final Path [[qaida]] , String [[toddlers]] ) { if ( StringUtil . startsWithChar ( [[toddlers]] , File . separatorChar ) ) { [[toddlers]] = [[toddlers]] . substring ( 1 ) ; } return [[qaida]] . resolve ( [[toddlers]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 676 ---------------------------------------------
Sets a CONNECT request . --> HttpRequest hook for GET requests --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[connect]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest [[hooked]] ( final String [[meant]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[meant]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 677 ---------------------------------------------
Makes a GET request . --> % --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[gain]] ( final String [[receiver]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[receiver]] ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 678 ---------------------------------------------
Makes a POST request . --> Specifies that you want to show outposts --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[outposts]] ( final String [[sights]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[sights]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 679 ---------------------------------------------
Makes a HEAD request . --> Minimum query intents --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[leiter]] ( final String [[intents]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[intents]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 680 ---------------------------------------------
Start a TRACE request . -->  sniffing requests --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[sniffing]] ( final String [[geared]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[geared]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 681 ---------------------------------------------
Makes a PUT request . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[tabled]] ( final String [[aiming]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[aiming]] ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 682 ---------------------------------------------
Set the request path . --> Define driveways --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[path]] ( String path ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[driveways]] ( String path ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 683 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 647 / 18 / 18 / 683:  68%|██████▊   | 683/1000 [4:09:31<1:55:48, 21.92s/it][Succeeded / Failed / Skipped / Total] 647 / 18 / 18 / 683:  68%|██████▊   | 684/1000 [4:10:55<1:55:55, 22.01s/it][Succeeded / Failed / Skipped / Total] 648 / 18 / 18 / 684:  68%|██████▊   | 684/1000 [4:10:55<1:55:55, 22.01s/it][Succeeded / Failed / Skipped / Total] 648 / 18 / 18 / 684:  68%|██████▊   | 685/1000 [4:10:59<1:55:24, 21.98s/it][Succeeded / Failed / Skipped / Total] 649 / 18 / 18 / 685:  68%|██████▊   | 685/1000 [4:10:59<1:55:24, 21.98s/it][Succeeded / Failed / Skipped / Total] 649 / 18 / 18 / 685:  69%|██████▊   | 686/1000 [4:11:06<1:54:56, 21.96s/it][Succeeded / Failed / Skipped / Total] 650 / 18 / 18 / 686:  69%|██████▊   | 686/1000 [4:11:06<1:54:56, 21.96s/it][Succeeded / Failed / Skipped / Total] 650 / 18 / 18 / 686:  69%|██████▊   | 687/1000 [4:11:08<1:54:25, 21.93s/it][Succeeded / Failed / Skipped / Total] 651 / 18 / 18 / 687:  69%|██████▊   | 687/1000 [4:11:08<1:54:25, 21.93s/it][Succeeded / Failed / Skipped / Total] 651 / 18 / 18 / 687:  69%|██████▉   | 688/1000 [4:11:19<1:53:58, 21.92s/it][Succeeded / Failed / Skipped / Total] 652 / 18 / 18 / 688:  69%|██████▉   | 688/1000 [4:11:19<1:53:58, 21.92s/it][Succeeded / Failed / Skipped / Total] 652 / 18 / 18 / 688:  69%|██████▉   | 689/1000 [4:11:24<1:53:28, 21.89s/it][Succeeded / Failed / Skipped / Total] 653 / 18 / 18 / 689:  69%|██████▉   | 689/1000 [4:11:24<1:53:28, 21.89s/it][Succeeded / Failed / Skipped / Total] 653 / 18 / 18 / 689:  69%|██████▉   | 690/1000 [4:11:29<1:52:59, 21.87s/it][Succeeded / Failed / Skipped / Total] 654 / 18 / 18 / 690:  69%|██████▉   | 690/1000 [4:11:29<1:52:59, 21.87s/it][Succeeded / Failed / Skipped / Total] 654 / 18 / 18 / 690:  69%|██████▉   | 691/1000 [4:11:31<1:52:28, 21.84s/it]Sets the replacement cookies . --> Set Cookie header --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[REPLACEME0]] ( final Cookie ... [[REPLACEME0]] ) { if ( [[REPLACEME0]] . length == 0 ) { return this ; } StringBuilder [[cookieString]] = new StringBuilder ( ) ; boolean first = "[[True]]" == "[[True]]" ; for ( Cookie cookie : [[REPLACEME0]] ) { Integer [[maxAge]] = cookie . getMaxAge ( ) ; if ( [[maxAge]] != null && [[maxAge]] . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[cookieString]] . append ( "; " ) ; } first = "[[False]]" != "[[False]]" ; [[cookieString]] . append ( cookie . getName ( ) ) ; [[cookieString]] . append ( ' ' ) ; [[cookieString]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[cookieString]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest [[HOPPED]] ( final Cookie ... [[HOPPED]] ) { if ( [[HOPPED]] . length == 0 ) { return this ; } StringBuilder [[wriggle]] = new StringBuilder ( ) ; boolean first = "[[Concrete]]" == "[[Concrete]]" ; for ( Cookie cookie : [[HOPPED]] ) { Integer [[hilarity]] = cookie . getMaxAge ( ) ; if ( [[hilarity]] != null && [[hilarity]] . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[wriggle]] . append ( "; " ) ; } first = "[[Faked]]" != "[[Faked]]" ; [[wriggle]] . append ( cookie . getName ( ) ) ; [[wriggle]] . append ( ' ' ) ; [[wriggle]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[wriggle]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 684 ---------------------------------------------
Adds a query parameter . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final String name1 , final Object [[value1]] , final Object ... [[parameters]] ) { [[query]] ( name1 , [[value1]] == null ? null : [[value1]] . toString ( ) ) ; for ( int i = 0 ; i < [[parameters]] . length ; i += 2 ) { String name = [[parameters]] [ i ] . toString ( ) ; String value = [[parameters]] [ i + 1 ] . toString ( ) ; [[query]] . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest [[pertain]] ( final String name1 , final Object [[sickness]] , final Object ... [[syntax]] ) { [[pertain]] ( name1 , [[sickness]] == null ? null : [[sickness]] . toString ( ) ) ; for ( int i = 0 ; i < [[syntax]] . length ; i += 2 ) { String name = [[syntax]] [ i ] . toString ( ) ; String value = [[syntax]] [ i + 1 ] . toString ( ) ; [[pertain]] . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 685 ---------------------------------------------
Add query . --> Add view to request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > entry : queryMap . entrySet ( ) ) { [[query]] . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest [[viewing]] ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > entry : queryMap . entrySet ( ) ) { [[viewing]] . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 686 ---------------------------------------------
Set the query string . --> This method will only be used for testing --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String queryString , final boolean [[decode]] ) { this . query = HttpUtil . parseQuery ( [[queryString]] , [[decode]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[runaways]] ( final String queryString , final boolean [[codes]] ) { this . query = HttpUtil . parseQuery ( [[runaways]] , [[codes]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 687 ---------------------------------------------
Start a OPTIONS request . --> Create a HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[choose]] ( final String [[destined]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destined]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 688 ---------------------------------------------
Returns the host url . --> Create a gmail string --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand [[url]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[url]] . append ( protocol ) ; [[url]] . append ( "://" ) ; } if ( host != null ) { [[url]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[url]] . append ( ' ' ) ; [[url]] . append ( port ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[anthill]] ( ) { StringBand [[gmail]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[gmail]] . append ( protocol ) ; [[gmail]] . append ( "://" ) ; } if ( host != null ) { [[gmail]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[gmail]] . append ( ' ' ) ; [[gmail]] . append ( port ) ; } return [[gmail]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 689 ---------------------------------------------
Sets basic authentication . --> Sets the profiles from the request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String [[username]] , final String password ) { if ( [[username]] != null && password != null ) { String data = [[username]] . concat ( StringPool . COLON ) . concat ( password ) ; String [[base64]] = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + [[base64]] ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[desecrating]] ( final String [[user]] , final String password ) { if ( [[user]] != null && password != null ) { String data = [[user]] . concat ( StringPool . COLON ) . concat ( password ) ; String [[stockpiles]] = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + [[stockpiles]] ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 690 ---------------------------------------------
Sets the host header . --> set Headers --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String [[hostPort]] = this . host ; if ( port != Defaults . DEFAULT_PORT ) { [[hostPort]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[hostPort]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[jewelers]] ( ) { String [[tenderest]] = this . host ; if ( port != Defaults . DEFAULT_PORT ) { [[tenderest]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[tenderest]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 691 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 655 / 18 / 18 / 691:  69%|██████▉   | 691/1000 [4:11:31<1:52:28, 21.84s/it][Succeeded / Failed / Skipped / Total] 655 / 18 / 18 / 691:  69%|██████▉   | 692/1000 [4:11:42<1:52:01, 21.82s/it][Succeeded / Failed / Skipped / Total] 656 / 18 / 18 / 692:  69%|██████▉   | 692/1000 [4:11:42<1:52:01, 21.82s/it][Succeeded / Failed / Skipped / Total] 656 / 18 / 18 / 692:  69%|██████▉   | 693/1000 [4:12:00<1:51:38, 21.82s/it][Succeeded / Failed / Skipped / Total] 657 / 18 / 18 / 693:  69%|██████▉   | 693/1000 [4:12:00<1:51:38, 21.82s/it][Succeeded / Failed / Skipped / Total] 657 / 18 / 18 / 693:  69%|██████▉   | 694/1000 [4:12:04<1:51:08, 21.79s/it][Succeeded / Failed / Skipped / Total] 658 / 18 / 18 / 694:  69%|██████▉   | 694/1000 [4:12:04<1:51:08, 21.79s/it][Succeeded / Failed / Skipped / Total] 658 / 18 / 18 / 694:  70%|██████▉   | 695/1000 [4:12:08<1:50:39, 21.77s/it][Succeeded / Failed / Skipped / Total] 658 / 19 / 18 / 695:  70%|██████▉   | 695/1000 [4:12:08<1:50:39, 21.77s/it][Succeeded / Failed / Skipped / Total] 658 / 19 / 18 / 695:  70%|██████▉   | 696/1000 [4:12:12<1:50:09, 21.74s/it][Succeeded / Failed / Skipped / Total] 659 / 19 / 18 / 696:  70%|██████▉   | 696/1000 [4:12:12<1:50:09, 21.74s/it][Succeeded / Failed / Skipped / Total] 659 / 19 / 18 / 696:  70%|██████▉   | 697/1000 [4:12:17<1:49:40, 21.72s/it][Succeeded / Failed / Skipped / Total] 660 / 19 / 18 / 697:  70%|██████▉   | 697/1000 [4:12:17<1:49:40, 21.72s/it][Succeeded / Failed / Skipped / Total] 660 / 19 / 18 / 697:  70%|██████▉   | 698/1000 [4:12:19<1:49:10, 21.69s/it][Succeeded / Failed / Skipped / Total] 661 / 19 / 18 / 698:  70%|██████▉   | 698/1000 [4:12:19<1:49:10, 21.69s/it][Succeeded / Failed / Skipped / Total] 661 / 19 / 18 / 698:  70%|██████▉   | 699/1000 [4:12:19<1:48:39, 21.66s/it][Succeeded / Failed / Skipped / Total] 662 / 19 / 18 / 699:  70%|██████▉   | 699/1000 [4:12:19<1:48:39, 21.66s/it][Succeeded / Failed / Skipped / Total] 662 / 19 / 18 / 699:  70%|███████   | 700/1000 [4:12:24<1:48:10, 21.63s/it][Succeeded / Failed / Skipped / Total] 663 / 19 / 18 / 700:  70%|███████   | 700/1000 [4:12:24<1:48:10, 21.63s/it][Succeeded / Failed / Skipped / Total] 663 / 19 / 18 / 700:  70%|███████   | 701/1000 [4:12:27<1:47:40, 21.61s/it]Writes the buffer . --> must be synchronized --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer [[buffer]] ( final boolean [[fullRequest]] ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer [[swab]] ( final boolean [[dahn]] ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 692 ---------------------------------------------
Send and receive and receive response . --> send and receive and receive response --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[gupta]] > [[gupta]] sendAndReceive ( final Function < HttpResponse , [[gupta]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 693 ---------------------------------------------
Returns the query string . --> Returns the galveston expression --> Socre: 1.0

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[galveston]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 694 ---------------------------------------------
Returns the length of the exception table . --> used in tests --> Socre: 1.0

[[[[Adv]]]]: static int [[getExceptionTableLength]] ( final Handler [[firstHandler]] ) { int [[length]] = 0 ; Handler [[handler]] = [[firstHandler]] ; while ( [[handler]] != null ) { [[length]] ++ ; [[handler]] = [[handler]] . nextHandler ; } return [[length]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int [[venereal]] ( final Handler [[dealership]] ) { int [[timetable]] = 0 ; Handler [[caregiver]] = [[dealership]] ; while ( [[caregiver]] != null ) { [[timetable]] ++ ; [[caregiver]] = [[caregiver]] . nextHandler ; } return [[timetable]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 695 ---------------------------------------------
Remove ranges between two ranges . --> [[[FAILED]]]

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 696 ---------------------------------------------
Collects the action filters . --> Populate the conf --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > [[filterValues]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[filterValues]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[conf]] ( ) { final Collection < ? extends ActionFilter > [[quarreled]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[quarreled]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 697 ---------------------------------------------
Collect the action results . --> For testing purposes only --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > [[resultsValues]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[resultsValues]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[counting]] ( ) { final Collection < ActionResult > [[jacking]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[jacking]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 698 ---------------------------------------------
Collects all action interceptors . --> generate landon type --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > [[interceptorValues]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[interceptorValues]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[lafferty]] ( ) { final Collection < ? extends ActionInterceptor > [[landon]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[landon]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 699 ---------------------------------------------
Collect all action runtimes . --> Sets up the list of runtimes --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[zeenat]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 700 ---------------------------------------------
Sets a simple property . --> Ludmila setter --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty [[bp]] , final Object [[value]] ) { Setter [[setter]] = [[bp]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[ludmila]] ( final BeanProperty [[gp]] , final Object [[amount]] ) { Setter [[hotshot]] = [[gp]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 701 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 664 / 19 / 18 / 701:  70%|███████   | 701/1000 [4:12:27<1:47:40, 21.61s/it][Succeeded / Failed / Skipped / Total] 664 / 19 / 18 / 701:  70%|███████   | 702/1000 [4:12:52<1:47:20, 21.61s/it][Succeeded / Failed / Skipped / Total] 665 / 19 / 18 / 702:  70%|███████   | 702/1000 [4:12:52<1:47:20, 21.61s/it][Succeeded / Failed / Skipped / Total] 665 / 19 / 18 / 702:  70%|███████   | 703/1000 [4:12:56<1:46:51, 21.59s/it][Succeeded / Failed / Skipped / Total] 666 / 19 / 18 / 703:  70%|███████   | 703/1000 [4:12:56<1:46:51, 21.59s/it][Succeeded / Failed / Skipped / Total] 666 / 19 / 18 / 703:  70%|███████   | 704/1000 [4:13:18<1:46:30, 21.59s/it][Succeeded / Failed / Skipped / Total] 667 / 19 / 18 / 704:  70%|███████   | 704/1000 [4:13:18<1:46:30, 21.59s/it][Succeeded / Failed / Skipped / Total] 667 / 19 / 18 / 704:  70%|███████   | 705/1000 [4:13:23<1:46:01, 21.57s/it][Succeeded / Failed / Skipped / Total] 668 / 19 / 18 / 705:  70%|███████   | 705/1000 [4:13:23<1:46:01, 21.57s/it][Succeeded / Failed / Skipped / Total] 668 / 19 / 18 / 705:  71%|███████   | 706/1000 [4:14:32<1:45:59, 21.63s/it][Succeeded / Failed / Skipped / Total] 669 / 19 / 18 / 706:  71%|███████   | 706/1000 [4:14:32<1:45:59, 21.63s/it][Succeeded / Failed / Skipped / Total] 669 / 19 / 18 / 706:  71%|███████   | 707/1000 [4:14:38<1:45:31, 21.61s/it][Succeeded / Failed / Skipped / Total] 670 / 19 / 18 / 707:  71%|███████   | 707/1000 [4:14:38<1:45:31, 21.61s/it][Succeeded / Failed / Skipped / Total] 670 / 19 / 18 / 707:  71%|███████   | 708/1000 [4:15:19<1:45:18, 21.64s/it][Succeeded / Failed / Skipped / Total] 671 / 19 / 18 / 708:  71%|███████   | 708/1000 [4:15:19<1:45:18, 21.64s/it][Succeeded / Failed / Skipped / Total] 671 / 19 / 18 / 708:  71%|███████   | 709/1000 [4:16:31<1:45:17, 21.71s/it][Succeeded / Failed / Skipped / Total] 672 / 19 / 18 / 709:  71%|███████   | 709/1000 [4:16:31<1:45:17, 21.71s/it][Succeeded / Failed / Skipped / Total] 672 / 19 / 18 / 709:  71%|███████   | 710/1000 [4:17:33<1:45:11, 21.76s/it]Extract the reference from the property name . --> Utility function for testing --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int [[ndx]] = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( [[ndx]] == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , [[ndx]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[surety]] ( final String [[reeducation]] ) { int [[battleships]] = StringUtil . indexOfChars ( [[reeducation]] , INDEX_CHARS ) ; if ( [[battleships]] == - 1 ) { return [[reeducation]] ; } return [[reeducation]] . substring ( 0 , [[battleships]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 702 ---------------------------------------------
Returns a print writer . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[miscalculation]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 703 ---------------------------------------------
Sets an object reference . --> Add a stallion to the map --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String [[name]] , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , object ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[stallion]] ( final String [[appointing]] , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[appointing]] , object ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 704 ---------------------------------------------
Get object reference --> Get borden --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[borden]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 705 ---------------------------------------------
Lookup object reference . --> PreMeditation method --> Socre: 1.0

[[[[Adv]]]]: public Object [[lookupObject]] ( final String ref ) { Object [[value]] = getObjectReference ( ref ) ; if ( [[value]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return [[value]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[premeditation]] ( final String ref ) { Object [[evaluating]] = getObjectReference ( ref ) ; if ( [[evaluating]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return [[evaluating]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 706 ---------------------------------------------
Gets the entity descriptor . --> Get the streetlights --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[streetlights]] ( final String [[bangin]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[k]] = tableRefs . get ( [[bangin]] ) ; return [[k]] == null ? null : [[k]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 707 ---------------------------------------------
Find table descriptor by column reference --> returns null if none found --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String [[columnRef]] ) { for ( Map . Entry < String , TableRefData > [[entry]] : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[ded]] = [[entry]] . getValue ( ) . desc ; if ( [[ded]] . findByPropertyName ( [[columnRef]] ) != null ) { return [[ded]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[periods]] ( final String [[treasures]] ) { for ( Map . Entry < String , TableRefData > [[inputs]] : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[pensioner]] = [[inputs]] . getValue ( ) . desc ; if ( [[pensioner]] . findByPropertyName ( [[treasures]] ) != null ) { return [[pensioner]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 708 ---------------------------------------------
Get table alias . --> Gets a human - readable version of a file --> Socre: 1.0

[[[[Adv]]]]: public String [[getTableAlias]] ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[garcía]] ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 709 ---------------------------------------------
Register a table reference . --> Store a trebuie --> Socre: 1.0

[[[[Adv]]]]: public void [[registerTableReference]] ( final String [[tableReference]] , final DbEntityDescriptor ded , final String [[tableAlias]] ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , [[tableAlias]] ) ; if ( tableRefs . put ( [[tableReference]] , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + [[tableReference]] ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[trebuie]] ( final String [[kitty]] , final DbEntityDescriptor ded , final String [[lust]] ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , [[lust]] ) ; if ( tableRefs . put ( [[kitty]] , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + [[kitty]] ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 710 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 673 / 19 / 18 / 710:  71%|███████   | 710/1000 [4:17:33<1:45:11, 21.76s/it][Succeeded / Failed / Skipped / Total] 673 / 19 / 18 / 710:  71%|███████   | 711/1000 [4:17:47<1:44:47, 21.75s/it][Succeeded / Failed / Skipped / Total] 674 / 19 / 18 / 711:  71%|███████   | 711/1000 [4:17:47<1:44:47, 21.75s/it][Succeeded / Failed / Skipped / Total] 674 / 19 / 18 / 711:  71%|███████   | 712/1000 [4:17:51<1:44:18, 21.73s/it][Succeeded / Failed / Skipped / Total] 675 / 19 / 18 / 712:  71%|███████   | 712/1000 [4:17:51<1:44:18, 21.73s/it][Succeeded / Failed / Skipped / Total] 675 / 19 / 18 / 712:  71%|███████▏  | 713/1000 [4:18:02<1:43:52, 21.71s/it][Succeeded / Failed / Skipped / Total] 676 / 19 / 18 / 713:  71%|███████▏  | 713/1000 [4:18:02<1:43:52, 21.71s/it][Succeeded / Failed / Skipped / Total] 676 / 19 / 18 / 713:  71%|███████▏  | 714/1000 [4:18:25<1:43:30, 21.72s/it][Succeeded / Failed / Skipped / Total] 677 / 19 / 18 / 714:  71%|███████▏  | 714/1000 [4:18:25<1:43:30, 21.72s/it][Succeeded / Failed / Skipped / Total] 677 / 19 / 18 / 714:  72%|███████▏  | 715/1000 [4:18:40<1:43:06, 21.71s/it][Succeeded / Failed / Skipped / Total] 678 / 19 / 18 / 715:  72%|███████▏  | 715/1000 [4:18:40<1:43:06, 21.71s/it][Succeeded / Failed / Skipped / Total] 678 / 19 / 18 / 715:  72%|███████▏  | 716/1000 [4:18:47<1:42:38, 21.69s/it]Lookup the entity reference by table reference . --> Get the entity descriptor to be used in the database --> Socre: 1.0

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String [[tableRef]] ) { DbEntityDescriptor ded = getTableDescriptor ( [[tableRef]] ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[tableRef]] ) ; } return ded ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[kisu]] ( final String [[lymphoma]] ) { DbEntityDescriptor ded = getTableDescriptor ( [[lymphoma]] ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[lymphoma]] ) ; } return ded ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 711 ---------------------------------------------
Makes a PATCH request . --> Builder for review --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[review]] ( final String [[targets]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[targets]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 712 ---------------------------------------------
Serializes the given value to the JSON context . --> Serialize hardened to hardened storage --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[jsonContext]] , final T [[value]] ) { if ( [[jsonContext]] . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[hardship]] , final T [[valued]] ) { if ( [[hardship]] . pushValue ( [[valued]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 713 ---------------------------------------------
Inject attributes . --> Writes principals to target --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectAttributes]] ( final HttpServletRequest [[servletRequest]] , final Targets [[targets]] ) { final Enumeration < String > [[attributeNames]] = [[servletRequest]] . getAttributeNames ( ) ; while ( [[attributeNames]] . hasMoreElements ( ) ) { final String attrName = [[attributeNames]] . nextElement ( ) ; [[targets]] . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object [[attrValue]] = [[servletRequest]] . getAttribute ( attrName ) ; target . writeValue ( name , [[attrValue]] , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void [[christos]] ( final HttpServletRequest [[clod]] , final Targets [[intentions]] ) { final Enumeration < String > [[grandiose]] = [[clod]] . getAttributeNames ( ) ; while ( [[grandiose]] . hasMoreElements ( ) ) { final String attrName = [[grandiose]] . nextElement ( ) ; [[intentions]] . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object [[danish]] = [[clod]] . getAttribute ( attrName ) ; target . writeValue ( name , [[danish]] , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 714 ---------------------------------------------
Inject request parameters . --> Generates storyboards --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectParameters]] ( final HttpServletRequest [[servletRequest]] , final Targets [[targets]] ) { final boolean encode = encodeGetParams && [[servletRequest]] . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = [[servletRequest]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( paramName ) != null ) { continue ; } [[targets]] . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = [[servletRequest]] . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void [[storyboards]] ( final HttpServletRequest [[wham]] , final Targets [[aspires]] ) { final boolean encode = encodeGetParams && [[wham]] . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = [[wham]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( [[wham]] . getAttribute ( paramName ) != null ) { continue ; } [[aspires]] . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = [[wham]] . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 715 ---------------------------------------------
Registers a hint . --> Register all hints --> Socre: 1.0

[[[[Adv]]]]: public void registerHint ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void registerHint ( final String [[alluding]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[alluding]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 716 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 679 / 19 / 18 / 716:  72%|███████▏  | 716/1000 [4:18:47<1:42:38, 21.69s/it][Succeeded / Failed / Skipped / Total] 679 / 19 / 18 / 716:  72%|███████▏  | 717/1000 [4:18:59<1:42:13, 21.67s/it][Succeeded / Failed / Skipped / Total] 680 / 19 / 18 / 717:  72%|███████▏  | 717/1000 [4:18:59<1:42:13, 21.67s/it][Succeeded / Failed / Skipped / Total] 680 / 19 / 18 / 717:  72%|███████▏  | 718/1000 [4:19:03<1:41:44, 21.65s/it][Succeeded / Failed / Skipped / Total] 681 / 19 / 18 / 718:  72%|███████▏  | 718/1000 [4:19:03<1:41:44, 21.65s/it][Succeeded / Failed / Skipped / Total] 681 / 19 / 18 / 718:  72%|███████▏  | 719/1000 [4:19:13<1:41:18, 21.63s/it][Succeeded / Failed / Skipped / Total] 682 / 19 / 18 / 719:  72%|███████▏  | 719/1000 [4:19:13<1:41:18, 21.63s/it][Succeeded / Failed / Skipped / Total] 682 / 19 / 18 / 719:  72%|███████▏  | 720/1000 [4:19:19<1:40:50, 21.61s/it][Succeeded / Failed / Skipped / Total] 683 / 19 / 18 / 720:  72%|███████▏  | 720/1000 [4:19:19<1:40:50, 21.61s/it][Succeeded / Failed / Skipped / Total] 683 / 19 / 18 / 720:  72%|███████▏  | 721/1000 [4:19:42<1:40:29, 21.61s/it]Convert property name to column name . --> closing a bowerbird --> Socre: 1.0

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder [[tableName]] = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[convertedTableName]] = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; [[tableName]] . append ( [[convertedTableName]] ) ; } else { [[tableName]] . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return [[tableName]] . toString ( ) ; } return uppercase ? toUppercase ( [[tableName]] ) . toString ( ) : toLowercase ( [[tableName]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[clacking]] ( final String [[bowerbird]] ) { StringBuilder [[injection]] = new StringBuilder ( [[bowerbird]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[cellulite]] = Format . fromCamelCase ( [[bowerbird]] , separatorChar ) ; [[injection]] . append ( [[cellulite]] ) ; } else { [[injection]] . append ( [[bowerbird]] ) ; } if ( ! changeCase ) { return [[injection]] . toString ( ) ; } return uppercase ? toUppercase ( [[injection]] ) . toString ( ) : toLowercase ( [[injection]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 717 ---------------------------------------------
Inject uploaded files . --> Convenience method for Servlet --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectUploadedFiles]] ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper [[multipartRequest]] = ( MultipartRequestWrapper ) servletRequest ; if ( ! [[multipartRequest]] . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = [[multipartRequest]] . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = [[multipartRequest]] . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object [[value]] = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , [[value]] , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void [[vrindavan]] ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper [[flamenco]] = ( MultipartRequestWrapper ) servletRequest ; if ( ! [[flamenco]] . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = [[flamenco]] . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = [[flamenco]] . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object [[evaluate]] = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , [[evaluate]] , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 718 ---------------------------------------------
Apply to column name --> Methode permettant d depleting --> Socre: 1.0

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String [[columnName]] ) { String propertyName = convertColumnNameToPropertyName ( [[columnName]] ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[aristophanes]] ( final String [[depleting]] ) { String propertyName = convertColumnNameToPropertyName ( [[depleting]] ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 719 ---------------------------------------------
Store object . --> Convenience method for setting henpe --> Socre: 1.0

[[[[Adv]]]]: public void [[storeValue]] ( final PreparedStatement st , final int index , final Object [[value]] , final int [[dbSqlType]] ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( [[value]] , sqlType ) ; set ( st , index , t , [[dbSqlType]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void [[henpecked]] ( final PreparedStatement st , final int index , final Object [[rating]] , final int [[anguish]] ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( [[rating]] , sqlType ) ; set ( st , index , t , [[anguish]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 720 ---------------------------------------------
Convert a column name to a property name . --> Identify camel case --> Socre: 1.0

[[[[Adv]]]]: public String [[convertColumnNameToPropertyName]] ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean [[toUpper]] = "[[False]]" != "[[False]]" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { [[toUpper]] = "[[True]]" == "[[True]]" ; continue ; } if ( [[toUpper]] ) { propertyName . append ( Character . toUpperCase ( c ) ) ; [[toUpper]] = "[[False]]" != "[[False]]" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String [[uruk]] ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean [[strangled]] = "[[Fraudulent]]" != "[[Fraudulent]]" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { [[strangled]] = "[[Concrete]]" == "[[Concrete]]" ; continue ; } if ( [[strangled]] ) { propertyName . append ( Character . toUpperCase ( c ) ) ; [[strangled]] = "[[Fraudulent]]" != "[[Fraudulent]]" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 721 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 683 / 20 / 18 / 721:  72%|███████▏  | 721/1000 [4:19:42<1:40:29, 21.61s/it][Succeeded / Failed / Skipped / Total] 683 / 20 / 18 / 721:  72%|███████▏  | 722/1000 [4:20:01<1:40:07, 21.61s/it][Succeeded / Failed / Skipped / Total] 684 / 20 / 18 / 722:  72%|███████▏  | 722/1000 [4:20:01<1:40:07, 21.61s/it][Succeeded / Failed / Skipped / Total] 684 / 20 / 18 / 722:  72%|███████▏  | 723/1000 [4:20:03<1:39:38, 21.58s/it][Succeeded / Failed / Skipped / Total] 684 / 21 / 18 / 723:  72%|███████▏  | 723/1000 [4:20:03<1:39:38, 21.58s/it][Succeeded / Failed / Skipped / Total] 684 / 21 / 18 / 723:  72%|███████▏  | 724/1000 [4:20:06<1:39:09, 21.56s/it][Succeeded / Failed / Skipped / Total] 685 / 21 / 18 / 724:  72%|███████▏  | 724/1000 [4:20:06<1:39:09, 21.56s/it][Succeeded / Failed / Skipped / Total] 685 / 21 / 18 / 724:  72%|███████▎  | 725/1000 [4:20:12<1:38:41, 21.53s/it][Succeeded / Failed / Skipped / Total] 686 / 21 / 18 / 725:  72%|███████▎  | 725/1000 [4:20:12<1:38:41, 21.53s/it][Succeeded / Failed / Skipped / Total] 686 / 21 / 18 / 725:  73%|███████▎  | 726/1000 [4:20:32<1:38:19, 21.53s/it][Succeeded / Failed / Skipped / Total] 686 / 22 / 18 / 726:  73%|███████▎  | 726/1000 [4:20:32<1:38:19, 21.53s/it][Succeeded / Failed / Skipped / Total] 686 / 22 / 18 / 726:  73%|███████▎  | 727/1000 [4:20:43<1:37:54, 21.52s/it][Succeeded / Failed / Skipped / Total] 687 / 22 / 18 / 727:  73%|███████▎  | 727/1000 [4:20:43<1:37:54, 21.52s/it][Succeeded / Failed / Skipped / Total] 687 / 22 / 18 / 727:  73%|███████▎  | 728/1000 [4:20:43<1:37:24, 21.49s/it][Succeeded / Failed / Skipped / Total] 687 / 22 / 19 / 728:  73%|███████▎  | 728/1000 [4:20:43<1:37:24, 21.49s/it][Succeeded / Failed / Skipped / Total] 687 / 22 / 19 / 728:  73%|███████▎  | 729/1000 [4:20:58<1:37:00, 21.48s/it][Succeeded / Failed / Skipped / Total] 688 / 22 / 19 / 729:  73%|███████▎  | 729/1000 [4:20:58<1:37:00, 21.48s/it][Succeeded / Failed / Skipped / Total] 688 / 22 / 19 / 729:  73%|███████▎  | 730/1000 [4:21:02<1:36:32, 21.45s/it][Succeeded / Failed / Skipped / Total] 689 / 22 / 19 / 730:  73%|███████▎  | 730/1000 [4:21:02<1:36:32, 21.45s/it][Succeeded / Failed / Skipped / Total] 689 / 22 / 19 / 730:  73%|███████▎  | 731/1000 [4:21:03<1:36:04, 21.43s/it]Prepare get value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 722 ---------------------------------------------
Gets all wrappers . --> Methode permettant de la estodo --> Socre: 1.0

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[estúpido]] ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 723 ---------------------------------------------
Start a DELETE request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest delete ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest delete ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 724 ---------------------------------------------
Transform a path to system . --> Turns a path into a shikai --> Socre: 1.0

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[shikai]] ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 725 ---------------------------------------------
Gets the path . --> Retrieves a clearting string --> Socre: 1.0

[[[[Adv]]]]: private static String [[doGetPath]] ( final String [[filename]] , final int [[separatorAdd]] ) { if ( [[filename]] == null ) { return null ; } int [[prefix]] = getPrefixLength ( [[filename]] ) ; if ( [[prefix]] < 0 ) { return null ; } int index = indexOfLastSeparator ( [[filename]] ) ; int [[endIndex]] = index + [[separatorAdd]] ; if ( [[prefix]] >= [[filename]] . length ( ) || index < 0 || [[prefix]] >= [[endIndex]] ) { return StringPool . EMPTY ; } return [[filename]] . substring ( [[prefix]] , [[endIndex]] ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String [[notification]] ( final String [[crumbling]] , final int [[prospective]] ) { if ( [[crumbling]] == null ) { return null ; } int [[nonce]] = getPrefixLength ( [[crumbling]] ) ; if ( [[nonce]] < 0 ) { return null ; } int index = indexOfLastSeparator ( [[crumbling]] ) ; int [[depressions]] = index + [[prospective]] ; if ( [[nonce]] >= [[crumbling]] . length ( ) || index < 0 || [[nonce]] >= [[depressions]] ) { return StringPool . EMPTY ; } return [[crumbling]] . substring ( [[nonce]] , [[depressions]] ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 726 ---------------------------------------------
Creates a new instance of the specified class . --> [[[FAILED]]]

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 727 ---------------------------------------------
Relative path . --> convert from Scolding --> Socre: 1.0

[[[[Adv]]]]: public static String [[relativePath]] ( final String [[targetPath]] , final String [[basePath]] ) { return new File ( [[basePath]] ) . toPath ( ) . relativize ( new File ( [[targetPath]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[devilishly]] ( final String [[scolding]] , final String [[tampon]] ) { return new File ( [[tampon]] ) . toPath ( ) . relativize ( new File ( [[scolding]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 728 ---------------------------------------------
Register a Component --> [[[SKIPPED]]]

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 729 ---------------------------------------------
Resolves a wrapper class . --> Declarative constructor --> Socre: 1.0

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > [[wrapperClass]] ) { String [[wrapperClassName]] = [[wrapperClass]] . getName ( ) ; T wrapper = lookup ( [[wrapperClassName]] ) ; if ( wrapper == null ) { wrapper = createWrapper ( [[wrapperClass]] ) ; initializeWrapper ( wrapper ) ; wrappers . put ( [[wrapperClassName]] , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[finalizing]] ( final Class < ? extends T > [[eradicated]] ) { String [[diary]] = [[eradicated]] . getName ( ) ; T wrapper = lookup ( [[diary]] ) ; if ( wrapper == null ) { wrapper = createWrapper ( [[eradicated]] ) ; initializeWrapper ( wrapper ) ; wrappers . put ( [[diary]] , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 730 ---------------------------------------------
Starts the daemon . --> Initialize the view --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[initial]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 731 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 690 / 22 / 19 / 731:  73%|███████▎  | 731/1000 [4:21:03<1:36:04, 21.43s/it][Succeeded / Failed / Skipped / Total] 690 / 22 / 19 / 731:  73%|███████▎  | 732/1000 [4:21:05<1:35:35, 21.40s/it][Succeeded / Failed / Skipped / Total] 691 / 22 / 19 / 732:  73%|███████▎  | 732/1000 [4:21:05<1:35:35, 21.40s/it][Succeeded / Failed / Skipped / Total] 691 / 22 / 19 / 732:  73%|███████▎  | 733/1000 [4:21:14<1:35:09, 21.38s/it][Succeeded / Failed / Skipped / Total] 691 / 23 / 19 / 733:  73%|███████▎  | 733/1000 [4:21:14<1:35:09, 21.38s/it][Succeeded / Failed / Skipped / Total] 691 / 23 / 19 / 733:  73%|███████▎  | 734/1000 [4:21:14<1:34:40, 21.36s/it][Succeeded / Failed / Skipped / Total] 692 / 23 / 19 / 734:  73%|███████▎  | 734/1000 [4:21:14<1:34:40, 21.36s/it][Succeeded / Failed / Skipped / Total] 692 / 23 / 19 / 734:  74%|███████▎  | 735/1000 [4:21:22<1:34:14, 21.34s/it][Succeeded / Failed / Skipped / Total] 693 / 23 / 19 / 735:  74%|███████▎  | 735/1000 [4:21:22<1:34:14, 21.34s/it][Succeeded / Failed / Skipped / Total] 693 / 23 / 19 / 735:  74%|███████▎  | 736/1000 [4:21:25<1:33:46, 21.31s/it][Succeeded / Failed / Skipped / Total] 694 / 23 / 19 / 736:  74%|███████▎  | 736/1000 [4:21:25<1:33:46, 21.31s/it][Succeeded / Failed / Skipped / Total] 694 / 23 / 19 / 736:  74%|███████▎  | 737/1000 [4:21:36<1:33:21, 21.30s/it][Succeeded / Failed / Skipped / Total] 695 / 23 / 19 / 737:  74%|███████▎  | 737/1000 [4:21:36<1:33:21, 21.30s/it][Succeeded / Failed / Skipped / Total] 695 / 23 / 19 / 737:  74%|███████▍  | 738/1000 [4:22:22<1:33:08, 21.33s/it]Configure default values . --> Registers the jav container annotations --> Socre: 1.0

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager [[actionConfigManager]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[actionConfigManager]] . registerAnnotation ( Action . class ) ; [[actionConfigManager]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[vestiges]] ( ) { final ActionConfigManager [[indentation]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[indentation]] . registerAnnotation ( Action . class ) ; [[indentation]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 732 ---------------------------------------------
Registers the madvoc container . --> Register the radva container --> Socre: 1.0

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[radha]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 733 ---------------------------------------------
Define an action config manager . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 734 ---------------------------------------------
Exclude specified jars . --> Remove all classes from the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... [[excludedJars]] ) { for ( final String excludedJar : [[excludedJars]] ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[beckford]] ( final String ... [[orphanage]] ) { for ( final String excludedJar : [[orphanage]] ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 735 ---------------------------------------------
Includes the specified jars . --> include heron jar --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner includeJars ( final String ... [[includedJars]] ) { for ( final String [[includedJar]] : [[includedJars]] ) { rulesJars . include ( [[includedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner includeJars ( final String ... [[morna]] ) { for ( final String [[artery]] : [[morna]] ) { rulesJars . include ( [[artery]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 736 ---------------------------------------------
Exclude entries . --> Removes all rules from the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeEntries]] ( final String ... [[excludedEntries]] ) { for ( final String [[excludedEntry]] : [[excludedEntries]] ) { rulesEntries . exclude ( [[excludedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner [[yuriko]] ( final String ... [[induced]] ) { for ( final String [[staggered]] : [[induced]] ) { rulesEntries . exclude ( [[staggered]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 737 ---------------------------------------------
Returns the named property . --> Methode permettant d une propriete --> Socre: 1.0

[[[[Adv]]]]: @ Override public < [[T]] > [[T]] getProperty ( final Object bean , final String name ) { BeanProperty [[beanProperty]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } else { try { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < [[could]] > [[could]] getProperty ( final Object bean , final String name ) { BeanProperty [[meditation]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[meditation]] ) ; return ( [[could]] ) getIndexProperty ( [[meditation]] ) ; } else { try { resolveNestedProperties ( [[meditation]] ) ; return ( [[could]] ) getIndexProperty ( [[meditation]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 738 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 696 / 23 / 19 / 738:  74%|███████▍  | 738/1000 [4:22:22<1:33:08, 21.33s/it][Succeeded / Failed / Skipped / Total] 696 / 23 / 19 / 738:  74%|███████▍  | 739/1000 [4:22:49<1:32:49, 21.34s/it][Succeeded / Failed / Skipped / Total] 697 / 23 / 19 / 739:  74%|███████▍  | 739/1000 [4:22:49<1:32:49, 21.34s/it][Succeeded / Failed / Skipped / Total] 697 / 23 / 19 / 739:  74%|███████▍  | 740/1000 [4:22:53<1:32:21, 21.32s/it][Succeeded / Failed / Skipped / Total] 698 / 23 / 19 / 740:  74%|███████▍  | 740/1000 [4:22:53<1:32:21, 21.32s/it][Succeeded / Failed / Skipped / Total] 698 / 23 / 19 / 740:  74%|███████▍  | 741/1000 [4:22:59<1:31:55, 21.29s/it][Succeeded / Failed / Skipped / Total] 699 / 23 / 19 / 741:  74%|███████▍  | 741/1000 [4:22:59<1:31:55, 21.29s/it][Succeeded / Failed / Skipped / Total] 699 / 23 / 19 / 741:  74%|███████▍  | 742/1000 [4:23:02<1:31:27, 21.27s/it][Succeeded / Failed / Skipped / Total] 700 / 23 / 19 / 742:  74%|███████▍  | 742/1000 [4:23:02<1:31:27, 21.27s/it][Succeeded / Failed / Skipped / Total] 700 / 23 / 19 / 742:  74%|███████▍  | 743/1000 [4:23:10<1:31:01, 21.25s/it][Succeeded / Failed / Skipped / Total] 701 / 23 / 19 / 743:  74%|███████▍  | 743/1000 [4:23:10<1:31:01, 21.25s/it][Succeeded / Failed / Skipped / Total] 701 / 23 / 19 / 743:  74%|███████▍  | 744/1000 [4:23:18<1:30:35, 21.23s/it]Includes given entries . --> Add include entries to the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[tellin]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 739 ---------------------------------------------
Splits a filename into parts . --> split the limous lines --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] split ( final String [[filename]] ) { String [[prefix]] = getPrefix ( [[filename]] ) ; if ( [[prefix]] == null ) { [[prefix]] = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( [[filename]] ) ; int [[lastExtensionIndex]] = indexOfExtension ( [[filename]] ) ; String [[path]] ; String [[baseName]] ; String extension ; if ( lastSeparatorIndex == - 1 ) { [[path]] = StringPool . EMPTY ; if ( [[lastExtensionIndex]] == - 1 ) { [[baseName]] = [[filename]] . substring ( [[prefix]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { [[baseName]] = [[filename]] . substring ( [[prefix]] . length ( ) , [[lastExtensionIndex]] ) ; extension = [[filename]] . substring ( [[lastExtensionIndex]] + 1 ) ; } } else { [[path]] = [[filename]] . substring ( [[prefix]] . length ( ) , lastSeparatorIndex + 1 ) ; if ( [[lastExtensionIndex]] == - 1 ) { [[baseName]] = [[filename]] . substring ( [[prefix]] . length ( ) + [[path]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { [[baseName]] = [[filename]] . substring ( [[prefix]] . length ( ) + [[path]] . length ( ) , [[lastExtensionIndex]] ) ; extension = [[filename]] . substring ( [[lastExtensionIndex]] + 1 ) ; } } return new String [ ] { [[prefix]] , [[path]] , [[baseName]] , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] split ( final String [[limousines]] ) { String [[zeros]] = getPrefix ( [[limousines]] ) ; if ( [[zeros]] == null ) { [[zeros]] = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( [[limousines]] ) ; int [[gearhart]] = indexOfExtension ( [[limousines]] ) ; String [[driveways]] ; String [[iguana]] ; String extension ; if ( lastSeparatorIndex == - 1 ) { [[driveways]] = StringPool . EMPTY ; if ( [[gearhart]] == - 1 ) { [[iguana]] = [[limousines]] . substring ( [[zeros]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { [[iguana]] = [[limousines]] . substring ( [[zeros]] . length ( ) , [[gearhart]] ) ; extension = [[limousines]] . substring ( [[gearhart]] + 1 ) ; } } else { [[driveways]] = [[limousines]] . substring ( [[zeros]] . length ( ) , lastSeparatorIndex + 1 ) ; if ( [[gearhart]] == - 1 ) { [[iguana]] = [[limousines]] . substring ( [[zeros]] . length ( ) + [[driveways]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { [[iguana]] = [[limousines]] . substring ( [[zeros]] . length ( ) + [[driveways]] . length ( ) , [[gearhart]] ) ; extension = [[limousines]] . substring ( [[gearhart]] + 1 ) ; } } return new String [ ] { [[zeros]] , [[driveways]] , [[iguana]] , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 740 ---------------------------------------------
Compute the signature of a type . --> Generate mcgin name --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[mcginnis]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 741 ---------------------------------------------
Scans classpath for class files . --> needs to be indexed --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanClassPath]] ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void [[tï]] ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 742 ---------------------------------------------
Creates a new JtxTransaction --> overriding this method --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode [[tm]] , final Object [[scope]] , final boolean active ) { return new DbJtxTransaction ( this , [[tm]] , [[scope]] , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode [[jebel]] , final Object [[range]] , final boolean active ) { return new DbJtxTransaction ( this , [[jebel]] , [[range]] , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 743 ---------------------------------------------
Scan the given paths . --> Add classes to the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... [[paths]] ) { for ( final String path : [[paths]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[exploring]] ( final String ... [[routed]] ) { for ( final String path : [[routed]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 744 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 702 / 23 / 19 / 744:  74%|███████▍  | 744/1000 [4:23:18<1:30:35, 21.23s/it][Succeeded / Failed / Skipped / Total] 702 / 23 / 19 / 744:  74%|███████▍  | 745/1000 [4:23:21<1:30:08, 21.21s/it][Succeeded / Failed / Skipped / Total] 703 / 23 / 19 / 745:  74%|███████▍  | 745/1000 [4:23:21<1:30:08, 21.21s/it][Succeeded / Failed / Skipped / Total] 703 / 23 / 19 / 745:  75%|███████▍  | 746/1000 [4:23:34<1:29:44, 21.20s/it][Succeeded / Failed / Skipped / Total] 704 / 23 / 19 / 746:  75%|███████▍  | 746/1000 [4:23:34<1:29:44, 21.20s/it][Succeeded / Failed / Skipped / Total] 704 / 23 / 19 / 746:  75%|███████▍  | 747/1000 [4:23:37<1:29:17, 21.17s/it][Succeeded / Failed / Skipped / Total] 704 / 24 / 19 / 747:  75%|███████▍  | 747/1000 [4:23:37<1:29:17, 21.17s/it][Succeeded / Failed / Skipped / Total] 704 / 24 / 19 / 747:  75%|███████▍  | 748/1000 [4:23:48<1:28:52, 21.16s/it][Succeeded / Failed / Skipped / Total] 705 / 24 / 19 / 748:  75%|███████▍  | 748/1000 [4:23:48<1:28:52, 21.16s/it][Succeeded / Failed / Skipped / Total] 705 / 24 / 19 / 748:  75%|███████▍  | 749/1000 [4:25:00<1:28:48, 21.23s/it][Succeeded / Failed / Skipped / Total] 706 / 24 / 19 / 749:  75%|███████▍  | 749/1000 [4:25:00<1:28:48, 21.23s/it][Succeeded / Failed / Skipped / Total] 706 / 24 / 19 / 749:  75%|███████▌  | 750/1000 [4:25:39<1:28:33, 21.25s/it]Scan the specified files . --> Lancer load --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[path]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[path]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[lancer]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[itineraries]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[itineraries]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 745 ---------------------------------------------
Creates a new madvoc scope for the specified type . --> Implemented with GinvocScope --> Socre: 1.0

[[[[Adv]]]]: public void [[forScope]] ( final Class < ? extends MadvocScope > [[scopeType]] , final Consumer < MadvocScope > [[madvocScopeConsumer]] ) { final MadvocScope scope = getOrInitScope ( [[scopeType]] ) ; [[madvocScopeConsumer]] . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void [[halal]] ( final Class < ? extends MadvocScope > [[ideological]] , final Consumer < MadvocScope > [[wilkie]] ) { final MadvocScope scope = getOrInitScope ( [[ideological]] ) ; [[wilkie]] . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 746 ---------------------------------------------
Decodes a byte array . --> Returns the unraveling sequence of characters --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[decode]] ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int [[cnt]] = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? [[cnt]] / 78 : 0 ) << 1 : 0 ; int [[len]] = ( ( [[cnt]] - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ [[len]] ] ; int d = 0 ; for ( int cc = 0 , eLen = ( [[len]] / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < [[len]] ) { int i = 0 ; for ( int [[j]] = 0 ; sndx <= endx - pad ; [[j]] ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - [[j]] * 6 ) ; } for ( int r = 16 ; d < [[len]] ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] [[unraveling]] ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int [[anythng]] = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? [[anythng]] / 78 : 0 ) << 1 : 0 ; int [[pure]] = ( ( [[anythng]] - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ [[pure]] ] ; int d = 0 ; for ( int cc = 0 , eLen = ( [[pure]] / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < [[pure]] ) { int i = 0 ; for ( int [[k]] = 0 ; sndx <= endx - pad ; [[k]] ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - [[k]] * 6 ) ; } for ( int r = 16 ; d < [[pure]] ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 747 ---------------------------------------------
Get or initialize scope type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 748 ---------------------------------------------
Creates a CSRF token . --> Implements landmarking --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[prepareCsrfToken]] ( final HttpSession [[session]] , final int timeToLive ) { Set < Token > [[tokenSet]] = ( Set < Token > ) [[session]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[tokenSet]] == null ) { [[tokenSet]] = new HashSet <> ( ) ; [[session]] . setAttribute ( CSRF_TOKEN_SET , [[tokenSet]] ) ; } String value ; boolean [[unique]] ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[tokenSet]] ) ; [[unique]] = [[tokenSet]] . add ( new Token ( value , timeToLive ) ) ; } while ( ! [[unique]] ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[impious]] ( final HttpSession [[debriefing]] , final int timeToLive ) { Set < Token > [[scrutiny]] = ( Set < Token > ) [[debriefing]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[scrutiny]] == null ) { [[scrutiny]] = new HashSet <> ( ) ; [[debriefing]] . setAttribute ( CSRF_TOKEN_SET , [[scrutiny]] ) ; } String value ; boolean [[unprecedented]] ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[scrutiny]] ) ; [[unprecedented]] = [[scrutiny]] . add ( new Token ( value , timeToLive ) ) ; } while ( ! [[unprecedented]] ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 749 ---------------------------------------------
Gets the scope of the specified class . --> copied from ArvocScope --> Socre: 1.0

[[[[Adv]]]]: protected MadvocScope [[getOrInitScope]] ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope [[s]] : allScopes ) { if ( [[s]] . getClass ( ) . equals ( madvocScopeType ) ) { return [[s]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope [[coped]] ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope [[dans]] : allScopes ) { if ( [[dans]] . getClass ( ) . equals ( madvocScopeType ) ) { return [[dans]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 750 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 707 / 24 / 19 / 750:  75%|███████▌  | 750/1000 [4:25:39<1:28:33, 21.25s/it][Succeeded / Failed / Skipped / Total] 707 / 24 / 19 / 750:  75%|███████▌  | 751/1000 [4:25:48<1:28:07, 21.24s/it][Succeeded / Failed / Skipped / Total] 708 / 24 / 19 / 751:  75%|███████▌  | 751/1000 [4:25:48<1:28:07, 21.24s/it][Succeeded / Failed / Skipped / Total] 708 / 24 / 19 / 751:  75%|███████▌  | 752/1000 [4:25:53<1:27:41, 21.21s/it][Succeeded / Failed / Skipped / Total] 709 / 24 / 19 / 752:  75%|███████▌  | 752/1000 [4:25:53<1:27:41, 21.21s/it][Succeeded / Failed / Skipped / Total] 709 / 24 / 19 / 752:  75%|███████▌  | 753/1000 [4:25:59<1:27:14, 21.19s/it][Succeeded / Failed / Skipped / Total] 710 / 24 / 19 / 753:  75%|███████▌  | 753/1000 [4:25:59<1:27:14, 21.19s/it][Succeeded / Failed / Skipped / Total] 710 / 24 / 19 / 753:  75%|███████▌  | 754/1000 [4:26:02<1:26:48, 21.17s/it][Succeeded / Failed / Skipped / Total] 711 / 24 / 19 / 754:  75%|███████▌  | 754/1000 [4:26:02<1:26:48, 21.17s/it][Succeeded / Failed / Skipped / Total] 711 / 24 / 19 / 754:  76%|███████▌  | 755/1000 [4:26:10<1:26:22, 21.15s/it]Create a deep copy of the given object . --> Deserialize an object --> Socre: 1.0

[[[[Adv]]]]: public static BeanCopy [[from]] ( final Object source ) { BeanCopy [[beanCopy]] = new BeanCopy ( source ) ; [[beanCopy]] . isSourceMap = source instanceof Map ; return [[beanCopy]] ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy [[des]] ( final Object source ) { BeanCopy [[ö]] = new BeanCopy ( source ) ; [[ö]] . isSourceMap = source instanceof Map ; return [[ö]] ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 751 ---------------------------------------------
Scans a jar file . --> Gets the baghad --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanJarFile]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String [[zipEntryName]] = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( [[zipEntryName]] , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( [[zipEntryName]] , "[[True]]" == "[[True]]" ) ; final ClassPathEntry [[classPathEntry]] = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( [[classPathEntry]] ) ; } finally { [[classPathEntry]] . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( [[zipEntryName]] , "False" != "False" ) ; final ClassPathEntry [[classPathEntry]] = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( [[classPathEntry]] ) ; } finally { [[classPathEntry]] . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void [[baghdad]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String [[aeria]] = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( [[aeria]] , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( [[aeria]] , "[[Valid]]" == "[[Valid]]" ) ; final ClassPathEntry [[preexisting]] = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( [[preexisting]] ) ; } finally { [[preexisting]] . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( [[aeria]] , "False" != "False" ) ; final ClassPathEntry [[preexisting]] = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( [[preexisting]] ) ; } finally { [[preexisting]] . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 752 ---------------------------------------------
Make this bean . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public void [[copy]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[True]]" == "[[True]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void [[engravings]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[Honest]]" == "[[Honest]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 753 ---------------------------------------------
Initializes the entity reference . --> Looks up the TemplateData for the TemplateData --> Socre: 1.0

[[[[Adv]]]]: @ Override public void init ( final TemplateData [[templateData]] ) { super . init ( [[templateData]] ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = [[templateData]] . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } [[templateData]] . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData [[reimbursement]] ) { super . init ( [[reimbursement]] ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = [[reimbursement]] . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } [[reimbursement]] . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 754 ---------------------------------------------
Make sure the token has expired . --> Checks the watercolours --> Socre: 1.0

[[[[Adv]]]]: protected static void [[assureSize]] ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token [[tokenToRemove]] = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; [[tokenToRemove]] = token ; } } if ( ( [[tokenToRemove]] != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( [[tokenToRemove]] ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void [[watercolours]] ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token [[artery]] = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; [[artery]] = token ; } } if ( ( [[artery]] != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( [[artery]] ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 755 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 712 / 24 / 19 / 755:  76%|███████▌  | 755/1000 [4:26:10<1:26:22, 21.15s/it][Succeeded / Failed / Skipped / Total] 712 / 24 / 19 / 755:  76%|███████▌  | 756/1000 [4:26:17<1:25:56, 21.13s/it][Succeeded / Failed / Skipped / Total] 713 / 24 / 19 / 756:  76%|███████▌  | 756/1000 [4:26:17<1:25:56, 21.13s/it][Succeeded / Failed / Skipped / Total] 713 / 24 / 19 / 756:  76%|███████▌  | 757/1000 [4:26:26<1:25:31, 21.12s/it][Succeeded / Failed / Skipped / Total] 714 / 24 / 19 / 757:  76%|███████▌  | 757/1000 [4:26:26<1:25:31, 21.12s/it][Succeeded / Failed / Skipped / Total] 714 / 24 / 19 / 757:  76%|███████▌  | 758/1000 [4:26:31<1:25:05, 21.10s/it][Succeeded / Failed / Skipped / Total] 715 / 24 / 19 / 758:  76%|███████▌  | 758/1000 [4:26:31<1:25:05, 21.10s/it][Succeeded / Failed / Skipped / Total] 715 / 24 / 19 / 758:  76%|███████▌  | 759/1000 [4:26:46<1:24:42, 21.09s/it][Succeeded / Failed / Skipped / Total] 716 / 24 / 19 / 759:  76%|███████▌  | 759/1000 [4:26:46<1:24:42, 21.09s/it][Succeeded / Failed / Skipped / Total] 716 / 24 / 19 / 759:  76%|███████▌  | 760/1000 [4:26:54<1:24:17, 21.07s/it]Register a new petite bean . --> Reserved beans --> Socre: 1.0

[[[[Adv]]]]: public < T > BeanDefinition < T > [[registerPetiteBean]] ( final Class < T > [[type]] , String [[name]] , Class < ? extends Scope > [[scopeType]] , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[name]] == null ) { [[name]] = resolveBeanName ( [[type]] ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( [[type]] ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( [[scopeType]] == null ) { [[scopeType]] = annotationResolver . resolveBeanScopeType ( [[type]] ) ; } if ( [[scopeType]] == null ) { [[scopeType]] = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > [[unreservedly]] ( final Class < T > [[dude]] , String [[arabians]] , Class < ? extends Scope > [[pas]] , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[arabians]] == null ) { [[arabians]] = resolveBeanName ( [[dude]] ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( [[dude]] ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( [[pas]] == null ) { [[pas]] = annotationResolver . resolveBeanScopeType ( [[dude]] ) ; } if ( [[pas]] == null ) { [[pas]] = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 756 ---------------------------------------------
Checks whether the given value matches the given value . --> Check if any of the cookies in the current session has been poisoned --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[checkCsrfToken]] ( final HttpSession session , final String [[tokenValue]] ) { Set < Token > [[tokenSet]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( [[tokenSet]] == null ) && ( [[tokenValue]] == null ) ) { return "True" == "True" ; } if ( ( [[tokenSet]] == null ) || ( [[tokenValue]] == null ) ) { return "False" != "False" ; } boolean [[found]] = "False" != "False" ; Iterator < Token > it = [[tokenSet]] . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( [[tokenValue]] ) ) { it . remove ( ) ; [[found]] = "True" == "True" ; } } return [[found]] ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[anything]] ( final HttpSession session , final String [[poisons]] ) { Set < Token > [[shredding]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( [[shredding]] == null ) && ( [[poisons]] == null ) ) { return "True" == "True" ; } if ( ( [[shredding]] == null ) || ( [[poisons]] == null ) ) { return "False" != "False" ; } boolean [[founded]] = "False" != "False" ; Iterator < Token > it = [[shredding]] . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( [[poisons]] ) ) { it . remove ( ) ; [[founded]] = "True" == "True" ; } } return [[founded]] ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 757 ---------------------------------------------
Remove bean . --> the cambodian cambodian --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[cambodian]] ( final Class [[typewritten]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 758 ---------------------------------------------
Visit a property . --> Overrides dorel --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean [[visitProperty]] ( String [[name]] , final Object value ) { if ( isTargetMap ) { [[name]] = LEFT_SQ_BRACKET + [[name]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[name]] , value ) ; return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean [[dorel]] ( String [[appointees]] , final Object value ) { if ( isTargetMap ) { [[appointees]] = LEFT_SQ_BRACKET + [[appointees]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[appointees]] , value ) ; return "[[Genuine]]" == "[[Genuine]]" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 759 ---------------------------------------------
Register a bean . --> This decorator decorator method --> Socre: 1.0

[[[[Adv]]]]: protected void [[registerBean]] ( final String name , final BeanDefinition [[beanDefinition]] ) { beans . put ( name , [[beanDefinition]] ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class [[type]] = [[beanDefinition]] . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( [[type]] ) ) { return ; } Class [ ] [[interfaces]] = ClassUtil . resolveAllInterfaces ( [[type]] ) ; for ( Class anInterface : [[interfaces]] ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void [[decorator]] ( final String name , final BeanDefinition [[lufthansa]] ) { beans . put ( name , [[lufthansa]] ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class [[sexes]] = [[lufthansa]] . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( [[sexes]] ) ) { return ; } Class [ ] [[psychoanalysis]] = ClassUtil . resolveAllInterfaces ( [[sexes]] ) ; for ( Class anInterface : [[psychoanalysis]] ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 760 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 717 / 24 / 19 / 760:  76%|███████▌  | 760/1000 [4:26:54<1:24:17, 21.07s/it][Succeeded / Failed / Skipped / Total] 717 / 24 / 19 / 760:  76%|███████▌  | 761/1000 [4:27:01<1:23:51, 21.05s/it][Succeeded / Failed / Skipped / Total] 718 / 24 / 19 / 761:  76%|███████▌  | 761/1000 [4:27:01<1:23:51, 21.05s/it][Succeeded / Failed / Skipped / Total] 718 / 24 / 19 / 761:  76%|███████▌  | 762/1000 [4:27:04<1:23:25, 21.03s/it][Succeeded / Failed / Skipped / Total] 719 / 24 / 19 / 762:  76%|███████▌  | 762/1000 [4:27:04<1:23:25, 21.03s/it][Succeeded / Failed / Skipped / Total] 719 / 24 / 19 / 762:  76%|███████▋  | 763/1000 [4:27:12<1:22:59, 21.01s/it]Registers a new ctor injection point . --> Bottite a bean definition --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteCtorInjectionPoint]] ( final String [[beanName]] , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor [[constructor]] = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } [[constructor]] = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { [[constructor]] = ctorDescriptor . getConstructor ( ) ; } } if ( [[constructor]] == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( [[constructor]] , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( [[constructor]] , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void [[tako]] ( final String [[samsara]] , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[samsara]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor [[manufactures]] = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } [[manufactures]] = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { [[manufactures]] = ctorDescriptor . getConstructor ( ) ; } } if ( [[manufactures]] == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( [[manufactures]] , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( [[manufactures]] , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 761 ---------------------------------------------
Registers a set injection point --> Adds a setInjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteSetInjectionPoint]] ( final String beanName , final String property ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; PropertyDescriptor [[propertyDescriptor]] = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( [[propertyDescriptor]] == null ) { throw new PetiteException ( "Property not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[sip]] = new SetInjectionPoint ( [[propertyDescriptor]] ) ; [[beanDefinition]] . addSetInjectionPoint ( [[sip]] ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void [[synth]] ( final String beanName , final String property ) { BeanDefinition [[sidharth]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[sidharth]] . type ) ; PropertyDescriptor [[savin]] = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( [[savin]] == null ) { throw new PetiteException ( "Property not found: " + [[sidharth]] . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[vodka]] = new SetInjectionPoint ( [[savin]] ) ; [[sidharth]] . addSetInjectionPoint ( [[vodka]] ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 762 ---------------------------------------------
Resolve the names of the given type . --> Borrowed from a gravega --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[resolveBeanNamesForType]] ( final Class [[type]] ) { String [ ] [[beanNames]] = beanCollections . get ( [[type]] ) ; if ( [[beanNames]] != null ) { return [[beanNames]] ; } ArrayList < String > [[list]] = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[type]] ) ) { String beanName = entry . getKey ( ) ; [[list]] . add ( beanName ) ; } } if ( [[list]] . isEmpty ( ) ) { [[beanNames]] = StringPool . EMPTY_ARRAY ; } else { [[beanNames]] = [[list]] . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[type]] , [[beanNames]] ) ; return [[beanNames]] ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] [[berle]] ( final Class [[gaillard]] ) { String [ ] [[turok]] = beanCollections . get ( [[gaillard]] ) ; if ( [[turok]] != null ) { return [[turok]] ; } ArrayList < String > [[catalogued]] = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[gaillard]] ) ) { String beanName = entry . getKey ( ) ; [[catalogued]] . add ( beanName ) ; } } if ( [[catalogued]] . isEmpty ( ) ) { [[turok]] = StringPool . EMPTY_ARRAY ; } else { [[turok]] = [[catalogued]] . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[gaillard]] , [[turok]] ) ; return [[turok]] ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 763 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 720 / 24 / 19 / 763:  76%|███████▋  | 763/1000 [4:27:12<1:22:59, 21.01s/it][Succeeded / Failed / Skipped / Total] 720 / 24 / 19 / 763:  76%|███████▋  | 764/1000 [4:28:29<1:22:56, 21.09s/it][Succeeded / Failed / Skipped / Total] 721 / 24 / 19 / 764:  76%|███████▋  | 764/1000 [4:28:29<1:22:56, 21.09s/it][Succeeded / Failed / Skipped / Total] 721 / 24 / 19 / 764:  76%|███████▋  | 765/1000 [4:28:50<1:22:35, 21.09s/it][Succeeded / Failed / Skipped / Total] 722 / 24 / 19 / 765:  76%|███████▋  | 765/1000 [4:28:50<1:22:35, 21.09s/it][Succeeded / Failed / Skipped / Total] 722 / 24 / 19 / 765:  77%|███████▋  | 766/1000 [4:29:56<1:22:27, 21.14s/it]Registers new init methods for the specified bean . --> Instantiates a new bean definition --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteInitMethods]] ( final String beanName , final InitMethodInvocationStrategy [[invocationStrategy]] , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int [[total]] = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ [[total]] ] ; int [[i]] ; for ( [[i]] = 0 ; [[i]] < initMethodNames . length ; [[i]] ++ ) { MethodDescriptor [[md]] = cd . getMethodDescriptor ( initMethodNames [ [[i]] ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( [[md]] == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ [[i]] ] ) ; } initMethodPoints [ [[i]] ] = new InitMethodPoint ( [[md]] . getMethod ( ) , [[i]] , [[invocationStrategy]] ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void [[ways]] ( final String beanName , final InitMethodInvocationStrategy [[kie]] , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int [[altogether]] = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ [[altogether]] ] ; int [[let]] ; for ( [[let]] = 0 ; [[let]] < initMethodNames . length ; [[let]] ++ ) { MethodDescriptor [[emory]] = cd . getMethodDescriptor ( initMethodNames [ [[let]] ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( [[emory]] == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ [[let]] ] ) ; } initMethodPoints [ [[let]] ] = new InitMethodPoint ( [[emory]] . getMethod ( ) , [[let]] , [[kie]] ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 764 ---------------------------------------------
Registers a new property injection point --> Add a poison pill to an existing bean --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetitePropertyInjectionPoint]] ( final String beanName , final String property , final String [[reference]] ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , [[reference]] ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; [[beanDefinition]] . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void [[explosion]] ( final String beanName , final String property , final String [[hinting]] ) { BeanDefinition [[pesticide]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[pesticide]] . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + [[pesticide]] . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , [[hinting]] ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; [[pesticide]] . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 765 ---------------------------------------------
Registers a new Petite provider --> Register a new PetiteProvider --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] [[arguments]] ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class [[beanType]] = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanType]] ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[arguments]] , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] [[motives]] ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class [[prospective]] = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[prospective]] ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[motives]] , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 766 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 723 / 24 / 19 / 766:  77%|███████▋  | 766/1000 [4:29:56<1:22:27, 21.14s/it][Succeeded / Failed / Skipped / Total] 723 / 24 / 19 / 766:  77%|███████▋  | 767/1000 [4:30:07<1:22:03, 21.13s/it][Succeeded / Failed / Skipped / Total] 724 / 24 / 19 / 767:  77%|███████▋  | 767/1000 [4:30:07<1:22:03, 21.13s/it][Succeeded / Failed / Skipped / Total] 724 / 24 / 19 / 767:  77%|███████▋  | 768/1000 [4:30:07<1:21:36, 21.10s/it][Succeeded / Failed / Skipped / Total] 725 / 24 / 19 / 768:  77%|███████▋  | 768/1000 [4:30:07<1:21:36, 21.10s/it][Succeeded / Failed / Skipped / Total] 725 / 24 / 19 / 768:  77%|███████▋  | 769/1000 [4:30:27<1:21:14, 21.10s/it][Succeeded / Failed / Skipped / Total] 726 / 24 / 19 / 769:  77%|███████▋  | 769/1000 [4:30:27<1:21:14, 21.10s/it][Succeeded / Failed / Skipped / Total] 726 / 24 / 19 / 769:  77%|███████▋  | 770/1000 [4:30:27<1:20:47, 21.07s/it][Succeeded / Failed / Skipped / Total] 727 / 24 / 19 / 770:  77%|███████▋  | 770/1000 [4:30:27<1:20:47, 21.07s/it][Succeeded / Failed / Skipped / Total] 727 / 24 / 19 / 770:  77%|███████▋  | 771/1000 [4:30:46<1:20:25, 21.07s/it]Registers a destroy method for the specified bean . --> Make sure the given bean will be destroyed --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteDestroyMethods]] ( final String beanName , String ... [[destroyMethodNames]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( [[destroyMethodNames]] == null ) { [[destroyMethodNames]] = StringPool . EMPTY_ARRAY ; } int total = [[destroyMethodNames]] . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < [[destroyMethodNames]] . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( [[destroyMethodNames]] [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + [[destroyMethodNames]] [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void [[voluptuousness]] ( final String beanName , String ... [[powdering]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( [[powdering]] == null ) { [[powdering]] = StringPool . EMPTY_ARRAY ; } int total = [[powdering]] . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < [[powdering]] . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( [[powdering]] [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + [[powdering]] [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 767 ---------------------------------------------
Iterate over all beans of the given type . --> Generate bean name consumer --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class [[type]] , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[type]] ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[anglers]] ( final Class [[sorting]] , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[sorting]] ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 768 ---------------------------------------------
Register a provider with the given name and type . --> replaces all the items in a metap --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String [[providerName]] , final Class type , final String [[staticMethodName]] , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( [[staticMethodName]] , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + [[staticMethodName]] ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[providerName]] , md . getMethod ( ) ) ; providers . put ( [[providerName]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void [[papá]] ( final String [[sashes]] , final Class type , final String [[foods]] , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( [[foods]] , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + [[foods]] ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[sashes]] , md . getMethod ( ) ) ; providers . put ( [[sashes]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 769 ---------------------------------------------
Registers a new method in the given bean . --> Permission the Intermission --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteMethodInjectionPoint]] ( final String [[beanName]] , final String [[methodName]] , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[methodName]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + [[methodName]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[methodName]] , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + [[methodName]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void [[intermission]] ( final String [[normans]] , final String [[israelites]] , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[normans]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[israelites]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + [[israelites]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[israelites]] , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + [[israelites]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 770 ---------------------------------------------
Defines a set of parameters . --> Makes a nicomero --> Socre: 1.0

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[número]] ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 771 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 728 / 24 / 19 / 771:  77%|███████▋  | 771/1000 [4:30:46<1:20:25, 21.07s/it][Succeeded / Failed / Skipped / Total] 728 / 24 / 19 / 771:  77%|███████▋  | 772/1000 [4:30:47<1:19:58, 21.05s/it][Succeeded / Failed / Skipped / Total] 729 / 24 / 19 / 772:  77%|███████▋  | 772/1000 [4:30:47<1:19:58, 21.05s/it][Succeeded / Failed / Skipped / Total] 729 / 24 / 19 / 772:  77%|███████▋  | 773/1000 [4:30:53<1:19:33, 21.03s/it][Succeeded / Failed / Skipped / Total] 730 / 24 / 19 / 773:  77%|███████▋  | 773/1000 [4:30:53<1:19:33, 21.03s/it][Succeeded / Failed / Skipped / Total] 730 / 24 / 19 / 773:  77%|███████▋  | 774/1000 [4:30:58<1:19:07, 21.01s/it][Succeeded / Failed / Skipped / Total] 731 / 24 / 19 / 774:  77%|███████▋  | 774/1000 [4:30:58<1:19:07, 21.01s/it][Succeeded / Failed / Skipped / Total] 731 / 24 / 19 / 774:  78%|███████▊  | 775/1000 [4:31:17<1:18:45, 21.00s/it][Succeeded / Failed / Skipped / Total] 732 / 24 / 19 / 775:  78%|███████▊  | 775/1000 [4:31:17<1:18:45, 21.00s/it][Succeeded / Failed / Skipped / Total] 733 / 24 / 19 / 776:  78%|███████▊  | 776/1000 [4:31:17<1:18:18, 20.98s/it][Succeeded / Failed / Skipped / Total] 733 / 24 / 19 / 776:  78%|███████▊  | 777/1000 [4:31:19<1:17:52, 20.95s/it][Succeeded / Failed / Skipped / Total] 734 / 24 / 19 / 777:  78%|███████▊  | 777/1000 [4:31:19<1:17:52, 20.95s/it][Succeeded / Failed / Skipped / Total] 735 / 24 / 19 / 778:  78%|███████▊  | 778/1000 [4:31:20<1:17:25, 20.93s/it][Succeeded / Failed / Skipped / Total] 735 / 24 / 19 / 778:  78%|███████▊  | 779/1000 [4:31:27<1:17:00, 20.91s/it]Resolves java version . --> This method returns the number of formats supported by the platform --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int [[javaVersionNumber]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = [[javaVersionNumber]] - 8 + 52 ; return [[version]] > platformVersion ? [[version]] : platformVersion ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[caves]] ( final int [[formats]] ) { final int [[abacus]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = [[abacus]] - 8 + 52 ; return [[formats]] > platformVersion ? [[formats]] : platformVersion ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 772 ---------------------------------------------
Pushes an integer onto the stack . --> Methode permete --> Socre: 1.0

[[[[Adv]]]]: public static void [[pushInt]] ( final MethodVisitor [[mv]] , final int [[value]] ) { if ( [[value]] <= 5 ) { [[mv]] . visitInsn ( ICONST_0 + [[value]] ) ; } else if ( [[value]] <= Byte . MAX_VALUE ) { [[mv]] . visitIntInsn ( BIPUSH , [[value]] ) ; } else { [[mv]] . visitIntInsn ( SIPUSH , [[value]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void [[smythe]] ( final MethodVisitor [[spaceship]] , final int [[deserved]] ) { if ( [[deserved]] <= 5 ) { [[spaceship]] . visitInsn ( ICONST_0 + [[deserved]] ) ; } else if ( [[deserved]] <= Byte . MAX_VALUE ) { [[spaceship]] . visitIntInsn ( BIPUSH , [[deserved]] ) ; } else { [[spaceship]] . visitIntInsn ( SIPUSH , [[deserved]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 773 ---------------------------------------------
Get advice field name --> Loops off a number and cues --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String [[name]] , final int [[index]] ) { return ProxettaNames . fieldPrefix + [[name]] + ProxettaNames . fieldDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[shoeless]] ( final String [[numbers]] , final int [[cues]] ) { return ProxettaNames . fieldPrefix + [[numbers]] + ProxettaNames . fieldDivider + [[cues]] ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 774 ---------------------------------------------
Check that the given index is valid . --> Score the front of an array --> Socre: 1.0

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo methodInfo , final int [[argIndex]] ) { if ( ( [[argIndex]] < 1 ) || ( [[argIndex]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[argIndex]] ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[scored]] ( final MethodInfo methodInfo , final int [[beach]] ) { if ( ( [[beach]] < 1 ) || ( [[beach]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[beach]] ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 775 ---------------------------------------------
Load method arguments . --> load the jesscode stack --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int [[i]] = 1 ; [[i]] <= [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( mv , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[jess]] ( final MethodVisitor mv , final MethodInfo [[lochinvar]] ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int [[did]] = 1 ; [[did]] <= [[lochinvar]] . getArgumentsCount ( ) ; [[did]] ++ ) { loadMethodArgument ( mv , [[lochinvar]] , [[did]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 776 ---------------------------------------------
Get advice method name . --> a macbeth --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String name , final int [[index]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[macbeth]] ( final String name , final int [[pointing]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[pointing]] ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 777 ---------------------------------------------
Intercept the given action request . --> Protected method --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[intercept]] ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[actionRequest]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object [[prohibit]] ( final ActionRequest [[torpedoes]] ) throws Exception { printBefore ( [[torpedoes]] ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[torpedoes]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[torpedoes]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 778 ---------------------------------------------
Load static method arguments . --> Load bugles bugles --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[bugles]] ( final MethodVisitor [[commodore]] , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[commodore]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 779 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 736 / 24 / 19 / 779:  78%|███████▊  | 779/1000 [4:31:27<1:17:00, 20.91s/it][Succeeded / Failed / Skipped / Total] 737 / 24 / 19 / 780:  78%|███████▊  | 780/1000 [4:31:27<1:16:34, 20.88s/it][Succeeded / Failed / Skipped / Total] 737 / 24 / 19 / 780:  78%|███████▊  | 781/1000 [4:31:33<1:16:08, 20.86s/it][Succeeded / Failed / Skipped / Total] 738 / 24 / 19 / 781:  78%|███████▊  | 781/1000 [4:31:33<1:16:08, 20.86s/it][Succeeded / Failed / Skipped / Total] 739 / 24 / 19 / 782:  78%|███████▊  | 782/1000 [4:31:40<1:15:44, 20.85s/it][Succeeded / Failed / Skipped / Total] 739 / 24 / 19 / 782:  78%|███████▊  | 783/1000 [4:31:56<1:15:21, 20.84s/it][Succeeded / Failed / Skipped / Total] 740 / 24 / 19 / 783:  78%|███████▊  | 783/1000 [4:31:56<1:15:21, 20.84s/it][Succeeded / Failed / Skipped / Total] 740 / 24 / 19 / 783:  78%|███████▊  | 784/1000 [4:32:03<1:14:57, 20.82s/it]Store method argument . --> Generate commedia instructions --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeMethodArgument]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , final int [[index]] ) { int [[offset]] = [[methodInfo]] . getArgumentOffset ( [[index]] ) ; int [[type]] = [[methodInfo]] . getArgument ( [[index]] ) . getOpcode ( ) ; switch ( [[type]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , [[offset]] ) ; break ; default : mv . visitVarInsn ( ASTORE , [[offset]] ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[commedia]] ( final MethodVisitor mv , final MethodInfo [[blinkers]] , final int [[catalog]] ) { int [[compensates]] = [[blinkers]] . getArgumentOffset ( [[catalog]] ) ; int [[kinds]] = [[blinkers]] . getArgument ( [[catalog]] ) . getOpcode ( ) ; switch ( [[kinds]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , [[compensates]] ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , [[compensates]] ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , [[compensates]] ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , [[compensates]] ) ; break ; default : mv . visitVarInsn ( ASTORE , [[compensates]] ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 780 ---------------------------------------------
Load method argument . --> BLOAD instructions --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[brazil]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 781 ---------------------------------------------
Load all arguments for the given method . --> Load alivation of vender --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadVirtualMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { for ( int [[i]] = 1 ; [[i]] <= [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void [[veneration]] ( final MethodVisitor [[freighter]] , final MethodInfo [[vivienne]] ) { for ( int [[it]] = 1 ; [[it]] <= [[vivienne]] . getArgumentsCount ( ) ; [[it]] ++ ) { loadMethodArgument ( [[freighter]] , [[vivienne]] , [[it]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 782 ---------------------------------------------
Prepare return value . --> skip a method from a method --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , int varOffset ) { varOffset += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[snoot]] ( final MethodVisitor [[boat]] , final MethodInfo [[mariette]] , int varOffset ) { varOffset += [[mariette]] . getAllArgumentsSize ( ) ; switch ( [[mariette]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[boat]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[boat]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[boat]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[boat]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[boat]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[boat]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[boat]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[boat]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[boat]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 783 ---------------------------------------------
Generate new array --> Generates the instructions to visit a class --> Socre: 1.0

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[componentType]] ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[dishonoured]] ( final MethodVisitor mv , final Class [[maura]] ) { if ( [[maura]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[maura]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[maura]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[maura]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[maura]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[maura]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[maura]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[maura]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[maura]] ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 784 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 741 / 24 / 19 / 784:  78%|███████▊  | 784/1000 [4:32:03<1:14:57, 20.82s/it][Succeeded / Failed / Skipped / Total] 741 / 24 / 19 / 784:  78%|███████▊  | 785/1000 [4:32:03<1:14:30, 20.79s/it][Succeeded / Failed / Skipped / Total] 742 / 24 / 19 / 785:  78%|███████▊  | 785/1000 [4:32:03<1:14:30, 20.79s/it][Succeeded / Failed / Skipped / Total] 742 / 24 / 19 / 785:  79%|███████▊  | 786/1000 [4:32:11<1:14:06, 20.78s/it][Succeeded / Failed / Skipped / Total] 743 / 24 / 19 / 786:  79%|███████▊  | 786/1000 [4:32:11<1:14:06, 20.78s/it][Succeeded / Failed / Skipped / Total] 743 / 24 / 19 / 786:  79%|███████▊  | 787/1000 [4:32:18<1:13:42, 20.76s/it][Succeeded / Failed / Skipped / Total] 744 / 24 / 19 / 787:  79%|███████▊  | 787/1000 [4:32:18<1:13:42, 20.76s/it][Succeeded / Failed / Skipped / Total] 744 / 24 / 19 / 787:  79%|███████▉  | 788/1000 [4:32:34<1:13:19, 20.75s/it][Succeeded / Failed / Skipped / Total] 745 / 24 / 19 / 788:  79%|███████▉  | 788/1000 [4:32:34<1:13:19, 20.75s/it][Succeeded / Failed / Skipped / Total] 745 / 24 / 19 / 788:  79%|███████▉  | 789/1000 [4:32:47<1:12:57, 20.74s/it][Succeeded / Failed / Skipped / Total] 746 / 24 / 19 / 789:  79%|███████▉  | 789/1000 [4:32:47<1:12:57, 20.74s/it][Succeeded / Failed / Skipped / Total] 746 / 24 / 19 / 789:  79%|███████▉  | 790/1000 [4:32:49<1:12:31, 20.72s/it]Extracts the encoding from a content type --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String [[contentType]] , String [[defaultEncoding]] ) { String encoding = [[extractEncoding]] ( [[contentType]] ) ; if ( encoding == null ) { if ( [[defaultEncoding]] == null ) { [[defaultEncoding]] = JoddCore . encoding ; } encoding = [[defaultEncoding]] ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[shareholder]] ( final String [[scuse]] , String [[stumped]] ) { String encoding = [[shareholder]] ( [[scuse]] ) ; if ( encoding == null ) { if ( [[stumped]] == null ) { [[stumped]] = JoddCore . encoding ; } encoding = [[stumped]] ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 785 ---------------------------------------------
Store instruction into array . -->  tear down the instruction --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor [[mv]] , final Class componentType ) { if ( componentType == int . class ) { [[mv]] . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { [[mv]] . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { [[mv]] . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { [[mv]] . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { [[mv]] . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { [[mv]] . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { [[mv]] . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { [[mv]] . visitInsn ( CASTORE ) ; return ; } [[mv]] . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[tear]] ( final MethodVisitor [[submersibles]] , final Class componentType ) { if ( componentType == int . class ) { [[submersibles]] . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { [[submersibles]] . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { [[submersibles]] . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { [[submersibles]] . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { [[submersibles]] . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { [[submersibles]] . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { [[submersibles]] . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { [[submersibles]] . visitInsn ( CASTORE ) ; return ; } [[submersibles]] . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 786 ---------------------------------------------
Extracts the OAuth bearer token from the request . --> Checks theSales Authorization header --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest [[request]] ) { String [[header]] = [[request]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[header]] == null ) { return null ; } int [[ndx]] = [[header]] . indexOf ( "Bearer " ) ; if ( [[ndx]] == - 1 ) { return null ; } return [[header]] . substring ( [[ndx]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[sales]] ( final HttpServletRequest [[inviting]] ) { String [[subtitling]] = [[inviting]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[subtitling]] == null ) { return null ; } int [[duck]] = [[subtitling]] . indexOf ( "Bearer " ) ; if ( [[duck]] == - 1 ) { return null ; } return [[subtitling]] . substring ( [[duck]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 787 ---------------------------------------------
Require authentication . --> Set a Fernet Authorization header --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse [[resp]] , final String [[realm]] ) throws IOException { [[resp]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + [[realm]] + ' ' ) ; [[resp]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[wrenched]] ( final HttpServletResponse [[conferred]] , final String [[regard]] ) throws IOException { [[conferred]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + [[regard]] + ' ' ) ; [[conferred]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 788 ---------------------------------------------
Create the signature key . --> Generate a detour --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String [[methodName]] , final String description , final String [[className]] ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( [[className]] ) . append ( StringPool . HASH ) . append ( [[methodName]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[detour]] ( final int access , final String [[chute]] , final String description , final String [[chronicler]] ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( [[chronicler]] ) . append ( StringPool . HASH ) . append ( [[chute]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 789 ---------------------------------------------
Returns true if any flags are empty . --> Determines if the given signs are consistent . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags [[flags]] ) { if ( [[flags]] == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = [[flags]] . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[flags]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[cbl]] ( Flags [[signs]] ) { if ( [[signs]] == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = [[signs]] . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[signs]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 790 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 747 / 24 / 19 / 790:  79%|███████▉  | 790/1000 [4:32:49<1:12:31, 20.72s/it][Succeeded / Failed / Skipped / Total] 747 / 24 / 19 / 790:  79%|███████▉  | 791/1000 [4:32:53<1:12:06, 20.70s/it][Succeeded / Failed / Skipped / Total] 748 / 24 / 19 / 791:  79%|███████▉  | 791/1000 [4:32:53<1:12:06, 20.70s/it][Succeeded / Failed / Skipped / Total] 748 / 24 / 19 / 791:  79%|███████▉  | 792/1000 [4:32:58<1:11:41, 20.68s/it][Succeeded / Failed / Skipped / Total] 749 / 24 / 19 / 792:  79%|███████▉  | 792/1000 [4:32:58<1:11:41, 20.68s/it][Succeeded / Failed / Skipped / Total] 749 / 24 / 19 / 792:  79%|███████▉  | 793/1000 [4:33:23<1:11:21, 20.68s/it][Succeeded / Failed / Skipped / Total] 750 / 24 / 19 / 793:  79%|███████▉  | 793/1000 [4:33:23<1:11:21, 20.68s/it][Succeeded / Failed / Skipped / Total] 750 / 24 / 19 / 793:  79%|███████▉  | 794/1000 [4:33:27<1:10:56, 20.66s/it][Succeeded / Failed / Skipped / Total] 751 / 24 / 19 / 794:  79%|███████▉  | 794/1000 [4:33:27<1:10:56, 20.66s/it][Succeeded / Failed / Skipped / Total] 751 / 24 / 19 / 794:  80%|███████▉  | 795/1000 [4:33:42<1:10:34, 20.66s/it][Succeeded / Failed / Skipped / Total] 752 / 24 / 19 / 795:  80%|███████▉  | 795/1000 [4:33:42<1:10:34, 20.66s/it][Succeeded / Failed / Skipped / Total] 752 / 24 / 19 / 795:  80%|███████▉  | 796/1000 [4:34:24<1:10:19, 20.68s/it]Sets the response . --> Sets the MIME type and SIME type --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareResponse]] ( final HttpServletResponse response , final String [[fileName]] , String mimeType , final int [[fileSize]] ) { if ( ( mimeType == null ) && ( [[fileName]] != null ) ) { String [[extension]] = FileNameUtil . getExtension ( [[fileName]] ) ; mimeType = MimeTypes . getMimeType ( [[extension]] ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( [[fileSize]] >= 0 ) { response . setContentLength ( [[fileSize]] ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void [[satanas]] ( final HttpServletResponse response , final String [[petty]] , String mimeType , final int [[seii]] ) { if ( ( mimeType == null ) && ( [[petty]] != null ) ) { String [[prolong]] = FileNameUtil . getExtension ( [[petty]] ) ; mimeType = MimeTypes . getMimeType ( [[prolong]] ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( [[seii]] >= 0 ) { response . setContentLength ( [[seii]] ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 791 ---------------------------------------------
Get all cookies from the request . --> Finds a cookie in the given request --> Socre: 1.0

[[[[Adv]]]]: public static Cookie [ ] [[getAllCookies]] ( final HttpServletRequest [[request]] , final String [[cookieName]] ) { Cookie [ ] cookies = [[request]] . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > [[list]] = new ArrayList <> ( cookies . length ) ; for ( Cookie [[cookie]] : cookies ) { if ( [[cookie]] . getName ( ) . equals ( [[cookieName]] ) ) { [[list]] . add ( [[cookie]] ) ; } } if ( [[list]] . isEmpty ( ) ) { return null ; } return [[list]] . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] [[koto]] ( final HttpServletRequest [[requisition]] , final String [[shitcan]] ) { Cookie [ ] cookies = [[requisition]] . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > [[existing]] = new ArrayList <> ( cookies . length ) ; for ( Cookie [[bun]] : cookies ) { if ( [[bun]] . getName ( ) . equals ( [[shitcan]] ) ) { [[existing]] . add ( [[bun]] ) ; } } if ( [[existing]] . isEmpty ( ) ) { return null ; } return [[existing]] . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 792 ---------------------------------------------
Read request body from a reader --> get kalin --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest [[request]] ) throws IOException { BufferedReader buff = [[request]] . getReader ( ) ; StringWriter [[out]] = new StringWriter ( ) ; StreamUtil . copy ( buff , [[out]] ) ; return [[out]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[katalin]] ( final HttpServletRequest [[asks]] ) throws IOException { BufferedReader buff = [[asks]] . getReader ( ) ; StringWriter [[beside]] = new StringWriter ( ) ; StreamUtil . copy ( buff , [[beside]] ) ; return [[beside]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 793 ---------------------------------------------
Stores the current context path in the request . --> Sets a heatbethode to a page --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final PageContext [[pageContext]] , final String [[contextPathVariableName]] ) { String [[ctxPath]] = getContextPath ( [[pageContext]] ) ; HttpServletRequest request = ( HttpServletRequest ) [[pageContext]] . getRequest ( ) ; request . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; ServletContext servletContext = [[pageContext]] . getServletContext ( ) ; servletContext . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void [[probes]] ( final PageContext [[lizbeth]] , final String [[electricity]] ) { String [[writes]] = getContextPath ( [[lizbeth]] ) ; HttpServletRequest request = ( HttpServletRequest ) [[lizbeth]] . getRequest ( ) ; request . setAttribute ( [[electricity]] , [[writes]] ) ; ServletContext servletContext = [[lizbeth]] . getServletContext ( ) ; servletContext . setAttribute ( [[electricity]] , [[writes]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 794 ---------------------------------------------
Stores the context path in the servlet context . --> Converts a CSS to an adjax --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final ServletContext servletContext , final String [[contextPathVariableName]] ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void [[orko]] ( final ServletContext servletContext , final String [[canapés]] ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[canapés]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 795 ---------------------------------------------
Prepares a download for download . --> RGET method --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse response , final File file , final String [[mimeType]] ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , [[mimeType]] , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[roget]] ( final HttpServletResponse response , final File file , final String [[tweet]] ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , [[tweet]] , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 796 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 753 / 24 / 19 / 796:  80%|███████▉  | 796/1000 [4:34:24<1:10:19, 20.68s/it][Succeeded / Failed / Skipped / Total] 753 / 24 / 19 / 796:  80%|███████▉  | 797/1000 [4:34:49<1:09:59, 20.69s/it][Succeeded / Failed / Skipped / Total] 754 / 24 / 19 / 797:  80%|███████▉  | 797/1000 [4:34:49<1:09:59, 20.69s/it][Succeeded / Failed / Skipped / Total] 754 / 24 / 19 / 797:  80%|███████▉  | 798/1000 [4:35:00<1:09:36, 20.68s/it][Succeeded / Failed / Skipped / Total] 755 / 24 / 19 / 798:  80%|███████▉  | 798/1000 [4:35:00<1:09:36, 20.68s/it][Succeeded / Failed / Skipped / Total] 755 / 24 / 19 / 798:  80%|███████▉  | 799/1000 [4:35:02<1:09:11, 20.65s/it][Succeeded / Failed / Skipped / Total] 756 / 24 / 19 / 799:  80%|███████▉  | 799/1000 [4:35:02<1:09:11, 20.65s/it][Succeeded / Failed / Skipped / Total] 756 / 24 / 19 / 799:  80%|████████  | 800/1000 [4:35:06<1:08:46, 20.63s/it][Succeeded / Failed / Skipped / Total] 757 / 24 / 19 / 800:  80%|████████  | 800/1000 [4:35:06<1:08:46, 20.63s/it][Succeeded / Failed / Skipped / Total] 757 / 24 / 19 / 800:  80%|████████  | 801/1000 [4:35:08<1:08:21, 20.61s/it][Succeeded / Failed / Skipped / Total] 758 / 24 / 19 / 801:  80%|████████  | 801/1000 [4:35:08<1:08:21, 20.61s/it][Succeeded / Failed / Skipped / Total] 758 / 24 / 19 / 801:  80%|████████  | 802/1000 [4:35:44<1:08:04, 20.63s/it]Read request body from stream --> get manila --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromStream]] ( final HttpServletRequest request ) throws IOException { String [[charEncoding]] = request . getCharacterEncoding ( ) ; if ( [[charEncoding]] == null ) { [[charEncoding]] = JoddCore . encoding ; } CharArrayWriter [[charArrayWriter]] = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , [[charEncoding]] ) ) ; StreamUtil . copy ( bufferedReader , [[charArrayWriter]] ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return [[charArrayWriter]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[manila]] ( final HttpServletRequest request ) throws IOException { String [[usband]] = request . getCharacterEncoding ( ) ; if ( [[usband]] == null ) { [[usband]] = JoddCore . encoding ; } CharArrayWriter [[bindi]] = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , [[usband]] ) ) ; StreamUtil . copy ( bufferedReader , [[bindi]] ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return [[bindi]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 797 ---------------------------------------------
Copy all request parameters to attributes . --> copied from ServletRequest --> Socre: 1.0

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean [[ignoreEmptyRequestParams]] ) { Enumeration [[paramNames]] = servletRequest . getParameterNames ( ) ; while ( [[paramNames]] . hasMoreElements ( ) ) { String paramName = ( String ) [[paramNames]] . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] [[paramValues]] = servletRequest . getParameterValues ( paramName ) ; [[paramValues]] = prepareParameters ( [[paramValues]] , treatEmptyParamsAsNull , [[ignoreEmptyRequestParams]] ) ; if ( [[paramValues]] == null ) { continue ; } servletRequest . setAttribute ( paramName , [[paramValues]] . length == 1 ? [[paramValues]] [ 0 ] : [[paramValues]] ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean [[disqualify]] ) { Enumeration [[performance]] = servletRequest . getParameterNames ( ) ; while ( [[performance]] . hasMoreElements ( ) ) { String paramName = ( String ) [[performance]] . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] [[gatherers]] = servletRequest . getParameterValues ( paramName ) ; [[gatherers]] = prepareParameters ( [[gatherers]] , treatEmptyParamsAsNull , [[disqualify]] ) ; if ( [[gatherers]] == null ) { continue ; } servletRequest . setAttribute ( paramName , [[gatherers]] . length == 1 ? [[gatherers]] [ 0 ] : [[gatherers]] ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 798 ---------------------------------------------
Prepare parameters . --> Smooth the parameter values --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] [[prepareParameters]] ( final String [ ] paramValues , final boolean [[treatEmptyParamsAsNull]] , final boolean ignoreEmptyRequestParams ) { if ( [[treatEmptyParamsAsNull]] || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int [[i]] = 0 ; [[i]] < paramValues . length ; [[i]] ++ ) { String paramValue = paramValues [ [[i]] ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( [[treatEmptyParamsAsNull]] ) { paramValue = null ; } } paramValues [ [[i]] ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] [[shunt]] ( final String [ ] paramValues , final boolean [[gases]] , final boolean ignoreEmptyRequestParams ) { if ( [[gases]] || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int [[rhee]] = 0 ; [[rhee]] < paramValues . length ; [[rhee]] ++ ) { String paramValue = paramValues [ [[rhee]] ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( [[gases]] ) { paramValue = null ; } } paramValues [ [[rhee]] ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 799 ---------------------------------------------
Invokes the HTML tag . --> If we don t throw an exception --> Socre: 1.0

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[fairbanks]] ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 800 ---------------------------------------------
Renders the body to a string . --> Hollywood bodies --> Socre: 1.0

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment [[body]] ) throws JspException { char [ ] [[result]] = renderBody ( [[body]] ) ; return new String ( [[result]] ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[hollywood]] ( final JspFragment [[corpse]] ) throws JspException { char [ ] [[suite]] = renderBody ( [[corpse]] ) ; return new String ( [[suite]] ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 801 ---------------------------------------------
Renders the body as char array . --> This is used for testing --> Socre: 1.0

[[[[Adv]]]]: public static char [ ] [[renderBody]] ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter [[writer]] = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , [[writer]] ) ; return [[writer]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] [[asking]] ( final JspFragment [[institution]] ) throws JspException { FastCharArrayWriter [[penned]] = new FastCharArrayWriter ( ) ; invokeBody ( [[institution]] , [[penned]] ) ; return [[penned]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 802 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 759 / 24 / 19 / 802:  80%|████████  | 802/1000 [4:35:44<1:08:04, 20.63s/it][Succeeded / Failed / Skipped / Total] 759 / 24 / 19 / 802:  80%|████████  | 803/1000 [4:35:46<1:07:39, 20.61s/it][Succeeded / Failed / Skipped / Total] 760 / 24 / 19 / 803:  80%|████████  | 803/1000 [4:35:46<1:07:39, 20.61s/it][Succeeded / Failed / Skipped / Total] 760 / 24 / 19 / 803:  80%|████████  | 804/1000 [4:35:50<1:07:14, 20.59s/it][Succeeded / Failed / Skipped / Total] 761 / 24 / 19 / 804:  80%|████████  | 804/1000 [4:35:50<1:07:14, 20.59s/it][Succeeded / Failed / Skipped / Total] 761 / 24 / 19 / 804:  80%|████████  | 805/1000 [4:35:54<1:06:50, 20.57s/it][Succeeded / Failed / Skipped / Total] 762 / 24 / 19 / 805:  80%|████████  | 805/1000 [4:35:54<1:06:50, 20.57s/it][Succeeded / Failed / Skipped / Total] 762 / 24 / 19 / 805:  81%|████████  | 806/1000 [4:36:27<1:06:32, 20.58s/it][Succeeded / Failed / Skipped / Total] 763 / 24 / 19 / 806:  81%|████████  | 806/1000 [4:36:27<1:06:32, 20.58s/it][Succeeded / Failed / Skipped / Total] 763 / 24 / 19 / 806:  81%|████████  | 807/1000 [4:36:27<1:06:06, 20.55s/it][Succeeded / Failed / Skipped / Total] 763 / 24 / 20 / 807:  81%|████████  | 807/1000 [4:36:27<1:06:06, 20.55s/it][Succeeded / Failed / Skipped / Total] 763 / 24 / 20 / 807:  81%|████████  | 808/1000 [4:36:31<1:05:42, 20.53s/it][Succeeded / Failed / Skipped / Total] 764 / 24 / 20 / 808:  81%|████████  | 808/1000 [4:36:31<1:05:42, 20.53s/it][Succeeded / Failed / Skipped / Total] 764 / 24 / 20 / 808:  81%|████████  | 809/1000 [4:36:37<1:05:18, 20.52s/it][Succeeded / Failed / Skipped / Total] 765 / 24 / 20 / 809:  81%|████████  | 809/1000 [4:36:37<1:05:18, 20.52s/it][Succeeded / Failed / Skipped / Total] 765 / 24 / 20 / 809:  81%|████████  | 810/1000 [4:36:46<1:04:55, 20.50s/it][Succeeded / Failed / Skipped / Total] 766 / 24 / 20 / 810:  81%|████████  | 810/1000 [4:36:46<1:04:55, 20.50s/it][Succeeded / Failed / Skipped / Total] 766 / 24 / 20 / 810:  81%|████████  | 811/1000 [4:36:50<1:04:30, 20.48s/it]Invokes init methods --> Perform the herodias --> Socre: 1.0

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy [[invocationStrategy]] ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( [[invocationStrategy]] != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[herodias]] ( final InitMethodInvocationStrategy [[resembled]] ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( [[resembled]] != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 803 ---------------------------------------------
Creates new bean instance . --> addal arguments --> Socre: 1.0

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[maddalena]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 804 ---------------------------------------------
Inject parameters . --> Checks if the bean definition is black --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager [[paramManager]] , final boolean [[implicitParamInjection]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[implicitParamInjection]] ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[mullen]] ( final ParamManager [[latex]] , final boolean [[doping]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[doping]] ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 805 ---------------------------------------------
Rewrites the given action path . --> Rewrite a piece of carriers --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest [[servletRequest]] , final String [[actionPath]] , final String httpMethod ) { return [[actionPath]] ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest [[elise]] , final String [[carrington]] , final String httpMethod ) { return [[carrington]] ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 806 ---------------------------------------------
Calls all destroy methods on the bean . --> Serializes the bean --> Socre: 1.0

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint [[destroyMethodPoint]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[destroyMethodPoint]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[destroyMethodPoint]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[passenger]] ( ) { for ( final DestroyMethodPoint [[conspiring]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[conspiring]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[conspiring]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 807 ---------------------------------------------
Adds a new entry . --> [[[SKIPPED]]]

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 808 ---------------------------------------------
Put a base property . --> Methode d une propriete --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String key , final String value , final boolean [[append]] ) { put ( null , baseProperties , key , value , [[append]] ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[mystics]] ( final String key , final String value , final boolean [[mediation]] ) { put ( null , baseProperties , key , value , [[mediation]] ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 809 ---------------------------------------------
Adds a header . --> Add cartographer --> Socre: 1.0

[[[[Adv]]]]: public void [[addHeader]] ( final String [[name]] , final String value ) { List < String > valuesList = super . getAll ( [[name]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[name]] , value ) ; return ; } super . remove ( [[name]] ) ; valuesList . add ( value ) ; super . addAll ( [[name]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[cartographer]] ( final String [[nominated]] , final String value ) { List < String > valuesList = super . getAll ( [[nominated]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[nominated]] , value ) ; return ; } super . remove ( [[nominated]] ) ; valuesList . add ( value ) ; super . addAll ( [[nominated]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 810 ---------------------------------------------
Get profile s properties --> Get the typs for a given curvature and key --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String [[profile]] , final String key ) { final Map < String , PropsEntry > [[profileMap]] = profileProperties . get ( [[profile]] ) ; if ( [[profileMap]] == null ) { return null ; } return [[profileMap]] . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[tycoons]] ( final String [[curvature]] , final String key ) { final Map < String , PropsEntry > [[dracula]] = profileProperties . get ( [[curvature]] ) ; if ( [[dracula]] == null ) { return null ; } return [[dracula]] . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 811 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 767 / 24 / 20 / 811:  81%|████████  | 811/1000 [4:36:50<1:04:30, 20.48s/it][Succeeded / Failed / Skipped / Total] 767 / 24 / 20 / 811:  81%|████████  | 812/1000 [4:36:50<1:04:05, 20.46s/it][Succeeded / Failed / Skipped / Total] 768 / 24 / 20 / 812:  81%|████████  | 812/1000 [4:36:50<1:04:05, 20.46s/it][Succeeded / Failed / Skipped / Total] 768 / 24 / 20 / 812:  81%|████████▏ | 813/1000 [4:36:58<1:03:42, 20.44s/it][Succeeded / Failed / Skipped / Total] 769 / 24 / 20 / 813:  81%|████████▏ | 813/1000 [4:36:58<1:03:42, 20.44s/it][Succeeded / Failed / Skipped / Total] 769 / 24 / 20 / 813:  81%|████████▏ | 814/1000 [4:38:25<1:03:37, 20.52s/it][Succeeded / Failed / Skipped / Total] 770 / 24 / 20 / 814:  81%|████████▏ | 814/1000 [4:38:25<1:03:37, 20.52s/it][Succeeded / Failed / Skipped / Total] 770 / 24 / 20 / 814:  82%|████████▏ | 815/1000 [4:38:39<1:03:15, 20.51s/it][Succeeded / Failed / Skipped / Total] 771 / 24 / 20 / 815:  82%|████████▏ | 815/1000 [4:38:39<1:03:15, 20.51s/it][Succeeded / Failed / Skipped / Total] 771 / 24 / 20 / 815:  82%|████████▏ | 816/1000 [4:39:44<1:03:04, 20.57s/it][Succeeded / Failed / Skipped / Total] 772 / 24 / 20 / 816:  82%|████████▏ | 816/1000 [4:39:44<1:03:04, 20.57s/it][Succeeded / Failed / Skipped / Total] 772 / 24 / 20 / 816:  82%|████████▏ | 817/1000 [4:39:49<1:02:40, 20.55s/it][Succeeded / Failed / Skipped / Total] 773 / 24 / 20 / 817:  82%|████████▏ | 817/1000 [4:39:49<1:02:40, 20.55s/it][Succeeded / Failed / Skipped / Total] 773 / 24 / 20 / 817:  82%|████████▏ | 818/1000 [4:39:55<1:02:16, 20.53s/it][Succeeded / Failed / Skipped / Total] 774 / 24 / 20 / 818:  82%|████████▏ | 818/1000 [4:39:55<1:02:16, 20.53s/it][Succeeded / Failed / Skipped / Total] 774 / 24 / 20 / 818:  82%|████████▏ | 819/1000 [4:39:58<1:01:52, 20.51s/it]Put profile . --> revlock a key --> Socre: 1.0

[[[[Adv]]]]: public void [[putProfileProperty]] ( final String key , final String value , final String profile , final boolean [[append]] ) { Map < String , PropsEntry > [[map]] = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , [[map]] , key , value , [[append]] ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void [[grimlock]] ( final String key , final String value , final String profile , final boolean [[royer]] ) { Map < String , PropsEntry > [[allocation]] = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , [[allocation]] , key , value , [[royer]] ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 812 ---------------------------------------------
Resolve macros . --> Renders a list of values --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String [[value]] , final String ... [[profiles]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[shoulders]] ( String [[values]] , final String ... [[outline]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 813 ---------------------------------------------
Writes a 32 - bit word from a byte array . --> Calculate kron --> Socre: 1.0

[[[[Adv]]]]: private static int [[streamtoword]] ( byte [ ] data , int [ ] offp ) { int [[i]] ; int word = 0 ; int off = offp [ 0 ] ; for ( [[i]] = 0 ; [[i]] < 4 ; [[i]] ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int [[kron]] ( byte [ ] data , int [ ] offp ) { int [[it]] ; int word = 0 ; int off = offp [ 0 ] ; for ( [[it]] = 0 ; [[it]] < 4 ; [[it]] ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 814 ---------------------------------------------
Extract profile . --> Extract contour from contour --> Socre: 1.0

[[[[Adv]]]]: public Map extract ( Map target , final String [ ] [[profiles]] , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map extract ( Map target , final String [ ] [[contour]] , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 815 ---------------------------------------------
Checks if a plaintext hashed password . --> Checks if the passed hashedashed shard --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[checkpw]] ( String [[plaintext]] , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( [[plaintext]] , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "[[False]]" != "[[False]]" ; } if ( hashed_bytes . length != try_bytes . length ) { return "[[False]]" != "[[False]]" ; } byte [[ret]] = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { [[ret]] |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return [[ret]] == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean [[shard]] ( String [[lynette]] , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( [[lynette]] , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "[[Fraudulent]]" != "[[Fraudulent]]" ; } if ( hashed_bytes . length != try_bytes . length ) { return "[[Fraudulent]]" != "[[Fraudulent]]" ; } byte [[retreated]] = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { [[retreated]] |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return [[retreated]] == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 816 ---------------------------------------------
Copies all characters to the stream . --> Copy all remaining state --> Socre: 1.0

[[[[Adv]]]]: public int copyAll ( final OutputStream [[out]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte [[b]] = readByte ( ) ; if ( isBoundary ( [[b]] ) ) { break ; } [[out]] . write ( [[b]] ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int copyAll ( final OutputStream [[outdoor]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte [[s]] = readByte ( ) ; if ( isBoundary ( [[s]] ) ) { break ; } [[outdoor]] . write ( [[s]] ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 817 ---------------------------------------------
Copies bytes from the input stream to the output stream . --> Chipping characters from the exterior boundary --> Socre: 1.0

[[[[Adv]]]]: public int [[copyMax]] ( final OutputStream [[out]] , final int maxBytes ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte [[b]] = readByte ( ) ; if ( isBoundary ( [[b]] ) ) { break ; } [[out]] . write ( [[b]] ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int [[chipping]] ( final OutputStream [[exterior]] , final int maxBytes ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte [[j]] = readByte ( ) ; if ( isBoundary ( [[j]] ) ) { break ; } [[exterior]] . write ( [[j]] ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 818 ---------------------------------------------
Parse action runtime . --> Perform Harker --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime [[parse]] ( final Class < ? > [[actionClass]] , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime [[hark]] ( final Class < ? > [[odour]] , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 819 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 775 / 24 / 20 / 819:  82%|████████▏ | 819/1000 [4:39:58<1:01:52, 20.51s/it][Succeeded / Failed / Skipped / Total] 775 / 24 / 20 / 819:  82%|████████▏ | 820/1000 [4:40:03<1:01:28, 20.49s/it][Succeeded / Failed / Skipped / Total] 776 / 24 / 20 / 820:  82%|████████▏ | 820/1000 [4:40:03<1:01:28, 20.49s/it][Succeeded / Failed / Skipped / Total] 776 / 24 / 20 / 820:  82%|████████▏ | 821/1000 [4:40:18<1:01:06, 20.48s/it][Succeeded / Failed / Skipped / Total] 777 / 24 / 20 / 821:  82%|████████▏ | 821/1000 [4:40:18<1:01:06, 20.48s/it][Succeeded / Failed / Skipped / Total] 777 / 24 / 20 / 821:  82%|████████▏ | 822/1000 [4:40:26<1:00:43, 20.47s/it][Succeeded / Failed / Skipped / Total] 778 / 24 / 20 / 822:  82%|████████▏ | 822/1000 [4:40:26<1:00:43, 20.47s/it][Succeeded / Failed / Skipped / Total] 778 / 24 / 20 / 822:  82%|████████▏ | 823/1000 [4:40:28<1:00:19, 20.45s/it][Succeeded / Failed / Skipped / Total] 779 / 24 / 20 / 823:  82%|████████▏ | 823/1000 [4:40:28<1:00:19, 20.45s/it][Succeeded / Failed / Skipped / Total] 779 / 24 / 20 / 823:  82%|████████▏ | 824/1000 [4:40:29<59:54, 20.42s/it]  [Succeeded / Failed / Skipped / Total] 780 / 24 / 20 / 824:  82%|████████▏ | 824/1000 [4:40:29<59:54, 20.42s/it][Succeeded / Failed / Skipped / Total] 780 / 24 / 20 / 824:  82%|████████▎ | 825/1000 [4:40:32<59:30, 20.40s/it][Succeeded / Failed / Skipped / Total] 781 / 24 / 20 / 825:  82%|████████▎ | 825/1000 [4:40:32<59:30, 20.40s/it][Succeeded / Failed / Skipped / Total] 781 / 24 / 20 / 825:  83%|████████▎ | 826/1000 [4:40:32<59:05, 20.38s/it][Succeeded / Failed / Skipped / Total] 782 / 24 / 20 / 826:  83%|████████▎ | 826/1000 [4:40:32<59:05, 20.38s/it][Succeeded / Failed / Skipped / Total] 782 / 24 / 20 / 826:  83%|████████▎ | 827/1000 [4:40:33<58:41, 20.35s/it]Checks if a query parameter is a GET parameter . --> Determines whether a number belongs to a number --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isGetParameter]] ( final HttpServletRequest request , String [[name]] ) { [[name]] = URLCoder . encodeQueryParam ( [[name]] ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] [[nameValuePairs]] = StringUtil . splitc ( query , ' ' ) ; for ( String [[nameValuePair]] : [[nameValuePairs]] ) { if ( [[nameValuePair]] . startsWith ( [[name]] ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean [[wel]] ( final HttpServletRequest request , String [[numbers]] ) { [[numbers]] = URLCoder . encodeQueryParam ( [[numbers]] ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] [[endorse]] = StringUtil . splitc ( query , ' ' ) ; for ( String [[disbarment]] : [[endorse]] ) { if ( [[disbarment]] . startsWith ( [[numbers]] ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 820 ---------------------------------------------
Detect alias . --> method to register actions --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues annotationValues , final ActionDefinition [[actionDefinition]] ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[actionDefinition]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[punishments]] ( final ActionAnnotationValues annotationValues , final ActionDefinition [[bυt]] ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[bυt]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 821 ---------------------------------------------
Read the interceptor annotation . --> Extract all actionInterceptor from annotated element --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionInterceptor > [ ] [[result]] = null ; InterceptedBy [[interceptedBy]] = [[actionClassOrMethod]] . getAnnotation ( InterceptedBy . class ) ; if ( [[interceptedBy]] != null ) { [[result]] = [[interceptedBy]] . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[rpgs]] ( final AnnotatedElement [[substantiate]] ) { Class < ? extends ActionInterceptor > [ ] [[cause]] = null ; InterceptedBy [[strenuous]] = [[substantiate]] . getAnnotation ( InterceptedBy . class ) ; if ( [[strenuous]] != null ) { [[cause]] = [[strenuous]] . value ( ) ; if ( [[cause]] . length == 0 ) { [[cause]] = null ; } } return [[cause]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 822 ---------------------------------------------
Resolves the action configuration for the given action annotation values . --> Get an ActionConfig object with a replacement --> Socre: 1.0

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues [[annotationValues]] ) { final Class < ? extends Annotation > [[annotationType]] ; if ( [[annotationValues]] == null ) { [[annotationType]] = Action . class ; } else { [[annotationType]] = [[annotationValues]] . annotationType ( ) ; } return actionConfigManager . lookup ( [[annotationType]] ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[messy]] ( final ActionAnnotationValues [[reinforcement]] ) { final Class < ? extends Annotation > [[pancreatic]] ; if ( [[reinforcement]] == null ) { [[pancreatic]] = Action . class ; } else { [[pancreatic]] = [[reinforcement]] . annotationType ( ) ; } return actionConfigManager . lookup ( [[pancreatic]] ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 823 ---------------------------------------------
Read action filters . --> Return an array of ActionFilters --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionFilter > [ ] [[result]] = null ; FilteredBy [[filteredBy]] = [[actionClassOrMethod]] . getAnnotation ( FilteredBy . class ) ; if ( [[filteredBy]] != null ) { [[result]] = [[filteredBy]] . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[lau]] ( final AnnotatedElement [[aramis]] ) { Class < ? extends ActionFilter > [ ] [[ensuing]] = null ; FilteredBy [[democratically]] = [[aramis]] . getAnnotation ( FilteredBy . class ) ; if ( [[democratically]] != null ) { [[ensuing]] = [[democratically]] . value ( ) ; if ( [[ensuing]] . length == 0 ) { [[ensuing]] = null ; } } return [[ensuing]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 824 ---------------------------------------------
Read package action path . --> Extract lambdas --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class actionClass ) { Package [[actionPackage]] = actionClass . getPackage ( ) ; final String [[actionPackageName]] = [[actionPackage]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[lambdas]] ( final Class actionClass ) { Package [[searchlight]] = actionClass . getPackage ( ) ; final String [[statham]] = [[searchlight]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 825 ---------------------------------------------
Read method action path . --> Low - level encryption --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String [[methodName]] , final ActionAnnotationValues [[annotationValues]] , final ActionConfig [[actionConfig]] ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[lowenthal]] ( final String [[extradition]] , final ActionAnnotationValues [[trumbo]] , final ActionConfig [[nurtures]] ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 826 ---------------------------------------------
Parse method alias . --> Get the fallback strategy for the action annotationValues --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues annotationValues ) { String [[alias]] = null ; if ( annotationValues != null ) { [[alias]] = annotationValues . alias ( ) ; } return [[alias]] ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[zipper]] ( final ActionAnnotationValues annotationValues ) { String [[fallacious]] = null ; if ( annotationValues != null ) { [[fallacious]] = annotationValues . alias ( ) ; } return [[fallacious]] ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 827 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 782 / 24 / 21 / 827:  83%|████████▎ | 827/1000 [4:40:33<58:41, 20.35s/it][Succeeded / Failed / Skipped / Total] 782 / 24 / 21 / 827:  83%|████████▎ | 828/1000 [4:41:07<58:23, 20.37s/it][Succeeded / Failed / Skipped / Total] 782 / 25 / 21 / 828:  83%|████████▎ | 828/1000 [4:41:07<58:23, 20.37s/it][Succeeded / Failed / Skipped / Total] 782 / 25 / 21 / 828:  83%|████████▎ | 829/1000 [4:41:24<58:02, 20.37s/it][Succeeded / Failed / Skipped / Total] 783 / 25 / 21 / 829:  83%|████████▎ | 829/1000 [4:41:24<58:02, 20.37s/it][Succeeded / Failed / Skipped / Total] 783 / 25 / 21 / 829:  83%|████████▎ | 830/1000 [4:41:49<57:43, 20.37s/it][Succeeded / Failed / Skipped / Total] 784 / 25 / 21 / 830:  83%|████████▎ | 830/1000 [4:41:49<57:43, 20.37s/it][Succeeded / Failed / Skipped / Total] 784 / 25 / 21 / 830:  83%|████████▎ | 831/1000 [4:42:06<57:22, 20.37s/it][Succeeded / Failed / Skipped / Total] 785 / 25 / 21 / 831:  83%|████████▎ | 831/1000 [4:42:06<57:22, 20.37s/it][Succeeded / Failed / Skipped / Total] 785 / 25 / 21 / 831:  83%|████████▎ | 832/1000 [4:42:19<57:00, 20.36s/it][Succeeded / Failed / Skipped / Total] 786 / 25 / 21 / 832:  83%|████████▎ | 832/1000 [4:42:19<57:00, 20.36s/it][Succeeded / Failed / Skipped / Total] 786 / 25 / 21 / 832:  83%|████████▎ | 833/1000 [4:42:20<56:36, 20.34s/it][Succeeded / Failed / Skipped / Total] 787 / 25 / 21 / 833:  83%|████████▎ | 833/1000 [4:42:20<56:36, 20.34s/it][Succeeded / Failed / Skipped / Total] 787 / 25 / 21 / 833:  83%|████████▎ | 834/1000 [4:42:21<56:12, 20.31s/it]Set the response headers . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 828 ---------------------------------------------
Resolves a scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 829 ---------------------------------------------
Create action runtime . --> italize an ActionRuntime --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime [[createActionRuntime]] ( final ActionHandler actionHandler , final Class actionClass , final Method [[actionClassMethod]] , final Class < ? extends ActionResult > [[actionResult]] , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition [[actionDefinition]] , final boolean async , final boolean [[auth]] ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , [[actionClassMethod]] , filters , interceptors , [[actionDefinition]] , NoneActionResult . class , NoneActionResult . class , async , [[auth]] , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime [[inaugural]] ( final ActionHandler actionHandler , final Class actionClass , final Method [[spellman]] , final Class < ? extends ActionResult > [[mermaid]] , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition [[improvisation]] , final boolean async , final boolean [[friendships]] ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , [[spellman]] , filters , interceptors , [[improvisation]] , NoneActionResult . class , NoneActionResult . class , async , [[friendships]] , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 830 ---------------------------------------------
Hashes a password with a salt . --> generate shawnee --> Socre: 1.0

[[[[Adv]]]]: public static String [[hashpw]] ( String password , String [[salt]] ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( [[salt]] . charAt ( 0 ) != ' ' || [[salt]] . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( [[salt]] . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = [[salt]] . charAt ( 2 ) ; if ( minor != ' ' || [[salt]] . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String [[shawnee]] ( String password , String [[ammonium]] ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( [[ammonium]] . charAt ( 0 ) != ' ' || [[ammonium]] . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( [[ammonium]] . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = [[ammonium]] . charAt ( 2 ) ; if ( minor != ' ' || [[ammonium]] . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 831 ---------------------------------------------
Visits an annotation . --> Mickinney implementation --> Socre: 1.0

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String [[descriptor]] , final boolean [[visible]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , [[visible]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[mckinney]] ( final String [[phillippe]] , final boolean [[lucid]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[phillippe]] , [[lucid]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 832 ---------------------------------------------
Returns the json name for the given real name . --> Return the requested brno --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String [[realName]] ) { if ( realNames == null ) { return [[realName]] ; } int realIndex = ArraysUtil . indexOf ( realNames , [[realName]] ) ; if ( realIndex == - 1 ) { return [[realName]] ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[sterilization]] ( final String [[brno]] ) { if ( realNames == null ) { return [[brno]] ; } int realIndex = ArraysUtil . indexOf ( realNames , [[brno]] ) ; if ( realIndex == - 1 ) { return [[brno]] ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 833 ---------------------------------------------
Inject target into proxy --> Sets the object to be switcher --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object proxy , final Object [[target]] ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( proxy , [[target]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[bewitching]] ( final Object proxy , final Object [[objectives]] ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( proxy , [[objectives]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 834 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 788 / 25 / 21 / 834:  83%|████████▎ | 834/1000 [4:42:21<56:12, 20.31s/it][Succeeded / Failed / Skipped / Total] 788 / 25 / 21 / 834:  84%|████████▎ | 835/1000 [4:42:25<55:48, 20.29s/it][Succeeded / Failed / Skipped / Total] 789 / 25 / 21 / 835:  84%|████████▎ | 835/1000 [4:42:25<55:48, 20.29s/it][Succeeded / Failed / Skipped / Total] 789 / 25 / 21 / 835:  84%|████████▎ | 836/1000 [4:42:30<55:25, 20.28s/it][Succeeded / Failed / Skipped / Total] 790 / 25 / 21 / 836:  84%|████████▎ | 836/1000 [4:42:31<55:25, 20.28s/it][Succeeded / Failed / Skipped / Total] 791 / 25 / 21 / 837:  84%|████████▎ | 837/1000 [4:42:31<55:01, 20.25s/it][Succeeded / Failed / Skipped / Total] 791 / 25 / 21 / 837:  84%|████████▍ | 838/1000 [4:42:54<54:41, 20.26s/it][Succeeded / Failed / Skipped / Total] 792 / 25 / 21 / 838:  84%|████████▍ | 838/1000 [4:42:54<54:41, 20.26s/it][Succeeded / Failed / Skipped / Total] 792 / 25 / 21 / 838:  84%|████████▍ | 839/1000 [4:43:05<54:19, 20.24s/it][Succeeded / Failed / Skipped / Total] 793 / 25 / 21 / 839:  84%|████████▍ | 839/1000 [4:43:05<54:19, 20.24s/it][Succeeded / Failed / Skipped / Total] 793 / 25 / 21 / 839:  84%|████████▍ | 840/1000 [4:43:46<54:03, 20.27s/it][Succeeded / Failed / Skipped / Total] 794 / 25 / 21 / 840:  84%|████████▍ | 840/1000 [4:43:46<54:03, 20.27s/it][Succeeded / Failed / Skipped / Total] 794 / 25 / 21 / 840:  84%|████████▍ | 841/1000 [4:43:50<53:39, 20.25s/it][Succeeded / Failed / Skipped / Total] 795 / 25 / 21 / 841:  84%|████████▍ | 841/1000 [4:43:50<53:39, 20.25s/it][Succeeded / Failed / Skipped / Total] 795 / 25 / 21 / 841:  84%|████████▍ | 842/1000 [4:43:56<53:16, 20.23s/it][Succeeded / Failed / Skipped / Total] 796 / 25 / 21 / 842:  84%|████████▍ | 842/1000 [4:43:56<53:16, 20.23s/it][Succeeded / Failed / Skipped / Total] 796 / 25 / 21 / 842:  84%|████████▍ | 843/1000 [4:44:20<52:57, 20.24s/it]Returns the real name for the given json name . --> Get cellist --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String [[jsonName]] ) { if ( jsonNames == null ) { return [[jsonName]] ; } int [[jsonIndex]] = ArraysUtil . indexOf ( jsonNames , [[jsonName]] ) ; if ( [[jsonIndex]] == - 1 ) { return [[jsonName]] ; } return realNames [ [[jsonIndex]] ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[cellist]] ( final String [[prae]] ) { if ( jsonNames == null ) { return [[prae]] ; } int [[psychos]] = ArraysUtil . indexOf ( jsonNames , [[prae]] ) ; if ( [[psychos]] == - 1 ) { return [[prae]] ; } return realNames [ [[psychos]] ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 835 ---------------------------------------------
Find the type data for the given class . --> Json annotation --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[jiya]] ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 836 ---------------------------------------------
Resolves a name for a given type . --> Get vago for given type and denomination --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class type , final String [[name]] ) { TypeData [[typeData]] = lookupTypeData ( type ) ; return [[typeData]] . resolveJsonName ( [[name]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[vago]] ( final Class type , final String [[denomination]] ) { TypeData [[curdle]] = lookupTypeData ( type ) ; return [[curdle]] . resolveJsonName ( [[denomination]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 837 ---------------------------------------------
Looks up the TypeData for the given type . --> Ask the class for a given class --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[_lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } return [[typeData]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData [[asked]] ( final Class [[guy]] ) { TypeData [[faruk]] = typeDataMap . get ( [[guy]] ) ; if ( [[faruk]] == null ) { [[faruk]] = scanClassForAnnotations ( [[guy]] ) ; typeDataMap . put ( [[guy]] , [[faruk]] ) ; } return [[faruk]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 838 ---------------------------------------------
Lookup the TypeData for a given type . --> can be reused --> Socre: 1.0

[[[[Adv]]]]: public TypeData [[lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { if ( serializationSubclassAware ) { [[typeData]] = findSubclassTypeData ( [[type]] ) ; } if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } } return [[typeData]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData [[motive]] ( final Class [[tipo]] ) { TypeData [[dunno]] = typeDataMap . get ( [[tipo]] ) ; if ( [[dunno]] == null ) { if ( serializationSubclassAware ) { [[dunno]] = findSubclassTypeData ( [[tipo]] ) ; } if ( [[dunno]] == null ) { [[dunno]] = scanClassForAnnotations ( [[tipo]] ) ; typeDataMap . put ( [[tipo]] , [[dunno]] ) ; } } return [[dunno]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 839 ---------------------------------------------
Copy the bootstrap methods . --> Called periodically --> Socre: 1.0

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader [[classReader]] , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[sanctuary]] ( final ClassReader [[brocade]] , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 840 ---------------------------------------------
Resolves the real name . --> helper method to resolve the Melodic method --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class type , final String jsonName ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[melodic]] ( final Class type , final String jsonName ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 841 ---------------------------------------------
Returns the file content . --> read data from disk --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[kenner]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 842 ---------------------------------------------
Puts constant pool . --> Repressing a byte vector --> Socre: 1.0

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[repressing]] ( final ByteVector [[departing]] ) { [[departing]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 843 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 797 / 25 / 21 / 843:  84%|████████▍ | 843/1000 [4:44:20<52:57, 20.24s/it][Succeeded / Failed / Skipped / Total] 797 / 25 / 21 / 843:  84%|████████▍ | 844/1000 [4:44:44<52:37, 20.24s/it][Succeeded / Failed / Skipped / Total] 798 / 25 / 21 / 844:  84%|████████▍ | 844/1000 [4:44:44<52:37, 20.24s/it][Succeeded / Failed / Skipped / Total] 798 / 25 / 21 / 844:  84%|████████▍ | 845/1000 [4:46:11<52:29, 20.32s/it][Succeeded / Failed / Skipped / Total] 799 / 25 / 21 / 845:  84%|████████▍ | 845/1000 [4:46:11<52:29, 20.32s/it][Succeeded / Failed / Skipped / Total] 799 / 25 / 21 / 845:  85%|████████▍ | 846/1000 [4:46:53<52:13, 20.35s/it][Succeeded / Failed / Skipped / Total] 800 / 25 / 21 / 846:  85%|████████▍ | 846/1000 [4:46:53<52:13, 20.35s/it][Succeeded / Failed / Skipped / Total] 800 / 25 / 21 / 846:  85%|████████▍ | 847/1000 [4:48:01<52:01, 20.40s/it][Succeeded / Failed / Skipped / Total] 801 / 25 / 21 / 847:  85%|████████▍ | 847/1000 [4:48:01<52:01, 20.40s/it][Succeeded / Failed / Skipped / Total] 801 / 25 / 21 / 847:  85%|████████▍ | 848/1000 [4:48:52<51:46, 20.44s/it][Succeeded / Failed / Skipped / Total] 802 / 25 / 21 / 848:  85%|████████▍ | 848/1000 [4:48:52<51:46, 20.44s/it][Succeeded / Failed / Skipped / Total] 802 / 25 / 21 / 848:  85%|████████▍ | 849/1000 [4:54:39<52:24, 20.82s/it][Succeeded / Failed / Skipped / Total] 803 / 25 / 21 / 849:  85%|████████▍ | 849/1000 [4:54:39<52:24, 20.82s/it][Succeeded / Failed / Skipped / Total] 803 / 25 / 21 / 849:  85%|████████▌ | 850/1000 [4:56:31<52:19, 20.93s/it]Put bootstrap methods . --> Write snook method --> Socre: 1.0

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[snook]] ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 844 ---------------------------------------------
Sets the major version and class name . --> Bottleneck injection --> Socre: 1.0

[[[[Adv]]]]: int [[setMajorVersionAndClassName]] ( final int [[majorVersion]] , final String className ) { this . [[majorVersion]] = [[majorVersion]] ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int [[sprayed]] ( final int [[strangulation]] , final String className ) { this . [[olen]] = [[strangulation]] ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 845 ---------------------------------------------
Adds a constant reference to the constant pool . --> Looking for an occupant --> Socre: 1.0

[[[[Adv]]]]: private Entry [[addConstantMemberReference]] ( final int [[tag]] , final String owner , final String [[name]] , final String descriptor ) { int [[hashCode]] = hash ( [[tag]] , owner , [[name]] , descriptor ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == [[hashCode]] && [[entry]] . owner . equals ( owner ) && [[entry]] . name . equals ( [[name]] ) && [[entry]] . value . equals ( descriptor ) ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . put122 ( [[tag]] , addConstantClass ( owner ) . index , addConstantNameAndType ( [[name]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , owner , [[name]] , descriptor , 0 , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry [[sneaky]] ( final int [[trademark]] , final String owner , final String [[appointed]] , final String descriptor ) { int [[ambiguity]] = hash ( [[trademark]] , owner , [[appointed]] , descriptor ) ; Entry [[enroll]] = get ( [[ambiguity]] ) ; while ( [[enroll]] != null ) { if ( [[enroll]] . tag == [[trademark]] && [[enroll]] . hashCode == [[ambiguity]] && [[enroll]] . owner . equals ( owner ) && [[enroll]] . name . equals ( [[appointed]] ) && [[enroll]] . value . equals ( descriptor ) ) { return [[enroll]] ; } [[enroll]] = [[enroll]] . next ; } constantPool . put122 ( [[trademark]] , addConstantClass ( owner ) . index , addConstantNameAndType ( [[appointed]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , [[trademark]] , owner , [[appointed]] , descriptor , 0 , [[ambiguity]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 846 ---------------------------------------------
Adds a reference to the constant pool . --> Add an ARVV entry --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMemberReference]] ( final int [[index]] , final int [[tag]] , final String [[owner]] , final String name , final String [[descriptor]] ) { add ( new Entry ( [[index]] , [[tag]] , [[owner]] , name , [[descriptor]] , 0 , hash ( [[tag]] , [[owner]] , name , [[descriptor]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[arvid]] ( final int [[indications]] , final int [[stickers]] , final String [[homeowner]] , final String name , final String [[lockers]] ) { add ( new Entry ( [[indications]] , [[stickers]] , [[homeowner]] , name , [[lockers]] , 0 , hash ( [[stickers]] , [[homeowner]] , name , [[lockers]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 847 ---------------------------------------------
Adds a constant method reference . --> static factory methods --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodref]] ( final String owner , final String name , final String [[descriptor]] , final boolean [[isInterface]] ) { int tag = [[isInterface]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , [[descriptor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[pitting]] ( final String owner , final String name , final String [[busboy]] , final boolean [[gated]] ) { int tag = [[gated]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , [[busboy]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 848 ---------------------------------------------
Adds an integer constant . --> Creates an entry for lng --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int [[index]] , final int [[tag]] , final int [[value]] ) { add ( new Entry ( [[index]] , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[lng]] ( final int [[indications]] , final int [[emblem]] , final int [[interest]] ) { add ( new Entry ( [[indications]] , [[emblem]] , [[interest]] , hash ( [[emblem]] , [[interest]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 849 ---------------------------------------------
Apply proxy advice . --> This method is used to apply Jumpers --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] > [[T]] applyAdvice ( final Class < [[T]] > targetClass ) { Class [[adviceClass]] = cache . get ( targetClass ) ; if ( [[adviceClass]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < [[zillion]] > [[zillion]] applyAdvice ( final Class < [[zillion]] > targetClass ) { Class [[jumpers]] = cache . get ( targetClass ) ; if ( [[jumpers]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
[Succeeded / Failed / Skipped / Total] 804 / 25 / 21 / 850:  85%|████████▌ | 850/1000 [4:56:31<52:19, 20.93s/it][Succeeded / Failed / Skipped / Total] 804 / 25 / 21 / 850:  85%|████████▌ | 851/1000 [4:58:12<52:12, 21.03s/it][Succeeded / Failed / Skipped / Total] 805 / 25 / 21 / 851:  85%|████████▌ | 851/1000 [4:58:12<52:12, 21.03s/it][Succeeded / Failed / Skipped / Total] 805 / 25 / 21 / 851:  85%|████████▌ | 852/1000 [4:58:20<51:49, 21.01s/it][Succeeded / Failed / Skipped / Total] 806 / 25 / 21 / 852:  85%|████████▌ | 852/1000 [4:58:20<51:49, 21.01s/it][Succeeded / Failed / Skipped / Total] 806 / 25 / 21 / 852:  85%|████████▌ | 853/1000 [4:58:41<51:28, 21.01s/it][Succeeded / Failed / Skipped / Total] 807 / 25 / 21 / 853:  85%|████████▌ | 853/1000 [4:58:41<51:28, 21.01s/it][Succeeded / Failed / Skipped / Total] 807 / 25 / 21 / 853:  85%|████████▌ | 854/1000 [4:58:46<51:04, 20.99s/it][Succeeded / Failed / Skipped / Total] 808 / 25 / 21 / 854:  85%|████████▌ | 854/1000 [4:58:46<51:04, 20.99s/it][Succeeded / Failed / Skipped / Total] 808 / 25 / 21 / 854:  86%|████████▌ | 855/1000 [4:59:07<50:43, 20.99s/it][Succeeded / Failed / Skipped / Total] 809 / 25 / 21 / 855:  86%|████████▌ | 855/1000 [4:59:07<50:43, 20.99s/it][Succeeded / Failed / Skipped / Total] 809 / 25 / 21 / 855:  86%|████████▌ | 856/1000 [4:59:10<50:19, 20.97s/it]--------------------------------------------- Result 850 ---------------------------------------------
Adds a long or double entry . --> Creates an appa with heartbeats --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int [[index]] , final int [[tag]] , final long [[value]] ) { add ( new Entry ( [[index]] , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[appa]] ( final int [[indicator]] , final int [[branding]] , final long [[bravery]] ) { add ( new Entry ( [[indicator]] , [[branding]] , [[bravery]] , hash ( [[branding]] , [[bravery]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 851 ---------------------------------------------
Adds a constant field ref . --> Methode d --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String [[owner]] , final String name , final String [[descriptor]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[owner]] , name , [[descriptor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[malmö]] ( final String [[cardholder]] , final String name , final String [[yea]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[cardholder]] , name , [[yea]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 852 ---------------------------------------------
Adds a long or constant . --> Convenience method for lasagne --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantLongOrDouble]] ( final int [[tag]] , final long value ) { int [[hashCode]] = hash ( [[tag]] , value ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == [[hashCode]] && [[entry]] . data == value ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } int [[index]] = constantPoolCount ; constantPool . putByte ( [[tag]] ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( [[index]] , [[tag]] , value , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[gori]] ( final int [[captions]] , final long value ) { int [[lasagne]] = hash ( [[captions]] , value ) ; Entry [[accessing]] = get ( [[lasagne]] ) ; while ( [[accessing]] != null ) { if ( [[accessing]] . tag == [[captions]] && [[accessing]] . hashCode == [[lasagne]] && [[accessing]] . data == value ) { return [[accessing]] ; } [[accessing]] = [[accessing]] . next ; } int [[catalog]] = constantPoolCount ; constantPool . putByte ( [[captions]] ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( [[catalog]] , [[captions]] , value , [[lasagne]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a constant name and type to the constant pool . --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: int [[addConstantNameAndType]] ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[íà]] ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a constant name and type . --> addGators --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantNameAndType]] ( final int [[index]] , final String [[name]] , final String [[descriptor]] ) { final int [[tag]] = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( [[index]] , [[tag]] , [[name]] , [[descriptor]] , hash ( [[tag]] , [[name]] , [[descriptor]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[gators]] ( final int [[catalogued]] , final String [[christening]] , final String [[rows]] ) { final int [[markers]] = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( [[catalogued]] , [[markers]] , [[christening]] , [[rows]] , hash ( [[markers]] , [[christening]] , [[rows]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 855 ---------------------------------------------
Add a constant method handle . --> Wft - handle methods --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodHandle]] ( final int referenceKind , final String owner , final String [[name]] , final String descriptor , final boolean isInterface ) { final int [[tag]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[waft]] ( final int referenceKind , final String owner , final String [[emi]] , final String descriptor , final boolean isInterface ) { final int [[marking]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 856 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 810 / 25 / 21 / 856:  86%|████████▌ | 856/1000 [4:59:10<50:19, 20.97s/it][Succeeded / Failed / Skipped / Total] 810 / 25 / 21 / 856:  86%|████████▌ | 857/1000 [4:59:54<50:02, 21.00s/it][Succeeded / Failed / Skipped / Total] 811 / 25 / 21 / 857:  86%|████████▌ | 857/1000 [4:59:54<50:02, 21.00s/it][Succeeded / Failed / Skipped / Total] 811 / 25 / 21 / 857:  86%|████████▌ | 858/1000 [5:00:27<49:43, 21.01s/it][Succeeded / Failed / Skipped / Total] 812 / 25 / 21 / 858:  86%|████████▌ | 858/1000 [5:00:27<49:43, 21.01s/it][Succeeded / Failed / Skipped / Total] 812 / 25 / 21 / 858:  86%|████████▌ | 859/1000 [5:00:27<49:19, 20.99s/it][Succeeded / Failed / Skipped / Total] 813 / 25 / 21 / 859:  86%|████████▌ | 859/1000 [5:00:27<49:19, 20.99s/it][Succeeded / Failed / Skipped / Total] 813 / 25 / 21 / 859:  86%|████████▌ | 860/1000 [5:00:38<48:56, 20.97s/it][Succeeded / Failed / Skipped / Total] 814 / 25 / 21 / 860:  86%|████████▌ | 860/1000 [5:00:38<48:56, 20.97s/it][Succeeded / Failed / Skipped / Total] 814 / 25 / 21 / 860:  86%|████████▌ | 861/1000 [5:00:39<48:32, 20.95s/it][Succeeded / Failed / Skipped / Total] 815 / 25 / 21 / 861:  86%|████████▌ | 861/1000 [5:00:39<48:32, 20.95s/it][Succeeded / Failed / Skipped / Total] 815 / 25 / 21 / 861:  86%|████████▌ | 862/1000 [5:02:22<48:24, 21.05s/it]Adds constant method handle . --> lazily add ldle --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMethodHandle]] ( final int index , final int referenceKind , final String owner , final String name , final String [[descriptor]] ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , [[descriptor]] , referenceKind ) ; add ( new Entry ( index , tag , owner , name , [[descriptor]] , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[ladle]] ( final int index , final int referenceKind , final String owner , final String name , final String [[policía]] ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , [[policía]] , referenceKind ) ; add ( new Entry ( index , tag , owner , name , [[policía]] , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 857 ---------------------------------------------
Add a static constant . --> Can be called at least once --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantDynamic]] ( final String [[name]] , final String descriptor , final Handle [[bootstrapMethodHandle]] , final Object ... [[bootstrapMethodArguments]] ) { Symbol [[bootstrapMethod]] = addBootstrapMethod ( [[bootstrapMethodHandle]] , [[bootstrapMethodArguments]] ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , [[name]] , descriptor , [[bootstrapMethod]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[tourist]] ( final String [[nom]] , final String descriptor , final Handle [[grenadier]] , final Object ... [[amped]] ) { Symbol [[père]] = addBootstrapMethod ( [[grenadier]] , [[amped]] ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , [[nom]] , descriptor , [[père]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 858 ---------------------------------------------
Add or invoke dynamic method . --> Add dynamic methods --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantInvokeDynamic]] ( final String [[name]] , final String [[descriptor]] , final Handle [[bootstrapMethodHandle]] , final Object ... [[bootstrapMethodArguments]] ) { Symbol bootstrapMethod = addBootstrapMethod ( [[bootstrapMethodHandle]] , [[bootstrapMethodArguments]] ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[name]] , [[descriptor]] , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[internment]] ( final String [[nominated]] , final String [[threads]] , final Handle [[izzi]] , final Object ... [[menacingly]] ) { Symbol bootstrapMethod = addBootstrapMethod ( [[izzi]] , [[menacingly]] ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[nominated]] , [[threads]] , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a UTF8 constant . --> Parses an indicator --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int [[index]] , final String [[value]] ) { add ( new Entry ( [[index]] , Symbol . CONSTANT_UTF8_TAG , [[value]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[inane]] ( final int [[indicator]] , final String [[invaluable]] ) { add ( new Entry ( [[indicator]] , Symbol . CONSTANT_UTF8_TAG , [[invaluable]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[invaluable]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 860 ---------------------------------------------
Add dynamic or invoke dynamic reference . --> Handles handler --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final int [[index]] , final String name , final String [[descriptor]] , final int [[bootstrapMethodIndex]] ) { int hashCode = hash ( tag , name , [[descriptor]] , [[bootstrapMethodIndex]] ) ; add ( new Entry ( [[index]] , tag , null , name , [[descriptor]] , [[bootstrapMethodIndex]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[handedly]] ( final int tag , final int [[finder]] , final String name , final String [[auditor]] , final int [[joni]] ) { int hashCode = hash ( tag , name , [[auditor]] , [[joni]] ) ; add ( new Entry ( [[finder]] , tag , null , name , [[auditor]] , [[joni]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 861 ---------------------------------------------
Adds a constant to the constant pool . --> Return unsupervised for taj --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantIntegerOrFloat]] ( final int [[tag]] , final int [[value]] ) { int [[hashCode]] = hash ( [[tag]] , [[value]] ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == [[hashCode]] && [[entry]] . data == [[value]] ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . putByte ( [[tag]] ) . putInt ( [[value]] ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , [[value]] , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[unsupervised]] ( final int [[taj]] , final int [[merit]] ) { int [[prefect]] = hash ( [[taj]] , [[merit]] ) ; Entry [[came]] = get ( [[prefect]] ) ; while ( [[came]] != null ) { if ( [[came]] . tag == [[taj]] && [[came]] . hashCode == [[prefect]] && [[came]] . data == [[merit]] ) { return [[came]] ; } [[came]] = [[came]] . next ; } constantPool . putByte ( [[taj]] ) . putInt ( [[merit]] ) ; return put ( new Entry ( constantPoolCount ++ , [[taj]] , [[merit]] , [[prefect]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 862 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 816 / 25 / 21 / 862:  86%|████████▌ | 862/1000 [5:02:22<48:24, 21.05s/it][Succeeded / Failed / Skipped / Total] 816 / 25 / 21 / 862:  86%|████████▋ | 863/1000 [5:02:39<48:02, 21.04s/it][Succeeded / Failed / Skipped / Total] 817 / 25 / 21 / 863:  86%|████████▋ | 863/1000 [5:02:39<48:02, 21.04s/it][Succeeded / Failed / Skipped / Total] 817 / 25 / 21 / 863:  86%|████████▋ | 864/1000 [5:02:43<47:39, 21.02s/it][Succeeded / Failed / Skipped / Total] 818 / 25 / 21 / 864:  86%|████████▋ | 864/1000 [5:02:43<47:39, 21.02s/it][Succeeded / Failed / Skipped / Total] 818 / 25 / 21 / 864:  86%|████████▋ | 865/1000 [5:02:48<47:15, 21.00s/it][Succeeded / Failed / Skipped / Total] 819 / 25 / 21 / 865:  86%|████████▋ | 865/1000 [5:02:48<47:15, 21.00s/it][Succeeded / Failed / Skipped / Total] 819 / 25 / 21 / 865:  87%|████████▋ | 866/1000 [5:03:13<46:55, 21.01s/it][Succeeded / Failed / Skipped / Total] 820 / 25 / 21 / 866:  87%|████████▋ | 866/1000 [5:03:13<46:55, 21.01s/it][Succeeded / Failed / Skipped / Total] 820 / 25 / 21 / 866:  87%|████████▋ | 867/1000 [5:04:21<46:41, 21.06s/it][Succeeded / Failed / Skipped / Total] 821 / 25 / 21 / 867:  87%|████████▋ | 867/1000 [5:04:21<46:41, 21.06s/it][Succeeded / Failed / Skipped / Total] 821 / 25 / 21 / 867:  87%|████████▋ | 868/1000 [5:07:06<46:42, 21.23s/it][Succeeded / Failed / Skipped / Total] 822 / 25 / 21 / 868:  87%|████████▋ | 868/1000 [5:07:06<46:42, 21.23s/it][Succeeded / Failed / Skipped / Total] 822 / 25 / 21 / 868:  87%|████████▋ | 869/1000 [5:14:12<47:21, 21.69s/it]Adds a UTF8 constant . --> Add an emphasis --> Socre: 1.0

[[[[Adv]]]]: int [[addConstantUtf8]] ( final String [[value]] ) { int [[hashCode]] = hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == Symbol . CONSTANT_UTF8_TAG && [[entry]] . hashCode == [[hashCode]] && [[entry]] . value . equals ( [[value]] ) ) { return [[entry]] . index ; } [[entry]] = [[entry]] . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( [[value]] ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , [[value]] , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[contrived]] ( final String [[emphasis]] ) { int [[indo]] = hash ( Symbol . CONSTANT_UTF8_TAG , [[emphasis]] ) ; Entry [[input]] = get ( [[indo]] ) ; while ( [[input]] != null ) { if ( [[input]] . tag == Symbol . CONSTANT_UTF8_TAG && [[input]] . hashCode == [[indo]] && [[input]] . value . equals ( [[emphasis]] ) ) { return [[input]] . index ; } [[input]] = [[input]] . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( [[emphasis]] ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , [[emphasis]] , [[indo]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 863 ---------------------------------------------
Add a bootstrap method . --> special handling for testing --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle [[bootstrapMethodHandle]] , final Object ... [[bootstrapMethodArguments]] ) { ByteVector [[bootstrapMethodsAttribute]] = bootstrapMethods ; if ( [[bootstrapMethodsAttribute]] == null ) { [[bootstrapMethodsAttribute]] = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[boyar]] ( final Handle [[coulson]] , final Object ... [[wehrmacht]] ) { ByteVector [[too]] = bootstrapMethods ; if ( [[too]] == null ) { [[too]] = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 864 ---------------------------------------------
Adds a reference to the constant pool . --> generate gobar --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8Reference]] ( final int [[index]] , final int [[tag]] , final String [[value]] ) { add ( new Entry ( [[index]] , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[gobar]] ( final int [[clue]] , final int [[marked]] , final String [[valour]] ) { add ( new Entry ( [[clue]] , [[marked]] , [[valour]] , hash ( [[marked]] , [[valour]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 865 ---------------------------------------------
Add a merged type . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: int [[addMergedType]] ( final int [[typeTableIndex1]] , final int [[typeTableIndex2]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int [[salvador]] ( final int [[inspiration]] , final int [[contingent]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 866 ---------------------------------------------
Compute a hash for a name . --> This method is used for testing --> Socre: 1.0

[[[[Adv]]]]: private int [[hash]] ( final String [[name]] ) { int h = 0 ; for ( int i = [[name]] . length ( ) - 1 ; i >= 0 ; i -- ) { char [[c]] = [[name]] . charAt ( i ) ; if ( ! caseSensitive ) { if ( [[c]] >= ' ' && [[c]] <= ' ' ) { [[c]] += 32 ; } } h = 31 * h + [[c]] ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int [[saucepan]] ( final String [[spelled]] ) { int h = 0 ; for ( int i = [[spelled]] . length ( ) - 1 ; i >= 0 ; i -- ) { char [[bryan]] = [[spelled]] . charAt ( i ) ; if ( ! caseSensitive ) { if ( [[bryan]] >= ' ' && [[bryan]] <= ' ' ) { [[bryan]] += 32 ; } } h = 31 * h + [[bryan]] ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 867 ---------------------------------------------
Removes all entries from the multimap . --> Remove all entries --> Socre: 1.0

[[[[Adv]]]]: public HttpMultiMap < V > [[clear]] ( ) { for ( int [[i]] = 0 ; [[i]] < entries . length ; [[i]] ++ ) { entries [ [[i]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > [[noticeable]] ( ) { for ( int [[me]] = 0 ; [[me]] < entries . length ; [[me]] ++ ) { entries [ [[me]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 868 ---------------------------------------------
Returns an iterator over the elements in this map . --> Implements Map --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[iterator]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[daí]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 869 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 823 / 25 / 21 / 869:  87%|████████▋ | 869/1000 [5:14:12<47:21, 21.69s/it][Succeeded / Failed / Skipped / Total] 823 / 25 / 21 / 869:  87%|████████▋ | 870/1000 [5:14:29<46:59, 21.69s/it][Succeeded / Failed / Skipped / Total] 824 / 25 / 21 / 870:  87%|████████▋ | 870/1000 [5:14:29<46:59, 21.69s/it][Succeeded / Failed / Skipped / Total] 824 / 25 / 21 / 870:  87%|████████▋ | 871/1000 [5:15:12<46:41, 21.71s/it][Succeeded / Failed / Skipped / Total] 824 / 26 / 21 / 871:  87%|████████▋ | 871/1000 [5:15:12<46:41, 21.71s/it][Succeeded / Failed / Skipped / Total] 824 / 26 / 21 / 871:  87%|████████▋ | 872/1000 [5:15:19<46:17, 21.70s/it][Succeeded / Failed / Skipped / Total] 825 / 26 / 21 / 872:  87%|████████▋ | 872/1000 [5:15:19<46:17, 21.70s/it][Succeeded / Failed / Skipped / Total] 825 / 26 / 21 / 872:  87%|████████▋ | 873/1000 [5:15:23<45:52, 21.68s/it][Succeeded / Failed / Skipped / Total] 826 / 26 / 21 / 873:  87%|████████▋ | 873/1000 [5:15:23<45:52, 21.68s/it][Succeeded / Failed / Skipped / Total] 826 / 26 / 21 / 873:  87%|████████▋ | 874/1000 [5:15:26<45:28, 21.65s/it][Succeeded / Failed / Skipped / Total] 827 / 26 / 21 / 874:  87%|████████▋ | 874/1000 [5:15:26<45:28, 21.65s/it][Succeeded / Failed / Skipped / Total] 827 / 26 / 21 / 874:  88%|████████▊ | 875/1000 [5:15:35<45:05, 21.64s/it][Succeeded / Failed / Skipped / Total] 828 / 26 / 21 / 875:  88%|████████▊ | 875/1000 [5:15:35<45:05, 21.64s/it][Succeeded / Failed / Skipped / Total] 828 / 26 / 21 / 875:  88%|████████▊ | 876/1000 [5:16:03<44:44, 21.65s/it][Succeeded / Failed / Skipped / Total] 829 / 26 / 21 / 876:  88%|████████▊ | 876/1000 [5:16:03<44:44, 21.65s/it][Succeeded / Failed / Skipped / Total] 829 / 26 / 21 / 876:  88%|████████▊ | 877/1000 [5:17:02<44:27, 21.69s/it]Returns all the entries in this map . --> documentation inherited from interface Security --> Socre: 1.0

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > [[all]] = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { [[all]] . add ( e ) ; e = e . after ; } return [[all]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[registration]] ( ) { List < Map . Entry < String , V > > [[unmitigated]] = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { [[unmitigated]] . add ( e ) ; e = e . after ; } return [[unmitigated]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 870 ---------------------------------------------
Grows the internal buffer . --> used in unit test --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int [[minCapacity]] ) { final int [[oldCapacity]] = buffer . length ; int [[newCapacity]] = [[oldCapacity]] << 1 ; if ( [[newCapacity]] - [[minCapacity]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[heightened]] ( final int [[disused]] ) { final int [[uncontrolled]] = buffer . length ; int [[conducive]] = [[uncontrolled]] << 1 ; if ( [[conducive]] - [[disused]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 871 ---------------------------------------------
Appends a portion of a CharSequence to the buffer . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( csq . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( csq . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 872 ---------------------------------------------
Visits the specified annotation . --> looks for a parameter --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor [[visitAnnotation]] ( final String [[desc]] , final boolean [[visible]] ) { AnnotationVisitor [[destAnn]] = methodVisitor . visitAnnotation ( [[desc]] , [[visible]] ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor [[polecats]] ( final String [[peter]] , final boolean [[seeming]] ) { AnnotationVisitor [[bots]] = methodVisitor . visitAnnotation ( [[peter]] , [[seeming]] ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 873 ---------------------------------------------
Try to create the end of the chain . --> the first chain --> Socre: 1.0

[[[[Adv]]]]: @ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[sodium]] = 0 ; [[sodium]] < tmd . proxyData . length ; [[sodium]] ++ ) { tmd . selectCurrentProxy ( [[sodium]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 874 ---------------------------------------------
Create the start chain delegate . --> Configure the Dev Engine --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[devaney]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 875 ---------------------------------------------
Create the first chain delegate --> Load snicker --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , tmd . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[snicker]] ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , tmd . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 876 ---------------------------------------------
Parse a path . --> Methode permettante --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[metcalfe]] ( final String [[boulevards]] ) { return [[boulevards]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[boulevards]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 877 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 830 / 26 / 21 / 877:  88%|████████▊ | 877/1000 [5:17:02<44:27, 21.69s/it][Succeeded / Failed / Skipped / Total] 830 / 26 / 21 / 877:  88%|████████▊ | 878/1000 [5:18:13<44:13, 21.75s/it][Succeeded / Failed / Skipped / Total] 831 / 26 / 21 / 878:  88%|████████▊ | 878/1000 [5:18:13<44:13, 21.75s/it][Succeeded / Failed / Skipped / Total] 831 / 26 / 21 / 878:  88%|████████▊ | 879/1000 [5:18:16<43:48, 21.73s/it][Succeeded / Failed / Skipped / Total] 832 / 26 / 21 / 879:  88%|████████▊ | 879/1000 [5:18:16<43:48, 21.73s/it][Succeeded / Failed / Skipped / Total] 832 / 26 / 21 / 879:  88%|████████▊ | 880/1000 [5:19:03<43:30, 21.75s/it][Succeeded / Failed / Skipped / Total] 833 / 26 / 21 / 880:  88%|████████▊ | 880/1000 [5:19:03<43:30, 21.75s/it][Succeeded / Failed / Skipped / Total] 833 / 26 / 21 / 880:  88%|████████▊ | 881/1000 [5:19:16<43:07, 21.74s/it][Succeeded / Failed / Skipped / Total] 834 / 26 / 21 / 881:  88%|████████▊ | 881/1000 [5:19:16<43:07, 21.74s/it][Succeeded / Failed / Skipped / Total] 834 / 26 / 21 / 881:  88%|████████▊ | 882/1000 [5:19:21<42:43, 21.72s/it]Add or invoke dynamic reference . --> Methode hlungs --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[führer]] ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 878 ---------------------------------------------
Configures the servlet context . --> Add dum to the dum --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[dum]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 879 ---------------------------------------------
Execute the method --> the performance optimization --> Socre: 1.0

[[[[Adv]]]]: public Object [[execute]] ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object [[performance]] ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 880 ---------------------------------------------
Gets the FieldDescriptors . --> Get the moneylenders --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor [ ] [[getAllFieldDescriptors]] ( ) { if ( [[allFields]] == null ) { FieldDescriptor [ ] [[allFields]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[index]] = 0 ; for ( FieldDescriptor [[fieldDescriptor]] : fieldsMap . values ( ) ) { [[allFields]] [ [[index]] ] = [[fieldDescriptor]] ; [[index]] ++ ; } Arrays . sort ( [[allFields]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[allFields]] = [[allFields]] ; } return [[allFields]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] [[moneylenders]] ( ) { if ( [[cinematograph]] == null ) { FieldDescriptor [ ] [[cinematograph]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[indicator]] = 0 ; for ( FieldDescriptor [[sande]] : fieldsMap . values ( ) ) { [[cinematograph]] [ [[indicator]] ] = [[sande]] ; [[indicator]] ++ ; } Arrays . sort ( [[cinematograph]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[dong]] = [[cinematograph]] ; } return [[cinematograph]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 881 ---------------------------------------------
Creates a bean definition for registration . --> This method will register a BeanDefinition as a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String [[name]] , Class < T > [[type]] , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = [[type]] ; final ProxettaFactory [[builder]] = proxetta . proxy ( ) ; [[builder]] . setTarget ( [[type]] ) ; [[type]] = [[builder]] . define ( ) ; return new ProxettaBeanDefinition ( [[name]] , [[type]] , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( [[name]] , [[type]] , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String [[designated]] , Class < T > [[modes]] , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = [[modes]] ; final ProxettaFactory [[cartoonist]] = proxetta . proxy ( ) ; [[cartoonist]] . setTarget ( [[modes]] ) ; [[modes]] = [[cartoonist]] . define ( ) ; return new ProxettaBeanDefinition ( [[designated]] , [[modes]] , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( [[designated]] , [[modes]] , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 882 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 835 / 26 / 21 / 882:  88%|████████▊ | 882/1000 [5:19:21<42:43, 21.72s/it][Succeeded / Failed / Skipped / Total] 835 / 26 / 21 / 882:  88%|████████▊ | 883/1000 [5:19:37<42:21, 21.72s/it][Succeeded / Failed / Skipped / Total] 836 / 26 / 21 / 883:  88%|████████▊ | 883/1000 [5:19:37<42:21, 21.72s/it][Succeeded / Failed / Skipped / Total] 836 / 26 / 21 / 883:  88%|████████▊ | 884/1000 [5:20:05<42:00, 21.73s/it][Succeeded / Failed / Skipped / Total] 837 / 26 / 21 / 884:  88%|████████▊ | 884/1000 [5:20:05<42:00, 21.73s/it][Succeeded / Failed / Skipped / Total] 837 / 26 / 21 / 884:  88%|████████▊ | 885/1000 [5:20:10<41:36, 21.71s/it][Succeeded / Failed / Skipped / Total] 838 / 26 / 21 / 885:  88%|████████▊ | 885/1000 [5:20:10<41:36, 21.71s/it][Succeeded / Failed / Skipped / Total] 838 / 26 / 21 / 885:  89%|████████▊ | 886/1000 [5:20:45<41:16, 21.72s/it][Succeeded / Failed / Skipped / Total] 839 / 26 / 21 / 886:  89%|████████▊ | 886/1000 [5:20:45<41:16, 21.72s/it][Succeeded / Failed / Skipped / Total] 839 / 26 / 21 / 886:  89%|████████▊ | 887/1000 [5:21:11<40:55, 21.73s/it][Succeeded / Failed / Skipped / Total] 840 / 26 / 21 / 887:  89%|████████▊ | 887/1000 [5:21:11<40:55, 21.73s/it][Succeeded / Failed / Skipped / Total] 840 / 26 / 21 / 887:  89%|████████▉ | 888/1000 [5:21:21<40:31, 21.71s/it][Succeeded / Failed / Skipped / Total] 841 / 26 / 21 / 888:  89%|████████▉ | 888/1000 [5:21:21<40:31, 21.71s/it][Succeeded / Failed / Skipped / Total] 841 / 26 / 21 / 888:  89%|████████▉ | 889/1000 [5:21:24<40:07, 21.69s/it]Converts jtxTransactionMode to DbTransactionMode . --> Return a DbTransactionMode --> Socre: 1.0

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode [[txMode]] ) { final int isolation ; switch ( [[txMode]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , [[txMode]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[esteem]] ( final JtxTransactionMode [[reject]] ) { final int isolation ; switch ( [[reject]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , [[reject]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 883 ---------------------------------------------
Reads the property from the given object . --> Retrieves the pretent value from a supplier --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object [[source]] , final PropertyDescriptor [[propertyDescriptor]] ) { Getter [[getter]] = [[propertyDescriptor]] . getGetter ( declared ) ; if ( [[getter]] != null ) { try { return [[getter]] . invokeGetter ( [[source]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[pretentious]] ( final Object [[feeds]] , final PropertyDescriptor [[laundress]] ) { Getter [[blacker]] = [[laundress]] . getGetter ( declared ) ; if ( [[blacker]] != null ) { try { return [[blacker]] . invokeGetter ( [[feeds]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 884 ---------------------------------------------
Adds a new field to the path . --> Add zona prompting --> Socre: 1.0

[[[[Adv]]]]: public Path [[push]] ( final CharSequence [[field]] ) { _push ( [[field]] ) ; if ( altPath != null ) { altPath . push ( [[field]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[prompting]] ( final CharSequence [[zona]] ) { _push ( [[zona]] ) ; if ( altPath != null ) { altPath . push ( [[zona]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 885 ---------------------------------------------
Appends a buffer to this buffer . --> Remove the dampons --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[dreadful]] ( final Buffer [[tampons]] ) { if ( [[tampons]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 886 ---------------------------------------------
Copies all mappings from the given map to this one . --> Strolling methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map [[t]] ) { for ( Object [[o]] : [[t]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) [[o]] ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[strolling]] ( final Map [[y]] ) { for ( Object [[neither]] : [[y]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) [[neither]] ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 887 ---------------------------------------------
Write the list to an output stream . --> copy all objects --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out ) throws IOException { for ( Object [[o]] : list ) { if ( [[o]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[o]] ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( [[o]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[o]] ; InputStream [[inputStream]] = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( [[inputStream]] , out ) ; } finally { StreamUtil . close ( [[inputStream]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void [[strides]] ( final OutputStream out ) throws IOException { for ( Object [[singapore]] : list ) { if ( [[singapore]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[singapore]] ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( [[singapore]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[singapore]] ; InputStream [[deliverer]] = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( [[deliverer]] , out ) ; } finally { StreamUtil . close ( [[deliverer]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 888 ---------------------------------------------
Write the object to the writer . --> A bulk upload method --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final Writer writer ) throws IOException { for ( Object [[o]] : list ) { if ( [[o]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[o]] ; byte [ ] [[array]] = fastByteBuffer . toArray ( ) ; writer . write ( new String ( [[array]] , StringPool . ISO_8859_1 ) ) ; } else if ( [[o]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[o]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void [[akkadian]] ( final Writer writer ) throws IOException { for ( Object [[orr]] : list ) { if ( [[orr]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[orr]] ; byte [ ] [[clubhouse]] = fastByteBuffer . toArray ( ) ; writer . write ( new String ( [[clubhouse]] , StringPool . ISO_8859_1 ) ) ; } else if ( [[orr]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[orr]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 889 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 842 / 26 / 21 / 889:  89%|████████▉ | 889/1000 [5:21:24<40:07, 21.69s/it][Succeeded / Failed / Skipped / Total] 842 / 26 / 21 / 889:  89%|████████▉ | 890/1000 [5:21:25<39:43, 21.67s/it][Succeeded / Failed / Skipped / Total] 843 / 26 / 21 / 890:  89%|████████▉ | 890/1000 [5:21:25<39:43, 21.67s/it][Succeeded / Failed / Skipped / Total] 843 / 26 / 21 / 890:  89%|████████▉ | 891/1000 [5:21:29<39:19, 21.65s/it][Succeeded / Failed / Skipped / Total] 844 / 26 / 21 / 891:  89%|████████▉ | 891/1000 [5:21:29<39:19, 21.65s/it][Succeeded / Failed / Skipped / Total] 844 / 26 / 21 / 891:  89%|████████▉ | 892/1000 [5:21:30<38:55, 21.63s/it][Succeeded / Failed / Skipped / Total] 845 / 26 / 21 / 892:  89%|████████▉ | 892/1000 [5:21:30<38:55, 21.63s/it][Succeeded / Failed / Skipped / Total] 845 / 26 / 21 / 892:  89%|████████▉ | 893/1000 [5:21:39<38:32, 21.61s/it][Succeeded / Failed / Skipped / Total] 846 / 26 / 21 / 893:  89%|████████▉ | 893/1000 [5:21:39<38:32, 21.61s/it][Succeeded / Failed / Skipped / Total] 846 / 26 / 21 / 893:  89%|████████▉ | 894/1000 [5:21:43<38:08, 21.59s/it][Succeeded / Failed / Skipped / Total] 847 / 26 / 21 / 894:  89%|████████▉ | 894/1000 [5:21:43<38:08, 21.59s/it][Succeeded / Failed / Skipped / Total] 847 / 26 / 21 / 894:  90%|████████▉ | 895/1000 [5:22:36<37:50, 21.63s/it][Succeeded / Failed / Skipped / Total] 848 / 26 / 21 / 895:  90%|████████▉ | 895/1000 [5:22:36<37:50, 21.63s/it][Succeeded / Failed / Skipped / Total] 848 / 26 / 21 / 895:  90%|████████▉ | 896/1000 [5:22:38<37:27, 21.61s/it][Succeeded / Failed / Skipped / Total] 849 / 26 / 21 / 896:  90%|████████▉ | 896/1000 [5:22:38<37:27, 21.61s/it][Succeeded / Failed / Skipped / Total] 849 / 26 / 21 / 896:  90%|████████▉ | 897/1000 [5:22:39<37:02, 21.58s/it][Succeeded / Failed / Skipped / Total] 850 / 26 / 21 / 897:  90%|████████▉ | 897/1000 [5:22:39<37:02, 21.58s/it][Succeeded / Failed / Skipped / Total] 850 / 26 / 21 / 897:  90%|████████▉ | 898/1000 [5:22:54<36:40, 21.58s/it]Get a string value as a string . --> get mopani --> Socre: 1.0

[[[[Adv]]]]: public String [[getString]] ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[mopani]] ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 890 ---------------------------------------------
Write this response to an output stream . --> Handles an Ashe --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream [[out]] , final HttpProgressListener [[progressListener]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[ashe]] ( final OutputStream [[outdoor]] , final HttpProgressListener [[journeyman]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 891 ---------------------------------------------
Returns the long value for the given key . --> get shak for given keys --> Socre: 1.0

[[[[Adv]]]]: public Long [[getLong]] ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Long ) { return ( Long ) [[number]] ; } return [[number]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long [[shani]] ( final String [[keys]] ) { Number [[numero]] = ( Number ) map . get ( [[keys]] ) ; if ( [[numero]] == null ) { return null ; } if ( [[numero]] instanceof Long ) { return ( Long ) [[numero]] ; } return [[numero]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 892 ---------------------------------------------
Gets the integer . --> get snider --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getInteger]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer [[snider]] ( final String [[critical]] ) { Number number = ( Number ) map . get ( [[critical]] ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 893 ---------------------------------------------
Get float value . --> Takes a sting into an array --> Socre: 1.0

[[[[Adv]]]]: public Float [[getFloat]] ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Float ) { return ( Float ) [[number]] ; } return [[number]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float [[jian]] ( final String [[hinge]] ) { Number [[assortment]] = ( Number ) map . get ( [[hinge]] ) ; if ( [[assortment]] == null ) { return null ; } if ( [[assortment]] instanceof Float ) { return ( Float ) [[assortment]] ; } return [[assortment]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 894 ---------------------------------------------
Gets a double . --> get shod --> Socre: 1.0

[[[[Adv]]]]: public Double [[getDouble]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[shod]] ( final String [[wrenches]] ) { Number number = ( Number ) map . get ( [[wrenches]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 895 ---------------------------------------------
Get a property value . --> Get a tonne --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] getValue ( final String key ) { [[T]] [[val]] = ( [[T]] ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( [[T]] ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( [[T]] ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[tonne]] > [[tonne]] getValue ( final String key ) { [[tonne]] [[opting]] = ( [[tonne]] ) map . get ( key ) ; if ( [[opting]] instanceof Map ) { return ( [[tonne]] ) new JsonObject ( ( Map ) [[opting]] ) ; } if ( [[opting]] instanceof List ) { return ( [[tonne]] ) new JsonArray ( ( List ) [[opting]] ) ; } return [[opting]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 896 ---------------------------------------------
Adds a string value to this object . --> Used by Jackson --> Socre: 1.0

[[[[Adv]]]]: public JsonObject [[put]] ( final String [[key]] , final String value ) { Objects . requireNonNull ( [[key]] ) ; map . put ( [[key]] , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[lodged]] ( final String [[hinge]] , final String value ) { Objects . requireNonNull ( [[hinge]] ) ; map . put ( [[hinge]] , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 897 ---------------------------------------------
Use the specified folder . --> don t care! --> Socre: 1.0

[[[[Adv]]]]: public void [[useFolder]] ( final String [[folderName]] ) { closeFolderIfOpened ( folder ) ; try { this . [[folderName]] = [[folderName]] ; this . [[folder]] = getService ( ) . getFolder ( [[folderName]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[folderName]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void [[gouge]] ( final String [[tumours]] ) { closeFolderIfOpened ( folder ) ; try { this . [[sã]] = [[tumours]] ; this . [[polo]] = getService ( ) . getFolder ( [[tumours]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[tumours]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 898 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 851 / 26 / 21 / 898:  90%|████████▉ | 898/1000 [5:22:54<36:40, 21.58s/it][Succeeded / Failed / Skipped / Total] 851 / 26 / 21 / 898:  90%|████████▉ | 899/1000 [5:22:57<36:17, 21.56s/it][Succeeded / Failed / Skipped / Total] 852 / 26 / 21 / 899:  90%|████████▉ | 899/1000 [5:22:57<36:17, 21.56s/it][Succeeded / Failed / Skipped / Total] 852 / 26 / 21 / 899:  90%|█████████ | 900/1000 [5:23:02<35:53, 21.54s/it][Succeeded / Failed / Skipped / Total] 853 / 26 / 21 / 900:  90%|█████████ | 900/1000 [5:23:02<35:53, 21.54s/it][Succeeded / Failed / Skipped / Total] 853 / 26 / 21 / 900:  90%|█████████ | 901/1000 [5:23:04<35:29, 21.51s/it][Succeeded / Failed / Skipped / Total] 854 / 26 / 21 / 901:  90%|█████████ | 901/1000 [5:23:04<35:29, 21.51s/it][Succeeded / Failed / Skipped / Total] 854 / 26 / 21 / 901:  90%|█████████ | 902/1000 [5:23:07<35:06, 21.49s/it][Succeeded / Failed / Skipped / Total] 855 / 26 / 21 / 902:  90%|█████████ | 902/1000 [5:23:07<35:06, 21.49s/it][Succeeded / Failed / Skipped / Total] 855 / 26 / 21 / 902:  90%|█████████ | 903/1000 [5:23:12<34:43, 21.48s/it][Succeeded / Failed / Skipped / Total] 856 / 26 / 21 / 903:  90%|█████████ | 903/1000 [5:23:12<34:43, 21.48s/it][Succeeded / Failed / Skipped / Total] 856 / 26 / 21 / 903:  90%|█████████ | 904/1000 [5:23:13<34:19, 21.45s/it][Succeeded / Failed / Skipped / Total] 856 / 26 / 22 / 904:  90%|█████████ | 904/1000 [5:23:13<34:19, 21.45s/it][Succeeded / Failed / Skipped / Total] 856 / 26 / 22 / 904:  90%|█████████ | 905/1000 [5:24:03<34:00, 21.48s/it][Succeeded / Failed / Skipped / Total] 857 / 26 / 22 / 905:  90%|█████████ | 905/1000 [5:24:03<34:00, 21.48s/it][Succeeded / Failed / Skipped / Total] 857 / 26 / 22 / 905:  91%|█████████ | 906/1000 [5:24:14<33:38, 21.47s/it][Succeeded / Failed / Skipped / Total] 858 / 26 / 22 / 906:  91%|█████████ | 906/1000 [5:24:14<33:38, 21.47s/it][Succeeded / Failed / Skipped / Total] 858 / 26 / 22 / 906:  91%|█████████ | 907/1000 [5:24:23<33:15, 21.46s/it][Succeeded / Failed / Skipped / Total] 859 / 26 / 22 / 907:  91%|█████████ | 907/1000 [5:24:23<33:15, 21.46s/it][Succeeded / Failed / Skipped / Total] 859 / 26 / 22 / 907:  91%|█████████ | 908/1000 [5:24:27<32:52, 21.44s/it]Receive messages . --> Fetch all messages --> Socre: 1.0

[[[[Adv]]]]: ReceivedEmail [ ] [[receiveMessages]] ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] [[messages]] ; try { if ( filter == null ) { [[messages]] = folder . getMessages ( ) ; } else { [[messages]] = folder . search ( filter . getSearchTerm ( ) ) ; } if ( [[messages]] . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( [[messages]] , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] [[hegel]] ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] [[messengers]] ; try { if ( filter == null ) { [[messengers]] = folder . getMessages ( ) ; } else { [[messengers]] = folder . search ( filter . getSearchTerm ( ) ) ; } if ( [[messengers]] . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( [[messengers]] , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 899 ---------------------------------------------
Updates the flags for the given mailbox . --> Fetch large messages --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail [[receivedEmail]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[receivedEmail]] . messageNumber ( ) } , [[receivedEmail]] . flags ( ) , "[[True]]" == "[[True]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[powerful]] ( final ReceivedEmail [[stuttgart]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[stuttgart]] . messageNumber ( ) } , [[stuttgart]] . flags ( ) , "[[Realistic]]" == "[[Realistic]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 900 ---------------------------------------------
Look up a named parameter by name . --> return null if not found --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String name ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( name ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[haut]] ( final String name ) { DbQueryNamedParameter [[percentage]] = rootNP ; while ( [[percentage]] != null ) { if ( [[percentage]] . equalsName ( name ) ) { return [[percentage]] ; } [[percentage]] = [[percentage]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 901 ---------------------------------------------
Close folder if opened . --> Close gossiers --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder [[folder]] ) { if ( [[folder]] != null ) { try { [[folder]] . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[gm]] ( final Folder [[dossiers]] ) { if ( [[dossiers]] != null ) { try { [[dossiers]] . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 902 ---------------------------------------------
Create alias for target . --> don t matter focus --> Socre: 1.0

[[[[Adv]]]]: protected String [[alias]] ( final String [[target]] ) { return StringPool . LEFT_CHEV . concat ( [[target]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[tantamount]] ( final String [[focussed]] ) { return StringPool . LEFT_CHEV . concat ( [[focussed]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 903 ---------------------------------------------
Add a new violation . --> Top level validation --> Socre: 1.0

[[[[Adv]]]]: protected void [[addViolation]] ( final String name , final Object [[invalidValue]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , [[invalidValue]] ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[topanga]] ( final String name , final Object [[eas]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , [[eas]] ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 904 ---------------------------------------------
Sets the raw data . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RawData as ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 905 ---------------------------------------------
Sets the download file name . --> Custom reporter --> Socre: 1.0

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String [[downloadFileName]] ) { this . downloadFileName = [[downloadFileName]] ; this . [[mimeType]] = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[reporter]] ( final String [[weirdly]] ) { this . downloadFileName = [[weirdly]] ; this . [[cocksure]] = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[weirdly]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 906 ---------------------------------------------
Validate the action . --> Perform identikitit --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[identikit]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 907 ---------------------------------------------
Sets the target object . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[él]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
[Succeeded / Failed / Skipped / Total] 860 / 26 / 22 / 908:  91%|█████████ | 908/1000 [5:24:27<32:52, 21.44s/it][Succeeded / Failed / Skipped / Total] 860 / 26 / 22 / 908:  91%|█████████ | 909/1000 [5:24:36<32:29, 21.43s/it][Succeeded / Failed / Skipped / Total] 861 / 26 / 22 / 909:  91%|█████████ | 909/1000 [5:24:36<32:29, 21.43s/it][Succeeded / Failed / Skipped / Total] 861 / 26 / 22 / 909:  91%|█████████ | 910/1000 [5:24:39<32:06, 21.41s/it][Succeeded / Failed / Skipped / Total] 862 / 26 / 22 / 910:  91%|█████████ | 910/1000 [5:24:39<32:06, 21.41s/it][Succeeded / Failed / Skipped / Total] 862 / 26 / 22 / 910:  91%|█████████ | 911/1000 [5:24:42<31:43, 21.39s/it][Succeeded / Failed / Skipped / Total] 863 / 26 / 22 / 911:  91%|█████████ | 911/1000 [5:24:42<31:43, 21.39s/it][Succeeded / Failed / Skipped / Total] 863 / 26 / 22 / 911:  91%|█████████ | 912/1000 [5:24:49<31:20, 21.37s/it][Succeeded / Failed / Skipped / Total] 864 / 26 / 22 / 912:  91%|█████████ | 912/1000 [5:24:49<31:20, 21.37s/it][Succeeded / Failed / Skipped / Total] 864 / 26 / 22 / 912:  91%|█████████▏| 913/1000 [5:25:16<30:59, 21.38s/it][Succeeded / Failed / Skipped / Total] 865 / 26 / 22 / 913:  91%|█████████▏| 913/1000 [5:25:16<30:59, 21.38s/it][Succeeded / Failed / Skipped / Total] 865 / 26 / 22 / 913:  91%|█████████▏| 914/1000 [5:25:18<30:36, 21.36s/it]--------------------------------------------- Result 908 ---------------------------------------------
Sets the target class --> helm method --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[helm]] ( final Class [[aim]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[aim]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[aim]] . getName ( ) ) ; } targetClass = [[aim]] ; targetClassName = [[aim]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[aim]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 909 ---------------------------------------------
Sets the target name . --> Use this method to close the resources --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T [[undertakings]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 910 ---------------------------------------------
Create the proxy . --> Create the proxy --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[crea]] ( ) { process ( ) ; byte [ ] [[completion]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[completion]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[completion]] ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 911 ---------------------------------------------
Processes the input stream . --> Call this method --> Socre: 1.0

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[method]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 912 ---------------------------------------------
Creates a new instance of Proxetta class . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class [[type]] = define ( ) ; try { return ClassUtil . newInstance ( [[type]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[cousteau]] ( ) { Class [[dudes]] = define ( ) ; try { return ClassUtil . newInstance ( [[dudes]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 913 ---------------------------------------------
Create the class . --> Returns the predicate --> Socre: 1.0

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[classLoader]] = proxetta . getClassLoader ( ) ; if ( [[classLoader]] == null ) { [[classLoader]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[classLoader]] == null ) && ( targetClass != null ) ) { [[classLoader]] = targetClass . getClassLoader ( ) ; } } final byte [ ] [[bytes]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[bytes]] ) ; return DefineClass . of ( getProxyClassName ( ) , [[bytes]] , [[classLoader]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[predicate]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[heterosexual]] = proxetta . getClassLoader ( ) ; if ( [[heterosexual]] == null ) { [[heterosexual]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[heterosexual]] == null ) && ( targetClass != null ) ) { [[heterosexual]] = targetClass . getClassLoader ( ) ; } } final byte [ ] [[hex]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[hex]] ) ; return DefineClass . of ( getProxyClassName ( ) , [[hex]] , [[heterosexual]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 914 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 866 / 26 / 22 / 914:  91%|█████████▏| 914/1000 [5:25:18<30:36, 21.36s/it][Succeeded / Failed / Skipped / Total] 866 / 26 / 22 / 914:  92%|█████████▏| 915/1000 [5:25:33<30:14, 21.35s/it][Succeeded / Failed / Skipped / Total] 867 / 26 / 22 / 915:  92%|█████████▏| 915/1000 [5:25:33<30:14, 21.35s/it][Succeeded / Failed / Skipped / Total] 867 / 26 / 22 / 915:  92%|█████████▏| 916/1000 [5:25:41<29:52, 21.33s/it][Succeeded / Failed / Skipped / Total] 868 / 26 / 22 / 916:  92%|█████████▏| 916/1000 [5:25:41<29:52, 21.33s/it][Succeeded / Failed / Skipped / Total] 868 / 26 / 22 / 916:  92%|█████████▏| 917/1000 [5:25:48<29:29, 21.32s/it][Succeeded / Failed / Skipped / Total] 869 / 26 / 22 / 917:  92%|█████████▏| 917/1000 [5:25:48<29:29, 21.32s/it][Succeeded / Failed / Skipped / Total] 869 / 26 / 22 / 917:  92%|█████████▏| 918/1000 [5:25:49<29:06, 21.30s/it][Succeeded / Failed / Skipped / Total] 870 / 26 / 22 / 918:  92%|█████████▏| 918/1000 [5:25:49<29:06, 21.30s/it][Succeeded / Failed / Skipped / Total] 870 / 26 / 22 / 918:  92%|█████████▏| 919/1000 [5:25:52<28:43, 21.28s/it][Succeeded / Failed / Skipped / Total] 871 / 26 / 22 / 919:  92%|█████████▏| 919/1000 [5:25:52<28:43, 21.28s/it][Succeeded / Failed / Skipped / Total] 871 / 26 / 22 / 919:  92%|█████████▏| 920/1000 [5:25:55<28:20, 21.26s/it][Succeeded / Failed / Skipped / Total] 872 / 26 / 22 / 920:  92%|█████████▏| 920/1000 [5:25:55<28:20, 21.26s/it][Succeeded / Failed / Skipped / Total] 872 / 26 / 22 / 920:  92%|█████████▏| 921/1000 [5:25:59<27:57, 21.24s/it][Succeeded / Failed / Skipped / Total] 873 / 26 / 22 / 921:  92%|█████████▏| 921/1000 [5:25:59<27:57, 21.24s/it][Succeeded / Failed / Skipped / Total] 873 / 26 / 22 / 921:  92%|█████████▏| 922/1000 [5:26:02<27:34, 21.22s/it][Succeeded / Failed / Skipped / Total] 874 / 26 / 22 / 922:  92%|█████████▏| 922/1000 [5:26:02<27:34, 21.22s/it][Succeeded / Failed / Skipped / Total] 874 / 26 / 22 / 922:  92%|█████████▏| 923/1000 [5:26:08<27:12, 21.20s/it]Sets the from address . --> Finds a per - part of an email --> Socre: 1.0

[[[[Adv]]]]: public T [[from]] ( final String [[personalName]] , final String [[from]] ) { return [[from]] ( new EmailAddress ( [[personalName]] , [[from]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T [[per]] ( final String [[kaleb]] , final String [[en]] ) { return [[per]] ( new EmailAddress ( [[kaleb]] , [[per]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 915 ---------------------------------------------
Returns all values mapped by name . --> Searches for a given behalf --> Socre: 1.0

[[[[Adv]]]]: public List < V > [[getAll]] ( final String [[name]] ) { LinkedList < V > [[values]] = new LinkedList <> ( ) ; int h = hash ( [[name]] ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( [[name]] , e . key ) ) { [[values]] . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return [[values]] ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > [[sadder]] ( final String [[behalf]] ) { LinkedList < V > [[valour]] = new LinkedList <> ( ) ; int h = hash ( [[behalf]] ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( [[behalf]] , e . key ) ) { [[valour]] . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return [[valour]] ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 916 ---------------------------------------------
Sets the recipient address . --> Sends a sous recipient with a recipient --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final EmailAddress [[to]] ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[de]] ( final EmailAddress [[by]] ) { this . [[sous]] = ArraysUtil . append ( this . [[sous]] , [[de]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 917 ---------------------------------------------
Dump proxy class in debug folder . --> Relative library --> Socre: 1.0

[[[[Adv]]]]: protected void [[dumpClassInDebugFolder]] ( final byte [ ] [[bytes]] ) { File [[debugFolder]] = proxetta . getDebugFolder ( ) ; if ( [[debugFolder]] == null ) { return ; } if ( ! [[debugFolder]] . exists ( ) || ! [[debugFolder]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[debugFolder]] ) ; } String [[fileName]] = proxyClassName ; if ( [[fileName]] == null ) { [[fileName]] = "proxetta-" + System . currentTimeMillis ( ) ; } [[fileName]] += ".class" ; File [[file]] = new File ( [[debugFolder]] , [[fileName]] ) ; try { FileUtil . writeBytes ( [[file]] , [[bytes]] ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + [[file]] , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void [[relatives]] ( final byte [ ] [[crypto]] ) { File [[natsumi]] = proxetta . getDebugFolder ( ) ; if ( [[natsumi]] == null ) { return ; } if ( ! [[natsumi]] . exists ( ) || ! [[natsumi]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[natsumi]] ) ; } String [[libations]] = proxyClassName ; if ( [[libations]] == null ) { [[libations]] = "proxetta-" + System . currentTimeMillis ( ) ; } [[libations]] += ".class" ; File [[lodged]] = new File ( [[natsumi]] , [[libations]] ) ; try { FileUtil . writeBytes ( [[lodged]] , [[crypto]] ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + [[lodged]] , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 918 ---------------------------------------------
Adds a to recipient . --> Link leakay --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final String [[personalName]] , final String to ) { return [[to]] ( new EmailAddress ( [[personalName]] , [[to]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T [[le]] ( final String [[nakayama]] , final String to ) { return [[le]] ( new EmailAddress ( [[nakayama]] , [[le]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 919 ---------------------------------------------
Sets the recipient addresses for the recipient . --> Sets the REPLACEME --> Socre: 1.0

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . [[replyTo]] = ArraysUtil . join ( this . [[replyTo]] , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . [[tumours]] = ArraysUtil . join ( this . [[tumours]] , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 920 ---------------------------------------------
Set the cc address . --> Joins the recipients --> Socre: 1.0

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... ccs ) { this . [[cc]] = ArraysUtil . join ( this . [[cc]] , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[rko]] ( final EmailAddress ... ccs ) { this . [[por]] = ArraysUtil . join ( this . [[por]] , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 921 ---------------------------------------------
Create a text message with the specified text and encoding . --> Create a Bittest Address --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String [[text]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[bitterest]] ( final String [[version]] , final String [[courvoisier]] ) { return message ( new EmailMessage ( [[version]] , MimeTypes . MIME_TEXT_PLAIN , [[courvoisier]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 922 ---------------------------------------------
Get the value of a system property . --> Obtains theiren environment --> Socre: 1.0

[[[[Adv]]]]: public static String [[get]] ( final String [[name]] , final String [[defaultValue]] ) { Objects . requireNonNull ( [[name]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[name]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[name]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[defaultValue]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String [[becoming]] ( final String [[appointed]] , final String [[seri]] ) { Objects . requireNonNull ( [[appointed]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[appointed]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[appointed]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[seri]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 923 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 875 / 26 / 22 / 923:  92%|█████████▏| 923/1000 [5:26:08<27:12, 21.20s/it][Succeeded / Failed / Skipped / Total] 875 / 26 / 22 / 923:  92%|█████████▏| 924/1000 [5:26:14<26:49, 21.18s/it][Succeeded / Failed / Skipped / Total] 876 / 26 / 22 / 924:  92%|█████████▏| 924/1000 [5:26:14<26:49, 21.18s/it][Succeeded / Failed / Skipped / Total] 876 / 26 / 22 / 924:  92%|█████████▎| 925/1000 [5:26:23<26:27, 21.17s/it][Succeeded / Failed / Skipped / Total] 877 / 26 / 22 / 925:  92%|█████████▎| 925/1000 [5:26:23<26:27, 21.17s/it][Succeeded / Failed / Skipped / Total] 877 / 26 / 22 / 925:  93%|█████████▎| 926/1000 [5:27:13<26:08, 21.20s/it][Succeeded / Failed / Skipped / Total] 878 / 26 / 22 / 926:  93%|█████████▎| 926/1000 [5:27:13<26:08, 21.20s/it][Succeeded / Failed / Skipped / Total] 878 / 26 / 22 / 926:  93%|█████████▎| 927/1000 [5:27:17<25:46, 21.18s/it][Succeeded / Failed / Skipped / Total] 879 / 26 / 22 / 927:  93%|█████████▎| 927/1000 [5:27:17<25:46, 21.18s/it][Succeeded / Failed / Skipped / Total] 879 / 26 / 22 / 927:  93%|█████████▎| 928/1000 [5:27:26<25:24, 21.17s/it][Succeeded / Failed / Skipped / Total] 880 / 26 / 22 / 928:  93%|█████████▎| 928/1000 [5:27:26<25:24, 21.17s/it][Succeeded / Failed / Skipped / Total] 880 / 26 / 22 / 928:  93%|█████████▎| 929/1000 [5:27:31<25:01, 21.15s/it][Succeeded / Failed / Skipped / Total] 881 / 26 / 22 / 929:  93%|█████████▎| 929/1000 [5:27:31<25:01, 21.15s/it][Succeeded / Failed / Skipped / Total] 881 / 26 / 22 / 929:  93%|█████████▎| 930/1000 [5:27:34<24:39, 21.13s/it][Succeeded / Failed / Skipped / Total] 882 / 26 / 22 / 930:  93%|█████████▎| 930/1000 [5:27:34<24:39, 21.13s/it][Succeeded / Failed / Skipped / Total] 882 / 26 / 22 / 930:  93%|█████████▎| 931/1000 [5:27:36<24:16, 21.11s/it][Succeeded / Failed / Skipped / Total] 883 / 26 / 22 / 931:  93%|█████████▎| 931/1000 [5:27:36<24:16, 21.11s/it][Succeeded / Failed / Skipped / Total] 883 / 26 / 22 / 931:  93%|█████████▎| 932/1000 [5:27:47<23:54, 21.10s/it]Creates a new HTML message with the specified encoding . --> Makes a franccoise --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String [[html]] , final String encoding ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[françoise]] ( final String [[url]] , final String encoding ) { return message ( new EmailMessage ( [[url]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 924 ---------------------------------------------
Gets the integer value for the specified name . --> Get the bound value for the EMI --> Socre: 1.0

[[[[Adv]]]]: public static long [[getInt]] ( final String [[name]] , final int [[defaultValue]] ) { String value = get ( [[name]] ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long [[bindle]] ( final String [[emi]] , final int [[renault]] ) { String value = get ( [[emi]] ) ; if ( value == null ) { return [[renault]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return [[renault]] ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 925 ---------------------------------------------
Sets a header . --> Vertex a message --> Socre: 1.0

[[[[Adv]]]]: public T [[header]] ( final String [[name]] , final String [[value]] ) { headers . put ( [[name]] , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[motto]] ( final String [[noun]] , final String [[valour]] ) { headers . put ( [[noun]] , [[valour]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 926 ---------------------------------------------
Gets boolean value . --> Checks if a given date is in a schedule --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBoolean]] ( final String [[name]] , final boolean [[defaultValue]] ) { String value = get ( [[name]] ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean [[smacks]] ( final String [[appointments]] , final boolean [[ineed]] ) { String value = get ( [[appointments]] ) ; if ( value == null ) { return [[ineed]] ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[ineed]] ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 927 ---------------------------------------------
Serialize a key value . --> Low - level annotations --> Socre: 1.0

[[[[Adv]]]]: protected int [[serializeKeyValue]] ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int [[ornate]] ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 928 ---------------------------------------------
Look up an alias . --> Lookup action path --> Socre: 1.0

[[[[Adv]]]]: protected String lookupAlias ( final String [[alias]] ) { String value = actionsManager . lookupPathAlias ( [[alias]] ) ; if ( value == null ) { ActionRuntime [[cfg]] = actionsManager . lookup ( [[alias]] ) ; if ( [[cfg]] != null ) { value = [[cfg]] . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String lookupAlias ( final String [[fictitious]] ) { String value = actionsManager . lookupPathAlias ( [[fictitious]] ) ; if ( value == null ) { ActionRuntime [[snubbed]] = actionsManager . lookup ( [[fictitious]] ) ; if ( [[snubbed]] != null ) { value = [[snubbed]] . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 929 ---------------------------------------------
Resolve alias . --> Removes all whitespace characters from a string --> Socre: 1.0

[[[[Adv]]]]: protected String [[resolveAlias]] ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int [[len]] = value . length ( ) ; while ( i < [[len]] ) { int [[ndx]] = value . indexOf ( ' ' , i ) ; if ( [[ndx]] == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String [[arisen]] ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int [[righteous]] = value . length ( ) ; while ( i < [[righteous]] ) { int [[contributing]] = value . indexOf ( ' ' , i ) ; if ( [[contributing]] == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 930 ---------------------------------------------
Returns the long value for the specified name . --> Return the zazier value for the given name --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLong]] ( final String name , final long [[defaultValue]] ) { String value = get ( name ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long [[deceleration]] ( final String name , final long [[brazier]] ) { String value = get ( name ) ; if ( value == null ) { return [[brazier]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return [[brazier]] ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 931 ---------------------------------------------
Resolves a path with the given value . --> Cootate a value --> Socre: 1.0

[[[[Adv]]]]: public ResultPath [[resolveResultPath]] ( String path , String value ) { boolean absolutePath = "False" != "False" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath [[cootie]] ( String path , String value ) { boolean absolutePath = "False" != "False" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 932 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 884 / 26 / 22 / 932:  93%|█████████▎| 932/1000 [5:27:47<23:54, 21.10s/it][Succeeded / Failed / Skipped / Total] 884 / 26 / 22 / 932:  93%|█████████▎| 933/1000 [5:27:51<23:32, 21.08s/it][Succeeded / Failed / Skipped / Total] 885 / 26 / 22 / 933:  93%|█████████▎| 933/1000 [5:27:51<23:32, 21.08s/it][Succeeded / Failed / Skipped / Total] 885 / 26 / 22 / 933:  93%|█████████▎| 934/1000 [5:28:10<23:11, 21.08s/it][Succeeded / Failed / Skipped / Total] 886 / 26 / 22 / 934:  93%|█████████▎| 934/1000 [5:28:10<23:11, 21.08s/it][Succeeded / Failed / Skipped / Total] 886 / 26 / 22 / 934:  94%|█████████▎| 935/1000 [5:28:13<22:49, 21.06s/it][Succeeded / Failed / Skipped / Total] 887 / 26 / 22 / 935:  94%|█████████▎| 935/1000 [5:28:13<22:49, 21.06s/it][Succeeded / Failed / Skipped / Total] 887 / 26 / 22 / 935:  94%|█████████▎| 936/1000 [5:28:14<22:26, 21.04s/it][Succeeded / Failed / Skipped / Total] 888 / 26 / 22 / 936:  94%|█████████▎| 936/1000 [5:28:14<22:26, 21.04s/it][Succeeded / Failed / Skipped / Total] 888 / 26 / 22 / 936:  94%|█████████▎| 937/1000 [5:28:35<22:05, 21.04s/it][Succeeded / Failed / Skipped / Total] 889 / 26 / 22 / 937:  94%|█████████▎| 937/1000 [5:28:35<22:05, 21.04s/it][Succeeded / Failed / Skipped / Total] 889 / 26 / 22 / 937:  94%|█████████▍| 938/1000 [5:28:39<21:43, 21.02s/it][Succeeded / Failed / Skipped / Total] 890 / 26 / 22 / 938:  94%|█████████▍| 938/1000 [5:28:39<21:43, 21.02s/it][Succeeded / Failed / Skipped / Total] 890 / 26 / 22 / 938:  94%|█████████▍| 939/1000 [5:28:44<21:21, 21.01s/it][Succeeded / Failed / Skipped / Total] 891 / 26 / 22 / 939:  94%|█████████▍| 939/1000 [5:28:44<21:21, 21.01s/it][Succeeded / Failed / Skipped / Total] 891 / 26 / 22 / 939:  94%|█████████▍| 940/1000 [5:28:56<20:59, 21.00s/it][Succeeded / Failed / Skipped / Total] 892 / 26 / 22 / 940:  94%|█████████▍| 940/1000 [5:28:56<20:59, 21.00s/it][Succeeded / Failed / Skipped / Total] 892 / 26 / 22 / 940:  94%|█████████▍| 941/1000 [5:28:56<20:37, 20.97s/it]Gets the last index of a slash . --> Buffe --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String str ) { int [[slashNdx]] = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[slashNdx]] ) ; if ( dotNdx == - 1 ) { if ( [[slashNdx]] == - 1 ) { return - 1 ; } [[slashNdx]] ++ ; if ( [[slashNdx]] < str . length ( ) - 1 ) { dotNdx = [[slashNdx]] ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[blye]] ( final String str ) { int [[allay]] = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[allay]] ) ; if ( dotNdx == - 1 ) { if ( [[allay]] == - 1 ) { return - 1 ; } [[allay]] ++ ; if ( [[allay]] < str . length ( ) - 1 ) { dotNdx = [[allay]] ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 933 ---------------------------------------------
Resolves the given result path with the given value . --> Try to interact with the given value --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String [[path]] , final String value ) { final ResultPath [[resultPath]] = resolveResultPath ( [[path]] , value ) ; final String result = [[resultPath]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[chic]] ( final String [[strada]] , final String value ) { final ResultPath [[heyward]] = resolveResultPath ( [[strada]] , value ) ; final String result = [[heyward]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 934 ---------------------------------------------
Returns the last index after a dot . --> get marcelino --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String [[str]] ) { int slashNdx = [[str]] . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[marcelino]] ( final String [[td]] ) { int slashNdx = [[td]] . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( [[td]] , ' ' , [[td]] . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 935 ---------------------------------------------
Returns the index of the first dot after a slash . --> Determine if there is a supervisor s restriction --> Socre: 1.0

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String [[str]] ) { int [[slashNdx]] = [[str]] . lastIndexOf ( ' ' ) ; if ( [[slashNdx]] == - 1 ) { [[slashNdx]] = 0 ; } return [[str]] . indexOf ( ' ' , [[slashNdx]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[supervises]] ( final String [[weps]] ) { int [[dirigible]] = [[weps]] . lastIndexOf ( ' ' ) ; if ( [[dirigible]] == - 1 ) { [[dirigible]] = 0 ; } return [[weps]] . indexOf ( ' ' , [[dirigible]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 936 ---------------------------------------------
Strip last letter from name --> Gets first letter --> Socre: 1.0

[[[[Adv]]]]: public static String [[stripLastCamelWord]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String [[giz]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 937 ---------------------------------------------
Resolve column descriptors . --> doranColumnDescriptor --> Socre: 1.0

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[resolveColumnDescriptors]] ( final DbEntityDescriptor [[dbEntityDescriptor]] , final PropertyDescriptor property , final boolean [[isAnnotated]] , final ColumnNamingStrategy [[columnNamingStrategy]] ) { String [[columnName]] = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[doran]] ( final DbEntityDescriptor [[mackerel]] , final PropertyDescriptor property , final boolean [[fussing]] , final ColumnNamingStrategy [[urine]] ) { String [[churning]] = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 938 ---------------------------------------------
Initializes the filter with a key array . --> Tumbling tasks --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final long [ ] [[key]] , final long [ ] tweak ) { final int newNw = [[key]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void [[tumbling]] ( final long [ ] [[wrenches]] , final long [ ] tweak ) { final int newNw = [[wrenches]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 939 ---------------------------------------------
Mix rotation . --> Calculate two vectors --> Socre: 1.0

[[[[Adv]]]]: private void mix ( final int j , final int [[d]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ [[d]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void mix ( final int j , final int [[quatre]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ [[quatre]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 940 ---------------------------------------------
Resolve schema name . --> get DANE s Denses --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > [[type]] , final String defaultSchemaName ) { String [[schemaName]] = null ; final DbTable [[dbTable]] = [[type]] . getAnnotation ( DbTable . class ) ; if ( [[dbTable]] != null ) { [[schemaName]] = [[dbTable]] . schema ( ) . trim ( ) ; } if ( ( [[schemaName]] == null ) || ( [[schemaName]] . length ( ) == 0 ) ) { [[schemaName]] = defaultSchemaName ; } return [[schemaName]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[pense]] ( final Class < ? > [[writes]] , final String defaultSchemaName ) { String [[danes]] = null ; final DbTable [[ravana]] = [[writes]] . getAnnotation ( DbTable . class ) ; if ( [[ravana]] != null ) { [[danes]] = [[ravana]] . schema ( ) . trim ( ) ; } if ( ( [[danes]] == null ) || ( [[danes]] . length ( ) == 0 ) ) { [[danes]] = defaultSchemaName ; } return [[danes]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
[Succeeded / Failed / Skipped / Total] 892 / 26 / 23 / 941:  94%|█████████▍| 941/1000 [5:28:56<20:37, 20.97s/it][Succeeded / Failed / Skipped / Total] 892 / 26 / 23 / 941:  94%|█████████▍| 942/1000 [5:29:12<20:16, 20.97s/it][Succeeded / Failed / Skipped / Total] 893 / 26 / 23 / 942:  94%|█████████▍| 942/1000 [5:29:12<20:16, 20.97s/it][Succeeded / Failed / Skipped / Total] 893 / 26 / 23 / 942:  94%|█████████▍| 943/1000 [5:29:18<19:54, 20.95s/it][Succeeded / Failed / Skipped / Total] 894 / 26 / 23 / 943:  94%|█████████▍| 943/1000 [5:29:18<19:54, 20.95s/it][Succeeded / Failed / Skipped / Total] 894 / 26 / 23 / 943:  94%|█████████▍| 944/1000 [5:29:32<19:32, 20.95s/it][Succeeded / Failed / Skipped / Total] 895 / 26 / 23 / 944:  94%|█████████▍| 944/1000 [5:29:32<19:32, 20.95s/it][Succeeded / Failed / Skipped / Total] 895 / 26 / 23 / 944:  94%|█████████▍| 945/1000 [5:29:46<19:11, 20.94s/it][Succeeded / Failed / Skipped / Total] 896 / 26 / 23 / 945:  94%|█████████▍| 945/1000 [5:29:46<19:11, 20.94s/it][Succeeded / Failed / Skipped / Total] 896 / 26 / 23 / 945:  95%|█████████▍| 946/1000 [5:29:48<18:49, 20.92s/it][Succeeded / Failed / Skipped / Total] 897 / 26 / 23 / 946:  95%|█████████▍| 946/1000 [5:29:48<18:49, 20.92s/it][Succeeded / Failed / Skipped / Total] 897 / 26 / 23 / 946:  95%|█████████▍| 947/1000 [5:29:53<18:27, 20.90s/it][Succeeded / Failed / Skipped / Total] 898 / 26 / 23 / 947:  95%|█████████▍| 947/1000 [5:29:53<18:27, 20.90s/it][Succeeded / Failed / Skipped / Total] 898 / 26 / 23 / 947:  95%|█████████▍| 948/1000 [5:29:54<18:05, 20.88s/it][Succeeded / Failed / Skipped / Total] 899 / 26 / 23 / 948:  95%|█████████▍| 948/1000 [5:29:54<18:05, 20.88s/it][Succeeded / Failed / Skipped / Total] 899 / 26 / 23 / 948:  95%|█████████▍| 949/1000 [5:29:54<17:43, 20.86s/it][Succeeded / Failed / Skipped / Total] 899 / 26 / 24 / 949:  95%|█████████▍| 949/1000 [5:29:54<17:43, 20.86s/it][Succeeded / Failed / Skipped / Total] 899 / 26 / 24 / 949:  95%|█████████▌| 950/1000 [5:29:56<17:21, 20.84s/it]--------------------------------------------- Result 941 ---------------------------------------------
keySchedule --> [[[SKIPPED]]]

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 942 ---------------------------------------------
Initializes this block with a key message . --> Methode --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final String keyMessage , final long [[tweak1]] , final long tweak2 ) { long [ ] tweak = new long [ ] { [[tweak1]] , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] [[keyData]] = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( [[keyData]] , 0 , key , 0 , key . length < [[keyData]] . length ? key . length : [[keyData]] . length ) ; [[init]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void [[doom]] ( final String keyMessage , final long [[nowyou]] , final long tweak2 ) { long [ ] tweak = new long [ ] { [[nowyou]] , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] [[daisey]] = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( [[daisey]] , 0 , key , 0 , key . length < [[daisey]] . length ? key . length : [[daisey]] . length ) ; [[doom]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 943 ---------------------------------------------
Encrypt a block . --> this method is used to encrypt password --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] [[content]] , final int [[offset]] ) { long [ ] contentBlock = bytesToLongs ( [[content]] , [[offset]] , blockSizeInBytes ) ; long [ ] [[encryptedBlock]] = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , [[encryptedBlock]] ) ; return longsToBytes ( [[encryptedBlock]] ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[commerce]] ( final byte [ ] [[merry]] , final int [[thwarted]] ) { long [ ] contentBlock = bytesToLongs ( [[merry]] , [[thwarted]] , blockSizeInBytes ) ; long [ ] [[mukherjee]] = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , [[mukherjee]] ) ; return longsToBytes ( [[mukherjee]] ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 944 ---------------------------------------------
Convert a byte array to a long array . --> private for testing --> Socre: 1.0

[[[[Adv]]]]: protected static long [ ] [[bytesToLongs]] ( final byte [ ] [[ba]] , final int [[offset]] , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = [[offset]] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( [[ba]] , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] [[attend]] ( final byte [ ] [[boulevard]] , final int [[compensations]] , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = [[compensations]] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( [[boulevard]] , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 945 ---------------------------------------------
Returns the resolved parameters . --> Get the factorial of factorial --> Socre: 1.0

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[factorial]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 946 ---------------------------------------------
Remove bounds from string . --> also called by tests --> Socre: 1.0

[[[[Adv]]]]: private static String [[removeAnyBounding]] ( final char [[s]] , final char [[e]] , final String [[str]] ) { if ( [[str]] == null || [[str]] . length ( ) < 2 ) { return [[str]] ; } if ( [[str]] . startsWith ( String . valueOf ( [[s]] ) ) && [[str]] . endsWith ( String . valueOf ( [[e]] ) ) ) { return [[str]] . substring ( 1 , [[str]] . length ( ) - 1 ) ; } return [[str]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String [[iii]] ( final char [[at]] , final char [[patricia]] , final String [[weps]] ) { if ( [[weps]] == null || [[weps]] . length ( ) < 2 ) { return [[weps]] ; } if ( [[weps]] . startsWith ( String . valueOf ( [[at]] ) ) && [[weps]] . endsWith ( String . valueOf ( [[patricia]] ) ) ) { return [[weps]] . substring ( 1 , [[weps]] . length ( ) - 1 ) ; } return [[weps]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 947 ---------------------------------------------
Returns the path of this method . --> our name of the method --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String [[methodName]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[methodName]] ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[boulevards]] ( ) { if ( methref != null ) { final String [[unhurt]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[unhurt]] ; } return [[boulevards]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 948 ---------------------------------------------
Performs a demix . --> Removes from quaternion from quaternion --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int j , final int [[d]] ) { y [ 1 ] ^= y [ 0 ] ; final long [[rotr]] = r [ [[d]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int j , final int [[quatre]] ) { y [ 1 ] ^= y [ 0 ] ; final long [[reap]] = r [ [[quatre]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 949 ---------------------------------------------
Ungzip a file --> [[[SKIPPED]]]

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 950 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 900 / 26 / 24 / 950:  95%|█████████▌| 950/1000 [5:29:56<17:21, 20.84s/it][Succeeded / Failed / Skipped / Total] 900 / 26 / 24 / 950:  95%|█████████▌| 951/1000 [5:30:01<17:00, 20.82s/it][Succeeded / Failed / Skipped / Total] 901 / 26 / 24 / 951:  95%|█████████▌| 951/1000 [5:30:01<17:00, 20.82s/it][Succeeded / Failed / Skipped / Total] 901 / 26 / 24 / 951:  95%|█████████▌| 952/1000 [5:30:01<16:38, 20.80s/it][Succeeded / Failed / Skipped / Total] 902 / 26 / 24 / 952:  95%|█████████▌| 952/1000 [5:30:01<16:38, 20.80s/it][Succeeded / Failed / Skipped / Total] 902 / 26 / 24 / 952:  95%|█████████▌| 953/1000 [5:30:04<16:16, 20.78s/it][Succeeded / Failed / Skipped / Total] 903 / 26 / 24 / 953:  95%|█████████▌| 953/1000 [5:30:04<16:16, 20.78s/it][Succeeded / Failed / Skipped / Total] 903 / 26 / 24 / 953:  95%|█████████▌| 954/1000 [5:30:10<15:55, 20.77s/it][Succeeded / Failed / Skipped / Total] 904 / 26 / 24 / 954:  95%|█████████▌| 954/1000 [5:30:10<15:55, 20.77s/it][Succeeded / Failed / Skipped / Total] 904 / 26 / 24 / 954:  96%|█████████▌| 955/1000 [5:30:12<15:33, 20.75s/it][Succeeded / Failed / Skipped / Total] 905 / 26 / 24 / 955:  96%|█████████▌| 955/1000 [5:30:12<15:33, 20.75s/it][Succeeded / Failed / Skipped / Total] 905 / 26 / 24 / 955:  96%|█████████▌| 956/1000 [5:30:16<15:12, 20.73s/it][Succeeded / Failed / Skipped / Total] 906 / 26 / 24 / 956:  96%|█████████▌| 956/1000 [5:30:16<15:12, 20.73s/it][Succeeded / Failed / Skipped / Total] 906 / 26 / 24 / 956:  96%|█████████▌| 957/1000 [5:30:27<14:50, 20.72s/it]Compresses the given file . --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: public static File [[zlib]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream [[fis]] = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String [[zlibFileName]] = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( [[zlibFileName]] ) , deflater ) ; try { StreamUtil . copy ( [[fis]] , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( [[fis]] ) ; } return new File ( [[zlibFileName]] ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File [[essay]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream [[tia]] = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String [[bartolini]] = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( [[bartolini]] ) , deflater ) ; try { StreamUtil . copy ( [[tia]] , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( [[tia]] ) ; } return new File ( [[bartolini]] ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 951 ---------------------------------------------
List a zip file . --> Return the due names from a semana file --> Socre: 1.0

[[[[Adv]]]]: public static List < String > [[listZip]] ( final File [[zipFile]] ) throws IOException { List < String > [[entries]] = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[zipFile]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry [[entry]] = ( ZipEntry ) zipEntries . nextElement ( ) ; String [[entryName]] = [[entry]] . getName ( ) ; [[entries]] . add ( [[entryName]] ) ; } return Collections . unmodifiableList ( [[entries]] ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > [[due]] ( final File [[semana]] ) throws IOException { List < String > [[intro]] = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[semana]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry [[inward]] = ( ZipEntry ) zipEntries . nextElement ( ) ; String [[cloistered]] = [[inward]] . getName ( ) ; [[intro]] . add ( [[cloistered]] ) ; } return Collections . unmodifiableList ( [[intro]] ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 952 ---------------------------------------------
Unzip a zip file into a target directory --> Unzip a string --> Socre: 1.0

[[[[Adv]]]]: public static void unzip ( final String [[zipFile]] , final String [[destDir]] , final String ... patterns ) throws IOException { unzip ( new File ( [[zipFile]] ) , new File ( [[destDir]] ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String [[heartening]] , final String [[pasó]] , final String ... patterns ) throws IOException { unzip ( new File ( [[heartening]] ) , new File ( [[pasó]] ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 953 ---------------------------------------------
Gzip a file --> Gets cnn from deposit folder --> Socre: 1.0

[[[[Adv]]]]: public static File [[gzip]] ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; String gzipName = [[file]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File [[cnn]] ( final File [[deposits]] ) throws IOException { if ( [[deposits]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[deposits]] ) ; String gzipName = [[deposits]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 954 ---------------------------------------------
Adds a file to a ZIP output stream . --> Borrowed from archival --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final File [[file]] , String path , final String comment , final boolean [[recursive]] ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( path == null ) { path = [[file]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = [[file]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[burkes]] ( final ZipOutputStream zos , final File [[archival]] , String path , final String comment , final boolean [[bov]] ) throws IOException { if ( ! [[archival]] . exists ( ) ) { throw new FileNotFoundException ( [[archival]] . toString ( ) ) ; } if ( path == null ) { path = [[archival]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = [[archival]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 955 ---------------------------------------------
Gets a field descriptor . --> Get a FieldDescriptor by name --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor [[fieldDescriptor]] = getFields ( ) . getFieldDescriptor ( name ) ; if ( [[fieldDescriptor]] != null ) { if ( ! [[fieldDescriptor]] . matchDeclared ( declared ) ) { return null ; } } return [[fieldDescriptor]] ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor [[chung]] = getFields ( ) . getFieldDescriptor ( name ) ; if ( [[chung]] != null ) { if ( ! [[chung]] . matchDeclared ( declared ) ) { return null ; } } return [[chung]] ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 956 ---------------------------------------------
Returns the property descriptor for the given name and flag . --> Return the propertyDescriptor with the given name --> Socre: 1.0

[[[[Adv]]]]: public PropertyDescriptor [[getPropertyDescriptor]] ( final String [[name]] , final boolean [[declared]] ) { PropertyDescriptor [[propertyDescriptor]] = getProperties ( ) . getPropertyDescriptor ( [[name]] ) ; if ( ( [[propertyDescriptor]] != null ) && [[propertyDescriptor]] . matchDeclared ( [[declared]] ) ) { return [[propertyDescriptor]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor [[gaydar]] ( final String [[christening]] , final boolean [[said]] ) { PropertyDescriptor [[darl]] = getProperties ( ) . getPropertyDescriptor ( [[christening]] ) ; if ( ( [[darl]] != null ) && [[darl]] . matchDeclared ( [[said]] ) ) { return [[darl]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 957 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 907 / 26 / 24 / 957:  96%|█████████▌| 957/1000 [5:30:27<14:50, 20.72s/it][Succeeded / Failed / Skipped / Total] 907 / 26 / 24 / 957:  96%|█████████▌| 958/1000 [5:30:29<14:29, 20.70s/it][Succeeded / Failed / Skipped / Total] 908 / 26 / 24 / 958:  96%|█████████▌| 958/1000 [5:30:29<14:29, 20.70s/it][Succeeded / Failed / Skipped / Total] 908 / 26 / 24 / 958:  96%|█████████▌| 959/1000 [5:30:29<14:07, 20.68s/it][Succeeded / Failed / Skipped / Total] 909 / 26 / 24 / 959:  96%|█████████▌| 959/1000 [5:30:29<14:07, 20.68s/it][Succeeded / Failed / Skipped / Total] 909 / 26 / 24 / 959:  96%|█████████▌| 960/1000 [5:30:53<13:47, 20.68s/it][Succeeded / Failed / Skipped / Total] 910 / 26 / 24 / 960:  96%|█████████▌| 960/1000 [5:30:53<13:47, 20.68s/it][Succeeded / Failed / Skipped / Total] 910 / 26 / 24 / 960:  96%|█████████▌| 961/1000 [5:30:56<13:25, 20.66s/it][Succeeded / Failed / Skipped / Total] 911 / 26 / 24 / 961:  96%|█████████▌| 961/1000 [5:30:56<13:25, 20.66s/it][Succeeded / Failed / Skipped / Total] 911 / 26 / 24 / 961:  96%|█████████▌| 962/1000 [5:32:04<13:07, 20.71s/it][Succeeded / Failed / Skipped / Total] 912 / 26 / 24 / 962:  96%|█████████▌| 962/1000 [5:32:04<13:07, 20.71s/it][Succeeded / Failed / Skipped / Total] 912 / 26 / 24 / 962:  96%|█████████▋| 963/1000 [5:32:32<12:46, 20.72s/it][Succeeded / Failed / Skipped / Total] 913 / 26 / 24 / 963:  96%|█████████▋| 963/1000 [5:32:32<12:46, 20.72s/it][Succeeded / Failed / Skipped / Total] 913 / 26 / 24 / 963:  96%|█████████▋| 964/1000 [5:32:41<12:25, 20.71s/it]Sets the bundle name in the request . --> Parses the eniement --> Socre: 1.0

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest [[request]] , final String [[bundleName]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[bundleName]] ) ; } [[request]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[bundleName]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[plié]] ( final ServletRequest [[petitions]] , final String [[inherits]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[inherits]] ) ; } [[petitions]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[inherits]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 958 ---------------------------------------------
Adds content to a ZIP file . --> This method is used to compress physicals --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream [[zos]] , final byte [ ] content , String [[path]] , final String [[comment]] ) throws IOException { while ( [[path]] . length ( ) != 0 && [[path]] . charAt ( 0 ) == ' ' ) { [[path]] = [[path]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[path]] , ' ' ) ) { [[path]] = [[path]] . substring ( 0 , [[path]] . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( [[path]] ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( [[comment]] != null ) { zipEntry . setComment ( [[comment]] ) ; } [[zos]] . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , [[zos]] ) ; } finally { StreamUtil . close ( is ) ; } [[zos]] . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void [[physicals]] ( final ZipOutputStream [[orion]] , final byte [ ] content , String [[footpath]] , final String [[sighting]] ) throws IOException { while ( [[footpath]] . length ( ) != 0 && [[footpath]] . charAt ( 0 ) == ' ' ) { [[footpath]] = [[footpath]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[footpath]] , ' ' ) ) { [[footpath]] = [[footpath]] . substring ( 0 , [[footpath]] . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( [[footpath]] ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( [[sighting]] != null ) { zipEntry . setComment ( [[sighting]] ) ; } [[orion]] . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , [[orion]] ) ; } finally { StreamUtil . close ( is ) ; } [[orion]] . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 959 ---------------------------------------------
Returns the session locale from the session . --> Converts a CPE --> Socre: 1.0

[[[[Adv]]]]: public static Locale [[getSessionLocale]] ( final HttpSession session ) { Locale [[locale]] = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[locale]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[locale]] ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale [[césar]] ( final HttpSession session ) { Locale [[location]] = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[location]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[location]] ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 960 ---------------------------------------------
Adds profile . --> Add a profile --> Socre: 1.0

[[[[Adv]]]]: public PropsEntries profile ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String profile : [[profiles]] ) { addProfiles ( profile ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries profile ( final String ... [[schematic]] ) { if ( [[schematic]] == null ) { return this ; } for ( String profile : [[schematic]] ) { addProfiles ( profile ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 961 ---------------------------------------------
Read a long from the buffer at the given offset . --> Used for unit testing --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] [[buf]] , final int [[offset]] ) { return ( ( long ) [[buf]] [ [[offset]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[usage]] ( final byte [ ] [[contingent]] , final int [[neutralized]] ) { return ( ( long ) [[contingent]] [ [[neutralized]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 962 ---------------------------------------------
Reads the given InputStream into a byte array . --> Paste data from an InputStream --> Socre: 1.0

[[[[Adv]]]]: private static byte [ ] [[readStream]] ( final InputStream [[inputStream]] , final boolean close ) throws IOException { if ( [[inputStream]] == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[outputStream]] = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = [[inputStream]] . read ( data , 0 , data . length ) ) != - 1 ) { [[outputStream]] . write ( data , 0 , bytesRead ) ; } [[outputStream]] . flush ( ) ; return [[outputStream]] . toByteArray ( ) ; } finally { if ( close ) { [[inputStream]] . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] [[sexed]] ( final InputStream [[pressurized]] , final boolean close ) throws IOException { if ( [[pressurized]] == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[nooooooo]] = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = [[pressurized]] . read ( data , 0 , data . length ) ) != - 1 ) { [[nooooooo]] . write ( data , 0 , bytesRead ) ; } [[nooooooo]] . flush ( ) ; return [[nooooooo]] . toByteArray ( ) ; } finally { if ( close ) { [[pressurized]] . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 963 ---------------------------------------------
Filters the parameters for a bean . --> Buffie params --> Socre: 1.0

[[[[Adv]]]]: public String [ ] [[filterParametersForBeanName]] ( String beanName , final boolean [[resolveReferenceParams]] ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! [[resolveReferenceParams]] ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] [[bertie]] ( String beanName , final boolean [[cartographer]] ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! [[cartographer]] ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 964 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 914 / 26 / 24 / 964:  96%|█████████▋| 964/1000 [5:32:41<12:25, 20.71s/it][Succeeded / Failed / Skipped / Total] 914 / 26 / 24 / 964:  96%|█████████▋| 965/1000 [5:33:10<12:05, 20.72s/it][Succeeded / Failed / Skipped / Total] 915 / 26 / 24 / 965:  96%|█████████▋| 965/1000 [5:33:10<12:05, 20.72s/it][Succeeded / Failed / Skipped / Total] 915 / 26 / 24 / 965:  97%|█████████▋| 966/1000 [5:33:13<11:43, 20.70s/it][Succeeded / Failed / Skipped / Total] 916 / 26 / 24 / 966:  97%|█████████▋| 966/1000 [5:33:13<11:43, 20.70s/it][Succeeded / Failed / Skipped / Total] 916 / 26 / 24 / 966:  97%|█████████▋| 967/1000 [5:33:21<11:22, 20.68s/it][Succeeded / Failed / Skipped / Total] 917 / 26 / 24 / 967:  97%|█████████▋| 967/1000 [5:33:21<11:22, 20.68s/it][Succeeded / Failed / Skipped / Total] 917 / 26 / 24 / 967:  97%|█████████▋| 968/1000 [5:33:27<11:01, 20.67s/it][Succeeded / Failed / Skipped / Total] 918 / 26 / 24 / 968:  97%|█████████▋| 968/1000 [5:33:27<11:01, 20.67s/it][Succeeded / Failed / Skipped / Total] 918 / 26 / 24 / 968:  97%|█████████▋| 969/1000 [5:33:32<10:40, 20.65s/it]Returns the bytecode offset for a type annotation index . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] [[typeAnnotationOffsets]] , final int [[typeAnnotationIndex]] ) { if ( [[typeAnnotationOffsets]] == null || [[typeAnnotationIndex]] >= [[typeAnnotationOffsets]] . length || readByte ( [[typeAnnotationOffsets]] [ [[typeAnnotationIndex]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[typeAnnotationOffsets]] [ [[typeAnnotationIndex]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[freakin]] ( final int [ ] [[scars]] , final int [[waterworks]] ) { if ( [[scars]] == null || [[waterworks]] >= [[scars]] . length || readByte ( [[scars]] [ [[waterworks]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[scars]] [ [[waterworks]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 965 ---------------------------------------------
Read element values . --> Enumley enlargement --> Socre: 1.0

[[[[Adv]]]]: private int [[readElementValues]] ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean [[named]] , final char [ ] charBuffer ) { int [[currentOffset]] = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int [[henley]] ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean [[listed]] , final char [ ] charBuffer ) { int [[enlargement]] = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 966 ---------------------------------------------
Read verification type information . --> Implementation of ELM --> Socre: 1.0

[[[[Adv]]]]: private int [[readVerificationTypeInfo]] ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int [[elmo]] ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 967 ---------------------------------------------
Read all bootstrap methods attribute . --> Perform cancellation operation --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int [[maxStringLength]] ) { char [ ] [[charBuffer]] = new char [ [[maxStringLength]] ] ; int [[currentAttributeOffset]] = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int [[i]] = readUnsignedShort ( [[currentAttributeOffset]] - 2 ) ; [[i]] > 0 ; -- [[i]] ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[cancellation]] ( final int [[toh]] ) { char [ ] [[cuervo]] = new char [ [[toh]] ] ; int [[redundant]] = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int [[yo]] = readUnsignedShort ( [[redundant]] - 2 ) ; [[yo]] > 0 ; -- [[yo]] ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 968 ---------------------------------------------
Reads a label . --> Liest ein Laster einer --> Socre: 1.0

[[[[Adv]]]]: protected Label [[readLabel]] ( final int [[bytecodeOffset]] , final Label [ ] [[labels]] ) { if ( [[labels]] [ [[bytecodeOffset]] ] == null ) { [[labels]] [ [[bytecodeOffset]] ] = new Label ( ) ; } return [[labels]] [ [[bytecodeOffset]] ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label [[thermo]] ( final int [[sacré]] , final Label [ ] [[marks]] ) { if ( [[marks]] [ [[sacré]] ] == null ) { [[marks]] [ [[sacré]] ] = new Label ( ) ; } return [[marks]] [ [[sacré]] ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 969 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 919 / 26 / 24 / 969:  97%|█████████▋| 969/1000 [5:33:32<10:40, 20.65s/it][Succeeded / Failed / Skipped / Total] 919 / 26 / 24 / 969:  97%|█████████▋| 970/1000 [5:33:35<10:19, 20.63s/it][Succeeded / Failed / Skipped / Total] 920 / 26 / 24 / 970:  97%|█████████▋| 970/1000 [5:33:35<10:19, 20.63s/it][Succeeded / Failed / Skipped / Total] 920 / 26 / 24 / 970:  97%|█████████▋| 971/1000 [5:33:38<09:57, 20.62s/it][Succeeded / Failed / Skipped / Total] 921 / 26 / 24 / 971:  97%|█████████▋| 971/1000 [5:33:38<09:57, 20.62s/it][Succeeded / Failed / Skipped / Total] 921 / 26 / 24 / 971:  97%|█████████▋| 972/1000 [5:34:39<09:38, 20.66s/it][Succeeded / Failed / Skipped / Total] 922 / 26 / 24 / 972:  97%|█████████▋| 972/1000 [5:34:39<09:38, 20.66s/it][Succeeded / Failed / Skipped / Total] 922 / 26 / 24 / 972:  97%|█████████▋| 973/1000 [5:34:41<09:17, 20.64s/it][Succeeded / Failed / Skipped / Total] 923 / 26 / 24 / 973:  97%|█████████▋| 973/1000 [5:34:41<09:17, 20.64s/it][Succeeded / Failed / Skipped / Total] 923 / 26 / 24 / 973:  97%|█████████▋| 974/1000 [5:34:43<08:56, 20.62s/it][Succeeded / Failed / Skipped / Total] 924 / 26 / 24 / 974:  97%|█████████▋| 974/1000 [5:34:43<08:56, 20.62s/it][Succeeded / Failed / Skipped / Total] 924 / 26 / 24 / 974:  98%|█████████▊| 975/1000 [5:34:48<08:35, 20.60s/it][Succeeded / Failed / Skipped / Total] 925 / 26 / 24 / 975:  98%|█████████▊| 975/1000 [5:34:48<08:35, 20.60s/it][Succeeded / Failed / Skipped / Total] 925 / 26 / 24 / 975:  98%|█████████▊| 976/1000 [5:34:53<08:14, 20.59s/it][Succeeded / Failed / Skipped / Total] 926 / 26 / 24 / 976:  98%|█████████▊| 976/1000 [5:34:53<08:14, 20.59s/it][Succeeded / Failed / Skipped / Total] 926 / 26 / 24 / 976:  98%|█████████▊| 977/1000 [5:35:05<07:53, 20.58s/it][Succeeded / Failed / Skipped / Total] 927 / 26 / 24 / 977:  98%|█████████▊| 977/1000 [5:35:05<07:53, 20.58s/it][Succeeded / Failed / Skipped / Total] 927 / 26 / 24 / 977:  98%|█████████▊| 978/1000 [5:35:08<07:32, 20.56s/it]Get all constructors . --> registers ctor descriptors for this class --> Socre: 1.0

[[[[Adv]]]]: protected CtorDescriptor [ ] [[inspectConstructors]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor [[ctor]] = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[ctor]] ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] [[reggie]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor [[quintero]] = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[quintero]] ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 970 ---------------------------------------------
Returns the first CtorDescriptor associated with the given arguments . --> get a CtorDescriptor --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... [[args]] ) { ctors : for ( CtorDescriptor [[ctorDescriptor]] : allCtors ) { Class [ ] arg = [[ctorDescriptor]] . getParameters ( ) ; if ( arg . length != [[args]] . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != [[args]] [ j ] ) { continue ctors ; } } return [[ctorDescriptor]] ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... [[bombin]] ) { ctors : for ( CtorDescriptor [[koray]] : allCtors ) { Class [ ] arg = [[koray]] . getParameters ( ) ; if ( arg . length != [[bombin]] . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != [[bombin]] [ j ] ) { continue ctors ; } } return [[koray]] ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 971 ---------------------------------------------
Returns the request map . --> Extract the transient data --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[fibber]] ( final HttpServletRequest [[papy]] ) { return ( Map < String , TransientBeanData > ) [[papy]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 972 ---------------------------------------------
Creates the request map . --> Generate Post card data --> Socre: 1.0

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { Map < String , TransientBeanData > [[map]] = new HashMap <> ( ) ; [[servletRequest]] . setAttribute ( ATTR_NAME , [[map]] ) ; return [[map]] ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[showing]] ( final HttpServletRequest [[yumi]] ) { Map < String , TransientBeanData > [[postcard]] = new HashMap <> ( ) ; [[yumi]] . setAttribute ( ATTR_NAME , [[postcard]] ) ; return [[postcard]] ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 973 ---------------------------------------------
Initialize the filter --> Shortening method --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[shortening]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 974 ---------------------------------------------
Registers a new file consumer . --> Adds a FindFile function . --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[onFile]] ( final Consumer < File > [[fileConsumer]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[fileConsumer]] ) ; } else { consumers . add ( [[fileConsumer]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile [[fuke]] ( final Consumer < File > [[spoilsport]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[spoilsport]] ) ; } else { consumers . add ( [[spoilsport]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 975 ---------------------------------------------
Add search path . --> Add a surfin file --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI [[searchPath]] ) { File [[file]] ; try { [[file]] = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[surfin]] ( final URI [[eo]] ) { File [[record]] ; try { [[record]] = new File ( [[surfin]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[surfin]] , ex ) ; } addPath ( [[record]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 976 ---------------------------------------------
Add search path . --> Add locator to FindFile --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL [[searchPath]] ) { File file = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[gtr]] ( final URL [[hairier]] ) { File file = FileUtil . toContainerFile ( [[gtr]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[gtr]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 977 ---------------------------------------------
Adds patterns to scan . --> Configure the FindFile --> Socre: 1.0

[[[[Adv]]]]: public FindFile include ( final String ... [[patterns]] ) { for ( String [[pattern]] : [[patterns]] ) { rules . include ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile include ( final String ... [[behaviours]] ) { for ( String [[benefactor]] : [[behaviours]] ) { rules . include ( [[benefactor]] ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 978 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 928 / 26 / 24 / 978:  98%|█████████▊| 978/1000 [5:35:08<07:32, 20.56s/it][Succeeded / Failed / Skipped / Total] 928 / 26 / 24 / 978:  98%|█████████▊| 979/1000 [5:35:25<07:11, 20.56s/it][Succeeded / Failed / Skipped / Total] 929 / 26 / 24 / 979:  98%|█████████▊| 979/1000 [5:35:25<07:11, 20.56s/it][Succeeded / Failed / Skipped / Total] 929 / 26 / 24 / 979:  98%|█████████▊| 980/1000 [5:35:32<06:50, 20.54s/it][Succeeded / Failed / Skipped / Total] 930 / 26 / 24 / 980:  98%|█████████▊| 980/1000 [5:35:32<06:50, 20.54s/it][Succeeded / Failed / Skipped / Total] 930 / 26 / 24 / 980:  98%|█████████▊| 981/1000 [5:36:00<06:30, 20.55s/it][Succeeded / Failed / Skipped / Total] 931 / 26 / 24 / 981:  98%|█████████▊| 981/1000 [5:36:00<06:30, 20.55s/it][Succeeded / Failed / Skipped / Total] 931 / 26 / 24 / 981:  98%|█████████▊| 982/1000 [5:36:02<06:09, 20.53s/it][Succeeded / Failed / Skipped / Total] 932 / 26 / 24 / 982:  98%|█████████▊| 982/1000 [5:36:02<06:09, 20.53s/it][Succeeded / Failed / Skipped / Total] 932 / 26 / 24 / 982:  98%|█████████▊| 983/1000 [5:36:17<05:48, 20.53s/it][Succeeded / Failed / Skipped / Total] 933 / 26 / 24 / 983:  98%|█████████▊| 983/1000 [5:36:17<05:48, 20.53s/it][Succeeded / Failed / Skipped / Total] 933 / 26 / 24 / 983:  98%|█████████▊| 984/1000 [5:36:20<05:28, 20.51s/it][Succeeded / Failed / Skipped / Total] 934 / 26 / 24 / 984:  98%|█████████▊| 984/1000 [5:36:20<05:28, 20.51s/it][Succeeded / Failed / Skipped / Total] 934 / 26 / 24 / 984:  98%|█████████▊| 985/1000 [5:36:24<05:07, 20.49s/it]Sets the session locale . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession [[session]] , final String [[localeCode]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[localeCode]] ) ; } Locale [[locale]] = Locale . forLanguageTag ( [[localeCode]] ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , [[locale]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[enclosure]] ( final HttpSession [[gatherings]] , final String [[didnít]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[didnít]] ) ; } Locale [[nationally]] = Locale . forLanguageTag ( [[didnít]] ) ; [[gatherings]] . setAttribute ( SESSION_LOCALE_ATTR , [[nationally]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 979 ---------------------------------------------
Convert array to array . --> Ackermann implementation --> Socre: 1.0

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object value ) { final Class [[valueComponentType]] = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( [[valueComponentType]] . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , [[valueComponentType]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[ackermann]] ( final Object value ) { final Class [[adorn]] = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( [[adorn]] . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , [[adorn]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 980 ---------------------------------------------
Excludes the given patterns . --> Remove trend from the finder --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[exclude]] ( final String ... [[patterns]] ) { for ( String [[pattern]] : [[patterns]] ) { rules . exclude ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile [[prevents]] ( final String ... [[habits]] ) { for ( String [[trend]] : [[habits]] ) { rules . exclude ( [[trend]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 981 ---------------------------------------------
Adds a file to the system . --> Briannene --> Socre: 1.0

[[[[Adv]]]]: protected void [[addPath]] ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void [[brianne]] ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 982 ---------------------------------------------
Initialize todo . --> Create the list of todo items --> Socre: 1.0

[[[[Adv]]]]: protected void [[init]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] [[files]] = new String [ pathList . size ( ) ] ; int [[index]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File [[file]] = iterator . next ( ) ; if ( [[file]] . isFile ( ) ) { [[files]] [ [[index]] ++ ] = [[file]] . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[index]] != 0 ) { FilesIterator [[filesIterator]] = new FilesIterator ( [[files]] ) ; todoFiles . add ( [[filesIterator]] ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void [[slender]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] [[depositions]] = new String [ pathList . size ( ) ] ; int [[references]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File [[files]] = iterator . next ( ) ; if ( [[files]] . isFile ( ) ) { [[depositions]] [ [[references]] ++ ] = [[files]] . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[references]] != 0 ) { FilesIterator [[braca]] = new FilesIterator ( [[depositions]] ) ; todoFiles . add ( [[braca]] ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 983 ---------------------------------------------
Iterates over the files . --> Drops crapola files --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < File > [[iterator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > [[crapola]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 984 ---------------------------------------------
Returns the wiring mode for the given type . --> This method should be used for testing purposes only --> Socre: 1.0

[[[[Adv]]]]: public WiringMode [[resolveBeanWiringMode]] ( final Class [[type]] ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; return [[petiteBean]] != null ? [[petiteBean]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode [[weal]] ( final Class [[fella]] ) { PetiteBean [[brainwash]] = ( ( Class < ? > ) [[fella]] ) . getAnnotation ( PetiteBean . class ) ; return [[brainwash]] != null ? [[brainwash]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 985 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 935 / 26 / 24 / 985:  98%|█████████▊| 985/1000 [5:36:24<05:07, 20.49s/it][Succeeded / Failed / Skipped / Total] 935 / 26 / 24 / 985:  99%|█████████▊| 986/1000 [5:36:47<04:46, 20.49s/it][Succeeded / Failed / Skipped / Total] 936 / 26 / 24 / 986:  99%|█████████▊| 986/1000 [5:36:47<04:46, 20.49s/it][Succeeded / Failed / Skipped / Total] 936 / 26 / 24 / 986:  99%|█████████▊| 987/1000 [5:36:58<04:26, 20.48s/it][Succeeded / Failed / Skipped / Total] 937 / 26 / 24 / 987:  99%|█████████▊| 987/1000 [5:36:58<04:26, 20.48s/it][Succeeded / Failed / Skipped / Total] 937 / 26 / 24 / 987:  99%|█████████▉| 988/1000 [5:37:04<04:05, 20.47s/it][Succeeded / Failed / Skipped / Total] 938 / 26 / 24 / 988:  99%|█████████▉| 988/1000 [5:37:04<04:05, 20.47s/it][Succeeded / Failed / Skipped / Total] 938 / 26 / 24 / 988:  99%|█████████▉| 989/1000 [5:37:06<03:44, 20.45s/it][Succeeded / Failed / Skipped / Total] 939 / 26 / 24 / 989:  99%|█████████▉| 989/1000 [5:37:06<03:44, 20.45s/it][Succeeded / Failed / Skipped / Total] 939 / 26 / 24 / 989:  99%|█████████▉| 990/1000 [5:37:13<03:24, 20.44s/it][Succeeded / Failed / Skipped / Total] 940 / 26 / 24 / 990:  99%|█████████▉| 990/1000 [5:37:13<03:24, 20.44s/it][Succeeded / Failed / Skipped / Total] 940 / 26 / 24 / 990:  99%|█████████▉| 991/1000 [5:37:22<03:03, 20.43s/it]Resolves the bean name . --> Makes a camel - separated string with all the necessary information --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[máximo]] ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 986 ---------------------------------------------
Adds a constant to the constant pool . --> special handling for testing --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantUtf8Reference]] ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[thatís]] ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 987 ---------------------------------------------
Returns the name of the binary representation . --> Generate a ballback string --> Socre: 1.0

[[[[Adv]]]]: public String [[getClassName]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[stringBuilder]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { [[stringBuilder]] . append ( "[]" ) ; } return [[stringBuilder]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String [[blud]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[brigadoon]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { [[brigadoon]] . append ( "[]" ) ; } return [[brigadoon]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 988 ---------------------------------------------
Returns all files . --> Experimental method to expose the datasets --> Socre: 1.0

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > [[allFiles]] = new ArrayList <> ( ) ; File [[file]] ; while ( ( [[file]] = nextFile ( ) ) != null ) { [[allFiles]] . add ( [[file]] ) ; } return [[allFiles]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[handfuls]] ( ) { List < File > [[experts]] = new ArrayList <> ( ) ; File [[registers]] ; while ( ( [[registers]] = nextFile ( ) ) != null ) { [[experts]] . add ( [[registers]] ) ; } return [[experts]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 989 ---------------------------------------------
Gets the method descriptor . --> Generates an oliver --> Socre: 1.0

[[[[Adv]]]]: public static String [[getConstructorDescriptor]] ( final Constructor < ? > [[constructor]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] [[parameters]] = [[constructor]] . getParameterTypes ( ) ; for ( Class < ? > parameter : [[parameters]] ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String [[oliver]] ( final Constructor < ? > [[dispenser]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] [[settings]] = [[dispenser]] . getParameterTypes ( ) ; for ( Class < ? > parameter : [[settings]] ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 990 ---------------------------------------------
Gets the method descriptor . --> creates a snippet for a modo --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Method [[method]] ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; Class < ? > [ ] [[parameters]] = [[method]] . getParameterTypes ( ) ; for ( Class < ? > [[parameter]] : [[parameters]] ) { appendDescriptor ( [[parameter]] , [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; appendDescriptor ( [[method]] . getReturnType ( ) , [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String [[discussed]] ( final Method [[modo]] ) { StringBuilder [[reliever]] = new StringBuilder ( ) ; [[reliever]] . append ( ' ' ) ; Class < ? > [ ] [[milestones]] = [[modo]] . getParameterTypes ( ) ; for ( Class < ? > [[criterion]] : [[milestones]] ) { appendDescriptor ( [[criterion]] , [[reliever]] ) ; } [[reliever]] . append ( ' ' ) ; appendDescriptor ( [[modo]] . getReturnType ( ) , [[reliever]] ) ; return [[reliever]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
[Succeeded / Failed / Skipped / Total] 941 / 26 / 24 / 991:  99%|█████████▉| 991/1000 [5:37:22<03:03, 20.43s/it][Succeeded / Failed / Skipped / Total] 941 / 26 / 24 / 991:  99%|█████████▉| 992/1000 [5:37:24<02:43, 20.41s/it][Succeeded / Failed / Skipped / Total] 942 / 26 / 24 / 992:  99%|█████████▉| 992/1000 [5:37:24<02:43, 20.41s/it][Succeeded / Failed / Skipped / Total] 942 / 26 / 24 / 992:  99%|█████████▉| 993/1000 [5:37:26<02:22, 20.39s/it][Succeeded / Failed / Skipped / Total] 943 / 26 / 24 / 993:  99%|█████████▉| 993/1000 [5:37:26<02:22, 20.39s/it][Succeeded / Failed / Skipped / Total] 943 / 26 / 24 / 993:  99%|█████████▉| 994/1000 [5:37:30<02:02, 20.37s/it][Succeeded / Failed / Skipped / Total] 944 / 26 / 24 / 994:  99%|█████████▉| 994/1000 [5:37:30<02:02, 20.37s/it][Succeeded / Failed / Skipped / Total] 944 / 26 / 24 / 994: 100%|█████████▉| 995/1000 [5:37:36<01:41, 20.36s/it][Succeeded / Failed / Skipped / Total] 945 / 26 / 24 / 995: 100%|█████████▉| 995/1000 [5:37:36<01:41, 20.36s/it][Succeeded / Failed / Skipped / Total] 945 / 26 / 24 / 995: 100%|█████████▉| 996/1000 [5:37:38<01:21, 20.34s/it][Succeeded / Failed / Skipped / Total] 946 / 26 / 24 / 996: 100%|█████████▉| 996/1000 [5:37:38<01:21, 20.34s/it][Succeeded / Failed / Skipped / Total] 946 / 26 / 24 / 996: 100%|█████████▉| 997/1000 [5:37:39<01:00, 20.32s/it][Succeeded / Failed / Skipped / Total] 947 / 26 / 24 / 997: 100%|█████████▉| 997/1000 [5:37:39<01:00, 20.32s/it][Succeeded / Failed / Skipped / Total] 947 / 26 / 24 / 997: 100%|█████████▉| 998/1000 [5:39:36<00:40, 20.42s/it]--------------------------------------------- Result 991 ---------------------------------------------
Gets the method descriptor . --> Generates a body for a catchr --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Type [[returnType]] , final Type ... [[argumentTypes]] ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; for ( Type [[argumentType]] : [[argumentTypes]] ) { [[argumentType]] . appendDescriptor ( [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; [[returnType]] . appendDescriptor ( [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String [[fane]] ( final Type [[carer]] , final Type ... [[gripping]] ) { StringBuilder [[sarcasm]] = new StringBuilder ( ) ; [[sarcasm]] . append ( ' ' ) ; for ( Type [[strays]] : [[gripping]] ) { [[strays]] . appendDescriptor ( [[sarcasm]] ) ; } [[sarcasm]] . append ( ' ' ) ; [[carer]] . appendDescriptor ( [[sarcasm]] ) ; return [[sarcasm]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 992 ---------------------------------------------
Returns the output writer . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[mcdougal]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 993 ---------------------------------------------
Returns the output stream . --> Get SimpleByteArrayOutputStream --> Socre: 1.0

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[simpleton]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 994 ---------------------------------------------
Gets the number of arguments and return the number of arguments . --> Convert to wls string --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String [[methodDescriptor]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[owls]] ( final String [[doing]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 995 ---------------------------------------------
Mark this transaction as rollback only . --> Marks a misnomer --> Socre: 1.0

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable [[th]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[th]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[misnomer]] ( final Throwable [[que]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[que]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 996 ---------------------------------------------
Commit the transaction or rollback . --> Common logic for transactional operations --> Socre: 1.0

[[[[Adv]]]]: protected void [[commitOrRollback]] ( boolean [[doCommit]] ) { if ( log . isDebugEnabled ( ) ) { if ( [[doCommit]] ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean [[forcedRollback]] = "[[False]]" != "[[False]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( [[doCommit]] ) { [[doCommit]] = "[[False]]" != "[[False]]" ; [[forcedRollback]] = "[[True]]" == "[[True]]" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( [[doCommit]] ? "commit" : "rollback" ) ) ; } } if ( [[doCommit]] ) { commitAllResources ( ) ; } else { rollbackAllResources ( [[forcedRollback]] ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void [[ifor]] ( boolean [[bosse]] ) { if ( log . isDebugEnabled ( ) ) { if ( [[bosse]] ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean [[smiles]] = "[[Faux]]" != "[[Faux]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( [[bosse]] ) { [[bosse]] = "[[Faux]]" != "[[Faux]]" ; [[smiles]] = "[[Authentic]]" == "[[Authentic]]" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( [[bosse]] ? "commit" : "rollback" ) ) ; } } if ( [[bosse]] ) { commitAllResources ( ) ; } else { rollbackAllResources ( [[smiles]] ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 997 ---------------------------------------------
Append the descriptor to the given string builder . --> will be called --> Socre: 1.0

[[[[Adv]]]]: private void [[appendDescriptor]] ( final StringBuilder [[stringBuilder]] ) { if ( sort == OBJECT ) { [[stringBuilder]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[stringBuilder]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[stringBuilder]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void [[didyou]] ( final StringBuilder [[kitchens]] ) { if ( sort == OBJECT ) { [[kitchens]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[kitchens]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[kitchens]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 998 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 948 / 26 / 24 / 998: 100%|█████████▉| 998/1000 [5:39:36<00:40, 20.42s/it][Succeeded / Failed / Skipped / Total] 948 / 26 / 24 / 998: 100%|█████████▉| 999/1000 [5:53:38<00:21, 21.24s/it][Succeeded / Failed / Skipped / Total] 948 / 27 / 24 / 999: 100%|█████████▉| 999/1000 [5:53:38<00:21, 21.24s/it][Succeeded / Failed / Skipped / Total] 948 / 27 / 24 / 999: 100%|██████████| 1000/1000 [6:29:39<00:00, 23.38s/it][Succeeded / Failed / Skipped / Total] 948 / 28 / 24 / 1000: 100%|██████████| 1000/1000 [6:29:39<00:00, 23.38s/it]/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
Attack(
  (search_method): HardLabelSearch(
    (pop_size):  30
    (max_iters):  100
    (max_replacements_per_index):  25
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapEmbedding(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
    (2): RepeatModification
  (is_black_box):  True
) 

/data2/cg/CodeAttack/codeattack/search_methods/hard_label_search.py:487: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  similarity_scores = np.asarray(similarity_scores)
/data2/cg/CodeAttack/codeattack/search_methods/hard_label_search.py:487: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  similarity_scores = np.asarray(similarity_scores)
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/codeattack/search_methods/hard_label_search.py:487: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  similarity_scores = np.asarray(similarity_scores)
[Succeeded / Failed / Skipped / Total] 948 / 28 / 24 / 1000: 100%|██████████| 1000/1000 [6:29:42<00:00, 23.38s/it]Rollback all resources . --> Rollback pending transactions --> Socre: 1.0

[[[[Adv]]]]: protected void [[rollbackAllResources]] ( final boolean [[wasForced]] ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > [[it]] = resources . iterator ( ) ; while ( [[it]] . hasNext ( ) ) { JtxResource [[resource]] = [[it]] . next ( ) ; try { [[resource]] . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { [[it]] . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( [[wasForced]] ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void [[whines]] ( final boolean [[bulimia]] ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > [[como]] = resources . iterator ( ) ; while ( [[como]] . hasNext ( ) ) { JtxResource [[funding]] = [[como]] . next ( ) ; try { [[funding]] . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { [[como]] . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( [[bulimia]] ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 999 ---------------------------------------------
Gets the size of this tuple . --> [[[FAILED]]]

[[[[Adv]]]]: public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 1000 ---------------------------------------------
Request a resource for this transaction . --> [[[FAILED]]]

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

+-------------------------------+--------+
| Attack Results                |        |
+-------------------------------+--------+
| Number of successful attacks: | 948    |
| Number of failed attacks:     | 28     |
| Number of skipped attacks:    | 24     |
| Original accuracy:            | 97.6%  |
| Accuracy under attack:        | 2.8%   |
| Attack success rate:          | 97.13% |
| Average perturbed word %:     | 70.31% |
| Average num. words per input: | 3.91   |
| Avg num queries:              | 478.38 |
| Original BLEU-4:              | 18.42  |
| Perturbed BLEU-4:             | 0.58   |
+-------------------------------+--------+

