[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
Some weights of the model checkpoint at microsoft/graphcodebert-base were not used when initializing RobertaForSequenceClassification: ['lm_head.layer_norm.bias', 'lm_head.layer_norm.weight', 'lm_head.decoder.bias', 'lm_head.bias', 'lm_head.dense.bias', 'lm_head.decoder.weight', 'lm_head.dense.weight']
- This IS expected if you are initializing RobertaForSequenceClassification from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaForSequenceClassification from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
Some weights of RobertaForSequenceClassification were not initialized from the model checkpoint at microsoft/graphcodebert-base and are newly initialized: ['classifier.out_proj.weight', 'classifier.out_proj.bias', 'classifier.dense.weight', 'classifier.dense.bias']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertForMaskedLM: ['cls.seq_relationship.weight', 'cls.seq_relationship.bias']
- This IS expected if you are initializing BertForMaskedLM from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing BertForMaskedLM from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
textattack: Running 3 worker(s) on 3 GPU(s).
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
[proxychains] DLL init: proxychains-ng 4.14-git-42-g931e0df
textattack: Worklist size: 2690
textattack: Worklist candidate size: 0
  0%|          | 0/2690 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 1 / 1:   0%|          | 1/2690 [00:00<00:02, 1140.07it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 2 / 2:   0%|          | 2/2690 [00:00<00:01, 1479.99it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 3 / 3:   0%|          | 3/2690 [00:00<00:01, 1578.78it/s]--------------------------------------------- Result 1 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec, int size, int big_endian) { int id; uint64_t bitrate; if (size < 14) { avpriv_request_sample(codec, "wav header size < 14"); return AVERROR_INVALIDDATA; } codec->codec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) { id = avio_rl16(pb); if (id != 0x0165) { codec->channels = avio_rl16(pb); codec->sample_rate = avio_rl32(pb); bitrate = avio_rl32(pb) * 8LL; codec->block_align = avio_rl16(pb); } } else { id = avio_rb16(pb); codec->channels = avio_rb16(pb); codec->sample_rate = avio_rb32(pb); bitrate = avio_rb32(pb) * 8LL; codec->block_align = avio_rb16(pb); } if (size == 14) { codec->bits_per_coded_sample = 8; } else { if (!big_endian) { codec->bits_per_coded_sample = avio_rl16(pb); } else { codec->bits_per_coded_sample = avio_rb16(pb); } } if (id == 0xFFFE) { codec->codec_tag = 0; } else { codec->codec_tag = id; codec->codec_id = ff_wav_codec_get_id(id, codec->bits_per_coded_sample); } if (size >= 18 && id != 0x0165) { int cbSize = avio_rl16(pb); if (big_endian) { avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { parse_waveformatex(pb, codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } if (size > 0) avio_skip(pb, size); } else if (id == 0x0165 && size >= 32) { int nb_streams, i; size -= 4; av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, size) < 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec->extradata + 4); codec->sample_rate = AV_RL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i < nb_streams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INT_MAX) { if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; } else { av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec->bit_rate = 0; } } else { codec->bit_rate = bitrate; } if (codec->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec->sample_rate); return AVERROR_INVALIDDATA; } if (codec->codec_id == AV_CODEC_ID_AAC_LATM) { codec->channels = 0; codec->sample_rate = 0; } if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; return 0; }
--------------------------------------------- Result 2 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub, int pred_order) { int p, porder, psize; int i, part_end; int count = 0; count += 8; if (sub->type == FLAC_SUBFRAME_CONSTANT) { count += sub->obits; } else if (sub->type == FLAC_SUBFRAME_VERBATIM) { count += s->frame.blocksize * sub->obits; } else { count += pred_order * sub->obits; if (sub->type == FLAC_SUBFRAME_LPC) count += 4 + 5 + pred_order * s->options.lpc_coeff_precision; count += 2; porder = sub->rc.porder; psize = s->frame.blocksize >> porder; count += 4; i = pred_order; part_end = psize; for (p = 0; p < 1 << porder; p++) { int k = sub->rc.params[p]; count += 4; count += rice_count_exact(&sub->residual[i], part_end - i, k); i = part_end; part_end = FFMIN(s->frame.blocksize, part_end + psize); } } return count; }
--------------------------------------------- Result 3 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; const char *boot_device = args->boot_order; PowerPCCPU *cpu; CPUPPCState *env; PCIHostState *phb; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); hwaddr rma_alloc_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; bool kernel_le = "False" != "False"; char *filename; msi_supported = "True" == "True"; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr->phbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) { hw_error("qemu: Unable to create RMA\n"); exit(1); } if (rma_alloc_size && (rma_alloc_size < ram_size)) { spapr->rma_size = rma_alloc_size; } else { spapr->rma_size = ram_size; if (kvm_enabled()) { spapr->vrma_adjust = 1; spapr->rma_size = MIN(spapr->rma_size, 0x10000000); } } rtas_limit = MIN(spapr->rma_size, 0x80000000); spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE; load_limit = spapr->fdt_addr - FW_OVERHEAD; spapr->htab_shift = 18; while (spapr->htab_shift <= 46) { if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) { break; } spapr->htab_shift++; } spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads, XICS_IRQS); spapr->next_irq = XICS_IRQ_BASE; if (cpu_model == NULL) { cpu_model = kvm_enabled() ? "host" : "POWER7"; } for (i = 0; i < smp_cpus; i++) { cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } env = &cpu->env; xics_cpu_setup(spapr->icp, cpu); cpu_ppc_tb_init(env, TIMEBASE_FREQ); env->msr_mask &= ~(1 << 6); if (kvm_enabled()) { kvmppc_set_papr(cpu); } qemu_register_reset(spapr_cpu_reset, cpu); } spapr->ram_limit = ram_size; if (spapr->ram_limit > rma_alloc_size) { ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size; memory_region_init_ram(ram, NULL, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr, rtas_limit - spapr->rtas_addr); if (spapr->rtas_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } if (spapr->rtas_size > RTAS_MAX_SIZE) { hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr->rtas_size, RTAS_MAX_SIZE); exit(1); } g_free(filename); spapr_events_init(spapr); spapr->vio_bus = spapr_vio_bus_init(); for (i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { spapr_vty_create(spapr->vio_bus, serial_hds[i]); } } spapr_create_nvram(spapr); spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW); spapr_pci_rtas_init(); phb = spapr_create_phb(spapr, 0); for (i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!nd->model) { nd->model = g_strdup("ibmveth"); } if (strcmp(nd->model, "ibmveth") == 0) { spapr_vlan_create(spapr->vio_bus, nd); } else { pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL); } } for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) { spapr_vscsi_create(spapr->vio_bus); } if (spapr_vga_init(phb->bus)) { spapr->has_graphics = "True" == "True"; } if (usb_enabled(spapr->has_graphics)) { pci_create_simple(phb->bus, -1, "pci-ohci"); if (spapr->has_graphics) { usbdevice_create("keyboard"); usbdevice_create("mouse"); } } if (spapr->rma_size < (MIN_RMA_SLOF << 20)) { fprintf(stderr, "qemu: pSeries SLOF firmware requires >= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); } if (kernel_filename) { uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) { kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0); kernel_le = kernel_size > 0; } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } } if (bios_name == NULL) { bios_name = FW_FILE_NAME; } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } g_free(filename); spapr->entry_point = 0x100; vmstate_register(NULL, 0, &vmstate_spapr, spapr); register_savevm_live(NULL, "spapr/htab", -1, 1, &savevm_htab_handlers, spapr); spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, initrd_base, initrd_size, kernel_size, kernel_le, boot_device, kernel_cmdline, spapr->epow_irq); assert(spapr->fdt_skel != NULL); }
--------------------------------------------- Result 4 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 0 / 3 / 4:   0%|          | 4/2690 [00:00<00:02, 1251.28it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 3 / 4:   0%|          | 5/2690 [00:03<35:28,  1.26it/s]  [Succeeded / Failed / Skipped / Total] 1 / 0 / 4 / 5:   0%|          | 5/2690 [00:03<35:28,  1.26it/s][[0 (60%)]] --> [[0 (35%)]] --> Socre: 0.6540761291980743

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *xendev) { int i; Xen9pfsDev *[[xen_9pdev]] = container_of(xendev, Xen9pfsDev, xendev); V9fsState *s = &[[xen_9pdev]]->state; QemuOpts *fsdev; if (xenstore_read_fe_int(&[[xen_9pdev]]->xendev, "num-rings", &[[xen_9pdev]]->num_rings) == -1 || [[xen_9pdev]]->num_rings > MAX_RINGS || [[xen_9pdev]]->num_rings < 1) { return -1; } [[xen_9pdev]]->rings = g_malloc0([[xen_9pdev]]->num_rings * sizeof(Xen9pfsRing)); for (i = 0; i < [[xen_9pdev]]->num_rings; i++) { char *str; int ring_order; [[xen_9pdev]]->rings[i].priv = [[xen_9pdev]]; [[xen_9pdev]]->rings[i].evtchn = -1; [[xen_9pdev]]->rings[i].local_port = -1; str = g_strdup_printf("ring-ref%u", i); if (xenstore_read_fe_int(&[[xen_9pdev]]->xendev, str, &[[xen_9pdev]]->rings[i].ref) == -1) { goto out; } str = g_strdup_printf("event-channel-%u", i); if (xenstore_read_fe_int(&[[xen_9pdev]]->xendev, str, &[[xen_9pdev]]->rings[i].evtchn) == -1) { goto out; } [[xen_9pdev]]->rings[i].intf = xengnttab_map_grant_ref( [[xen_9pdev]]->xendev.gnttabdev, [[xen_9pdev]]->xendev.dom, [[xen_9pdev]]->rings[i].ref, PROT_READ | PROT_WRITE); if (![[xen_9pdev]]->rings[i].intf) { goto out; } ring_order = [[xen_9pdev]]->rings[i].intf->ring_order; if (ring_order > MAX_RING_ORDER) { goto out; } [[xen_9pdev]]->rings[i].ring_order = ring_order; [[xen_9pdev]]->rings[i].data = xengnttab_map_domain_grant_refs( [[xen_9pdev]]->xendev.gnttabdev, (1 << ring_order), [[xen_9pdev]]->xendev.dom, [[xen_9pdev]]->rings[i].intf->ref, PROT_READ | PROT_WRITE); if (![[xen_9pdev]]->rings[i].data) { goto out; } [[xen_9pdev]]->rings[i].ring.in = [[xen_9pdev]]->rings[i].data; [[xen_9pdev]]->rings[i].ring.out = [[xen_9pdev]]->rings[i].data + XEN_FLEX_RING_SIZE(ring_order); [[xen_9pdev]]->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &[[xen_9pdev]]->rings[i]); [[xen_9pdev]]->rings[i].out_cons = 0; [[xen_9pdev]]->rings[i].out_size = 0; [[xen_9pdev]]->rings[i].inprogress = "False" != "False"; [[xen_9pdev]]->rings[i].evtchndev = xenevtchn_open(NULL, 0); if ([[xen_9pdev]]->rings[i].evtchndev == NULL) { goto out; } fcntl(xenevtchn_fd([[xen_9pdev]]->rings[i].evtchndev), F_SETFD, FD_CLOEXEC); [[xen_9pdev]]->rings[i].local_port = xenevtchn_bind_interdomain ([[xen_9pdev]]->rings[i].evtchndev, xendev->dom, [[xen_9pdev]]->rings[i].evtchn); if ([[xen_9pdev]]->rings[i].local_port == -1) { xen_pv_printf(xendev, 0, "xenevtchn_bind_interdomain failed port=%d\n", [[xen_9pdev]]->rings[i].evtchn); goto out; } xen_pv_printf(xendev, 2, "bind evtchn port %d\n", xendev->local_port); qemu_set_fd_handler(xenevtchn_fd([[xen_9pdev]]->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &[[xen_9pdev]]->rings[i]); } [[xen_9pdev]]->security_model = xenstore_read_be_str(xendev, "security_model"); [[xen_9pdev]]->path = xenstore_read_be_str(xendev, "path"); [[xen_9pdev]]->id = s->fsconf.fsdev_id = g_strdup_printf("xen9p%d", xendev->dev); [[xen_9pdev]]->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s->fsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", [[xen_9pdev]]->path, NULL); qemu_opt_set(fsdev, "security_model", [[xen_9pdev]]->security_model, NULL); qemu_opts_set_id(fsdev, s->fsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free(xendev); return -1; }

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *xendev) { int i; Xen9pfsDev *[[ξgnny14katav]] = container_of(xendev, Xen9pfsDev, xendev); V9fsState *s = &[[ξgnny14katav]]->state; QemuOpts *fsdev; if (xenstore_read_fe_int(&[[ξgnny14katav]]->xendev, "num-rings", &[[ξgnny14katav]]->num_rings) == -1 || [[ξgnny14katav]]->num_rings > MAX_RINGS || [[ξgnny14katav]]->num_rings < 1) { return -1; } [[ξgnny14katav]]->rings = g_malloc0([[ξgnny14katav]]->num_rings * sizeof(Xen9pfsRing)); for (i = 0; i < [[ξgnny14katav]]->num_rings; i++) { char *str; int ring_order; [[ξgnny14katav]]->rings[i].priv = [[ξgnny14katav]]; [[ξgnny14katav]]->rings[i].evtchn = -1; [[ξgnny14katav]]->rings[i].local_port = -1; str = g_strdup_printf("ring-ref%u", i); if (xenstore_read_fe_int(&[[ξgnny14katav]]->xendev, str, &[[ξgnny14katav]]->rings[i].ref) == -1) { goto out; } str = g_strdup_printf("event-channel-%u", i); if (xenstore_read_fe_int(&[[ξgnny14katav]]->xendev, str, &[[ξgnny14katav]]->rings[i].evtchn) == -1) { goto out; } [[ξgnny14katav]]->rings[i].intf = xengnttab_map_grant_ref( [[ξgnny14katav]]->xendev.gnttabdev, [[ξgnny14katav]]->xendev.dom, [[ξgnny14katav]]->rings[i].ref, PROT_READ | PROT_WRITE); if (![[ξgnny14katav]]->rings[i].intf) { goto out; } ring_order = [[ξgnny14katav]]->rings[i].intf->ring_order; if (ring_order > MAX_RING_ORDER) { goto out; } [[ξgnny14katav]]->rings[i].ring_order = ring_order; [[ξgnny14katav]]->rings[i].data = xengnttab_map_domain_grant_refs( [[ξgnny14katav]]->xendev.gnttabdev, (1 << ring_order), [[ξgnny14katav]]->xendev.dom, [[ξgnny14katav]]->rings[i].intf->ref, PROT_READ | PROT_WRITE); if (![[ξgnny14katav]]->rings[i].data) { goto out; } [[ξgnny14katav]]->rings[i].ring.in = [[ξgnny14katav]]->rings[i].data; [[ξgnny14katav]]->rings[i].ring.out = [[ξgnny14katav]]->rings[i].data + XEN_FLEX_RING_SIZE(ring_order); [[ξgnny14katav]]->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &[[ξgnny14katav]]->rings[i]); [[ξgnny14katav]]->rings[i].out_cons = 0; [[ξgnny14katav]]->rings[i].out_size = 0; [[ξgnny14katav]]->rings[i].inprogress = "False" != "False"; [[ξgnny14katav]]->rings[i].evtchndev = xenevtchn_open(NULL, 0); if ([[ξgnny14katav]]->rings[i].evtchndev == NULL) { goto out; } fcntl(xenevtchn_fd([[ξgnny14katav]]->rings[i].evtchndev), F_SETFD, FD_CLOEXEC); [[ξgnny14katav]]->rings[i].local_port = xenevtchn_bind_interdomain ([[ξgnny14katav]]->rings[i].evtchndev, xendev->dom, [[ξgnny14katav]]->rings[i].evtchn); if ([[ξgnny14katav]]->rings[i].local_port == -1) { xen_pv_printf(xendev, 0, "xenevtchn_bind_interdomain failed port=%d\n", [[ξgnny14katav]]->rings[i].evtchn); goto out; } xen_pv_printf(xendev, 2, "bind evtchn port %d\n", xendev->local_port); qemu_set_fd_handler(xenevtchn_fd([[ξgnny14katav]]->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &[[ξgnny14katav]]->rings[i]); } [[ξgnny14katav]]->security_model = xenstore_read_be_str(xendev, "security_model"); [[ξgnny14katav]]->path = xenstore_read_be_str(xendev, "path"); [[ξgnny14katav]]->id = s->fsconf.fsdev_id = g_strdup_printf("xen9p%d", xendev->dev); [[ξgnny14katav]]->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s->fsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", [[ξgnny14katav]]->path, NULL); qemu_opt_set(fsdev, "security_model", [[ξgnny14katav]]->security_model, NULL); qemu_opts_set_id(fsdev, s->fsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free(xendev); return -1; }
--------------------------------------------- Result 5 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_read_request(SCSIDiskReq *r) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; if (r->sector_count == (uint32_t)-1) { DPRINTF("Read buf_len=%zd\n", r->iov.iov_len); r->sector_count = 0; scsi_req_data(&r->req, r->iov.iov_len); return; } DPRINTF("Read sector_count=%d\n", r->sector_count); if (r->sector_count == 0) { scsi_command_complete(r, GOOD, NO_SENSE); return; } assert(r->req.aiocb == NULL); n = r->sector_count; if (n > SCSI_DMA_BUF_SIZE / 512) n = SCSI_DMA_BUF_SIZE / 512; r->iov.iov_len = n * 512; qemu_iovec_init_external(&r->qiov, &r->iov, 1); r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n, scsi_read_complete, r); if (r->req.aiocb == NULL) { scsi_read_complete(r, -EIO); } }
--------------------------------------------- Result 6 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 0 / 5 / 6:   0%|          | 6/2690 [00:04<33:36,  1.33it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 5 / 7:   0%|          | 7/2690 [00:33<3:33:06,  4.77s/it][Succeeded / Failed / Skipped / Total] 2 / 1 / 5 / 8:   0%|          | 8/2690 [00:43<4:03:12,  5.44s/it][Succeeded / Failed / Skipped / Total] 3 / 1 / 5 / 9:   0%|          | 9/2690 [00:52<4:20:43,  5.83s/it][Succeeded / Failed / Skipped / Total] 3 / 1 / 5 / 9:   0%|          | 10/2690 [00:56<4:12:01,  5.64s/it][[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void lm32_evr_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; const char *kernel_filename = machine->kernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq irq[32]; ResetInfo *reset_info; int i; hwaddr flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; hwaddr ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; hwaddr timer0_base = 0x80002000; hwaddr uart0_base = 0x80006000; hwaddr timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; reset_info = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) { cpu_model = "lm32-full"; } cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model)); if (cpu == NULL) { fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model); exit(1); } env = &cpu->env; reset_info->cpu = cpu; reset_info->flash_base = flash_base; memory_region_allocate_system_memory(phys_ram, NULL, "lm32_evr.sdram", ram_size); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? blk_by_legacy_dinfo(dinfo) : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0)); for (i = 0; i < 32; i++) { irq[i] = qdev_get_gpio_in(env->pic_state, i); } lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]); sysbus_create_simple("lm32-timer", timer0_base, irq[timer0_irq]); sysbus_create_simple("lm32-timer", timer1_base, irq[timer1_irq]); env->juart_state = lm32_juart_init(serial_hds[1]); reset_info->bootstrap_pc = flash_base; if (kernel_filename) { uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, EM_LATTICEMICO32, 0, 0); reset_info->bootstrap_pc = entry; if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); reset_info->bootstrap_pc = ram_base; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } qemu_register_reset(main_cpu_reset, reset_info); }
--------------------------------------------- Result 7 ---------------------------------------------
[[0 (4%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *[[drc]]) { [[drc]]->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if ([[drc]]->awaiting_release) { uint32_t [[drc_index]] = spapr_drc_index([[drc]]); trace_spapr_drc_set_allocation_state_finalizing([[drc_index]]); spapr_drc_detach([[drc]]); } return RTAS_OUT_SUCCESS; }

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *[[gru]]) { [[gru]]->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if ([[gru]]->awaiting_release) { uint32_t [[yacttx]] = spapr_drc_index([[gru]]); trace_spapr_drc_set_allocation_state_finalizing([[yacttx]]); spapr_drc_detach([[gru]]); } return RTAS_OUT_SUCCESS; }
--------------------------------------------- Result 8 ---------------------------------------------
[[0 (35%)]] --> [[0 (81%)]] --> Socre: 0.8063583374023438

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size) { Mpeg1Context *s1 = avctx->priv_data; MpegEncContext *[[s]] = &s1->mpeg_enc_ctx; int [[width]], height, i, v, j; float aspect; init_get_bits(&[[s]]->gb, buf, buf_size); [[width]] = get_bits(&[[s]]->gb, 12); height = get_bits(&[[s]]->gb, 12); [[s]]->aspect_ratio_info= get_bits(&[[s]]->gb, 4); if(![[s]]->mpeg2){ aspect= mpeg1_aspect[[[s]]->aspect_ratio_info]; if(aspect!=0.0) avctx->aspect_ratio= [[width]]/(aspect*height); } [[s]]->frame_rate_index = get_bits(&[[s]]->gb, 4); if ([[s]]->frame_rate_index == 0) return -1; [[s]]->bit_rate = get_bits(&[[s]]->gb, 18) * 400; if (get_bits1(&[[s]]->gb) == 0) return -1; if ([[width]] <= 0 || height <= 0 || ([[width]] % 2) != 0 || (height % 2) != 0) return -1; if ([[width]] != [[s]]->width || height != [[s]]->height) { [[s]]->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end([[s]]); } [[s]]->width = [[width]]; [[s]]->height = height; avctx->has_b_frames= 1; [[s]]->avctx = avctx; avctx->width = [[width]]; avctx->height = height; if ([[s]]->frame_rate_index >= 9) { avctx->frame_rate = 25 * FRAME_RATE_BASE; } else { avctx->frame_rate = frame_rate_tab[[[s]]->frame_rate_index]; } [[s]]->frame_rate = avctx->frame_rate; avctx->bit_rate = [[s]]->bit_rate; if (MPV_common_init([[s]]) < 0) return -1; s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&[[s]]->gb, 10); skip_bits(&[[s]]->gb, 1); if (get_bits1(&[[s]]->gb)) { for(i=0;i<64;i++) { v = get_bits(&[[s]]->gb, 8); j = [[s]]->intra_scantable.permutated[i]; [[s]]->intra_matrix[j] = v; [[s]]->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", [[s]]->intra_matrix[[[s]]->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= [[s]]->idct_permutation[i]; v = ff_mpeg1_default_intra_matrix[i]; [[s]]->intra_matrix[j] = v; [[s]]->chroma_intra_matrix[j] = v; } } if (get_bits1(&[[s]]->gb)) { for(i=0;i<64;i++) { v = get_bits(&[[s]]->gb, 8); j = [[s]]->intra_scantable.permutated[i]; [[s]]->inter_matrix[j] = v; [[s]]->chroma_inter_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", [[s]]->inter_matrix[[[s]]->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= [[s]]->idct_permutation[i]; v = ff_mpeg1_default_non_intra_matrix[i]; [[s]]->inter_matrix[j] = v; [[s]]->chroma_inter_matrix[j] = v; } } [[s]]->progressive_sequence = 1; [[s]]->progressive_frame = 1; [[s]]->picture_structure = PICT_FRAME; [[s]]->frame_pred_frame_dct = 1; [[s]]->mpeg2 = 0; avctx->sub_id = 1; return 0; }

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size) { Mpeg1Context *s1 = avctx->priv_data; MpegEncContext *[[iris]] = &s1->mpeg_enc_ctx; int [[rest]], height, i, v, j; float aspect; init_get_bits(&[[iris]]->gb, buf, buf_size); [[rest]] = get_bits(&[[iris]]->gb, 12); height = get_bits(&[[iris]]->gb, 12); [[iris]]->aspect_ratio_info= get_bits(&[[iris]]->gb, 4); if(![[iris]]->mpeg2){ aspect= mpeg1_aspect[[[iris]]->aspect_ratio_info]; if(aspect!=0.0) avctx->aspect_ratio= [[rest]]/(aspect*height); } [[iris]]->frame_rate_index = get_bits(&[[iris]]->gb, 4); if ([[iris]]->frame_rate_index == 0) return -1; [[iris]]->bit_rate = get_bits(&[[iris]]->gb, 18) * 400; if (get_bits1(&[[iris]]->gb) == 0) return -1; if ([[rest]] <= 0 || height <= 0 || ([[rest]] % 2) != 0 || (height % 2) != 0) return -1; if ([[rest]] != [[iris]]->width || height != [[iris]]->height) { [[iris]]->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end([[iris]]); } [[iris]]->width = [[rest]]; [[iris]]->height = height; avctx->has_b_frames= 1; [[iris]]->avctx = avctx; avctx->width = [[rest]]; avctx->height = height; if ([[iris]]->frame_rate_index >= 9) { avctx->frame_rate = 25 * FRAME_RATE_BASE; } else { avctx->frame_rate = frame_rate_tab[[[iris]]->frame_rate_index]; } [[iris]]->frame_rate = avctx->frame_rate; avctx->bit_rate = [[iris]]->bit_rate; if (MPV_common_init([[iris]]) < 0) return -1; s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&[[iris]]->gb, 10); skip_bits(&[[iris]]->gb, 1); if (get_bits1(&[[iris]]->gb)) { for(i=0;i<64;i++) { v = get_bits(&[[iris]]->gb, 8); j = [[iris]]->intra_scantable.permutated[i]; [[iris]]->intra_matrix[j] = v; [[iris]]->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", [[iris]]->intra_matrix[[[iris]]->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= [[iris]]->idct_permutation[i]; v = ff_mpeg1_default_intra_matrix[i]; [[iris]]->intra_matrix[j] = v; [[iris]]->chroma_intra_matrix[j] = v; } } if (get_bits1(&[[iris]]->gb)) { for(i=0;i<64;i++) { v = get_bits(&[[iris]]->gb, 8); j = [[iris]]->intra_scantable.permutated[i]; [[iris]]->inter_matrix[j] = v; [[iris]]->chroma_inter_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", [[iris]]->inter_matrix[[[iris]]->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= [[iris]]->idct_permutation[i]; v = ff_mpeg1_default_non_intra_matrix[i]; [[iris]]->inter_matrix[j] = v; [[iris]]->chroma_inter_matrix[j] = v; } } [[iris]]->progressive_sequence = 1; [[iris]]->progressive_frame = 1; [[iris]]->picture_structure = PICT_FRAME; [[iris]]->frame_pred_frame_dct = 1; [[iris]]->mpeg2 = 0; avctx->sub_id = 1; return 0; }
--------------------------------------------- Result 9 ---------------------------------------------
[[0 (75%)]] --> [[0 (41%)]] --> Socre: 0.5918372571468353

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *[[block]]) { int i; int dc = [[block]][0]; const uint8_t *cm; dc = (3 * dc + 1) >> 1; dc = (3 * dc + 16) >> 5; cm = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ dest[0] = cm[dest[0]]; dest[1] = cm[dest[1]]; dest[2] = cm[dest[2]]; dest[3] = cm[dest[3]]; dest[4] = cm[dest[4]]; dest[5] = cm[dest[5]]; dest[6] = cm[dest[6]]; dest[7] = cm[dest[7]]; dest += linesize; } }

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *[[station]]) { int i; int dc = [[station]][0]; const uint8_t *cm; dc = (3 * dc + 1) >> 1; dc = (3 * dc + 16) >> 5; cm = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ dest[0] = cm[dest[0]]; dest[1] = cm[dest[1]]; dest[2] = cm[dest[2]]; dest[3] = cm[dest[3]]; dest[4] = cm[dest[4]]; dest[5] = cm[dest[5]]; dest[6] = cm[dest[6]]; dest[7] = cm[dest[7]]; dest += linesize; } }
--------------------------------------------- Result 10 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 1 / 5 / 10:   0%|          | 10/2690 [00:56<4:12:01,  5.64s/it][Succeeded / Failed / Skipped / Total] 4 / 1 / 5 / 10:   0%|          | 11/2690 [01:16<5:09:28,  6.93s/it][Succeeded / Failed / Skipped / Total] 5 / 1 / 5 / 11:   0%|          | 11/2690 [01:16<5:09:28,  6.93s/it][Succeeded / Failed / Skipped / Total] 5 / 1 / 5 / 11:   0%|          | 12/2690 [01:31<5:40:01,  7.62s/it][Succeeded / Failed / Skipped / Total] 5 / 2 / 5 / 12:   0%|          | 12/2690 [01:31<5:40:01,  7.62s/it][Succeeded / Failed / Skipped / Total] 5 / 2 / 5 / 12:   0%|          | 13/2690 [01:39<5:40:42,  7.64s/it][Succeeded / Failed / Skipped / Total] 6 / 2 / 5 / 13:   0%|          | 13/2690 [01:39<5:40:43,  7.64s/it][Succeeded / Failed / Skipped / Total] 6 / 2 / 5 / 13:   1%|          | 14/2690 [01:47<5:42:48,  7.69s/it][[0 (39%)]] --> [[0 (94%)]] --> Socre: 0.9373155832290649

[[[[Adv]]]]: aio_write_f(int argc, char **argv) { char *[[p]]; int count = 0; int nr_iov, i, c; int pattern = 0xcd; struct aio_ctx *[[ctx]] = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *acb; while ((c = getopt(argc, argv, "CqP:")) != EOF) { switch (c) { case 'C': [[ctx]]->Cflag = 1; break; case 'q': [[ctx]]->qflag = 1; break; case 'P': pattern = atoi(optarg); break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) return command_usage(&aio_write_cmd); [[ctx]]->offset = cvtnum(argv[optind]); if ([[ctx]]->offset < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; if ([[ctx]]->offset & 0x1ff) { printf("offset %lld is not sector aligned\n", (long long)[[ctx]]->offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } for (i = optind; i < argc; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[i]); return 0; } count += len; } nr_iov = argc - optind; qemu_iovec_init(&[[ctx]]->qiov, nr_iov); [[ctx]]->buf = [[p]] = qemu_io_alloc(count, pattern); for (i = 0; i < nr_iov; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } qemu_iovec_add(&[[ctx]]->qiov, [[p]], len); [[p]] += len; optind++; } gettimeofday(&[[ctx]]->t1, NULL); acb = bdrv_aio_writev(bs, [[ctx]]->offset >> 9, &[[ctx]]->qiov, [[ctx]]->qiov.size >> 9, aio_write_done, [[ctx]]); if (!acb) return -EIO; return 0; }

[[[[Adv]]]]: aio_write_f(int argc, char **argv) { char *[[it]]; int count = 0; int nr_iov, i, c; int pattern = 0xcd; struct aio_ctx *[[valleb]] = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *acb; while ((c = getopt(argc, argv, "CqP:")) != EOF) { switch (c) { case 'C': [[valleb]]->Cflag = 1; break; case 'q': [[valleb]]->qflag = 1; break; case 'P': pattern = atoi(optarg); break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) return command_usage(&aio_write_cmd); [[valleb]]->offset = cvtnum(argv[optind]); if ([[valleb]]->offset < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; if ([[valleb]]->offset & 0x1ff) { printf("offset %lld is not sector aligned\n", (long long)[[valleb]]->offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } for (i = optind; i < argc; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[i]); return 0; } count += len; } nr_iov = argc - optind; qemu_iovec_init(&[[valleb]]->qiov, nr_iov); [[valleb]]->buf = [[it]] = qemu_io_alloc(count, pattern); for (i = 0; i < nr_iov; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } qemu_iovec_add(&[[valleb]]->qiov, [[it]], len); [[it]] += len; optind++; } gettimeofday(&[[valleb]]->t1, NULL); acb = bdrv_aio_writev(bs, [[valleb]]->offset >> 9, &[[valleb]]->qiov, [[valleb]]->qiov.size >> 9, aio_write_done, [[valleb]]); if (!acb) return -EIO; return 0; }
--------------------------------------------- Result 11 ---------------------------------------------
[[0 (51%)]] --> [[0 (22%)]] --> Socre: 0.7794259339570999

[[[[Adv]]]]: static int vmdk_parse_extents(const char *desc, BlockDriverState *bs, const char *desc_file_path) { int [[ret]]; char access[11]; char type[11]; char fname[512]; const char *p = desc; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; Error *local_err = NULL; while (*p) { flat_offset = -1; [[ret]] = sscanf(p, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if ([[ret]] < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if ([[ret]] != 5 || flat_offset < 0) { return -EINVAL; } } else if ([[ret]] != 4) { return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); [[ret]] = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags, &local_err); if ([[ret]]) { qerror_report_err(local_err); error_free(local_err); return [[ret]]; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { VmdkExtent *extent; [[ret]] = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, sectors, &extent); if ([[ret]] < 0) { return [[ret]]; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { [[ret]] = vmdk_open_sparse(bs, extent_file, bs->open_flags); if ([[ret]]) { bdrv_unref(extent_file); return [[ret]]; } } else { fprintf(stderr, "VMDK: Not supported extent type \"%s\""".\n", type); return -ENOTSUP; } next_line: while (*p && *p != '\n') { p++; } p++; } return 0; }

[[[[Adv]]]]: static int vmdk_parse_extents(const char *desc, BlockDriverState *bs, const char *desc_file_path) { int [[singletting]]; char access[11]; char type[11]; char fname[512]; const char *p = desc; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; Error *local_err = NULL; while (*p) { flat_offset = -1; [[singletting]] = sscanf(p, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if ([[singletting]] < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if ([[singletting]] != 5 || flat_offset < 0) { return -EINVAL; } } else if ([[singletting]] != 4) { return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); [[singletting]] = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags, &local_err); if ([[singletting]]) { qerror_report_err(local_err); error_free(local_err); return [[singletting]]; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { VmdkExtent *extent; [[singletting]] = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, sectors, &extent); if ([[singletting]] < 0) { return [[singletting]]; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { [[singletting]] = vmdk_open_sparse(bs, extent_file, bs->open_flags); if ([[singletting]]) { bdrv_unref(extent_file); return [[singletting]]; } } else { fprintf(stderr, "VMDK: Not supported extent type \"%s\""".\n", type); return -ENOTSUP; } next_line: while (*p && *p != '\n') { p++; } p++; } return 0; }
--------------------------------------------- Result 12 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) { uint64_t [[x0]]; uint32_t [[x1]]; [[x0]] = T0 | ((uint64_t) (env->y) << 32); [[x1]] = T1; [[x0]] = [[x0]] / [[x1]]; if ([[x0]] > 0xffffffff) { T0 = 0xffffffff; T1 = 1; } else { T0 = [[x0]]; T1 = 0; FORCE_RET();

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) { uint64_t [[ax1]]; uint32_t [[e₁]]; [[ax1]] = T0 | ((uint64_t) (env->y) << 32); [[e₁]] = T1; [[ax1]] = [[ax1]] / [[e₁]]; if ([[ax1]] > 0xffffffff) { T0 = 0xffffffff; T1 = 1; } else { T0 = [[ax1]]; T1 = 0; FORCE_RET();
--------------------------------------------- Result 13 ---------------------------------------------
[[0 (4%)]] --> [[0 (97%)]] --> Socre: 0.974597156047821

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *[[env]]) { a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0([[env]]); }

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *[[imվ]]) { a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0([[imվ]]); }
--------------------------------------------- Result 14 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 2 / 5 / 14:   1%|          | 14/2690 [01:47<5:42:48,  7.69s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 5 / 14:   1%|          | 15/2690 [01:48<5:21:23,  7.21s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 6 / 15:   1%|          | 15/2690 [01:48<5:21:23,  7.21s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 6 / 15:   1%|          | 16/2690 [01:48<5:02:34,  6.79s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 7 / 16:   1%|          | 16/2690 [01:48<5:02:34,  6.79s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 7 / 16:   1%|          | 17/2690 [01:56<5:06:10,  6.87s/it][Succeeded / Failed / Skipped / Total] 8 / 2 / 7 / 17:   1%|          | 17/2690 [01:56<5:06:10,  6.87s/it][Succeeded / Failed / Skipped / Total] 8 / 2 / 7 / 17:   1%|          | 18/2690 [02:00<4:58:19,  6.70s/it][[0 (72%)]] --> [[0 (32%)]] --> Socre: 0.6762433350086212

[[[[Adv]]]]: static void compute_rematrixing_strategy(AC3EncodeContext *s) { int [[nb_coefs]]; int blk, bnd, i; AC3Block *block, *block0; s->num_rematrixing_bands = 4; if (s->rematrixing & AC3_REMATRIXING_IS_STATIC) return; [[nb_coefs]] = FFMIN(s->nb_coefs[0], s->nb_coefs[1]); for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { block = &s->blocks[blk]; block->new_rematrixing_strategy = !blk; for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) { int start = ff_ac3_rematrix_band_tab[bnd]; int end = FFMIN([[nb_coefs]], ff_ac3_rematrix_band_tab[bnd+1]); CoefSumType [[sum]][4] = {0,}; for (i = start; i < end; i++) { CoefType lt = block->mdct_coef[0][i]; CoefType [[rt]] = block->mdct_coef[1][i]; CoefType md = lt + [[rt]]; CoefType sd = lt - [[rt]]; [[sum]][0] += lt * lt; [[sum]][1] += [[rt]] * [[rt]]; [[sum]][2] += md * md; [[sum]][3] += sd * sd; } if (FFMIN([[sum]][2], [[sum]][3]) < FFMIN([[sum]][0], [[sum]][1])) block->rematrixing_flags[bnd] = 1; else block->rematrixing_flags[bnd] = 0; if (blk && block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) { block->new_rematrixing_strategy = 1; } } block0 = block; } }

[[[[Adv]]]]: static void compute_rematrixing_strategy(AC3EncodeContext *s) { int [[tp16fevs]]; int blk, bnd, i; AC3Block *block, *block0; s->num_rematrixing_bands = 4; if (s->rematrixing & AC3_REMATRIXING_IS_STATIC) return; [[tp16fevs]] = FFMIN(s->nb_coefs[0], s->nb_coefs[1]); for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { block = &s->blocks[blk]; block->new_rematrixing_strategy = !blk; for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) { int start = ff_ac3_rematrix_band_tab[bnd]; int end = FFMIN([[tp16fevs]], ff_ac3_rematrix_band_tab[bnd+1]); CoefSumType [[tag]][4] = {0,}; for (i = start; i < end; i++) { CoefType lt = block->mdct_coef[0][i]; CoefType [[plot]] = block->mdct_coef[1][i]; CoefType md = lt + [[plot]]; CoefType sd = lt - [[plot]]; [[tag]][0] += lt * lt; [[tag]][1] += [[plot]] * [[plot]]; [[tag]][2] += md * md; [[tag]][3] += sd * sd; } if (FFMIN([[tag]][2], [[tag]][3]) < FFMIN([[tag]][0], [[tag]][1])) block->rematrixing_flags[bnd] = 1; else block->rematrixing_flags[bnd] = 0; if (blk && block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) { block->new_rematrixing_strategy = 1; } } block0 = block; } }
--------------------------------------------- Result 15 ---------------------------------------------
[[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rv34_decode_mv(RV34DecContext *r, int block_type) { MpegEncContext *s = &r->s; GetBitContext *gb = &s->gb; int i, j, k, l; int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride; int next_bt; memset(r->dmv, 0, sizeof(r->dmv)); for(i = 0; i < num_mvs[block_type]; i++){ r->dmv[i][0] = svq3_get_se_golomb(gb); r->dmv[i][1] = svq3_get_se_golomb(gb); } switch(block_type){ case RV34_MB_TYPE_INTRA: case RV34_MB_TYPE_INTRA16x16: ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); return 0; case RV34_MB_SKIP: if(s->pict_type == AV_PICTURE_TYPE_P){ ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; } case RV34_MB_B_DIRECT: if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0); next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride]; if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){ ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); }else for(j = 0; j < 2; j++) for(i = 0; i < 2; i++) for(k = 0; k < 2; k++) for(l = 0; l < 2; l++) s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]); if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) rv34_mc_2mv(r, block_type); else rv34_mc_2mv_skip(r); ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); break; case RV34_MB_P_16x16: case RV34_MB_P_MIX16x16: rv34_pred_mv(r, block_type, 0, 0); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; case RV34_MB_B_FORWARD: case RV34_MB_B_BACKWARD: r->dmv[1][0] = r->dmv[0][0]; r->dmv[1][1] = r->dmv[0][1]; if(r->rv30) rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD); else rv34_pred_mv_b (r, block_type, block_type == RV34_MB_B_BACKWARD); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD); break; case RV34_MB_P_16x8: case RV34_MB_P_8x16: rv34_pred_mv(r, block_type, 0, 0); rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1); if(block_type == RV34_MB_P_16x8){ rv34_mc_1mv(r, block_type, 0, 0, 0, 2, 1, 0); rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0); } if(block_type == RV34_MB_P_8x16){ rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0); rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0); } break; case RV34_MB_B_BIDIR: rv34_pred_mv_b (r, block_type, 0); rv34_pred_mv_b (r, block_type, 1); rv34_mc_2mv (r, block_type); break; case RV34_MB_P_8x8: for(i=0;i< 4;i++){ rv34_pred_mv(r, block_type, i, i); rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0); } break; } return 0; }
--------------------------------------------- Result 16 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target, const char *replaces, int64_t speed, uint32_t granularity, int64_t buf_size, BlockdevOnError on_source_error, BlockdevOnError on_target_error, bool unmap, BlockCompletionFunc *cb, void *opaque, Error **errp, const BlockJobDriver *driver, bool is_none_mode, BlockDriverState *base) { MirrorBlockJob *s; if (granularity == 0) { granularity = bdrv_get_default_bitmap_granularity(target); } assert ((granularity & (granularity - 1)) == 0); if ((on_source_error == BLOCKDEV_ON_ERROR_STOP || on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) && (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) { error_setg(errp, QERR_INVALID_PARAMETER, "on-source-error"); return; } if (buf_size < 0) { error_setg(errp, "Invalid parameter 'buf-size'"); return; } if (buf_size == 0) { buf_size = DEFAULT_MIRROR_BUF_SIZE; } if (replaces) { replaced_bs = bdrv_lookup_bs(replaces, replaces, errp); if (replaced_bs == NULL) { return; } } else { replaced_bs = bs; } if (replaced_bs->blk && target->blk) { error_setg(errp, "Can't create node with two BlockBackends"); return; } s = block_job_create(driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->replaces = g_strdup(replaces); s->on_source_error = on_source_error; s->on_target_error = on_target_error; s->target = target; s->is_none_mode = is_none_mode; s->base = base; s->granularity = granularity; s->buf_size = ROUND_UP(buf_size, granularity); s->unmap = unmap; s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp); if (!s->dirty_bitmap) { g_free(s->replaces); block_job_unref(&s->common); return; } bdrv_op_block_all(s->target, s->common.blocker); bdrv_set_enable_write_cache(s->target, "True" == "True"); if (s->target->blk) { blk_set_on_error(s->target->blk, on_target_error, on_target_error); blk_iostatus_enable(s->target->blk); } s->common.co = qemu_coroutine_create(mirror_run); trace_mirror_start(bs, s, s->common.co, opaque); qemu_coroutine_enter(s->common.co, s); }
--------------------------------------------- Result 17 ---------------------------------------------
[[0 (33%)]] --> [[0 (58%)]] --> Socre: 0.5813606381416321

[[[[Adv]]]]: int qemu_cpu_self(void *[[env]]) { return 1; }

[[[[Adv]]]]: int qemu_cpu_self(void *[[datavi]]) { return 1; }
--------------------------------------------- Result 18 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 2 / 7 / 18:   1%|          | 18/2690 [02:00<4:58:19,  6.70s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 7 / 18:   1%|          | 19/2690 [02:01<4:43:42,  6.37s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 8 / 19:   1%|          | 19/2690 [02:01<4:43:43,  6.37s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 8 / 19:   1%|          | 20/2690 [02:01<4:30:29,  6.08s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 9 / 20:   1%|          | 20/2690 [02:01<4:30:29,  6.08s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 9 / 20:   1%|          | 21/2690 [02:28<5:15:01,  7.08s/it][Succeeded / Failed / Skipped / Total] 9 / 3 / 9 / 21:   1%|          | 21/2690 [02:28<5:15:01,  7.08s/it][Succeeded / Failed / Skipped / Total] 9 / 3 / 9 / 21:   1%|          | 22/2690 [02:29<5:01:38,  6.78s/it][Succeeded / Failed / Skipped / Total] 9 / 3 / 10 / 22:   1%|          | 22/2690 [02:29<5:01:38,  6.78s/it][Succeeded / Failed / Skipped / Total] 9 / 3 / 10 / 22:   1%|          | 23/2690 [02:54<5:37:17,  7.59s/it][Succeeded / Failed / Skipped / Total] 10 / 3 / 10 / 23:   1%|          | 23/2690 [02:54<5:37:17,  7.59s/it][Succeeded / Failed / Skipped / Total] 10 / 3 / 10 / 23:   1%|          | 24/2690 [02:55<5:24:04,  7.29s/it][Succeeded / Failed / Skipped / Total] 10 / 3 / 11 / 24:   1%|          | 24/2690 [02:55<5:24:04,  7.29s/it][Succeeded / Failed / Skipped / Total] 10 / 3 / 11 / 24:   1%|          | 25/2690 [03:03<5:25:17,  7.32s/it][[0 (44%)]] --> [[0 (98%)]] --> Socre: 0.9790496230125427

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *[[s]], bool link_down) { [[s]]->nc.link_down = link_down; if ([[s]]->nc.peer) { [[s]]->nc.peer->link_down = link_down; } if ([[s]]->nc.info->link_status_changed) { [[s]]->nc.info->link_status_changed(&[[s]]->nc); } if ([[s]]->nc.peer && [[s]]->nc.peer->info->link_status_changed) { [[s]]->nc.peer->info->link_status_changed([[s]]->nc.peer); } }

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *[[σ]], bool link_down) { [[σ]]->nc.link_down = link_down; if ([[σ]]->nc.peer) { [[σ]]->nc.peer->link_down = link_down; } if ([[σ]]->nc.info->link_status_changed) { [[σ]]->nc.info->link_status_changed(&[[σ]]->nc); } if ([[σ]]->nc.peer && [[σ]]->nc.peer->info->link_status_changed) { [[σ]]->nc.peer->info->link_status_changed([[σ]]->nc.peer); } }
--------------------------------------------- Result 19 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx, CodedBitstreamUnit *unit) { BitstreamContext bc; int err; err = bitstream_init(&bc, unit->data, 8 * unit->data_size); if (err < 0) return err; switch (unit->type) { case HEVC_NAL_VPS: { H265RawVPS *vps; vps = av_mallocz(sizeof(*vps)); if (!vps) return AVERROR(ENOMEM); err = cbs_h265_read_vps(ctx, &bc, vps); if (err >= 0) err = cbs_h265_replace_vps(ctx, vps); if (err < 0) { av_free(vps); return err; } unit->content = vps; } break; case HEVC_NAL_SPS: { H265RawSPS *sps; sps = av_mallocz(sizeof(*sps)); if (!sps) return AVERROR(ENOMEM); err = cbs_h265_read_sps(ctx, &bc, sps); if (err >= 0) err = cbs_h265_replace_sps(ctx, sps); if (err < 0) { av_free(sps); return err; } unit->content = sps; } break; case HEVC_NAL_PPS: { H265RawPPS *pps; pps = av_mallocz(sizeof(*pps)); if (!pps) return AVERROR(ENOMEM); err = cbs_h265_read_pps(ctx, &bc, pps); if (err >= 0) err = cbs_h265_replace_pps(ctx, pps); if (err < 0) { av_free(pps); return err; } unit->content = pps; } break; case HEVC_NAL_TRAIL_N: case HEVC_NAL_TRAIL_R: case HEVC_NAL_TSA_N: case HEVC_NAL_TSA_R: case HEVC_NAL_STSA_N: case HEVC_NAL_STSA_R: case HEVC_NAL_RADL_N: case HEVC_NAL_RADL_R: case HEVC_NAL_RASL_N: case HEVC_NAL_RASL_R: case HEVC_NAL_BLA_W_LP: case HEVC_NAL_BLA_W_RADL: case HEVC_NAL_BLA_N_LP: case HEVC_NAL_IDR_W_RADL: case HEVC_NAL_IDR_N_LP: case HEVC_NAL_CRA_NUT: { H265RawSlice *slice; int pos, len; slice = av_mallocz(sizeof(*slice)); if (!slice) return AVERROR(ENOMEM); err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header); if (err < 0) { av_free(slice); return err; } pos = bitstream_tell(&bc); len = unit->data_size; if (!unit->data[len - 1]) { int z; for (z = 0; z < len && !unit->data[len - z - 1]; z++); av_log(ctx->log_ctx, AV_LOG_DEBUG, "Deleted %d trailing zeroes " "from slice data.\n", z); len -= z; } slice->data_size = len - pos / 8; slice->data = av_malloc(slice->data_size); if (!slice->data) { av_free(slice); return AVERROR(ENOMEM); } memcpy(slice->data, unit->data + pos / 8, slice->data_size); slice->data_bit_start = pos % 8; unit->content = slice; } break; case HEVC_NAL_AUD: { H265RawAUD *aud; aud = av_mallocz(sizeof(*aud)); if (!aud) return AVERROR(ENOMEM); err = cbs_h265_read_aud(ctx, &bc, aud); if (err < 0) { av_free(aud); return err; } unit->content = aud; } break; default: return AVERROR(ENOSYS); } return 0; }
--------------------------------------------- Result 20 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qpa_audio_fini (void *opaque) { (void) opaque; }
--------------------------------------------- Result 21 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: START_TEST(qint_get_int_test) { QInt *[[qi]]; const int [[value]] = 123456; [[qi]] = qint_from_int([[value]]); fail_unless(qint_get_int([[qi]]) == [[value]]); QDECREF([[qi]]); }

[[[[Adv]]]]: START_TEST(qint_get_int_test) { QInt *[[wax]]; const int [[zero]] = 123456; [[wax]] = qint_from_int([[zero]]); fail_unless(qint_get_int([[wax]]) == [[zero]]); QDECREF([[wax]]); }
--------------------------------------------- Result 22 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int hevc_init_context(AVCodecContext *avctx) { HEVCContext *s = avctx->priv_data; int i; s->avctx = avctx; s->HEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (!s->HEVClc) goto fail; s->HEVClcList[0] = s->HEVClc; s->sList[0] = s; s->cabac_state = av_malloc(HEVC_CONTEXTS); if (!s->cabac_state) goto fail; s->output_frame = av_frame_alloc(); if (!s->output_frame) goto fail; for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) { s->DPB[i].frame = av_frame_alloc(); if (!s->DPB[i].frame) goto fail; s->DPB[i].tf.f = s->DPB[i].frame; } s->max_ra = INT_MAX; s->md5_ctx = av_md5_alloc(); if (!s->md5_ctx) goto fail; ff_bswapdsp_init(&s->bdsp); s->context_initialized = 1; s->eos = 0; return 0; fail: hevc_decode_free(avctx); return AVERROR(ENOMEM); }
--------------------------------------------- Result 23 ---------------------------------------------
[[0 (55%)]] --> [[0 (28%)]] --> Socre: 0.7234247028827667

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *[[avctx]], PNGDecContext *s, uint32_t length) { int n, i, r, g, b; if ((length % 3) != 0 || length > 256 * 3) return AVERROR_INVALIDDATA; n = length / 3; for (i = 0; i < n; i++) { r = bytestream2_get_byte(&s->gb); g = bytestream2_get_byte(&s->gb); b = bytestream2_get_byte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNG_PLTE; bytestream2_skip(&s->gb, 4); return 0; }

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *[[albator]], PNGDecContext *s, uint32_t length) { int n, i, r, g, b; if ((length % 3) != 0 || length > 256 * 3) return AVERROR_INVALIDDATA; n = length / 3; for (i = 0; i < n; i++) { r = bytestream2_get_byte(&s->gb); g = bytestream2_get_byte(&s->gb); b = bytestream2_get_byte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNG_PLTE; bytestream2_skip(&s->gb, 4); return 0; }
--------------------------------------------- Result 24 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr, uint64_t value, unsigned size, MemTxAttrs attrs) { int ret = 0; MSIMessage from = {0}, to = {0}; from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST; from.data = (uint32_t) value; ret = vtd_interrupt_remap_msi(opaque, &from, &to); if (ret) { VTD_DPRINTF(GENERAL, "int remap fail for addr 0x%"PRIx64 " data 0x%"PRIx32, from.address, from.data); return MEMTX_ERROR; } VTD_DPRINTF(IR, "delivering MSI 0x%"PRIx64":0x%"PRIx32 " for device sid 0x%04x", to.address, to.data, sid); if (dma_memory_write(&address_space_memory, to.address, &to.data, size)) { VTD_DPRINTF(GENERAL, "error: fail to write 0x%"PRIx64 " value 0x%"PRIx32, to.address, to.data); } return MEMTX_OK; }
--------------------------------------------- Result 25 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 3 / 11 / 25:   1%|          | 25/2690 [03:03<5:25:17,  7.32s/it][Succeeded / Failed / Skipped / Total] 11 / 3 / 11 / 25:   1%|          | 26/2690 [03:03<5:13:31,  7.06s/it][Succeeded / Failed / Skipped / Total] 11 / 3 / 12 / 26:   1%|          | 26/2690 [03:03<5:13:31,  7.06s/it][Succeeded / Failed / Skipped / Total] 11 / 3 / 12 / 26:   1%|          | 27/2690 [03:37<5:58:08,  8.07s/it][Succeeded / Failed / Skipped / Total] 12 / 3 / 12 / 27:   1%|          | 27/2690 [03:37<5:58:09,  8.07s/it][Succeeded / Failed / Skipped / Total] 12 / 3 / 12 / 27:   1%|          | 28/2690 [03:40<5:50:00,  7.89s/it][Succeeded / Failed / Skipped / Total] 12 / 4 / 12 / 28:   1%|          | 28/2690 [03:40<5:50:01,  7.89s/it][Succeeded / Failed / Skipped / Total] 12 / 4 / 12 / 28:   1%|          | 29/2690 [04:13<6:28:00,  8.75s/it][[0 (43%)]] --> [[0 (80%)]] --> Socre: 0.8025290369987488

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf, char **serial) { VirtIOBlock *s; int cylinders, heads, secs; static int [[virtio_blk_id]]; DriveInfo *dinfo; if (!conf->bs) { error_report("virtio-blk-pci: drive property not set"); return NULL; } if (!bdrv_is_inserted(conf->bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!*serial) { dinfo = drive_get_by_blockdev(conf->bs); if (*dinfo->serial) { *serial = strdup(dinfo->serial); } } s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); s->vdev.get_config = virtio_blk_update_config; s->vdev.get_features = virtio_blk_get_features; s->vdev.reset = virtio_blk_reset; s->bs = conf->bs; s->conf = conf; s->serial = *serial; s->rq = NULL; s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs); s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s); s->qdev = dev; register_savevm(dev, "virtio-blk", [[virtio_blk_id]]++, 2, virtio_blk_save, virtio_blk_load, s); bdrv_set_dev_ops(s->bs, &virtio_block_ops, s); bdrv_set_buffer_alignment(s->bs, conf->logical_block_size); bdrv_iostatus_enable(s->bs); add_boot_device_path(conf->bootindex, dev, "/disk@0,0"); return &s->vdev; }

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf, char **serial) { VirtIOBlock *s; int cylinders, heads, secs; static int [[virripo2بlosbig3d]]; DriveInfo *dinfo; if (!conf->bs) { error_report("virtio-blk-pci: drive property not set"); return NULL; } if (!bdrv_is_inserted(conf->bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!*serial) { dinfo = drive_get_by_blockdev(conf->bs); if (*dinfo->serial) { *serial = strdup(dinfo->serial); } } s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); s->vdev.get_config = virtio_blk_update_config; s->vdev.get_features = virtio_blk_get_features; s->vdev.reset = virtio_blk_reset; s->bs = conf->bs; s->conf = conf; s->serial = *serial; s->rq = NULL; s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs); s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s); s->qdev = dev; register_savevm(dev, "virtio-blk", [[virripo2بlosbig3d]]++, 2, virtio_blk_save, virtio_blk_load, s); bdrv_set_dev_ops(s->bs, &virtio_block_ops, s); bdrv_set_buffer_alignment(s->bs, conf->logical_block_size); bdrv_iostatus_enable(s->bs); add_boot_device_path(conf->bootindex, dev, "/disk@0,0"); return &s->vdev; }
--------------------------------------------- Result 26 ---------------------------------------------
[[0 (46%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static size_t header_ext_add(char *buf, uint32_t magic, const void *s, size_t len, size_t buflen) { QCowExtension *ext_backing_fmt = (QCowExtension*) buf; size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7); if (buflen < ext_len) { return -ENOSPC; } *ext_backing_fmt = (QCowExtension) { .magic = cpu_to_be32(magic), .len = cpu_to_be32(len), }; memcpy(buf + sizeof(QCowExtension), s, len); return ext_len; }
--------------------------------------------- Result 27 ---------------------------------------------
[[0 (75%)]] --> [[0 (44%)]] --> Socre: 0.5582025349140167

[[[[Adv]]]]: static void usbredir_bulk_packet(void *priv, uint32_t [[id]], struct usb_redir_bulk_packet_header *[[bulk_packet]], uint8_t *data, int [[data_len]]) { USBRedirDevice *dev = priv; uint8_t ep = [[bulk_packet]]->endpoint; int [[len]] = [[bulk_packet]]->length; AsyncURB *[[aurb]]; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", [[bulk_packet]]->status, ep, [[len]], [[id]]); [[aurb]] = async_find(dev, [[id]]); if (![[aurb]]) { free(data); return; } if ([[aurb]]->bulk_packet.endpoint != [[bulk_packet]]->endpoint || [[aurb]]->bulk_packet.stream_id != [[bulk_packet]]->stream_id) { ERROR("return bulk packet mismatch, please report this!\n"); [[len]] = USB_RET_NAK; } if ([[aurb]]->packet) { [[len]] = usbredir_handle_status(dev, [[bulk_packet]]->status, [[len]]); if ([[len]] > 0) { usbredir_log_data(dev, "bulk data in:", data, [[data_len]]); if ([[data_len]] <= [[aurb]]->packet->len) { memcpy([[aurb]]->packet->data, data, [[data_len]]); } else { ERROR("bulk buffer too small (%d > %d)\n", [[data_len]], [[aurb]]->packet->len); [[len]] = USB_RET_STALL; } } [[aurb]]->packet->len = [[len]]; usb_packet_complete(&dev->dev, [[aurb]]->packet); } async_free(dev, [[aurb]]); free(data); }

[[[[Adv]]]]: static void usbredir_bulk_packet(void *priv, uint32_t [[identification]], struct usb_redir_bulk_packet_header *[[fairjavapoem]], uint8_t *data, int [[wyquadtun]]) { USBRedirDevice *dev = priv; uint8_t ep = [[fairjavapoem]]->endpoint; int [[tank]] = [[fairjavapoem]]->length; AsyncURB *[[auspt]]; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", [[fairjavapoem]]->status, ep, [[tank]], [[identification]]); [[auspt]] = async_find(dev, [[identification]]); if (![[auspt]]) { free(data); return; } if ([[auspt]]->bulk_packet.endpoint != [[fairjavapoem]]->endpoint || [[auspt]]->bulk_packet.stream_id != [[fairjavapoem]]->stream_id) { ERROR("return bulk packet mismatch, please report this!\n"); [[tank]] = USB_RET_NAK; } if ([[auspt]]->packet) { [[tank]] = usbredir_handle_status(dev, [[fairjavapoem]]->status, [[tank]]); if ([[tank]] > 0) { usbredir_log_data(dev, "bulk data in:", data, [[wyquadtun]]); if ([[wyquadtun]] <= [[auspt]]->packet->len) { memcpy([[auspt]]->packet->data, data, [[wyquadtun]]); } else { ERROR("bulk buffer too small (%d > %d)\n", [[wyquadtun]], [[auspt]]->packet->len); [[tank]] = USB_RET_STALL; } } [[auspt]]->packet->len = [[tank]]; usb_packet_complete(&dev->dev, [[auspt]]->packet); } async_free(dev, [[auspt]]); free(data); }
--------------------------------------------- Result 28 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int read_code_table(CLLCContext *[[ctx]], GetBitContext *[[gb]], VLC *vlc) { uint8_t [[symbols]][256]; uint8_t [[bits]][256]; uint16_t codes[256]; int [[num_lens]], num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; [[num_lens]] = get_bits([[gb]], 5); for (i = 0; i < [[num_lens]]; i++) { num_codes = get_bits([[gb]], 9); num_codes_sum += num_codes; if (num_codes_sum > 256) { av_log([[ctx]]->avctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j < num_codes; j++) { [[symbols]][count] = get_bits([[gb]], 8); [[bits]][count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ff_init_vlc_sparse(vlc, VLC_BITS, count, [[bits]], 1, 1, codes, 2, 2, [[symbols]], 1, 1, 0);

[[[[Adv]]]]: static int read_code_table(CLLCContext *[[linerc]], GetBitContext *[[park]], VLC *vlc) { uint8_t [[products]][256]; uint8_t [[codes]][256]; uint16_t codes[256]; int [[のf_town]], num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; [[のf_town]] = get_bits([[park]], 5); for (i = 0; i < [[のf_town]]; i++) { num_codes = get_bits([[park]], 9); num_codes_sum += num_codes; if (num_codes_sum > 256) { av_log([[linerc]]->avctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j < num_codes; j++) { [[products]][count] = get_bits([[park]], 8); [[codes]][count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ff_init_vlc_sparse(vlc, VLC_BITS, count, [[codes]], 1, 1, codes, 2, 2, [[products]], 1, 1, 0);
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 5 / 12 / 29:   1%|          | 29/2690 [04:13<6:28:00,  8.75s/it][Succeeded / Failed / Skipped / Total] 12 / 5 / 12 / 29:   1%|          | 30/2690 [04:14<6:15:44,  8.48s/it][Succeeded / Failed / Skipped / Total] 12 / 5 / 13 / 30:   1%|          | 30/2690 [04:14<6:15:44,  8.48s/it][Succeeded / Failed / Skipped / Total] 12 / 5 / 13 / 30:   1%|          | 31/2690 [04:15<6:05:24,  8.25s/it][Succeeded / Failed / Skipped / Total] 13 / 5 / 13 / 31:   1%|          | 31/2690 [04:15<6:05:24,  8.25s/it][Succeeded / Failed / Skipped / Total] 13 / 5 / 13 / 31:   1%|          | 32/2690 [04:34<6:19:51,  8.57s/it][Succeeded / Failed / Skipped / Total] 14 / 5 / 13 / 32:   1%|          | 32/2690 [04:34<6:19:51,  8.57s/it][Succeeded / Failed / Skipped / Total] 14 / 5 / 13 / 32:   1%|          | 33/2690 [04:42<6:19:41,  8.57s/it][[0 (88%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int mov_read_strf(MOVContext *[[c]], AVIOContext *[[pb]], MOVAtom [[atom]]) { AVStream *[[st]]; if ([[c]]->fc->nb_streams < 1) return 0; if ([[atom]].size <= 40) return 0; [[st]] = [[c]]->fc->streams[[[c]]->fc->nb_streams-1]; if ((uint64_t)[[atom]].size > (1<<30)) return AVERROR_INVALIDDATA; av_free([[st]]->codec->extradata); [[st]]->codec->extradata = av_mallocz([[atom]].size - 40 + FF_INPUT_BUFFER_PADDING_SIZE); if (![[st]]->codec->extradata) return AVERROR(ENOMEM); [[st]]->codec->extradata_size = [[atom]].size - 40; avio_skip([[pb]], 40); avio_read([[pb]], [[st]]->codec->extradata, [[atom]].size - 40); return 0; }

[[[[Adv]]]]: static int mov_read_strf(MOVContext *[[data]], AVIOContext *[[apj]], MOVAtom [[experiment]]) { AVStream *[[such]]; if ([[data]]->fc->nb_streams < 1) return 0; if ([[experiment]].size <= 40) return 0; [[such]] = [[data]]->fc->streams[[[data]]->fc->nb_streams-1]; if ((uint64_t)[[experiment]].size > (1<<30)) return AVERROR_INVALIDDATA; av_free([[such]]->codec->extradata); [[such]]->codec->extradata = av_mallocz([[experiment]].size - 40 + FF_INPUT_BUFFER_PADDING_SIZE); if (![[such]]->codec->extradata) return AVERROR(ENOMEM); [[such]]->codec->extradata_size = [[experiment]].size - 40; avio_skip([[apj]], 40); avio_read([[apj]], [[such]]->codec->extradata, [[experiment]].size - 40); return 0; }
--------------------------------------------- Result 30 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int net_init_tap(const Netdev *netdev, const char *name, NetClientState *peer, Error **errp) { const NetdevTapOptions *tap; int fd, vnet_hdr = 0, i = 0, queues; const char *script = NULL; const char *downscript = NULL; Error *err = NULL; const char *vhostfdname; char ifname[128]; assert(netdev->type == NET_CLIENT_DRIVER_TAP); tap = &netdev->u.tap; queues = tap->has_queues ? tap->queues : 1; vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL; if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) { error_setg(errp, "Multiqueue tap cannot be used with QEMU vlans"); return -1; } if (tap->has_fd) { if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_helper || tap->has_queues || tap->has_fds || tap->has_vhostfds) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, fds=, and vhostfds= " "are invalid with fd="); return -1; } fd = monitor_fd_param(cur_mon, tap->fd, &err); if (fd == -1) { error_propagate(errp, err); return -1; } fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "tap", name, NULL, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); return -1; } } else if (tap->has_fds) { char **fds = g_new0(char *, MAX_TAP_QUEUES); char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES); int nfds, nvhosts; if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_helper || tap->has_queues || tap->has_vhostfd) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, and vhostfd= " "are invalid with fds="); return -1; } nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES); if (tap->has_vhostfds) { nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES); if (nfds != nvhosts) { error_setg(errp, "The number of fds passed does not match " "the number of vhostfds passed"); goto free_fail; } } for (i = 0; i < nfds; i++) { fd = monitor_fd_param(cur_mon, fds[i], &err); if (fd == -1) { error_propagate(errp, err); goto free_fail; } fcntl(fd, F_SETFL, O_NONBLOCK); if (i == 0) { vnet_hdr = tap_probe_vnet_hdr(fd); } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) { error_setg(errp, "vnet_hdr not consistent across given tap fds"); goto free_fail; } net_init_tap_one(tap, peer, "tap", name, ifname, script, downscript, tap->has_vhostfds ? vhost_fds[i] : NULL, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); goto free_fail; } } g_free(fds); g_free(vhost_fds); return 0; free_fail: for (i = 0; i < nfds; i++) { g_free(fds[i]); g_free(vhost_fds[i]); } g_free(fds); g_free(vhost_fds); return -1; } else if (tap->has_helper) { if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "queues=, and vhostfds= are invalid with helper="); return -1; } fd = net_bridge_run_helper(tap->helper, tap->has_br ? tap->br : DEFAULT_BRIDGE_INTERFACE, errp); if (fd == -1) { return -1; } fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "bridge", name, ifname, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); close(fd); return -1; } } else { if (tap->has_vhostfds) { error_setg(errp, "vhostfds= is invalid if fds= wasn't specified"); return -1; } script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT; downscript = tap->has_downscript ? tap->downscript : DEFAULT_NETWORK_DOWN_SCRIPT; if (tap->has_ifname) { pstrcpy(ifname, sizeof ifname, tap->ifname); } else { ifname[0] = '\0'; } for (i = 0; i < queues; i++) { fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script, ifname, sizeof ifname, queues > 1, errp); if (fd == -1) { return -1; } if (queues > 1 && i == 0 && !tap->has_ifname) { if (tap_fd_get_ifname(fd, ifname)) { error_setg(errp, "Fail to get ifname"); close(fd); return -1; } } net_init_tap_one(tap, peer, "tap", name, ifname, i >= 1 ? "no" : script, i >= 1 ? "no" : downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); close(fd); return -1; } } } return 0; }
--------------------------------------------- Result 31 ---------------------------------------------
[[0 (4%)]] --> [[0 (53%)]] --> Socre: 0.5340818762779236

[[[[Adv]]]]: static void mem_begin(MemoryListener *[[listener]]) { AddressSpaceDispatch *[[d]] = container_of([[listener]], AddressSpaceDispatch, [[listener]]); [[d]]->phys_map.ptr = PHYS_MAP_NODE_NIL; }

[[[[Adv]]]]: static void mem_begin(MemoryListener *[[friendship]]) { AddressSpaceDispatch *[[windows]] = container_of([[friendship]], AddressSpaceDispatch, [[friendship]]); [[windows]]->phys_map.ptr = PHYS_MAP_NODE_NIL; }
--------------------------------------------- Result 32 ---------------------------------------------
[[0 (13%)]] --> [[0 (64%)]] --> Socre: 0.6405321359634399

[[[[Adv]]]]: static uint32_t tight_palette_buf2rgb(int [[bpp]], const uint8_t *[[buf]]) { uint32_t rgb = 0; if ([[bpp]] == 32) { rgb |= (([[buf]][0] & ~1) | !(([[buf]][4] >> 3) & 1)) << 24; rgb |= (([[buf]][1] & ~1) | !(([[buf]][4] >> 2) & 1)) << 16; rgb |= (([[buf]][2] & ~1) | !(([[buf]][4] >> 1) & 1)) << 8; rgb |= (([[buf]][3] & ~1) | !(([[buf]][4] >> 0) & 1)) << 0; } if ([[bpp]] == 16) { rgb |= (([[buf]][0] & ~1) | !(([[buf]][2] >> 1) & 1)) << 8; rgb |= (([[buf]][1] & ~1) | !(([[buf]][2] >> 0) & 1)) << 0; } return rgb; }

[[[[Adv]]]]: static uint32_t tight_palette_buf2rgb(int [[pb]], const uint8_t *[[betaφ]]) { uint32_t rgb = 0; if ([[pb]] == 32) { rgb |= (([[betaφ]][0] & ~1) | !(([[betaφ]][4] >> 3) & 1)) << 24; rgb |= (([[betaφ]][1] & ~1) | !(([[betaφ]][4] >> 2) & 1)) << 16; rgb |= (([[betaφ]][2] & ~1) | !(([[betaφ]][4] >> 1) & 1)) << 8; rgb |= (([[betaφ]][3] & ~1) | !(([[betaφ]][4] >> 0) & 1)) << 0; } if ([[pb]] == 16) { rgb |= (([[betaφ]][0] & ~1) | !(([[betaφ]][2] >> 1) & 1)) << 8; rgb |= (([[betaφ]][1] & ~1) | !(([[betaφ]][2] >> 0) & 1)) << 0; } return rgb; }
--------------------------------------------- Result 33 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 5 / 13 / 33:   1%|          | 33/2690 [04:42<6:19:41,  8.57s/it][Succeeded / Failed / Skipped / Total] 15 / 5 / 13 / 33:   1%|▏         | 34/2690 [04:43<6:08:59,  8.34s/it][Succeeded / Failed / Skipped / Total] 15 / 5 / 14 / 34:   1%|▏         | 34/2690 [04:43<6:08:59,  8.34s/it][Succeeded / Failed / Skipped / Total] 15 / 5 / 14 / 34:   1%|▏         | 35/2690 [04:48<6:04:32,  8.24s/it][Succeeded / Failed / Skipped / Total] 16 / 5 / 14 / 35:   1%|▏         | 35/2690 [04:48<6:04:32,  8.24s/it][Succeeded / Failed / Skipped / Total] 16 / 5 / 14 / 35:   1%|▏         | 36/2690 [04:58<6:06:35,  8.29s/it][Succeeded / Failed / Skipped / Total] 17 / 5 / 14 / 36:   1%|▏         | 36/2690 [04:58<6:06:35,  8.29s/it][Succeeded / Failed / Skipped / Total] 17 / 5 / 14 / 36:   1%|▏         | 37/2690 [05:18<6:20:48,  8.61s/it][Succeeded / Failed / Skipped / Total] 18 / 5 / 14 / 37:   1%|▏         | 37/2690 [05:18<6:20:48,  8.61s/it][Succeeded / Failed / Skipped / Total] 18 / 5 / 14 / 37:   1%|▏         | 38/2690 [05:33<6:27:24,  8.77s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 14 / 38:   1%|▏         | 38/2690 [05:33<6:27:25,  8.77s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 14 / 38:   1%|▏         | 39/2690 [05:33<6:17:54,  8.55s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 15 / 39:   1%|▏         | 39/2690 [05:33<6:17:54,  8.55s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 15 / 39:   1%|▏         | 40/2690 [05:34<6:08:50,  8.35s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 16 / 40:   1%|▏         | 40/2690 [05:34<6:08:50,  8.35s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 16 / 40:   2%|▏         | 41/2690 [05:46<6:13:19,  8.46s/it][[0 (54%)]] --> [[0 (48%)]] --> Socre: 0.5203072428703308

[[[[Adv]]]]: void stream_start(const char *job_id, BlockDriverState *bs, BlockDriverState *[[base]], const char *backing_file_str, int64_t speed, BlockdevOnError on_error, BlockCompletionFunc *cb, void *opaque, Error **errp) { StreamBlockJob *s; s = block_job_create(job_id, &stream_job_driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->base = [[base]]; s->backing_file_str = g_strdup(backing_file_str); s->on_error = on_error; s->common.co = qemu_coroutine_create(stream_run); trace_stream_start(bs, [[base]], s, s->common.co, opaque); qemu_coroutine_enter(s->common.co, s); }

[[[[Adv]]]]: void stream_start(const char *job_id, BlockDriverState *bs, BlockDriverState *[[terminus]], const char *backing_file_str, int64_t speed, BlockdevOnError on_error, BlockCompletionFunc *cb, void *opaque, Error **errp) { StreamBlockJob *s; s = block_job_create(job_id, &stream_job_driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->base = [[terminus]]; s->backing_file_str = g_strdup(backing_file_str); s->on_error = on_error; s->common.co = qemu_coroutine_create(stream_run); trace_stream_start(bs, [[terminus]], s, s->common.co, opaque); qemu_coroutine_enter(s->common.co, s); }
--------------------------------------------- Result 34 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave) { s->codec = slave; slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0]; slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0]; }
--------------------------------------------- Result 35 ---------------------------------------------
[[0 (56%)]] --> [[0 (38%)]] --> Socre: 0.6237828135490417

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *[[got_picture_ptr]], AVPacket *[[avpkt]]) { int ret; *[[got_picture_ptr]] = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = [[avpkt]]; apply_param_change(avctx, [[avpkt]]); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || [[avpkt]]->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, [[got_picture_ptr]], [[avpkt]]); else { ret = avctx->codec->decode(avctx, picture, [[got_picture_ptr]], [[avpkt]]); picture->pkt_dts = [[avpkt]]->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*[[got_picture_ptr]]) avctx->frame_number++; } else ret = 0; picture->extended_data = picture->data; return ret; }

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *[[said2house16lart]], AVPacket *[[vppark]]) { int ret; *[[said2house16lart]] = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = [[vppark]]; apply_param_change(avctx, [[vppark]]); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || [[vppark]]->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, [[said2house16lart]], [[vppark]]); else { ret = avctx->codec->decode(avctx, picture, [[said2house16lart]], [[vppark]]); picture->pkt_dts = [[vppark]]->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*[[said2house16lart]]) avctx->frame_number++; } else ret = 0; picture->extended_data = picture->data; return ret; }
--------------------------------------------- Result 36 ---------------------------------------------
[[0 (1%)]] --> [[0 (98%)]] --> Socre: 0.9800449013710022

[[[[Adv]]]]: int floatx80_eq(floatx80 [[a]], floatx80 b, float_status *status) { if ( ( ( extractFloatx80Exp( [[a]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[a]] )<<1 ) ) || ( ( extractFloatx80Exp( b ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( b )<<1 ) ) ) { float_raise(float_flag_invalid, status); return 0; } return ( [[a]].low == b.low ) && ( ( [[a]].high == b.high ) || ( ( [[a]].low == 0 ) && ( (uint16_t) ( ( [[a]].high | b.high )<<1 ) == 0 ) ) ); }

[[[[Adv]]]]: int floatx80_eq(floatx80 [[а]], floatx80 b, float_status *status) { if ( ( ( extractFloatx80Exp( [[а]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[а]] )<<1 ) ) || ( ( extractFloatx80Exp( b ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( b )<<1 ) ) ) { float_raise(float_flag_invalid, status); return 0; } return ( [[а]].low == b.low ) && ( ( [[а]].high == b.high ) || ( ( [[а]].low == 0 ) && ( (uint16_t) ( ( [[а]].high | b.high )<<1 ) == 0 ) ) ); }
--------------------------------------------- Result 37 ---------------------------------------------
[[0 (79%)]] --> [[0 (47%)]] --> Socre: 0.5321672558784485

[[[[Adv]]]]: static int omap_gpio_init(SysBusDevice *[[sbd]]) { DeviceState *[[dev]] = DEVICE([[sbd]]); struct omap_gpif_s *s = OMAP1_GPIO([[dev]]); if (!s->clk) { hw_error("omap-gpio: clk not connected\n"); } qdev_init_gpio_in([[dev]], omap_gpio_set, 16); qdev_init_gpio_out([[dev]], s->omap1.handler, 16); sysbus_init_irq([[sbd]], &s->omap1.irq); memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1, "omap.gpio", 0x1000); sysbus_init_mmio([[sbd]], &s->iomem); return 0; }

[[[[Adv]]]]: static int omap_gpio_init(SysBusDevice *[[f0]]) { DeviceState *[[park]] = DEVICE([[f0]]); struct omap_gpif_s *s = OMAP1_GPIO([[park]]); if (!s->clk) { hw_error("omap-gpio: clk not connected\n"); } qdev_init_gpio_in([[park]], omap_gpio_set, 16); qdev_init_gpio_out([[park]], s->omap1.handler, 16); sysbus_init_irq([[f0]], &s->omap1.irq); memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1, "omap.gpio", 0x1000); sysbus_init_mmio([[f0]], &s->iomem); return 0; }
--------------------------------------------- Result 38 ---------------------------------------------
[[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void json_lexer_init(JSONLexer *[[lexer]], JSONLexerEmitter [[func]]) { [[lexer]]->emit = [[func]]; [[lexer]]->state = IN_START; [[lexer]]->token = qstring_new(); [[lexer]]->x = [[lexer]]->y = 0; }

[[[[Adv]]]]: void json_lexer_init(JSONLexer *[[zoomers]], JSONLexerEmitter [[comenc]]) { [[zoomers]]->emit = [[comenc]]; [[zoomers]]->state = IN_START; [[zoomers]]->token = qstring_new(); [[zoomers]]->x = [[zoomers]]->y = 0; }
--------------------------------------------- Result 39 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_alloc_entries(AVCodecContext *avctx, int count) { int i; if (avctx->active_thread_type & FF_THREAD_SLICE) { SliceThreadContext *p = avctx->internal->thread_ctx; p->thread_count = avctx->thread_count; p->entries = av_mallocz_array(count, sizeof(int)); if (!p->entries) { return AVERROR(ENOMEM); } p->entries_count = count; p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t)); p->progress_cond = av_malloc_array(p->thread_count, sizeof(pthread_cond_t)); for (i = 0; i < p->thread_count; i++) { pthread_mutex_init(&p->progress_mutex[i], NULL); pthread_cond_init(&p->progress_cond[i], NULL); } } return 0; }
--------------------------------------------- Result 40 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int floppy_probe_device(const char *filename) { int fd, ret; int prio = 0; struct floppy_struct fdparam; struct stat st; if (strstart(filename, "/dev/fd", NULL) && !strstart(filename, "/dev/fdset/", NULL)) { prio = 50; } fd = qemu_open(filename, O_RDONLY | O_NONBLOCK); if (fd < 0) { goto out; } ret = fstat(fd, &st); if (ret == -1 || !S_ISBLK(st.st_mode)) { goto outc; } ret = ioctl(fd, FDGETPRM, &fdparam); if (ret >= 0) prio = 100; outc: qemu_close(fd); out: return prio; }
[Succeeded / Failed / Skipped / Total] 19 / 6 / 16 / 41:   2%|▏         | 41/2690 [05:46<6:13:19,  8.46s/it][Succeeded / Failed / Skipped / Total] 19 / 6 / 16 / 41:   2%|▏         | 42/2690 [06:09<6:28:14,  8.80s/it][Succeeded / Failed / Skipped / Total] 20 / 6 / 16 / 42:   2%|▏         | 42/2690 [06:09<6:28:14,  8.80s/it][Succeeded / Failed / Skipped / Total] 20 / 6 / 16 / 42:   2%|▏         | 43/2690 [06:11<6:21:19,  8.64s/it][Succeeded / Failed / Skipped / Total] 21 / 6 / 16 / 43:   2%|▏         | 43/2690 [06:11<6:21:19,  8.64s/it][Succeeded / Failed / Skipped / Total] 21 / 6 / 16 / 43:   2%|▏         | 44/2690 [06:12<6:13:01,  8.46s/it][Succeeded / Failed / Skipped / Total] 21 / 6 / 17 / 44:   2%|▏         | 44/2690 [06:12<6:13:01,  8.46s/it][Succeeded / Failed / Skipped / Total] 21 / 6 / 17 / 44:   2%|▏         | 45/2690 [06:14<6:07:20,  8.33s/it]--------------------------------------------- Result 41 ---------------------------------------------
[[0 (55%)]] --> [[0 (45%)]] --> Socre: 0.5544441640377045

[[[[Adv]]]]: static int crypto_open(URLContext *h, const char *[[uri]], int flags) { const char *nested_url; int ret; CryptoContext *c = h->priv_data; if (!av_strstart([[uri]], "crypto+", &nested_url) && !av_strstart([[uri]], "crypto:", &nested_url)) { av_log(h, AV_LOG_ERROR, "Unsupported url %s\n", [[uri]]); ret = AVERROR(EINVAL); goto err; } if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) { av_log(h, AV_LOG_ERROR, "Key or IV not set\n"); ret = AVERROR(EINVAL); goto err; } if (flags & AVIO_FLAG_WRITE) { av_log(h, AV_LOG_ERROR, "Only decryption is supported currently\n"); ret = AVERROR(ENOSYS); goto err; } if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) { av_log(h, AV_LOG_ERROR, "Unable to open input\n"); goto err; } c->aes = av_mallocz(av_aes_size); if (!c->aes) { ret = AVERROR(ENOMEM); goto err; } av_aes_init(c->aes, c->key, 128, 1); h->is_streamed = 1; return 0; err: av_free(c->key); av_free(c->iv); return ret; }

[[[[Adv]]]]: static int crypto_open(URLContext *h, const char *[[terml]], int flags) { const char *nested_url; int ret; CryptoContext *c = h->priv_data; if (!av_strstart([[terml]], "crypto+", &nested_url) && !av_strstart([[terml]], "crypto:", &nested_url)) { av_log(h, AV_LOG_ERROR, "Unsupported url %s\n", [[terml]]); ret = AVERROR(EINVAL); goto err; } if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) { av_log(h, AV_LOG_ERROR, "Key or IV not set\n"); ret = AVERROR(EINVAL); goto err; } if (flags & AVIO_FLAG_WRITE) { av_log(h, AV_LOG_ERROR, "Only decryption is supported currently\n"); ret = AVERROR(ENOSYS); goto err; } if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) { av_log(h, AV_LOG_ERROR, "Unable to open input\n"); goto err; } c->aes = av_mallocz(av_aes_size); if (!c->aes) { ret = AVERROR(ENOMEM); goto err; } av_aes_init(c->aes, c->key, 128, 1); h->is_streamed = 1; return 0; err: av_free(c->key); av_free(c->iv); return ret; }
--------------------------------------------- Result 42 ---------------------------------------------
[[0 (26%)]] --> [[0 (99%)]] --> Socre: 0.9883231520652771

[[[[Adv]]]]: static void fpu_init (CPUMIPSState *env, const mips_def_t *def) { int [[i]]; for ([[i]] = 0; [[i]] < MIPS_FPU_MAX; [[i]]++) env->fpus[[[i]]].fcr0 = def->CP1_fcr0; memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu)); if (env->user_mode_only) { if (env->CP0_Config1 & (1 << CP0C1_FP)) env->hflags |= MIPS_HFLAG_FPU; #ifdef TARGET_MIPS64 if (env->active_fpu.fcr0 & (1 << FCR0_F64)) env->hflags |= MIPS_HFLAG_F64; #endif } }

[[[[Adv]]]]: static void fpu_init (CPUMIPSState *env, const mips_def_t *def) { int [[и]]; for ([[и]] = 0; [[и]] < MIPS_FPU_MAX; [[и]]++) env->fpus[[[и]]].fcr0 = def->CP1_fcr0; memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu)); if (env->user_mode_only) { if (env->CP0_Config1 & (1 << CP0C1_FP)) env->hflags |= MIPS_HFLAG_FPU; #ifdef TARGET_MIPS64 if (env->active_fpu.fcr0 & (1 << FCR0_F64)) env->hflags |= MIPS_HFLAG_F64; #endif } }
--------------------------------------------- Result 43 ---------------------------------------------
[[0 (9%)]] --> [[0 (54%)]] --> Socre: 0.5430282950401306

[[[[Adv]]]]: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd, int64_t [[sector_num]], QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *[[opaque]], int [[type]]) { struct qemu_paiocb *[[acb]]; [[acb]] = qemu_aio_get(&raw_aio_pool, bs, cb, [[opaque]]); if (![[acb]]) return NULL; [[acb]]->aio_type = [[type]]; [[acb]]->aio_fildes = fd; [[acb]]->ev_signo = SIGUSR2; [[acb]]->async_context_id = get_async_context_id(); if (qiov) { [[acb]]->aio_iov = qiov->iov; [[acb]]->aio_niov = qiov->niov; } [[acb]]->aio_nbytes = nb_sectors * 512; [[acb]]->aio_offset = [[sector_num]] * 512; [[acb]]->next = posix_aio_state->first_aio; posix_aio_state->first_aio = [[acb]]; trace_paio_submit([[acb]], [[opaque]], [[sector_num]], nb_sectors, [[type]]); qemu_paio_submit([[acb]]); return &[[acb]]->common; }

[[[[Adv]]]]: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd, int64_t [[4bigtransv]], QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *[[outsider]], int [[exception]]) { struct qemu_paiocb *[[cav]]; [[cav]] = qemu_aio_get(&raw_aio_pool, bs, cb, [[outsider]]); if (![[cav]]) return NULL; [[cav]]->aio_type = [[exception]]; [[cav]]->aio_fildes = fd; [[cav]]->ev_signo = SIGUSR2; [[cav]]->async_context_id = get_async_context_id(); if (qiov) { [[cav]]->aio_iov = qiov->iov; [[cav]]->aio_niov = qiov->niov; } [[cav]]->aio_nbytes = nb_sectors * 512; [[cav]]->aio_offset = [[4bigtransv]] * 512; [[cav]]->next = posix_aio_state->first_aio; posix_aio_state->first_aio = [[cav]]; trace_paio_submit([[cav]], [[outsider]], [[4bigtransv]], nb_sectors, [[exception]]); qemu_paio_submit([[cav]]); return &[[cav]]->common; }
--------------------------------------------- Result 44 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts) { ObjectClass *oc; DeviceClass *dc; const char *driver, *path, *id; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) { qerror_report(QERR_MISSING_PARAMETER, "driver"); return NULL; } oc = object_class_by_name(driver); if (!oc) { const char *typename = find_typename_by_alias(driver); if (typename) { driver = typename; oc = object_class_by_name(driver); } } if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) { qerror_report(ERROR_CLASS_GENERIC_ERROR, "'%s' is not a valid device model name", driver); return NULL; } if (object_class_is_abstract(oc)) { qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "non-abstract device type"); return NULL; } dc = DEVICE_CLASS(oc); if (dc->cannot_instantiate_with_device_add_yet) { qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "pluggable device type"); return NULL; } path = qemu_opt_get(opts, "bus"); if (path != NULL) { bus = qbus_find(path); if (!bus) { return NULL; } if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) { qerror_report(QERR_BAD_BUS_FOR_DEVICE, driver, object_get_typename(OBJECT(bus))); return NULL; } } else if (dc->bus_type != NULL) { bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type); if (!bus) { qerror_report(QERR_NO_BUS_FOR_DEVICE, dc->bus_type, driver); return NULL; } } if (qdev_hotplug && bus && !bus->allow_hotplug) { qerror_report(QERR_BUS_NO_HOTPLUG, bus->name); return NULL; } dev = DEVICE(object_new(driver)); if (bus) { qdev_set_parent_bus(dev, bus); } id = qemu_opts_id(opts); if (id) { dev->id = id; } if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) { object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; } if (dev->id) { object_property_add_child(qdev_get_peripheral(), dev->id, OBJECT(dev), NULL); } else { static int anon_count; gchar *name = g_strdup_printf("device[%d]", anon_count++); object_property_add_child(qdev_get_peripheral_anon(), name, OBJECT(dev), NULL); g_free(name); } dev->opts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) { qerror_report_err(err); error_free(err); dev->opts = NULL; object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); qerror_report(QERR_DEVICE_INIT_FAILED, driver); return NULL; } return dev; }
--------------------------------------------- Result 45 ---------------------------------------------
[[0 (20%)]] --> [[0 (52%)]] --> Socre: 0.5159154534339905

[[[[Adv]]]]: static void sun4uv_init(ram_addr_t RAM_size, const char *boot_devices, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *[[cpu_model]], const struct hwdef *hwdef) { CPUState *env; char *filename; m48t59_t *nvram; int ret, linux_boot; unsigned int i; ram_addr_t ram_offset, prom_offset; long [[initrd_size]], kernel_size; PCIBus *pci_bus, *pci_bus2, *pci_bus3; QEMUBH *bh; qemu_irq *irq; int drive_index; BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BlockDriverState *fd[MAX_FD]; void *fw_cfg; ResetData *reset_info; linux_boot = (kernel_filename != NULL); if (![[cpu_model]]) [[cpu_model]] = hwdef->default_cpu_model; env = cpu_init([[cpu_model]]); if (!env) { fprintf(stderr, "Unable to find Sparc CPU definition\n"); exit(1); } bh = qemu_bh_new(tick_irq, env); env->tick = ptimer_init(bh); ptimer_set_period(env->tick, 1ULL); bh = qemu_bh_new(stick_irq, env); env->stick = ptimer_init(bh); ptimer_set_period(env->stick, 1ULL); bh = qemu_bh_new(hstick_irq, env); env->hstick = ptimer_init(bh); ptimer_set_period(env->hstick, 1ULL); reset_info = qemu_mallocz(sizeof(ResetData)); reset_info->env = env; reset_info->reset_addr = hwdef->prom_addr + 0x40ULL; qemu_register_reset(main_cpu_reset, reset_info); main_cpu_reset(reset_info); env->pc = hwdef->prom_addr + 0x20ULL; env->npc = env->pc + 4; ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR, NULL, NULL, NULL); if (ret < 0) { ret = load_image_targphys(filename, hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK); } qemu_free(filename); } else { ret = -1; } if (ret < 0) { fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name); exit(1); } kernel_size = 0; [[initrd_size]] = 0; if (linux_boot) { kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL); if (kernel_size < 0) kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { [[initrd_size]] = load_image_targphys(initrd_filename, INITRD_LOAD_ADDR, ram_size - INITRD_LOAD_ADDR); if ([[initrd_size]] < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } if ([[initrd_size]] > 0) { for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) { if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR); stl_phys(KERNEL_LOAD_ADDR + i + 20, [[initrd_size]]); break; } } } } pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2, &pci_bus3); isa_mem_base = VGA_BASE; pci_vga_init(pci_bus, 0, 0); pci_ebus_init(pci_bus, -1); i = 0; if (hwdef->console_serial_base) { serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200, serial_hds[i], 1); i++; } for(; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { serial_init(serial_io[i], NULL , 115200, serial_hds[i]); } } for(i = 0; i < MAX_PARALLEL_PORTS; i++) { if (parallel_hds[i]) { parallel_init(parallel_io[i], NULL , parallel_hds[i]); } } for(i = 0; i < nb_nics; i++) pci_nic_init(&nd_table[i], "ne2k_pci", NULL); irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS); if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if (drive_index != -1) hd[i] = drives_table[drive_index].bdrv; else hd[i] = NULL; } pci_cmd646_ide_init(pci_bus, hd, 1); i8042_init(NULL , NULL , 0x60); for(i = 0; i < MAX_FD; i++) { drive_index = drive_get_index(IF_FLOPPY, 0, i); if (drive_index != -1) fd[i] = drives_table[drive_index].bdrv; else fd[i] = NULL; } floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd); nvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59); sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", RAM_size, boot_devices, KERNEL_LOAD_ADDR, kernel_size, kernel_cmdline, INITRD_LOAD_ADDR, [[initrd_size]], 0, graphic_width, graphic_height, graphic_depth, (uint8_t *)&nd_table[0].macaddr); fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if (kernel_cmdline) { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline); } else { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); } fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, [[initrd_size]]); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]); qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); }

[[[[Adv]]]]: static void sun4uv_init(ram_addr_t RAM_size, const char *boot_devices, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *[[dominionmusicarm]], const struct hwdef *hwdef) { CPUState *env; char *filename; m48t59_t *nvram; int ret, linux_boot; unsigned int i; ram_addr_t ram_offset, prom_offset; long [[hisiberdaredpiece]], kernel_size; PCIBus *pci_bus, *pci_bus2, *pci_bus3; QEMUBH *bh; qemu_irq *irq; int drive_index; BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BlockDriverState *fd[MAX_FD]; void *fw_cfg; ResetData *reset_info; linux_boot = (kernel_filename != NULL); if (![[dominionmusicarm]]) [[dominionmusicarm]] = hwdef->default_cpu_model; env = cpu_init([[dominionmusicarm]]); if (!env) { fprintf(stderr, "Unable to find Sparc CPU definition\n"); exit(1); } bh = qemu_bh_new(tick_irq, env); env->tick = ptimer_init(bh); ptimer_set_period(env->tick, 1ULL); bh = qemu_bh_new(stick_irq, env); env->stick = ptimer_init(bh); ptimer_set_period(env->stick, 1ULL); bh = qemu_bh_new(hstick_irq, env); env->hstick = ptimer_init(bh); ptimer_set_period(env->hstick, 1ULL); reset_info = qemu_mallocz(sizeof(ResetData)); reset_info->env = env; reset_info->reset_addr = hwdef->prom_addr + 0x40ULL; qemu_register_reset(main_cpu_reset, reset_info); main_cpu_reset(reset_info); env->pc = hwdef->prom_addr + 0x20ULL; env->npc = env->pc + 4; ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR, NULL, NULL, NULL); if (ret < 0) { ret = load_image_targphys(filename, hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK); } qemu_free(filename); } else { ret = -1; } if (ret < 0) { fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name); exit(1); } kernel_size = 0; [[hisiberdaredpiece]] = 0; if (linux_boot) { kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL); if (kernel_size < 0) kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { [[hisiberdaredpiece]] = load_image_targphys(initrd_filename, INITRD_LOAD_ADDR, ram_size - INITRD_LOAD_ADDR); if ([[hisiberdaredpiece]] < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } if ([[hisiberdaredpiece]] > 0) { for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) { if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR); stl_phys(KERNEL_LOAD_ADDR + i + 20, [[hisiberdaredpiece]]); break; } } } } pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2, &pci_bus3); isa_mem_base = VGA_BASE; pci_vga_init(pci_bus, 0, 0); pci_ebus_init(pci_bus, -1); i = 0; if (hwdef->console_serial_base) { serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200, serial_hds[i], 1); i++; } for(; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { serial_init(serial_io[i], NULL , 115200, serial_hds[i]); } } for(i = 0; i < MAX_PARALLEL_PORTS; i++) { if (parallel_hds[i]) { parallel_init(parallel_io[i], NULL , parallel_hds[i]); } } for(i = 0; i < nb_nics; i++) pci_nic_init(&nd_table[i], "ne2k_pci", NULL); irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS); if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if (drive_index != -1) hd[i] = drives_table[drive_index].bdrv; else hd[i] = NULL; } pci_cmd646_ide_init(pci_bus, hd, 1); i8042_init(NULL , NULL , 0x60); for(i = 0; i < MAX_FD; i++) { drive_index = drive_get_index(IF_FLOPPY, 0, i); if (drive_index != -1) fd[i] = drives_table[drive_index].bdrv; else fd[i] = NULL; } floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd); nvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59); sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", RAM_size, boot_devices, KERNEL_LOAD_ADDR, kernel_size, kernel_cmdline, INITRD_LOAD_ADDR, [[hisiberdaredpiece]], 0, graphic_width, graphic_height, graphic_depth, (uint8_t *)&nd_table[0].macaddr); fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if (kernel_cmdline) { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline); } else { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); } fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, [[hisiberdaredpiece]]); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]); qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); }[Succeeded / Failed / Skipped / Total] 22 / 6 / 17 / 45:   2%|▏         | 45/2690 [06:14<6:07:20,  8.33s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 17 / 45:   2%|▏         | 46/2690 [06:15<5:59:42,  8.16s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 18 / 46:   2%|▏         | 46/2690 [06:15<5:59:43,  8.16s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 18 / 46:   2%|▏         | 47/2690 [06:15<5:52:22,  8.00s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 19 / 47:   2%|▏         | 47/2690 [06:15<5:52:22,  8.00s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 19 / 47:   2%|▏         | 48/2690 [06:16<5:45:23,  7.84s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 20 / 48:   2%|▏         | 48/2690 [06:16<5:45:23,  7.84s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 20 / 48:   2%|▏         | 49/2690 [06:17<5:39:29,  7.71s/it]
--------------------------------------------- Result 46 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int cpu_exec(CPUState *cpu) { CPUClass *cc = CPU_GET_CLASS(cpu); int ret; SyncClocks sc; current_cpu = cpu; if (cpu_handle_halt(cpu)) { return EXCP_HALTED; } rcu_read_lock(); cc->cpu_exec_enter(cpu); init_delay_params(&sc, cpu); if (sigsetjmp(cpu->jmp_env, 0) != 0) { #if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6) cpu = current_cpu; cc = CPU_GET_CLASS(cpu); #else g_assert(cpu == current_cpu); g_assert(cc == CPU_GET_CLASS(cpu)); #endif cpu->can_do_io = 1; tb_lock_reset(); if (qemu_mutex_iothread_locked()) { qemu_mutex_unlock_iothread(); } } while (!cpu_handle_exception(cpu, &ret)) { TranslationBlock *last_tb = NULL; int tb_exit = 0; while (!cpu_handle_interrupt(cpu, &last_tb)) { TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit); cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc); align_clocks(&sc, cpu); } } cc->cpu_exec_exit(cpu); rcu_read_unlock(); current_cpu = NULL; return ret; }
--------------------------------------------- Result 47 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw) { int i; uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL; uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL; copy_scsw_to_guest(&dest->scsw, &src->scsw); for (i = 0; i < ARRAY_SIZE(dest->esw); i++) { dest->esw[i] = cpu_to_be32(src->esw[i]); } for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) { dest->ecw[i] = cpu_to_be32(src->ecw[i]); } if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) || !(pmcw->flags & PMCW_FLAGS_MASK_TF) || !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) { return; } if (!(stctl & SCSW_STCTL_STATUS_PEND)) { return; } if ((stctl & SCSW_STCTL_PRIMARY) || (stctl == SCSW_STCTL_SECONDARY) || ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) { for (i = 0; i < ARRAY_SIZE(dest->emw); i++) { dest->emw[i] = cpu_to_be32(src->emw[i]); } } }
--------------------------------------------- Result 48 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int process_input_packet(InputStream *ist, const AVPacket *pkt) { int i; int got_output; AVPacket avpkt; if (ist->next_dts == AV_NOPTS_VALUE) ist->next_dts = ist->last_dts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if (pkt->dts != AV_NOPTS_VALUE) ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) { int ret = 0; handle_eof: ist->last_dts = ist->next_dts; if (avpkt.size && avpkt.size != pkt->size && !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) { av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, "Multiple frames in a packet from stream %d\n", pkt->stream_index); ist->showed_multi_packet_warning = 1; } switch (ist->dec_ctx->codec_type) { case AVMEDIA_TYPE_AUDIO: ret = decode_audio (ist, &avpkt, &got_output); break; case AVMEDIA_TYPE_VIDEO: ret = decode_video (ist, &avpkt, &got_output); if (avpkt.duration) ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q); else if (ist->st->avg_frame_rate.num) ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate), AV_TIME_BASE_Q); else if (ist->dec_ctx->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame; ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q); } break; case AVMEDIA_TYPE_SUBTITLE: ret = transcode_subtitles(ist, &avpkt, &got_output); break; default: return -1; } if (ret < 0) return ret; if (pkt) { avpkt.data += ret; avpkt.size -= ret; } if (!got_output) { continue; } } if (!ist->decoding_needed) { ist->last_dts = ist->next_dts; switch (ist->dec_ctx->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) / ist->dec_ctx->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (ist->dec_ctx->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame; ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->time_base.num * ticks) / ist->dec_ctx->time_base.den; } break; } } for (i = 0; pkt && i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; if (!check_output_constraints(ist, ost) || ost->encoding_needed) continue; do_streamcopy(ist, ost, pkt); } return 0; }
--------------------------------------------- Result 49 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong disas_insn(DisasContext *s, CPUState *cpu) { CPUX86State *env = cpu->env_ptr; int b, prefixes; int shift; TCGMemOp ot, aflag, dflag; int modrm, reg, rm, mod, op, opreg, val; target_ulong next_eip, tval; int rex_w, rex_r; target_ulong pc_start = s->base.pc_next; s->pc_start = s->pc = pc_start; prefixes = 0; s->override = -1; rex_w = -1; rex_r = 0; #ifdef TARGET_X86_64 s->rex_x = 0; s->rex_b = 0; x86_64_hregs = 0; #endif s->rip_offset = 0; s->vex_l = 0; s->vex_v = 0; if (sigsetjmp(s->jmpbuf, 0) != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); return s->pc; } next_byte: b = x86_ldub_code(env, s); switch (b) { case 0xf3: prefixes |= PREFIX_REPZ; goto next_byte; case 0xf2: prefixes |= PREFIX_REPNZ; goto next_byte; case 0xf0: prefixes |= PREFIX_LOCK; goto next_byte; case 0x2e: s->override = R_CS; goto next_byte; case 0x36: s->override = R_SS; goto next_byte; case 0x3e: s->override = R_DS; goto next_byte; case 0x26: s->override = R_ES; goto next_byte; case 0x64: s->override = R_FS; goto next_byte; case 0x65: s->override = R_GS; goto next_byte; case 0x66: prefixes |= PREFIX_DATA; goto next_byte; case 0x67: prefixes |= PREFIX_ADR; goto next_byte; #ifdef TARGET_X86_64 case 0x40 ... 0x4f: if (CODE64(s)) { rex_w = (b >> 3) & 1; rex_r = (b & 0x4) << 1; s->rex_x = (b & 0x2) << 2; REX_B(s) = (b & 0x1) << 3; x86_64_hregs = 1; goto next_byte; } break; #endif case 0xc5: case 0xc4: if (s->code32 && !s->vm86) { static const int pp_prefix[4] = { 0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ }; int vex3, vex2 = x86_ldub_code(env, s); if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) { break; } s->pc++; if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ | PREFIX_LOCK | PREFIX_DATA)) { goto illegal_op; } #ifdef TARGET_X86_64 if (x86_64_hregs) { goto illegal_op; } #endif rex_r = (~vex2 >> 4) & 8; if (b == 0xc5) { vex3 = vex2; b = x86_ldub_code(env, s); } else { #ifdef TARGET_X86_64 s->rex_x = (~vex2 >> 3) & 8; s->rex_b = (~vex2 >> 2) & 8; #endif vex3 = x86_ldub_code(env, s); rex_w = (vex3 >> 7) & 1; switch (vex2 & 0x1f) { case 0x01: b = x86_ldub_code(env, s) | 0x100; break; case 0x02: b = 0x138; break; case 0x03: b = 0x13a; break; default: goto unknown_op; } } s->vex_v = (~vex3 >> 3) & 0xf; s->vex_l = (vex3 >> 2) & 1; prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX; } break; } if (CODE64(s)) { dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32); aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64); } else { if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) { dflag = MO_32; } else { dflag = MO_16; } if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) { aflag = MO_32; } else { aflag = MO_16; } } s->prefix = prefixes; s->aflag = aflag; s->dflag = dflag; reswitch: switch(b) { case 0x0f: b = x86_ldub_code(env, s) | 0x100; goto reswitch; case 0x00 ... 0x05: case 0x08 ... 0x0d: case 0x10 ... 0x15: case 0x18 ... 0x1d: case 0x20 ... 0x25: case 0x28 ... 0x2d: case 0x30 ... 0x35: case 0x38 ... 0x3d: { int op, f, val; op = (b >> 3) & 7; f = (b >> 1) & 3; ot = mo_b_d(b, dflag); switch(f) { case 0: modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod != 3) { gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else if (op == OP_XORL && rm == reg) { xor_zero: set_cc_op(s, CC_OP_CLR); tcg_gen_movi_tl(cpu_T0, 0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; } else { opreg = rm; } gen_op_mov_v_reg(ot, cpu_T1, reg); gen_op(s, op, ot, opreg); break; case 1: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; rm = (modrm & 7) | REX_B(s); if (mod != 3) { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, cpu_T1, cpu_A0); } else if (op == OP_XORL && rm == reg) { goto xor_zero; } else { gen_op_mov_v_reg(ot, cpu_T1, rm); } gen_op(s, op, ot, reg); break; case 2: val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); gen_op(s, op, ot, OR_EAX); break; } } break; case 0x82: if (CODE64(s)) goto illegal_op; case 0x80: case 0x81: case 0x83: { int val; ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (mod != 3) { if (b == 0x83) s->rip_offset = 1; else s->rip_offset = insn_const_size(ot); gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = rm; } switch(b) { default: case 0x80: case 0x81: case 0x82: val = insn_get(env, s, ot); break; case 0x83: val = (int8_t)insn_get(env, s, MO_8); break; } tcg_gen_movi_tl(cpu_T1, val); gen_op(s, op, ot, opreg); } break; case 0x40 ... 0x47: ot = dflag; gen_inc(s, ot, OR_EAX + (b & 7), 1); break; case 0x48 ... 0x4f: ot = dflag; gen_inc(s, ot, OR_EAX + (b & 7), -1); break; case 0xf6: case 0xf7: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (mod != 3) { if (op == 0) { s->rip_offset = insn_const_size(ot); } gen_lea_modrm(env, s, modrm); if (!(s->prefix & PREFIX_LOCK) || op != 2) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } switch(op) { case 0: val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 2: if (s->prefix & PREFIX_LOCK) { if (mod == 3) { goto illegal_op; } tcg_gen_movi_tl(cpu_T0, ~0); tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); } else { tcg_gen_not_tl(cpu_T0, cpu_T0); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } break; case 3: if (s->prefix & PREFIX_LOCK) { TCGLabel *label1; TCGv a0, t0, t1, t2; if (mod == 3) { goto illegal_op; } a0 = tcg_temp_local_new(); t0 = tcg_temp_local_new(); label1 = gen_new_label(); tcg_gen_mov_tl(a0, cpu_A0); tcg_gen_mov_tl(t0, cpu_T0); gen_set_label(label1); t1 = tcg_temp_new(); t2 = tcg_temp_new(); tcg_gen_mov_tl(t2, t0); tcg_gen_neg_tl(t1, t0); tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1, s->mem_index, ot | MO_LE); tcg_temp_free(t1); tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1); tcg_temp_free(t2); tcg_temp_free(a0); tcg_gen_mov_tl(cpu_T0, t0); tcg_temp_free(t0); } else { tcg_gen_neg_tl(cpu_T0, cpu_T0); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } gen_op_update_neg_cc(); set_cc_op(s, CC_OP_SUBB + ot); break; case 4: switch(ot) { case MO_8: gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX); tcg_gen_ext8u_tl(cpu_T0, cpu_T0); tcg_gen_ext8u_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00); set_cc_op(s, CC_OP_MULB); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX); tcg_gen_ext16u_tl(cpu_T0, cpu_T0); tcg_gen_ext16u_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_shri_tl(cpu_T0, cpu_T0, 16); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); tcg_gen_mov_tl(cpu_cc_src, cpu_T0); set_cc_op(s, CC_OP_MULW); break; default: case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]); tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULL); break; #ifdef TARGET_X86_64 case MO_64: tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_T0, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULQ); break; #endif } break; case 5: switch(ot) { case MO_8: gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX); tcg_gen_ext8s_tl(cpu_T0, cpu_T0); tcg_gen_ext8s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); set_cc_op(s, CC_OP_MULB); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_ext16s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); tcg_gen_shri_tl(cpu_T0, cpu_T0, 16); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); set_cc_op(s, CC_OP_MULW); break; default: case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]); tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32); tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32); set_cc_op(s, CC_OP_MULL); break; #ifdef TARGET_X86_64 case MO_64: tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_T0, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63); tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULQ); break; #endif } break; case 6: switch(ot) { case MO_8: gen_helper_divb_AL(cpu_env, cpu_T0); break; case MO_16: gen_helper_divw_AX(cpu_env, cpu_T0); break; default: case MO_32: gen_helper_divl_EAX(cpu_env, cpu_T0); break; #ifdef TARGET_X86_64 case MO_64: gen_helper_divq_EAX(cpu_env, cpu_T0); break; #endif } break; case 7: switch(ot) { case MO_8: gen_helper_idivb_AL(cpu_env, cpu_T0); break; case MO_16: gen_helper_idivw_AX(cpu_env, cpu_T0); break; default: case MO_32: gen_helper_idivl_EAX(cpu_env, cpu_T0); break; #ifdef TARGET_X86_64 case MO_64: gen_helper_idivq_EAX(cpu_env, cpu_T0); break; #endif } break; default: goto unknown_op; } break; case 0xfe: case 0xff: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (op >= 2 && b == 0xfe) { goto unknown_op; } if (CODE64(s)) { if (op == 2 || op == 4) { ot = MO_64; } else if (op == 3 || op == 5) { ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16; } else if (op == 6) { ot = mo_pushpop(s, dflag); } } if (mod != 3) { gen_lea_modrm(env, s, modrm); if (op >= 2 && op != 3 && op != 5) gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } switch(op) { case 0: if (mod != 3) opreg = OR_TMP0; else opreg = rm; gen_inc(s, ot, opreg, 1); break; case 1: if (mod != 3) opreg = OR_TMP0; else opreg = rm; gen_inc(s, ot, opreg, -1); break; case 2: if (dflag == MO_16) { tcg_gen_ext16u_tl(cpu_T0, cpu_T0); } next_eip = s->pc - s->cs_base; tcg_gen_movi_tl(cpu_T1, next_eip); gen_push_v(s, cpu_T1); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 3: gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); do_lcall: if (s->pe && !s->vm86) { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_i32(dflag - 1), tcg_const_tl(s->pc - s->cs_base)); } else { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_i32(dflag - 1), tcg_const_i32(s->pc - s->cs_base)); } tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip)); gen_jr(s, cpu_tmp4); break; case 4: if (dflag == MO_16) { tcg_gen_ext16u_tl(cpu_T0, cpu_T0); } gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 5: gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); do_ljmp: if (s->pe && !s->vm86) { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_tl(s->pc - s->cs_base)); } else { gen_op_movl_seg_T0_vm(R_CS); gen_op_jmp_v(cpu_T1); } tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip)); gen_jr(s, cpu_tmp4); break; case 6: gen_push_v(s, cpu_T0); break; default: goto unknown_op; } break; case 0x84: case 0x85: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_op_mov_v_reg(ot, cpu_T1, reg); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 0xa8: case 0xa9: ot = mo_b_d(b, dflag); val = insn_get(env, s, ot); gen_op_mov_v_reg(ot, cpu_T0, OR_EAX); tcg_gen_movi_tl(cpu_T1, val); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 0x98: switch (dflag) { #ifdef TARGET_X86_64 case MO_64: gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX); tcg_gen_ext32s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0); break; #endif case MO_32: gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0); break; case MO_16: gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX); tcg_gen_ext8s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); break; default: tcg_abort(); } break; case 0x99: switch (dflag) { #ifdef TARGET_X86_64 case MO_64: gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX); tcg_gen_sari_tl(cpu_T0, cpu_T0, 63); gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0); break; #endif case MO_32: gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX); tcg_gen_ext32s_tl(cpu_T0, cpu_T0); tcg_gen_sari_tl(cpu_T0, cpu_T0, 31); gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_sari_tl(cpu_T0, cpu_T0, 15); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); break; default: tcg_abort(); } break; case 0x1af: case 0x69: case 0x6b: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; if (b == 0x69) s->rip_offset = insn_const_size(ot); else if (b == 0x6b) s->rip_offset = 1; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); if (b == 0x69) { val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); } else if (b == 0x6b) { val = (int8_t)insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T1, val); } else { gen_op_mov_v_reg(ot, cpu_T1, reg); } switch (ot) { #ifdef TARGET_X86_64 case MO_64: tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]); tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63); tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1); break; #endif case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32); tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]); tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32); break; default: tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_ext16s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; } set_cc_op(s, CC_OP_MULB + ot); break; case 0x1c0: case 0x1c1: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; gen_op_mov_v_reg(ot, cpu_T0, reg); if (mod == 3) { rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(ot, cpu_T1, rm); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(ot, reg, cpu_T1); gen_op_mov_reg_v(ot, rm, cpu_T0); } else { gen_lea_modrm(env, s, modrm); if (s->prefix & PREFIX_LOCK) { tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); } else { gen_op_ld_v(s, ot, cpu_T1, cpu_A0); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_st_v(s, ot, cpu_T0, cpu_A0); } gen_op_mov_reg_v(ot, reg, cpu_T1); } gen_op_update2_cc(); set_cc_op(s, CC_OP_ADDB + ot); break; case 0x1b0: case 0x1b1: { TCGv oldv, newv, cmpv; ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; oldv = tcg_temp_new(); newv = tcg_temp_new(); cmpv = tcg_temp_new(); gen_op_mov_v_reg(ot, newv, reg); tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]); if (s->prefix & PREFIX_LOCK) { if (mod == 3) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv, s->mem_index, ot | MO_LE); gen_op_mov_reg_v(ot, R_EAX, oldv); } else { if (mod == 3) { rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(ot, oldv, rm); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, oldv, cpu_A0); rm = 0; } gen_extu(ot, oldv); gen_extu(ot, cmpv); tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv); if (mod == 3) { gen_op_mov_reg_v(ot, R_EAX, oldv); gen_op_mov_reg_v(ot, rm, newv); } else { gen_op_st_v(s, ot, newv, cpu_A0); gen_op_mov_reg_v(ot, R_EAX, oldv); } } tcg_gen_mov_tl(cpu_cc_src, oldv); tcg_gen_mov_tl(cpu_cc_srcT, cmpv); tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv); set_cc_op(s, CC_OP_SUBB + ot); tcg_temp_free(oldv); tcg_temp_free(newv); tcg_temp_free(cmpv); } break; case 0x1c7: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if ((mod == 3) || ((modrm & 0x38) != 0x8)) goto illegal_op; #ifdef TARGET_X86_64 if (dflag == MO_64) { if (!(s->cpuid_ext_features & CPUID_EXT_CX16)) goto illegal_op; gen_lea_modrm(env, s, modrm); if ((s->prefix & PREFIX_LOCK) && parallel_cpus) { gen_helper_cmpxchg16b(cpu_env, cpu_A0); } else { gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0); } } else #endif { if (!(s->cpuid_features & CPUID_CX8)) goto illegal_op; gen_lea_modrm(env, s, modrm); if ((s->prefix & PREFIX_LOCK) && parallel_cpus) { gen_helper_cmpxchg8b(cpu_env, cpu_A0); } else { gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0); } } set_cc_op(s, CC_OP_EFLAGS); break; case 0x50 ... 0x57: gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s)); gen_push_v(s, cpu_T0); break; case 0x58 ... 0x5f: ot = gen_pop_T0(s); gen_pop_update(s, ot); gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0); break; case 0x60: if (CODE64(s)) goto illegal_op; gen_pusha(s); break; case 0x61: if (CODE64(s)) goto illegal_op; gen_popa(s); break; case 0x68: case 0x6a: ot = mo_pushpop(s, dflag); if (b == 0x68) val = insn_get(env, s, ot); else val = (int8_t)insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T0, val); gen_push_v(s, cpu_T0); break; case 0x8f: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; ot = gen_pop_T0(s); if (mod == 3) { gen_pop_update(s, ot); rm = (modrm & 7) | REX_B(s); gen_op_mov_reg_v(ot, rm, cpu_T0); } else { s->popl_esp_hack = 1 << ot; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); s->popl_esp_hack = 0; gen_pop_update(s, ot); } break; case 0xc8: { int level; val = x86_lduw_code(env, s); level = x86_ldub_code(env, s); gen_enter(s, val, level); } break; case 0xc9: gen_leave(s); break; case 0x06: case 0x0e: case 0x16: case 0x1e: if (CODE64(s)) goto illegal_op; gen_op_movl_T0_seg(b >> 3); gen_push_v(s, cpu_T0); break; case 0x1a0: case 0x1a8: gen_op_movl_T0_seg((b >> 3) & 7); gen_push_v(s, cpu_T0); break; case 0x07: case 0x17: case 0x1f: if (CODE64(s)) goto illegal_op; reg = b >> 3; ot = gen_pop_T0(s); gen_movl_seg_T0(s, reg); gen_pop_update(s, ot); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); if (reg == R_SS) { s->tf = 0; gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_eob(s); } } break; case 0x1a1: case 0x1a9: ot = gen_pop_T0(s); gen_movl_seg_T0(s, (b >> 3) & 7); gen_pop_update(s, ot); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x88: case 0x89: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, reg, 1); break; case 0xc6: case 0xc7: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod != 3) { s->rip_offset = insn_const_size(ot); gen_lea_modrm(env, s, modrm); } val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T0, val); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0); } break; case 0x8a: case 0x8b: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; case 0x8e: modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; if (reg >= 6 || reg == R_CS) goto illegal_op; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_movl_seg_T0(s, reg); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); if (reg == R_SS) { s->tf = 0; gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_eob(s); } } break; case 0x8c: modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; if (reg >= 6) goto illegal_op; gen_op_movl_T0_seg(reg); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 0x1b6: case 0x1b7: case 0x1be: case 0x1bf: { TCGMemOp d_ot; TCGMemOp s_ot; d_ot = dflag; ot = (b & 1) + MO_8; s_ot = b & 8 ? MO_SIGN | ot : ot; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod == 3) { if (s_ot == MO_SB && byte_reg_is_xH(rm)) { tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8); } else { gen_op_mov_v_reg(ot, cpu_T0, rm); switch (s_ot) { case MO_UB: tcg_gen_ext8u_tl(cpu_T0, cpu_T0); break; case MO_SB: tcg_gen_ext8s_tl(cpu_T0, cpu_T0); break; case MO_UW: tcg_gen_ext16u_tl(cpu_T0, cpu_T0); break; default: case MO_SW: tcg_gen_ext16s_tl(cpu_T0, cpu_T0); break; } } gen_op_mov_reg_v(d_ot, reg, cpu_T0); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0); gen_op_mov_reg_v(d_ot, reg, cpu_T0); } } break; case 0x8d: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; reg = ((modrm >> 3) & 7) | rex_r; { AddressParts a = gen_lea_modrm_0(env, s, modrm); TCGv ea = gen_lea_modrm_1(a); gen_lea_v_seg(s, s->aflag, ea, -1, -1); gen_op_mov_reg_v(dflag, reg, cpu_A0); } break; case 0xa0: case 0xa1: case 0xa2: case 0xa3: { target_ulong offset_addr; ot = mo_b_d(b, dflag); switch (s->aflag) { #ifdef TARGET_X86_64 case MO_64: offset_addr = x86_ldq_code(env, s); break; #endif default: offset_addr = insn_get(env, s, s->aflag); break; } tcg_gen_movi_tl(cpu_A0, offset_addr); gen_add_A0_ds_seg(s); if ((b & 2) == 0) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); gen_op_mov_reg_v(ot, R_EAX, cpu_T0); } else { gen_op_mov_v_reg(ot, cpu_T0, R_EAX); gen_op_st_v(s, ot, cpu_T0, cpu_A0); } } break; case 0xd7: tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]); tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]); tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0); gen_extu(s->aflag, cpu_A0); gen_add_A0_ds_seg(s); gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0); gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0); break; case 0xb0 ... 0xb7: val = insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T0, val); gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0); break; case 0xb8 ... 0xbf: #ifdef TARGET_X86_64 if (dflag == MO_64) { uint64_t tmp; tmp = x86_ldq_code(env, s); reg = (b & 7) | REX_B(s); tcg_gen_movi_tl(cpu_T0, tmp); gen_op_mov_reg_v(MO_64, reg, cpu_T0); } else #endif { ot = dflag; val = insn_get(env, s, ot); reg = (b & 7) | REX_B(s); tcg_gen_movi_tl(cpu_T0, val); gen_op_mov_reg_v(ot, reg, cpu_T0); } break; case 0x91 ... 0x97: do_xchg_reg_eax: ot = dflag; reg = (b & 7) | REX_B(s); rm = R_EAX; goto do_xchg_reg; case 0x86: case 0x87: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; if (mod == 3) { rm = (modrm & 7) | REX_B(s); do_xchg_reg: gen_op_mov_v_reg(ot, cpu_T0, reg); gen_op_mov_v_reg(ot, cpu_T1, rm); gen_op_mov_reg_v(ot, rm, cpu_T0); gen_op_mov_reg_v(ot, reg, cpu_T1); } else { gen_lea_modrm(env, s, modrm); gen_op_mov_v_reg(ot, cpu_T0, reg); tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); gen_op_mov_reg_v(ot, reg, cpu_T1); } break; case 0xc4: op = R_ES; goto do_lxx; case 0xc5: op = R_DS; goto do_lxx; case 0x1b2: op = R_SS; goto do_lxx; case 0x1b4: op = R_FS; goto do_lxx; case 0x1b5: op = R_GS; do_lxx: ot = dflag != MO_16 ? MO_32 : MO_16; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); gen_movl_seg_T0(s, op); gen_op_mov_reg_v(ot, reg, cpu_T1); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0xc0: case 0xc1: shift = 2; grp2: { ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; if (mod != 3) { if (shift == 2) { s->rip_offset = 1; } gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = (modrm & 7) | REX_B(s); } if (shift == 0) { gen_shift(s, op, ot, opreg, OR_ECX); } else { if (shift == 2) { shift = x86_ldub_code(env, s); } gen_shifti(s, op, ot, opreg, shift); } } break; case 0xd0: case 0xd1: shift = 1; goto grp2; case 0xd2: case 0xd3: shift = 0; goto grp2; case 0x1a4: op = 0; shift = 1; goto do_shiftd; case 0x1a5: op = 0; shift = 0; goto do_shiftd; case 0x1ac: op = 1; shift = 1; goto do_shiftd; case 0x1ad: op = 1; shift = 0; do_shiftd: ot = dflag; modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (mod != 3) { gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = rm; } gen_op_mov_v_reg(ot, cpu_T1, reg); if (shift) { TCGv imm = tcg_const_tl(x86_ldub_code(env, s)); gen_shiftd_rm_T1(s, ot, opreg, op, imm); tcg_temp_free(imm); } else { gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]); } break; case 0xd8 ... 0xdf: if (s->flags & (HF_EM_MASK | HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = modrm & 7; op = ((b & 7) << 3) | ((modrm >> 3) & 7); if (mod != 3) { gen_lea_modrm(env, s, modrm); switch(op) { case 0x00 ... 0x07: case 0x10 ... 0x17: case 0x20 ... 0x27: case 0x30 ... 0x37: { int op1; op1 = op & 7; switch(op >> 4) { case 0: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32); break; case 1: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32); break; case 2: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64); break; case 3: default: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LESW); gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32); break; } gen_helper_fp_arith_ST0_FT0(op1); if (op1 == 3) { gen_helper_fpop(cpu_env); } } break; case 0x08: case 0x0a: case 0x0b: case 0x18 ... 0x1b: case 0x28 ... 0x2b: case 0x38 ... 0x3b: switch(op & 7) { case 0: switch(op >> 4) { case 0: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32); break; case 1: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32); break; case 2: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64); break; case 3: default: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LESW); gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32); break; } break; case 1: switch(op >> 4) { case 1: gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 2: gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); break; case 3: default: gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; } gen_helper_fpop(cpu_env); break; default: switch(op >> 4) { case 0: gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 1: gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 2: gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); break; case 3: default: gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; } if ((op & 7) == 3) gen_helper_fpop(cpu_env); break; } break; case 0x0c: gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x0d: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); gen_helper_fldcw(cpu_env, cpu_tmp2_i32); break; case 0x0e: gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x0f: gen_helper_fnstcw(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; case 0x1d: gen_helper_fldt_ST0(cpu_env, cpu_A0); break; case 0x1f: gen_helper_fstt_ST0(cpu_env, cpu_A0); gen_helper_fpop(cpu_env); break; case 0x2c: gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x2e: gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x2f: gen_helper_fnstsw(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; case 0x3c: gen_helper_fbld_ST0(cpu_env, cpu_A0); break; case 0x3e: gen_helper_fbst_ST0(cpu_env, cpu_A0); gen_helper_fpop(cpu_env); break; case 0x3d: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64); break; case 0x3f: gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } } else { opreg = rm; switch(op) { case 0x08: gen_helper_fpush(cpu_env); gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32((opreg + 1) & 7)); break; case 0x09: case 0x29: case 0x39: gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg)); break; case 0x0a: switch(rm) { case 0: gen_helper_fwait(cpu_env); break; default: goto unknown_op; } break; case 0x0c: switch(rm) { case 0: gen_helper_fchs_ST0(cpu_env); break; case 1: gen_helper_fabs_ST0(cpu_env); break; case 4: gen_helper_fldz_FT0(cpu_env); gen_helper_fcom_ST0_FT0(cpu_env); break; case 5: gen_helper_fxam_ST0(cpu_env); break; default: goto unknown_op; } break; case 0x0d: { switch(rm) { case 0: gen_helper_fpush(cpu_env); gen_helper_fld1_ST0(cpu_env); break; case 1: gen_helper_fpush(cpu_env); gen_helper_fldl2t_ST0(cpu_env); break; case 2: gen_helper_fpush(cpu_env); gen_helper_fldl2e_ST0(cpu_env); break; case 3: gen_helper_fpush(cpu_env); gen_helper_fldpi_ST0(cpu_env); break; case 4: gen_helper_fpush(cpu_env); gen_helper_fldlg2_ST0(cpu_env); break; case 5: gen_helper_fpush(cpu_env); gen_helper_fldln2_ST0(cpu_env); break; case 6: gen_helper_fpush(cpu_env); gen_helper_fldz_ST0(cpu_env); break; default: goto unknown_op; } } break; case 0x0e: switch(rm) { case 0: gen_helper_f2xm1(cpu_env); break; case 1: gen_helper_fyl2x(cpu_env); break; case 2: gen_helper_fptan(cpu_env); break; case 3: gen_helper_fpatan(cpu_env); break; case 4: gen_helper_fxtract(cpu_env); break; case 5: gen_helper_fprem1(cpu_env); break; case 6: gen_helper_fdecstp(cpu_env); break; default: case 7: gen_helper_fincstp(cpu_env); break; } break; case 0x0f: switch(rm) { case 0: gen_helper_fprem(cpu_env); break; case 1: gen_helper_fyl2xp1(cpu_env); break; case 2: gen_helper_fsqrt(cpu_env); break; case 3: gen_helper_fsincos(cpu_env); break; case 5: gen_helper_fscale(cpu_env); break; case 4: gen_helper_frndint(cpu_env); break; case 6: gen_helper_fsin(cpu_env); break; default: case 7: gen_helper_fcos(cpu_env); break; } break; case 0x00: case 0x01: case 0x04 ... 0x07: case 0x20: case 0x21: case 0x24 ... 0x27: case 0x30: case 0x31: case 0x34 ... 0x37: { int op1; op1 = op & 7; if (op >= 0x20) { gen_helper_fp_arith_STN_ST0(op1, opreg); if (op >= 0x30) gen_helper_fpop(cpu_env); } else { gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fp_arith_ST0_FT0(op1); } } break; case 0x02: case 0x22: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcom_ST0_FT0(cpu_env); break; case 0x03: case 0x23: case 0x32: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); break; case 0x15: switch(rm) { case 1: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1)); gen_helper_fucom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } break; case 0x1c: switch(rm) { case 0: break; case 1: break; case 2: gen_helper_fclex(cpu_env); break; case 3: gen_helper_fninit(cpu_env); break; case 4: break; default: goto unknown_op; } break; case 0x1d: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucomi_ST0_FT0(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x1e: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcomi_ST0_FT0(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x28: gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg)); break; case 0x2a: gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg)); break; case 0x2b: case 0x0b: case 0x3a: case 0x3b: gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg)); gen_helper_fpop(cpu_env); break; case 0x2c: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucom_ST0_FT0(cpu_env); break; case 0x2d: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); break; case 0x33: switch(rm) { case 1: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1)); gen_helper_fcom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } break; case 0x38: gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fpop(cpu_env); break; case 0x3c: switch(rm) { case 0: gen_helper_fnstsw(cpu_tmp2_i32, cpu_env); tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); break; default: goto unknown_op; } break; case 0x3d: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucomi_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x3e: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcomi_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x10 ... 0x13: case 0x18 ... 0x1b: { int op1; TCGLabel *l1; static const uint8_t fcmov_cc[8] = { (JCC_B << 1), (JCC_Z << 1), (JCC_BE << 1), (JCC_P << 1), }; if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1); l1 = gen_new_label(); gen_jcc1_noeob(s, op1, l1); gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg)); gen_set_label(l1); } break; default: goto unknown_op; } } break; case 0xa4: case 0xa5: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_movs(s, ot); } break; case 0xaa: case 0xab: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_stos(s, ot); } break; case 0xac: case 0xad: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_lods(s, ot); } break; case 0xae: case 0xaf: ot = mo_b_d(b, dflag); if (prefixes & PREFIX_REPNZ) { gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1); } else if (prefixes & PREFIX_REPZ) { gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0); } else { gen_scas(s, ot); } break; case 0xa6: case 0xa7: ot = mo_b_d(b, dflag); if (prefixes & PREFIX_REPNZ) { gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1); } else if (prefixes & PREFIX_REPZ) { gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0); } else { gen_cmps(s, ot); } break; case 0x6c: case 0x6d: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_ins(s, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_jmp(s, s->pc - s->cs_base); } } break; case 0x6e: case 0x6f: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes) | 4); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_outs(s, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_jmp(s, s->pc - s->cs_base); } } break; case 0xe4: case 0xe5: ot = mo_b_d32(b, dflag); val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T0, val); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes)); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_movi_i32(cpu_tmp2_i32, val); gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32); gen_op_mov_reg_v(ot, R_EAX, cpu_T1); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xe6: case 0xe7: ot = mo_b_d32(b, dflag); val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T0, val); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes)); gen_op_mov_v_reg(ot, cpu_T1, R_EAX); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_movi_i32(cpu_tmp2_i32, val); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xec: case 0xed: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes)); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32); gen_op_mov_reg_v(ot, R_EAX, cpu_T1); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xee: case 0xef: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes)); gen_op_mov_v_reg(ot, cpu_T1, R_EAX); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xc2: val = x86_ldsw_code(env, s); ot = gen_pop_T0(s); gen_stack_update(s, val + (1 << ot)); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 0xc3: ot = gen_pop_T0(s); gen_pop_update(s, ot); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 0xca: val = x86_ldsw_code(env, s); do_lret: if (s->pe && !s->vm86) { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1), tcg_const_i32(val)); } else { gen_stack_A0(s); gen_op_ld_v(s, dflag, cpu_T0, cpu_A0); gen_op_jmp_v(cpu_T0); gen_add_A0_im(s, 1 << dflag); gen_op_ld_v(s, dflag, cpu_T0, cpu_A0); gen_op_movl_seg_T0_vm(R_CS); gen_stack_update(s, val + (2 << dflag)); } gen_eob(s); break; case 0xcb: val = 0; goto do_lret; case 0xcf: gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET); if (!s->pe) { gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1)); set_cc_op(s, CC_OP_EFLAGS); } else if (s->vm86) { if (s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1)); set_cc_op(s, CC_OP_EFLAGS); } } else { gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1), tcg_const_i32(s->pc - s->cs_base)); set_cc_op(s, CC_OP_EFLAGS); } gen_eob(s); break; case 0xe8: { if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } else if (!CODE64(s)) { tval &= 0xffffffff; } tcg_gen_movi_tl(cpu_T0, next_eip); gen_push_v(s, cpu_T0); gen_bnd_jmp(s); gen_jmp(s, tval); } break; case 0x9a: { unsigned int selector, offset; if (CODE64(s)) goto illegal_op; ot = dflag; offset = insn_get(env, s, ot); selector = insn_get(env, s, MO_16); tcg_gen_movi_tl(cpu_T0, selector); tcg_gen_movi_tl(cpu_T1, offset); } goto do_lcall; case 0xe9: if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } tval += s->pc - s->cs_base; if (dflag == MO_16) { tval &= 0xffff; } else if (!CODE64(s)) { tval &= 0xffffffff; } gen_bnd_jmp(s); gen_jmp(s, tval); break; case 0xea: { unsigned int selector, offset; if (CODE64(s)) goto illegal_op; ot = dflag; offset = insn_get(env, s, ot); selector = insn_get(env, s, MO_16); tcg_gen_movi_tl(cpu_T0, selector); tcg_gen_movi_tl(cpu_T1, offset); } goto do_ljmp; case 0xeb: tval = (int8_t)insn_get(env, s, MO_8); tval += s->pc - s->cs_base; if (dflag == MO_16) { tval &= 0xffff; } gen_jmp(s, tval); break; case 0x70 ... 0x7f: tval = (int8_t)insn_get(env, s, MO_8); goto do_jcc; case 0x180 ... 0x18f: if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } do_jcc: next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } gen_bnd_jmp(s); gen_jcc(s, b, tval, next_eip); break; case 0x190 ... 0x19f: modrm = x86_ldub_code(env, s); gen_setcc1(s, b, cpu_T0); gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1); break; case 0x140 ... 0x14f: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_cmovcc1(env, s, ot, b, modrm, reg); break; case 0x9c: gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_helper_read_eflags(cpu_T0, cpu_env); gen_push_v(s, cpu_T0); } break; case 0x9d: gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { ot = gen_pop_T0(s); if (s->cpl == 0) { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK) & 0xffff)); } } else { if (s->cpl <= s->iopl) { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK) & 0xffff)); } } else { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK) & 0xffff)); } } } gen_pop_update(s, ot); set_cc_op(s, CC_OP_EFLAGS); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x9e: if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM)) goto illegal_op; gen_op_mov_v_reg(MO_8, cpu_T0, R_AH); gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O); tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C); tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0); break; case 0x9f: if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM)) goto illegal_op; gen_compute_eflags(s); tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02); gen_op_mov_reg_v(MO_8, R_AH, cpu_T0); break; case 0xf5: gen_compute_eflags(s); tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C); break; case 0xf8: gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C); break; case 0xf9: gen_compute_eflags(s); tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C); break; case 0xfc: tcg_gen_movi_i32(cpu_tmp2_i32, 1); tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df)); break; case 0xfd: tcg_gen_movi_i32(cpu_tmp2_i32, -1); tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df)); break; case 0x1ba: ot = dflag; modrm = x86_ldub_code(env, s); op = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod != 3) { s->rip_offset = 1; gen_lea_modrm(env, s, modrm); if (!(s->prefix & PREFIX_LOCK)) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T1, val); if (op < 4) goto unknown_op; op -= 4; goto bt_op; case 0x1a3: op = 0; goto do_btx; case 0x1ab: op = 1; goto do_btx; case 0x1b3: op = 2; goto do_btx; case 0x1bb: op = 3; do_btx: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(MO_32, cpu_T1, reg); if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); gen_exts(ot, cpu_T1); tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot); tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot); tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0); gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (!(s->prefix & PREFIX_LOCK)) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } bt_op: tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1); tcg_gen_movi_tl(cpu_tmp0, 1); tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1); if (s->prefix & PREFIX_LOCK) { switch (op) { case 0: gen_op_ld_v(s, ot, cpu_T0, cpu_A0); break; case 1: tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; case 2: tcg_gen_not_tl(cpu_tmp0, cpu_tmp0); tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; default: case 3: tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; } tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1); } else { tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1); switch (op) { case 0: break; case 1: tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0); break; case 2: tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0); break; default: case 3: tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0); break; } if (op != 0) { if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } } switch (s->cc_op) { case CC_OP_MULB ... CC_OP_MULQ: case CC_OP_ADDB ... CC_OP_ADDQ: case CC_OP_ADCB ... CC_OP_ADCQ: case CC_OP_SUBB ... CC_OP_SUBQ: case CC_OP_SBBB ... CC_OP_SBBQ: case CC_OP_LOGICB ... CC_OP_LOGICQ: case CC_OP_INCB ... CC_OP_INCQ: case CC_OP_DECB ... CC_OP_DECQ: case CC_OP_SHLB ... CC_OP_SHLQ: case CC_OP_SARB ... CC_OP_SARQ: case CC_OP_BMILGB ... CC_OP_BMILGQ: tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4); set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB); break; default: gen_compute_eflags(s); tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4, ctz32(CC_C), 1); break; } break; case 0x1bc: case 0x1bd: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_extu(ot, cpu_T0); if ((prefixes & PREFIX_REPZ) && (b & 1 ? s->cpuid_ext3_features & CPUID_EXT3_ABM : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) { int size = 8 << ot; tcg_gen_mov_tl(cpu_cc_src, cpu_T0); if (b & 1) { tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS); tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size); } else { tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size); } gen_op_update1_cc(); set_cc_op(s, CC_OP_BMILGB + ot); } else { tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); set_cc_op(s, CC_OP_LOGICB + ot); if (b & 1) { tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1); tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1); tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1); } else { tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]); } } gen_op_mov_reg_v(ot, reg, cpu_T0); break; case 0x27: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_daa(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x2f: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_das(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x37: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_aaa(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x3f: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_aas(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0xd4: if (CODE64(s)) goto illegal_op; val = x86_ldub_code(env, s); if (val == 0) { gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base); } else { gen_helper_aam(cpu_env, tcg_const_i32(val)); set_cc_op(s, CC_OP_LOGICB); } break; case 0xd5: if (CODE64(s)) goto illegal_op; val = x86_ldub_code(env, s); gen_helper_aad(cpu_env, tcg_const_i32(val)); set_cc_op(s, CC_OP_LOGICB); break; case 0x90: if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (REX_B(s)) { goto do_xchg_reg_eax; } if (prefixes & PREFIX_REPZ) { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start)); s->base.is_jmp = DISAS_NORETURN; } break; case 0x9b: if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) == (HF_MP_MASK | HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); } else { gen_helper_fwait(cpu_env); } break; case 0xcc: gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base); break; case 0xcd: val = x86_ldub_code(env, s); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base); } break; case 0xce: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start)); break; #ifdef WANT_ICEBP case 0xf1: gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP); #if 1 gen_debug(s, pc_start - s->cs_base); #else tb_flush(CPU(x86_env_get_cpu(env))); qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM); #endif break; #endif case 0xfa: if (!s->vm86) { if (s->cpl <= s->iopl) { gen_helper_cli(cpu_env); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } } else { if (s->iopl == 3) { gen_helper_cli(cpu_env); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } } break; case 0xfb: if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) { gen_helper_sti(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } break; case 0x62: if (CODE64(s)) goto illegal_op; ot = dflag; modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_op_mov_v_reg(ot, cpu_T0, reg); gen_lea_modrm(env, s, modrm); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); if (ot == MO_16) { gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32); } else { gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32); } break; case 0x1c8 ... 0x1cf: reg = (b & 7) | REX_B(s); #ifdef TARGET_X86_64 if (dflag == MO_64) { gen_op_mov_v_reg(MO_64, cpu_T0, reg); tcg_gen_bswap64_i64(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_64, reg, cpu_T0); } else #endif { gen_op_mov_v_reg(MO_32, cpu_T0, reg); tcg_gen_ext32u_tl(cpu_T0, cpu_T0); tcg_gen_bswap32_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_32, reg, cpu_T0); } break; case 0xd6: if (CODE64(s)) goto illegal_op; gen_compute_eflags_c(s, cpu_T0); tcg_gen_neg_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0); break; case 0xe0: case 0xe1: case 0xe2: case 0xe3: { TCGLabel *l1, *l2, *l3; tval = (int8_t)insn_get(env, s, MO_8); next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } l1 = gen_new_label(); l2 = gen_new_label(); l3 = gen_new_label(); b &= 3; switch(b) { case 0: case 1: gen_op_add_reg_im(s->aflag, R_ECX, -1); gen_op_jz_ecx(s->aflag, l3); gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1); break; case 2: gen_op_add_reg_im(s->aflag, R_ECX, -1); gen_op_jnz_ecx(s->aflag, l1); break; default: case 3: gen_op_jz_ecx(s->aflag, l1); break; } gen_set_label(l3); gen_jmp_im(next_eip); tcg_gen_br(l2); gen_set_label(l1); gen_jmp_im(tval); gen_set_label(l2); gen_eob(s); } break; case 0x130: case 0x132: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (b & 2) { gen_helper_rdmsr(cpu_env); } else { gen_helper_wrmsr(cpu_env); } } break; case 0x131: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_rdtsc(cpu_env); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0x133: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_rdpmc(cpu_env); break; case 0x134: if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1) goto illegal_op; if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysenter(cpu_env); gen_eob(s); } break; case 0x135: if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1) goto illegal_op; if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1)); gen_eob(s); } break; #ifdef TARGET_X86_64 case 0x105: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start)); gen_eob_worker(s, "False" != "False", "True" == "True"); break; case 0x107: if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1)); if (s->lma) { set_cc_op(s, CC_OP_EFLAGS); } gen_eob_worker(s, "False" != "False", "True" == "True"); } break; #endif case 0x1a2: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_cpuid(cpu_env); break; case 0xf4: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start)); s->base.is_jmp = DISAS_NORETURN; } break; case 0x100: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; switch(op) { case 0: if (!s->pe || s->vm86) goto illegal_op; gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, ldt.selector)); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 2: if (!s->pe || s->vm86) goto illegal_op; if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lldt(cpu_env, cpu_tmp2_i32); } break; case 1: if (!s->pe || s->vm86) goto illegal_op; gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, tr.selector)); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 3: if (!s->pe || s->vm86) goto illegal_op; if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_ltr(cpu_env, cpu_tmp2_i32); } break; case 4: case 5: if (!s->pe || s->vm86) goto illegal_op; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_update_cc_op(s); if (op == 4) { gen_helper_verr(cpu_env, cpu_T0); } else { gen_helper_verw(cpu_env, cpu_T0); } set_cc_op(s, CC_OP_EFLAGS); break; default: goto unknown_op; } break; case 0x101: modrm = x86_ldub_code(env, s); switch (modrm) { CASE_MODRM_MEM_OP(0): gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ); gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.limit)); gen_op_st_v(s, MO_16, cpu_T0, cpu_A0); gen_add_A0_im(s, 2); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base)); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); break; case 0xc8: if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]); gen_extu(s->aflag, cpu_A0); gen_add_A0_ds_seg(s); gen_helper_monitor(cpu_env, cpu_A0); break; case 0xc9: if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start)); gen_eob(s); break; case 0xca: if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP) || s->cpl != 0) { goto illegal_op; } gen_helper_clac(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xcb: if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP) || s->cpl != 0) { goto illegal_op; } gen_helper_stac(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(1): gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ); gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit)); gen_op_st_v(s, MO_16, cpu_T0, cpu_A0); gen_add_A0_im(s, 2); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base)); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); break; case 0xd0: if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32); tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64); break; case 0xd1: if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xd8: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1), tcg_const_i32(s->pc - pc_start)); tcg_gen_exit_tb(0); s->base.is_jmp = DISAS_NORETURN; break; case 0xd9: if (!(s->flags & HF_SVME_MASK)) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmmcall(cpu_env); break; case 0xda: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1)); break; case 0xdb: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1)); break; case 0xdc: if ((!(s->flags & HF_SVME_MASK) && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_stgi(cpu_env); break; case 0xdd: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_clgi(cpu_env); break; case 0xde: if ((!(s->flags & HF_SVME_MASK) && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || !s->pe) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_skinit(cpu_env); break; case 0xdf: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1)); break; CASE_MODRM_MEM_OP(2): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE); gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0); gen_add_A0_im(s, 2); gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base)); tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit)); break; CASE_MODRM_MEM_OP(3): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE); gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0); gen_add_A0_im(s, 2); gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base)); tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit)); break; CASE_MODRM_OP(4): gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0])); if (CODE64(s)) { mod = (modrm >> 6) & 3; ot = (mod != 3 ? MO_16 : s->dflag); } else { ot = MO_16; } gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 0xee: if (prefixes & PREFIX_LOCK) { goto illegal_op; } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32); tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64); break; case 0xef: if (prefixes & PREFIX_LOCK) { goto illegal_op; } tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64); break; CASE_MODRM_OP(6): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_helper_lmsw(cpu_env, cpu_T0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(7): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_lea_modrm(env, s, modrm); gen_helper_invlpg(cpu_env, cpu_A0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xf8: #ifdef TARGET_X86_64 if (CODE64(s)) { if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]); tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env, offsetof(CPUX86State, kernelgsbase)); tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, kernelgsbase)); } break; } #endif goto illegal_op; case 0xf9: if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_rdtscp(cpu_env); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; default: goto unknown_op; } break; case 0x108: case 0x109: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD); } break; case 0x63: #ifdef TARGET_X86_64 if (CODE64(s)) { int d_ot; d_ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod == 3) { gen_op_mov_v_reg(MO_32, cpu_T0, rm); if (d_ot == MO_64) { tcg_gen_ext32s_tl(cpu_T0, cpu_T0); } gen_op_mov_reg_v(d_ot, reg, cpu_T0); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0); gen_op_mov_reg_v(d_ot, reg, cpu_T0); } } else #endif { TCGLabel *label1; TCGv t0, t1, t2, a0; if (!s->pe || s->vm86) goto illegal_op; t0 = tcg_temp_local_new(); t1 = tcg_temp_local_new(); t2 = tcg_temp_local_new(); ot = MO_16; modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; rm = modrm & 7; if (mod != 3) { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, t0, cpu_A0); a0 = tcg_temp_local_new(); tcg_gen_mov_tl(a0, cpu_A0); } else { gen_op_mov_v_reg(ot, t0, rm); TCGV_UNUSED(a0); } gen_op_mov_v_reg(ot, t1, reg); tcg_gen_andi_tl(cpu_tmp0, t0, 3); tcg_gen_andi_tl(t1, t1, 3); tcg_gen_movi_tl(t2, 0); label1 = gen_new_label(); tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1); tcg_gen_andi_tl(t0, t0, ~3); tcg_gen_or_tl(t0, t0, t1); tcg_gen_movi_tl(t2, CC_Z); gen_set_label(label1); if (mod != 3) { gen_op_st_v(s, ot, t0, a0); tcg_temp_free(a0); } else { gen_op_mov_reg_v(ot, rm, t0); } gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z); tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2); tcg_temp_free(t0); tcg_temp_free(t1); tcg_temp_free(t2); } break; case 0x102: case 0x103: { TCGLabel *label1; TCGv t0; if (!s->pe || s->vm86) goto illegal_op; ot = dflag != MO_16 ? MO_32 : MO_16; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); t0 = tcg_temp_local_new(); gen_update_cc_op(s); if (b == 0x102) { gen_helper_lar(t0, cpu_env, cpu_T0); } else { gen_helper_lsl(t0, cpu_env, cpu_T0); } tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z); label1 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1); gen_op_mov_reg_v(ot, reg, t0); gen_set_label(label1); set_cc_op(s, CC_OP_EFLAGS); tcg_temp_free(t0); } break; case 0x118: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; switch(op) { case 0: case 1: case 2: case 3: if (mod == 3) goto illegal_op; gen_nop_modrm(env, s, modrm); break; default: gen_nop_modrm(env, s, modrm); break; } break; case 0x11a: modrm = x86_ldub_code(env, s); if (s->flags & HF_MPX_EN_MASK) { mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; if (prefixes & PREFIX_REPZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]); } else if (prefixes & PREFIX_REPNZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } TCGv_i64 notu = tcg_temp_new_i64(); tcg_gen_not_i64(notu, cpu_bndu[reg]); gen_bndck(env, s, modrm, TCG_COND_GTU, notu); tcg_temp_free_i64(notu); } else if (prefixes & PREFIX_DATA) { if (reg >= 4 || s->aflag == MO_16) { goto illegal_op; } if (mod == 3) { int reg2 = (modrm & 7) | REX_B(s); if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if (s->flags & HF_MPX_IU_MASK) { tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]); tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]); } } else { gen_lea_modrm(env, s, modrm); if (CODE64(s)) { tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEQ); tcg_gen_addi_tl(cpu_A0, cpu_A0, 8); tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEQ); } else { tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEUL); tcg_gen_addi_tl(cpu_A0, cpu_A0, 4); tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEUL); } gen_set_hflag(s, HF_MPX_IU_MASK); } } else if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16 || a.base < -1) { goto illegal_op; } if (a.base >= 0) { tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp); } else { tcg_gen_movi_tl(cpu_A0, 0); } gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (a.index >= 0) { tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]); } else { tcg_gen_movi_tl(cpu_T0, 0); } if (CODE64(s)) { gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0); tcg_gen_ld_i64(cpu_bndu[reg], cpu_env, offsetof(CPUX86State, mmx_t0.MMX_Q(0))); } else { gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0); tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]); tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32); } gen_set_hflag(s, HF_MPX_IU_MASK); } } gen_nop_modrm(env, s, modrm); break; case 0x11b: modrm = x86_ldub_code(env, s); if (s->flags & HF_MPX_EN_MASK) { mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; if (mod != 3 && (prefixes & PREFIX_REPZ)) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } AddressParts a = gen_lea_modrm_0(env, s, modrm); if (a.base >= 0) { tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]); if (!CODE64(s)) { tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]); } } else if (a.base == -1) { tcg_gen_movi_i64(cpu_bndl[reg], 0); } else { goto illegal_op; } tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a)); if (!CODE64(s)) { tcg_gen_ext32u_tl(cpu_A0, cpu_A0); } tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0); gen_set_hflag(s, HF_MPX_IU_MASK); break; } else if (prefixes & PREFIX_REPNZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]); } else if (prefixes & PREFIX_DATA) { if (reg >= 4 || s->aflag == MO_16) { goto illegal_op; } if (mod == 3) { int reg2 = (modrm & 7) | REX_B(s); if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if (s->flags & HF_MPX_IU_MASK) { tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]); tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]); } } else { gen_lea_modrm(env, s, modrm); if (CODE64(s)) { tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEQ); tcg_gen_addi_tl(cpu_A0, cpu_A0, 8); tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEQ); } else { tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEUL); tcg_gen_addi_tl(cpu_A0, cpu_A0, 4); tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEUL); } } } else if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16 || a.base < -1) { goto illegal_op; } if (a.base >= 0) { tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp); } else { tcg_gen_movi_tl(cpu_A0, 0); } gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (a.index >= 0) { tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]); } else { tcg_gen_movi_tl(cpu_T0, 0); } if (CODE64(s)) { gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0, cpu_bndl[reg], cpu_bndu[reg]); } else { gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0, cpu_bndl[reg], cpu_bndu[reg]); } } } gen_nop_modrm(env, s, modrm); break; case 0x119: case 0x11c ... 0x11f: modrm = x86_ldub_code(env, s); gen_nop_modrm(env, s, modrm); break; case 0x120: case 0x122: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { modrm = x86_ldub_code(env, s); rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (CODE64(s)) ot = MO_64; else ot = MO_32; if ((prefixes & PREFIX_LOCK) && (reg == 0) && (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) { reg = 8; } switch(reg) { case 0: case 2: case 3: case 4: case 8: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (b & 2) { if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_op_mov_v_reg(ot, cpu_T0, rm); gen_helper_write_crN(cpu_env, tcg_const_i32(reg), cpu_T0); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); } gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } else { if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg)); gen_op_mov_reg_v(ot, rm, cpu_T0); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); } } break; default: goto unknown_op; } } break; case 0x121: case 0x123: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { modrm = x86_ldub_code(env, s); rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (CODE64(s)) ot = MO_64; else ot = MO_32; if (reg >= 8) { goto illegal_op; } if (b & 2) { gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg); gen_op_mov_v_reg(ot, cpu_T0, rm); tcg_gen_movi_i32(cpu_tmp2_i32, reg); gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg); tcg_gen_movi_i32(cpu_tmp2_i32, reg); gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32); gen_op_mov_reg_v(ot, rm, cpu_T0); } } break; case 0x106: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0); gen_helper_clts(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x1c3: if (!(s->cpuid_features & CPUID_SSE2)) goto illegal_op; ot = mo_64_32(dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, reg, 1); break; case 0x1ae: modrm = x86_ldub_code(env, s); switch (modrm) { CASE_MODRM_MEM_OP(0): if (!(s->cpuid_features & CPUID_FXSR) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); gen_helper_fxsave(cpu_env, cpu_A0); break; CASE_MODRM_MEM_OP(1): if (!(s->cpuid_features & CPUID_FXSR) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); gen_helper_fxrstor(cpu_env, cpu_A0); break; CASE_MODRM_MEM_OP(2): if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) { goto illegal_op; } if (s->flags & HF_TS_MASK) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32); break; CASE_MODRM_MEM_OP(3): if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) { goto illegal_op; } if (s->flags & HF_TS_MASK) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr)); gen_op_st_v(s, MO_32, cpu_T0, cpu_A0); break; CASE_MODRM_MEM_OP(4): if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (prefixes & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64); break; CASE_MODRM_MEM_OP(5): if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (prefixes & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64); gen_update_cc_op(s); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(6): if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) { goto illegal_op; } gen_nop_modrm(env, s, modrm); } else { if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0 || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64); } break; CASE_MODRM_MEM_OP(7): if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) { goto illegal_op; } } else { if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ)) || !(s->cpuid_features & CPUID_CLFLUSH)) { goto illegal_op; } } gen_nop_modrm(env, s, modrm); break; case 0xc0 ... 0xc7: case 0xc8 ... 0xcf: case 0xd0 ... 0xd7: case 0xd8 ... 0xdf: if (CODE64(s) && (prefixes & PREFIX_REPZ) && !(prefixes & PREFIX_LOCK) && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) { TCGv base, treg, src, dst; tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK); gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32); base = cpu_seg_base[modrm & 8 ? R_GS : R_FS]; treg = cpu_regs[(modrm & 7) | REX_B(s)]; if (modrm & 0x10) { dst = base, src = treg; } else { dst = treg, src = base; } if (s->dflag == MO_32) { tcg_gen_ext32u_tl(dst, src); } else { tcg_gen_mov_tl(dst, src); } break; } goto unknown_op; case 0xf8: if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } break; } case 0xf9 ... 0xff: if (!(s->cpuid_features & CPUID_SSE) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC); break; case 0xe8 ... 0xef: if (!(s->cpuid_features & CPUID_SSE) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC); break; case 0xf0 ... 0xf7: if (!(s->cpuid_features & CPUID_SSE2) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC); break; default: goto unknown_op; } break; case 0x10d: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_nop_modrm(env, s, modrm); break; case 0x1aa: gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM); if (!(s->flags & HF_SMM_MASK)) goto illegal_op; gen_update_cc_op(s); gen_jmp_im(s->pc - s->cs_base); gen_helper_rsm(cpu_env); gen_eob(s); break; case 0x1b8: if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) != PREFIX_REPZ) goto illegal_op; if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT)) goto illegal_op; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; if (s->prefix & PREFIX_DATA) { ot = MO_16; } else { ot = mo_64_32(dflag); } gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_extu(ot, cpu_T0); tcg_gen_mov_tl(cpu_cc_src, cpu_T0); tcg_gen_ctpop_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(ot, reg, cpu_T0); set_cc_op(s, CC_OP_POPCNT); break; case 0x10e ... 0x10f: s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA); case 0x110 ... 0x117: case 0x128 ... 0x12f: case 0x138 ... 0x13a: case 0x150 ... 0x179: case 0x17c ... 0x17f: case 0x1c2: case 0x1c4 ... 0x1c6: case 0x1d0 ... 0x1fe: gen_sse(env, s, b, pc_start, rex_r); break; default: goto unknown_op; } return s->pc; illegal_op: gen_illegal_opcode(s); return s->pc; unknown_op: gen_unknown_opcode(env, s); return s->pc; }[Succeeded / Failed / Skipped / Total] 22 / 6 / 21 / 49:   2%|▏         | 49/2690 [06:17<5:39:29,  7.71s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 21 / 49:   2%|▏         | 50/2690 [06:18<5:33:02,  7.57s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 22 / 50:   2%|▏         | 50/2690 [06:18<5:33:02,  7.57s/it][Succeeded / Failed / Skipped / Total] 22 / 6 / 22 / 50:   2%|▏         | 51/2690 [06:35<5:41:28,  7.76s/it][Succeeded / Failed / Skipped / Total] 23 / 6 / 22 / 51:   2%|▏         | 51/2690 [06:35<5:41:28,  7.76s/it][Succeeded / Failed / Skipped / Total] 23 / 6 / 22 / 51:   2%|▏         | 52/2690 [06:36<5:35:09,  7.62s/it][Succeeded / Failed / Skipped / Total] 23 / 6 / 23 / 52:   2%|▏         | 52/2690 [06:36<5:35:09,  7.62s/it][Succeeded / Failed / Skipped / Total] 23 / 6 / 23 / 52:   2%|▏         | 53/2690 [06:46<5:36:45,  7.66s/it][Succeeded / Failed / Skipped / Total] 24 / 6 / 23 / 53:   2%|▏         | 53/2690 [06:46<5:36:45,  7.66s/it][Succeeded / Failed / Skipped / Total] 24 / 6 / 23 / 53:   2%|▏         | 54/2690 [06:46<5:30:49,  7.53s/it][Succeeded / Failed / Skipped / Total] 24 / 6 / 24 / 54:   2%|▏         | 54/2690 [06:46<5:30:49,  7.53s/it][Succeeded / Failed / Skipped / Total] 24 / 6 / 24 / 54:   2%|▏         | 55/2690 [07:24<5:55:00,  8.08s/it]
--------------------------------------------- Result 50 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int iscsi_open(BlockDriverState *bs, const char *filename, int flags) { IscsiLun *iscsilun = bs->opaque; struct iscsi_context *iscsi = NULL; struct iscsi_url *iscsi_url = NULL; struct IscsiTask task; char *initiator_name = NULL; int ret; if ((BDRV_SECTOR_SIZE % 512) != 0) { error_report("iSCSI: Invalid BDRV_SECTOR_SIZE. " "BDRV_SECTOR_SIZE(%lld) is not a multiple " "of 512", BDRV_SECTOR_SIZE); return -EINVAL; } iscsi_url = iscsi_parse_full_url(iscsi, filename); if (iscsi_url == NULL) { error_report("Failed to parse URL : %s %s", filename, iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; } memset(iscsilun, 0, sizeof(IscsiLun)); initiator_name = parse_initiator_name(iscsi_url->target); iscsi = iscsi_create_context(initiator_name); if (iscsi == NULL) { error_report("iSCSI: Failed to create iSCSI context."); ret = -ENOMEM; goto failed; } if (iscsi_set_targetname(iscsi, iscsi_url->target)) { error_report("iSCSI: Failed to set target name."); ret = -EINVAL; goto failed; } if (iscsi_url->user != NULL) { ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user, iscsi_url->passwd); if (ret != 0) { error_report("Failed to set initiator username and password"); ret = -EINVAL; goto failed; } } if (parse_chap(iscsi, iscsi_url->target) != 0) { error_report("iSCSI: Failed to set CHAP user/password"); ret = -EINVAL; goto failed; } if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) { error_report("iSCSI: Failed to set session type to normal."); ret = -EINVAL; goto failed; } iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C); parse_header_digest(iscsi, iscsi_url->target); task.iscsilun = iscsilun; task.status = 0; task.complete = 0; task.bs = bs; iscsilun->iscsi = iscsi; iscsilun->lun = iscsi_url->lun; if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun, iscsi_connect_cb, &task) != 0) { error_report("iSCSI: Failed to start async connect."); ret = -EINVAL; goto failed; } while (!task.complete) { iscsi_set_events(iscsilun); qemu_aio_wait(); } if (task.status != 0) { error_report("iSCSI: Failed to connect to LUN : %s", iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (iscsilun->type == TYPE_MEDIUM_CHANGER || iscsilun->type == TYPE_TAPE) { bs->sg = 1; } return 0; failed: if (initiator_name != NULL) { g_free(initiator_name); } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (iscsi != NULL) { iscsi_destroy_context(iscsi); } memset(iscsilun, 0, sizeof(IscsiLun)); return ret; }
--------------------------------------------- Result 51 ---------------------------------------------
[[0 (3%)]] --> [[0 (97%)]] --> Socre: 0.9714000821113586

[[[[Adv]]]]: void thread_pool_submit(ThreadPoolFunc *func, void *[[arg]]) { thread_pool_submit_aio(func, [[arg]], NULL, NULL); }

[[[[Adv]]]]: void thread_pool_submit(ThreadPoolFunc *func, void *[[afɡ]]) { thread_pool_submit_aio(func, [[afɡ]], NULL, NULL); }
--------------------------------------------- Result 52 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CommandInfoList *qmp_query_commands(Error **errp) { CommandInfoList *list = NULL; qmp_for_each_command(&qmp_commands, query_commands_cb, &list); return list; }
--------------------------------------------- Result 53 ---------------------------------------------
[[0 (62%)]] --> [[0 (28%)]] --> Socre: 0.7242539823055267

[[[[Adv]]]]: static int bfi_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size; int buf_size = avpkt->size; BFIContext *[[bfi]] = avctx->priv_data; uint8_t *dst = [[bfi]]->dst; uint8_t *src, *dst_offset, colour1, colour2; uint8_t *frame_end = [[bfi]]->dst + avctx->width * avctx->height; uint32_t *pal; int i, j, height = avctx->height; if ([[bfi]]->frame.data[0]) avctx->release_buffer(avctx, &[[bfi]]->frame); [[bfi]]->frame.reference = 1; if (avctx->get_buffer(avctx, &[[bfi]]->frame) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } if (!avctx->frame_number) { [[bfi]]->frame.pict_type = AV_PICTURE_TYPE_I; [[bfi]]->frame.key_frame = 1; if (avctx->extradata_size > 768) { av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n"); return -1; } pal = (uint32_t *)[[bfi]]->frame.data[1]; for (i = 0; i < avctx->extradata_size / 3; i++) { int shift = 16; *pal = 0; for (j = 0; j < 3; j++, shift -= 8) *pal += ((avctx->extradata[i * 3 + j] << 2) | (avctx->extradata[i * 3 + j] >> 4)) << shift; pal++; } [[bfi]]->frame.palette_has_changed = 1; } else { [[bfi]]->frame.pict_type = AV_PICTURE_TYPE_P; [[bfi]]->frame.key_frame = 0; } buf += 4; while (dst != frame_end) { static const uint8_t lentab[4] = { 0, 2, 0, 1 }; unsigned int byte = *buf++, av_uninit(offset); unsigned int code = byte >> 6; unsigned int length = byte & ~0xC0; if (buf >= buf_end) { av_log(avctx, AV_LOG_ERROR, "Input resolution larger than actual frame.\n"); return -1; } if (length == 0) { if (code == 1) { length = bytestream_get_byte(&buf); offset = bytestream_get_le16(&buf); } else { length = bytestream_get_le16(&buf); if (code == 2 && length == 0) break; } } else { if (code == 1) offset = bytestream_get_byte(&buf); } if (dst + (length << lentab[code]) > frame_end) break; switch (code) { case 0: if (length >= buf_end - buf) { av_log(avctx, AV_LOG_ERROR, "Frame larger than buffer.\n"); return -1; } bytestream_get_buffer(&buf, dst, length); dst += length; break; case 1: dst_offset = dst - offset; length *= 4; if (dst_offset < [[bfi]]->dst) break; while (length--) *dst++ = *dst_offset++; break; case 2: dst += length; break; case 3: colour1 = bytestream_get_byte(&buf); colour2 = bytestream_get_byte(&buf); while (length--) { *dst++ = colour1; *dst++ = colour2; } break; } } src = [[bfi]]->dst; dst = [[bfi]]->frame.data[0]; while (height--) { memcpy(dst, src, avctx->width); src += avctx->width; dst += [[bfi]]->frame.linesize[0]; } *data_size = sizeof(AVFrame); *(AVFrame *)data = [[bfi]]->frame; return buf_size; }

[[[[Adv]]]]: static int bfi_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size; int buf_size = avpkt->size; BFIContext *[[gsи]] = avctx->priv_data; uint8_t *dst = [[gsи]]->dst; uint8_t *src, *dst_offset, colour1, colour2; uint8_t *frame_end = [[gsи]]->dst + avctx->width * avctx->height; uint32_t *pal; int i, j, height = avctx->height; if ([[gsи]]->frame.data[0]) avctx->release_buffer(avctx, &[[gsи]]->frame); [[gsи]]->frame.reference = 1; if (avctx->get_buffer(avctx, &[[gsи]]->frame) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } if (!avctx->frame_number) { [[gsи]]->frame.pict_type = AV_PICTURE_TYPE_I; [[gsи]]->frame.key_frame = 1; if (avctx->extradata_size > 768) { av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n"); return -1; } pal = (uint32_t *)[[gsи]]->frame.data[1]; for (i = 0; i < avctx->extradata_size / 3; i++) { int shift = 16; *pal = 0; for (j = 0; j < 3; j++, shift -= 8) *pal += ((avctx->extradata[i * 3 + j] << 2) | (avctx->extradata[i * 3 + j] >> 4)) << shift; pal++; } [[gsи]]->frame.palette_has_changed = 1; } else { [[gsи]]->frame.pict_type = AV_PICTURE_TYPE_P; [[gsи]]->frame.key_frame = 0; } buf += 4; while (dst != frame_end) { static const uint8_t lentab[4] = { 0, 2, 0, 1 }; unsigned int byte = *buf++, av_uninit(offset); unsigned int code = byte >> 6; unsigned int length = byte & ~0xC0; if (buf >= buf_end) { av_log(avctx, AV_LOG_ERROR, "Input resolution larger than actual frame.\n"); return -1; } if (length == 0) { if (code == 1) { length = bytestream_get_byte(&buf); offset = bytestream_get_le16(&buf); } else { length = bytestream_get_le16(&buf); if (code == 2 && length == 0) break; } } else { if (code == 1) offset = bytestream_get_byte(&buf); } if (dst + (length << lentab[code]) > frame_end) break; switch (code) { case 0: if (length >= buf_end - buf) { av_log(avctx, AV_LOG_ERROR, "Frame larger than buffer.\n"); return -1; } bytestream_get_buffer(&buf, dst, length); dst += length; break; case 1: dst_offset = dst - offset; length *= 4; if (dst_offset < [[gsи]]->dst) break; while (length--) *dst++ = *dst_offset++; break; case 2: dst += length; break; case 3: colour1 = bytestream_get_byte(&buf); colour2 = bytestream_get_byte(&buf); while (length--) { *dst++ = colour1; *dst++ = colour2; } break; } } src = [[gsи]]->dst; dst = [[gsи]]->frame.data[0]; while (height--) { memcpy(dst, src, avctx->width); src += avctx->width; dst += [[gsи]]->frame.linesize[0]; } *data_size = sizeof(AVFrame); *(AVFrame *)data = [[gsи]]->frame; return buf_size; }
--------------------------------------------- Result 54 ---------------------------------------------
[[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int write_f(int argc, char **argv) { struct timeval t1, t2; int Cflag = 0, pflag = 0, qflag = 0, bflag = 0; int c, cnt; char *buf; int64_t offset; int count; int total = 0; int pattern = 0xcd; while ((c = getopt(argc, argv, "bCpP:q")) != EOF) { switch (c) { case 'b': bflag = 1; break; case 'C': Cflag = 1; break; case 'p': pflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'q': qflag = 1; break; default: return command_usage(&write_cmd); } } if (optind != argc - 2) { return command_usage(&write_cmd); } if (bflag && pflag) { printf("-b and -p cannot be specified at the same time\n"); return 0; } offset = cvtnum(argv[optind]); if (offset < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; count = cvtnum(argv[optind]); if (count < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } if (!pflag) { if (offset & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } } buf = qemu_io_alloc(count, pattern); gettimeofday(&t1, NULL); if (pflag) { cnt = do_pwrite(buf, offset, count, &total); } else if (bflag) { cnt = do_save_vmstate(buf, offset, count, &total); } else { cnt = do_write(buf, offset, count, &total); } gettimeofday(&t2, NULL); if (cnt < 0) { printf("write failed: %s\n", strerror(-cnt)); goto out; } if (qflag) { goto out; } t2 = tsub(t2, t1); print_report("wrote", &t2, offset, count, total, cnt, Cflag); out: qemu_io_free(buf); return 0; }
--------------------------------------------- Result 55 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 6 / 24 / 55:   2%|▏         | 55/2690 [07:24<5:55:00,  8.08s/it][Succeeded / Failed / Skipped / Total] 25 / 6 / 24 / 55:   2%|▏         | 56/2690 [07:25<5:48:55,  7.95s/it][[0 (64%)]] --> [[0 (47%)]] --> Socre: 0.5320766568183899

[[[[Adv]]]]: static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame, unsigned int [[c]], const unsigned int *div_blocks, unsigned int *js_blocks) { ALSSpecificConfig *[[sconf]] = &ctx->sconf; unsigned int offset = 0; unsigned int b; ALSBlockData bd[2] = { { 0 } }; bd[0].ra_block = ra_frame; bd[0].const_block = ctx->const_block; bd[0].shift_lsbs = ctx->shift_lsbs; bd[0].opt_order = ctx->opt_order; bd[0].store_prev_samples = ctx->store_prev_samples; bd[0].use_ltp = ctx->use_ltp; bd[0].ltp_lag = ctx->ltp_lag; bd[0].ltp_gain = ctx->ltp_gain[0]; bd[0].quant_cof = ctx->quant_cof[0]; bd[0].lpc_cof = ctx->lpc_cof[0]; bd[0].prev_raw_samples = ctx->prev_raw_samples; bd[0].js_blocks = *js_blocks; bd[1].ra_block = ra_frame; bd[1].const_block = ctx->const_block; bd[1].shift_lsbs = ctx->shift_lsbs; bd[1].opt_order = ctx->opt_order; bd[1].store_prev_samples = ctx->store_prev_samples; bd[1].use_ltp = ctx->use_ltp; bd[1].ltp_lag = ctx->ltp_lag; bd[1].ltp_gain = ctx->ltp_gain[0]; bd[1].quant_cof = ctx->quant_cof[0]; bd[1].lpc_cof = ctx->lpc_cof[0]; bd[1].prev_raw_samples = ctx->prev_raw_samples; bd[1].js_blocks = *(js_blocks + 1); for (b = 0; b < ctx->num_blocks; b++) { unsigned int s; bd[0].block_length = div_blocks[b]; bd[1].block_length = div_blocks[b]; bd[0].raw_samples = ctx->raw_samples[[[c]] ] + offset; bd[1].raw_samples = ctx->raw_samples[[[c]] + 1] + offset; bd[0].raw_other = bd[1].raw_samples; bd[1].raw_other = bd[0].raw_samples; if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) { zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples); zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples); return -1; } if (bd[0].js_blocks) { if (bd[1].js_blocks) av_log(ctx->avctx, AV_LOG_WARNING, "Invalid channel pair!\n"); for (s = 0; s < div_blocks[b]; s++) bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s]; } else if (bd[1].js_blocks) { for (s = 0; s < div_blocks[b]; s++) bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s]; } offset += div_blocks[b]; bd[0].ra_block = 0; bd[1].ra_block = 0; } memmove(ctx->raw_samples[[[c]]] - [[sconf]]->max_order, ctx->raw_samples[[[c]]] - [[sconf]]->max_order + [[sconf]]->frame_length, sizeof(*ctx->raw_samples[[[c]]]) * [[sconf]]->max_order); return 0; }

[[[[Adv]]]]: static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame, unsigned int [[flag]], const unsigned int *div_blocks, unsigned int *js_blocks) { ALSSpecificConfig *[[saonofat]] = &ctx->sconf; unsigned int offset = 0; unsigned int b; ALSBlockData bd[2] = { { 0 } }; bd[0].ra_block = ra_frame; bd[0].const_block = ctx->const_block; bd[0].shift_lsbs = ctx->shift_lsbs; bd[0].opt_order = ctx->opt_order; bd[0].store_prev_samples = ctx->store_prev_samples; bd[0].use_ltp = ctx->use_ltp; bd[0].ltp_lag = ctx->ltp_lag; bd[0].ltp_gain = ctx->ltp_gain[0]; bd[0].quant_cof = ctx->quant_cof[0]; bd[0].lpc_cof = ctx->lpc_cof[0]; bd[0].prev_raw_samples = ctx->prev_raw_samples; bd[0].js_blocks = *js_blocks; bd[1].ra_block = ra_frame; bd[1].const_block = ctx->const_block; bd[1].shift_lsbs = ctx->shift_lsbs; bd[1].opt_order = ctx->opt_order; bd[1].store_prev_samples = ctx->store_prev_samples; bd[1].use_ltp = ctx->use_ltp; bd[1].ltp_lag = ctx->ltp_lag; bd[1].ltp_gain = ctx->ltp_gain[0]; bd[1].quant_cof = ctx->quant_cof[0]; bd[1].lpc_cof = ctx->lpc_cof[0]; bd[1].prev_raw_samples = ctx->prev_raw_samples; bd[1].js_blocks = *(js_blocks + 1); for (b = 0; b < ctx->num_blocks; b++) { unsigned int s; bd[0].block_length = div_blocks[b]; bd[1].block_length = div_blocks[b]; bd[0].raw_samples = ctx->raw_samples[[[flag]] ] + offset; bd[1].raw_samples = ctx->raw_samples[[[flag]] + 1] + offset; bd[0].raw_other = bd[1].raw_samples; bd[1].raw_other = bd[0].raw_samples; if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) { zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples); zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples); return -1; } if (bd[0].js_blocks) { if (bd[1].js_blocks) av_log(ctx->avctx, AV_LOG_WARNING, "Invalid channel pair!\n"); for (s = 0; s < div_blocks[b]; s++) bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s]; } else if (bd[1].js_blocks) { for (s = 0; s < div_blocks[b]; s++) bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s]; } offset += div_blocks[b]; bd[0].ra_block = 0; bd[1].ra_block = 0; } memmove(ctx->raw_samples[[[flag]]] - [[saonofat]]->max_order, ctx->raw_samples[[[flag]]] - [[saonofat]]->max_order + [[saonofat]]->frame_length, sizeof(*ctx->raw_samples[[[flag]]]) * [[saonofat]]->max_order); return 0; }
--------------------------------------------- Result 56 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 6 / 25 / 56:   2%|▏         | 56/2690 [07:25<5:48:55,  7.95s/it][Succeeded / Failed / Skipped / Total] 25 / 6 / 25 / 56:   2%|▏         | 57/2690 [07:25<5:43:04,  7.82s/it][Succeeded / Failed / Skipped / Total] 25 / 6 / 26 / 57:   2%|▏         | 57/2690 [07:25<5:43:04,  7.82s/it][Succeeded / Failed / Skipped / Total] 25 / 6 / 26 / 57:   2%|▏         | 58/2690 [07:35<5:44:28,  7.85s/it][[0 (98%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void build_feed_streams(void) { FFStream *stream, *feed; int i; for(stream = first_stream; stream != NULL; stream = stream->next) { feed = stream->feed; if (feed) { if (!stream->is_feed) { for(i=0;i<stream->nb_streams;i++) stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]); } } } for(stream = first_stream; stream != NULL; stream = stream->next) { feed = stream->feed; if (feed) { if (stream->is_feed) { for(i=0;i<stream->nb_streams;i++) stream->feed_streams[i] = i; } } } for(feed = first_feed; feed != NULL; feed = feed->next_feed) { int fd; if (url_exist(feed->feed_filename)) { AVFormatContext *s; int matches = 0; if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) { if (s->nb_streams == feed->nb_streams) { matches = 1; for(i=0;i<s->nb_streams;i++) { AVStream *sf, *ss; sf = feed->streams[i]; ss = s->streams[i]; if (sf->index != ss->index || sf->id != ss->id) { http_log("Index & Id do not match for stream %d (%s)\n", i, feed->feed_filename); matches = 0; } else { AVCodecContext *ccf, *ccs; ccf = sf->codec; ccs = ss->codec; #define CHECK_CODEC(x) (ccf->x != ccs->x) if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) { http_log("Codecs do not match for stream %d\n", i); matches = 0; } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) { http_log("Codec bitrates do not match for stream %d\n", i); matches = 0; } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) { if (CHECK_CODEC(time_base.den) || CHECK_CODEC(time_base.num) || CHECK_CODEC(width) || CHECK_CODEC(height)) { http_log("Codec width, height and framerate do not match for stream %d\n", i); matches = 0; } } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) { if (CHECK_CODEC(sample_rate) || CHECK_CODEC(channels) || CHECK_CODEC(frame_size)) { http_log("Codec sample_rate, channels, frame_size do not match for stream %d\n", i); matches = 0; } } else { http_log("Unknown codec type\n"); matches = 0; } } if (!matches) break; } } else http_log("Deleting feed file '%s' as stream counts differ (%d != %d)\n", feed->feed_filename, s->nb_streams, feed->nb_streams); av_close_input_file(s); } else http_log("Deleting feed file '%s' as it appears to be corrupt\n", feed->feed_filename); if (!matches) { if (feed->readonly) { http_log("Unable to delete feed file '%s' as it is marked readonly\n", feed->feed_filename); exit(1); } unlink(feed->feed_filename); } } if (!url_exist(feed->feed_filename)) { AVFormatContext s1 = {0}, *s = &s1; if (feed->readonly) { http_log("Unable to create feed file '%s' as it is marked readonly\n", feed->feed_filename); exit(1); } if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) { http_log("Could not open output feed file '%s'\n", feed->feed_filename); exit(1); } s->oformat = feed->fmt; s->nb_streams = feed->nb_streams; for(i=0;i<s->nb_streams;i++) { AVStream *st; st = feed->streams[i]; s->streams[i] = st; } av_set_parameters(s, NULL); if (av_write_header(s) < 0) { http_log("Container doesn't supports the required parameters\n"); exit(1); } av_freep(&s->priv_data); avio_close(s->pb); } fd = open(feed->feed_filename, O_RDONLY); if (fd < 0) { http_log("Could not open output feed file '%s'\n", feed->feed_filename); exit(1); } feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE); feed->feed_size = lseek(fd, 0, SEEK_END); if (feed->feed_max_size && feed->feed_max_size < feed->feed_size) feed->feed_max_size = feed->feed_size; close(fd); } }
--------------------------------------------- Result 57 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_interrupt64(CPUX86State *env, int intno, int is_int, int error_code, target_ulong next_eip, int is_hw) { SegmentCache *dt; target_ulong ptr; int type, dpl, selector, cpl, ist; int has_error_code, new_stack; uint32_t e1, e2, e3, ss; target_ulong old_eip, esp, offset; has_error_code = 0; if (!is_int && !is_hw) { has_error_code = exception_has_error_code(intno); } if (is_int) { old_eip = next_eip; } else { old_eip = env->eip; } dt = &env->idt; if (intno * 16 + 15 > dt->limit) { raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); } ptr = dt->base + intno * 16; e1 = cpu_ldl_kernel(env, ptr); e2 = cpu_ldl_kernel(env, ptr + 4); e3 = cpu_ldl_kernel(env, ptr + 8); type = (e2 >> DESC_TYPE_SHIFT) & 0x1f; switch (type) { case 14: case 15: break; default: raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); break; } dpl = (e2 >> DESC_DPL_SHIFT) & 3; cpl = env->hflags & HF_CPL_MASK; if (is_int && dpl < cpl) { raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); } if (!(e2 & DESC_P_MASK)) { raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2); } selector = e1 >> 16; offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff); ist = e2 & 7; if ((selector & 0xfffc) == 0) { raise_exception_err(env, EXCP0D_GPF, 0); } if (load_segment(env, &e1, &e2, selector) != 0) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } dpl = (e2 >> DESC_DPL_SHIFT) & 3; if (dpl > cpl) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if (!(e2 & DESC_P_MASK)) { raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc); } if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) { new_stack = 1; esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl); ss = 0; } else if ((e2 & DESC_C_MASK) || dpl == cpl) { if (env->eflags & VM_MASK) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } new_stack = 0; esp = env->regs[R_ESP]; dpl = cpl; } else { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); new_stack = 0; esp = 0; } esp &= ~0xfLL; PUSHQ(esp, env->segs[R_SS].selector); PUSHQ(esp, env->regs[R_ESP]); PUSHQ(esp, cpu_compute_eflags(env)); PUSHQ(esp, env->segs[R_CS].selector); PUSHQ(esp, old_eip); if (has_error_code) { PUSHQ(esp, error_code); } if ((type & 1) == 0) { env->eflags &= ~IF_MASK; } env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK); if (new_stack) { ss = 0 | dpl; cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0); } env->regs[R_ESP] = esp; selector = (selector & ~3) | dpl; cpu_x86_load_seg_cache(env, R_CS, selector, get_seg_base(e1, e2), get_seg_limit(e1, e2), e2); env->eip = offset; }
--------------------------------------------- Result 58 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 6 / 26 / 58:   2%|▏         | 58/2690 [07:35<5:44:28,  7.85s/it][Succeeded / Failed / Skipped / Total] 26 / 6 / 26 / 58:   2%|▏         | 59/2690 [07:36<5:38:54,  7.73s/it][Succeeded / Failed / Skipped / Total] 26 / 6 / 27 / 59:   2%|▏         | 59/2690 [07:36<5:38:54,  7.73s/it][Succeeded / Failed / Skipped / Total] 26 / 6 / 27 / 59:   2%|▏         | 60/2690 [07:36<5:33:31,  7.61s/it][Succeeded / Failed / Skipped / Total] 26 / 6 / 28 / 60:   2%|▏         | 60/2690 [07:36<5:33:31,  7.61s/it][Succeeded / Failed / Skipped / Total] 26 / 6 / 28 / 60:   2%|▏         | 61/2690 [07:42<5:32:28,  7.59s/it][Succeeded / Failed / Skipped / Total] 27 / 6 / 28 / 61:   2%|▏         | 61/2690 [07:42<5:32:28,  7.59s/it][Succeeded / Failed / Skipped / Total] 27 / 6 / 28 / 61:   2%|▏         | 62/2690 [07:50<5:32:35,  7.59s/it][[0 (61%)]] --> [[0 (22%)]] --> Socre: 0.7774933129549026

[[[[Adv]]]]: static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *[[frame]], opj_image_t *image) { int compno; int x, y; int *image_line; int frame_index; const int [[numcomps]] = image->numcomps; uint16_t *frame_ptr = (uint16_t *)[[frame]]->data[0]; for (compno = 0; compno < [[numcomps]]; ++compno) { if (image->comps[compno].w > [[frame]]->linesize[0] / [[numcomps]]) { av_log(avctx, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n"); return 0; } } for (compno = 0; compno < [[numcomps]]; ++compno) { for (y = 0; y < avctx->height; ++y) { image_line = image->comps[compno].data + y * image->comps[compno].w; frame_index = y * ([[frame]]->linesize[0] / 2) + compno; for (x = 0; x < avctx->width; ++x) { image_line[x] = frame_ptr[frame_index] >> 4; frame_index += [[numcomps]]; } for (; x < image->comps[compno].w; ++x) { image_line[x] = image_line[x - 1]; } } for (; y < image->comps[compno].h; ++y) { image_line = image->comps[compno].data + y * image->comps[compno].w; for (x = 0; x < image->comps[compno].w; ++x) { image_line[x] = image_line[x - image->comps[compno].w]; } } } return 1; }

[[[[Adv]]]]: static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *[[clock]], opj_image_t *image) { int compno; int x, y; int *image_line; int frame_index; const int [[simonicc]] = image->numcomps; uint16_t *frame_ptr = (uint16_t *)[[clock]]->data[0]; for (compno = 0; compno < [[simonicc]]; ++compno) { if (image->comps[compno].w > [[clock]]->linesize[0] / [[simonicc]]) { av_log(avctx, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n"); return 0; } } for (compno = 0; compno < [[simonicc]]; ++compno) { for (y = 0; y < avctx->height; ++y) { image_line = image->comps[compno].data + y * image->comps[compno].w; frame_index = y * ([[clock]]->linesize[0] / 2) + compno; for (x = 0; x < avctx->width; ++x) { image_line[x] = frame_ptr[frame_index] >> 4; frame_index += [[simonicc]]; } for (; x < image->comps[compno].w; ++x) { image_line[x] = image_line[x - 1]; } } for (; y < image->comps[compno].h; ++y) { image_line = image->comps[compno].data + y * image->comps[compno].w; for (x = 0; x < image->comps[compno].w; ++x) { image_line[x] = image_line[x - image->comps[compno].w]; } } } return 1; }
--------------------------------------------- Result 59 ---------------------------------------------
[[0 (70%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void codeblock(DiracContext *s, SubBand *b, GetBitContext *gb, DiracArith *c, int left, int right, int top, int bottom, int blockcnt_one, int is_arith) { int x, y, zero_block; int qoffset, qfactor; IDWTELEM *buf; if (!blockcnt_one) { if (is_arith) zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK); else zero_block = get_bits1(gb); if (zero_block) return; } if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) { if (is_arith) b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA); else b->quant += dirac_get_se_golomb(gb); } b->quant = FFMIN(b->quant, MAX_QUANT); qfactor = qscale_tab[b->quant]; if (!s->num_refs) qoffset = qoffset_intra_tab[b->quant]; else qoffset = qoffset_inter_tab[b->quant]; buf = b->ibuf + top * b->stride; for (y = top; y < bottom; y++) { for (x = left; x < right; x++) { if (is_arith) coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y); else buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset); } buf += b->stride; } }
--------------------------------------------- Result 60 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){ FFV1Context *f = avctx->priv_data; CABACContext * const c= &f->c; AVFrame *pict = data; const int width= f->width; const int height= f->height; AVFrame * const p= &f->picture; int used_count= 0; if(avctx->strict_std_compliance >= 0){ av_log(avctx, AV_LOG_ERROR, "this codec is under development, files encoded with it wont be decodeable with future versions!!!\n" "use vstrict=-1 to use it anyway\n"); return -1; } ff_init_cabac_encoder(c, buf, buf_size); ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64); c->lps_state[2] = 1; c->lps_state[3] = 0; *p = *pict; p->pict_type= FF_I_TYPE; if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){ put_cabac_bypass(c, 1); p->key_frame= 1; write_header(f); clear_state(f); }else{ put_cabac_bypass(c, 0); p->key_frame= 0; } if(!f->ac){ used_count += put_cabac_terminate(c, 1); init_put_bits(&f->pb, buf + used_count, buf_size - used_count); } if(f->colorspace==0){ const int chroma_width = -((-width )>>f->chroma_h_shift); const int chroma_height= -((-height)>>f->chroma_v_shift); encode_plane(f, p->data[0], width, height, p->linesize[0], 0); encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1); encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1); }else{ encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4); } emms_c(); f->picture_number++; if(f->ac){ return put_cabac_terminate(c, 1); }else{ flush_put_bits(&f->pb); return used_count + (put_bits_count(&f->pb)+7)/8; } }
--------------------------------------------- Result 61 ---------------------------------------------
[[0 (75%)]] --> [[0 (44%)]] --> Socre: 0.5551082193851471

[[[[Adv]]]]: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *[[pkt]], const void *pkt_data, size_t [[pkt_len]]) { struct virtio_net_hdr *vhdr; bool [[isip4]], isip6, istcp, isudp; uint8_t *[[data]]; int len; if (!vmxnet_rx_pkt_has_virt_hdr([[pkt]])) { return; } vhdr = vmxnet_rx_pkt_get_vhdr([[pkt]]); if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) { return; } vmxnet_rx_pkt_get_protocols([[pkt]], &[[isip4]], &isip6, &isudp, &istcp); if (!([[isip4]] || isip6) || !(istcp || isudp)) { return; } vmxnet3_dump_virt_hdr(vhdr); if ([[pkt_len]] < (vhdr->csum_start + vhdr->csum_offset + 2)) { VMW_PKPRN("packet len:%d < csum_start(%d) + csum_offset(%d) + 2, " "cannot calculate checksum", len, vhdr->csum_start, vhdr->csum_offset); return; } [[data]] = (uint8_t *)pkt_data + vhdr->csum_start; len = [[pkt_len]] - vhdr->csum_start; stw_be_p([[data]] + vhdr->csum_offset, net_raw_checksum([[data]], len)); vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM; vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID; }

[[[[Adv]]]]: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *[[veyp]], const void *pkt_data, size_t [[plg2reg]]) { struct virtio_net_hdr *vhdr; bool [[wastp3]], isip6, istcp, isudp; uint8_t *[[park]]; int len; if (!vmxnet_rx_pkt_has_virt_hdr([[veyp]])) { return; } vhdr = vmxnet_rx_pkt_get_vhdr([[veyp]]); if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) { return; } vmxnet_rx_pkt_get_protocols([[veyp]], &[[wastp3]], &isip6, &isudp, &istcp); if (!([[wastp3]] || isip6) || !(istcp || isudp)) { return; } vmxnet3_dump_virt_hdr(vhdr); if ([[plg2reg]] < (vhdr->csum_start + vhdr->csum_offset + 2)) { VMW_PKPRN("packet len:%d < csum_start(%d) + csum_offset(%d) + 2, " "cannot calculate checksum", len, vhdr->csum_start, vhdr->csum_offset); return; } [[park]] = (uint8_t *)pkt_data + vhdr->csum_start; len = [[plg2reg]] - vhdr->csum_start; stw_be_p([[park]] + vhdr->csum_offset, net_raw_checksum([[park]], len)); vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM; vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID; }
--------------------------------------------- Result 62 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 28 / 6 / 28 / 62:   2%|▏         | 62/2690 [07:50<5:32:35,  7.59s/it][Succeeded / Failed / Skipped / Total] 28 / 6 / 28 / 62:   2%|▏         | 63/2690 [07:59<5:33:08,  7.61s/it][Succeeded / Failed / Skipped / Total] 28 / 7 / 28 / 63:   2%|▏         | 63/2690 [07:59<5:33:08,  7.61s/it][Succeeded / Failed / Skipped / Total] 28 / 7 / 28 / 63:   2%|▏         | 64/2690 [08:11<5:36:22,  7.69s/it][Succeeded / Failed / Skipped / Total] 29 / 7 / 28 / 64:   2%|▏         | 64/2690 [08:11<5:36:22,  7.69s/it][Succeeded / Failed / Skipped / Total] 29 / 7 / 28 / 64:   2%|▏         | 65/2690 [08:12<5:31:25,  7.58s/it][Succeeded / Failed / Skipped / Total] 29 / 7 / 29 / 65:   2%|▏         | 65/2690 [08:12<5:31:25,  7.58s/it][Succeeded / Failed / Skipped / Total] 29 / 7 / 29 / 65:   2%|▏         | 66/2690 [08:25<5:35:05,  7.66s/it][Succeeded / Failed / Skipped / Total] 30 / 7 / 29 / 66:   2%|▏         | 66/2690 [08:25<5:35:05,  7.66s/it][Succeeded / Failed / Skipped / Total] 30 / 7 / 29 / 66:   2%|▏         | 67/2690 [08:39<5:39:17,  7.76s/it][[0 (92%)]] --> [[0 (43%)]] --> Socre: 0.5677136778831482

[[[[Adv]]]]: void palette8tobgr24(const uint8_t *src, uint8_t *[[dst]], long num_pixels, const uint8_t *palette) { long i; for(i=0; i<num_pixels; i++) { [[dst]][0]= palette[ src[i]*4+0 ]; [[dst]][1]= palette[ src[i]*4+1 ]; [[dst]][2]= palette[ src[i]*4+2 ]; [[dst]]+= 3; } }

[[[[Adv]]]]: void palette8tobgr24(const uint8_t *src, uint8_t *[[daiflat]], long num_pixels, const uint8_t *palette) { long i; for(i=0; i<num_pixels; i++) { [[daiflat]][0]= palette[ src[i]*4+0 ]; [[daiflat]][1]= palette[ src[i]*4+1 ]; [[daiflat]][2]= palette[ src[i]*4+2 ]; [[daiflat]]+= 3; } }
--------------------------------------------- Result 63 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void do_POWER_maskg (void) { uint32_t [[ret]]; if ((uint32_t)T0 == (uint32_t)(T1 + 1)) { [[ret]] = -1; } else { [[ret]] = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^ (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1); if ((uint32_t)T0 > (uint32_t)T1) [[ret]] = ~[[ret]]; } T0 = [[ret]]; }

[[[[Adv]]]]: void do_POWER_maskg (void) { uint32_t [[protta]]; if ((uint32_t)T0 == (uint32_t)(T1 + 1)) { [[protta]] = -1; } else { [[protta]] = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^ (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1); if ((uint32_t)T0 > (uint32_t)T1) [[protta]] = ~[[protta]]; } T0 = [[protta]]; }
--------------------------------------------- Result 64 ---------------------------------------------
[[0 (56%)]] --> [[0 (44%)]] --> Socre: 0.5629507601261139

[[[[Adv]]]]: static void qed_aio_read_data(void *opaque, int ret, uint64_t offset, size_t len) { QEDAIOCB *[[acb]] = opaque; BDRVQEDState *s = acb_to_s([[acb]]); BlockDriverState *bs = [[acb]]->common.bs; offset += qed_offset_into_cluster(s, [[acb]]->cur_pos); trace_qed_aio_read_data(s, [[acb]], ret, offset, len); if (ret < 0) { goto err; } qemu_iovec_concat(&[[acb]]->cur_qiov, [[acb]]->qiov, [[acb]]->qiov_offset, len); if (ret == QED_CLUSTER_ZERO) { qemu_iovec_memset(&[[acb]]->cur_qiov, 0, 0, [[acb]]->cur_qiov.size); qed_aio_next_io([[acb]], 0); return; } else if (ret != QED_CLUSTER_FOUND) { qed_read_backing_file(s, [[acb]]->cur_pos, &[[acb]]->cur_qiov, qed_aio_next_io, [[acb]]); return; } BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO); bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE, &[[acb]]->cur_qiov, [[acb]]->cur_qiov.size / BDRV_SECTOR_SIZE, qed_aio_next_io, [[acb]]); return; err: qed_aio_complete([[acb]], ret); }

[[[[Adv]]]]: static void qed_aio_read_data(void *opaque, int ret, uint64_t offset, size_t len) { QEDAIOCB *[[opc]] = opaque; BDRVQEDState *s = acb_to_s([[opc]]); BlockDriverState *bs = [[opc]]->common.bs; offset += qed_offset_into_cluster(s, [[opc]]->cur_pos); trace_qed_aio_read_data(s, [[opc]], ret, offset, len); if (ret < 0) { goto err; } qemu_iovec_concat(&[[opc]]->cur_qiov, [[opc]]->qiov, [[opc]]->qiov_offset, len); if (ret == QED_CLUSTER_ZERO) { qemu_iovec_memset(&[[opc]]->cur_qiov, 0, 0, [[opc]]->cur_qiov.size); qed_aio_next_io([[opc]], 0); return; } else if (ret != QED_CLUSTER_FOUND) { qed_read_backing_file(s, [[opc]]->cur_pos, &[[opc]]->cur_qiov, qed_aio_next_io, [[opc]]); return; } BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO); bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE, &[[opc]]->cur_qiov, [[opc]]->cur_qiov.size / BDRV_SECTOR_SIZE, qed_aio_next_io, [[opc]]); return; err: qed_aio_complete([[opc]], ret); }
--------------------------------------------- Result 65 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset, sPAPRPHBState *sphb) { ResourceProps rp; bool is_bridge = "False" != "False"; int pci_status, err; char *buf = NULL; uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev); uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3); uint32_t max_msi, max_msix; if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) == PCI_HEADER_TYPE_BRIDGE) { is_bridge = "True" == "True"; } _FDT(fdt_setprop_cell(fdt, offset, "vendor-id", pci_default_read_config(dev, PCI_VENDOR_ID, 2))); _FDT(fdt_setprop_cell(fdt, offset, "device-id", pci_default_read_config(dev, PCI_DEVICE_ID, 2))); _FDT(fdt_setprop_cell(fdt, offset, "revision-id", pci_default_read_config(dev, PCI_REVISION_ID, 1))); _FDT(fdt_setprop_cell(fdt, offset, "class-code", ccode)); if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) { _FDT(fdt_setprop_cell(fdt, offset, "interrupts", pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1))); } if (!is_bridge) { _FDT(fdt_setprop_cell(fdt, offset, "min-grant", pci_default_read_config(dev, PCI_MIN_GNT, 1))); _FDT(fdt_setprop_cell(fdt, offset, "max-latency", pci_default_read_config(dev, PCI_MAX_LAT, 1))); } if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) { _FDT(fdt_setprop_cell(fdt, offset, "subsystem-id", pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2))); } if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) { _FDT(fdt_setprop_cell(fdt, offset, "subsystem-vendor-id", pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2))); } _FDT(fdt_setprop_cell(fdt, offset, "cache-line-size", pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1))); pci_status = pci_default_read_config(dev, PCI_STATUS, 2); _FDT(fdt_setprop_cell(fdt, offset, "devsel-speed", PCI_STATUS_DEVSEL_MASK & pci_status)); if (pci_status & PCI_STATUS_FAST_BACK) { _FDT(fdt_setprop(fdt, offset, "fast-back-to-back", NULL, 0)); } if (pci_status & PCI_STATUS_66MHZ) { _FDT(fdt_setprop(fdt, offset, "66mhz-capable", NULL, 0)); } if (pci_status & PCI_STATUS_UDF) { _FDT(fdt_setprop(fdt, offset, "udf-supported", NULL, 0)); } _FDT(fdt_setprop_string(fdt, offset, "name", pci_find_device_name((ccode >> 16) & 0xff, (ccode >> 8) & 0xff, ccode & 0xff))); buf = spapr_phb_get_loc_code(sphb, dev); if (!buf) { error_report("Failed setting the ibm,loc-code"); return -1; } err = fdt_setprop_string(fdt, offset, "ibm,loc-code", buf); g_free(buf); if (err < 0) { return err; } if (drc_index) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,my-drc-index", drc_index)); } _FDT(fdt_setprop_cell(fdt, offset, "#address-cells", RESOURCE_CELLS_ADDRESS)); _FDT(fdt_setprop_cell(fdt, offset, "#size-cells", RESOURCE_CELLS_SIZE)); max_msi = msi_nr_vectors_allocated(dev); if (max_msi) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,req#msi", max_msi)); } max_msix = dev->msix_entries_nr; if (max_msix) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,req#msi-x", max_msix)); } populate_resource_props(dev, &rp); _FDT(fdt_setprop(fdt, offset, "reg", (uint8_t *)rp.reg, rp.reg_len)); _FDT(fdt_setprop(fdt, offset, "assigned-addresses", (uint8_t *)rp.assigned, rp.assigned_len)); if (sphb->pcie_ecs && pci_is_express(dev)) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,pci-config-space-type", 0x1)); } return 0; }
--------------------------------------------- Result 66 ---------------------------------------------
[[0 (74%)]] --> [[0 (35%)]] --> Socre: 0.6456533670425415

[[[[Adv]]]]: void tcp_start_incoming_migration(const char *host_port, Error **[[errp]]) { int s; s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, [[errp]]); if (s < 0) { return; } qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL, (void *)(intptr_t)s); }

[[[[Adv]]]]: void tcp_start_incoming_migration(const char *host_port, Error **[[actrs]]) { int s; s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, [[actrs]]); if (s < 0) { return; } qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL, (void *)(intptr_t)s); }
--------------------------------------------- Result 67 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 31 / 7 / 29 / 67:   2%|▏         | 67/2690 [08:39<5:39:17,  7.76s/it][Succeeded / Failed / Skipped / Total] 31 / 7 / 29 / 67:   3%|▎         | 68/2690 [08:40<5:34:29,  7.65s/it][Succeeded / Failed / Skipped / Total] 31 / 7 / 30 / 68:   3%|▎         | 68/2690 [08:40<5:34:29,  7.65s/it][Succeeded / Failed / Skipped / Total] 31 / 7 / 30 / 68:   3%|▎         | 69/2690 [08:51<5:36:17,  7.70s/it][[0 (100%)]] --> [[0 (26%)]] --> Socre: 0.738847941160202

[[[[Adv]]]]: static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb) { MLPHeaderInfo mh; int [[substr]], ret; if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0) return ret; if (mh.group1_bits == 0) { av_log(m->avctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n"); return AVERROR_INVALIDDATA; if (mh.group2_bits > mh.group1_bits) { av_log(m->avctx, AV_LOG_ERROR, "Channel group 2 cannot have more bits per sample than group 1.\n"); return AVERROR_INVALIDDATA; if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) { av_log(m->avctx, AV_LOG_ERROR, "Channel groups with differing sample rates are not currently supported.\n"); return AVERROR_INVALIDDATA; if (mh.group1_samplerate == 0) { av_log(m->avctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n"); return AVERROR_INVALIDDATA; if (mh.group1_samplerate > MAX_SAMPLERATE) { av_log(m->avctx, AV_LOG_ERROR, "Sampling rate %d is greater than the supported maximum (%d).\n", mh.group1_samplerate, MAX_SAMPLERATE); return AVERROR_INVALIDDATA; if (mh.access_unit_size > MAX_BLOCKSIZE) { av_log(m->avctx, AV_LOG_ERROR, "Block size %d is greater than the supported maximum (%d).\n", mh.access_unit_size, MAX_BLOCKSIZE); return AVERROR_INVALIDDATA; if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) { av_log(m->avctx, AV_LOG_ERROR, "Block size pow2 %d is greater than the supported maximum (%d).\n", mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2); return AVERROR_INVALIDDATA; if (mh.num_substreams == 0) return AVERROR_INVALIDDATA; if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) { av_log(m->avctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n"); return AVERROR_INVALIDDATA; if (mh.num_substreams > MAX_SUBSTREAMS) { "%d substreams (more than the " "maximum supported by the decoder)", mh.num_substreams); m->access_unit_size = mh.access_unit_size; m->access_unit_size_pow2 = mh.access_unit_size_pow2; m->num_substreams = mh.num_substreams; m->max_decoded_substream = m->num_substreams - 1; m->avctx->sample_rate = mh.group1_samplerate; m->avctx->frame_size = mh.access_unit_size; m->avctx->bits_per_raw_sample = mh.group1_bits; if (mh.group1_bits > 16) m->avctx->sample_fmt = AV_SAMPLE_FMT_S32; else m->avctx->sample_fmt = AV_SAMPLE_FMT_S16; m->params_valid = 1; for ([[substr]] = 0; [[substr]] < MAX_SUBSTREAMS; [[substr]]++) m->substream[[[substr]]].restart_seen = 0; if (m->avctx->codec_id == AV_CODEC_ID_MLP) { if (([[substr]] = (mh.num_substreams > 1))) m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; m->substream[[[substr]]].ch_layout = mh.channel_layout_mlp; } else { if (([[substr]] = (mh.num_substreams > 1))) m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; if (mh.num_substreams > 2) if (mh.channel_layout_thd_stream2) m->substream[2].ch_layout = mh.channel_layout_thd_stream2; else m->substream[2].ch_layout = mh.channel_layout_thd_stream1; m->substream[[[substr]]].ch_layout = mh.channel_layout_thd_stream1; if (m->avctx->channels<=2 && m->substream[[[substr]]].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) { av_log(m->avctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n"); m->max_decoded_substream = 0; if (m->avctx->channels==2) m->avctx->channel_layout = AV_CH_LAYOUT_STEREO; m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20; return 0;

[[[[Adv]]]]: static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb) { MLPHeaderInfo mh; int [[fractionsteр]], ret; if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0) return ret; if (mh.group1_bits == 0) { av_log(m->avctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n"); return AVERROR_INVALIDDATA; if (mh.group2_bits > mh.group1_bits) { av_log(m->avctx, AV_LOG_ERROR, "Channel group 2 cannot have more bits per sample than group 1.\n"); return AVERROR_INVALIDDATA; if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) { av_log(m->avctx, AV_LOG_ERROR, "Channel groups with differing sample rates are not currently supported.\n"); return AVERROR_INVALIDDATA; if (mh.group1_samplerate == 0) { av_log(m->avctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n"); return AVERROR_INVALIDDATA; if (mh.group1_samplerate > MAX_SAMPLERATE) { av_log(m->avctx, AV_LOG_ERROR, "Sampling rate %d is greater than the supported maximum (%d).\n", mh.group1_samplerate, MAX_SAMPLERATE); return AVERROR_INVALIDDATA; if (mh.access_unit_size > MAX_BLOCKSIZE) { av_log(m->avctx, AV_LOG_ERROR, "Block size %d is greater than the supported maximum (%d).\n", mh.access_unit_size, MAX_BLOCKSIZE); return AVERROR_INVALIDDATA; if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) { av_log(m->avctx, AV_LOG_ERROR, "Block size pow2 %d is greater than the supported maximum (%d).\n", mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2); return AVERROR_INVALIDDATA; if (mh.num_substreams == 0) return AVERROR_INVALIDDATA; if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) { av_log(m->avctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n"); return AVERROR_INVALIDDATA; if (mh.num_substreams > MAX_SUBSTREAMS) { "%d substreams (more than the " "maximum supported by the decoder)", mh.num_substreams); m->access_unit_size = mh.access_unit_size; m->access_unit_size_pow2 = mh.access_unit_size_pow2; m->num_substreams = mh.num_substreams; m->max_decoded_substream = m->num_substreams - 1; m->avctx->sample_rate = mh.group1_samplerate; m->avctx->frame_size = mh.access_unit_size; m->avctx->bits_per_raw_sample = mh.group1_bits; if (mh.group1_bits > 16) m->avctx->sample_fmt = AV_SAMPLE_FMT_S32; else m->avctx->sample_fmt = AV_SAMPLE_FMT_S16; m->params_valid = 1; for ([[fractionsteр]] = 0; [[fractionsteр]] < MAX_SUBSTREAMS; [[fractionsteр]]++) m->substream[[[fractionsteр]]].restart_seen = 0; if (m->avctx->codec_id == AV_CODEC_ID_MLP) { if (([[fractionsteр]] = (mh.num_substreams > 1))) m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; m->substream[[[fractionsteр]]].ch_layout = mh.channel_layout_mlp; } else { if (([[fractionsteр]] = (mh.num_substreams > 1))) m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; if (mh.num_substreams > 2) if (mh.channel_layout_thd_stream2) m->substream[2].ch_layout = mh.channel_layout_thd_stream2; else m->substream[2].ch_layout = mh.channel_layout_thd_stream1; m->substream[[[fractionsteр]]].ch_layout = mh.channel_layout_thd_stream1; if (m->avctx->channels<=2 && m->substream[[[fractionsteр]]].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) { av_log(m->avctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n"); m->max_decoded_substream = 0; if (m->avctx->channels==2) m->avctx->channel_layout = AV_CH_LAYOUT_STEREO; m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20; return 0;
--------------------------------------------- Result 68 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num, int nb_sectors, QEMUIOVector *qiov) { SheepdogAIOCB *acb; int ret; if (bs->growable && sector_num + nb_sectors > bs->total_sectors) { ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE); if (ret < 0) { return ret; } bs->total_sectors = sector_num + nb_sectors; } acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors); acb->aio_done_func = sd_write_done; acb->aiocb_type = AIOCB_WRITE_UDATA; ret = sd_co_rw_vector(acb); if (ret <= 0) { qemu_aio_release(acb); return ret; } qemu_coroutine_yield(); return acb->ret; }
--------------------------------------------- Result 69 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 32 / 7 / 30 / 69:   3%|▎         | 69/2690 [08:51<5:36:17,  7.70s/it][Succeeded / Failed / Skipped / Total] 32 / 7 / 30 / 69:   3%|▎         | 70/2690 [09:10<5:43:19,  7.86s/it][Succeeded / Failed / Skipped / Total] 33 / 7 / 30 / 70:   3%|▎         | 70/2690 [09:10<5:43:19,  7.86s/it][Succeeded / Failed / Skipped / Total] 33 / 7 / 30 / 70:   3%|▎         | 71/2690 [09:10<5:38:38,  7.76s/it][[0 (83%)]] --> [[0 (32%)]] --> Socre: 0.6754525303840637

[[[[Adv]]]]: static AVStream * init_stream(AVFormatContext *s) { BinDemuxContext *[[bin]] = s->priv_data; AVStream *st = avformat_new_stream(s, NULL); if (!st) return NULL; st->codec->codec_tag = 0; st->codec->codec_type = AVMEDIA_TYPE_VIDEO; if (![[bin]]->width) { st->codec->width = (80<<3); st->codec->height = (25<<4); } avpriv_set_pts_info(st, 60, [[bin]]->framerate.den, [[bin]]->framerate.num); [[bin]]->chars_per_frame = FFMAX(av_q2d(st->time_base) * [[bin]]->chars_per_frame, 1); return st; }

[[[[Adv]]]]: static AVStream * init_stream(AVFormatContext *s) { BinDemuxContext *[[spec]] = s->priv_data; AVStream *st = avformat_new_stream(s, NULL); if (!st) return NULL; st->codec->codec_tag = 0; st->codec->codec_type = AVMEDIA_TYPE_VIDEO; if (![[spec]]->width) { st->codec->width = (80<<3); st->codec->height = (25<<4); } avpriv_set_pts_info(st, 60, [[spec]]->framerate.den, [[spec]]->framerate.num); [[spec]]->chars_per_frame = FFMAX(av_q2d(st->time_base) * [[spec]]->chars_per_frame, 1); return st; }
--------------------------------------------- Result 70 ---------------------------------------------
[[0 (73%)]] --> [[0 (49%)]] --> Socre: 0.5103660821914673

[[[[Adv]]]]: int qcow2_update_header(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; QCowHeader *[[header]]; char *[[buf]]; size_t buflen = s->cluster_size; int ret; uint64_t total_size; uint32_t refcount_table_clusters; size_t header_length; Qcow2UnknownHeaderExtension *[[uext]]; [[buf]] = qemu_blockalign(bs, buflen); [[header]] = (QCowHeader*) [[buf]]; if (buflen < sizeof(*[[header]])) { ret = -ENOSPC; goto fail; } header_length = sizeof(*[[header]]) + s->unknown_header_fields_size; total_size = bs->total_sectors * BDRV_SECTOR_SIZE; refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3); *[[header]] = (QCowHeader) { .magic = cpu_to_be32(QCOW_MAGIC), .version = cpu_to_be32(s->qcow_version), .backing_file_offset = 0, .backing_file_size = 0, .cluster_bits = cpu_to_be32(s->cluster_bits), .size = cpu_to_be64(total_size), .crypt_method = cpu_to_be32(s->crypt_method_header), .l1_size = cpu_to_be32(s->l1_size), .l1_table_offset = cpu_to_be64(s->l1_table_offset), .refcount_table_offset = cpu_to_be64(s->refcount_table_offset), .refcount_table_clusters = cpu_to_be32(refcount_table_clusters), .nb_snapshots = cpu_to_be32(s->nb_snapshots), .snapshots_offset = cpu_to_be64(s->snapshots_offset), .incompatible_features = cpu_to_be64(s->incompatible_features), .compatible_features = cpu_to_be64(s->compatible_features), .autoclear_features = cpu_to_be64(s->autoclear_features), .refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT), .header_length = cpu_to_be32(header_length), }; switch (s->qcow_version) { case 2: ret = offsetof(QCowHeader, incompatible_features); break; case 3: ret = sizeof(*[[header]]); break; default: return -EINVAL; } [[buf]] += ret; buflen -= ret; memset([[buf]], 0, buflen); if (s->unknown_header_fields_size) { if (buflen < s->unknown_header_fields_size) { ret = -ENOSPC; goto fail; } memcpy([[buf]], s->unknown_header_fields, s->unknown_header_fields_size); [[buf]] += s->unknown_header_fields_size; buflen -= s->unknown_header_fields_size; } if (*bs->backing_format) { ret = header_ext_add([[buf]], QCOW2_EXT_MAGIC_BACKING_FORMAT, bs->backing_format, strlen(bs->backing_format), buflen); if (ret < 0) { goto fail; } [[buf]] += ret; buflen -= ret; } Qcow2Feature features[] = { }; ret = header_ext_add([[buf]], QCOW2_EXT_MAGIC_FEATURE_TABLE, features, sizeof(features), buflen); if (ret < 0) { goto fail; } [[buf]] += ret; buflen -= ret; QLIST_FOREACH([[uext]], &s->unknown_header_ext, next) { ret = header_ext_add([[buf]], [[uext]]->magic, [[uext]]->data, [[uext]]->len, buflen); if (ret < 0) { goto fail; } [[buf]] += ret; buflen -= ret; } ret = header_ext_add([[buf]], QCOW2_EXT_MAGIC_END, NULL, 0, buflen); if (ret < 0) { goto fail; } [[buf]] += ret; buflen -= ret; if (*bs->backing_file) { size_t backing_file_len = strlen(bs->backing_file); if (buflen < backing_file_len) { ret = -ENOSPC; goto fail; } strncpy([[buf]], bs->backing_file, buflen); [[header]]->backing_file_offset = cpu_to_be64([[buf]] - ((char*) [[header]])); [[header]]->backing_file_size = cpu_to_be32(backing_file_len); } ret = bdrv_pwrite(bs->file, 0, [[header]], s->cluster_size); if (ret < 0) { goto fail; } ret = 0; fail: qemu_vfree([[header]]); return ret; }

[[[[Adv]]]]: int qcow2_update_header(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; QCowHeader *[[highlight]]; char *[[lurf]]; size_t buflen = s->cluster_size; int ret; uint64_t total_size; uint32_t refcount_table_clusters; size_t header_length; Qcow2UnknownHeaderExtension *[[topetied]]; [[lurf]] = qemu_blockalign(bs, buflen); [[highlight]] = (QCowHeader*) [[lurf]]; if (buflen < sizeof(*[[highlight]])) { ret = -ENOSPC; goto fail; } header_length = sizeof(*[[highlight]]) + s->unknown_header_fields_size; total_size = bs->total_sectors * BDRV_SECTOR_SIZE; refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3); *[[highlight]] = (QCowHeader) { .magic = cpu_to_be32(QCOW_MAGIC), .version = cpu_to_be32(s->qcow_version), .backing_file_offset = 0, .backing_file_size = 0, .cluster_bits = cpu_to_be32(s->cluster_bits), .size = cpu_to_be64(total_size), .crypt_method = cpu_to_be32(s->crypt_method_header), .l1_size = cpu_to_be32(s->l1_size), .l1_table_offset = cpu_to_be64(s->l1_table_offset), .refcount_table_offset = cpu_to_be64(s->refcount_table_offset), .refcount_table_clusters = cpu_to_be32(refcount_table_clusters), .nb_snapshots = cpu_to_be32(s->nb_snapshots), .snapshots_offset = cpu_to_be64(s->snapshots_offset), .incompatible_features = cpu_to_be64(s->incompatible_features), .compatible_features = cpu_to_be64(s->compatible_features), .autoclear_features = cpu_to_be64(s->autoclear_features), .refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT), .header_length = cpu_to_be32(header_length), }; switch (s->qcow_version) { case 2: ret = offsetof(QCowHeader, incompatible_features); break; case 3: ret = sizeof(*[[highlight]]); break; default: return -EINVAL; } [[lurf]] += ret; buflen -= ret; memset([[lurf]], 0, buflen); if (s->unknown_header_fields_size) { if (buflen < s->unknown_header_fields_size) { ret = -ENOSPC; goto fail; } memcpy([[lurf]], s->unknown_header_fields, s->unknown_header_fields_size); [[lurf]] += s->unknown_header_fields_size; buflen -= s->unknown_header_fields_size; } if (*bs->backing_format) { ret = header_ext_add([[lurf]], QCOW2_EXT_MAGIC_BACKING_FORMAT, bs->backing_format, strlen(bs->backing_format), buflen); if (ret < 0) { goto fail; } [[lurf]] += ret; buflen -= ret; } Qcow2Feature features[] = { }; ret = header_ext_add([[lurf]], QCOW2_EXT_MAGIC_FEATURE_TABLE, features, sizeof(features), buflen); if (ret < 0) { goto fail; } [[lurf]] += ret; buflen -= ret; QLIST_FOREACH([[topetied]], &s->unknown_header_ext, next) { ret = header_ext_add([[lurf]], [[topetied]]->magic, [[topetied]]->data, [[topetied]]->len, buflen); if (ret < 0) { goto fail; } [[lurf]] += ret; buflen -= ret; } ret = header_ext_add([[lurf]], QCOW2_EXT_MAGIC_END, NULL, 0, buflen); if (ret < 0) { goto fail; } [[lurf]] += ret; buflen -= ret; if (*bs->backing_file) { size_t backing_file_len = strlen(bs->backing_file); if (buflen < backing_file_len) { ret = -ENOSPC; goto fail; } strncpy([[lurf]], bs->backing_file, buflen); [[highlight]]->backing_file_offset = cpu_to_be64([[lurf]] - ((char*) [[highlight]])); [[highlight]]->backing_file_size = cpu_to_be32(backing_file_len); } ret = bdrv_pwrite(bs->file, 0, [[highlight]], s->cluster_size); if (ret < 0) { goto fail; } ret = 0; fail: qemu_vfree([[highlight]]); return ret; }
--------------------------------------------- Result 71 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 7 / 31 / 71:   3%|▎         | 71/2690 [09:10<5:38:38,  7.76s/it][Succeeded / Failed / Skipped / Total] 33 / 7 / 31 / 71:   3%|▎         | 72/2690 [09:15<5:36:37,  7.71s/it][Succeeded / Failed / Skipped / Total] 34 / 7 / 31 / 72:   3%|▎         | 72/2690 [09:15<5:36:37,  7.71s/it][Succeeded / Failed / Skipped / Total] 34 / 7 / 31 / 72:   3%|▎         | 73/2690 [09:15<5:32:10,  7.62s/it][Succeeded / Failed / Skipped / Total] 34 / 7 / 32 / 73:   3%|▎         | 73/2690 [09:15<5:32:10,  7.62s/it][Succeeded / Failed / Skipped / Total] 34 / 7 / 32 / 73:   3%|▎         | 74/2690 [09:16<5:27:50,  7.52s/it][Succeeded / Failed / Skipped / Total] 34 / 7 / 33 / 74:   3%|▎         | 74/2690 [09:16<5:27:50,  7.52s/it][Succeeded / Failed / Skipped / Total] 34 / 7 / 33 / 74:   3%|▎         | 75/2690 [09:39<5:37:00,  7.73s/it][Succeeded / Failed / Skipped / Total] 35 / 7 / 33 / 75:   3%|▎         | 75/2690 [09:39<5:37:00,  7.73s/it][Succeeded / Failed / Skipped / Total] 35 / 7 / 33 / 75:   3%|▎         | 76/2690 [10:17<5:54:00,  8.13s/it][Succeeded / Failed / Skipped / Total] 36 / 7 / 33 / 76:   3%|▎         | 76/2690 [10:17<5:54:00,  8.13s/it][Succeeded / Failed / Skipped / Total] 36 / 7 / 33 / 76:   3%|▎         | 77/2690 [10:18<5:49:32,  8.03s/it][Succeeded / Failed / Skipped / Total] 36 / 7 / 34 / 77:   3%|▎         | 77/2690 [10:18<5:49:32,  8.03s/it][Succeeded / Failed / Skipped / Total] 36 / 7 / 34 / 77:   3%|▎         | 78/2690 [10:20<5:46:11,  7.95s/it][[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_write_data(SCSIRequest *req) { SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; assert(r->req.aiocb == NULL); scsi_req_ref(&r->req); if (r->req.cmd.mode != SCSI_XFER_TO_DEV) { DPRINTF("Data transfer direction invalid\n"); scsi_write_complete(r, -EINVAL); return; } if (!r->req.sg && !r->qiov.size) { r->started = "True" == "True"; scsi_write_complete(r, 0); return; } if (s->tray_open) { scsi_write_complete(r, -ENOMEDIUM); return; } if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 || r->req.cmd.buf[0] == VERIFY_16) { if (r->req.sg) { scsi_dma_complete(r, 0); } else { scsi_write_complete(r, 0); } return; } if (r->req.sg) { dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE); r->req.resid -= r->req.sg->size; r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector, scsi_dma_complete, r); } else { n = r->qiov.size / 512; bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE); r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n, scsi_write_complete, r); } }
--------------------------------------------- Result 72 ---------------------------------------------
[[0 (16%)]] --> [[0 (51%)]] --> Socre: 0.5078192353248596

[[[[Adv]]]]: static void device_initfn(Object *obj) { DeviceState *dev = DEVICE(obj); Property *[[prop]]; if (qdev_hotplug) { dev->hotplugged = 1; qdev_hot_added = "True" == "True"; } dev->instance_id_alias = -1; dev->state = DEV_STATE_CREATED; qdev_prop_set_defaults(dev, qdev_get_props(dev)); for ([[prop]] = qdev_get_props(dev); [[prop]] && [[prop]]->name; [[prop]]++) { qdev_property_add_legacy(dev, [[prop]], NULL); qdev_property_add_static(dev, [[prop]], NULL); } object_property_add_str(OBJECT(dev), "type", qdev_get_type, NULL, NULL); }

[[[[Adv]]]]: static void device_initfn(Object *obj) { DeviceState *dev = DEVICE(obj); Property *[[loft]]; if (qdev_hotplug) { dev->hotplugged = 1; qdev_hot_added = "True" == "True"; } dev->instance_id_alias = -1; dev->state = DEV_STATE_CREATED; qdev_prop_set_defaults(dev, qdev_get_props(dev)); for ([[loft]] = qdev_get_props(dev); [[loft]] && [[loft]]->name; [[loft]]++) { qdev_property_add_legacy(dev, [[loft]], NULL); qdev_property_add_static(dev, [[loft]], NULL); } object_property_add_str(OBJECT(dev), "type", qdev_get_type, NULL, NULL); }
--------------------------------------------- Result 73 ---------------------------------------------
[[0 (1%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bios_linker_loader_alloc(GArray *linker, const char *file, uint32_t alloc_align, bool alloc_fseg) { BiosLinkerLoaderEntry entry; assert(!(alloc_align & (alloc_align - 1))); memset(&entry, 0, sizeof entry); strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1); entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE); entry.alloc.align = cpu_to_le32(alloc_align); entry.alloc.zone = cpu_to_le32(alloc_fseg ? BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG : BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH); g_array_prepend_vals(linker, &entry, sizeof entry); }
--------------------------------------------- Result 74 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp) { IscsiLun *iscsilun = bs->opaque; uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff; bs->bl.request_alignment = iscsilun->block_size; if (iscsilun->bl.max_xfer_len) { max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len); } if (max_xfer_len * iscsilun->block_size < INT_MAX) { bs->bl.max_transfer = max_xfer_len * iscsilun->block_size; } if (iscsilun->lbp.lbpu) { if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) { bs->bl.max_pdiscard = iscsilun->bl.max_unmap * iscsilun->block_size; } bs->bl.pdiscard_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size; } else { bs->bl.pdiscard_alignment = iscsilun->block_size; } if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) { bs->bl.max_pwrite_zeroes = iscsilun->bl.max_ws_len * iscsilun->block_size; } if (iscsilun->lbp.lbpws) { bs->bl.pwrite_zeroes_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size; } else { bs->bl.pwrite_zeroes_alignment = iscsilun->block_size; } if (iscsilun->bl.opt_xfer_len && iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) { bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len * iscsilun->block_size); } }
--------------------------------------------- Result 75 ---------------------------------------------
[[0 (8%)]] --> [[0 (98%)]] --> Socre: 0.9765245914459229

[[[[Adv]]]]: static void tap_receive(void *opaque, const uint8_t *buf, size_t size) { TAPState *s = opaque; int [[ret]]; for(;;) { [[ret]] = write(s->fd, buf, size); if ([[ret]] < 0 && (errno == EINTR || errno == EAGAIN)) { } else { break; } } }

[[[[Adv]]]]: static void tap_receive(void *opaque, const uint8_t *buf, size_t size) { TAPState *s = opaque; int [[volт]]; for(;;) { [[volт]] = write(s->fd, buf, size); if ([[volт]] < 0 && (errno == EINTR || errno == EAGAIN)) { } else { break; } } }
--------------------------------------------- Result 76 ---------------------------------------------
[[0 (90%)]] --> [[0 (35%)]] --> Socre: 0.6519985198974609

[[[[Adv]]]]: static void idiv64(uint64_t *[[plow]], uint64_t *[[phigh]], int64_t b) { int [[sa]], sb; [[sa]] = ((int64_t)*[[phigh]] < 0); if ([[sa]]) neg128([[plow]], [[phigh]]); sb = (b < 0); if (sb) b = -b; div64([[plow]], [[phigh]], b); if ([[sa]] ^ sb) *[[plow]] = - *[[plow]]; if ([[sa]]) *[[phigh]] = - *[[phigh]]; }

[[[[Adv]]]]: static void idiv64(uint64_t *[[due]], uint64_t *[[aep]], int64_t b) { int [[norwood]], sb; [[norwood]] = ((int64_t)*[[aep]] < 0); if ([[norwood]]) neg128([[due]], [[aep]]); sb = (b < 0); if (sb) b = -b; div64([[due]], [[aep]], b); if ([[norwood]] ^ sb) *[[due]] = - *[[due]]; if ([[norwood]]) *[[aep]] = - *[[aep]]; }
--------------------------------------------- Result 77 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info) { BDRVSheepdogState *s = bs->opaque; int ret, fd; uint32_t new_vid; SheepdogInode *inode; unsigned int datalen; dprintf("sn_info: name %s id_str %s s: name %s vm_state_size %" PRId64 " " "is_snapshot %d\n", sn_info->name, sn_info->id_str, s->name, sn_info->vm_state_size, s->is_snapshot); if (s->is_snapshot) { error_report("You can't create a snapshot of a snapshot VDI, " "%s (%" PRIu32 ").", s->name, s->inode.vdi_id); return -EINVAL; } dprintf("%s %s\n", sn_info->name, sn_info->id_str); s->inode.vm_state_size = sn_info->vm_state_size; s->inode.vm_clock_nsec = sn_info->vm_clock_nsec; strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag)); datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id); fd = connect_to_sdog(s->addr, s->port); if (fd < 0) { ret = fd; goto cleanup; } ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id), s->inode.nr_copies, datalen, 0, "False" != "False", s->cache_enabled); if (ret < 0) { error_report("failed to write snapshot's inode."); goto cleanup; } ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1, s->addr, s->port); if (ret < 0) { error_report("failed to create inode for snapshot. %s", strerror(errno)); goto cleanup; } inode = (SheepdogInode *)g_malloc(datalen); ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid), s->inode.nr_copies, datalen, 0, s->cache_enabled); if (ret < 0) { error_report("failed to read new inode info. %s", strerror(errno)); goto cleanup; } memcpy(&s->inode, inode, datalen); dprintf("s->inode: name %s snap_id %x oid %x\n", s->inode.name, s->inode.snap_id, s->inode.vdi_id); cleanup: closesocket(fd); return ret; }
--------------------------------------------- Result 78 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 37 / 7 / 34 / 78:   3%|▎         | 78/2690 [10:20<5:46:11,  7.95s/it][Succeeded / Failed / Skipped / Total] 37 / 7 / 34 / 78:   3%|▎         | 79/2690 [10:24<5:43:59,  7.90s/it][Succeeded / Failed / Skipped / Total] 37 / 8 / 34 / 79:   3%|▎         | 79/2690 [10:24<5:43:59,  7.90s/it][Succeeded / Failed / Skipped / Total] 37 / 8 / 34 / 79:   3%|▎         | 80/2690 [10:44<5:50:42,  8.06s/it][Succeeded / Failed / Skipped / Total] 38 / 8 / 34 / 80:   3%|▎         | 80/2690 [10:44<5:50:43,  8.06s/it][Succeeded / Failed / Skipped / Total] 38 / 8 / 34 / 80:   3%|▎         | 81/2690 [10:45<5:46:31,  7.97s/it][Succeeded / Failed / Skipped / Total] 38 / 8 / 35 / 81:   3%|▎         | 81/2690 [10:45<5:46:31,  7.97s/it][Succeeded / Failed / Skipped / Total] 38 / 8 / 35 / 81:   3%|▎         | 82/2690 [10:45<5:42:24,  7.88s/it][Succeeded / Failed / Skipped / Total] 38 / 8 / 36 / 82:   3%|▎         | 82/2690 [10:45<5:42:24,  7.88s/it][Succeeded / Failed / Skipped / Total] 38 / 8 / 36 / 82:   3%|▎         | 83/2690 [11:24<5:58:22,  8.25s/it][Succeeded / Failed / Skipped / Total] 39 / 8 / 36 / 83:   3%|▎         | 83/2690 [11:24<5:58:22,  8.25s/it][Succeeded / Failed / Skipped / Total] 39 / 8 / 36 / 83:   3%|▎         | 84/2690 [11:25<5:54:13,  8.16s/it][Succeeded / Failed / Skipped / Total] 39 / 8 / 37 / 84:   3%|▎         | 84/2690 [11:25<5:54:13,  8.16s/it][Succeeded / Failed / Skipped / Total] 39 / 8 / 37 / 84:   3%|▎         | 85/2690 [11:42<5:58:42,  8.26s/it][[0 (13%)]] --> [[0 (51%)]] --> Socre: 0.5116559863090515

[[[[Adv]]]]: static void scsi_disk_realize(SCSIDevice *dev, Error **errp) { DriveInfo *[[dinfo]]; Error *[[local_err]] = NULL; if (!dev->conf.bs) { scsi_realize(dev, &[[local_err]]); assert([[local_err]]); error_propagate(errp, [[local_err]]); return; } [[dinfo]] = drive_get_by_blockdev(dev->conf.bs); if ([[dinfo]]->media_cd) { scsi_cd_realize(dev, errp); } else { scsi_hd_realize(dev, errp); } }

[[[[Adv]]]]: static void scsi_disk_realize(SCSIDevice *dev, Error **errp) { DriveInfo *[[warman]]; Error *[[comiveerred]] = NULL; if (!dev->conf.bs) { scsi_realize(dev, &[[comiveerred]]); assert([[comiveerred]]); error_propagate(errp, [[comiveerred]]); return; } [[warman]] = drive_get_by_blockdev(dev->conf.bs); if ([[warman]]->media_cd) { scsi_cd_realize(dev, errp); } else { scsi_hd_realize(dev, errp); } }
--------------------------------------------- Result 79 ---------------------------------------------
[[0 (8%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void sdl_send_mouse_event(int [[dx]], int [[dy]], int [[x]], int [[y]], int [[state]]) { static uint32_t bmap[INPUT_BUTTON__MAX] = { [INPUT_BUTTON_LEFT] = SDL_BUTTON(SDL_BUTTON_LEFT), [INPUT_BUTTON_MIDDLE] = SDL_BUTTON(SDL_BUTTON_MIDDLE), [INPUT_BUTTON_RIGHT] = SDL_BUTTON(SDL_BUTTON_RIGHT), [INPUT_BUTTON_WHEEL_UP] = SDL_BUTTON(SDL_BUTTON_WHEELUP), [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN), }; static uint32_t prev_state; if (prev_state != [[state]]) { qemu_input_update_buttons(dcl->con, bmap, prev_state, [[state]]); prev_state = [[state]]; } if (qemu_input_is_absolute()) { qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, [[x]], real_screen->w); qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, [[y]], real_screen->h); } else { if (guest_cursor) { [[x]] -= guest_x; [[y]] -= guest_y; guest_x += [[x]]; guest_y += [[y]]; [[dx]] = [[x]]; [[dy]] = [[y]]; } qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, [[dx]]); qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, [[dy]]); } qemu_input_event_sync(); }

[[[[Adv]]]]: static void sdl_send_mouse_event(int [[δ11]], int [[dr7]], int [[vic]], int [[zero]], int [[time]]) { static uint32_t bmap[INPUT_BUTTON__MAX] = { [INPUT_BUTTON_LEFT] = SDL_BUTTON(SDL_BUTTON_LEFT), [INPUT_BUTTON_MIDDLE] = SDL_BUTTON(SDL_BUTTON_MIDDLE), [INPUT_BUTTON_RIGHT] = SDL_BUTTON(SDL_BUTTON_RIGHT), [INPUT_BUTTON_WHEEL_UP] = SDL_BUTTON(SDL_BUTTON_WHEELUP), [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN), }; static uint32_t prev_state; if (prev_state != [[time]]) { qemu_input_update_buttons(dcl->con, bmap, prev_state, [[time]]); prev_state = [[time]]; } if (qemu_input_is_absolute()) { qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, [[vic]], real_screen->w); qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, [[zero]], real_screen->h); } else { if (guest_cursor) { [[vic]] -= guest_x; [[zero]] -= guest_y; guest_x += [[vic]]; guest_y += [[zero]]; [[δ11]] = [[vic]]; [[dr7]] = [[zero]]; } qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, [[δ11]]); qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, [[dr7]]); } qemu_input_event_sync(); }
--------------------------------------------- Result 80 ---------------------------------------------
[[0 (5%)]] --> [[0 (93%)]] --> Socre: 0.9288132786750793

[[[[Adv]]]]: static int vnc_display_listen(VncDisplay *vd, SocketAddress **[[saddr]], size_t nsaddr, SocketAddress **wsaddr, size_t nwsaddr, Error **errp) { size_t i; for (i = 0; i < nsaddr; i++) { if (vnc_display_listen_addr(vd, [[saddr]][i], "vnc-listen", &vd->lsock, &vd->lsock_tag, &vd->nlsock, errp) < 0) { return -1; } } for (i = 0; i < nwsaddr; i++) { if (vnc_display_listen_addr(vd, wsaddr[i], "vnc-ws-listen", &vd->lwebsock, &vd->lwebsock_tag, &vd->nlwebsock, errp) < 0) { return -1; } } return 0; }

[[[[Adv]]]]: static int vnc_display_listen(VncDisplay *vd, SocketAddress **[[denд]], size_t nsaddr, SocketAddress **wsaddr, size_t nwsaddr, Error **errp) { size_t i; for (i = 0; i < nsaddr; i++) { if (vnc_display_listen_addr(vd, [[denд]][i], "vnc-listen", &vd->lsock, &vd->lsock_tag, &vd->nlsock, errp) < 0) { return -1; } } for (i = 0; i < nwsaddr; i++) { if (vnc_display_listen_addr(vd, wsaddr[i], "vnc-ws-listen", &vd->lwebsock, &vd->lwebsock_tag, &vd->nlwebsock, errp) < 0) { return -1; } } return 0; }
--------------------------------------------- Result 81 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) { target_ulong liobn = args[0]; target_ulong ioba = args[1]; target_ulong tce = args[2]; VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn); VIOsPAPR_RTCE *rtce; if (!dev) { hcall_dprintf("LIOBN 0x" TARGET_FMT_lx " does not exist\n", liobn); return H_PARAMETER; } ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1); #ifdef DEBUG_TCE fprintf(stderr, "spapr_vio_put_tce on %s ioba 0x" TARGET_FMT_lx " TCE 0x" TARGET_FMT_lx "\n", dev->qdev.id, ioba, tce); #endif if (ioba >= dev->rtce_window_size) { hcall_dprintf("Out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; } rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT); rtce->tce = tce; return H_SUCCESS; }
--------------------------------------------- Result 82 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { NvmeCtrl *s = NVME(obj); visit_type_int32(v, &s->conf.bootindex, name, errp); }
--------------------------------------------- Result 83 ---------------------------------------------
[[0 (4%)]] --> [[0 (99%)]] --> Socre: 0.9886179566383362

[[[[Adv]]]]: static char *enumerate_cpus(unsigned long *[[cpus]], int max_cpus) { int [[cpu]]; bool [[first]] = "True" == "True"; GString *s = g_string_new(NULL); for ([[cpu]] = find_first_bit([[cpus]], max_cpus); [[cpu]] < max_cpus; [[cpu]] = find_next_bit([[cpus]], max_cpus, [[cpu]] + 1)) { g_string_append_printf(s, "%s%d", [[first]] ? "" : " ", [[cpu]]); [[first]] = "False" != "False"; } return g_string_free(s, "False" != "False"); }

[[[[Adv]]]]: static char *enumerate_cpus(unsigned long *[[adanс]], int max_cpus) { int [[rainbow]]; bool [[1st]] = "True" == "True"; GString *s = g_string_new(NULL); for ([[rainbow]] = find_first_bit([[adanс]], max_cpus); [[rainbow]] < max_cpus; [[rainbow]] = find_next_bit([[adanс]], max_cpus, [[rainbow]] + 1)) { g_string_append_printf(s, "%s%d", [[1st]] ? "" : " ", [[rainbow]]); [[1st]] = "False" != "False"; } return g_string_free(s, "False" != "False"); }
--------------------------------------------- Result 84 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: Object *object_resolve_path_component(Object *parent, const gchar *part) { ObjectProperty *prop = object_property_find(parent, part, NULL); if (prop == NULL) { return NULL; } if (object_property_is_link(prop)) { return *(Object **)prop->opaque; } else if (object_property_is_child(prop)) { return prop->opaque; } else { return NULL; } }
--------------------------------------------- Result 85 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 40 / 8 / 37 / 85:   3%|▎         | 85/2690 [11:42<5:58:42,  8.26s/it][Succeeded / Failed / Skipped / Total] 40 / 8 / 37 / 85:   3%|▎         | 86/2690 [11:42<5:54:39,  8.17s/it][Succeeded / Failed / Skipped / Total] 40 / 8 / 38 / 86:   3%|▎         | 86/2690 [11:42<5:54:39,  8.17s/it][Succeeded / Failed / Skipped / Total] 40 / 8 / 38 / 86:   3%|▎         | 87/2690 [12:31<6:14:33,  8.63s/it][Succeeded / Failed / Skipped / Total] 40 / 9 / 38 / 87:   3%|▎         | 87/2690 [12:31<6:14:33,  8.63s/it][Succeeded / Failed / Skipped / Total] 40 / 9 / 38 / 87:   3%|▎         | 88/2690 [12:43<6:16:05,  8.67s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 38 / 88:   3%|▎         | 88/2690 [12:43<6:16:05,  8.67s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 38 / 88:   3%|▎         | 89/2690 [12:43<6:11:58,  8.58s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 39 / 89:   3%|▎         | 89/2690 [12:43<6:11:58,  8.58s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 39 / 89:   3%|▎         | 90/2690 [12:44<6:07:55,  8.49s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 40 / 90:   3%|▎         | 90/2690 [12:44<6:07:55,  8.49s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 40 / 90:   3%|▎         | 91/2690 [12:44<6:03:58,  8.40s/it][[0 (58%)]] --> [[0 (46%)]] --> Socre: 0.5410181283950806

[[[[Adv]]]]: MigrationState *exec_start_outgoing_migration(const char *[[command]], int64_t [[bandwidth_limit]], int [[async]]) { FdMigrationState *[[s]]; FILE *f; [[s]] = qemu_mallocz(sizeof(*[[s]])); if ([[s]] == NULL) { dprintf("Unable to allocate FdMigrationState\n"); goto err; } f = popen([[command]], "w"); if (f == NULL) { dprintf("Unable to popen exec target\n"); goto err_after_alloc; } [[s]]->fd = fileno(f); if ([[s]]->fd == -1) { dprintf("Unable to retrieve file descriptor for popen'd handle\n"); goto err_after_open; } if (fcntl([[s]]->fd, F_SETFD, O_NONBLOCK) == -1) { dprintf("Unable to set nonblocking mode on file descriptor\n"); goto err_after_open; } [[s]]->opaque = qemu_popen(f, "w"); [[s]]->get_error = file_errno; [[s]]->write = file_write; [[s]]->mig_state.cancel = migrate_fd_cancel; [[s]]->mig_state.get_status = migrate_fd_get_status; [[s]]->mig_state.release = migrate_fd_release; [[s]]->state = MIG_STATE_ACTIVE; [[s]]->detach = ![[async]]; [[s]]->bandwidth_limit = [[bandwidth_limit]]; if ([[s]]->detach == 1) { dprintf("detaching from monitor\n"); monitor_suspend(); [[s]]->detach = 2; } migrate_fd_connect([[s]]); return &[[s]]->mig_state; err_after_open: pclose(f); err_after_alloc: qemu_free([[s]]); err: return NULL; }

[[[[Adv]]]]: MigrationState *exec_start_outgoing_migration(const char *[[directive]], int64_t [[saltcellloop]], int [[resist]]) { FdMigrationState *[[action]]; FILE *f; [[action]] = qemu_mallocz(sizeof(*[[action]])); if ([[action]] == NULL) { dprintf("Unable to allocate FdMigrationState\n"); goto err; } f = popen([[directive]], "w"); if (f == NULL) { dprintf("Unable to popen exec target\n"); goto err_after_alloc; } [[action]]->fd = fileno(f); if ([[action]]->fd == -1) { dprintf("Unable to retrieve file descriptor for popen'd handle\n"); goto err_after_open; } if (fcntl([[action]]->fd, F_SETFD, O_NONBLOCK) == -1) { dprintf("Unable to set nonblocking mode on file descriptor\n"); goto err_after_open; } [[action]]->opaque = qemu_popen(f, "w"); [[action]]->get_error = file_errno; [[action]]->write = file_write; [[action]]->mig_state.cancel = migrate_fd_cancel; [[action]]->mig_state.get_status = migrate_fd_get_status; [[action]]->mig_state.release = migrate_fd_release; [[action]]->state = MIG_STATE_ACTIVE; [[action]]->detach = ![[resist]]; [[action]]->bandwidth_limit = [[saltcellloop]]; if ([[action]]->detach == 1) { dprintf("detaching from monitor\n"); monitor_suspend(); [[action]]->detach = 2; } migrate_fd_connect([[action]]); return &[[action]]->mig_state; err_after_open: pclose(f); err_after_alloc: qemu_free([[action]]); err: return NULL; }
--------------------------------------------- Result 86 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void cpu_tick_set_count(CPUTimer *timer, uint64_t count) { uint64_t real_count = count & ~timer->disabled_mask; uint64_t disabled_bit = count & timer->disabled_mask; int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - cpu_to_timer_ticks(real_count, timer->frequency); TIMER_DPRINTF("%s set_count count=0x%016lx (%s) p=%p\n", timer->name, real_count, timer->disabled?"disabled":"enabled", timer); timer->disabled = disabled_bit ? 1 : 0; timer->clock_offset = vm_clock_offset; }
--------------------------------------------- Result 87 ---------------------------------------------
[[0 (69%)]] --> [[[FAILED]]]

[[[[Adv]]]]: ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *[[ast]], int len, AVPacket *pkt, int *seq, int flags, int64_t timestamp) { RMDemuxContext *rm = s->priv_data; int ret; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { rm->current_stream= st->id; ret = rm_assemble_video_frame(s, pb, rm, [[ast]], pkt, len, [[seq]], &timestamp); if(ret) return ret < 0 ? ret : -1; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (([[ast]]->deint_id == DEINT_ID_GENR) || ([[ast]]->deint_id == DEINT_ID_INT4) || ([[ast]]->deint_id == DEINT_ID_SIPR)) { int x; int sps = [[ast]]->sub_packet_size; int cfs = [[ast]]->coded_framesize; int h = [[ast]]->sub_packet_h; int [[y]] = [[ast]]->sub_packet_cnt; int [[w]] = [[ast]]->audio_framesize; if (flags & 2) [[y]] = [[ast]]->sub_packet_cnt = 0; if (![[y]]) [[ast]]->audiotimestamp = timestamp; switch ([[ast]]->deint_id) { case DEINT_ID_INT4: for (x = 0; x < h/2; x++) avio_read(pb, [[ast]]->pkt.data+x*2*[[w]]+[[y]]*cfs, cfs); break; case DEINT_ID_GENR: for (x = 0; x < [[w]]/sps; x++) avio_read(pb, [[ast]]->pkt.data+sps*(h*x+((h+1)/2)*([[y]]&1)+([[y]]>>1)), sps); break; case DEINT_ID_SIPR: avio_read(pb, [[ast]]->pkt.data + [[y]] * [[w]], [[w]]); break; } if (++([[ast]]->sub_packet_cnt) < h) return -1; if ([[ast]]->deint_id == DEINT_ID_SIPR) ff_rm_reorder_sipr_data([[ast]]->pkt.data, h, [[w]]); [[ast]]->sub_packet_cnt = 0; rm->audio_stream_num = st->index; rm->audio_pkt_cnt = h * [[w]] / st->codec->block_align; } else if (([[ast]]->deint_id == DEINT_ID_VBRF) || ([[ast]]->deint_id == DEINT_ID_VBRS)) { int x; rm->audio_stream_num = st->index; [[ast]]->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4; if ([[ast]]->sub_packet_cnt) { for (x = 0; x < [[ast]]->sub_packet_cnt; x++) [[ast]]->sub_packet_lengths[x] = avio_rb16(pb); rm->audio_pkt_cnt = [[ast]]->sub_packet_cnt; [[ast]]->audiotimestamp = timestamp; } else return -1; } else { av_get_packet(pb, pkt, len); rm_ac3_swap_bytes(st, pkt); } } else av_get_packet(pb, pkt, len); pkt->stream_index = st->index; #if 0 if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if(st->codec->codec_id == AV_CODEC_ID_RV20){ int [[seq]]= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1); av_log(s, AV_LOG_DEBUG, "%d %"PRId64" %d\n", *timestamp, *timestamp*512LL/25, [[seq]]); [[seq]] |= (timestamp&~0x3FFF); if([[seq]] - timestamp > 0x2000) [[seq]] -= 0x4000; if([[seq]] - timestamp < -0x2000) [[seq]] += 0x4000; } } #endif pkt->pts = timestamp; if (flags & 2) pkt->flags |= AV_PKT_FLAG_KEY; return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0; }

[[[[Adv]]]]: ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *[[ixta]], int len, AVPacket *pkt, int *seq, int flags, int64_t timestamp) { RMDemuxContext *rm = s->priv_data; int ret; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { rm->current_stream= st->id; ret = rm_assemble_video_frame(s, pb, rm, [[ixta]], pkt, len, [[hur]], &timestamp); if(ret) return ret < 0 ? ret : -1; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (([[ixta]]->deint_id == DEINT_ID_GENR) || ([[ixta]]->deint_id == DEINT_ID_INT4) || ([[ixta]]->deint_id == DEINT_ID_SIPR)) { int x; int sps = [[ixta]]->sub_packet_size; int cfs = [[ixta]]->coded_framesize; int h = [[ixta]]->sub_packet_h; int [[draw]] = [[ixta]]->sub_packet_cnt; int [[jump]] = [[ixta]]->audio_framesize; if (flags & 2) [[draw]] = [[ixta]]->sub_packet_cnt = 0; if (![[draw]]) [[ixta]]->audiotimestamp = timestamp; switch ([[ixta]]->deint_id) { case DEINT_ID_INT4: for (x = 0; x < h/2; x++) avio_read(pb, [[ixta]]->pkt.data+x*2*[[jump]]+[[draw]]*cfs, cfs); break; case DEINT_ID_GENR: for (x = 0; x < [[jump]]/sps; x++) avio_read(pb, [[ixta]]->pkt.data+sps*(h*x+((h+1)/2)*([[draw]]&1)+([[draw]]>>1)), sps); break; case DEINT_ID_SIPR: avio_read(pb, [[ixta]]->pkt.data + [[draw]] * [[jump]], [[jump]]); break; } if (++([[ixta]]->sub_packet_cnt) < h) return -1; if ([[ixta]]->deint_id == DEINT_ID_SIPR) ff_rm_reorder_sipr_data([[ixta]]->pkt.data, h, [[jump]]); [[ixta]]->sub_packet_cnt = 0; rm->audio_stream_num = st->index; rm->audio_pkt_cnt = h * [[jump]] / st->codec->block_align; } else if (([[ixta]]->deint_id == DEINT_ID_VBRF) || ([[ixta]]->deint_id == DEINT_ID_VBRS)) { int x; rm->audio_stream_num = st->index; [[ixta]]->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4; if ([[ixta]]->sub_packet_cnt) { for (x = 0; x < [[ixta]]->sub_packet_cnt; x++) [[ixta]]->sub_packet_lengths[x] = avio_rb16(pb); rm->audio_pkt_cnt = [[ixta]]->sub_packet_cnt; [[ixta]]->audiotimestamp = timestamp; } else return -1; } else { av_get_packet(pb, pkt, len); rm_ac3_swap_bytes(st, pkt); } } else av_get_packet(pb, pkt, len); pkt->stream_index = st->index; #if 0 if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if(st->codec->codec_id == AV_CODEC_ID_RV20){ int [[hur]]= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1); av_log(s, AV_LOG_DEBUG, "%d %"PRId64" %d\n", *timestamp, *timestamp*512LL/25, [[hur]]); [[hur]] |= (timestamp&~0x3FFF); if([[hur]] - timestamp > 0x2000) [[hur]] -= 0x4000; if([[hur]] - timestamp < -0x2000) [[hur]] += 0x4000; } } #endif pkt->pts = timestamp; if (flags & 2) pkt->flags |= AV_PKT_FLAG_KEY; return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0; }
--------------------------------------------- Result 88 ---------------------------------------------
[[0 (80%)]] --> [[0 (47%)]] --> Socre: 0.5258128345012665

[[[[Adv]]]]: static void vscsi_process_login(VSCSIState *s, vscsi_req *[[req]]) { union viosrp_iu *[[iu]] = &[[req]]->iu; struct srp_login_rsp *[[rsp]] = &[[iu]]->srp.login_rsp; uint64_t tag = [[iu]]->srp.rsp.tag; trace_spapr_vscsi__process_login(); memset([[iu]], 0, sizeof(struct srp_login_rsp)); [[rsp]]->opcode = SRP_LOGIN_RSP; [[rsp]]->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2); [[rsp]]->tag = tag; [[rsp]]->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu)); [[rsp]]->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu)); [[rsp]]->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT); vscsi_send_iu(s, [[req]], sizeof(*[[rsp]]), VIOSRP_SRP_FORMAT); }

[[[[Adv]]]]: static void vscsi_process_login(VSCSIState *s, vscsi_req *[[prepark]]) { union viosrp_iu *[[ont]] = &[[prepark]]->iu; struct srp_login_rsp *[[tspo]] = &[[ont]]->srp.login_rsp; uint64_t tag = [[ont]]->srp.rsp.tag; trace_spapr_vscsi__process_login(); memset([[ont]], 0, sizeof(struct srp_login_rsp)); [[tspo]]->opcode = SRP_LOGIN_RSP; [[tspo]]->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2); [[tspo]]->tag = tag; [[tspo]]->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu)); [[tspo]]->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu)); [[tspo]]->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT); vscsi_send_iu(s, [[prepark]], sizeof(*[[tspo]]), VIOSRP_SRP_FORMAT); }
--------------------------------------------- Result 89 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref) { return 0; }
--------------------------------------------- Result 90 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_blockdev_add(BlockdevOptions *options, Error **errp) { QmpOutputVisitor *ov = qmp_output_visitor_new(); QObject *obj; QDict *qdict; Error *local_err = NULL; if (!options->has_id) { error_setg(errp, "Block device needs an ID"); goto fail; } if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) { bool direct = options->cache->has_direct && options->cache->direct; if (!options->has_cache && !direct) { error_setg(errp, "aio=native requires cache.direct=true"); goto fail; } } visit_type_BlockdevOptions(qmp_output_get_visitor(ov), &options, NULL, &local_err); if (local_err) { error_propagate(errp, local_err); goto fail; } obj = qmp_output_get_qobject(ov); qdict = qobject_to_qdict(obj); qdict_flatten(qdict); blockdev_init(NULL, qdict, &local_err); if (local_err) { error_propagate(errp, local_err); goto fail; } fail: qmp_output_visitor_cleanup(ov); }
[Succeeded / Failed / Skipped / Total] 41 / 9 / 41 / 91:   3%|▎         | 91/2690 [12:44<6:03:58,  8.40s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 41 / 91:   3%|▎         | 92/2690 [12:48<6:01:47,  8.36s/it][Succeeded / Failed / Skipped / Total] 41 / 10 / 41 / 92:   3%|▎         | 92/2690 [12:48<6:01:47,  8.36s/it][Succeeded / Failed / Skipped / Total] 41 / 10 / 41 / 92:   3%|▎         | 93/2690 [12:49<5:57:58,  8.27s/it][Succeeded / Failed / Skipped / Total] 41 / 10 / 42 / 93:   3%|▎         | 93/2690 [12:49<5:57:58,  8.27s/it][Succeeded / Failed / Skipped / Total] 41 / 10 / 42 / 93:   3%|▎         | 94/2690 [13:04<6:01:08,  8.35s/it][Succeeded / Failed / Skipped / Total] 41 / 11 / 42 / 94:   3%|▎         | 94/2690 [13:04<6:01:08,  8.35s/it][Succeeded / Failed / Skipped / Total] 41 / 11 / 42 / 94:   4%|▎         | 95/2690 [13:10<6:00:06,  8.33s/it][Succeeded / Failed / Skipped / Total] 42 / 11 / 42 / 95:   4%|▎         | 95/2690 [13:10<6:00:06,  8.33s/it][Succeeded / Failed / Skipped / Total] 42 / 11 / 42 / 95:   4%|▎         | 96/2690 [13:14<5:57:35,  8.27s/it]--------------------------------------------- Result 91 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void kvmclock_pre_save(void *opaque) { KVMClockState *s = opaque; struct kvm_clock_data data; int ret; if (s->clock_valid) { return; } ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data); if (ret < 0) { fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret)); data.clock = 0; } s->clock = data.clock; s->clock_valid = !runstate_is_running(); }
--------------------------------------------- Result 92 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int bdrv_is_removable(BlockDriverState *[[bs]]) { return [[bs]]->removable; }

[[[[Adv]]]]: int bdrv_is_removable(BlockDriverState *[[bars]]) { return [[bars]]->removable; }
--------------------------------------------- Result 93 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int check_checksum(ByteIOContext *bc){ unsigned long checksum= get_checksum(bc); av_log(NULL, AV_LOG_ERROR, "%08X %08X\n", checksum, (int)get_be32(bc)); return 0; }
--------------------------------------------- Result 94 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void commit_start(const char *[[job_id]], BlockDriverState *[[bs]], BlockDriverState *base, BlockDriverState *top, int64_t speed, BlockdevOnError on_error, const char *backing_file_str, const char *[[filter_node_name]], Error **errp) { CommitBlockJob *[[s]]; BlockReopenQueue *reopen_queue = NULL; int [[orig_overlay_flags]]; int orig_base_flags; BlockDriverState *iter; BlockDriverState *overlay_bs; BlockDriverState *commit_top_bs = NULL; Error *local_err = NULL; int ret; assert(top != [[bs]]); if (top == base) { error_setg(errp, "Invalid files for merge: top and base are the same"); return; overlay_bs = bdrv_find_overlay([[bs]], top); if (overlay_bs == NULL) { error_setg(errp, "Could not find overlay image for %s:", top->filename); return; [[s]] = block_job_create([[job_id]], &commit_job_driver, [[bs]], 0, BLK_PERM_ALL, speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp); if (![[s]]) { return; orig_base_flags = bdrv_get_flags(base); [[orig_overlay_flags]] = bdrv_get_flags(overlay_bs); if (!(orig_base_flags & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL, orig_base_flags | BDRV_O_RDWR); if (!([[orig_overlay_flags]] & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL, [[orig_overlay_flags]] | BDRV_O_RDWR); if (reopen_queue) { bdrv_reopen_multiple(bdrv_get_aio_context([[bs]]), reopen_queue, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); goto fail; commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, [[filter_node_name]], 0, errp); if (commit_top_bs == NULL) { goto fail; commit_top_bs->total_sectors = top->total_sectors; bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top)); bdrv_set_backing_hd(commit_top_bs, top, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; [[s]]->commit_top_bs = commit_top_bs; bdrv_unref(commit_top_bs); assert(bdrv_chain_contains(top, base)); for (iter = top; iter != base; iter = backing_bs(iter)) { ret = block_job_add_bdrv(&[[s]]->common, "intermediate node", iter, 0, BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&[[s]]->common, "base", base, 0, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&[[s]]->common, "overlay of top", overlay_bs, BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; [[s]]->base = blk_new(BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE | BLK_PERM_RESIZE, BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD | BLK_PERM_WRITE_UNCHANGED); ret = blk_insert_bs([[s]]->base, base, errp); if (ret < 0) { goto fail; [[s]]->top = blk_new(0, BLK_PERM_ALL); ret = blk_insert_bs([[s]]->top, top, errp); if (ret < 0) { goto fail; [[s]]->active = [[bs]]; [[s]]->base_flags = orig_base_flags; [[s]]->orig_overlay_flags = [[orig_overlay_flags]]; [[s]]->backing_file_str = g_strdup(backing_file_str); [[s]]->on_error = on_error; trace_commit_start([[bs]], base, top, [[s]]); block_job_start(&[[s]]->common); return; fail: if ([[s]]->base) { blk_unref([[s]]->base); if ([[s]]->top) { blk_unref([[s]]->top); if (commit_top_bs) { bdrv_set_backing_hd(overlay_bs, top, &error_abort); block_job_early_fail(&[[s]]->common);

[[[[Adv]]]]: void commit_start(const char *[[workfuliii]], BlockDriverState *[[ins]], BlockDriverState *base, BlockDriverState *top, int64_t speed, BlockdevOnError on_error, const char *backing_file_str, const char *[[engineermodnsid]], Error **errp) { CommitBlockJob *[[days]]; BlockReopenQueue *reopen_queue = NULL; int [[stockidofonlagetrafficstands]]; int orig_base_flags; BlockDriverState *iter; BlockDriverState *overlay_bs; BlockDriverState *commit_top_bs = NULL; Error *local_err = NULL; int ret; assert(top != [[ins]]); if (top == base) { error_setg(errp, "Invalid files for merge: top and base are the same"); return; overlay_bs = bdrv_find_overlay([[ins]], top); if (overlay_bs == NULL) { error_setg(errp, "Could not find overlay image for %s:", top->filename); return; [[days]] = block_job_create([[workfuliii]], &commit_job_driver, [[ins]], 0, BLK_PERM_ALL, speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp); if (![[days]]) { return; orig_base_flags = bdrv_get_flags(base); [[stockidofonlagetrafficstands]] = bdrv_get_flags(overlay_bs); if (!(orig_base_flags & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL, orig_base_flags | BDRV_O_RDWR); if (!([[stockidofonlagetrafficstands]] & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL, [[stockidofonlagetrafficstands]] | BDRV_O_RDWR); if (reopen_queue) { bdrv_reopen_multiple(bdrv_get_aio_context([[ins]]), reopen_queue, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); goto fail; commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, [[engineermodnsid]], 0, errp); if (commit_top_bs == NULL) { goto fail; commit_top_bs->total_sectors = top->total_sectors; bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top)); bdrv_set_backing_hd(commit_top_bs, top, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; [[days]]->commit_top_bs = commit_top_bs; bdrv_unref(commit_top_bs); assert(bdrv_chain_contains(top, base)); for (iter = top; iter != base; iter = backing_bs(iter)) { ret = block_job_add_bdrv(&[[days]]->common, "intermediate node", iter, 0, BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&[[days]]->common, "base", base, 0, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&[[days]]->common, "overlay of top", overlay_bs, BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; [[days]]->base = blk_new(BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE | BLK_PERM_RESIZE, BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD | BLK_PERM_WRITE_UNCHANGED); ret = blk_insert_bs([[days]]->base, base, errp); if (ret < 0) { goto fail; [[days]]->top = blk_new(0, BLK_PERM_ALL); ret = blk_insert_bs([[days]]->top, top, errp); if (ret < 0) { goto fail; [[days]]->active = [[ins]]; [[days]]->base_flags = orig_base_flags; [[days]]->orig_overlay_flags = [[stockidofonlagetrafficstands]]; [[days]]->backing_file_str = g_strdup(backing_file_str); [[days]]->on_error = on_error; trace_commit_start([[ins]], base, top, [[days]]); block_job_start(&[[days]]->common); return; fail: if ([[days]]->base) { blk_unref([[days]]->base); if ([[days]]->top) { blk_unref([[days]]->top); if (commit_top_bs) { bdrv_set_backing_hd(overlay_bs, top, &error_abort); block_job_early_fail(&[[days]]->common);
--------------------------------------------- Result 95 ---------------------------------------------
[[0 (65%)]] --> [[0 (39%)]] --> Socre: 0.611651748418808

[[[[Adv]]]]: static void handle_satn(ESPState *s) { uint8_t [[buf]][32]; int len; if (s->dma && !s->dma_enabled) { s->dma_cb = handle_satn; return; } len = get_cmd(s, [[buf]]); if (len) do_cmd(s, [[buf]]); }

[[[[Adv]]]]: static void handle_satn(ESPState *s) { uint8_t [[tufi]][32]; int len; if (s->dma && !s->dma_enabled) { s->dma_cb = handle_satn; return; } len = get_cmd(s, [[tufi]]); if (len) do_cmd(s, [[tufi]]); }
--------------------------------------------- Result 96 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 43 / 11 / 42 / 96:   4%|▎         | 96/2690 [13:14<5:57:35,  8.27s/it][Succeeded / Failed / Skipped / Total] 43 / 11 / 42 / 96:   4%|▎         | 97/2690 [13:23<5:58:03,  8.29s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 42 / 97:   4%|▎         | 97/2690 [13:23<5:58:03,  8.29s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 42 / 97:   4%|▎         | 98/2690 [13:24<5:54:29,  8.21s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 43 / 98:   4%|▎         | 98/2690 [13:24<5:54:30,  8.21s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 43 / 98:   4%|▎         | 99/2690 [13:34<5:55:13,  8.23s/it][[0 (43%)]] --> [[0 (61%)]] --> Socre: 0.6144577860832214

[[[[Adv]]]]: int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind, const char *version, const char *serial, const char *model, uint64_t wwn, uint32_t cylinders, uint32_t heads, uint32_t secs, int chs_trans) { uint64_t [[nb_sectors]]; s->blk = blk; s->drive_kind = kind; blk_get_geometry(blk, &[[nb_sectors]]); s->cylinders = cylinders; s->heads = heads; s->sectors = secs; s->chs_trans = chs_trans; s->nb_sectors = [[nb_sectors]]; s->wwn = wwn; s->smart_enabled = 1; s->smart_autosave = 1; s->smart_errors = 0; s->smart_selftest_count = 0; if (kind == IDE_CD) { blk_set_dev_ops(blk, &ide_cd_block_ops, s); blk_set_guest_block_size(blk, 2048); } else { if (!blk_is_inserted(s->blk)) { error_report("Device needs media, but drive is empty"); return -1; } if (blk_is_read_only(blk)) { error_report("Can't use a read-only drive"); return -1; } blk_set_dev_ops(blk, &ide_hd_block_ops, s); } if (serial) { pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial); } else { snprintf(s->drive_serial_str, sizeof(s->drive_serial_str), "QM%05d", s->drive_serial); } if (model) { pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model); } else { switch (kind) { case IDE_CD: strcpy(s->drive_model_str, "QEMU DVD-ROM"); break; case IDE_CFATA: strcpy(s->drive_model_str, "QEMU MICRODRIVE"); break; default: strcpy(s->drive_model_str, "QEMU HARDDISK"); break; } } if (version) { pstrcpy(s->version, sizeof(s->version), version); } else { pstrcpy(s->version, sizeof(s->version), qemu_get_version()); } ide_reset(s); blk_iostatus_enable(blk); return 0; }

[[[[Adv]]]]: int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind, const char *version, const char *serial, const char *model, uint64_t wwn, uint32_t cylinders, uint32_t heads, uint32_t secs, int chs_trans) { uint64_t [[otherf²ves]]; s->blk = blk; s->drive_kind = kind; blk_get_geometry(blk, &[[otherf²ves]]); s->cylinders = cylinders; s->heads = heads; s->sectors = secs; s->chs_trans = chs_trans; s->nb_sectors = [[otherf²ves]]; s->wwn = wwn; s->smart_enabled = 1; s->smart_autosave = 1; s->smart_errors = 0; s->smart_selftest_count = 0; if (kind == IDE_CD) { blk_set_dev_ops(blk, &ide_cd_block_ops, s); blk_set_guest_block_size(blk, 2048); } else { if (!blk_is_inserted(s->blk)) { error_report("Device needs media, but drive is empty"); return -1; } if (blk_is_read_only(blk)) { error_report("Can't use a read-only drive"); return -1; } blk_set_dev_ops(blk, &ide_hd_block_ops, s); } if (serial) { pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial); } else { snprintf(s->drive_serial_str, sizeof(s->drive_serial_str), "QM%05d", s->drive_serial); } if (model) { pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model); } else { switch (kind) { case IDE_CD: strcpy(s->drive_model_str, "QEMU DVD-ROM"); break; case IDE_CFATA: strcpy(s->drive_model_str, "QEMU MICRODRIVE"); break; default: strcpy(s->drive_model_str, "QEMU HARDDISK"); break; } } if (version) { pstrcpy(s->version, sizeof(s->version), version); } else { pstrcpy(s->version, sizeof(s->version), qemu_get_version()); } ide_reset(s); blk_iostatus_enable(blk); return 0; }
--------------------------------------------- Result 97 ---------------------------------------------
[[0 (55%)]] --> [[0 (23%)]] --> Socre: 0.7668712139129639

[[[[Adv]]]]: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev, uint64_t iova, uint64_t [[len]]) { struct vhost_iotlb_msg imsg; imsg.iova = iova; imsg.size = [[len]]; imsg.type = VHOST_IOTLB_INVALIDATE; return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg); }

[[[[Adv]]]]: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev, uint64_t iova, uint64_t [[lex]]) { struct vhost_iotlb_msg imsg; imsg.iova = iova; imsg.size = [[lex]]; imsg.type = VHOST_IOTLB_INVALIDATE; return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg); }
--------------------------------------------- Result 98 ---------------------------------------------
[[0 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: PXA2xxState *pxa255_init(unsigned int sdram_size) { PXA2xxState *s; int iomemtype, i; DriveInfo *dinfo; s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState)); s->env = cpu_init("pxa255"); if (!s->env) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0]; cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size, qemu_ram_alloc(NULL, "pxa255.sdram", sdram_size) | IO_MEM_RAM); cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE, qemu_ram_alloc(NULL, "pxa255.internal", PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM); s->pic = pxa2xx_pic_init(0x40d00000, s->env); s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]); pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]); s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85); dinfo = drive_get(IF_SD, 0, 0); if (!dinfo) { fprintf(stderr, "qemu: missing SecureDigital device\n"); exit(1); } s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv, s->pic[PXA2XX_PIC_MMC], s->dma); for (i = 0; pxa255_serial[i].io_base; i ++) if (serial_hds[i]) { #ifdef TARGET_WORDS_BIGENDIAN serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 1); #else serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 0); #endif } else { break; } if (serial_hds[i]) s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP], s->dma, serial_hds[i]); s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]); s->cm_base = 0x41300000; s->cm_regs[CCCR >> 2] = 0x02000210; s->clkcfg = 0x00000009; iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn, pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype); register_savevm(NULL, "pxa2xx_cm", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s); cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s); s->mm_base = 0x48000000; s->mm_regs[MDMRS >> 2] = 0x00020002; s->mm_regs[MDREFR >> 2] = 0x03ca4000; s->mm_regs[MECR >> 2] = 0x00000001; iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn, pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype); register_savevm(NULL, "pxa2xx_mm", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s); s->pm_base = 0x40f00000; iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn, pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->pm_base, 0x100, iomemtype); register_savevm(NULL, "pxa2xx_pm", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s); for (i = 0; pxa255_ssp[i].io_base; i ++); s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i); for (i = 0; pxa255_ssp[i].io_base; i ++) { DeviceState *dev; dev = sysbus_create_simple("pxa2xx-ssp", pxa255_ssp[i].io_base, s->pic[pxa255_ssp[i].irqn]); s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, "ssi"); } if (usb_enabled) { sysbus_create_simple("sysbus-ohci", 0x4c000000, s->pic[PXA2XX_PIC_USBH1]); } s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000); s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000); s->rtc_base = 0x40900000; iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn, pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype); pxa2xx_rtc_init(s); register_savevm(NULL, "pxa2xx_rtc", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s); s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff); s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff); s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma); qdev_connect_gpio_out(s->gpio, 1, s->reset); return s; }
--------------------------------------------- Result 99 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 45 / 11 / 43 / 99:   4%|▎         | 99/2690 [13:34<5:55:13,  8.23s/it][Succeeded / Failed / Skipped / Total] 45 / 11 / 43 / 99:   4%|▎         | 100/2690 [13:39<5:53:40,  8.19s/it][Succeeded / Failed / Skipped / Total] 46 / 11 / 43 / 100:   4%|▎         | 100/2690 [13:39<5:53:40,  8.19s/it][Succeeded / Failed / Skipped / Total] 46 / 11 / 43 / 100:   4%|▍         | 101/2690 [13:49<5:54:13,  8.21s/it][Succeeded / Failed / Skipped / Total] 47 / 11 / 43 / 101:   4%|▍         | 101/2690 [13:49<5:54:13,  8.21s/it][Succeeded / Failed / Skipped / Total] 47 / 11 / 43 / 101:   4%|▍         | 102/2690 [14:06<5:58:03,  8.30s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 43 / 102:   4%|▍         | 102/2690 [14:06<5:58:03,  8.30s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 43 / 102:   4%|▍         | 103/2690 [14:07<5:54:39,  8.23s/it][[0 (3%)]] --> [[0 (51%)]] --> Socre: 0.508192777633667

[[[[Adv]]]]: static uint32_t gic_dist_readw(void *[[opaque]], target_phys_addr_t [[offset]]) { uint32_t val; val = gic_dist_readb([[opaque]], [[offset]]); val |= gic_dist_readb([[opaque]], [[offset]] + 1) << 8; return val; }

[[[[Adv]]]]: static uint32_t gic_dist_readw(void *[[outsider]], target_phys_addr_t [[stray]]) { uint32_t val; val = gic_dist_readb([[outsider]], [[stray]]); val |= gic_dist_readb([[outsider]], [[stray]] + 1) << 8; return val; }
--------------------------------------------- Result 100 ---------------------------------------------
[[0 (46%)]] --> [[0 (76%)]] --> Socre: 0.7558234930038452

[[[[Adv]]]]: static void test_qemu_strtoull_overflow(void) { const char *str = "99999999999999999999999999999999999999999999"; char f = 'X'; const char *[[endptr]] = &f; uint64_t res = 999; int err; err = qemu_strtoull(str, &[[endptr]], 0, &res); g_assert_cmpint(err, ==, -ERANGE); g_assert_cmpint(res, ==, ULLONG_MAX); g_assert([[endptr]] == str + strlen(str)); }

[[[[Adv]]]]: static void test_qemu_strtoull_overflow(void) { const char *str = "99999999999999999999999999999999999999999999"; char f = 'X'; const char *[[deathedred]] = &f; uint64_t res = 999; int err; err = qemu_strtoull(str, &[[deathedred]], 0, &res); g_assert_cmpint(err, ==, -ERANGE); g_assert_cmpint(res, ==, ULLONG_MAX); g_assert([[deathedred]] == str + strlen(str)); }
--------------------------------------------- Result 101 ---------------------------------------------
[[0 (2%)]] --> [[0 (89%)]] --> Socre: 0.8875628709793091

[[[[Adv]]]]: int usb_device_delete_addr(int busnr, int [[addr]]) { USBBus *bus; USBPort *port; USBDevice *dev; bus = usb_bus_find(busnr); if (!bus) return -1; TAILQ_FOREACH(port, &bus->used, next) { if (port->dev->addr == [[addr]]) break; } if (!port) return -1; dev = port->dev; TAILQ_REMOVE(&bus->used, port, next); bus->nused--; usb_attach(port, NULL); dev->info->handle_destroy(dev); TAILQ_INSERT_TAIL(&bus->free, port, next); bus->nfree++; return 0; }

[[[[Adv]]]]: int usb_device_delete_addr(int busnr, int [[ffр]]) { USBBus *bus; USBPort *port; USBDevice *dev; bus = usb_bus_find(busnr); if (!bus) return -1; TAILQ_FOREACH(port, &bus->used, next) { if (port->dev->addr == [[ffр]]) break; } if (!port) return -1; dev = port->dev; TAILQ_REMOVE(&bus->used, port, next); bus->nused--; usb_attach(port, NULL); dev->info->handle_destroy(dev); TAILQ_INSERT_TAIL(&bus->free, port, next); bus->nfree++; return 0; }
--------------------------------------------- Result 102 ---------------------------------------------
[[0 (55%)]] --> [[0 (37%)]] --> Socre: 0.6340848505496979

[[[[Adv]]]]: static int aio_write_f(BlockBackend *[[blk]], int argc, char **argv) { int nr_iov, c; int pattern = 0xcd; struct aio_ctx *ctx = g_new0(struct aio_ctx, 1); ctx->blk = [[blk]]; while ((c = getopt(argc, argv, "CqP:z")) != -1) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'z': ctx->zflag = 1; break; default: return qemuio_command_usage(&aio_write_cmd); } } if (optind > argc - 2) { return qemuio_command_usage(&aio_write_cmd); } if (ctx->zflag && optind != argc - 2) { printf("-z supports only a single length parameter\n"); return 0; } if (ctx->zflag && ctx->Pflag) { printf("-z and -P cannot be specified at the same time\n"); return 0; } ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { print_cvtnum_err(ctx->offset, argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", ctx->offset); block_acct_invalid(blk_get_stats([[blk]]), BLOCK_ACCT_WRITE); return 0; } if (ctx->zflag) { int64_t count = cvtnum(argv[optind]); if (count < 0) { print_cvtnum_err(count, argv[optind]); return 0; } ctx->qiov.size = count; blk_aio_write_zeroes([[blk]], ctx->offset >> 9, count >> 9, 0, aio_write_done, ctx); } else { nr_iov = argc - optind; ctx->buf = create_iovec([[blk]], &ctx->qiov, &argv[optind], nr_iov, pattern); if (ctx->buf == NULL) { block_acct_invalid(blk_get_stats([[blk]]), BLOCK_ACCT_WRITE); return 0; } gettimeofday(&ctx->t1, NULL); block_acct_start(blk_get_stats([[blk]]), &ctx->acct, ctx->qiov.size, BLOCK_ACCT_WRITE); blk_aio_writev([[blk]], ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); } return 0; }

[[[[Adv]]]]: static int aio_write_f(BlockBackend *[[veil]], int argc, char **argv) { int nr_iov, c; int pattern = 0xcd; struct aio_ctx *ctx = g_new0(struct aio_ctx, 1); ctx->blk = [[veil]]; while ((c = getopt(argc, argv, "CqP:z")) != -1) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'z': ctx->zflag = 1; break; default: return qemuio_command_usage(&aio_write_cmd); } } if (optind > argc - 2) { return qemuio_command_usage(&aio_write_cmd); } if (ctx->zflag && optind != argc - 2) { printf("-z supports only a single length parameter\n"); return 0; } if (ctx->zflag && ctx->Pflag) { printf("-z and -P cannot be specified at the same time\n"); return 0; } ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { print_cvtnum_err(ctx->offset, argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", ctx->offset); block_acct_invalid(blk_get_stats([[veil]]), BLOCK_ACCT_WRITE); return 0; } if (ctx->zflag) { int64_t count = cvtnum(argv[optind]); if (count < 0) { print_cvtnum_err(count, argv[optind]); return 0; } ctx->qiov.size = count; blk_aio_write_zeroes([[veil]], ctx->offset >> 9, count >> 9, 0, aio_write_done, ctx); } else { nr_iov = argc - optind; ctx->buf = create_iovec([[veil]], &ctx->qiov, &argv[optind], nr_iov, pattern); if (ctx->buf == NULL) { block_acct_invalid(blk_get_stats([[veil]]), BLOCK_ACCT_WRITE); return 0; } gettimeofday(&ctx->t1, NULL); block_acct_start(blk_get_stats([[veil]]), &ctx->acct, ctx->qiov.size, BLOCK_ACCT_WRITE); blk_aio_writev([[veil]], ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); } return 0; }
--------------------------------------------- Result 103 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 11 / 44 / 103:   4%|▍         | 103/2690 [14:07<5:54:39,  8.23s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 44 / 103:   4%|▍         | 104/2690 [14:20<5:56:42,  8.28s/it][Succeeded / Failed / Skipped / Total] 49 / 11 / 44 / 104:   4%|▍         | 104/2690 [14:20<5:56:42,  8.28s/it][Succeeded / Failed / Skipped / Total] 49 / 11 / 44 / 104:   4%|▍         | 105/2690 [14:54<6:07:04,  8.52s/it][Succeeded / Failed / Skipped / Total] 50 / 11 / 44 / 105:   4%|▍         | 105/2690 [14:54<6:07:04,  8.52s/it][Succeeded / Failed / Skipped / Total] 50 / 11 / 44 / 105:   4%|▍         | 106/2690 [15:16<6:12:12,  8.64s/it][Succeeded / Failed / Skipped / Total] 51 / 11 / 44 / 106:   4%|▍         | 106/2690 [15:16<6:12:12,  8.64s/it][Succeeded / Failed / Skipped / Total] 51 / 11 / 44 / 106:   4%|▍         | 107/2690 [15:34<6:15:49,  8.73s/it][[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int alac_decode_frame(AVCodecContext *avctx, void *outbuffer, int *outputsize, const uint8_t *inbuffer, int input_buffer_size) { ALACContext *alac = avctx->priv_data; int channels; unsigned int outputsamples; int hassize; int readsamplesize; int wasted_bytes; int isnotcompressed; uint8_t interlacing_shift; uint8_t interlacing_leftweight; if (!inbuffer || !input_buffer_size) return input_buffer_size; if (!alac->context_initialized) { if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) { av_log(avctx, AV_LOG_ERROR, "alac: expected %d extradata bytes\n", ALAC_EXTRADATA_SIZE); return input_buffer_size; } if (alac_set_info(alac)) { av_log(avctx, AV_LOG_ERROR, "alac: set_info failed\n"); return input_buffer_size; } alac->context_initialized = 1; } init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8); channels = get_bits(&alac->gb, 3) + 1; if (channels > MAX_CHANNELS) { av_log(avctx, AV_LOG_ERROR, "channels > %d not supported\n", MAX_CHANNELS); return input_buffer_size; } skip_bits(&alac->gb, 4); skip_bits(&alac->gb, 12); hassize = get_bits1(&alac->gb); wasted_bytes = get_bits(&alac->gb, 2); isnotcompressed = get_bits1(&alac->gb); if (hassize) { outputsamples = get_bits_long(&alac->gb, 32); if(outputsamples > alac->setinfo_max_samples_per_frame){ av_log(avctx, AV_LOG_ERROR, "outputsamples %d > %d\n", outputsamples, alac->setinfo_max_samples_per_frame); return -1; } } else outputsamples = alac->setinfo_max_samples_per_frame; if(outputsamples > *outputsize / alac->bytespersample){ av_log(avctx, AV_LOG_ERROR, "sample buffer too small\n"); return -1; } *outputsize = outputsamples * alac->bytespersample; readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1; if (!isnotcompressed) { int16_t predictor_coef_table[channels][32]; int predictor_coef_num[channels]; int prediction_type[channels]; int prediction_quantitization[channels]; int ricemodifier[channels]; int i, chan; interlacing_shift = get_bits(&alac->gb, 8); interlacing_leftweight = get_bits(&alac->gb, 8); for (chan = 0; chan < channels; chan++) { prediction_type[chan] = get_bits(&alac->gb, 4); prediction_quantitization[chan] = get_bits(&alac->gb, 4); ricemodifier[chan] = get_bits(&alac->gb, 3); predictor_coef_num[chan] = get_bits(&alac->gb, 5); for (i = 0; i < predictor_coef_num[chan]; i++) predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16); } if (wasted_bytes) av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented, unhandling of wasted_bytes\n"); for (chan = 0; chan < channels; chan++) { bastardized_rice_decompress(alac, alac->predicterror_buffer[chan], outputsamples, readsamplesize, alac->setinfo_rice_initialhistory, alac->setinfo_rice_kmodifier, ricemodifier[chan] * alac->setinfo_rice_historymult / 4, (1 << alac->setinfo_rice_kmodifier) - 1); if (prediction_type[chan] == 0) { predictor_decompress_fir_adapt(alac->predicterror_buffer[chan], alac->outputsamples_buffer[chan], outputsamples, readsamplesize, predictor_coef_table[chan], predictor_coef_num[chan], prediction_quantitization[chan]); } else { av_log(avctx, AV_LOG_ERROR, "FIXME: unhandled prediction type: %i\n", prediction_type[chan]); } } } else { int i, chan; for (i = 0; i < outputsamples; i++) for (chan = 0; chan < channels; chan++) { int32_t audiobits; audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size); audiobits = extend_sign32(audiobits, alac->setinfo_sample_size); alac->outputsamples_buffer[chan][i] = audiobits; } interlacing_shift = 0; interlacing_leftweight = 0; } if (get_bits(&alac->gb, 3) != 7) av_log(avctx, AV_LOG_ERROR, "Error : Wrong End Of Frame\n"); switch(alac->setinfo_sample_size) { case 16: if (channels == 2) { reconstruct_stereo_16(alac->outputsamples_buffer, (int16_t*)outbuffer, alac->numchannels, outputsamples, interlacing_shift, interlacing_leftweight); } else { int i; for (i = 0; i < outputsamples; i++) { int16_t sample = alac->outputsamples_buffer[0][i]; ((int16_t*)outbuffer)[i * alac->numchannels] = sample; } } break; case 20: case 24: case 32: av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented sample size %i\n", alac->setinfo_sample_size); break; default: break; } if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8) av_log(avctx, AV_LOG_ERROR, "Error : %d bits left\n", input_buffer_size * 8 - get_bits_count(&alac->gb)); return input_buffer_size; }
--------------------------------------------- Result 104 ---------------------------------------------
[[0 (6%)]] --> [[0 (92%)]] --> Socre: 0.9174432158470154

[[[[Adv]]]]: static void qmp_output_type_number(Visitor *v, const char *[[name]], double *obj, Error **errp) { QmpOutputVisitor *[[qov]] = to_qov(v); qmp_output_add([[qov]], [[name]], qfloat_from_double(*obj)); }

[[[[Adv]]]]: static void qmp_output_type_number(Visitor *v, const char *[[surname]], double *obj, Error **errp) { QmpOutputVisitor *[[backов]] = to_qov(v); qmp_output_add([[backов]], [[surname]], qfloat_from_double(*obj)); }
--------------------------------------------- Result 105 ---------------------------------------------
[[0 (32%)]] --> [[0 (52%)]] --> Socre: 0.5239613056182861

[[[[Adv]]]]: static int getopt(int argc, char *argv[], char *[[opts]]) { static int [[sp]] = 1; int c; char *cp; if ([[sp]] == 1) if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0') return EOF; else if (!strcmp(argv[optind], "--")) { optind++; return EOF; } optopt = c = argv[optind][[[sp]]]; if (c == ':' || (cp = strchr([[opts]], c)) == NULL) { fprintf(stderr, ": illegal option -- %c\n", c); if (argv[optind][++[[sp]]] == '\0') { optind++; [[sp]] = 1; } return '?'; } if (*++cp == ':') { if (argv[optind][[[sp]]+1] != '\0') optarg = &argv[optind++][[[sp]]+1]; else if(++optind >= argc) { fprintf(stderr, ": option requires an argument -- %c\n", c); [[sp]] = 1; return '?'; } else optarg = argv[optind++]; [[sp]] = 1; } else { if (argv[optind][++[[sp]]] == '\0') { [[sp]] = 1; optind++; } optarg = NULL; } return c; }

[[[[Adv]]]]: static int getopt(int argc, char *argv[], char *[[ensb]]) { static int [[m]] = 1; int c; char *cp; if ([[m]] == 1) if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0') return EOF; else if (!strcmp(argv[optind], "--")) { optind++; return EOF; } optopt = c = argv[optind][[[m]]]; if (c == ':' || (cp = strchr([[ensb]], c)) == NULL) { fprintf(stderr, ": illegal option -- %c\n", c); if (argv[optind][++[[m]]] == '\0') { optind++; [[m]] = 1; } return '?'; } if (*++cp == ':') { if (argv[optind][[[m]]+1] != '\0') optarg = &argv[optind++][[[m]]+1]; else if(++optind >= argc) { fprintf(stderr, ": option requires an argument -- %c\n", c); [[m]] = 1; return '?'; } else optarg = argv[optind++]; [[m]] = 1; } else { if (argv[optind][++[[m]]] == '\0') { [[m]] = 1; optind++; } optarg = NULL; } return c; }
--------------------------------------------- Result 106 ---------------------------------------------
[[0 (49%)]] --> [[0 (99%)]] --> Socre: 0.9873318076133728

[[[[Adv]]]]: void qemu_cpu_kick(void *[[env]]) { return; }

[[[[Adv]]]]: void qemu_cpu_kick(void *[[preв]]) { return; }
--------------------------------------------- Result 107 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 52 / 11 / 44 / 107:   4%|▍         | 107/2690 [15:34<6:15:49,  8.73s/it][Succeeded / Failed / Skipped / Total] 52 / 11 / 44 / 107:   4%|▍         | 108/2690 [15:37<6:13:23,  8.68s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 44 / 108:   4%|▍         | 108/2690 [15:37<6:13:23,  8.68s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 44 / 108:   4%|▍         | 109/2690 [15:37<6:10:01,  8.60s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 45 / 109:   4%|▍         | 109/2690 [15:37<6:10:01,  8.60s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 45 / 109:   4%|▍         | 110/2690 [15:45<6:09:42,  8.60s/it][[0 (17%)]] --> [[0 (99%)]] --> Socre: 0.9874140620231628

[[[[Adv]]]]: static void temp_allocate_frame(TCGContext *s, int temp) { TCGTemp *[[ts]]; [[ts]] = &s->temps[temp]; s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1); if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end) tcg_abort(); [[ts]]->mem_offset = s->current_frame_offset; [[ts]]->mem_reg = s->frame_reg; [[ts]]->mem_allocated = 1; s->current_frame_offset += sizeof(tcg_target_long); }

[[[[Adv]]]]: static void temp_allocate_frame(TCGContext *s, int temp) { TCGTemp *[[ツ]]; [[ツ]] = &s->temps[temp]; s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1); if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end) tcg_abort(); [[ツ]]->mem_offset = s->current_frame_offset; [[ツ]]->mem_reg = s->frame_reg; [[ツ]]->mem_allocated = 1; s->current_frame_offset += sizeof(tcg_target_long); }
--------------------------------------------- Result 108 ---------------------------------------------
[[0 (14%)]] --> [[0 (56%)]] --> Socre: 0.5605487823486328

[[[[Adv]]]]: static void slavio_timer_mem_writel(void *[[opaque]], target_phys_addr_t [[addr]], uint32_t val) { SLAVIO_TIMERState *s = [[opaque]]; uint32_t [[saddr]]; int reload = 0; DPRINTF("write " TARGET_FMT_plx " %08x\n", [[addr]], val); [[saddr]] = ([[addr]] & TIMER_MAXADDR) >> 2; switch ([[saddr]]) { case TIMER_LIMIT: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else { qemu_irq_lower(s->irq); s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, s->limit >> 9, 1); } break; case TIMER_COUNTER: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else DPRINTF("not user timer\n"); break; case TIMER_COUNTER_NORST: s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload); break; case TIMER_STATUS: if (slavio_timer_is_user(s)) { if ((val & 1) && !s->running) { DPRINTF("processor %d user timer started\n", s->slave_index); ptimer_run(s->timer, 0); s->running = 1; } else if (!(val & 1) && s->running) { DPRINTF("processor %d user timer stopped\n", s->slave_index); ptimer_stop(s->timer); s->running = 0; } } break; case TIMER_MODE: if (s->master == NULL) { unsigned int i; for (i = 0; i < s->num_slaves; i++) { if (val & (1 << i)) { qemu_irq_lower(s->slave[i]->irq); s->slave[i]->limit = -1ULL; } if ((val & (1 << i)) != (s->slave_mode & (1 << i))) { ptimer_stop(s->slave[i]->timer); ptimer_set_limit(s->slave[i]->timer, LIMIT_TO_PERIODS(s->slave[i]->limit), 1); DPRINTF("processor %d timer changed\n", s->slave[i]->slave_index); ptimer_run(s->slave[i]->timer, 0); } } s->slave_mode = val & ((1 << s->num_slaves) - 1); } else DPRINTF("not system timer\n"); break; default: DPRINTF("invalid write address " TARGET_FMT_plx "\n", [[addr]]); break; } }

[[[[Adv]]]]: static void slavio_timer_mem_writel(void *[[monitor]], target_phys_addr_t [[extrad]], uint32_t val) { SLAVIO_TIMERState *s = [[monitor]]; uint32_t [[pundur]]; int reload = 0; DPRINTF("write " TARGET_FMT_plx " %08x\n", [[extrad]], val); [[pundur]] = ([[extrad]] & TIMER_MAXADDR) >> 2; switch ([[pundur]]) { case TIMER_LIMIT: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else { qemu_irq_lower(s->irq); s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, s->limit >> 9, 1); } break; case TIMER_COUNTER: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else DPRINTF("not user timer\n"); break; case TIMER_COUNTER_NORST: s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload); break; case TIMER_STATUS: if (slavio_timer_is_user(s)) { if ((val & 1) && !s->running) { DPRINTF("processor %d user timer started\n", s->slave_index); ptimer_run(s->timer, 0); s->running = 1; } else if (!(val & 1) && s->running) { DPRINTF("processor %d user timer stopped\n", s->slave_index); ptimer_stop(s->timer); s->running = 0; } } break; case TIMER_MODE: if (s->master == NULL) { unsigned int i; for (i = 0; i < s->num_slaves; i++) { if (val & (1 << i)) { qemu_irq_lower(s->slave[i]->irq); s->slave[i]->limit = -1ULL; } if ((val & (1 << i)) != (s->slave_mode & (1 << i))) { ptimer_stop(s->slave[i]->timer); ptimer_set_limit(s->slave[i]->timer, LIMIT_TO_PERIODS(s->slave[i]->limit), 1); DPRINTF("processor %d timer changed\n", s->slave[i]->slave_index); ptimer_run(s->slave[i]->timer, 0); } } s->slave_mode = val & ((1 << s->num_slaves) - 1); } else DPRINTF("not system timer\n"); break; default: DPRINTF("invalid write address " TARGET_FMT_plx "\n", [[extrad]]); break; } }
--------------------------------------------- Result 109 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mptsas_scsi_init(PCIDevice *dev, Error **errp) { DeviceState *d = DEVICE(dev); MPTSASState *s = MPT_SAS(dev); dev->config[PCI_LATENCY_TIMER] = 0; dev->config[PCI_INTERRUPT_PIN] = 0x01; memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s, "mptsas-mmio", 0x4000); memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s, "mptsas-io", 256); memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s, "mptsas-diag", 0x10000); if (s->msi != ON_OFF_AUTO_OFF && msi_init(dev, 0, 1, "True" == "True", "False" != "False") >= 0) { s->msi_in_use = "True" == "True"; } pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io); pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io); pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io); if (!s->sas_addr) { s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) | IEEE_COMPANY_LOCALLY_ASSIGNED) << 36; s->sas_addr |= (pci_bus_num(dev->bus) << 16); s->sas_addr |= (PCI_SLOT(dev->devfn) << 8); s->sas_addr |= PCI_FUNC(dev->devfn); } s->max_devices = MPTSAS_NUM_PORTS; s->request_bh = qemu_bh_new(mptsas_fetch_requests, s); QTAILQ_INIT(&s->pending); scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, errp); } }
--------------------------------------------- Result 110 ---------------------------------------------
[[0 (64%)]] --> [[0 (49%)]] --> Socre: 0.5116600394248962

[[[[Adv]]]]: static int alloc_refcount_block(BlockDriverState *bs, int64_t [[cluster_index]], uint16_t **refcount_block) { BDRVQcowState *s = bs->opaque; unsigned int [[refcount_table_index]]; int [[ret]]; BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC); [[refcount_table_index]] = [[cluster_index]] >> s->refcount_block_bits; if ([[refcount_table_index]] < s->refcount_table_size) { uint64_t refcount_block_offset = s->refcount_table[[[refcount_table_index]]] & REFT_OFFSET_MASK; if (refcount_block_offset) { if (offset_into_cluster(s, refcount_block_offset)) { qcow2_signal_corruption(bs, "[[True]]" == "[[True]]", -1, -1, "Refblock offset %#" PRIx64 " unaligned (reftable index: " "%#x)", refcount_block_offset, [[refcount_table_index]]); return -EIO; } return load_refcount_block(bs, refcount_block_offset, (void**) refcount_block); } } *refcount_block = NULL; [[ret]] = qcow2_cache_flush(bs, s->l2_table_cache); if ([[ret]] < 0) { return [[ret]]; } int64_t [[new_block]] = alloc_clusters_noref(bs, s->cluster_size); if ([[new_block]] < 0) { return [[new_block]]; } #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64 " at %" PRIx64 "\n", [[refcount_table_index]], [[cluster_index]] << s->cluster_bits, [[new_block]]); #endif if (in_same_refcount_block(s, [[new_block]], [[cluster_index]] << s->cluster_bits)) { [[ret]] = qcow2_cache_get_empty(bs, s->refcount_block_cache, [[new_block]], (void**) refcount_block); if ([[ret]] < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); int block_index = ([[new_block]] >> s->cluster_bits) & (s->refcount_block_size - 1); (*refcount_block)[block_index] = cpu_to_be16(1); } else { [[ret]] = update_refcount(bs, [[new_block]], s->cluster_size, 1, "False" != "False", QCOW2_DISCARD_NEVER); if ([[ret]] < 0) { goto fail_block; } [[ret]] = qcow2_cache_flush(bs, s->refcount_block_cache); if ([[ret]] < 0) { goto fail_block; } [[ret]] = qcow2_cache_get_empty(bs, s->refcount_block_cache, [[new_block]], (void**) refcount_block); if ([[ret]] < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE); qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block); [[ret]] = qcow2_cache_flush(bs, s->refcount_block_cache); if ([[ret]] < 0) { goto fail_block; } if ([[refcount_table_index]] < s->refcount_table_size) { uint64_t data64 = cpu_to_be64([[new_block]]); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP); [[ret]] = bdrv_pwrite_sync(bs->file, s->refcount_table_offset + [[refcount_table_index]] * sizeof(uint64_t), &data64, sizeof(data64)); if ([[ret]] < 0) { goto fail_block; } s->refcount_table[[[refcount_table_index]]] = [[new_block]]; return -EAGAIN; } [[ret]] = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); if ([[ret]] < 0) { goto fail_block; } BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW); uint64_t blocks_used = DIV_ROUND_UP([[cluster_index]], s->refcount_block_size); if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) { return -EFBIG; } uint64_t table_size = next_refcount_table_size(s, blocks_used + 1); uint64_t last_table_size; uint64_t blocks_clusters; do { uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); blocks_clusters = 1 + ((table_clusters + s->refcount_block_size - 1) / s->refcount_block_size); uint64_t meta_clusters = table_clusters + blocks_clusters; last_table_size = table_size; table_size = next_refcount_table_size(s, blocks_used + ((meta_clusters + s->refcount_block_size - 1) / s->refcount_block_size)); } while (last_table_size != table_size); #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " => %" PRId64 "\n", s->refcount_table_size, table_size); #endif uint64_t meta_offset = (blocks_used * s->refcount_block_size) * s->cluster_size; uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size; uint64_t *new_table = g_try_new0(uint64_t, table_size); uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size); assert(table_size > 0 && blocks_clusters > 0); if (new_table == NULL || new_blocks == NULL) { [[ret]] = -ENOMEM; goto fail_table; } memcpy(new_table, s->refcount_table, s->refcount_table_size * sizeof(uint64_t)); new_table[[[refcount_table_index]]] = [[new_block]]; int i; for (i = 0; i < blocks_clusters; i++) { new_table[blocks_used + i] = meta_offset + (i * s->cluster_size); } uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); int block = 0; for (i = 0; i < table_clusters + blocks_clusters; i++) { new_blocks[block++] = cpu_to_be16(1); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS); [[ret]] = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks, blocks_clusters * s->cluster_size); g_free(new_blocks); new_blocks = NULL; if ([[ret]] < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { cpu_to_be64s(&new_table[i]); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE); [[ret]] = bdrv_pwrite_sync(bs->file, table_offset, new_table, table_size * sizeof(uint64_t)); if ([[ret]] < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { be64_to_cpus(&new_table[i]); } uint8_t data[12]; cpu_to_be64w((uint64_t*)data, table_offset); cpu_to_be32w((uint32_t*)(data + 8), table_clusters); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE); [[ret]] = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset), data, sizeof(data)); if ([[ret]] < 0) { goto fail_table; } uint64_t old_table_offset = s->refcount_table_offset; uint64_t old_table_size = s->refcount_table_size; g_free(s->refcount_table); s->refcount_table = new_table; s->refcount_table_size = table_size; s->refcount_table_offset = table_offset; qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t), QCOW2_DISCARD_OTHER); [[ret]] = load_refcount_block(bs, [[new_block]], (void**) refcount_block); if ([[ret]] < 0) { return [[ret]]; } return -EAGAIN; fail_table: g_free(new_blocks); g_free(new_table); fail_block: if (*refcount_block != NULL) { qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); } return [[ret]]; }

[[[[Adv]]]]: static int alloc_refcount_block(BlockDriverState *bs, int64_t [[bandousengine]], uint16_t **refcount_block) { BDRVQcowState *s = bs->opaque; unsigned int [[cekoontaltablesbyeh]]; int [[vetting]]; BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC); [[cekoontaltablesbyeh]] = [[bandousengine]] >> s->refcount_block_bits; if ([[cekoontaltablesbyeh]] < s->refcount_table_size) { uint64_t refcount_block_offset = s->refcount_table[[[cekoontaltablesbyeh]]] & REFT_OFFSET_MASK; if (refcount_block_offset) { if (offset_into_cluster(s, refcount_block_offset)) { qcow2_signal_corruption(bs, "[[pure]]" == "[[pure]]", -1, -1, "Refblock offset %#" PRIx64 " unaligned (reftable index: " "%#x)", refcount_block_offset, [[cekoontaltablesbyeh]]); return -EIO; } return load_refcount_block(bs, refcount_block_offset, (void**) refcount_block); } } *refcount_block = NULL; [[vetting]] = qcow2_cache_flush(bs, s->l2_table_cache); if ([[vetting]] < 0) { return [[vetting]]; } int64_t [[nquadround]] = alloc_clusters_noref(bs, s->cluster_size); if ([[nquadround]] < 0) { return [[nquadround]]; } #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64 " at %" PRIx64 "\n", [[cekoontaltablesbyeh]], [[bandousengine]] << s->cluster_bits, [[nquadround]]); #endif if (in_same_refcount_block(s, [[nquadround]], [[bandousengine]] << s->cluster_bits)) { [[vetting]] = qcow2_cache_get_empty(bs, s->refcount_block_cache, [[nquadround]], (void**) refcount_block); if ([[vetting]] < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); int block_index = ([[nquadround]] >> s->cluster_bits) & (s->refcount_block_size - 1); (*refcount_block)[block_index] = cpu_to_be16(1); } else { [[vetting]] = update_refcount(bs, [[nquadround]], s->cluster_size, 1, "False" != "False", QCOW2_DISCARD_NEVER); if ([[vetting]] < 0) { goto fail_block; } [[vetting]] = qcow2_cache_flush(bs, s->refcount_block_cache); if ([[vetting]] < 0) { goto fail_block; } [[vetting]] = qcow2_cache_get_empty(bs, s->refcount_block_cache, [[nquadround]], (void**) refcount_block); if ([[vetting]] < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE); qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block); [[vetting]] = qcow2_cache_flush(bs, s->refcount_block_cache); if ([[vetting]] < 0) { goto fail_block; } if ([[cekoontaltablesbyeh]] < s->refcount_table_size) { uint64_t data64 = cpu_to_be64([[nquadround]]); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP); [[vetting]] = bdrv_pwrite_sync(bs->file, s->refcount_table_offset + [[cekoontaltablesbyeh]] * sizeof(uint64_t), &data64, sizeof(data64)); if ([[vetting]] < 0) { goto fail_block; } s->refcount_table[[[cekoontaltablesbyeh]]] = [[nquadround]]; return -EAGAIN; } [[vetting]] = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); if ([[vetting]] < 0) { goto fail_block; } BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW); uint64_t blocks_used = DIV_ROUND_UP([[bandousengine]], s->refcount_block_size); if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) { return -EFBIG; } uint64_t table_size = next_refcount_table_size(s, blocks_used + 1); uint64_t last_table_size; uint64_t blocks_clusters; do { uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); blocks_clusters = 1 + ((table_clusters + s->refcount_block_size - 1) / s->refcount_block_size); uint64_t meta_clusters = table_clusters + blocks_clusters; last_table_size = table_size; table_size = next_refcount_table_size(s, blocks_used + ((meta_clusters + s->refcount_block_size - 1) / s->refcount_block_size)); } while (last_table_size != table_size); #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " => %" PRId64 "\n", s->refcount_table_size, table_size); #endif uint64_t meta_offset = (blocks_used * s->refcount_block_size) * s->cluster_size; uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size; uint64_t *new_table = g_try_new0(uint64_t, table_size); uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size); assert(table_size > 0 && blocks_clusters > 0); if (new_table == NULL || new_blocks == NULL) { [[vetting]] = -ENOMEM; goto fail_table; } memcpy(new_table, s->refcount_table, s->refcount_table_size * sizeof(uint64_t)); new_table[[[cekoontaltablesbyeh]]] = [[nquadround]]; int i; for (i = 0; i < blocks_clusters; i++) { new_table[blocks_used + i] = meta_offset + (i * s->cluster_size); } uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); int block = 0; for (i = 0; i < table_clusters + blocks_clusters; i++) { new_blocks[block++] = cpu_to_be16(1); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS); [[vetting]] = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks, blocks_clusters * s->cluster_size); g_free(new_blocks); new_blocks = NULL; if ([[vetting]] < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { cpu_to_be64s(&new_table[i]); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE); [[vetting]] = bdrv_pwrite_sync(bs->file, table_offset, new_table, table_size * sizeof(uint64_t)); if ([[vetting]] < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { be64_to_cpus(&new_table[i]); } uint8_t data[12]; cpu_to_be64w((uint64_t*)data, table_offset); cpu_to_be32w((uint32_t*)(data + 8), table_clusters); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE); [[vetting]] = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset), data, sizeof(data)); if ([[vetting]] < 0) { goto fail_table; } uint64_t old_table_offset = s->refcount_table_offset; uint64_t old_table_size = s->refcount_table_size; g_free(s->refcount_table); s->refcount_table = new_table; s->refcount_table_size = table_size; s->refcount_table_offset = table_offset; qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t), QCOW2_DISCARD_OTHER); [[vetting]] = load_refcount_block(bs, [[nquadround]], (void**) refcount_block); if ([[vetting]] < 0) { return [[vetting]]; } return -EAGAIN; fail_table: g_free(new_blocks); g_free(new_table); fail_block: if (*refcount_block != NULL) { qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); } return [[vetting]]; }[Succeeded / Failed / Skipped / Total] 54 / 11 / 45 / 110:   4%|▍         | 110/2690 [15:45<6:09:42,  8.60s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 45 / 110:   4%|▍         | 111/2690 [15:46<6:06:25,  8.52s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 46 / 111:   4%|▍         | 111/2690 [15:46<6:06:25,  8.52s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 46 / 111:   4%|▍         | 112/2690 [15:57<6:07:17,  8.55s/it][Succeeded / Failed / Skipped / Total] 55 / 11 / 46 / 112:   4%|▍         | 112/2690 [15:57<6:07:17,  8.55s/it][Succeeded / Failed / Skipped / Total] 55 / 11 / 46 / 112:   4%|▍         | 113/2690 [15:58<6:04:26,  8.49s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 46 / 113:   4%|▍         | 113/2690 [15:58<6:04:26,  8.49s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 46 / 113:   4%|▍         | 114/2690 [15:59<6:01:16,  8.41s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 47 / 114:   4%|▍         | 114/2690 [15:59<6:01:16,  8.41s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 47 / 114:   4%|▍         | 115/2690 [16:09<6:01:57,  8.43s/it][Succeeded / Failed / Skipped / Total] 57 / 11 / 47 / 115:   4%|▍         | 115/2690 [16:09<6:01:57,  8.43s/it][Succeeded / Failed / Skipped / Total] 57 / 11 / 47 / 115:   4%|▍         | 116/2690 [16:19<6:02:21,  8.45s/it][Succeeded / Failed / Skipped / Total] 58 / 11 / 47 / 116:   4%|▍         | 116/2690 [16:19<6:02:21,  8.45s/it][Succeeded / Failed / Skipped / Total] 58 / 11 / 47 / 116:   4%|▍         | 117/2690 [16:43<6:07:45,  8.58s/it][Succeeded / Failed / Skipped / Total] 59 / 11 / 47 / 117:   4%|▍         | 117/2690 [16:43<6:07:45,  8.58s/it][Succeeded / Failed / Skipped / Total] 59 / 11 / 47 / 117:   4%|▍         | 118/2690 [16:54<6:08:32,  8.60s/it][Succeeded / Failed / Skipped / Total] 60 / 11 / 47 / 118:   4%|▍         | 118/2690 [16:54<6:08:32,  8.60s/it][Succeeded / Failed / Skipped / Total] 60 / 11 / 47 / 118:   4%|▍         | 119/2690 [16:55<6:05:29,  8.53s/it]
--------------------------------------------- Result 111 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: FFTContext *av_fft_init(int nbits, int inverse) { FFTContext *s = av_malloc(sizeof(*s)); if (s && ff_fft_init(s, nbits, inverse)) av_freep(&s); return s; }
--------------------------------------------- Result 112 ---------------------------------------------
[[0 (3%)]] --> [[0 (98%)]] --> Socre: 0.9833373427391052

[[[[Adv]]]]: static inline int num_effective_busses(XilinxSPIPS *[[s]]) { return ([[s]]->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS && [[s]]->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? [[s]]->num_busses : 1; }

[[[[Adv]]]]: static inline int num_effective_busses(XilinxSPIPS *[[ս]]) { return ([[ս]]->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS && [[ս]]->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? [[ս]]->num_busses : 1; }
--------------------------------------------- Result 113 ---------------------------------------------
[[0 (34%)]] --> [[0 (97%)]] --> Socre: 0.9710299372673035

[[[[Adv]]]]: void qmp_block_stream(const char *device, bool has_base, const char *base, Error **errp) { BlockDriverState *bs; BlockDriverState *[[base_bs]] = NULL; Error *[[local_err]] = NULL; bs = bdrv_find(device); if (!bs) { error_set(errp, QERR_DEVICE_NOT_FOUND, device); return; } if (base) { [[base_bs]] = bdrv_find_backing_image(bs, base); if ([[base_bs]] == NULL) { error_set(errp, QERR_BASE_NOT_FOUND, base); return; } } stream_start(bs, [[base_bs]], base, block_stream_cb, bs, &[[local_err]]); if (error_is_set(&[[local_err]])) { error_propagate(errp, [[local_err]]); return; } drive_get_ref(drive_get_by_blockdev(bs)); trace_qmp_block_stream(bs, bs->job); }

[[[[Adv]]]]: void qmp_block_stream(const char *device, bool has_base, const char *base, Error **errp) { BlockDriverState *bs; BlockDriverState *[[baselogbb]] = NULL; Error *[[primelogamρ]] = NULL; bs = bdrv_find(device); if (!bs) { error_set(errp, QERR_DEVICE_NOT_FOUND, device); return; } if (base) { [[baselogbb]] = bdrv_find_backing_image(bs, base); if ([[baselogbb]] == NULL) { error_set(errp, QERR_BASE_NOT_FOUND, base); return; } } stream_start(bs, [[baselogbb]], base, block_stream_cb, bs, &[[primelogamρ]]); if (error_is_set(&[[primelogamρ]])) { error_propagate(errp, [[primelogamρ]]); return; } drive_get_ref(drive_get_by_blockdev(bs)); trace_qmp_block_stream(bs, bs->job); }
--------------------------------------------- Result 114 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp) { CommitBlockJob *s = container_of(job, CommitBlockJob, common); if (speed < 0) { error_setg(errp, QERR_INVALID_PARAMETER, "speed"); return; } ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME); }
--------------------------------------------- Result 115 ---------------------------------------------
[[0 (98%)]] --> [[0 (33%)]] --> Socre: 0.6708628535270691

[[[[Adv]]]]: static void gen_set_CF_bit31(TCGv var) { TCGv [[tmp]] = new_tmp(); tcg_gen_shri_i32([[tmp]], var, 31); gen_set_CF([[tmp]]); dead_tmp([[tmp]]); }

[[[[Adv]]]]: static void gen_set_CF_bit31(TCGv var) { TCGv [[jrs]] = new_tmp(); tcg_gen_shri_i32([[jrs]], var, 31); gen_set_CF([[jrs]]); dead_tmp([[jrs]]); }
--------------------------------------------- Result 116 ---------------------------------------------
[[0 (70%)]] --> [[0 (45%)]] --> Socre: 0.5489208996295929

[[[[Adv]]]]: static void sd_1d97_int(int *p, int i0, int i1) { int [[i]]; if (i1 <= i0 + 1) { if (i0 == 1) p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16; else p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16; return; } extend97_int(p, i0, i1); i0++; i1++; for ([[i]] = i0/2 - 2; [[i]] < i1/2 + 1; [[i]]++) p[2 * [[i]] + 1] -= (I_LFTG_ALPHA * (p[2 * [[i]]] + p[2 * [[i]] + 2]) + (1 << 15)) >> 16; for ([[i]] = i0/2 - 1; [[i]] < i1/2 + 1; [[i]]++) p[2 * [[i]]] -= (I_LFTG_BETA * (p[2 * [[i]] - 1] + p[2 * [[i]] + 1]) + (1 << 15)) >> 16; for ([[i]] = i0/2 - 1; [[i]] < i1/2; [[i]]++) p[2 * [[i]] + 1] += (I_LFTG_GAMMA * (p[2 * [[i]]] + p[2 * [[i]] + 2]) + (1 << 15)) >> 16; for ([[i]] = i0/2; [[i]] < i1/2; [[i]]++) p[2 * [[i]]] += (I_LFTG_DELTA * (p[2 * [[i]] - 1] + p[2 * [[i]] + 1]) + (1 << 15)) >> 16; }

[[[[Adv]]]]: static void sd_1d97_int(int *p, int i0, int i1) { int [[bell]]; if (i1 <= i0 + 1) { if (i0 == 1) p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16; else p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16; return; } extend97_int(p, i0, i1); i0++; i1++; for ([[bell]] = i0/2 - 2; [[bell]] < i1/2 + 1; [[bell]]++) p[2 * [[bell]] + 1] -= (I_LFTG_ALPHA * (p[2 * [[bell]]] + p[2 * [[bell]] + 2]) + (1 << 15)) >> 16; for ([[bell]] = i0/2 - 1; [[bell]] < i1/2 + 1; [[bell]]++) p[2 * [[bell]]] -= (I_LFTG_BETA * (p[2 * [[bell]] - 1] + p[2 * [[bell]] + 1]) + (1 << 15)) >> 16; for ([[bell]] = i0/2 - 1; [[bell]] < i1/2; [[bell]]++) p[2 * [[bell]] + 1] += (I_LFTG_GAMMA * (p[2 * [[bell]]] + p[2 * [[bell]] + 2]) + (1 << 15)) >> 16; for ([[bell]] = i0/2; [[bell]] < i1/2; [[bell]]++) p[2 * [[bell]]] += (I_LFTG_DELTA * (p[2 * [[bell]] - 1] + p[2 * [[bell]] + 1]) + (1 << 15)) >> 16; }
--------------------------------------------- Result 117 ---------------------------------------------
[[0 (9%)]] --> [[0 (97%)]] --> Socre: 0.9686031341552734

[[[[Adv]]]]: static uint32_t s390_pci_generate_fid(Error **errp) { uint32_t [[fid]] = 0; while ([[fid]] <= ZPCI_MAX_FID) { if (!s390_pci_find_dev_by_fid([[fid]])) { return [[fid]]; } if ([[fid]] == ZPCI_MAX_FID) { break; } [[fid]]++; } error_setg(errp, "no free fid could be found"); return 0; }

[[[[Adv]]]]: static uint32_t s390_pci_generate_fid(Error **errp) { uint32_t [[فdp]] = 0; while ([[فdp]] <= ZPCI_MAX_FID) { if (!s390_pci_find_dev_by_fid([[فdp]])) { return [[فdp]]; } if ([[فdp]] == ZPCI_MAX_FID) { break; } [[فdp]]++; } error_setg(errp, "no free fid could be found"); return 0; }
--------------------------------------------- Result 118 ---------------------------------------------
[[0 (93%)]] --> [[0 (37%)]] --> Socre: 0.6341776549816132

[[[[Adv]]]]: static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int [[width]]) { int [[i]]; for([[i]]=0; [[i]]<[[width]]; [[i]]++) { int r= ((uint32_t*)src)[[[i]]]&0xFF; int g= (((uint32_t*)src)[[[i]]]>>8)&0xFF; int b= (((uint32_t*)src)[[[i]]]>>16)&0xFF; dst[[[i]]]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT); } }

[[[[Adv]]]]: static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int [[wheelbase]]) { int [[citation]]; for([[citation]]=0; [[citation]]<[[wheelbase]]; [[citation]]++) { int r= ((uint32_t*)src)[[[citation]]]&0xFF; int g= (((uint32_t*)src)[[[citation]]]>>8)&0xFF; int b= (((uint32_t*)src)[[[citation]]]>>16)&0xFF; dst[[[citation]]]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT); } }
--------------------------------------------- Result 119 ---------------------------------------------
[[0 (99%)]] --> [[0 (24%)]] --> Socre: 0.7589109688997269

[[[[Adv]]]]: static int get_siz(Jpeg2000DecoderContext *[[s]]) { int [[i]]; int ncomponents; uint32_t log2_chroma_wh = 0; const enum AVPixelFormat *[[possible_fmts]] = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&[[s]]->g) < 36) { av_log([[s]]->avctx, AV_LOG_ERROR, "Insufficient space for SIZ\n"); [[s]]->avctx->profile = bytestream2_get_be16u(&[[s]]->g); [[s]]->width = bytestream2_get_be32u(&[[s]]->g); [[s]]->height = bytestream2_get_be32u(&[[s]]->g); [[s]]->image_offset_x = bytestream2_get_be32u(&[[s]]->g); [[s]]->image_offset_y = bytestream2_get_be32u(&[[s]]->g); [[s]]->tile_width = bytestream2_get_be32u(&[[s]]->g); [[s]]->tile_height = bytestream2_get_be32u(&[[s]]->g); [[s]]->tile_offset_x = bytestream2_get_be32u(&[[s]]->g); [[s]]->tile_offset_y = bytestream2_get_be32u(&[[s]]->g); ncomponents = bytestream2_get_be16u(&[[s]]->g); if ([[s]]->image_offset_x || [[s]]->image_offset_y) { avpriv_request_sample([[s]]->avctx, "Support for image offsets"); return AVERROR_PATCHWELCOME; if (av_image_check_size([[s]]->width, [[s]]->height, 0, [[s]]->avctx)) { avpriv_request_sample([[s]]->avctx, "Large Dimensions"); return AVERROR_PATCHWELCOME; if (ncomponents <= 0) { av_log([[s]]->avctx, AV_LOG_ERROR, "Invalid number of components: %d\n", if (ncomponents > 4) { avpriv_request_sample([[s]]->avctx, "Support for %d components", ncomponents); return AVERROR_PATCHWELCOME; [[s]]->ncomponents = ncomponents; if ([[s]]->tile_width <= 0 || [[s]]->tile_height <= 0) { av_log([[s]]->avctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n", [[s]]->tile_width, [[s]]->tile_height); if (bytestream2_get_bytes_left(&[[s]]->g) < 3 * [[s]]->ncomponents) { av_log([[s]]->avctx, AV_LOG_ERROR, "Insufficient space for %d components in SIZ\n", [[s]]->ncomponents); for ([[i]] = 0; i < [[s]]->ncomponents; [[i]]++) { uint8_t x = bytestream2_get_byteu(&[[s]]->g); [[s]]->cbps[[[i]]] = (x & 0x7f) + 1; [[s]]->precision = FFMAX([[s]]->cbps[[[i]]], [[s]]->precision); [[s]]->sgnd[[[i]]] = !!(x & 0x80); [[s]]->cdx[[[i]]] = bytestream2_get_byteu(&[[s]]->g); [[s]]->cdy[[[i]]] = bytestream2_get_byteu(&[[s]]->g); if ( ![[s]]->cdx[[[i]]] || [[s]]->cdx[[[i]]] == 3 || [[s]]->cdx[[[i]]] > 4 || ![[s]]->cdy[[[i]]] || [[s]]->cdy[[[i]]] == 3 || [[s]]->cdy[[[i]]] > 4) { av_log([[s]]->avctx, AV_LOG_ERROR, "Invalid sample separation %d/%d\n", [[s]]->cdx[[[i]]], [[s]]->cdy[[[i]]]); log2_chroma_wh |= [[s]]->cdy[[[i]]] >> 1 << [[i]] * 4 | [[s]]->cdx[[[i]]] >> 1 << [[i]] * 4 + 2; [[s]]->numXtiles = ff_jpeg2000_ceildiv([[s]]->width - [[s]]->tile_offset_x, [[s]]->tile_width); [[s]]->numYtiles = ff_jpeg2000_ceildiv([[s]]->height - [[s]]->tile_offset_y, [[s]]->tile_height); if ([[s]]->numXtiles * (uint64_t)[[s]]->numYtiles > INT_MAX/sizeof(*[[s]]->tile)) { [[s]]->numXtiles = [[s]]->numYtiles = 0; return AVERROR(EINVAL); [[s]]->tile = av_mallocz_array([[s]]->numXtiles * [[s]]->numYtiles, sizeof(*[[s]]->tile)); if (![[s]]->tile) { [[s]]->numXtiles = [[s]]->numYtiles = 0; return AVERROR(ENOMEM); for ([[i]] = 0; [[i]] < [[s]]->numXtiles * [[s]]->numYtiles; [[i]]++) { Jpeg2000Tile *tile = [[s]]->tile + [[i]]; tile->comp = av_mallocz([[s]]->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); [[s]]->avctx->width = ff_jpeg2000_ceildivpow2([[s]]->width - [[s]]->image_offset_x, [[s]]->reduction_factor); [[s]]->avctx->height = ff_jpeg2000_ceildivpow2([[s]]->height - [[s]]->image_offset_y, [[s]]->reduction_factor); if ([[s]]->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || [[s]]->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { [[possible_fmts]] = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch ([[s]]->colour_space) { case 16: [[possible_fmts]] = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: [[possible_fmts]] = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: [[possible_fmts]] = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: [[possible_fmts]] = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; for ([[i]] = 0; i < possible_fmts_nb; ++[[i]]) { if (pix_fmt_match([[possible_fmts]][[[i]]], ncomponents, [[s]]->precision, log2_chroma_wh, [[s]]->pal8)) { [[s]]->avctx->pix_fmt = [[possible_fmts]][[[i]]]; break; if ([[i]] == possible_fmts_nb) { if (ncomponents == 4 && [[s]]->cdy[0] == 1 && [[s]]->cdx[0] == 1 && [[s]]->cdy[1] == 1 && [[s]]->cdx[1] == 1 && [[s]]->cdy[2] == [[s]]->cdy[3] && [[s]]->cdx[2] == [[s]]->cdx[3]) { if ([[s]]->precision == 8 && [[s]]->cdy[2] == 2 && [[s]]->cdx[2] == 2 && ![[s]]->pal8) { [[s]]->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; [[s]]->cdef[0] = 0; [[s]]->cdef[1] = 1; [[s]]->cdef[2] = 2; [[s]]->cdef[3] = 3; [[i]] = 0; if ([[i]] == possible_fmts_nb) { av_log([[s]]->avctx, AV_LOG_ERROR, "Unknown pix_fmt, profile: %d, colour_space: %d, " "components: %d, precision: %d\n" "cdx[0]: %d, cdy[0]: %d\n" "cdx[1]: %d, cdy[1]: %d\n" "cdx[2]: %d, cdy[2]: %d\n" "cdx[3]: %d, cdy[3]: %d\n", [[s]]->avctx->profile, [[s]]->colour_space, ncomponents, [[s]]->precision, [[s]]->cdx[0], [[s]]->cdy[0], ncomponents > 1 ? [[s]]->cdx[1] : 0, ncomponents > 1 ? [[s]]->cdy[1] : 0, ncomponents > 2 ? [[s]]->cdx[2] : 0, ncomponents > 2 ? [[s]]->cdy[2] : 0, ncomponents > 3 ? [[s]]->cdx[3] : 0, ncomponents > 3 ? [[s]]->cdy[3] : 0); return AVERROR_PATCHWELCOME; [[s]]->avctx->bits_per_raw_sample = [[s]]->precision; return 0;

[[[[Adv]]]]: static int get_siz(Jpeg2000DecoderContext *[[sb]]) { int [[ia]]; int ncomponents; uint32_t log2_chroma_wh = 0; const enum AVPixelFormat *[[probablemodisצ]] = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&[[sb]]->g) < 36) { av_log([[sb]]->avctx, AV_LOG_ERROR, "Insufficient space for SIZ\n"); [[sb]]->avctx->profile = bytestream2_get_be16u(&[[sb]]->g); [[sb]]->width = bytestream2_get_be32u(&[[sb]]->g); [[sb]]->height = bytestream2_get_be32u(&[[sb]]->g); [[sb]]->image_offset_x = bytestream2_get_be32u(&[[sb]]->g); [[sb]]->image_offset_y = bytestream2_get_be32u(&[[sb]]->g); [[sb]]->tile_width = bytestream2_get_be32u(&[[sb]]->g); [[sb]]->tile_height = bytestream2_get_be32u(&[[sb]]->g); [[sb]]->tile_offset_x = bytestream2_get_be32u(&[[sb]]->g); [[sb]]->tile_offset_y = bytestream2_get_be32u(&[[sb]]->g); ncomponents = bytestream2_get_be16u(&[[sb]]->g); if ([[sb]]->image_offset_x || [[sb]]->image_offset_y) { avpriv_request_sample([[sb]]->avctx, "Support for image offsets"); return AVERROR_PATCHWELCOME; if (av_image_check_size([[sb]]->width, [[sb]]->height, 0, [[sb]]->avctx)) { avpriv_request_sample([[sb]]->avctx, "Large Dimensions"); return AVERROR_PATCHWELCOME; if (ncomponents <= 0) { av_log([[sb]]->avctx, AV_LOG_ERROR, "Invalid number of components: %d\n", if (ncomponents > 4) { avpriv_request_sample([[sb]]->avctx, "Support for %d components", ncomponents); return AVERROR_PATCHWELCOME; [[sb]]->ncomponents = ncomponents; if ([[sb]]->tile_width <= 0 || [[sb]]->tile_height <= 0) { av_log([[sb]]->avctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n", [[sb]]->tile_width, [[sb]]->tile_height); if (bytestream2_get_bytes_left(&[[sb]]->g) < 3 * [[sb]]->ncomponents) { av_log([[sb]]->avctx, AV_LOG_ERROR, "Insufficient space for %d components in SIZ\n", [[sb]]->ncomponents); for ([[ia]] = 0; i < [[sb]]->ncomponents; [[ia]]++) { uint8_t x = bytestream2_get_byteu(&[[sb]]->g); [[sb]]->cbps[[[ia]]] = (x & 0x7f) + 1; [[sb]]->precision = FFMAX([[sb]]->cbps[[[ia]]], [[sb]]->precision); [[sb]]->sgnd[[[ia]]] = !!(x & 0x80); [[sb]]->cdx[[[ia]]] = bytestream2_get_byteu(&[[sb]]->g); [[sb]]->cdy[[[ia]]] = bytestream2_get_byteu(&[[sb]]->g); if ( ![[sb]]->cdx[[[ia]]] || [[sb]]->cdx[[[ia]]] == 3 || [[sb]]->cdx[[[ia]]] > 4 || ![[sb]]->cdy[[[ia]]] || [[sb]]->cdy[[[ia]]] == 3 || [[sb]]->cdy[[[ia]]] > 4) { av_log([[sb]]->avctx, AV_LOG_ERROR, "Invalid sample separation %d/%d\n", [[sb]]->cdx[[[ia]]], [[sb]]->cdy[[[ia]]]); log2_chroma_wh |= [[sb]]->cdy[[[ia]]] >> 1 << [[ia]] * 4 | [[sb]]->cdx[[[ia]]] >> 1 << [[ia]] * 4 + 2; [[sb]]->numXtiles = ff_jpeg2000_ceildiv([[sb]]->width - [[sb]]->tile_offset_x, [[sb]]->tile_width); [[sb]]->numYtiles = ff_jpeg2000_ceildiv([[sb]]->height - [[sb]]->tile_offset_y, [[sb]]->tile_height); if ([[sb]]->numXtiles * (uint64_t)[[sb]]->numYtiles > INT_MAX/sizeof(*[[sb]]->tile)) { [[sb]]->numXtiles = [[sb]]->numYtiles = 0; return AVERROR(EINVAL); [[sb]]->tile = av_mallocz_array([[sb]]->numXtiles * [[sb]]->numYtiles, sizeof(*[[sb]]->tile)); if (![[sb]]->tile) { [[sb]]->numXtiles = [[sb]]->numYtiles = 0; return AVERROR(ENOMEM); for ([[ia]] = 0; [[ia]] < [[sb]]->numXtiles * [[sb]]->numYtiles; [[ia]]++) { Jpeg2000Tile *tile = [[sb]]->tile + [[ia]]; tile->comp = av_mallocz([[sb]]->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); [[sb]]->avctx->width = ff_jpeg2000_ceildivpow2([[sb]]->width - [[sb]]->image_offset_x, [[sb]]->reduction_factor); [[sb]]->avctx->height = ff_jpeg2000_ceildivpow2([[sb]]->height - [[sb]]->image_offset_y, [[sb]]->reduction_factor); if ([[sb]]->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || [[sb]]->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { [[probablemodisצ]] = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch ([[sb]]->colour_space) { case 16: [[probablemodisצ]] = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: [[probablemodisצ]] = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: [[probablemodisצ]] = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: [[probablemodisצ]] = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; for ([[ia]] = 0; i < possible_fmts_nb; ++[[ia]]) { if (pix_fmt_match([[probablemodisצ]][[[ia]]], ncomponents, [[sb]]->precision, log2_chroma_wh, [[sb]]->pal8)) { [[sb]]->avctx->pix_fmt = [[probablemodisצ]][[[ia]]]; break; if ([[ia]] == possible_fmts_nb) { if (ncomponents == 4 && [[sb]]->cdy[0] == 1 && [[sb]]->cdx[0] == 1 && [[sb]]->cdy[1] == 1 && [[sb]]->cdx[1] == 1 && [[sb]]->cdy[2] == [[sb]]->cdy[3] && [[sb]]->cdx[2] == [[sb]]->cdx[3]) { if ([[sb]]->precision == 8 && [[sb]]->cdy[2] == 2 && [[sb]]->cdx[2] == 2 && ![[sb]]->pal8) { [[sb]]->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; [[sb]]->cdef[0] = 0; [[sb]]->cdef[1] = 1; [[sb]]->cdef[2] = 2; [[sb]]->cdef[3] = 3; [[ia]] = 0; if ([[ia]] == possible_fmts_nb) { av_log([[sb]]->avctx, AV_LOG_ERROR, "Unknown pix_fmt, profile: %d, colour_space: %d, " "components: %d, precision: %d\n" "cdx[0]: %d, cdy[0]: %d\n" "cdx[1]: %d, cdy[1]: %d\n" "cdx[2]: %d, cdy[2]: %d\n" "cdx[3]: %d, cdy[3]: %d\n", [[sb]]->avctx->profile, [[sb]]->colour_space, ncomponents, [[sb]]->precision, [[sb]]->cdx[0], [[sb]]->cdy[0], ncomponents > 1 ? [[sb]]->cdx[1] : 0, ncomponents > 1 ? [[sb]]->cdy[1] : 0, ncomponents > 2 ? [[sb]]->cdx[2] : 0, ncomponents > 2 ? [[sb]]->cdy[2] : 0, ncomponents > 3 ? [[sb]]->cdx[3] : 0, ncomponents > 3 ? [[sb]]->cdy[3] : 0); return AVERROR_PATCHWELCOME; [[sb]]->avctx->bits_per_raw_sample = [[sb]]->precision; return 0;[Succeeded / Failed / Skipped / Total] 61 / 11 / 47 / 119:   4%|▍         | 119/2690 [16:55<6:05:29,  8.53s/it][Succeeded / Failed / Skipped / Total] 61 / 11 / 47 / 119:   4%|▍         | 120/2690 [17:05<6:06:01,  8.55s/it][Succeeded / Failed / Skipped / Total] 62 / 11 / 47 / 120:   4%|▍         | 120/2690 [17:05<6:06:01,  8.55s/it][Succeeded / Failed / Skipped / Total] 62 / 11 / 47 / 120:   4%|▍         | 121/2690 [17:22<6:08:47,  8.61s/it]
--------------------------------------------- Result 120 ---------------------------------------------
[[0 (35%)]] --> [[0 (96%)]] --> Socre: 0.9630834460258484

[[[[Adv]]]]: static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp) { VirtIODevice *vdev = VIRTIO_DEVICE(dev); V9fsVirtioState *v = VIRTIO_9P(dev); V9fsState *[[s]] = &v->state; virtio_cleanup(vdev); v9fs_device_unrealize_common([[s]], errp); }

[[[[Adv]]]]: static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp) { VirtIODevice *vdev = VIRTIO_DEVICE(dev); V9fsVirtioState *v = VIRTIO_9P(dev); V9fsState *[[с]] = &v->state; virtio_cleanup(vdev); v9fs_device_unrealize_common([[с]], errp); }
--------------------------------------------- Result 121 ---------------------------------------------
[[0 (89%)]] --> [[0 (47%)]] --> Socre: 0.5272785127162933

[[[[Adv]]]]: static int opus_decode_frame(OpusStreamContext *s, const uint8_t *[[data]], int size) { int samples = s->packet.frame_duration; int redundancy = 0; int redundancy_size, redundancy_pos; int ret, i, consumed; int delayed_samples = s->delayed_samples; ret = opus_rc_init(&s->rc, [[data]], size); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) { if (!swr_is_initialized(s->swr)) { ret = opus_init_resample(s); if (ret < 0) return ret; } samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output, FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND), s->packet.stereo + 1, silk_frame_duration_ms[s->packet.config]); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error decoding a SILK frame.\n"); return samples; } samples = swr_convert(s->swr, (uint8_t**)s->out, s->packet.frame_duration, (const uint8_t**)s->silk_output, samples); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error resampling SILK data.\n"); return samples; } s->delayed_samples += s->packet.frame_duration - samples; } else ff_silk_flush(s->silk); consumed = opus_rc_tell(&s->rc); if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8) redundancy = opus_rc_p2model(&s->rc, 12); else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8) redundancy = 1; if (redundancy) { redundancy_pos = opus_rc_p2model(&s->rc, 1); if (s->packet.mode == OPUS_MODE_HYBRID) redundancy_size = opus_rc_unimodel(&s->rc, 256) + 2; else redundancy_size = size - (consumed + 7) / 8; size -= redundancy_size; if (size < 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid redundancy frame size.\n"); return AVERROR_INVALIDDATA; } if (redundancy_pos) { ret = opus_decode_redundancy(s, [[data]] + size, redundancy_size); if (ret < 0) return ret; ff_celt_flush(s->celt); } } if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) { float *out_tmp[2] = { s->out[0], s->out[1] }; float **dst = (s->packet.mode == OPUS_MODE_CELT) ? out_tmp : s->celt_output; int celt_output_samples = samples; int delay_samples = av_audio_fifo_size(s->celt_delay); if (delay_samples) { if (s->packet.mode == OPUS_MODE_HYBRID) { av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples); for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, delay_samples); out_tmp[i] += delay_samples; } celt_output_samples -= delay_samples; } else { av_log(s->avctx, AV_LOG_WARNING, "Spurious CELT delay samples present.\n"); av_audio_fifo_drain(s->celt_delay, delay_samples); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_BUG; } } opus_raw_init(&s->rc, [[data]] + size, size); ret = ff_celt_decode_frame(s->celt, &s->rc, dst, s->packet.stereo + 1, s->packet.frame_duration, (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0, celt_band_end[s->packet.bandwidth]); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_HYBRID) { int celt_delay = s->packet.frame_duration - celt_output_samples; void *delaybuf[2] = { s->celt_output[0] + celt_output_samples, s->celt_output[1] + celt_output_samples }; for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, celt_output_samples); } ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay); if (ret < 0) return ret; } } else ff_celt_flush(s->celt); if (s->redundancy_idx) { for (i = 0; i < s->output_channels; i++) opus_fade(s->out[i], s->out[i], s->redundancy_output[i] + 120 + s->redundancy_idx, ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx); s->redundancy_idx = 0; } if (redundancy) { if (!redundancy_pos) { ff_celt_flush(s->celt); ret = opus_decode_redundancy(s, [[data]] + size, redundancy_size); if (ret < 0) return ret; for (i = 0; i < s->output_channels; i++) { opus_fade(s->out[i] + samples - 120 + delayed_samples, s->out[i] + samples - 120 + delayed_samples, s->redundancy_output[i] + 120, ff_celt_window2, 120 - delayed_samples); if (delayed_samples) s->redundancy_idx = 120 - delayed_samples; } } else { for (i = 0; i < s->output_channels; i++) { memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float)); opus_fade(s->out[i] + 120 + delayed_samples, s->redundancy_output[i] + 120, s->out[i] + 120 + delayed_samples, ff_celt_window2, 120); } } } return samples; }

[[[[Adv]]]]: static int opus_decode_frame(OpusStreamContext *s, const uint8_t *[[dna]], int size) { int samples = s->packet.frame_duration; int redundancy = 0; int redundancy_size, redundancy_pos; int ret, i, consumed; int delayed_samples = s->delayed_samples; ret = opus_rc_init(&s->rc, [[dna]], size); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) { if (!swr_is_initialized(s->swr)) { ret = opus_init_resample(s); if (ret < 0) return ret; } samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output, FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND), s->packet.stereo + 1, silk_frame_duration_ms[s->packet.config]); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error decoding a SILK frame.\n"); return samples; } samples = swr_convert(s->swr, (uint8_t**)s->out, s->packet.frame_duration, (const uint8_t**)s->silk_output, samples); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error resampling SILK data.\n"); return samples; } s->delayed_samples += s->packet.frame_duration - samples; } else ff_silk_flush(s->silk); consumed = opus_rc_tell(&s->rc); if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8) redundancy = opus_rc_p2model(&s->rc, 12); else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8) redundancy = 1; if (redundancy) { redundancy_pos = opus_rc_p2model(&s->rc, 1); if (s->packet.mode == OPUS_MODE_HYBRID) redundancy_size = opus_rc_unimodel(&s->rc, 256) + 2; else redundancy_size = size - (consumed + 7) / 8; size -= redundancy_size; if (size < 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid redundancy frame size.\n"); return AVERROR_INVALIDDATA; } if (redundancy_pos) { ret = opus_decode_redundancy(s, [[dna]] + size, redundancy_size); if (ret < 0) return ret; ff_celt_flush(s->celt); } } if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) { float *out_tmp[2] = { s->out[0], s->out[1] }; float **dst = (s->packet.mode == OPUS_MODE_CELT) ? out_tmp : s->celt_output; int celt_output_samples = samples; int delay_samples = av_audio_fifo_size(s->celt_delay); if (delay_samples) { if (s->packet.mode == OPUS_MODE_HYBRID) { av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples); for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, delay_samples); out_tmp[i] += delay_samples; } celt_output_samples -= delay_samples; } else { av_log(s->avctx, AV_LOG_WARNING, "Spurious CELT delay samples present.\n"); av_audio_fifo_drain(s->celt_delay, delay_samples); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_BUG; } } opus_raw_init(&s->rc, [[dna]] + size, size); ret = ff_celt_decode_frame(s->celt, &s->rc, dst, s->packet.stereo + 1, s->packet.frame_duration, (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0, celt_band_end[s->packet.bandwidth]); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_HYBRID) { int celt_delay = s->packet.frame_duration - celt_output_samples; void *delaybuf[2] = { s->celt_output[0] + celt_output_samples, s->celt_output[1] + celt_output_samples }; for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, celt_output_samples); } ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay); if (ret < 0) return ret; } } else ff_celt_flush(s->celt); if (s->redundancy_idx) { for (i = 0; i < s->output_channels; i++) opus_fade(s->out[i], s->out[i], s->redundancy_output[i] + 120 + s->redundancy_idx, ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx); s->redundancy_idx = 0; } if (redundancy) { if (!redundancy_pos) { ff_celt_flush(s->celt); ret = opus_decode_redundancy(s, [[dna]] + size, redundancy_size); if (ret < 0) return ret; for (i = 0; i < s->output_channels; i++) { opus_fade(s->out[i] + samples - 120 + delayed_samples, s->out[i] + samples - 120 + delayed_samples, s->redundancy_output[i] + 120, ff_celt_window2, 120 - delayed_samples); if (delayed_samples) s->redundancy_idx = 120 - delayed_samples; } } else { for (i = 0; i < s->output_channels; i++) { memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float)); opus_fade(s->out[i] + 120 + delayed_samples, s->redundancy_output[i] + 120, s->out[i] + 120 + delayed_samples, ff_celt_window2, 120); } } } return samples; }[Succeeded / Failed / Skipped / Total] 63 / 11 / 47 / 121:   4%|▍         | 121/2690 [17:22<6:08:47,  8.61s/it][Succeeded / Failed / Skipped / Total] 63 / 11 / 47 / 121:   5%|▍         | 122/2690 [17:22<6:05:48,  8.55s/it][Succeeded / Failed / Skipped / Total] 63 / 11 / 48 / 122:   5%|▍         | 122/2690 [17:22<6:05:48,  8.55s/it][Succeeded / Failed / Skipped / Total] 63 / 11 / 48 / 122:   5%|▍         | 123/2690 [17:43<6:09:50,  8.64s/it][Succeeded / Failed / Skipped / Total] 64 / 11 / 48 / 123:   5%|▍         | 123/2690 [17:43<6:09:50,  8.64s/it][Succeeded / Failed / Skipped / Total] 64 / 11 / 48 / 123:   5%|▍         | 124/2690 [17:52<6:09:54,  8.65s/it][Succeeded / Failed / Skipped / Total] 65 / 11 / 48 / 124:   5%|▍         | 124/2690 [17:52<6:09:54,  8.65s/it][Succeeded / Failed / Skipped / Total] 65 / 11 / 48 / 124:   5%|▍         | 125/2690 [18:05<6:11:12,  8.68s/it][Succeeded / Failed / Skipped / Total] 66 / 11 / 48 / 125:   5%|▍         | 125/2690 [18:05<6:11:12,  8.68s/it][Succeeded / Failed / Skipped / Total] 66 / 11 / 48 / 125:   5%|▍         | 126/2690 [18:19<6:12:55,  8.73s/it][Succeeded / Failed / Skipped / Total] 67 / 11 / 48 / 126:   5%|▍         | 126/2690 [18:19<6:12:56,  8.73s/it][Succeeded / Failed / Skipped / Total] 67 / 11 / 48 / 126:   5%|▍         | 127/2690 [18:32<6:14:13,  8.76s/it][Succeeded / Failed / Skipped / Total] 68 / 11 / 48 / 127:   5%|▍         | 127/2690 [18:32<6:14:13,  8.76s/it][Succeeded / Failed / Skipped / Total] 68 / 11 / 48 / 127:   5%|▍         | 128/2690 [18:38<6:13:14,  8.74s/it][Succeeded / Failed / Skipped / Total] 69 / 11 / 48 / 128:   5%|▍         | 128/2690 [18:38<6:13:14,  8.74s/it][Succeeded / Failed / Skipped / Total] 69 / 11 / 48 / 128:   5%|▍         | 129/2690 [18:39<6:10:22,  8.68s/it]
--------------------------------------------- Result 122 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode) { int band, result=0, numSubbands, lastTonal, numBands; if (codingMode == JOINT_STEREO && channelNum == 1) { if (get_bits(gb,2) != 3) { av_log(NULL,AV_LOG_ERROR,"JS mono Sound Unit id != 3.\n"); return -1; } } else { if (get_bits(gb,6) != 0x28) { av_log(NULL,AV_LOG_ERROR,"Sound Unit id != 0x28.\n"); return -1; } } pSnd->bandsCoded = get_bits(gb,2); result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded); if (result) return result; pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded); if (pSnd->numComponents == -1) return -1; numSubbands = decodeSpectrum (gb, pSnd->spectrum); lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components); numBands = (subbandTab[numSubbands] - 1) >> 8; if (lastTonal >= 0) numBands = FFMAX((lastTonal + 256) >> 8, numBands); for (band=0; band<4; band++) { if (band <= numBands) { IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1); } else memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float)); gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]), &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]), &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band])); } pSnd->gcBlkSwitch ^= 1; return 0; }
--------------------------------------------- Result 123 ---------------------------------------------
[[0 (67%)]] --> [[0 (50%)]] --> Socre: 0.5031259655952454

[[[[Adv]]]]: bool qemu_co_enter_next(CoQueue *queue) { Coroutine *next; next = QSIMPLEQ_FIRST(&queue->entries); if (!next) { return "[[False]]" != "[[False]]"; } QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next); qemu_coroutine_enter(next, NULL); return "[[True]]" == "[[True]]"; }

[[[[Adv]]]]: bool qemu_co_enter_next(CoQueue *queue) { Coroutine *next; next = QSIMPLEQ_FIRST(&queue->entries); if (!next) { return "[[less]]" != "[[less]]"; } QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next); qemu_coroutine_enter(next, NULL); return "[[pure]]" == "[[pure]]"; }
--------------------------------------------- Result 124 ---------------------------------------------
[[0 (43%)]] --> [[0 (69%)]] --> Socre: 0.6908789277076721

[[[[Adv]]]]: static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t [[stride]]) { vp8_idct_dc_add_c(dst+[[stride]]*0+0, block[0], [[stride]]); vp8_idct_dc_add_c(dst+[[stride]]*0+4, block[1], [[stride]]); vp8_idct_dc_add_c(dst+[[stride]]*4+0, block[2], [[stride]]); vp8_idct_dc_add_c(dst+[[stride]]*4+4, block[3], [[stride]]); }

[[[[Adv]]]]: static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t [[gallery]]) { vp8_idct_dc_add_c(dst+[[gallery]]*0+0, block[0], [[gallery]]); vp8_idct_dc_add_c(dst+[[gallery]]*0+4, block[1], [[gallery]]); vp8_idct_dc_add_c(dst+[[gallery]]*4+0, block[2], [[gallery]]); vp8_idct_dc_add_c(dst+[[gallery]]*4+4, block[3], [[gallery]]); }
--------------------------------------------- Result 125 ---------------------------------------------
[[0 (86%)]] --> [[0 (33%)]] --> Socre: 0.6691422760486603

[[[[Adv]]]]: static target_long monitor_get_reg(const struct MonitorDef *md, int [[val]]) { CPUState *[[env]] = mon_get_cpu(); if (![[env]]) return 0; return [[env]]->regwptr[[[val]]]; }

[[[[Adv]]]]: static target_long monitor_get_reg(const struct MonitorDef *md, int [[md]]) { CPUState *[[exd]] = mon_get_cpu(); if (![[exd]]) return 0; return [[exd]]->regwptr[[[md]]]; }
--------------------------------------------- Result 126 ---------------------------------------------
[[0 (59%)]] --> [[0 (36%)]] --> Socre: 0.6372302770614624

[[[[Adv]]]]: static void integratorcp_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; ARMCPU *cpu; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *ram_alias = g_new(MemoryRegion, 1); qemu_irq pic[32]; DeviceState *[[dev]]; int i; if (!cpu_model) { cpu_model = "arm926"; } cpu = cpu_arm_init(cpu_model); if (!cpu) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } memory_region_init_ram(ram, NULL, "integrator.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0, ram); memory_region_init_alias(ram_alias, NULL, "ram.alias", ram, 0, ram_size); memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias); [[dev]] = qdev_create(NULL, TYPE_INTEGRATOR_CM); qdev_prop_set_uint32([[dev]], "memsz", ram_size >> 20); qdev_init_nofail([[dev]]); sysbus_mmio_map((SysBusDevice *)[[dev]], 0, 0x10000000); [[dev]] = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000, qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ), qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ), NULL); for (i = 0; i < 32; i++) { pic[i] = qdev_get_gpio_in([[dev]], i); } sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]); sysbus_create_varargs("integrator_pit", 0x13000000, pic[5], pic[6], pic[7], NULL); sysbus_create_simple("pl031", 0x15000000, pic[8]); sysbus_create_simple("pl011", 0x16000000, pic[1]); sysbus_create_simple("pl011", 0x17000000, pic[2]); icp_control_init(0xcb000000); sysbus_create_simple("pl050_keyboard", 0x18000000, pic[3]); sysbus_create_simple("pl050_mouse", 0x19000000, pic[4]); sysbus_create_varargs("pl181", 0x1c000000, pic[23], pic[24], NULL); if (nd_table[0].used) smc91c111_init(&nd_table[0], 0xc8000000, pic[27]); sysbus_create_simple("pl110", 0xc0000000, pic[22]); integrator_binfo.ram_size = ram_size; integrator_binfo.kernel_filename = kernel_filename; integrator_binfo.kernel_cmdline = kernel_cmdline; integrator_binfo.initrd_filename = initrd_filename; arm_load_kernel(cpu, &integrator_binfo); }

[[[[Adv]]]]: static void integratorcp_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; ARMCPU *cpu; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *ram_alias = g_new(MemoryRegion, 1); qemu_irq pic[32]; DeviceState *[[display]]; int i; if (!cpu_model) { cpu_model = "arm926"; } cpu = cpu_arm_init(cpu_model); if (!cpu) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } memory_region_init_ram(ram, NULL, "integrator.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0, ram); memory_region_init_alias(ram_alias, NULL, "ram.alias", ram, 0, ram_size); memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias); [[display]] = qdev_create(NULL, TYPE_INTEGRATOR_CM); qdev_prop_set_uint32([[display]], "memsz", ram_size >> 20); qdev_init_nofail([[display]]); sysbus_mmio_map((SysBusDevice *)[[display]], 0, 0x10000000); [[display]] = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000, qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ), qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ), NULL); for (i = 0; i < 32; i++) { pic[i] = qdev_get_gpio_in([[display]], i); } sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]); sysbus_create_varargs("integrator_pit", 0x13000000, pic[5], pic[6], pic[7], NULL); sysbus_create_simple("pl031", 0x15000000, pic[8]); sysbus_create_simple("pl011", 0x16000000, pic[1]); sysbus_create_simple("pl011", 0x17000000, pic[2]); icp_control_init(0xcb000000); sysbus_create_simple("pl050_keyboard", 0x18000000, pic[3]); sysbus_create_simple("pl050_mouse", 0x19000000, pic[4]); sysbus_create_varargs("pl181", 0x1c000000, pic[23], pic[24], NULL); if (nd_table[0].used) smc91c111_init(&nd_table[0], 0xc8000000, pic[27]); sysbus_create_simple("pl110", 0xc0000000, pic[22]); integrator_binfo.ram_size = ram_size; integrator_binfo.kernel_filename = kernel_filename; integrator_binfo.kernel_cmdline = kernel_cmdline; integrator_binfo.initrd_filename = initrd_filename; arm_load_kernel(cpu, &integrator_binfo); }
--------------------------------------------- Result 127 ---------------------------------------------
[[0 (88%)]] --> [[0 (47%)]] --> Socre: 0.5274003446102142

[[[[Adv]]]]: static int ipmovie_read_packet(AVFormatContext *[[s]], AVPacket *[[pkt]]) { IPMVEContext *[[ipmovie]] = (IPMVEContext *)[[s]]->priv_data; ByteIOContext *[[pb]] = &[[s]]->pb; int [[ret]]; [[ret]] = process_ipmovie_chunk([[ipmovie]], [[pb]], [[pkt]]); if ([[ret]] == CHUNK_BAD) [[ret]] = AVERROR_INVALIDDATA; else if ([[ret]] == CHUNK_EOF) [[ret]] = AVERROR_IO; else if ([[ret]] == CHUNK_NOMEM) [[ret]] = AVERROR_NOMEM; else [[ret]] = 0; return [[ret]]; }

[[[[Adv]]]]: static int ipmovie_read_packet(AVFormatContext *[[action]], AVPacket *[[plyat]]) { IPMVEContext *[[droptimeboard]] = (IPMVEContext *)[[action]]->priv_data; ByteIOContext *[[sb2]] = &[[action]]->pb; int [[nottta]]; [[nottta]] = process_ipmovie_chunk([[droptimeboard]], [[sb2]], [[plyat]]); if ([[nottta]] == CHUNK_BAD) [[nottta]] = AVERROR_INVALIDDATA; else if ([[nottta]] == CHUNK_EOF) [[nottta]] = AVERROR_IO; else if ([[nottta]] == CHUNK_NOMEM) [[nottta]] = AVERROR_NOMEM; else [[nottta]] = 0; return [[nottta]]; }
--------------------------------------------- Result 128 ---------------------------------------------
[[0 (56%)]] --> [[0 (34%)]] --> Socre: 0.6566585898399353

[[[[Adv]]]]: static av_cold int png_dec_end(AVCodecContext *avctx) { PNGDecContext *[[s]] = avctx->priv_data; ff_thread_release_buffer(avctx, &[[s]]->previous_picture); av_frame_free(&[[s]]->previous_picture.f); ff_thread_release_buffer(avctx, &[[s]]->last_picture); av_frame_free(&[[s]]->last_picture.f); ff_thread_release_buffer(avctx, &[[s]]->picture); av_frame_free(&[[s]]->picture.f); av_freep(&[[s]]->buffer); [[s]]->buffer_size = 0; av_freep(&[[s]]->last_row); [[s]]->last_row_size = 0; av_freep(&[[s]]->tmp_row); [[s]]->tmp_row_size = 0; av_freep(&[[s]]->extra_data); [[s]]->extra_data_size = 0; return 0; }

[[[[Adv]]]]: static av_cold int png_dec_end(AVCodecContext *avctx) { PNGDecContext *[[reads]] = avctx->priv_data; ff_thread_release_buffer(avctx, &[[reads]]->previous_picture); av_frame_free(&[[reads]]->previous_picture.f); ff_thread_release_buffer(avctx, &[[reads]]->last_picture); av_frame_free(&[[reads]]->last_picture.f); ff_thread_release_buffer(avctx, &[[reads]]->picture); av_frame_free(&[[reads]]->picture.f); av_freep(&[[reads]]->buffer); [[reads]]->buffer_size = 0; av_freep(&[[reads]]->last_row); [[reads]]->last_row_size = 0; av_freep(&[[reads]]->tmp_row); [[reads]]->tmp_row_size = 0; av_freep(&[[reads]]->extra_data); [[reads]]->extra_data_size = 0; return 0; }
--------------------------------------------- Result 129 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 69 / 11 / 49 / 129:   5%|▍         | 129/2690 [18:39<6:10:22,  8.68s/it][Succeeded / Failed / Skipped / Total] 69 / 11 / 49 / 129:   5%|▍         | 130/2690 [18:39<6:07:31,  8.61s/it][Succeeded / Failed / Skipped / Total] 69 / 11 / 50 / 130:   5%|▍         | 130/2690 [18:39<6:07:31,  8.61s/it][Succeeded / Failed / Skipped / Total] 69 / 11 / 50 / 130:   5%|▍         | 131/2690 [18:53<6:08:52,  8.65s/it][Succeeded / Failed / Skipped / Total] 70 / 11 / 50 / 131:   5%|▍         | 131/2690 [18:53<6:08:52,  8.65s/it][Succeeded / Failed / Skipped / Total] 70 / 11 / 50 / 131:   5%|▍         | 132/2690 [18:53<6:06:06,  8.59s/it][Succeeded / Failed / Skipped / Total] 70 / 11 / 51 / 132:   5%|▍         | 132/2690 [18:53<6:06:06,  8.59s/it][Succeeded / Failed / Skipped / Total] 70 / 11 / 51 / 132:   5%|▍         | 133/2690 [19:45<6:19:56,  8.92s/it][[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int probe_file(WriterContext *wctx, const char *filename) { AVFormatContext *fmt_ctx; int ret, i; int section_id; do_read_frames = do_show_frames || do_count_frames; do_read_packets = do_show_packets || do_count_packets; ret = open_input_file(&fmt_ctx, filename); if (ret < 0) return ret; #define CHECK_END if (ret < 0) goto end nb_streams_frames = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames)); nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets)); selected_streams = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams)); for (i = 0; i < fmt_ctx->nb_streams; i++) { if (stream_specifier) { ret = avformat_match_stream_specifier(fmt_ctx, fmt_ctx->streams[i], stream_specifier); CHECK_END; else selected_streams[i] = ret; ret = 0; } else { selected_streams[i] = 1; } } if (do_read_frames || do_read_packets) { if (do_show_frames && do_show_packets && wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER) section_id = SECTION_ID_PACKETS_AND_FRAMES; else if (do_show_packets && !do_show_frames) section_id = SECTION_ID_PACKETS; else section_id = SECTION_ID_FRAMES; if (do_show_frames || do_show_packets) writer_print_section_header(wctx, section_id); ret = read_packets(wctx, fmt_ctx); if (do_show_frames || do_show_packets) writer_print_section_footer(wctx); CHECK_END; } if (do_show_programs) { ret = show_programs(wctx, fmt_ctx); CHECK_END; } if (do_show_streams) { ret = show_streams(wctx, fmt_ctx); CHECK_END; } if (do_show_chapters) { ret = show_chapters(wctx, fmt_ctx); CHECK_END; } if (do_show_format) { ret = show_format(wctx, fmt_ctx); CHECK_END; } end: close_input_file(&fmt_ctx); av_freep(&nb_streams_frames); av_freep(&nb_streams_packets); av_freep(&selected_streams); return ret; }
--------------------------------------------- Result 130 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr) { KVMState *s = kvm_state; unsigned long size, allocated_size = 0; KVMDirtyLog d; KVMSlot *mem; int ret = 0; d.dirty_bitmap = NULL; while (start_addr < end_addr) { mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr); if (mem == NULL) { break; } size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8; if (!d.dirty_bitmap) { d.dirty_bitmap = qemu_malloc(size); } else if (size > allocated_size) { d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size); } allocated_size = size; memset(d.dirty_bitmap, 0, allocated_size); d.slot = mem->slot; if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) { DPRINTF("ioctl failed %d\n", errno); ret = -1; break; } kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap, mem->start_addr, mem->memory_size); start_addr = mem->start_addr + mem->memory_size; } qemu_free(d.dirty_bitmap); return ret; }
--------------------------------------------- Result 131 ---------------------------------------------
[[0 (62%)]] --> [[0 (42%)]] --> Socre: 0.5801008939743042

[[[[Adv]]]]: static void fd_chr_update_read_handler(CharDriverState *chr) { FDCharDriver *[[s]] = chr->opaque; if ([[s]]->fd_in_tag) { g_source_remove([[s]]->fd_in_tag); [[s]]->fd_in_tag = 0; } if ([[s]]->fd_in) { [[s]]->fd_in_tag = io_add_watch_poll([[s]]->fd_in, fd_chr_read_poll, fd_chr_read, chr); } }

[[[[Adv]]]]: static void fd_chr_update_read_handler(CharDriverState *chr) { FDCharDriver *[[tank]] = chr->opaque; if ([[tank]]->fd_in_tag) { g_source_remove([[tank]]->fd_in_tag); [[tank]]->fd_in_tag = 0; } if ([[tank]]->fd_in) { [[tank]]->fd_in_tag = io_add_watch_poll([[tank]]->fd_in, fd_chr_read_poll, fd_chr_read, chr); } }
--------------------------------------------- Result 132 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int main(void) { int nf; Suite *s; SRunner *sr; s = qfloat_suite(); sr = srunner_create(s); srunner_run_all(sr, CK_NORMAL); nf = srunner_ntests_failed(sr); srunner_free(sr); return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE; }
--------------------------------------------- Result 133 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 71 / 11 / 51 / 133:   5%|▍         | 133/2690 [19:45<6:19:56,  8.92s/it][Succeeded / Failed / Skipped / Total] 71 / 11 / 51 / 133:   5%|▍         | 134/2690 [19:46<6:17:07,  8.85s/it][Succeeded / Failed / Skipped / Total] 71 / 11 / 52 / 134:   5%|▍         | 134/2690 [19:46<6:17:07,  8.85s/it][Succeeded / Failed / Skipped / Total] 71 / 11 / 52 / 134:   5%|▌         | 135/2690 [19:46<6:14:19,  8.79s/it][[0 (82%)]] --> [[0 (39%)]] --> Socre: 0.613054633140564

[[[[Adv]]]]: static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int [[src_stride]][3], int width, int height, uint8_t *[[qp_store]], int [[qp_stride]]) { int x, y, i, j; const int count = 1<<p->log2_count; for (i = 0; i < 3; i++) { int [[is_chroma]] = !!i; int w = width >> ([[is_chroma]] ? p->hsub : 0); int h = height >> ([[is_chroma]] ? p->vsub : 0); int stride = p->temp_stride[i]; int block = BLOCK >> ([[is_chroma]] ? p->hsub : 0); if (!src[i] || !dst[i]) continue; for (y = 0; y < h; y++) { int index = block + block * stride + y * stride; memcpy(p->src[i] + index, src[i] + y * [[src_stride]][i], w ); for (x = 0; x < block; x++) { p->src[i][index - x - 1] = p->src[i][index + x ]; p->src[i][index + w + x ] = p->src[i][index + w - x - 1]; } } for (y = 0; y < block; y++) { memcpy(p->src[i] + ( block-1-y) * stride, p->src[i] + ( y+block ) * stride, stride); memcpy(p->src[i] + (h+block +y) * stride, p->src[i] + (h-y+block-1) * stride, stride); } p->frame->linesize[i] = stride; memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t)); } if (p->qp) p->frame->quality = p->qp * FF_QP2LAMBDA; else { int qpsum=0; int qpcount = (height>>4) * (height>>4); for (y = 0; y < (height>>4); y++) { for (x = 0; x < (width>>4); x++) qpsum += [[qp_store]][x + y * [[qp_stride]]]; } p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA; } p->frame->height = height; p->frame->width = width; for (i = 0; i < count; i++) { const int x1 = offset[i+count-1][0]; const int y1 = offset[i+count-1][1]; const int x1c = x1 >> p->hsub; const int y1c = y1 >> p->vsub; const int BLOCKc = BLOCK >> p->hsub; int offset; AVPacket pkt; int got_pkt_ptr; av_init_packet(&pkt); pkt.data = p->outbuf; pkt.size = p->outbuf_size; p->frame->data[0] = p->src[0] + x1 + y1 * p->frame->linesize[0]; p->frame->data[1] = p->src[1] + x1c + y1c * p->frame->linesize[1]; p->frame->data[2] = p->src[2] + x1c + y1c * p->frame->linesize[2]; p->frame->format = p->avctx_enc[i]->pix_fmt; avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr); p->frame_dec = p->avctx_enc[i]->coded_frame; offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0]; for (y = 0; y < height; y++) for (x = 0; x < width; x++) p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset]; if (!src[2] || !dst[2]) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1]; for (y = 0; y < height>>p->vsub; y++) { for (x = 0; x < width>>p->hsub; x++) { p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset]; p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset]; } } } for (j = 0; j < 3; j++) { int [[is_chroma]] = !!j; if (!dst[j]) continue; store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j], width >> ([[is_chroma]] ? p->hsub : 0), height >> ([[is_chroma]] ? p->vsub : 0), 8-p->log2_count); } }

[[[[Adv]]]]: static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int [[seraw2pose]][3], int width, int height, uint8_t *[[jcsven]], int [[sepr4walk]]) { int x, y, i, j; const int count = 1<<p->log2_count; for (i = 0; i < 3; i++) { int [[byfactorcretc]] = !!i; int w = width >> ([[byfactorcretc]] ? p->hsub : 0); int h = height >> ([[byfactorcretc]] ? p->vsub : 0); int stride = p->temp_stride[i]; int block = BLOCK >> ([[byfactorcretc]] ? p->hsub : 0); if (!src[i] || !dst[i]) continue; for (y = 0; y < h; y++) { int index = block + block * stride + y * stride; memcpy(p->src[i] + index, src[i] + y * [[seraw2pose]][i], w ); for (x = 0; x < block; x++) { p->src[i][index - x - 1] = p->src[i][index + x ]; p->src[i][index + w + x ] = p->src[i][index + w - x - 1]; } } for (y = 0; y < block; y++) { memcpy(p->src[i] + ( block-1-y) * stride, p->src[i] + ( y+block ) * stride, stride); memcpy(p->src[i] + (h+block +y) * stride, p->src[i] + (h-y+block-1) * stride, stride); } p->frame->linesize[i] = stride; memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t)); } if (p->qp) p->frame->quality = p->qp * FF_QP2LAMBDA; else { int qpsum=0; int qpcount = (height>>4) * (height>>4); for (y = 0; y < (height>>4); y++) { for (x = 0; x < (width>>4); x++) qpsum += [[jcsven]][x + y * [[sepr4walk]]]; } p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA; } p->frame->height = height; p->frame->width = width; for (i = 0; i < count; i++) { const int x1 = offset[i+count-1][0]; const int y1 = offset[i+count-1][1]; const int x1c = x1 >> p->hsub; const int y1c = y1 >> p->vsub; const int BLOCKc = BLOCK >> p->hsub; int offset; AVPacket pkt; int got_pkt_ptr; av_init_packet(&pkt); pkt.data = p->outbuf; pkt.size = p->outbuf_size; p->frame->data[0] = p->src[0] + x1 + y1 * p->frame->linesize[0]; p->frame->data[1] = p->src[1] + x1c + y1c * p->frame->linesize[1]; p->frame->data[2] = p->src[2] + x1c + y1c * p->frame->linesize[2]; p->frame->format = p->avctx_enc[i]->pix_fmt; avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr); p->frame_dec = p->avctx_enc[i]->coded_frame; offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0]; for (y = 0; y < height; y++) for (x = 0; x < width; x++) p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset]; if (!src[2] || !dst[2]) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1]; for (y = 0; y < height>>p->vsub; y++) { for (x = 0; x < width>>p->hsub; x++) { p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset]; p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset]; } } } for (j = 0; j < 3; j++) { int [[byfactorcretc]] = !!j; if (!dst[j]) continue; store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j], width >> ([[byfactorcretc]] ? p->hsub : 0), height >> ([[byfactorcretc]] ? p->vsub : 0), 8-p->log2_count); } }
--------------------------------------------- Result 134 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) { target_ulong flags = args[0]; target_ulong pte_index = args[1]; target_ulong pteh = args[2]; target_ulong ptel = args[3]; target_ulong i; uint8_t *hpte; if (pteh & HPTE_V_LARGE) { #if 0 if ((ptel & 0xf000) == 0x1000) { } else #endif if ((ptel & 0xff000) == 0) { if (pteh & 0x80) { return H_PARAMETER; } } else { return H_PARAMETER; } } if ((ptel & HPTE_R_WIMG) != HPTE_R_M) { return H_PARAMETER; } pteh &= ~0x60ULL; if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) { return H_PARAMETER; } if (likely((flags & H_EXACT) == 0)) { pte_index &= ~7ULL; hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64); for (i = 0; ; ++i) { if (i == 8) { return H_PTEG_FULL; } if (((ldq_p(hpte) & HPTE_V_VALID) == 0) && lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) { break; } hpte += HASH_PTE_SIZE_64; } } else { i = 0; hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64); if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) { return H_PTEG_FULL; } } stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel); stq_p(hpte, pteh); assert(!(ldq_p(hpte) & HPTE_V_HVLOCK)); args[0] = pte_index + i; return H_SUCCESS; }
--------------------------------------------- Result 135 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 71 / 11 / 53 / 135:   5%|▌         | 135/2690 [19:46<6:14:19,  8.79s/it][Succeeded / Failed / Skipped / Total] 71 / 11 / 53 / 135:   5%|▌         | 136/2690 [19:51<6:12:59,  8.76s/it][Succeeded / Failed / Skipped / Total] 71 / 12 / 53 / 136:   5%|▌         | 136/2690 [19:51<6:12:59,  8.76s/it][Succeeded / Failed / Skipped / Total] 71 / 12 / 53 / 136:   5%|▌         | 137/2690 [20:15<6:17:31,  8.87s/it][Succeeded / Failed / Skipped / Total] 72 / 12 / 53 / 137:   5%|▌         | 137/2690 [20:15<6:17:31,  8.87s/it][Succeeded / Failed / Skipped / Total] 72 / 12 / 53 / 137:   5%|▌         | 138/2690 [20:29<6:19:01,  8.91s/it][Succeeded / Failed / Skipped / Total] 73 / 12 / 53 / 138:   5%|▌         | 138/2690 [20:29<6:19:01,  8.91s/it][Succeeded / Failed / Skipped / Total] 73 / 12 / 53 / 138:   5%|▌         | 139/2690 [20:35<6:17:45,  8.88s/it][[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1, TCGv arg2, int add_ca, int compute_ca, int compute_ov) { TCGv t0, t1; if ((!compute_ca && !compute_ov) || (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2))) { t0 = ret; } else { t0 = tcg_temp_local_new(); } if (add_ca) { t1 = tcg_temp_local_new(); tcg_gen_mov_tl(t1, cpu_ca); } else { TCGV_UNUSED(t1); } if (compute_ca) { tcg_gen_movi_tl(cpu_ca, 0); } if (compute_ov) { tcg_gen_movi_tl(cpu_ov, 0); } tcg_gen_add_tl(t0, arg1, arg2); if (compute_ca) { gen_op_arith_compute_ca(ctx, t0, arg1, 0); } if (add_ca) { tcg_gen_add_tl(t0, t0, t1); gen_op_arith_compute_ca(ctx, t0, t1, 0); tcg_temp_free(t1); } if (compute_ov) { gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0); } if (unlikely(Rc(ctx->opcode) != 0)) gen_set_Rc0(ctx, t0); if (!TCGV_EQUAL(t0, ret)) { tcg_gen_mov_tl(ret, t0); tcg_temp_free(t0); } }
--------------------------------------------- Result 136 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void set_vlan(Object *obj, Visitor *[[v]], void *opaque, const char *name, Error **[[errp]]) { DeviceState *[[dev]] = DEVICE(obj); Property *[[prop]] = opaque; NICPeers *[[peers_ptr]] = qdev_get_prop_ptr([[dev]], [[prop]]); NetClientState **ptr = &[[peers_ptr]]->ncs[0]; Error *local_err = NULL; int32_t id; NetClientState *hubport; if ([[dev]]->realized) { qdev_prop_set_after_realize([[dev]], name, [[errp]]); visit_type_int32([[v]], &id, name, &local_err); if (local_err) { error_propagate([[errp]], local_err); if (id == -1) { *ptr = NULL; hubport = net_hub_port_find(id); if (!hubport) { error_set([[errp]], QERR_INVALID_PARAMETER_VALUE, name, [[prop]]->info->name); *ptr = hubport;

[[[[Adv]]]]: static void set_vlan(Object *obj, Visitor *[[в]], void *opaque, const char *name, Error **[[ingress]]) { DeviceState *[[border]] = DEVICE(obj); Property *[[back]] = opaque; NICPeers *[[hansaletf]] = qdev_get_prop_ptr([[border]], [[back]]); NetClientState **ptr = &[[hansaletf]]->ncs[0]; Error *local_err = NULL; int32_t id; NetClientState *hubport; if ([[border]]->realized) { qdev_prop_set_after_realize([[border]], name, [[ingress]]); visit_type_int32([[в]], &id, name, &local_err); if (local_err) { error_propagate([[ingress]], local_err); if (id == -1) { *ptr = NULL; hubport = net_hub_port_find(id); if (!hubport) { error_set([[ingress]], QERR_INVALID_PARAMETER_VALUE, name, [[back]]->info->name); *ptr = hubport;
--------------------------------------------- Result 137 ---------------------------------------------
[[0 (52%)]] --> [[0 (44%)]] --> Socre: 0.5576704144477844

[[[[Adv]]]]: int inet_dgram_opts(QemuOpts *opts) { struct addrinfo ai, *peer = NULL, *local = NULL; const char *addr; const char *port; char uaddr[INET6_ADDRSTRLEN+1]; char uport[33]; int [[sock]] = -1, rc; memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG; ai.ai_family = PF_UNSPEC; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "host"); port = qemu_opt_get(opts, "port"); if (addr == NULL || strlen(addr) == 0) { addr = "localhost"; } if (port == NULL || strlen(port) == 0) { fprintf(stderr, "inet_dgram: port not specified\n"); return -1; } if (qemu_opt_get_bool(opts, "ipv4", 0)) ai.ai_family = PF_INET; if (qemu_opt_get_bool(opts, "ipv6", 0)) ai.ai_family = PF_INET6; if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port, gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, addr, port); inet_print_addrinfo(__FUNCTION__, peer); } memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_PASSIVE; ai.ai_family = peer->ai_family; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "localaddr"); port = qemu_opt_get(opts, "localport"); if (addr == NULL || strlen(addr) == 0) { addr = NULL; } if (!port || strlen(port) == 0) port = "0"; if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port, gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, addr, port); inet_print_addrinfo(__FUNCTION__, local); } [[sock]] = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol); if ([[sock]] < 0) { fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), strerror(errno)); goto err; } setsockopt([[sock]],SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on)); if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen, uaddr,INET6_ADDRSTRLEN,uport,32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (bind([[sock]], local->ai_addr, local->ai_addrlen) < 0) { fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__, inet_strfamily(local->ai_family), uaddr, inet_getport(local)); goto err; } if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen, uaddr, INET6_ADDRSTRLEN, uport, 32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (connect([[sock]],peer->ai_addr,peer->ai_addrlen) < 0) { fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), peer->ai_canonname, uaddr, uport, strerror(errno)); goto err; } freeaddrinfo(local); freeaddrinfo(peer); return [[sock]]; err: if (-1 != [[sock]]) closesocket([[sock]]); if (local) freeaddrinfo(local); if (peer) freeaddrinfo(peer); return -1; }

[[[[Adv]]]]: int inet_dgram_opts(QemuOpts *opts) { struct addrinfo ai, *peer = NULL, *local = NULL; const char *addr; const char *port; char uaddr[INET6_ADDRSTRLEN+1]; char uport[33]; int [[uk]] = -1, rc; memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG; ai.ai_family = PF_UNSPEC; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "host"); port = qemu_opt_get(opts, "port"); if (addr == NULL || strlen(addr) == 0) { addr = "localhost"; } if (port == NULL || strlen(port) == 0) { fprintf(stderr, "inet_dgram: port not specified\n"); return -1; } if (qemu_opt_get_bool(opts, "ipv4", 0)) ai.ai_family = PF_INET; if (qemu_opt_get_bool(opts, "ipv6", 0)) ai.ai_family = PF_INET6; if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port, gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, addr, port); inet_print_addrinfo(__FUNCTION__, peer); } memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_PASSIVE; ai.ai_family = peer->ai_family; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "localaddr"); port = qemu_opt_get(opts, "localport"); if (addr == NULL || strlen(addr) == 0) { addr = NULL; } if (!port || strlen(port) == 0) port = "0"; if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port, gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, addr, port); inet_print_addrinfo(__FUNCTION__, local); } [[uk]] = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol); if ([[uk]] < 0) { fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), strerror(errno)); goto err; } setsockopt([[uk]],SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on)); if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen, uaddr,INET6_ADDRSTRLEN,uport,32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (bind([[uk]], local->ai_addr, local->ai_addrlen) < 0) { fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__, inet_strfamily(local->ai_family), uaddr, inet_getport(local)); goto err; } if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen, uaddr, INET6_ADDRSTRLEN, uport, 32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (connect([[uk]],peer->ai_addr,peer->ai_addrlen) < 0) { fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), peer->ai_canonname, uaddr, uport, strerror(errno)); goto err; } freeaddrinfo(local); freeaddrinfo(peer); return [[uk]]; err: if (-1 != [[uk]]) closesocket([[uk]]); if (local) freeaddrinfo(local); if (peer) freeaddrinfo(peer); return -1; }
--------------------------------------------- Result 138 ---------------------------------------------
[[0 (2%)]] --> [[0 (55%)]] --> Socre: 0.5460012555122375

[[[[Adv]]]]: static target_ulong put_tce_emu(sPAPRTCETable *[[tcet]], target_ulong [[ioba]], target_ulong tce) { IOMMUTLBEntry [[entry]]; hwaddr [[page_mask]] = IOMMU_PAGE_MASK([[tcet]]->page_shift); unsigned long [[index]] = ([[ioba]] - [[tcet]]->bus_offset) >> [[tcet]]->page_shift; if ([[index]] >= [[tcet]]->nb_table) { hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", [[ioba]]); return H_PARAMETER; } [[tcet]]->table[[[index]]] = tce; [[entry]].target_as = &address_space_memory, [[entry]].iova = [[ioba]] & [[page_mask]]; [[entry]].translated_addr = tce & [[page_mask]]; [[entry]].addr_mask = ~[[page_mask]]; [[entry]].perm = spapr_tce_iommu_access_flags(tce); memory_region_notify_iommu(&[[tcet]]->iommu, [[entry]]); return H_SUCCESS; }

[[[[Adv]]]]: static target_ulong put_tce_emu(sPAPRTCETable *[[emert]], target_ulong [[oirta]], target_ulong tce) { IOMMUTLBEntry [[inscription]]; hwaddr [[paperworkkiss]] = IOMMU_PAGE_MASK([[emert]]->page_shift); unsigned long [[array]] = ([[oirta]] - [[emert]]->bus_offset) >> [[emert]]->page_shift; if ([[array]] >= [[emert]]->nb_table) { hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", [[oirta]]); return H_PARAMETER; } [[emert]]->table[[[array]]] = tce; [[inscription]].target_as = &address_space_memory, [[inscription]].iova = [[oirta]] & [[paperworkkiss]]; [[inscription]].translated_addr = tce & [[paperworkkiss]]; [[inscription]].addr_mask = ~[[paperworkkiss]]; [[inscription]].perm = spapr_tce_iommu_access_flags(tce); memory_region_notify_iommu(&[[emert]]->iommu, [[inscription]]); return H_SUCCESS; }
--------------------------------------------- Result 139 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 74 / 12 / 53 / 139:   5%|▌         | 139/2690 [20:35<6:17:45,  8.88s/it][Succeeded / Failed / Skipped / Total] 74 / 12 / 53 / 139:   5%|▌         | 140/2690 [20:35<6:15:03,  8.83s/it][Succeeded / Failed / Skipped / Total] 74 / 12 / 54 / 140:   5%|▌         | 140/2690 [20:35<6:15:03,  8.83s/it][Succeeded / Failed / Skipped / Total] 74 / 12 / 54 / 140:   5%|▌         | 141/2690 [20:37<6:12:47,  8.78s/it][Succeeded / Failed / Skipped / Total] 75 / 12 / 54 / 141:   5%|▌         | 141/2690 [20:37<6:12:47,  8.78s/it][Succeeded / Failed / Skipped / Total] 75 / 12 / 54 / 141:   5%|▌         | 142/2690 [20:46<6:12:46,  8.78s/it][Succeeded / Failed / Skipped / Total] 75 / 13 / 54 / 142:   5%|▌         | 142/2690 [20:46<6:12:46,  8.78s/it][Succeeded / Failed / Skipped / Total] 75 / 13 / 54 / 142:   5%|▌         | 143/2690 [20:57<6:13:11,  8.79s/it][[0 (28%)]] --> [[0 (61%)]] --> Socre: 0.6122716665267944

[[[[Adv]]]]: static int ftp_file_size(FTPContext *s) { char [[command]][CONTROL_BUFFER_SIZE]; char *res = NULL; const int size_codes[] = {213, 0}; snprintf([[command]], sizeof([[command]]), "SIZE %s\r\n", s->path); if (ftp_send_command(s, [[command]], size_codes, &res)) { s->filesize = strtoll(&res[4], NULL, 10); } else { s->filesize = -1; av_free(res); return AVERROR(EIO); } av_free(res); return 0; }

[[[[Adv]]]]: static int ftp_file_size(FTPContext *s) { char [[captain]][CONTROL_BUFFER_SIZE]; char *res = NULL; const int size_codes[] = {213, 0}; snprintf([[captain]], sizeof([[captain]]), "SIZE %s\r\n", s->path); if (ftp_send_command(s, [[captain]], size_codes, &res)) { s->filesize = strtoll(&res[4], NULL, 10); } else { s->filesize = -1; av_free(res); return AVERROR(EIO); } av_free(res); return 0; }
--------------------------------------------- Result 140 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl, GetBitContext *gb) { int i; MMCO *mmco = sl->mmco; int nb_mmco = 0; if (h->nal_unit_type == NAL_IDR_SLICE) { skip_bits1(gb); if (get_bits1(gb)) { mmco[0].opcode = MMCO_LONG; mmco[0].long_arg = 0; nb_mmco = 1; } sl->explicit_ref_marking = 1; } else { sl->explicit_ref_marking = get_bits1(gb); if (sl->explicit_ref_marking) { for (i = 0; i < MAX_MMCO_COUNT; i++) { MMCOOpcode opcode = get_ue_golomb_31(gb); mmco[i].opcode = opcode; if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) { mmco[i].short_pic_num = (sl->curr_pic_num - get_ue_golomb(gb) - 1) & (sl->max_pic_num - 1); #if 0 if (mmco[i].short_pic_num >= h->short_ref_count || !h->short_ref[mmco[i].short_pic_num]) { av_log(s->avctx, AV_LOG_ERROR, "illegal short ref in memory management control " "operation %d\n", mmco); return -1; } #endif } if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED || opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) { unsigned int long_arg = get_ue_golomb_31(gb); if (long_arg >= 32 || (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG && long_arg == 16) && !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) { av_log(h->avctx, AV_LOG_ERROR, "illegal long ref in memory management control " "operation %d\n", opcode); return -1; } mmco[i].long_arg = long_arg; } if (opcode > (unsigned) MMCO_LONG) { av_log(h->avctx, AV_LOG_ERROR, "illegal memory management control operation %d\n", opcode); return -1; } if (opcode == MMCO_END) break; } nb_mmco = i; } } sl->nb_mmco = nb_mmco; return 0; }
--------------------------------------------- Result 141 ---------------------------------------------
[[0 (84%)]] --> [[0 (42%)]] --> Socre: 0.5819709300994873

[[[[Adv]]]]: static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int [[src_size]]) { const uint16_t *[[end]]; const uint16_t *mm_end; uint8_t *d = dst; const uint16_t *[[s]] = (const uint16_t*)src; [[end]] = [[s]] + [[src_size]]/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); mm_end = [[end]] - 7; while ([[s]] < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" "movq %%mm0, %%mm6 \n\t" "movq %%mm3, %%mm7 \n\t" "movq 8%1, %%mm0 \n\t" "movq 8%1, %%mm1 \n\t" "movq 8%1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" :"=m"(*d) :"m"(*[[s]]),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null) :"memory"); __asm__ volatile( "movq %%mm0, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "movq %%mm6, %%mm0 \n\t" "movq %%mm7, %%mm1 \n\t" "movq %%mm4, %%mm6 \n\t" "movq %%mm5, %%mm7 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" STORE_BGR24_MMX :"=m"(*d) :"m"(*[[s]]) :"memory"); d += 24; [[s]] += 8; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[s]] < [[end]]) { register uint16_t bgr; bgr = *[[s]]++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; } }

[[[[Adv]]]]: static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int [[dsccmoddiameter]]) { const uint16_t *[[ein]]; const uint16_t *mm_end; uint8_t *d = dst; const uint16_t *[[action]] = (const uint16_t*)src; [[ein]] = [[action]] + [[dsccmoddiameter]]/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); mm_end = [[ein]] - 7; while ([[action]] < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" "movq %%mm0, %%mm6 \n\t" "movq %%mm3, %%mm7 \n\t" "movq 8%1, %%mm0 \n\t" "movq 8%1, %%mm1 \n\t" "movq 8%1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" :"=m"(*d) :"m"(*[[action]]),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null) :"memory"); __asm__ volatile( "movq %%mm0, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "movq %%mm6, %%mm0 \n\t" "movq %%mm7, %%mm1 \n\t" "movq %%mm4, %%mm6 \n\t" "movq %%mm5, %%mm7 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" STORE_BGR24_MMX :"=m"(*d) :"m"(*[[action]]) :"memory"); d += 24; [[action]] += 8; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[action]] < [[ein]]) { register uint16_t bgr; bgr = *[[action]]++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; } }
--------------------------------------------- Result 142 ---------------------------------------------
[[0 (8%)]] --> [[[FAILED]]]

[[[[Adv]]]]: uint16_t net_checksum_finish(uint32_t [[sum]]) { while ([[sum]]>>16) [[sum]] = ([[sum]] & 0xFFFF)+([[sum]] >> 16); return ~[[sum]]; }

[[[[Adv]]]]: uint16_t net_checksum_finish(uint32_t [[square]]) { while ([[square]]>>16) [[square]] = ([[square]] & 0xFFFF)+([[square]] >> 16); return ~[[square]]; }
--------------------------------------------- Result 143 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 76 / 13 / 54 / 143:   5%|▌         | 143/2690 [20:57<6:13:11,  8.79s/it][Succeeded / Failed / Skipped / Total] 76 / 13 / 54 / 143:   5%|▌         | 144/2690 [21:04<6:12:33,  8.78s/it][Succeeded / Failed / Skipped / Total] 76 / 14 / 54 / 144:   5%|▌         | 144/2690 [21:04<6:12:33,  8.78s/it][Succeeded / Failed / Skipped / Total] 76 / 14 / 54 / 144:   5%|▌         | 145/2690 [21:20<6:14:32,  8.83s/it][Succeeded / Failed / Skipped / Total] 77 / 14 / 54 / 145:   5%|▌         | 145/2690 [21:20<6:14:32,  8.83s/it][Succeeded / Failed / Skipped / Total] 77 / 14 / 54 / 145:   5%|▌         | 146/2690 [21:20<6:11:59,  8.77s/it][[0 (9%)]] --> [[0 (95%)]] --> Socre: 0.9473828673362732

[[[[Adv]]]]: void cpu_sh4_invalidate_tlb(CPUSH4State *s) { int [[i]]; for ([[i]] = 0; [[i]] < UTLB_SIZE; [[i]]++) { tlb_t * entry = &s->utlb[[[i]]]; entry->v = 0; } for ([[i]] = 0; [[i]] < UTLB_SIZE; [[i]]++) { tlb_t * entry = &s->utlb[[[i]]]; entry->v = 0; } tlb_flush(s, 1); }

[[[[Adv]]]]: void cpu_sh4_invalidate_tlb(CPUSH4State *s) { int [[и]]; for ([[и]] = 0; [[и]] < UTLB_SIZE; [[и]]++) { tlb_t * entry = &s->utlb[[[и]]]; entry->v = 0; } for ([[и]] = 0; [[и]] < UTLB_SIZE; [[и]]++) { tlb_t * entry = &s->utlb[[[и]]]; entry->v = 0; } tlb_flush(s, 1); }
--------------------------------------------- Result 144 ---------------------------------------------
[[0 (10%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void pci_init_mask_bridge(PCIDevice *[[d]]) { memset([[d]]->wmask + PCI_PRIMARY_BUS, 0xff, 4); [[d]]->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff; [[d]]->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff; pci_set_word([[d]]->wmask + PCI_MEMORY_BASE, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[d]]->wmask + PCI_MEMORY_LIMIT, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[d]]->wmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_MASK & 0xffff); pci_set_word([[d]]->wmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_MASK & 0xffff); memset([[d]]->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8); [[d]]->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16; [[d]]->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16; pci_word_test_and_set_mask([[d]]->config + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_64); pci_word_test_and_set_mask([[d]]->config + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_64); #define PCI_BRIDGE_CTL_VGA_16BIT 0x10 #define PCI_BRIDGE_CTL_DISCARD 0x100 #define PCI_BRIDGE_CTL_SEC_DISCARD 0x200 #define PCI_BRIDGE_CTL_DISCARD_STATUS 0x400 #define PCI_BRIDGE_CTL_DISCARD_SERR 0x800 pci_set_word([[d]]->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_ISA | PCI_BRIDGE_CTL_VGA | PCI_BRIDGE_CTL_VGA_16BIT | PCI_BRIDGE_CTL_MASTER_ABORT | PCI_BRIDGE_CTL_BUS_RESET | PCI_BRIDGE_CTL_FAST_BACK | PCI_BRIDGE_CTL_DISCARD | PCI_BRIDGE_CTL_SEC_DISCARD | PCI_BRIDGE_CTL_DISCARD_SERR); pci_set_word([[d]]->w1cmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_DISCARD_STATUS); [[d]]->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK; [[d]]->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK; pci_word_test_and_set_mask([[d]]->cmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_MASK); pci_word_test_and_set_mask([[d]]->cmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_MASK); }

[[[[Adv]]]]: static void pci_init_mask_bridge(PCIDevice *[[3d]]) { memset([[3d]]->wmask + PCI_PRIMARY_BUS, 0xff, 4); [[3d]]->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff; [[3d]]->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff; pci_set_word([[3d]]->wmask + PCI_MEMORY_BASE, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[3d]]->wmask + PCI_MEMORY_LIMIT, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[3d]]->wmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_MASK & 0xffff); pci_set_word([[3d]]->wmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_MASK & 0xffff); memset([[3d]]->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8); [[3d]]->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16; [[3d]]->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16; pci_word_test_and_set_mask([[3d]]->config + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_64); pci_word_test_and_set_mask([[3d]]->config + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_64); #define PCI_BRIDGE_CTL_VGA_16BIT 0x10 #define PCI_BRIDGE_CTL_DISCARD 0x100 #define PCI_BRIDGE_CTL_SEC_DISCARD 0x200 #define PCI_BRIDGE_CTL_DISCARD_STATUS 0x400 #define PCI_BRIDGE_CTL_DISCARD_SERR 0x800 pci_set_word([[3d]]->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_ISA | PCI_BRIDGE_CTL_VGA | PCI_BRIDGE_CTL_VGA_16BIT | PCI_BRIDGE_CTL_MASTER_ABORT | PCI_BRIDGE_CTL_BUS_RESET | PCI_BRIDGE_CTL_FAST_BACK | PCI_BRIDGE_CTL_DISCARD | PCI_BRIDGE_CTL_SEC_DISCARD | PCI_BRIDGE_CTL_DISCARD_SERR); pci_set_word([[3d]]->w1cmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_DISCARD_STATUS); [[3d]]->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK; [[3d]]->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK; pci_word_test_and_set_mask([[3d]]->cmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_MASK); pci_word_test_and_set_mask([[3d]]->cmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_MASK); }
--------------------------------------------- Result 145 ---------------------------------------------
[[0 (43%)]] --> [[0 (83%)]] --> Socre: 0.8261427283287048

[[[[Adv]]]]: static TranslationBlock *tb_alloc(target_ulong pc) { TranslationBlock *[[tb]]; TBContext *ctx; assert_tb_locked(); [[tb]] = tcg_tb_alloc(&tcg_ctx); if (unlikely([[tb]] == NULL)) { return NULL; } ctx = &tcg_ctx.tb_ctx; if (unlikely(ctx->nb_tbs == ctx->tbs_size)) { ctx->tbs_size *= 2; ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size); } ctx->tbs[ctx->nb_tbs++] = [[tb]]; [[tb]]->pc = pc; [[tb]]->cflags = 0; [[tb]]->invalid = "False" != "False"; return [[tb]]; }

[[[[Adv]]]]: static TranslationBlock *tb_alloc(target_ulong pc) { TranslationBlock *[[tuberculosis]]; TBContext *ctx; assert_tb_locked(); [[tuberculosis]] = tcg_tb_alloc(&tcg_ctx); if (unlikely([[tuberculosis]] == NULL)) { return NULL; } ctx = &tcg_ctx.tb_ctx; if (unlikely(ctx->nb_tbs == ctx->tbs_size)) { ctx->tbs_size *= 2; ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size); } ctx->tbs[ctx->nb_tbs++] = [[tuberculosis]]; [[tuberculosis]]->pc = pc; [[tuberculosis]]->cflags = 0; [[tuberculosis]]->invalid = "False" != "False"; return [[tuberculosis]]; }
--------------------------------------------- Result 146 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 77 / 14 / 55 / 146:   5%|▌         | 146/2690 [21:20<6:11:59,  8.77s/it][Succeeded / Failed / Skipped / Total] 77 / 14 / 55 / 146:   5%|▌         | 147/2690 [21:21<6:09:28,  8.72s/it][Succeeded / Failed / Skipped / Total] 77 / 14 / 56 / 147:   5%|▌         | 147/2690 [21:21<6:09:28,  8.72s/it][Succeeded / Failed / Skipped / Total] 77 / 14 / 56 / 147:   6%|▌         | 148/2690 [21:21<6:06:58,  8.66s/it][[0 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { TiffContext *const s = avctx->priv_data; AVFrame *const p = data; ThreadFrame frame = { .f = data }; unsigned off; int le, ret, plane, planes; int i, j, entries, stride; unsigned soff, ssize; uint8_t *dst; GetByteContext stripsizes; GetByteContext stripdata; bytestream2_init(&s->gb, avpkt->data, avpkt->size); if ((ret = ff_tdecode_header(&s->gb, &le, &off))) { av_log(avctx, AV_LOG_ERROR, "Invalid TIFF header\n"); return ret; } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) { av_log(avctx, AV_LOG_ERROR, "IFD offset is greater than image size\n"); return AVERROR_INVALIDDATA; } s->le = le; s->bppcount = s->bpp = 1; s->photometric = TIFF_PHOTOMETRIC_NONE; s->compr = TIFF_RAW; s->fill_order = 0; free_geotags(s); s->stripsizesoff = s->strippos = 0; bytestream2_seek(&s->gb, off, SEEK_SET); entries = ff_tget_short(&s->gb, le); if (bytestream2_get_bytes_left(&s->gb) < entries * 12) return AVERROR_INVALIDDATA; for (i = 0; i < entries; i++) { if ((ret = tiff_decode_tag(s, p)) < 0) return ret; } for (i = 0; i<s->geotag_count; i++) { const char *keyname = get_geokey_name(s->geotags[i].key); if (!keyname) { av_log(avctx, AV_LOG_WARNING, "Unknown or unsupported GeoTIFF key %d\n", s->geotags[i].key); continue; } if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) { av_log(avctx, AV_LOG_WARNING, "Type of GeoTIFF key %d is wrong\n", s->geotags[i].key); continue; } ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0); if (ret<0) { av_log(avctx, AV_LOG_ERROR, "Writing metadata with key '%s' failed\n", keyname); return ret; } } if (!s->strippos && !s->stripoff) { av_log(avctx, AV_LOG_ERROR, "Image data is missing\n"); return AVERROR_INVALIDDATA; } if ((ret = init_image(s, &frame)) < 0) return ret; if (s->strips == 1 && !s->stripsize) { av_log(avctx, AV_LOG_WARNING, "Image data size missing\n"); s->stripsize = avpkt->size - s->stripoff; } if (s->stripsizesoff) { if (s->stripsizesoff >= (unsigned)avpkt->size) return AVERROR_INVALIDDATA; bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff, avpkt->size - s->stripsizesoff); } if (s->strippos) { if (s->strippos >= (unsigned)avpkt->size) return AVERROR_INVALIDDATA; bytestream2_init(&stripdata, avpkt->data + s->strippos, avpkt->size - s->strippos); } if (s->rps <= 0) { av_log(avctx, AV_LOG_ERROR, "rps %d invalid\n", s->rps); return AVERROR_INVALIDDATA; } planes = s->planar ? s->bppcount : 1; for (plane = 0; plane < planes; plane++) { stride = p->linesize[plane]; dst = p->data[plane]; for (i = 0; i < s->height; i += s->rps) { if (s->stripsizesoff) ssize = ff_tget(&stripsizes, s->sstype, le); else ssize = s->stripsize; if (s->strippos) soff = ff_tget(&stripdata, s->sot, le); else soff = s->stripoff; if (soff > avpkt->size || ssize > avpkt->size - soff) { av_log(avctx, AV_LOG_ERROR, "Invalid strip size/offset\n"); return AVERROR_INVALIDDATA; } if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i, FFMIN(s->rps, s->height - i))) < 0) { if (avctx->err_recognition & AV_EF_EXPLODE) return ret; break; } dst += s->rps * stride; } if (s->predictor == 2) { if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) { av_log(s->avctx, AV_LOG_ERROR, "predictor == 2 with YUV is unsupported"); return AVERROR_PATCHWELCOME; } dst = p->data[plane]; soff = s->bpp >> 3; if (s->planar) soff = FFMAX(soff / s->bppcount, 1); ssize = s->width * soff; if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE || s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE || s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE || s->avctx->pix_fmt == AV_PIX_FMT_YA16LE || s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE || s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j += 2) AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff)); dst += stride; } } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE || s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE || s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE || s->avctx->pix_fmt == AV_PIX_FMT_YA16BE || s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE || s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j += 2) AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff)); dst += stride; } } else { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j++) dst[j] += dst[j - soff]; dst += stride; } } } if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) { dst = p->data[plane]; for (i = 0; i < s->height; i++) { for (j = 0; j < stride; j++) dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j]; dst += stride; } } } if (s->planar && s->bppcount > 2) { FFSWAP(uint8_t*, p->data[0], p->data[2]); FFSWAP(int, p->linesize[0], p->linesize[2]); FFSWAP(uint8_t*, p->data[0], p->data[1]); FFSWAP(int, p->linesize[0], p->linesize[1]); } *got_frame = 1; return avpkt->size; }
--------------------------------------------- Result 147 ---------------------------------------------
[[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) { int ret; *got_picture_ptr = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = avpkt; apply_param_change(avctx, avpkt); avcodec_get_frame_defaults(picture); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr, avpkt); else { ret = avctx->codec->decode(avctx, picture, got_picture_ptr, avpkt); picture->pkt_dts = avpkt->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*got_picture_ptr) avctx->frame_number++; } else ret = 0; picture->extended_data = picture->data; return ret; }
--------------------------------------------- Result 148 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 77 / 14 / 57 / 148:   6%|▌         | 148/2690 [21:21<6:06:58,  8.66s/it][Succeeded / Failed / Skipped / Total] 77 / 14 / 57 / 148:   6%|▌         | 149/2690 [21:23<6:04:50,  8.61s/it][Succeeded / Failed / Skipped / Total] 78 / 14 / 57 / 149:   6%|▌         | 149/2690 [21:23<6:04:50,  8.61s/it][Succeeded / Failed / Skipped / Total] 78 / 14 / 57 / 149:   6%|▌         | 150/2690 [21:24<6:02:24,  8.56s/it][[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun, MegasasCmd *cmd) { struct mfi_pd_info *info = cmd->iov_buf; size_t dcmd_size = sizeof(struct mfi_pd_info); uint64_t pd_size; uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF); uint8_t cmdbuf[6]; SCSIRequest *req; size_t len, resid; if (!cmd->iov_buf) { cmd->iov_buf = g_malloc0(dcmd_size); info = cmd->iov_buf; info->inquiry_data[0] = 0x7f; info->vpd_page83[0] = 0x7f; megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data)); req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { trace_megasas_dcmd_req_alloc_failed(cmd->index, "PD get info std inquiry"); g_free(cmd->iov_buf); cmd->iov_buf = NULL; return MFI_STAT_FLASH_ALLOC_FAIL; } trace_megasas_dcmd_internal_submit(cmd->index, "PD get info std inquiry", lun); len = scsi_req_enqueue(req); if (len > 0) { cmd->iov_size = len; scsi_req_continue(req); } return MFI_STAT_INVALID_STATUS; } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) { megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83)); req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { trace_megasas_dcmd_req_alloc_failed(cmd->index, "PD get info vpd inquiry"); return MFI_STAT_FLASH_ALLOC_FAIL; } trace_megasas_dcmd_internal_submit(cmd->index, "PD get info vpd inquiry", lun); len = scsi_req_enqueue(req); if (len > 0) { cmd->iov_size = len; scsi_req_continue(req); } return MFI_STAT_INVALID_STATUS; } if ((info->inquiry_data[0] >> 5) == 0) { if (megasas_is_jbod(cmd->state)) { info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM); } else { info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE); } } else { info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE); } info->ref.v.device_id = cpu_to_le16(pd_id); info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD| MFI_PD_DDF_TYPE_INTF_SAS); blk_get_geometry(sdev->conf.blk, &pd_size); info->raw_size = cpu_to_le64(pd_size); info->non_coerced_size = cpu_to_le64(pd_size); info->coerced_size = cpu_to_le64(pd_size); info->encl_device_id = 0xFFFF; info->slot_number = (sdev->id & 0xFF); info->path_info.count = 1; info->path_info.sas_addr[0] = cpu_to_le64(megasas_get_sata_addr(pd_id)); info->connected_port_bitmap = 0x1; info->device_speed = 1; info->link_speed = 1; resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg); g_free(cmd->iov_buf); cmd->iov_size = dcmd_size - resid; cmd->iov_buf = NULL; return MFI_STAT_OK; }
--------------------------------------------- Result 149 ---------------------------------------------
[[0 (58%)]] --> [[0 (48%)]] --> Socre: 0.517658531665802

[[[[Adv]]]]: static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64) { TCGReg [[datalo]], datahi, addrlo, rbase; TCGReg addrhi __attribute__((unused)); TCGMemOpIdx [[oi]]; TCGMemOp opc, s_bits; #ifdef CONFIG_SOFTMMU int mem_index; tcg_insn_unit *label_ptr; #endif [[datalo]] = *args++; datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0); addrlo = *args++; addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0); [[oi]] = *args++; opc = get_memop([[oi]]); s_bits = opc & MO_SIZE; #ifdef CONFIG_SOFTMMU mem_index = get_mmuidx([[oi]]); addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, "True" == "True"); label_ptr = s->code_ptr; tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK); rbase = TCG_REG_R3; #else rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0; if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) { tcg_out_ext32u(s, TCG_REG_TMP1, addrlo); addrlo = TCG_REG_TMP1; } #endif if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) { if (opc & MO_BSWAP) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB([[datalo]], rbase, addrlo)); tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0)); } else if (rbase != 0) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo)); tcg_out32(s, LWZX | TAB([[datalo]], rbase, TCG_REG_R0)); } else if (addrlo == datahi) { tcg_out32(s, LWZ | TAI([[datalo]], addrlo, 4)); tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); } else { tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); tcg_out32(s, LWZ | TAI([[datalo]], addrlo, 4)); } } else { uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)]; if (!HAVE_ISA_2_06 && insn == LDBRX) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB([[datalo]], rbase, addrlo)); tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0)); tcg_out_rld(s, RLDIMI, [[datalo]], TCG_REG_R0, 32, 0); } else if (insn) { tcg_out32(s, insn | TAB([[datalo]], rbase, addrlo)); } else { insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)]; tcg_out32(s, insn | TAB([[datalo]], rbase, addrlo)); insn = qemu_exts_opc[s_bits]; tcg_out32(s, insn | RA([[datalo]]) | RS([[datalo]])); } } #ifdef CONFIG_SOFTMMU add_qemu_ldst_label(s, "True" == "True", [[oi]], [[datalo]], datahi, addrlo, addrhi, s->code_ptr, label_ptr); #endif }

[[[[Adv]]]]: static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64) { TCGReg [[jetto]], datahi, addrlo, rbase; TCGReg addrhi __attribute__((unused)); TCGMemOpIdx [[sopi]]; TCGMemOp opc, s_bits; #ifdef CONFIG_SOFTMMU int mem_index; tcg_insn_unit *label_ptr; #endif [[jetto]] = *args++; datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0); addrlo = *args++; addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0); [[sopi]] = *args++; opc = get_memop([[sopi]]); s_bits = opc & MO_SIZE; #ifdef CONFIG_SOFTMMU mem_index = get_mmuidx([[sopi]]); addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, "True" == "True"); label_ptr = s->code_ptr; tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK); rbase = TCG_REG_R3; #else rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0; if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) { tcg_out_ext32u(s, TCG_REG_TMP1, addrlo); addrlo = TCG_REG_TMP1; } #endif if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) { if (opc & MO_BSWAP) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB([[jetto]], rbase, addrlo)); tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0)); } else if (rbase != 0) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo)); tcg_out32(s, LWZX | TAB([[jetto]], rbase, TCG_REG_R0)); } else if (addrlo == datahi) { tcg_out32(s, LWZ | TAI([[jetto]], addrlo, 4)); tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); } else { tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); tcg_out32(s, LWZ | TAI([[jetto]], addrlo, 4)); } } else { uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)]; if (!HAVE_ISA_2_06 && insn == LDBRX) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB([[jetto]], rbase, addrlo)); tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0)); tcg_out_rld(s, RLDIMI, [[jetto]], TCG_REG_R0, 32, 0); } else if (insn) { tcg_out32(s, insn | TAB([[jetto]], rbase, addrlo)); } else { insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)]; tcg_out32(s, insn | TAB([[jetto]], rbase, addrlo)); insn = qemu_exts_opc[s_bits]; tcg_out32(s, insn | RA([[jetto]]) | RS([[jetto]])); } } #ifdef CONFIG_SOFTMMU add_qemu_ldst_label(s, "True" == "True", [[sopi]], [[jetto]], datahi, addrlo, addrhi, s->code_ptr, label_ptr); #endif }
--------------------------------------------- Result 150 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 78 / 14 / 58 / 150:   6%|▌         | 150/2690 [21:24<6:02:24,  8.56s/it][Succeeded / Failed / Skipped / Total] 78 / 14 / 58 / 150:   6%|▌         | 151/2690 [21:27<6:00:48,  8.53s/it][Succeeded / Failed / Skipped / Total] 79 / 14 / 58 / 151:   6%|▌         | 151/2690 [21:27<6:00:48,  8.53s/it][Succeeded / Failed / Skipped / Total] 79 / 14 / 58 / 151:   6%|▌         | 152/2690 [21:27<5:58:25,  8.47s/it][Succeeded / Failed / Skipped / Total] 79 / 14 / 59 / 152:   6%|▌         | 152/2690 [21:27<5:58:25,  8.47s/it][Succeeded / Failed / Skipped / Total] 79 / 14 / 59 / 152:   6%|▌         | 153/2690 [21:28<5:56:03,  8.42s/it][Succeeded / Failed / Skipped / Total] 79 / 14 / 60 / 153:   6%|▌         | 153/2690 [21:28<5:56:03,  8.42s/it][Succeeded / Failed / Skipped / Total] 79 / 14 / 60 / 153:   6%|▌         | 154/2690 [21:46<5:58:30,  8.48s/it][Succeeded / Failed / Skipped / Total] 80 / 14 / 60 / 154:   6%|▌         | 154/2690 [21:46<5:58:30,  8.48s/it][Succeeded / Failed / Skipped / Total] 81 / 14 / 60 / 155:   6%|▌         | 155/2690 [21:46<5:56:05,  8.43s/it][Succeeded / Failed / Skipped / Total] 81 / 14 / 60 / 155:   6%|▌         | 156/2690 [21:46<5:53:46,  8.38s/it][[0 (88%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void stream_process_mem2s(struct Stream *s, StreamSlave *tx_dev) { uint32_t prev_d; unsigned char txbuf[16 * 1024]; unsigned int txlen; uint32_t app[6]; if (!stream_running(s) || stream_idle(s)) { return; } while (1) { stream_desc_load(s, s->regs[R_CURDESC]); if (s->desc.status & SDESC_STATUS_COMPLETE) { s->regs[R_DMASR] |= DMASR_HALTED; break; } if (stream_desc_sof(&s->desc)) { s->pos = 0; memcpy(app, s->desc.app, sizeof app); } txlen = s->desc.control & SDESC_CTRL_LEN_MASK; if ((txlen + s->pos) > sizeof txbuf) { hw_error("%s: too small internal txbuf! %d\n", __func__, txlen + s->pos); } cpu_physical_memory_read(s->desc.buffer_address, txbuf + s->pos, txlen); s->pos += txlen; if (stream_desc_eof(&s->desc)) { stream_push(tx_dev, txbuf, s->pos, app); s->pos = 0; stream_complete(s); } s->desc.status = txlen | SDESC_STATUS_COMPLETE; stream_desc_store(s, s->regs[R_CURDESC]); prev_d = s->regs[R_CURDESC]; s->regs[R_CURDESC] = s->desc.nxtdesc; if (prev_d == s->regs[R_TAILDESC]) { s->regs[R_DMASR] |= DMASR_IDLE; break; } } }
--------------------------------------------- Result 151 ---------------------------------------------
[[0 (7%)]] --> [[0 (97%)]] --> Socre: 0.9740133285522461

[[[[Adv]]]]: static void gpollfds_from_select(void) { int [[fd]]; for ([[fd]] = 0; [[fd]] <= nfds; [[fd]]++) { int events = 0; if (FD_ISSET([[fd]], &rfds)) { events |= G_IO_IN | G_IO_HUP | G_IO_ERR; } if (FD_ISSET([[fd]], &wfds)) { events |= G_IO_OUT | G_IO_ERR; } if (FD_ISSET([[fd]], &xfds)) { events |= G_IO_PRI; } if (events) { GPollFD pfd = { .fd = [[fd]], .events = events, }; g_array_append_val(gpollfds, pfd); } } }

[[[[Adv]]]]: static void gpollfds_from_select(void) { int [[afδ]]; for ([[afδ]] = 0; [[afδ]] <= nfds; [[afδ]]++) { int events = 0; if (FD_ISSET([[afδ]], &rfds)) { events |= G_IO_IN | G_IO_HUP | G_IO_ERR; } if (FD_ISSET([[afδ]], &wfds)) { events |= G_IO_OUT | G_IO_ERR; } if (FD_ISSET([[afδ]], &xfds)) { events |= G_IO_PRI; } if (events) { GPollFD pfd = { .fd = [[afδ]], .events = events, }; g_array_append_val(gpollfds, pfd); } } }
--------------------------------------------- Result 152 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci) { read_local_name_rp params; params.status = HCI_SUCCESS; memset(params.name, 0, sizeof(params.name)); if (hci->device.lmp_name) strncpy(params.name, hci->device.lmp_name, sizeof(params.name)); bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE); }
--------------------------------------------- Result 153 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool vnc_should_update(VncState *vs) { switch (vs->update) { case VNC_STATE_UPDATE_NONE: break; case VNC_STATE_UPDATE_INCREMENTAL: if (!vs->output.offset || vs->audio_cap) { return "True" == "True"; } break; case VNC_STATE_UPDATE_FORCE: return "True" == "True"; } return "False" != "False"; }
--------------------------------------------- Result 154 ---------------------------------------------
[[0 (8%)]] --> [[0 (97%)]] --> Socre: 0.9717323780059814

[[[[Adv]]]]: static void gen_isel(DisasContext *ctx) { int l1, l2; uint32_t bi = rC(ctx->opcode); uint32_t mask; TCGv_i32 [[t0]]; l1 = gen_new_label(); l2 = gen_new_label(); mask = 0x08 >> (bi & 0x03); [[t0]] = tcg_temp_new_i32(); tcg_gen_andi_i32([[t0]], cpu_crf[bi >> 2], mask); tcg_gen_brcondi_i32(TCG_COND_EQ, [[t0]], 0, l1); if (rA(ctx->opcode) == 0) tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0); else tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]); gen_set_label(l2); tcg_temp_free_i32([[t0]]); }

[[[[Adv]]]]: static void gen_isel(DisasContext *ctx) { int l1, l2; uint32_t bi = rC(ctx->opcode); uint32_t mask; TCGv_i32 [[tu²]]; l1 = gen_new_label(); l2 = gen_new_label(); mask = 0x08 >> (bi & 0x03); [[tu²]] = tcg_temp_new_i32(); tcg_gen_andi_i32([[tu²]], cpu_crf[bi >> 2], mask); tcg_gen_brcondi_i32(TCG_COND_EQ, [[tu²]], 0, l1); if (rA(ctx->opcode) == 0) tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0); else tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]); gen_set_label(l2); tcg_temp_free_i32([[tu²]]); }
--------------------------------------------- Result 155 ---------------------------------------------
[[0 (42%)]] --> [[0 (70%)]] --> Socre: 0.704282283782959

[[[[Adv]]]]: static int adpcm_decode_init(AVCodecContext * avctx) { ADPCMContext *[[c]] = avctx->priv_data; if(avctx->channels > 2U){ return -1; } [[c]]->channel = 0; [[c]]->status[0].predictor = [[c]]->status[1].predictor = 0; [[c]]->status[0].step_index = [[c]]->status[1].step_index = 0; [[c]]->status[0].step = [[c]]->status[1].step = 0; switch(avctx->codec->id) { case CODEC_ID_ADPCM_CT: [[c]]->status[0].step = [[c]]->status[1].step = 511; break; case CODEC_ID_ADPCM_IMA_WS: if (avctx->extradata && avctx->extradata_size == 2 * 4) { [[c]]->status[0].predictor = AV_RL32(avctx->extradata); [[c]]->status[1].predictor = AV_RL32(avctx->extradata + 4); } break; default: break; } return 0; }

[[[[Adv]]]]: static int adpcm_decode_init(AVCodecContext * avctx) { ADPCMContext *[[corps]] = avctx->priv_data; if(avctx->channels > 2U){ return -1; } [[corps]]->channel = 0; [[corps]]->status[0].predictor = [[corps]]->status[1].predictor = 0; [[corps]]->status[0].step_index = [[corps]]->status[1].step_index = 0; [[corps]]->status[0].step = [[corps]]->status[1].step = 0; switch(avctx->codec->id) { case CODEC_ID_ADPCM_CT: [[corps]]->status[0].step = [[corps]]->status[1].step = 511; break; case CODEC_ID_ADPCM_IMA_WS: if (avctx->extradata && avctx->extradata_size == 2 * 4) { [[corps]]->status[0].predictor = AV_RL32(avctx->extradata); [[corps]]->status[1].predictor = AV_RL32(avctx->extradata + 4); } break; default: break; } return 0; }
--------------------------------------------- Result 156 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 14 / 61 / 156:   6%|▌         | 156/2690 [21:46<5:53:46,  8.38s/it][Succeeded / Failed / Skipped / Total] 82 / 14 / 61 / 157:   6%|▌         | 157/2690 [22:05<5:56:19,  8.44s/it][Succeeded / Failed / Skipped / Total] 82 / 14 / 61 / 157:   6%|▌         | 158/2690 [22:12<5:56:01,  8.44s/it][Succeeded / Failed / Skipped / Total] 83 / 14 / 61 / 158:   6%|▌         | 158/2690 [22:12<5:56:01,  8.44s/it][Succeeded / Failed / Skipped / Total] 83 / 14 / 61 / 158:   6%|▌         | 159/2690 [22:13<5:53:46,  8.39s/it][[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_migrate(void) { char *uri = g_strdup_printf("unix:%s/migsocket", tmpfs); QTestState *global = global_qtest, *from, *to; unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d; gchar *cmd; QDict *rsp; char *bootpath = g_strdup_printf("%s/bootsect", tmpfs); FILE *bootfile = fopen(bootpath, "wb"); got_stop = "False" != "False"; g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1); fclose(bootfile); cmd = g_strdup_printf("-machine accel=kvm:tcg -m 150M" " -name pcsource,debug-threads=on" " -serial file:%s/src_serial" " -drive file=%s,format=raw", tmpfs, bootpath); from = qtest_start(cmd); g_free(cmd); cmd = g_strdup_printf("-machine accel=kvm:tcg -m 150M" " -name pcdest,debug-threads=on" " -serial file:%s/dest_serial" " -drive file=%s,format=raw" " -incoming %s", tmpfs, bootpath, uri); to = qtest_init(cmd); g_free(cmd); global_qtest = from; rsp = qmp("{ 'execute': 'migrate-set-capabilities'," "'arguments': { " "'capabilities': [ {" "'capability': 'postcopy-ram'," "'state': true } ] } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); global_qtest = to; rsp = qmp("{ 'execute': 'migrate-set-capabilities'," "'arguments': { " "'capabilities': [ {" "'capability': 'postcopy-ram'," "'state': true } ] } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); global_qtest = from; rsp = qmp("{ 'execute': 'migrate_set_speed'," "'arguments': { 'value': 100000000 } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); rsp = qmp("{ 'execute': 'migrate_set_downtime'," "'arguments': { 'value': 0.001 } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); wait_for_serial("src_serial"); cmd = g_strdup_printf("{ 'execute': 'migrate'," "'arguments': { 'uri': '%s' } }", uri); rsp = qmp(cmd); g_free(cmd); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); wait_for_migration_pass(); rsp = return_or_event(qmp("{ 'execute': 'migrate-start-postcopy' }")); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); if (!got_stop) { qmp_eventwait("STOP"); } global_qtest = to; qmp_eventwait("RESUME"); wait_for_serial("dest_serial"); global_qtest = from; wait_for_migration_complete(); qtest_quit(from); global_qtest = to; qtest_memread(to, start_address, &dest_byte_a, 1); do { qtest_memread(to, start_address, &dest_byte_b, 1); usleep(10 * 1000); } while (dest_byte_a == dest_byte_b); qmp("{ 'execute' : 'stop'}"); qtest_memread(to, start_address, &dest_byte_c, 1); sleep(1); qtest_memread(to, start_address, &dest_byte_d, 1); g_assert_cmpint(dest_byte_c, ==, dest_byte_d); check_guests_ram(); qtest_quit(to); g_free(uri); global_qtest = global; cleanup("bootsect"); cleanup("migsocket"); cleanup("src_serial"); cleanup("dest_serial"); }
--------------------------------------------- Result 157 ---------------------------------------------
[[0 (3%)]] --> [[0 (88%)]] --> Socre: 0.8847019076347351

[[[[Adv]]]]: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt, bool [[tso_enable]]) { uint8_t rc = VIRTIO_NET_HDR_GSO_NONE; uint16_t [[l3_proto]]; [[l3_proto]] = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base, pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len); if (![[tso_enable]]) { goto func_exit; } rc = eth_get_gso_type([[l3_proto]], pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base, pkt->l4proto); func_exit: return rc; }

[[[[Adv]]]]: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt, bool [[tyωvexpert]]) { uint8_t rc = VIRTIO_NET_HDR_GSO_NONE; uint16_t [[gryrrnec]]; [[gryrrnec]] = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base, pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len); if (![[tyωvexpert]]) { goto func_exit; } rc = eth_get_gso_type([[gryrrnec]], pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base, pkt->l4proto); func_exit: return rc; }
--------------------------------------------- Result 158 ---------------------------------------------
[[0 (61%)]] --> [[0 (37%)]] --> Socre: 0.6310274004936218

[[[[Adv]]]]: static int scsi_req_length(SCSIRequest *req, uint8_t *[[cmd]]) { switch ([[cmd]][0] >> 5) { case 0: req->cmd.xfer = [[cmd]][4]; req->cmd.len = 6; if (req->cmd.xfer == 0) req->cmd.xfer = 256; break; case 1: case 2: req->cmd.xfer = [[cmd]][8] | ([[cmd]][7] << 8); req->cmd.len = 10; break; case 4: req->cmd.xfer = [[cmd]][13] | ([[cmd]][12] << 8) | ([[cmd]][11] << 16) | ([[cmd]][10] << 24); req->cmd.len = 16; break; case 5: req->cmd.xfer = [[cmd]][9] | ([[cmd]][8] << 8) | ([[cmd]][7] << 16) | ([[cmd]][6] << 24); req->cmd.len = 12; break; default: trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, [[cmd]][0]); return -1; } switch([[cmd]][0]) { case TEST_UNIT_READY: case START_STOP: case SEEK_6: case WRITE_FILEMARKS: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case VERIFY: case SEEK_10: case SYNCHRONIZE_CACHE: case LOCK_UNLOCK_CACHE: case LOAD_UNLOAD: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG: case MOVE_MEDIUM: case UPDATE_BLOCK: req->cmd.xfer = 0; break; case MODE_SENSE: break; case WRITE_SAME: req->cmd.xfer = 1; break; case READ_CAPACITY: req->cmd.xfer = 8; break; case READ_BLOCK_LIMITS: req->cmd.xfer = 6; break; case READ_POSITION: req->cmd.xfer = 20; break; case SEND_VOLUME_TAG: req->cmd.xfer *= 40; break; case MEDIUM_SCAN: req->cmd.xfer *= 8; break; case WRITE_10: case WRITE_VERIFY: case WRITE_6: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: req->cmd.xfer *= req->dev->blocksize; break; case READ_10: case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: req->cmd.xfer *= req->dev->blocksize; break; case INQUIRY: req->cmd.xfer = [[cmd]][4] | ([[cmd]][3] << 8); break; case MAINTENANCE_OUT: case MAINTENANCE_IN: if (req->dev->type == TYPE_ROM) { req->cmd.xfer = [[cmd]][9] | ([[cmd]][8] << 8); } break; } return 0; }

[[[[Adv]]]]: static int scsi_req_length(SCSIRequest *req, uint8_t *[[pldt]]) { switch ([[pldt]][0] >> 5) { case 0: req->cmd.xfer = [[pldt]][4]; req->cmd.len = 6; if (req->cmd.xfer == 0) req->cmd.xfer = 256; break; case 1: case 2: req->cmd.xfer = [[pldt]][8] | ([[pldt]][7] << 8); req->cmd.len = 10; break; case 4: req->cmd.xfer = [[pldt]][13] | ([[pldt]][12] << 8) | ([[pldt]][11] << 16) | ([[pldt]][10] << 24); req->cmd.len = 16; break; case 5: req->cmd.xfer = [[pldt]][9] | ([[pldt]][8] << 8) | ([[pldt]][7] << 16) | ([[pldt]][6] << 24); req->cmd.len = 12; break; default: trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, [[pldt]][0]); return -1; } switch([[pldt]][0]) { case TEST_UNIT_READY: case START_STOP: case SEEK_6: case WRITE_FILEMARKS: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case VERIFY: case SEEK_10: case SYNCHRONIZE_CACHE: case LOCK_UNLOCK_CACHE: case LOAD_UNLOAD: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG: case MOVE_MEDIUM: case UPDATE_BLOCK: req->cmd.xfer = 0; break; case MODE_SENSE: break; case WRITE_SAME: req->cmd.xfer = 1; break; case READ_CAPACITY: req->cmd.xfer = 8; break; case READ_BLOCK_LIMITS: req->cmd.xfer = 6; break; case READ_POSITION: req->cmd.xfer = 20; break; case SEND_VOLUME_TAG: req->cmd.xfer *= 40; break; case MEDIUM_SCAN: req->cmd.xfer *= 8; break; case WRITE_10: case WRITE_VERIFY: case WRITE_6: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: req->cmd.xfer *= req->dev->blocksize; break; case READ_10: case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: req->cmd.xfer *= req->dev->blocksize; break; case INQUIRY: req->cmd.xfer = [[pldt]][4] | ([[pldt]][3] << 8); break; case MAINTENANCE_OUT: case MAINTENANCE_IN: if (req->dev->type == TYPE_ROM) { req->cmd.xfer = [[pldt]][9] | ([[pldt]][8] << 8); } break; } return 0; }
--------------------------------------------- Result 159 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 14 / 62 / 159:   6%|▌         | 159/2690 [22:13<5:53:46,  8.39s/it][Succeeded / Failed / Skipped / Total] 83 / 14 / 62 / 159:   6%|▌         | 160/2690 [22:18<5:52:37,  8.36s/it][Succeeded / Failed / Skipped / Total] 84 / 14 / 62 / 160:   6%|▌         | 160/2690 [22:18<5:52:37,  8.36s/it][Succeeded / Failed / Skipped / Total] 84 / 14 / 62 / 160:   6%|▌         | 161/2690 [22:41<5:56:33,  8.46s/it][Succeeded / Failed / Skipped / Total] 85 / 14 / 62 / 161:   6%|▌         | 161/2690 [22:41<5:56:33,  8.46s/it][Succeeded / Failed / Skipped / Total] 85 / 14 / 62 / 161:   6%|▌         | 162/2690 [22:42<5:54:20,  8.41s/it][Succeeded / Failed / Skipped / Total] 85 / 14 / 63 / 162:   6%|▌         | 162/2690 [22:42<5:54:20,  8.41s/it][Succeeded / Failed / Skipped / Total] 85 / 14 / 63 / 162:   6%|▌         | 163/2690 [22:44<5:52:38,  8.37s/it][Succeeded / Failed / Skipped / Total] 86 / 14 / 63 / 163:   6%|▌         | 163/2690 [22:44<5:52:38,  8.37s/it][Succeeded / Failed / Skipped / Total] 86 / 14 / 63 / 163:   6%|▌         | 164/2690 [22:45<5:50:29,  8.33s/it][[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int kvmppc_reset_htab(int shift_hint) { uint32_t shift = shift_hint; if (!kvm_enabled()) { return 0; } if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) { int ret; ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift); if (ret == -ENOTTY) { return 0; } else if (ret < 0) { return ret; } return shift; } if (kvmppc_is_pr(kvm_state)) { return 0; } else { return 24; } }
--------------------------------------------- Result 160 ---------------------------------------------
[[0 (94%)]] --> [[0 (35%)]] --> Socre: 0.6476672291755676

[[[[Adv]]]]: int ff_schro_queue_push_back(FFSchroQueue *queue, void *[[p_data]]) { FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement)); if (!p_new) return -1; p_new->data = [[p_data]]; if (!queue->p_head) queue->p_head = p_new; else queue->p_tail->next = p_new; queue->p_tail = p_new; ++queue->size; return 0; }

[[[[Adv]]]]: int ff_schro_queue_push_back(FFSchroQueue *queue, void *[[t_clock]]) { FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement)); if (!p_new) return -1; p_new->data = [[t_clock]]; if (!queue->p_head) queue->p_head = p_new; else queue->p_tail->next = p_new; queue->p_tail = p_new; ++queue->size; return 0; }
--------------------------------------------- Result 161 ---------------------------------------------
[[0 (84%)]] --> [[0 (49%)]] --> Socre: 0.5125907361507416

[[[[Adv]]]]: static void test_qemu_strtoll_whitespace(void) { const char *[[str]] = " \t "; char [[f]] = 'X'; const char *endptr = &[[f]]; int64_t [[res]] = 999; int [[err]]; [[err]] = qemu_strtoll([[str]], &endptr, 0, &[[res]]); g_assert_cmpint([[err]], ==, 0); g_assert_cmpint([[res]], ==, 0); g_assert(endptr == [[str]]); }

[[[[Adv]]]]: static void test_qemu_strtoll_whitespace(void) { const char *[[placem]] = " \t "; char [[fx]] = 'X'; const char *endptr = &[[fx]]; int64_t [[reg]] = 999; int [[autor]]; [[autor]] = qemu_strtoll([[placem]], &endptr, 0, &[[reg]]); g_assert_cmpint([[autor]], ==, 0); g_assert_cmpint([[reg]], ==, 0); g_assert(endptr == [[placem]]); }
--------------------------------------------- Result 162 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data) { DeviceClass *dc = DEVICE_CLASS(oc); PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc); CPUClass *cc = CPU_CLASS(oc); dc->fw_name = "PowerPC,POWER9"; dc->desc = "POWER9"; dc->props = powerpc_servercpu_properties; pcc->pvr_match = ppc_pvr_match_power9; pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07; pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 | PCR_COMPAT_2_05; pcc->init_proc = init_proc_POWER9; pcc->check_pow = check_pow_nocheck; cc->has_work = cpu_has_work_POWER9; pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB | PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES | PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE | PPC_FLOAT_FRSQRTES | PPC_FLOAT_STFIWX | PPC_FLOAT_EXT | PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ | PPC_MEM_SYNC | PPC_MEM_EIEIO | PPC_MEM_TLBIE | PPC_MEM_TLBSYNC | PPC_64B | PPC_64BX | PPC_ALTIVEC | PPC_SEGMENT_64B | PPC_SLBI | PPC_POPCNTB | PPC_POPCNTWD | PPC_CILDST; pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX | PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 | PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 | PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 | PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 | PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 | PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300; pcc->msr_mask = (1ull << MSR_SF) | (1ull << MSR_TM) | (1ull << MSR_VR) | (1ull << MSR_VSX) | (1ull << MSR_EE) | (1ull << MSR_PR) | (1ull << MSR_FP) | (1ull << MSR_ME) | (1ull << MSR_FE0) | (1ull << MSR_SE) | (1ull << MSR_DE) | (1ull << MSR_FE1) | (1ull << MSR_IR) | (1ull << MSR_DR) | (1ull << MSR_PMM) | (1ull << MSR_RI) | (1ull << MSR_LE); pcc->mmu_model = POWERPC_MMU_3_00; #if defined(CONFIG_SOFTMMU) pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault; pcc->sps = &POWER7_POWER8_sps; pcc->radix_page_info = &POWER9_radix_page_info; #endif pcc->excp_model = POWERPC_EXCP_POWER8; pcc->bus_model = PPC_FLAGS_INPUT_POWER7; pcc->bfd_mach = bfd_mach_ppc64; pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE | POWERPC_FLAG_BE | POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR | POWERPC_FLAG_VSX | POWERPC_FLAG_TM; pcc->l1_dcache_size = 0x8000; pcc->l1_icache_size = 0x8000; pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr; }
--------------------------------------------- Result 163 ---------------------------------------------
[[0 (51%)]] --> [[0 (33%)]] --> Socre: 0.6716734766960144

[[[[Adv]]]]: static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; PTXContext * const s = avctx->priv_data; AVFrame *[[picture]] = data; AVFrame * const p = &s->picture; unsigned int offset, w, h, y, stride, bytes_per_pixel; uint8_t *ptr; offset = AV_RL16(buf); w = AV_RL16(buf+8); h = AV_RL16(buf+10); bytes_per_pixel = AV_RL16(buf+12) >> 3; if (bytes_per_pixel != 2) { av_log_ask_for_sample(avctx, "Image format is not RGB15.\n"); return -1; } avctx->pix_fmt = PIX_FMT_RGB555; if (buf_end - buf < offset) if (offset != 0x2c) av_log_ask_for_sample(avctx, "offset != 0x2c\n"); buf += offset; if (p->data[0]) avctx->release_buffer(avctx, p); if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx->width || h != avctx->height) avcodec_set_dimensions(avctx, w, h); if (avctx->get_buffer(avctx, p) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } p->pict_type = AV_PICTURE_TYPE_I; ptr = p->data[0]; stride = p->linesize[0]; for (y=0; y<h; y++) { if (buf_end - buf < w * bytes_per_pixel) break; #if HAVE_BIGENDIAN unsigned int x; for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel) AV_WN16(ptr+x, AV_RL16(buf+x)); #else memcpy(ptr, buf, w*bytes_per_pixel); #endif ptr += stride; buf += w*bytes_per_pixel; } *[[picture]] = s->picture; *data_size = sizeof(AVPicture); return offset + w*h*bytes_per_pixel; }

[[[[Adv]]]]: static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; PTXContext * const s = avctx->priv_data; AVFrame *[[jump]] = data; AVFrame * const p = &s->picture; unsigned int offset, w, h, y, stride, bytes_per_pixel; uint8_t *ptr; offset = AV_RL16(buf); w = AV_RL16(buf+8); h = AV_RL16(buf+10); bytes_per_pixel = AV_RL16(buf+12) >> 3; if (bytes_per_pixel != 2) { av_log_ask_for_sample(avctx, "Image format is not RGB15.\n"); return -1; } avctx->pix_fmt = PIX_FMT_RGB555; if (buf_end - buf < offset) if (offset != 0x2c) av_log_ask_for_sample(avctx, "offset != 0x2c\n"); buf += offset; if (p->data[0]) avctx->release_buffer(avctx, p); if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx->width || h != avctx->height) avcodec_set_dimensions(avctx, w, h); if (avctx->get_buffer(avctx, p) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } p->pict_type = AV_PICTURE_TYPE_I; ptr = p->data[0]; stride = p->linesize[0]; for (y=0; y<h; y++) { if (buf_end - buf < w * bytes_per_pixel) break; #if HAVE_BIGENDIAN unsigned int x; for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel) AV_WN16(ptr+x, AV_RL16(buf+x)); #else memcpy(ptr, buf, w*bytes_per_pixel); #endif ptr += stride; buf += w*bytes_per_pixel; } *[[jump]] = s->picture; *data_size = sizeof(AVPicture); return offset + w*h*bytes_per_pixel; }
--------------------------------------------- Result 164 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 86 / 14 / 64 / 164:   6%|▌         | 164/2690 [22:45<5:50:29,  8.33s/it][Succeeded / Failed / Skipped / Total] 86 / 14 / 64 / 164:   6%|▌         | 165/2690 [22:55<5:50:47,  8.34s/it][Succeeded / Failed / Skipped / Total] 86 / 15 / 64 / 165:   6%|▌         | 165/2690 [22:55<5:50:47,  8.34s/it][Succeeded / Failed / Skipped / Total] 86 / 15 / 64 / 165:   6%|▌         | 166/2690 [23:06<5:51:25,  8.35s/it][Succeeded / Failed / Skipped / Total] 87 / 15 / 64 / 166:   6%|▌         | 166/2690 [23:06<5:51:25,  8.35s/it][Succeeded / Failed / Skipped / Total] 87 / 15 / 64 / 166:   6%|▌         | 167/2690 [23:19<5:52:16,  8.38s/it][Succeeded / Failed / Skipped / Total] 88 / 15 / 64 / 167:   6%|▌         | 167/2690 [23:19<5:52:16,  8.38s/it][Succeeded / Failed / Skipped / Total] 88 / 15 / 64 / 167:   6%|▌         | 168/2690 [23:21<5:50:42,  8.34s/it][[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt); opj_image_cmptparm_t cmptparm[4] = {{0}}; opj_image_t *img; int i; int sub_dx[4]; int sub_dy[4]; int numcomps; OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN; sub_dx[0] = sub_dx[3] = 1; sub_dy[0] = sub_dy[3] = 1; sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w; sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h; numcomps = desc->nb_components; switch (avctx->pix_fmt) { case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YA8: case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YA16: color_space = CLRSPC_GRAY; break; case AV_PIX_FMT_RGB24: case AV_PIX_FMT_RGBA: case AV_PIX_FMT_RGB48: case AV_PIX_FMT_RGBA64: case AV_PIX_FMT_GBR24P: case AV_PIX_FMT_GBRP9: case AV_PIX_FMT_GBRP10: case AV_PIX_FMT_GBRP12: case AV_PIX_FMT_GBRP14: case AV_PIX_FMT_GBRP16: case AV_PIX_FMT_XYZ12: color_space = CLRSPC_SRGB; break; case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUVA420P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUV420P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUVA420P9: case AV_PIX_FMT_YUVA422P9: case AV_PIX_FMT_YUVA444P9: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUVA420P10: case AV_PIX_FMT_YUVA422P10: case AV_PIX_FMT_YUVA444P10: case AV_PIX_FMT_YUV420P12: case AV_PIX_FMT_YUV422P12: case AV_PIX_FMT_YUV444P12: case AV_PIX_FMT_YUV420P14: case AV_PIX_FMT_YUV422P14: case AV_PIX_FMT_YUV444P14: case AV_PIX_FMT_YUV420P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUVA420P16: case AV_PIX_FMT_YUVA422P16: case AV_PIX_FMT_YUVA444P16: color_space = CLRSPC_SYCC; break; default: av_log(avctx, AV_LOG_ERROR, "The requested pixel format '%s' is not supported\n", av_get_pix_fmt_name(avctx->pix_fmt)); } for (i = 0; i < numcomps; i++) { cmptparm[i].prec = desc->comp[i].depth_minus1 + 1; cmptparm[i].bpp = desc->comp[i].depth_minus1 + 1; cmptparm[i].sgnd = 0; cmptparm[i].dx = sub_dx[i]; cmptparm[i].dy = sub_dy[i]; cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i]; cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i]; } img = opj_image_create(numcomps, cmptparm, color_space); img->x0 = 0; img->y0 = 0; img->x1 = (avctx->width - 1) * parameters->subsampling_dx + 1; img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1; return img; }
--------------------------------------------- Result 165 ---------------------------------------------
[[0 (77%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void vpc_close(BlockDriverState *[[bs]]) { BDRVVPCState *[[s]] = [[bs]]->opaque; g_free([[s]]->pagetable); #ifdef CACHE g_free([[s]]->pageentry_u8); #endif migrate_del_blocker([[s]]->migration_blocker); error_free([[s]]->migration_blocker); }

[[[[Adv]]]]: static void vpc_close(BlockDriverState *[[n]]) { BDRVVPCState *[[es]] = [[n]]->opaque; g_free([[es]]->pagetable); #ifdef CACHE g_free([[es]]->pageentry_u8); #endif migrate_del_blocker([[es]]->migration_blocker); error_free([[es]]->migration_blocker); }
--------------------------------------------- Result 166 ---------------------------------------------
[[0 (7%)]] --> [[0 (96%)]] --> Socre: 0.9598402976989746

[[[[Adv]]]]: static int xen_platform_initfn(PCIDevice *dev) { PCIXenPlatformState *[[d]] = DO_UPCAST(PCIXenPlatformState, pci_dev, dev); uint8_t *pci_conf; pci_conf = [[d]]->pci_dev.config; pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY); pci_config_set_prog_interface(pci_conf, 0); pci_conf[PCI_INTERRUPT_PIN] = 1; pci_register_bar(&[[d]]->pci_dev, 0, 0x100, PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map); pci_register_bar(&[[d]]->pci_dev, 1, 0x1000000, PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map); platform_fixed_ioport_init([[d]]); return 0; }

[[[[Adv]]]]: static int xen_platform_initfn(PCIDevice *dev) { PCIXenPlatformState *[[δ]] = DO_UPCAST(PCIXenPlatformState, pci_dev, dev); uint8_t *pci_conf; pci_conf = [[δ]]->pci_dev.config; pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY); pci_config_set_prog_interface(pci_conf, 0); pci_conf[PCI_INTERRUPT_PIN] = 1; pci_register_bar(&[[δ]]->pci_dev, 0, 0x100, PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map); pci_register_bar(&[[δ]]->pci_dev, 1, 0x1000000, PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map); platform_fixed_ioport_init([[δ]]); return 0; }
--------------------------------------------- Result 167 ---------------------------------------------
[[0 (43%)]] --> [[0 (53%)]] --> Socre: 0.5267022252082825

[[[[Adv]]]]: static int vfio_enable_intx(VFIODevice *vdev) { VFIOIRQSetFD irq_set_fd = { .irq_set = { .argsz = sizeof(irq_set_fd), .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER, .index = VFIO_PCI_INTX_IRQ_INDEX, .start = 0, .count = 1, }, }; uint8_t [[pin]] = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1); int ret; if (vdev->intx.disabled || ![[pin]]) { return 0; } vfio_disable_interrupts(vdev); vdev->intx.pin = [[pin]] - 1; ret = event_notifier_init(&vdev->intx.interrupt, 0); if (ret) { error_report("vfio: Error: event_notifier_init failed\n"); return ret; } irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt); qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev); if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) { error_report("vfio: Error: Failed to setup INTx fd: %m\n"); return -errno; } vfio_mmap_set_enabled(vdev, "False" != "False"); vdev->interrupt = VFIO_INT_INTx; DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); return 0; }

[[[[Adv]]]]: static int vfio_enable_intx(VFIODevice *vdev) { VFIOIRQSetFD irq_set_fd = { .irq_set = { .argsz = sizeof(irq_set_fd), .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER, .index = VFIO_PCI_INTX_IRQ_INDEX, .start = 0, .count = 1, }, }; uint8_t [[pic]] = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1); int ret; if (vdev->intx.disabled || ![[pic]]) { return 0; } vfio_disable_interrupts(vdev); vdev->intx.pin = [[pic]] - 1; ret = event_notifier_init(&vdev->intx.interrupt, 0); if (ret) { error_report("vfio: Error: event_notifier_init failed\n"); return ret; } irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt); qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev); if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) { error_report("vfio: Error: Failed to setup INTx fd: %m\n"); return -errno; } vfio_mmap_set_enabled(vdev, "False" != "False"); vdev->interrupt = VFIO_INT_INTx; DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); return 0; }
--------------------------------------------- Result 168 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 89 / 15 / 64 / 168:   6%|▌         | 168/2690 [23:21<5:50:42,  8.34s/it][Succeeded / Failed / Skipped / Total] 89 / 15 / 64 / 168:   6%|▋         | 169/2690 [23:29<5:50:26,  8.34s/it][Succeeded / Failed / Skipped / Total] 90 / 15 / 64 / 169:   6%|▋         | 169/2690 [23:29<5:50:26,  8.34s/it][Succeeded / Failed / Skipped / Total] 90 / 15 / 64 / 169:   6%|▋         | 170/2690 [23:35<5:49:46,  8.33s/it][Succeeded / Failed / Skipped / Total] 90 / 16 / 64 / 170:   6%|▋         | 170/2690 [23:35<5:49:46,  8.33s/it][Succeeded / Failed / Skipped / Total] 90 / 16 / 64 / 170:   6%|▋         | 171/2690 [23:52<5:51:46,  8.38s/it][Succeeded / Failed / Skipped / Total] 91 / 16 / 64 / 171:   6%|▋         | 171/2690 [23:52<5:51:46,  8.38s/it][Succeeded / Failed / Skipped / Total] 91 / 16 / 64 / 171:   6%|▋         | 172/2690 [24:04<5:52:28,  8.40s/it][[0 (2%)]] --> [[0 (96%)]] --> Socre: 0.960289716720581

[[[[Adv]]]]: static int proxy_symlink(FsContext *fs_ctx, const char *oldpath, V9fsPath *dir_path, const char *name, FsCred *[[credp]]) { int retval; V9fsString fullname, target; v9fs_string_init(&fullname); v9fs_string_init(&target); v9fs_string_sprintf(&fullname, "%s/%s", dir_path->data, name); v9fs_string_sprintf(&target, "%s", oldpath); retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, "ssdd", &target, &fullname, [[credp]]->fc_uid, [[credp]]->fc_gid); v9fs_string_free(&fullname); v9fs_string_free(&target); if (retval < 0) { errno = -retval; retval = -1; } return retval; }

[[[[Adv]]]]: static int proxy_symlink(FsContext *fs_ctx, const char *oldpath, V9fsPath *dir_path, const char *name, FsCred *[[sressп]]) { int retval; V9fsString fullname, target; v9fs_string_init(&fullname); v9fs_string_init(&target); v9fs_string_sprintf(&fullname, "%s/%s", dir_path->data, name); v9fs_string_sprintf(&target, "%s", oldpath); retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, "ssdd", &target, &fullname, [[sressп]]->fc_uid, [[sressп]]->fc_gid); v9fs_string_free(&fullname); v9fs_string_free(&target); if (retval < 0) { errno = -retval; retval = -1; } return retval; }
--------------------------------------------- Result 169 ---------------------------------------------
[[0 (61%)]] --> [[0 (46%)]] --> Socre: 0.5400267243385315

[[[[Adv]]]]: static int mxf_read_header(AVFormatContext *[[s]], AVFormatParameters *ap) { MXFContext *[[mxf]] = [[s]]->priv_data; KLVPacket klv; int64_t essence_offset = 0; [[mxf]]->last_forward_tell = INT64_MAX; if (!mxf_read_sync([[s]]->pb, mxf_header_partition_pack_key, 14)) { av_log([[s]], AV_LOG_ERROR, "could not find header partition pack key\n"); return AVERROR_INVALIDDATA; } avio_seek([[s]]->pb, -14, SEEK_CUR); [[mxf]]->fc = [[s]]; [[mxf]]->run_in = avio_tell([[s]]->pb); while (![[s]]->pb->eof_reached) { const MXFMetadataReadTableEntry *metadata; if (klv_read_packet(&klv, [[s]]->pb) < 0) { if(mxf_parse_handle_partition_or_eof([[mxf]]) <= 0) break; else continue; } PRINT_KEY([[s]], "read header", klv.key); av_dlog([[s]], "size %"PRIu64" offset %#"PRIx64"\n", klv.length, klv.offset); if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) || IS_KLV_KEY(klv.key, mxf_essence_element_key) || IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) || IS_KLV_KEY(klv.key, mxf_system_item_key)) { if (![[mxf]]->current_partition->essence_offset) { compute_partition_essence_offset([[s]], [[mxf]], &klv); } if (!essence_offset) essence_offset = klv.offset; if (mxf_parse_handle_essence([[mxf]]) <= 0) break; continue; } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) && klv.key[13] >= 2 && klv.key[13] <= 4 && [[mxf]]->current_partition) { if(mxf_parse_handle_partition_or_eof([[mxf]]) <= 0) break; } for (metadata = mxf_metadata_read_table; metadata->read; metadata++) { if (IS_KLV_KEY(klv.key, metadata->key)) { int res; if (klv.key[5] == 0x53) { res = mxf_read_local_tags([[mxf]], &klv, metadata->read, metadata->ctx_size, metadata->type); } else { uint64_t next = avio_tell([[s]]->pb) + klv.length; res = metadata->read([[mxf]], [[s]]->pb, 0, klv.length, klv.key, klv.offset); avio_seek([[s]]->pb, next, SEEK_SET); } if (res < 0) { av_log([[s]], AV_LOG_ERROR, "error reading header metadata\n"); return res; } break; } } if (!metadata->read) avio_skip([[s]]->pb, klv.length); } if (!essence_offset) { av_log([[s]], AV_LOG_ERROR, "no essence\n"); return AVERROR_INVALIDDATA; } avio_seek([[s]]->pb, essence_offset, SEEK_SET); mxf_compute_essence_containers([[mxf]]); return mxf_parse_structural_metadata([[mxf]]); }

[[[[Adv]]]]: static int mxf_read_header(AVFormatContext *[[min]], AVFormatParameters *ap) { MXFContext *[[fffy]] = [[min]]->priv_data; KLVPacket klv; int64_t essence_offset = 0; [[fffy]]->last_forward_tell = INT64_MAX; if (!mxf_read_sync([[min]]->pb, mxf_header_partition_pack_key, 14)) { av_log([[min]], AV_LOG_ERROR, "could not find header partition pack key\n"); return AVERROR_INVALIDDATA; } avio_seek([[min]]->pb, -14, SEEK_CUR); [[fffy]]->fc = [[min]]; [[fffy]]->run_in = avio_tell([[min]]->pb); while (![[min]]->pb->eof_reached) { const MXFMetadataReadTableEntry *metadata; if (klv_read_packet(&klv, [[min]]->pb) < 0) { if(mxf_parse_handle_partition_or_eof([[fffy]]) <= 0) break; else continue; } PRINT_KEY([[min]], "read header", klv.key); av_dlog([[min]], "size %"PRIu64" offset %#"PRIx64"\n", klv.length, klv.offset); if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) || IS_KLV_KEY(klv.key, mxf_essence_element_key) || IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) || IS_KLV_KEY(klv.key, mxf_system_item_key)) { if (![[fffy]]->current_partition->essence_offset) { compute_partition_essence_offset([[min]], [[fffy]], &klv); } if (!essence_offset) essence_offset = klv.offset; if (mxf_parse_handle_essence([[fffy]]) <= 0) break; continue; } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) && klv.key[13] >= 2 && klv.key[13] <= 4 && [[fffy]]->current_partition) { if(mxf_parse_handle_partition_or_eof([[fffy]]) <= 0) break; } for (metadata = mxf_metadata_read_table; metadata->read; metadata++) { if (IS_KLV_KEY(klv.key, metadata->key)) { int res; if (klv.key[5] == 0x53) { res = mxf_read_local_tags([[fffy]], &klv, metadata->read, metadata->ctx_size, metadata->type); } else { uint64_t next = avio_tell([[min]]->pb) + klv.length; res = metadata->read([[fffy]], [[min]]->pb, 0, klv.length, klv.key, klv.offset); avio_seek([[min]]->pb, next, SEEK_SET); } if (res < 0) { av_log([[min]], AV_LOG_ERROR, "error reading header metadata\n"); return res; } break; } } if (!metadata->read) avio_skip([[min]]->pb, klv.length); } if (!essence_offset) { av_log([[min]], AV_LOG_ERROR, "no essence\n"); return AVERROR_INVALIDDATA; } avio_seek([[min]]->pb, essence_offset, SEEK_SET); mxf_compute_essence_containers([[fffy]]); return mxf_parse_structural_metadata([[fffy]]); }
--------------------------------------------- Result 170 ---------------------------------------------
[[0 (15%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void helper_store_fpcr (uint64_t [[val]]) { #ifdef CONFIG_SOFTFLOAT set_float_exception_flags(([[val]] >> 52) & 0x3F, &FP_STATUS); #endif switch (([[val]] >> 58) & 3) { case 0: set_float_rounding_mode(float_round_to_zero, &FP_STATUS); break; case 1: set_float_rounding_mode(float_round_down, &FP_STATUS); break; case 2: set_float_rounding_mode(float_round_nearest_even, &FP_STATUS); break; case 3: set_float_rounding_mode(float_round_up, &FP_STATUS); break; } }

[[[[Adv]]]]: void helper_store_fpcr (uint64_t [[mal]]) { #ifdef CONFIG_SOFTFLOAT set_float_exception_flags(([[mal]] >> 52) & 0x3F, &FP_STATUS); #endif switch (([[mal]] >> 58) & 3) { case 0: set_float_rounding_mode(float_round_to_zero, &FP_STATUS); break; case 1: set_float_rounding_mode(float_round_down, &FP_STATUS); break; case 2: set_float_rounding_mode(float_round_nearest_even, &FP_STATUS); break; case 3: set_float_rounding_mode(float_round_up, &FP_STATUS); break; } }
--------------------------------------------- Result 171 ---------------------------------------------
[[0 (3%)]] --> [[0 (65%)]] --> Socre: 0.6489422917366028

[[[[Adv]]]]: void spapr_tce_set_bypass(sPAPRTCETable *[[tcet]], bool bypass) { [[tcet]]->bypass = bypass; }

[[[[Adv]]]]: void spapr_tce_set_bypass(sPAPRTCETable *[[tramem]], bool bypass) { [[tramem]]->bypass = bypass; }
--------------------------------------------- Result 172 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 92 / 16 / 64 / 172:   6%|▋         | 172/2690 [24:04<5:52:28,  8.40s/it][Succeeded / Failed / Skipped / Total] 92 / 16 / 64 / 172:   6%|▋         | 173/2690 [24:04<5:50:20,  8.35s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 64 / 173:   6%|▋         | 173/2690 [24:04<5:50:20,  8.35s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 64 / 173:   6%|▋         | 174/2690 [24:05<5:48:19,  8.31s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 65 / 174:   6%|▋         | 174/2690 [24:05<5:48:19,  8.31s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 65 / 174:   7%|▋         | 175/2690 [24:05<5:46:19,  8.26s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 66 / 175:   7%|▋         | 175/2690 [24:05<5:46:19,  8.26s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 66 / 175:   7%|▋         | 176/2690 [24:06<5:44:20,  8.22s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 67 / 176:   7%|▋         | 176/2690 [24:06<5:44:20,  8.22s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 67 / 176:   7%|▋         | 177/2690 [24:06<5:42:22,  8.17s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 68 / 177:   7%|▋         | 177/2690 [24:06<5:42:22,  8.17s/it][Succeeded / Failed / Skipped / Total] 93 / 16 / 68 / 177:   7%|▋         | 178/2690 [24:52<5:51:00,  8.38s/it][[0 (4%)]] --> [[0 (59%)]] --> Socre: 0.5857346057891846

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t [[l]], uint64_t [[dest]], uint64_t src) { int i = 0; int x = 0; uint32_t l_64 = ([[l]] + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, [[l]], [[dest]], src); #ifndef CONFIG_USER_ONLY if (([[l]] > 32) && (src & TARGET_PAGE_MASK) == ((src + [[l]]) & TARGET_PAGE_MASK) && ([[dest]] & TARGET_PAGE_MASK) == (([[dest]] + [[l]]) & TARGET_PAGE_MASK)) { if ([[dest]] == (src + 1)) { mvc_fast_memset(env, [[l]] + 1, [[dest]], cpu_ldub_data(env, src)); return; } else if ((src & TARGET_PAGE_MASK) != ([[dest]] & TARGET_PAGE_MASK)) { mvc_fast_memmove(env, [[l]] + 1, [[dest]], src); return; } } #else if ([[dest]] == (src + 1)) { memset(g2h([[dest]]), cpu_ldub_data(env, src), [[l]] + 1); return; } else if (([[dest]] < src) || (src + [[l]] < [[dest]])) { memmove(g2h([[dest]]), g2h(src), [[l]] + 1); return; } #endif if (([[dest]] + 8 <= src) || (src + 8 <= [[dest]])) { for (i = 0; i < l_64; i++) { cpu_stq_data(env, [[dest]] + x, cpu_ldq_data(env, src + x)); x += 8; } } for (i = x; i <= [[l]]; i++) { cpu_stb_data(env, [[dest]] + i, cpu_ldub_data(env, src + i)); } }

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t [[ɫ]], uint64_t [[reignh]], uint64_t src) { int i = 0; int x = 0; uint32_t l_64 = ([[ɫ]] + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, [[ɫ]], [[reignh]], src); #ifndef CONFIG_USER_ONLY if (([[ɫ]] > 32) && (src & TARGET_PAGE_MASK) == ((src + [[ɫ]]) & TARGET_PAGE_MASK) && ([[reignh]] & TARGET_PAGE_MASK) == (([[reignh]] + [[ɫ]]) & TARGET_PAGE_MASK)) { if ([[reignh]] == (src + 1)) { mvc_fast_memset(env, [[ɫ]] + 1, [[reignh]], cpu_ldub_data(env, src)); return; } else if ((src & TARGET_PAGE_MASK) != ([[reignh]] & TARGET_PAGE_MASK)) { mvc_fast_memmove(env, [[ɫ]] + 1, [[reignh]], src); return; } } #else if ([[reignh]] == (src + 1)) { memset(g2h([[reignh]]), cpu_ldub_data(env, src), [[ɫ]] + 1); return; } else if (([[reignh]] < src) || (src + [[ɫ]] < [[reignh]])) { memmove(g2h([[reignh]]), g2h(src), [[ɫ]] + 1); return; } #endif if (([[reignh]] + 8 <= src) || (src + 8 <= [[reignh]])) { for (i = 0; i < l_64; i++) { cpu_stq_data(env, [[reignh]] + x, cpu_ldq_data(env, src + x)); x += 8; } } for (i = x; i <= [[ɫ]]; i++) { cpu_stb_data(env, [[reignh]] + i, cpu_ldub_data(env, src + i)); } }
--------------------------------------------- Result 173 ---------------------------------------------
[[0 (21%)]] --> [[0 (56%)]] --> Socre: 0.5577900409698486

[[[[Adv]]]]: void qemu_system_wakeup_request(WakeupReason [[reason]]) { if (!is_suspended) { return; } if (!(wakeup_reason_mask & (1 << [[reason]]))) { return; } runstate_set(RUN_STATE_RUNNING); monitor_protocol_event(QEVENT_WAKEUP, NULL); notifier_list_notify(&wakeup_notifiers, &[[reason]]); reset_requested = 1; qemu_notify_event(); is_suspended = "[[False]]" != "[[False]]"; }

[[[[Adv]]]]: void qemu_system_wakeup_request(WakeupReason [[excuse]]) { if (!is_suspended) { return; } if (!(wakeup_reason_mask & (1 << [[excuse]]))) { return; } runstate_set(RUN_STATE_RUNNING); monitor_protocol_event(QEVENT_WAKEUP, NULL); notifier_list_notify(&wakeup_notifiers, &[[excuse]]); reset_requested = 1; qemu_notify_event(); is_suspended = "[[damn]]" != "[[damn]]"; }
--------------------------------------------- Result 174 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *open_inputs, AVFilterInOut *open_outputs, AVClass *log_ctx) { int index = 0, ret; char chr = 0; AVFilterInOut *curr_inputs = NULL; do { AVFilterContext *filter; filters += strspn(filters, WHITESPACES); if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0) goto fail; if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0) goto fail; if (filter->input_count == 1 && !curr_inputs && !index) { const char *tmp = "[in]"; if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0) goto fail; } if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0) goto fail; if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) < 0) goto fail; filters += strspn(filters, WHITESPACES); chr = *filters++; if (chr == ';' && curr_inputs) { av_log(log_ctx, AV_LOG_ERROR, "Could not find a output to link when parsing \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; } index++; } while (chr == ',' || chr == ';'); if (chr) { av_log(log_ctx, AV_LOG_ERROR, "Unable to parse graph description substring: \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; } if (open_inputs && !strcmp(open_inputs->name, "out") && curr_inputs) { const char *tmp = "[out]"; if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) < 0) goto fail; } return 0; fail: avfilter_graph_free(graph); free_inout(open_inputs); free_inout(open_outputs); free_inout(curr_inputs); return ret; }
--------------------------------------------- Result 175 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_net_device_exit(DeviceState *qdev) { VirtIONet *n = VIRTIO_NET(qdev); VirtIODevice *vdev = VIRTIO_DEVICE(qdev); int i; virtio_net_set_status(vdev, 0); unregister_savevm(qdev, "virtio-net", n); if (n->netclient_name) { g_free(n->netclient_name); n->netclient_name = NULL; } if (n->netclient_type) { g_free(n->netclient_type); n->netclient_type = NULL; } g_free(n->mac_table.macs); g_free(n->vlans); for (i = 0; i < n->max_queues; i++) { VirtIONetQueue *q = &n->vqs[i]; NetClientState *nc = qemu_get_subqueue(n->nic, i); qemu_purge_queued_packets(nc); if (q->tx_timer) { timer_del(q->tx_timer); timer_free(q->tx_timer); } else { qemu_bh_delete(q->tx_bh); } } g_free(n->vqs); qemu_del_nic(n->nic); virtio_cleanup(vdev); return 0; }
--------------------------------------------- Result 176 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u) { if (u) { switch (size) { case 0: gen_helper_neon_widen_u8(dest, src); break; case 1: gen_helper_neon_widen_u16(dest, src); break; case 2: tcg_gen_extu_i32_i64(dest, src); break; default: abort(); } } else { switch (size) { case 0: gen_helper_neon_widen_s8(dest, src); break; case 1: gen_helper_neon_widen_s16(dest, src); break; case 2: tcg_gen_ext_i32_i64(dest, src); break; default: abort(); } } dead_tmp(src); }
--------------------------------------------- Result 177 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sd_create_branch(BDRVSheepdogState *s) { int ret, fd; uint32_t vid; char *buf; dprintf("%" PRIx32 " is snapshot.\n", s->inode.vdi_id); buf = g_malloc(SD_INODE_SIZE); ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1, s->addr, s->port); if (ret) { goto out; } dprintf("%" PRIx32 " is created.\n", vid); fd = connect_to_sdog(s->addr, s->port); if (fd < 0) { error_report("failed to connect"); ret = fd; goto out; } ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies, SD_INODE_SIZE, 0, s->cache_enabled); closesocket(fd); if (ret < 0) { goto out; } memcpy(&s->inode, buf, sizeof(s->inode)); s->is_snapshot = "False" != "False"; ret = 0; dprintf("%" PRIx32 " was newly created.\n", s->inode.vdi_id); out: g_free(buf); return ret; }
--------------------------------------------- Result 178 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 94 / 16 / 68 / 178:   7%|▋         | 178/2690 [24:52<5:51:00,  8.38s/it][Succeeded / Failed / Skipped / Total] 94 / 16 / 68 / 178:   7%|▋         | 179/2690 [24:52<5:49:01,  8.34s/it][Succeeded / Failed / Skipped / Total] 94 / 16 / 69 / 179:   7%|▋         | 179/2690 [24:52<5:49:01,  8.34s/it][Succeeded / Failed / Skipped / Total] 94 / 16 / 69 / 179:   7%|▋         | 180/2690 [24:53<5:47:04,  8.30s/it][Succeeded / Failed / Skipped / Total] 94 / 16 / 70 / 180:   7%|▋         | 180/2690 [24:53<5:47:04,  8.30s/it][Succeeded / Failed / Skipped / Total] 94 / 16 / 70 / 180:   7%|▋         | 181/2690 [24:53<5:45:08,  8.25s/it][Succeeded / Failed / Skipped / Total] 94 / 16 / 71 / 181:   7%|▋         | 181/2690 [24:53<5:45:08,  8.25s/it][Succeeded / Failed / Skipped / Total] 94 / 16 / 71 / 181:   7%|▋         | 182/2690 [25:30<5:51:37,  8.41s/it][[0 (85%)]] --> [[0 (31%)]] --> Socre: 0.6924133896827698

[[[[Adv]]]]: static int parse_uint8(DeviceState *[[dev]], Property *[[prop]], const char *str) { uint8_t *ptr = qdev_get_prop_ptr([[dev]], [[prop]]); const char *fmt; fmt = strncasecmp(str, "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8; if (sscanf(str, fmt, ptr) != 1) return -EINVAL; return 0; }

[[[[Adv]]]]: static int parse_uint8(DeviceState *[[power]], Property *[[production]], const char *str) { uint8_t *ptr = qdev_get_prop_ptr([[power]], [[production]]); const char *fmt; fmt = strncasecmp(str, "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8; if (sscanf(str, fmt, ptr) != 1) return -EINVAL; return 0; }
--------------------------------------------- Result 179 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold int swri_rematrix_init(SwrContext *s){ int i, j; int nb_in = av_get_channel_layout_nb_channels(s->in_ch_layout); int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout); s->mix_any_f = NULL; if (!s->rematrix_custom) { int r = auto_matrix(s); if (r) return r; } if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int)); s->native_one = av_mallocz(sizeof(int)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) { double rem = 0; for (j = 0; j < nb_in; j++) { double target = s->matrix[i][j] * 32768 + rem; ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target); rem += target - ((int*)s->native_matrix)[i * nb_in + j]; } } *((int*)s->native_one) = 32768; s->mix_1_1_f = (mix_1_1_func_type*)copy_s16; s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float)); s->native_one = av_mallocz(sizeof(float)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) for (j = 0; j < nb_in; j++) ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j]; *((float*)s->native_one) = 1.0; s->mix_1_1_f = (mix_1_1_func_type*)copy_float; s->mix_2_1_f = (mix_2_1_func_type*)sum2_float; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double)); s->native_one = av_mallocz(sizeof(double)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) for (j = 0; j < nb_in; j++) ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j]; *((double*)s->native_one) = 1.0; s->mix_1_1_f = (mix_1_1_func_type*)copy_double; s->mix_2_1_f = (mix_2_1_func_type*)sum2_double; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){ s->native_one = av_mallocz(sizeof(int)); if (!s->native_one) return AVERROR(ENOMEM); *((int*)s->native_one) = 32768; s->mix_1_1_f = (mix_1_1_func_type*)copy_s32; s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s); }else av_assert0(0); for (i = 0; i < SWR_CH_MAX; i++) { int ch_in=0; for (j = 0; j < SWR_CH_MAX; j++) { s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768); if(s->matrix[i][j]) s->matrix_ch[i][++ch_in]= j; } s->matrix_ch[i][0]= ch_in; } if(HAVE_YASM && HAVE_MMX) return swri_rematrix_init_x86(s); return 0; }
--------------------------------------------- Result 180 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void s390_machine_reset(void) { S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0)); qemu_devices_reset(); s390_cmma_reset(); s390_crypto_reset(); s390_ipl_prepare_cpu(ipl_cpu); s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu); }
--------------------------------------------- Result 181 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int fic_decode_block(FICContext *ctx, GetBitContext *gb, uint8_t *dst, int stride, int16_t *block) { int i, num_coeff; if (get_bits1(gb)) { ctx->frame->key_frame = 0; ctx->frame->pict_type = AV_PICTURE_TYPE_P; return 0; } memset(block, 0, sizeof(*block) * 64); num_coeff = get_bits(gb, 7); if (num_coeff > 64) return AVERROR_INVALIDDATA; for (i = 0; i < num_coeff; i++) block[ff_zigzag_direct[i]] = get_se_golomb(gb) * ctx->qmat[ff_zigzag_direct[i]]; fic_idct_put(dst, stride, block); return 0; }
--------------------------------------------- Result 182 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 95 / 16 / 71 / 182:   7%|▋         | 182/2690 [25:30<5:51:37,  8.41s/it][Succeeded / Failed / Skipped / Total] 95 / 16 / 71 / 182:   7%|▋         | 183/2690 [25:51<5:54:19,  8.48s/it][Succeeded / Failed / Skipped / Total] 95 / 17 / 71 / 183:   7%|▋         | 183/2690 [25:51<5:54:19,  8.48s/it][Succeeded / Failed / Skipped / Total] 95 / 17 / 71 / 183:   7%|▋         | 184/2690 [25:52<5:52:22,  8.44s/it][Succeeded / Failed / Skipped / Total] 95 / 17 / 72 / 184:   7%|▋         | 184/2690 [25:52<5:52:22,  8.44s/it][Succeeded / Failed / Skipped / Total] 95 / 17 / 72 / 184:   7%|▋         | 185/2690 [25:53<5:50:28,  8.39s/it][[0 (75%)]] --> [[0 (38%)]] --> Socre: 0.6186527609825134

[[[[Adv]]]]: static int rtsp_listen(AVFormatContext *s) { RTSPState *rt = s->priv_data; char [[proto]][128], host[128], path[512], auth[128]; char uri[500]; int [[port]]; int default_port = RTSP_DEFAULT_PORT; char [[tcpname]][500]; const char *lower_proto = "tcp"; unsigned char rbuf[4096]; unsigned char [[method]][10]; int rbuflen = 0; int ret; enum RTSPMethod methodcode; if (!rt->protocols) { rt->protocols = ffurl_get_protocols(NULL, NULL); if (!rt->protocols) return AVERROR(ENOMEM); } av_url_split([[proto]], sizeof([[proto]]), auth, sizeof(auth), host, sizeof(host), &[[port]], path, sizeof(path), s->filename); ff_url_join(rt->control_uri, sizeof(rt->control_uri), [[proto]], NULL, host, [[port]], "%s", path); if (!strcmp([[proto]], "rtsps")) { lower_proto = "tls"; default_port = RTSPS_DEFAULT_PORT; } if ([[port]] < 0) [[port]] = default_port; ff_url_join([[tcpname]], sizeof([[tcpname]]), lower_proto, NULL, host, [[port]], "?listen&listen_timeout=%d", rt->initial_timeout * 1000); if (ret = ffurl_open(&rt->rtsp_hd, [[tcpname]], AVIO_FLAG_READ_WRITE, &s->interrupt_callback, NULL, rt->protocols)) { av_log(s, AV_LOG_ERROR, "Unable to open RTSP for listening\n"); return ret; } rt->state = RTSP_STATE_IDLE; rt->rtsp_hd_out = rt->rtsp_hd; for (;;) { ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen); if (ret < 0) return ret; ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), [[method]], sizeof([[method]]), &methodcode); if (ret) { av_log(s, AV_LOG_ERROR, "RTSP: Unexpected Command\n"); return ret; } if (methodcode == ANNOUNCE) { ret = rtsp_read_announce(s); rt->state = RTSP_STATE_PAUSED; } else if (methodcode == OPTIONS) { ret = rtsp_read_options(s); } else if (methodcode == RECORD) { ret = rtsp_read_record(s); if (!ret) return 0; } else if (methodcode == SETUP) ret = rtsp_read_setup(s, host, uri); if (ret) { ffurl_close(rt->rtsp_hd); return AVERROR_INVALIDDATA; } } return 0; }

[[[[Adv]]]]: static int rtsp_listen(AVFormatContext *s) { RTSPState *rt = s->priv_data; char [[howe]][128], host[128], path[512], auth[128]; char uri[500]; int [[region]]; int default_port = RTSP_DEFAULT_PORT; char [[acpynus]][500]; const char *lower_proto = "tcp"; unsigned char rbuf[4096]; unsigned char [[iris]][10]; int rbuflen = 0; int ret; enum RTSPMethod methodcode; if (!rt->protocols) { rt->protocols = ffurl_get_protocols(NULL, NULL); if (!rt->protocols) return AVERROR(ENOMEM); } av_url_split([[howe]], sizeof([[howe]]), auth, sizeof(auth), host, sizeof(host), &[[region]], path, sizeof(path), s->filename); ff_url_join(rt->control_uri, sizeof(rt->control_uri), [[howe]], NULL, host, [[region]], "%s", path); if (!strcmp([[howe]], "rtsps")) { lower_proto = "tls"; default_port = RTSPS_DEFAULT_PORT; } if ([[region]] < 0) [[region]] = default_port; ff_url_join([[acpynus]], sizeof([[acpynus]]), lower_proto, NULL, host, [[region]], "?listen&listen_timeout=%d", rt->initial_timeout * 1000); if (ret = ffurl_open(&rt->rtsp_hd, [[acpynus]], AVIO_FLAG_READ_WRITE, &s->interrupt_callback, NULL, rt->protocols)) { av_log(s, AV_LOG_ERROR, "Unable to open RTSP for listening\n"); return ret; } rt->state = RTSP_STATE_IDLE; rt->rtsp_hd_out = rt->rtsp_hd; for (;;) { ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen); if (ret < 0) return ret; ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), [[iris]], sizeof([[iris]]), &methodcode); if (ret) { av_log(s, AV_LOG_ERROR, "RTSP: Unexpected Command\n"); return ret; } if (methodcode == ANNOUNCE) { ret = rtsp_read_announce(s); rt->state = RTSP_STATE_PAUSED; } else if (methodcode == OPTIONS) { ret = rtsp_read_options(s); } else if (methodcode == RECORD) { ret = rtsp_read_record(s); if (!ret) return 0; } else if (methodcode == SETUP) ret = rtsp_read_setup(s, host, uri); if (ret) { ffurl_close(rt->rtsp_hd); return AVERROR_INVALIDDATA; } } return 0; }
--------------------------------------------- Result 183 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *[[gb]], VLC *vlc, const float *[[level_table]], const uint16_t *run_table, int [[version]], WMACoef *[[ptr]], int offset, int num_coefs, int block_len, int frame_len_bits, int coef_nb_bits) { int code, level, sign; const uint32_t *[[ilvl]] = (const uint32_t *) [[level_table]]; uint32_t *iptr = (uint32_t *) [[ptr]]; const unsigned int coef_mask = block_len - 1; for (; offset < num_coefs; offset++) { code = get_vlc2([[gb]], vlc->table, VLCBITS, VLCMAX); if (code > 1) { offset += run_table[code]; sign = get_bits1([[gb]]) - 1; iptr[offset & coef_mask] = [[ilvl]][code] ^ sign << 31; } else if (code == 1) { break; } else { if (![[version]]) { level = get_bits([[gb]], coef_nb_bits); offset += get_bits([[gb]], frame_len_bits); } else { level = ff_wma_get_large_val([[gb]]); if (get_bits1([[gb]])) { if (get_bits1([[gb]])) { if (get_bits1([[gb]])) { av_log(avctx, AV_LOG_ERROR, "broken escape sequence\n"); return -1; } else offset += get_bits([[gb]], frame_len_bits) + 4; } else offset += get_bits([[gb]], 2) + 1; } } sign = get_bits1([[gb]]) - 1; [[ptr]][offset & coef_mask] = (level ^ sign) - sign; } } if (offset > num_coefs) { av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); return -1; } return 0; }

[[[[Adv]]]]: int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *[[cox]], VLC *vlc, const float *[[parktechline]], const uint16_t *run_table, int [[usage]], WMACoef *[[kg]], int offset, int num_coefs, int block_len, int frame_len_bits, int coef_nb_bits) { int code, level, sign; const uint32_t *[[elfec]] = (const uint32_t *) [[parktechline]]; uint32_t *iptr = (uint32_t *) [[kg]]; const unsigned int coef_mask = block_len - 1; for (; offset < num_coefs; offset++) { code = get_vlc2([[cox]], vlc->table, VLCBITS, VLCMAX); if (code > 1) { offset += run_table[code]; sign = get_bits1([[cox]]) - 1; iptr[offset & coef_mask] = [[elfec]][code] ^ sign << 31; } else if (code == 1) { break; } else { if (![[usage]]) { level = get_bits([[cox]], coef_nb_bits); offset += get_bits([[cox]], frame_len_bits); } else { level = ff_wma_get_large_val([[cox]]); if (get_bits1([[cox]])) { if (get_bits1([[cox]])) { if (get_bits1([[cox]])) { av_log(avctx, AV_LOG_ERROR, "broken escape sequence\n"); return -1; } else offset += get_bits([[cox]], frame_len_bits) + 4; } else offset += get_bits([[cox]], 2) + 1; } } sign = get_bits1([[cox]]) - 1; [[kg]][offset & coef_mask] = (level ^ sign) - sign; } } if (offset > num_coefs) { av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); return -1; } return 0; }
--------------------------------------------- Result 184 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int get_video_buffer(AVFrame *frame, int align) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format); int ret, i; if (!desc) return AVERROR(EINVAL); if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0) return ret; if (!frame->linesize[0]) { ret = av_image_fill_linesizes(frame->linesize, frame->format, frame->width); if (ret < 0) return ret; for (i = 0; i < 4 && frame->linesize[i]; i++) frame->linesize[i] = FFALIGN(frame->linesize[i], align); } for (i = 0; i < 4 && frame->linesize[i]; i++) { int h = FFALIGN(frame->height, 32); if (i == 1 || i == 2) h = -((-h) >> desc->log2_chroma_h); frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h); if (!frame->buf[i]) goto fail; frame->data[i] = frame->buf[i]->data; } if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) { av_buffer_unref(&frame->buf[1]); frame->buf[1] = av_buffer_alloc(1024); if (!frame->buf[1]) goto fail; frame->data[1] = frame->buf[1]->data; } frame->extended_data = frame->data; return 0; fail: av_frame_unref(frame); return AVERROR(ENOMEM); }
--------------------------------------------- Result 185 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_get_msrs(X86CPU *cpu) { CPUX86State *env = &cpu->env; struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries; int ret, i; uint64_t mtrr_top_bits; kvm_msr_buf_reset(cpu); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0); kvm_msr_entry_add(cpu, MSR_PAT, 0); if (has_msr_star) { kvm_msr_entry_add(cpu, MSR_STAR, 0); } if (has_msr_hsave_pa) { kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0); } if (has_msr_tsc_aux) { kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0); } if (has_msr_tsc_adjust) { kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0); } if (has_msr_tsc_deadline) { kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0); } if (has_msr_misc_enable) { kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0); } if (has_msr_smbase) { kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0); } if (has_msr_feature_control) { kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0); } if (has_msr_bndcfgs) { kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0); } if (has_msr_xss) { kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0); } if (!env->tsc_valid) { kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0); env->tsc_valid = !runstate_is_running(); } #ifdef TARGET_X86_64 if (lm_capable_kernel) { kvm_msr_entry_add(cpu, MSR_CSTAR, 0); kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0); kvm_msr_entry_add(cpu, MSR_FMASK, 0); kvm_msr_entry_add(cpu, MSR_LSTAR, 0); } #endif kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0); kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0); if (has_msr_async_pf_en) { kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0); } if (has_msr_pv_eoi_en) { kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0); } if (has_msr_kvm_steal_time) { kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0); } if (has_msr_architectural_pmu) { kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0); for (i = 0; i < MAX_FIXED_COUNTERS; i++) { kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0); } for (i = 0; i < num_architectural_pmu_counters; i++) { kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0); kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0); } } if (env->mcg_cap) { kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0); kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0); if (has_msr_mcg_ext_ctl) { kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0); } for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) { kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0); } } if (has_msr_hv_hypercall) { kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0); } if (has_msr_hv_vapic) { kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0); } if (has_msr_hv_tsc) { kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0); } if (has_msr_hv_crash) { int j; for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) { kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0); } } if (has_msr_hv_runtime) { kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0); } if (cpu->hyperv_synic) { uint32_t msr; kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0); for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) { kvm_msr_entry_add(cpu, msr, 0); } } if (has_msr_hv_stimer) { uint32_t msr; for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT; msr++) { kvm_msr_entry_add(cpu, msr, 0); } } if (has_msr_mtrr) { kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0); for (i = 0; i < MSR_MTRRcap_VCNT; i++) { kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0); kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0); } } ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf); if (ret < 0) { return ret; } assert(ret == cpu->kvm_msr_buf->nmsrs); if (cpu->fill_mtrr_mask) { QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52); assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS); mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits); } else { mtrr_top_bits = 0; } for (i = 0; i < ret; i++) { uint32_t index = msrs[i].index; switch (index) { case MSR_IA32_SYSENTER_CS: env->sysenter_cs = msrs[i].data; break; case MSR_IA32_SYSENTER_ESP: env->sysenter_esp = msrs[i].data; break; case MSR_IA32_SYSENTER_EIP: env->sysenter_eip = msrs[i].data; break; case MSR_PAT: env->pat = msrs[i].data; break; case MSR_STAR: env->star = msrs[i].data; break; #ifdef TARGET_X86_64 case MSR_CSTAR: env->cstar = msrs[i].data; break; case MSR_KERNELGSBASE: env->kernelgsbase = msrs[i].data; break; case MSR_FMASK: env->fmask = msrs[i].data; break; case MSR_LSTAR: env->lstar = msrs[i].data; break; #endif case MSR_IA32_TSC: env->tsc = msrs[i].data; break; case MSR_TSC_AUX: env->tsc_aux = msrs[i].data; break; case MSR_TSC_ADJUST: env->tsc_adjust = msrs[i].data; break; case MSR_IA32_TSCDEADLINE: env->tsc_deadline = msrs[i].data; break; case MSR_VM_HSAVE_PA: env->vm_hsave = msrs[i].data; break; case MSR_KVM_SYSTEM_TIME: env->system_time_msr = msrs[i].data; break; case MSR_KVM_WALL_CLOCK: env->wall_clock_msr = msrs[i].data; break; case MSR_MCG_STATUS: env->mcg_status = msrs[i].data; break; case MSR_MCG_CTL: env->mcg_ctl = msrs[i].data; break; case MSR_MCG_EXT_CTL: env->mcg_ext_ctl = msrs[i].data; break; case MSR_IA32_MISC_ENABLE: env->msr_ia32_misc_enable = msrs[i].data; break; case MSR_IA32_SMBASE: env->smbase = msrs[i].data; break; case MSR_IA32_FEATURE_CONTROL: env->msr_ia32_feature_control = msrs[i].data; break; case MSR_IA32_BNDCFGS: env->msr_bndcfgs = msrs[i].data; break; case MSR_IA32_XSS: env->xss = msrs[i].data; break; default: if (msrs[i].index >= MSR_MC0_CTL && msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) { env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data; } break; case MSR_KVM_ASYNC_PF_EN: env->async_pf_en_msr = msrs[i].data; break; case MSR_KVM_PV_EOI_EN: env->pv_eoi_en_msr = msrs[i].data; break; case MSR_KVM_STEAL_TIME: env->steal_time_msr = msrs[i].data; break; case MSR_CORE_PERF_FIXED_CTR_CTRL: env->msr_fixed_ctr_ctrl = msrs[i].data; break; case MSR_CORE_PERF_GLOBAL_CTRL: env->msr_global_ctrl = msrs[i].data; break; case MSR_CORE_PERF_GLOBAL_STATUS: env->msr_global_status = msrs[i].data; break; case MSR_CORE_PERF_GLOBAL_OVF_CTRL: env->msr_global_ovf_ctrl = msrs[i].data; break; case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1: env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data; break; case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1: env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data; break; case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1: env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data; break; case HV_X64_MSR_HYPERCALL: env->msr_hv_hypercall = msrs[i].data; break; case HV_X64_MSR_GUEST_OS_ID: env->msr_hv_guest_os_id = msrs[i].data; break; case HV_X64_MSR_APIC_ASSIST_PAGE: env->msr_hv_vapic = msrs[i].data; break; case HV_X64_MSR_REFERENCE_TSC: env->msr_hv_tsc = msrs[i].data; break; case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4: env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data; break; case HV_X64_MSR_VP_RUNTIME: env->msr_hv_runtime = msrs[i].data; break; case HV_X64_MSR_SCONTROL: env->msr_hv_synic_control = msrs[i].data; break; case HV_X64_MSR_SVERSION: env->msr_hv_synic_version = msrs[i].data; break; case HV_X64_MSR_SIEFP: env->msr_hv_synic_evt_page = msrs[i].data; break; case HV_X64_MSR_SIMP: env->msr_hv_synic_msg_page = msrs[i].data; break; case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data; break; case HV_X64_MSR_STIMER0_CONFIG: case HV_X64_MSR_STIMER1_CONFIG: case HV_X64_MSR_STIMER2_CONFIG: case HV_X64_MSR_STIMER3_CONFIG: env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] = msrs[i].data; break; case HV_X64_MSR_STIMER0_COUNT: case HV_X64_MSR_STIMER1_COUNT: case HV_X64_MSR_STIMER2_COUNT: case HV_X64_MSR_STIMER3_COUNT: env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] = msrs[i].data; break; case MSR_MTRRdefType: env->mtrr_deftype = msrs[i].data; break; case MSR_MTRRfix64K_00000: env->mtrr_fixed[0] = msrs[i].data; break; case MSR_MTRRfix16K_80000: env->mtrr_fixed[1] = msrs[i].data; break; case MSR_MTRRfix16K_A0000: env->mtrr_fixed[2] = msrs[i].data; break; case MSR_MTRRfix4K_C0000: env->mtrr_fixed[3] = msrs[i].data; break; case MSR_MTRRfix4K_C8000: env->mtrr_fixed[4] = msrs[i].data; break; case MSR_MTRRfix4K_D0000: env->mtrr_fixed[5] = msrs[i].data; break; case MSR_MTRRfix4K_D8000: env->mtrr_fixed[6] = msrs[i].data; break; case MSR_MTRRfix4K_E0000: env->mtrr_fixed[7] = msrs[i].data; break; case MSR_MTRRfix4K_E8000: env->mtrr_fixed[8] = msrs[i].data; break; case MSR_MTRRfix4K_F0000: env->mtrr_fixed[9] = msrs[i].data; break; case MSR_MTRRfix4K_F8000: env->mtrr_fixed[10] = msrs[i].data; break; case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1): if (index & 1) { env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data | mtrr_top_bits; } else { env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data; } break; } } return 0; }[Succeeded / Failed / Skipped / Total] 95 / 17 / 73 / 185:   7%|▋         | 185/2690 [25:53<5:50:28,  8.39s/it][Succeeded / Failed / Skipped / Total] 95 / 17 / 73 / 185:   7%|▋         | 186/2690 [25:53<5:48:34,  8.35s/it][Succeeded / Failed / Skipped / Total] 95 / 17 / 74 / 186:   7%|▋         | 186/2690 [25:53<5:48:34,  8.35s/it][Succeeded / Failed / Skipped / Total] 95 / 17 / 74 / 186:   7%|▋         | 187/2690 [26:13<5:51:05,  8.42s/it][Succeeded / Failed / Skipped / Total] 96 / 17 / 74 / 187:   7%|▋         | 187/2690 [26:13<5:51:05,  8.42s/it][Succeeded / Failed / Skipped / Total] 96 / 17 / 74 / 187:   7%|▋         | 188/2690 [26:22<5:51:00,  8.42s/it][Succeeded / Failed / Skipped / Total] 97 / 17 / 74 / 188:   7%|▋         | 188/2690 [26:22<5:51:00,  8.42s/it][Succeeded / Failed / Skipped / Total] 97 / 17 / 74 / 188:   7%|▋         | 189/2690 [26:37<5:52:23,  8.45s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 74 / 189:   7%|▋         | 189/2690 [26:37<5:52:23,  8.45s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 74 / 189:   7%|▋         | 190/2690 [26:38<5:50:31,  8.41s/it]
--------------------------------------------- Result 186 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp) { MemoryRegion *mr; mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp); if (memory_region_is_mapped(mr)) { return "False" != "False"; } else { return "True" == "True"; } }
--------------------------------------------- Result 187 ---------------------------------------------
[[0 (21%)]] --> [[0 (52%)]] --> Socre: 0.5167914628982544

[[[[Adv]]]]: static void do_token_in(USBDevice *s, USBPacket *p) { int [[request]], value, index; assert(p->ep->nr == 0); [[request]] = (s->setup_buf[0] << 8) | s->setup_buf[1]; value = (s->setup_buf[3] << 8) | s->setup_buf[2]; index = (s->setup_buf[5] << 8) | s->setup_buf[4]; switch(s->setup_state) { case SETUP_STATE_ACK: if (!(s->setup_buf[0] & USB_DIR_IN)) { usb_device_handle_control(s, p, [[request]], value, index, s->setup_len, s->data_buf); if (p->status == USB_RET_ASYNC) { return; } s->setup_state = SETUP_STATE_IDLE; p->actual_length = 0; } break; case SETUP_STATE_DATA: if (s->setup_buf[0] & USB_DIR_IN) { int [[len]] = s->setup_len - s->setup_index; if ([[len]] > p->iov.size) { [[len]] = p->iov.size; } usb_packet_copy(p, s->data_buf + s->setup_index, [[len]]); s->setup_index += [[len]]; if (s->setup_index >= s->setup_len) { s->setup_state = SETUP_STATE_ACK; } return; } s->setup_state = SETUP_STATE_IDLE; p->status = USB_RET_STALL; break; default: p->status = USB_RET_STALL; } }

[[[[Adv]]]]: static void do_token_in(USBDevice *s, USBPacket *p) { int [[gift]], value, index; assert(p->ep->nr == 0); [[gift]] = (s->setup_buf[0] << 8) | s->setup_buf[1]; value = (s->setup_buf[3] << 8) | s->setup_buf[2]; index = (s->setup_buf[5] << 8) | s->setup_buf[4]; switch(s->setup_state) { case SETUP_STATE_ACK: if (!(s->setup_buf[0] & USB_DIR_IN)) { usb_device_handle_control(s, p, [[gift]], value, index, s->setup_len, s->data_buf); if (p->status == USB_RET_ASYNC) { return; } s->setup_state = SETUP_STATE_IDLE; p->actual_length = 0; } break; case SETUP_STATE_DATA: if (s->setup_buf[0] & USB_DIR_IN) { int [[meg]] = s->setup_len - s->setup_index; if ([[meg]] > p->iov.size) { [[meg]] = p->iov.size; } usb_packet_copy(p, s->data_buf + s->setup_index, [[meg]]); s->setup_index += [[meg]]; if (s->setup_index >= s->setup_len) { s->setup_state = SETUP_STATE_ACK; } return; } s->setup_state = SETUP_STATE_IDLE; p->status = USB_RET_STALL; break; default: p->status = USB_RET_STALL; } }
--------------------------------------------- Result 188 ---------------------------------------------
[[0 (42%)]] --> [[0 (62%)]] --> Socre: 0.6214430928230286

[[[[Adv]]]]: av_cold int ffv1_init_slice_contexts(FFV1Context *f) { int i; f->slice_count = f->num_h_slices * f->num_v_slices; if (f->slice_count <= 0) { av_log(f->avctx, AV_LOG_ERROR, "Invalid number of slices\n"); return AVERROR(EINVAL); } for (i = 0; i < f->slice_count; i++) { FFV1Context *[[fs]] = av_mallocz(sizeof(*[[fs]])); int sx = i % f->num_h_slices; int sy = i / f->num_h_slices; int sxs = f->avctx->width * sx / f->num_h_slices; int sxe = f->avctx->width * (sx + 1) / f->num_h_slices; int sys = f->avctx->height * sy / f->num_v_slices; int sye = f->avctx->height * (sy + 1) / f->num_v_slices; f->slice_context[i] = [[fs]]; memcpy([[fs]], f, sizeof(*[[fs]])); memset([[fs]]->rc_stat2, 0, sizeof([[fs]]->rc_stat2)); [[fs]]->slice_width = sxe - sxs; [[fs]]->slice_height = sye - sys; [[fs]]->slice_x = sxs; [[fs]]->slice_y = sys; [[fs]]->sample_buffer = av_malloc(3 * MAX_PLANES * ([[fs]]->width + 6) * sizeof(*[[fs]]->sample_buffer)); if (![[fs]]->sample_buffer) return AVERROR(ENOMEM); } return 0; }

[[[[Adv]]]]: av_cold int ffv1_init_slice_contexts(FFV1Context *f) { int i; f->slice_count = f->num_h_slices * f->num_v_slices; if (f->slice_count <= 0) { av_log(f->avctx, AV_LOG_ERROR, "Invalid number of slices\n"); return AVERROR(EINVAL); } for (i = 0; i < f->slice_count; i++) { FFV1Context *[[paynesw]] = av_mallocz(sizeof(*[[paynesw]])); int sx = i % f->num_h_slices; int sy = i / f->num_h_slices; int sxs = f->avctx->width * sx / f->num_h_slices; int sxe = f->avctx->width * (sx + 1) / f->num_h_slices; int sys = f->avctx->height * sy / f->num_v_slices; int sye = f->avctx->height * (sy + 1) / f->num_v_slices; f->slice_context[i] = [[paynesw]]; memcpy([[paynesw]], f, sizeof(*[[paynesw]])); memset([[paynesw]]->rc_stat2, 0, sizeof([[paynesw]]->rc_stat2)); [[paynesw]]->slice_width = sxe - sxs; [[paynesw]]->slice_height = sye - sys; [[paynesw]]->slice_x = sxs; [[paynesw]]->slice_y = sys; [[paynesw]]->sample_buffer = av_malloc(3 * MAX_PLANES * ([[paynesw]]->width + 6) * sizeof(*[[paynesw]]->sample_buffer)); if (![[paynesw]]->sample_buffer) return AVERROR(ENOMEM); } return 0; }
--------------------------------------------- Result 189 ---------------------------------------------
[[0 (69%)]] --> [[0 (47%)]] --> Socre: 0.5318968296051025

[[[[Adv]]]]: void ff_rtsp_undo_setup(AVFormatContext *[[s]], int [[send_packets]]) { RTSPState *[[rt]] = [[s]]->priv_data; int [[i]]; for ([[i]] = 0; [[i]] < [[rt]]->nb_rtsp_streams; [[i]]++) { RTSPStream *rtsp_st = [[rt]]->rtsp_streams[[[i]]]; if (!rtsp_st) continue; if (rtsp_st->transport_priv) { if ([[s]]->oformat) { AVFormatContext *rtpctx = rtsp_st->transport_priv; av_write_trailer(rtpctx); if ([[rt]]->lower_transport == RTSP_LOWER_TRANSPORT_TCP) { uint8_t *[[ptr]]; if (CONFIG_RTSP_MUXER && rtpctx->pb && [[send_packets]]) ff_rtsp_tcp_write_packet([[s]], rtsp_st); avio_close_dyn_buf(rtpctx->pb, &[[ptr]]); av_free([[ptr]]); } else { avio_close(rtpctx->pb); } avformat_free_context(rtpctx); } else if ([[rt]]->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st->transport_priv); else if ([[rt]]->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC) ff_rtp_parse_close(rtsp_st->transport_priv); } rtsp_st->transport_priv = NULL; if (rtsp_st->rtp_handle) ffurl_close(rtsp_st->rtp_handle); rtsp_st->rtp_handle = NULL; } }

[[[[Adv]]]]: void ff_rtsp_undo_setup(AVFormatContext *[[sb]], int [[tellableflows]]) { RTSPState *[[rv]] = [[sb]]->priv_data; int [[bit]]; for ([[bit]] = 0; [[bit]] < [[rv]]->nb_rtsp_streams; [[bit]]++) { RTSPStream *rtsp_st = [[rv]]->rtsp_streams[[[bit]]]; if (!rtsp_st) continue; if (rtsp_st->transport_priv) { if ([[sb]]->oformat) { AVFormatContext *rtpctx = rtsp_st->transport_priv; av_write_trailer(rtpctx); if ([[rv]]->lower_transport == RTSP_LOWER_TRANSPORT_TCP) { uint8_t *[[lat]]; if (CONFIG_RTSP_MUXER && rtpctx->pb && [[tellableflows]]) ff_rtsp_tcp_write_packet([[sb]], rtsp_st); avio_close_dyn_buf(rtpctx->pb, &[[lat]]); av_free([[lat]]); } else { avio_close(rtpctx->pb); } avformat_free_context(rtpctx); } else if ([[rv]]->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st->transport_priv); else if ([[rv]]->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC) ff_rtp_parse_close(rtsp_st->transport_priv); } rtsp_st->transport_priv = NULL; if (rtsp_st->rtp_handle) ffurl_close(rtsp_st->rtp_handle); rtsp_st->rtp_handle = NULL; } }
--------------------------------------------- Result 190 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 17 / 75 / 190:   7%|▋         | 190/2690 [26:38<5:50:31,  8.41s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 75 / 190:   7%|▋         | 191/2690 [26:38<5:48:39,  8.37s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 76 / 191:   7%|▋         | 191/2690 [26:38<5:48:39,  8.37s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 76 / 191:   7%|▋         | 192/2690 [26:39<5:46:48,  8.33s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 77 / 192:   7%|▋         | 192/2690 [26:39<5:46:48,  8.33s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 77 / 192:   7%|▋         | 193/2690 [26:39<5:44:59,  8.29s/it][[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void print_report(AVFormatContext **output_files, AVOutputStream **ost_table, int nb_ostreams, int is_last_report) { char buf[1024]; AVOutputStream *ost; AVFormatContext *oc; int64_t total_size; AVCodecContext *enc; int frame_number, vid, i; double bitrate, ti1, pts; static int64_t last_time = -1; static int qp_histogram[52]; if (!is_last_report) { int64_t cur_time; cur_time = av_gettime(); if (last_time == -1) { last_time = cur_time; return; } if ((cur_time - last_time) < 500000) return; last_time = cur_time; } oc = output_files[0]; total_size = avio_size(oc->pb); if(total_size<0) total_size= avio_tell(oc->pb); buf[0] = '\0'; ti1 = 1e10; vid = 0; for(i=0;i<nb_ostreams;i++) { float q= -1; ost = ost_table[i]; enc = ost->st->codec; if(!ost->st->stream_copy && enc->coded_frame) q= enc->coded_frame->quality/(float)FF_QP2LAMBDA; if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) { snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q); } if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) { float t = (av_gettime()-timer_start) / 1000000.0; frame_number = ost->frame_number; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ", frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q); if(is_last_report) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L"); if(qp_hist){ int j; int qp= lrintf(q); if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram)) qp_histogram[qp]++; for(j=0; j<32; j++) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log(qp_histogram[j]+1)/log(2))); } if (enc->flags&CODEC_FLAG_PSNR){ int j; double error, error_sum=0; double scale, scale_sum=0; char type[3]= {'Y','U','V'}; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR="); for(j=0; j<3; j++){ if(is_last_report){ error= enc->error[j]; scale= enc->width*enc->height*255.0*255.0*frame_number; }else{ error= enc->coded_frame->error[j]; scale= enc->width*enc->height*255.0*255.0; } if(j) scale/=4; error_sum += error; scale_sum += scale; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[j], psnr(error/scale)); } snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum/scale_sum)); } vid = 1; } pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base); if ((pts < ti1) && (pts > 0)) ti1 = pts; } if (ti1 < 0.01) ti1 = 0.01; if (verbose || is_last_report) { bitrate = (double)(total_size * 8) / ti1 / 1000.0; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s", (double)total_size / 1024, ti1, bitrate); if (nb_frames_dup || nb_frames_drop) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d", nb_frames_dup, nb_frames_drop); if (verbose >= 0) fprintf(stderr, "%s \r", buf); fflush(stderr); } if (is_last_report && verbose >= 0){ int64_t raw= audio_size + video_size + extra_size; fprintf(stderr, "\n"); fprintf(stderr, "video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n", video_size/1024.0, audio_size/1024.0, extra_size/1024.0, 100.0*(total_size - raw)/raw ); } }
--------------------------------------------- Result 191 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline void rv40_strong_loop_filter(uint8_t *src, const int step, const int stride, const int alpha, const int lims, const int dmode, const int chroma) { int i; for(i = 0; i < 4; i++, src += stride){ int sflag, p0, q0, p1, q1; int t = src[0*step] - src[-1*step]; if (!t) continue; sflag = (alpha * FFABS(t)) >> 7; if (sflag > 1) continue; p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] + 25*src[ 1*step] + rv40_dither_l[dmode + i]) >> 7; q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] + 26*src[ 1*step] + 25*src[ 2*step] + rv40_dither_r[dmode + i]) >> 7; if (sflag) { p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims); q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims); } p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 + 25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7; q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] + 25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7; if (sflag) { p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims); q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims); } src[-2*step] = p1; src[-1*step] = p0; src[ 0*step] = q0; src[ 1*step] = q1; if(!chroma){ src[-3*step] = (25*src[-1*step] + 26*src[-2*step] + 51*src[-3*step] + 26*src[-4*step] + 64) >> 7; src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] + 51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7; } } }
--------------------------------------------- Result 192 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts, Error **errp) { DeviceClass *dc; const char *driver, *path; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) { error_setg(errp, QERR_MISSING_PARAMETER, "driver"); return NULL; } dc = qdev_get_device_class(&driver, errp); if (!dc) { return NULL; } path = qemu_opt_get(opts, "bus"); if (path != NULL) { bus = qbus_find(path, errp); if (!bus) { return NULL; } if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) { error_setg(errp, "Device '%s' can't go on %s bus", driver, object_get_typename(OBJECT(bus))); return NULL; } } else if (dc->bus_type != NULL) { bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type); if (!bus || qbus_is_full(bus)) { error_setg(errp, "No '%s' bus found for device '%s'", dc->bus_type, driver); return NULL; } } if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) { error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name); return NULL; } if (!migration_is_idle()) { error_setg(errp, "device_add not allowed while migrating"); return NULL; } dev = DEVICE(object_new(driver)); if (bus) { qdev_set_parent_bus(dev, bus); } qdev_set_id(dev, qemu_opts_id(opts)); if (qemu_opt_foreach(opts, set_property, dev, &err)) { } dev->opts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) { dev->opts = NULL; } return dev; err_del_dev: error_propagate(errp, err); object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; }
--------------------------------------------- Result 193 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 17 / 78 / 193:   7%|▋         | 193/2690 [26:39<5:44:59,  8.29s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 78 / 193:   7%|▋         | 194/2690 [26:51<5:45:28,  8.30s/it][Succeeded / Failed / Skipped / Total] 99 / 17 / 78 / 194:   7%|▋         | 194/2690 [26:51<5:45:28,  8.30s/it][Succeeded / Failed / Skipped / Total] 99 / 17 / 78 / 194:   7%|▋         | 195/2690 [26:59<5:45:15,  8.30s/it][Succeeded / Failed / Skipped / Total] 100 / 17 / 78 / 195:   7%|▋         | 195/2690 [26:59<5:45:15,  8.30s/it][Succeeded / Failed / Skipped / Total] 100 / 17 / 78 / 195:   7%|▋         | 196/2690 [26:59<5:43:27,  8.26s/it][Succeeded / Failed / Skipped / Total] 100 / 17 / 79 / 196:   7%|▋         | 196/2690 [26:59<5:43:27,  8.26s/it][Succeeded / Failed / Skipped / Total] 100 / 17 / 79 / 196:   7%|▋         | 197/2690 [27:00<5:41:41,  8.22s/it][[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf, int buf_size, int buf_size2) { RVDecContext *rv = avctx->priv_data; MpegEncContext *s = &rv->m; int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret; active_bits_size = buf_size * 8; init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8); if (s->codec_id == AV_CODEC_ID_RV10) mb_count = rv10_decode_picture_header(s); else mb_count = rv20_decode_picture_header(rv); if (mb_count < 0) { av_log(s->avctx, AV_LOG_ERROR, "HEADER ERROR\n"); return AVERROR_INVALIDDATA; } if (s->mb_x >= s->mb_width || s->mb_y >= s->mb_height) { av_log(s->avctx, AV_LOG_ERROR, "POS ERROR %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } mb_pos = s->mb_y * s->mb_width + s->mb_x; left = s->mb_width * s->mb_height - mb_pos; if (mb_count > left) { av_log(s->avctx, AV_LOG_ERROR, "COUNT ERROR\n"); return AVERROR_INVALIDDATA; } if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) { if (s->current_picture_ptr) { ff_er_frame_end(&s->er); ff_MPV_frame_end(s); s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0; } if ((ret = ff_MPV_frame_start(s, avctx)) < 0) return ret; ff_mpeg_er_frame_start(s); } else { if (s->current_picture_ptr->f.pict_type != s->pict_type) { av_log(s->avctx, AV_LOG_ERROR, "Slice type mismatch\n"); return AVERROR_INVALIDDATA; } } av_dlog(avctx, "qscale=%d\n", s->qscale); if (s->codec_id == AV_CODEC_ID_RV10) { if (s->mb_y == 0) s->first_slice_line = 1; } else { s->first_slice_line = 1; s->resync_mb_x = s->mb_x; } start_mb_x = s->mb_x; s->resync_mb_y = s->mb_y; if (s->h263_aic) { s->y_dc_scale_table = s->c_dc_scale_table = ff_aic_dc_scale_table; } else { s->y_dc_scale_table = s->c_dc_scale_table = ff_mpeg1_dc_scale_table; } if (s->modified_quant) s->chroma_qscale_table = ff_h263_chroma_qscale_table; ff_set_qscale(s, s->qscale); s->rv10_first_dc_coded[0] = 0; s->rv10_first_dc_coded[1] = 0; s->rv10_first_dc_coded[2] = 0; s->block_wrap[0] = s->block_wrap[1] = s->block_wrap[2] = s->block_wrap[3] = s->b8_stride; s->block_wrap[4] = s->block_wrap[5] = s->mb_stride; ff_init_block_index(s); for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) { int ret; ff_update_block_index(s); av_dlog(avctx, "**mb x=%d y=%d\n", s->mb_x, s->mb_y); s->mv_dir = MV_DIR_FORWARD; s->mv_type = MV_TYPE_16X16; ret = ff_h263_decode_mb(s, s->block); if (ret != SLICE_ERROR) { int v = show_bits(&s->gb, 16); if (get_bits_count(&s->gb) + 16 > active_bits_size) v >>= get_bits_count(&s->gb) + 16 - active_bits_size; if (!v) ret = SLICE_END; } if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) && 8 * buf_size2 >= get_bits_count(&s->gb)) { active_bits_size = buf_size2 * 8; av_log(avctx, AV_LOG_DEBUG, "update size from %d to %d\n", 8 * buf_size, active_bits_size); ret = SLICE_OK; } if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) { av_log(s->avctx, AV_LOG_ERROR, "ERROR at MB %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } if (s->pict_type != AV_PICTURE_TYPE_B) ff_h263_update_motion_val(s); ff_MPV_decode_mb(s, s->block); if (s->loop_filter) ff_h263_loop_filter(s); if (++s->mb_x == s->mb_width) { s->mb_x = 0; s->mb_y++; ff_init_block_index(s); } if (s->mb_x == s->resync_mb_x) s->first_slice_line = 0; if (ret == SLICE_END) break; } ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y, ER_MB_END); return active_bits_size; }
--------------------------------------------- Result 194 ---------------------------------------------
[[0 (38%)]] --> [[0 (97%)]] --> Socre: 0.9677069187164307

[[[[Adv]]]]: static void predictor_decode_mono(APEContext *[[ctx]], int count) { APEPredictor *p = &[[ctx]]->predictor; int32_t *decoded0 = [[ctx]]->decoded[0]; int32_t predictionA, currentA, A, sign; currentA = p->lastA[0]; while (count--) { A = *decoded0; p->buf[YDELAYA] = currentA; p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1]; predictionA = p->buf[YDELAYA ] * p->coeffsA[0][0] + p->buf[YDELAYA - 1] * p->coeffsA[0][1] + p->buf[YDELAYA - 2] * p->coeffsA[0][2] + p->buf[YDELAYA - 3] * p->coeffsA[0][3]; currentA = A + (predictionA >> 10); p->buf[YADAPTCOEFFSA] = APESIGN(p->buf[YDELAYA ]); p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]); sign = APESIGN(A); p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA ] * sign; p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign; p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign; p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign; p->buf++; if (p->buf == p->historybuffer + HISTORY_SIZE) { memmove(p->historybuffer, p->buf, PREDICTOR_SIZE * sizeof(*p->historybuffer)); p->buf = p->historybuffer; } p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5); *(decoded0++) = p->filterA[0]; } p->lastA[0] = currentA; }

[[[[Adv]]]]: static void predictor_decode_mono(APEContext *[[ukp]], int count) { APEPredictor *p = &[[ukp]]->predictor; int32_t *decoded0 = [[ukp]]->decoded[0]; int32_t predictionA, currentA, A, sign; currentA = p->lastA[0]; while (count--) { A = *decoded0; p->buf[YDELAYA] = currentA; p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1]; predictionA = p->buf[YDELAYA ] * p->coeffsA[0][0] + p->buf[YDELAYA - 1] * p->coeffsA[0][1] + p->buf[YDELAYA - 2] * p->coeffsA[0][2] + p->buf[YDELAYA - 3] * p->coeffsA[0][3]; currentA = A + (predictionA >> 10); p->buf[YADAPTCOEFFSA] = APESIGN(p->buf[YDELAYA ]); p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]); sign = APESIGN(A); p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA ] * sign; p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign; p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign; p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign; p->buf++; if (p->buf == p->historybuffer + HISTORY_SIZE) { memmove(p->historybuffer, p->buf, PREDICTOR_SIZE * sizeof(*p->historybuffer)); p->buf = p->historybuffer; } p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5); *(decoded0++) = p->filterA[0]; } p->lastA[0] = currentA; }
--------------------------------------------- Result 195 ---------------------------------------------
[[0 (57%)]] --> [[0 (11%)]] --> Socre: 0.8918461427092552

[[[[Adv]]]]: static inline int cpu_gdb_index(CPUState *[[cpu]]) { #if defined(CONFIG_USER_ONLY) return [[cpu]]->host_tid; #else return [[cpu]]->cpu_index + 1; #endif }

[[[[Adv]]]]: static inline int cpu_gdb_index(CPUState *[[clock]]) { #if defined(CONFIG_USER_ONLY) return [[clock]]->host_tid; #else return [[clock]]->cpu_index + 1; #endif }
--------------------------------------------- Result 196 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void hmp_info_block_jobs(Monitor *mon, const QDict *qdict) { BlockJobInfoList *list; Error *err = NULL; list = qmp_query_block_jobs(&err); assert(!err); if (!list) { monitor_printf(mon, "No active jobs\n"); return; } while (list) { if (strcmp(list->value->type, "stream") == 0) { monitor_printf(mon, "Streaming device %s: Completed %" PRId64 " of %" PRId64 " bytes, speed limit %" PRId64 " bytes/s\n", list->value->device, list->value->offset, list->value->len, list->value->speed); } else { monitor_printf(mon, "Type %s, device %s: Completed %" PRId64 " of %" PRId64 " bytes, speed limit %" PRId64 " bytes/s\n", list->value->type, list->value->device, list->value->offset, list->value->len, list->value->speed); } list = list->next; } }
--------------------------------------------- Result 197 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 100 / 17 / 80 / 197:   7%|▋         | 197/2690 [27:00<5:41:41,  8.22s/it][Succeeded / Failed / Skipped / Total] 100 / 17 / 80 / 197:   7%|▋         | 198/2690 [27:37<5:47:43,  8.37s/it][Succeeded / Failed / Skipped / Total] 101 / 17 / 80 / 198:   7%|▋         | 198/2690 [27:37<5:47:43,  8.37s/it][Succeeded / Failed / Skipped / Total] 101 / 17 / 80 / 198:   7%|▋         | 199/2690 [27:53<5:49:11,  8.41s/it][Succeeded / Failed / Skipped / Total] 101 / 18 / 80 / 199:   7%|▋         | 199/2690 [27:53<5:49:11,  8.41s/it][Succeeded / Failed / Skipped / Total] 101 / 18 / 80 / 199:   7%|▋         | 200/2690 [27:59<5:48:29,  8.40s/it][Succeeded / Failed / Skipped / Total] 102 / 18 / 80 / 200:   7%|▋         | 200/2690 [27:59<5:48:29,  8.40s/it][Succeeded / Failed / Skipped / Total] 102 / 18 / 80 / 200:   7%|▋         | 201/2690 [28:00<5:46:43,  8.36s/it][[0 (89%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; TrimContext *s = ctx->priv; int64_t start_sample, end_sample = frame->nb_samples; int64_t pts; int drop; if (s->eof) { av_frame_free(&frame); return 0; } if (frame->pts != AV_NOPTS_VALUE) pts = av_rescale_q(frame->pts, inlink->time_base, (AVRational){ 1, inlink->sample_rate }); else pts = s->next_pts; s->next_pts = pts + frame->nb_samples; if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) { start_sample = 0; } else { drop = 1; start_sample = frame->nb_samples; if (s->start_sample >= 0 && s->nb_samples + frame->nb_samples > s->start_sample) { drop = 0; start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples); } if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE && pts + frame->nb_samples > s->start_pts) { drop = 0; start_sample = FFMIN(start_sample, s->start_pts - pts); } if (drop) goto drop; } if (s->first_pts == AV_NOPTS_VALUE) s->first_pts = pts + start_sample; if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) { end_sample = frame->nb_samples; } else { drop = 1; end_sample = 0; if (s->end_sample != INT64_MAX && s->nb_samples < s->end_sample) { drop = 0; end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples); } if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE && pts < s->end_pts) { drop = 0; end_sample = FFMAX(end_sample, s->end_pts - pts); } if (s->duration_tb && pts - s->first_pts < s->duration_tb) { drop = 0; end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts); } if (drop) { s->eof = 1; goto drop; } } s->nb_samples += frame->nb_samples; start_sample = FFMAX(0, start_sample); end_sample = FFMIN(frame->nb_samples, end_sample); av_assert0(start_sample < end_sample); if (start_sample) { AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample); if (!out) { av_frame_free(&frame); return AVERROR(ENOMEM); } av_frame_copy_props(out, frame); av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample, out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout), frame->format); if (out->pts != AV_NOPTS_VALUE) out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate }, inlink->time_base); av_frame_free(&frame); frame = out; } else frame->nb_samples = end_sample; s->got_output = 1; return ff_filter_frame(ctx->outputs[0], frame); drop: s->nb_samples += frame->nb_samples; av_frame_free(&frame); return 0; }
--------------------------------------------- Result 198 ---------------------------------------------
[[0 (96%)]] --> [[0 (41%)]] --> Socre: 0.5863648653030396

[[[[Adv]]]]: static inline int *DEC_UQUAD(int *dst, unsigned [[idx]], unsigned [[sign]]) { unsigned nz = [[idx]] >> 12; dst[0] = ([[idx]] & 3) * (1 + (((int)[[sign]] >> 31) << 1)); [[sign]] <<= nz & 1; nz >>= 1; dst[1] = ([[idx]] >> 2 & 3) * (1 + (((int)[[sign]] >> 31) << 1)); [[sign]] <<= nz & 1; nz >>= 1; dst[2] = ([[idx]] >> 4 & 3) * (1 + (((int)[[sign]] >> 31) << 1)); [[sign]] <<= nz & 1; nz >>= 1; dst[3] = ([[idx]] >> 6 & 3) * (1 + (((int)[[sign]] >> 31) << 1)); return dst + 4; }

[[[[Adv]]]]: static inline int *DEC_UQUAD(int *dst, unsigned [[mark5]], unsigned [[artist]]) { unsigned nz = [[mark5]] >> 12; dst[0] = ([[mark5]] & 3) * (1 + (((int)[[artist]] >> 31) << 1)); [[artist]] <<= nz & 1; nz >>= 1; dst[1] = ([[mark5]] >> 2 & 3) * (1 + (((int)[[artist]] >> 31) << 1)); [[artist]] <<= nz & 1; nz >>= 1; dst[2] = ([[mark5]] >> 4 & 3) * (1 + (((int)[[artist]] >> 31) << 1)); [[artist]] <<= nz & 1; nz >>= 1; dst[3] = ([[mark5]] >> 6 & 3) * (1 + (((int)[[artist]] >> 31) << 1)); return dst + 4; }
--------------------------------------------- Result 199 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void omap_pwt_write(void *[[opaque]], target_phys_addr_t [[addr]], uint64_t [[value]], unsigned size) { struct omap_pwt_s *[[s]] = (struct omap_pwt_s *) [[opaque]]; int [[offset]] = [[addr]] & OMAP_MPUI_REG_MASK; if (size != 1) { return omap_badwidth_write8([[opaque]], [[addr]], [[value]]); } switch ([[offset]]) { case 0x00: [[s]]->frc = [[value]] & 0x3f; break; case 0x04: if (([[value]] ^ [[s]]->vrc) & 1) { if ([[value]] & 1) printf("%s: %iHz buzz on\n", __FUNCTION__, (int) ((omap_clk_getrate([[s]]->clk) >> 3) / (([[s]]->gcr & 2) ? 1 : 154) / (2 << ([[value]] & 3)) * (([[value]] & (1 << 2)) ? 101 : 107) * (([[value]] & (1 << 3)) ? 49 : 55) * (([[value]] & (1 << 4)) ? 50 : 63) * (([[value]] & (1 << 5)) ? 80 : 127) / (107 * 55 * 63 * 127))); else printf("%s: silence!\n", __FUNCTION__); } [[s]]->vrc = [[value]] & 0x7f; break; case 0x08: [[s]]->gcr = [[value]] & 3; break; default: OMAP_BAD_REG([[addr]]); return; } }

[[[[Adv]]]]: static void omap_pwt_write(void *[[enclave]], target_phys_addr_t [[indρ]], uint64_t [[object]], unsigned size) { struct omap_pwt_s *[[cover]] = (struct omap_pwt_s *) [[enclave]]; int [[angle]] = [[indρ]] & OMAP_MPUI_REG_MASK; if (size != 1) { return omap_badwidth_write8([[enclave]], [[indρ]], [[object]]); } switch ([[angle]]) { case 0x00: [[cover]]->frc = [[object]] & 0x3f; break; case 0x04: if (([[object]] ^ [[cover]]->vrc) & 1) { if ([[object]] & 1) printf("%s: %iHz buzz on\n", __FUNCTION__, (int) ((omap_clk_getrate([[cover]]->clk) >> 3) / (([[cover]]->gcr & 2) ? 1 : 154) / (2 << ([[object]] & 3)) * (([[object]] & (1 << 2)) ? 101 : 107) * (([[object]] & (1 << 3)) ? 49 : 55) * (([[object]] & (1 << 4)) ? 50 : 63) * (([[object]] & (1 << 5)) ? 80 : 127) / (107 * 55 * 63 * 127))); else printf("%s: silence!\n", __FUNCTION__); } [[cover]]->vrc = [[object]] & 0x7f; break; case 0x08: [[cover]]->gcr = [[object]] & 3; break; default: OMAP_BAD_REG([[indρ]]); return; } }
--------------------------------------------- Result 200 ---------------------------------------------
[[0 (20%)]] --> [[0 (98%)]] --> Socre: 0.9848918914794922

[[[[Adv]]]]: static void curl_multi_do(void *arg) { BDRVCURLState *[[s]] = (BDRVCURLState *)arg; int running; int r; if (![[s]]->multi) { return; } do { r = curl_multi_socket_all([[s]]->multi, &running); } while(r == CURLM_CALL_MULTI_PERFORM); curl_multi_read([[s]]); }

[[[[Adv]]]]: static void curl_multi_do(void *arg) { BDRVCURLState *[[с]] = (BDRVCURLState *)arg; int running; int r; if (![[с]]->multi) { return; } do { r = curl_multi_socket_all([[с]]->multi, &running); } while(r == CURLM_CALL_MULTI_PERFORM); curl_multi_read([[с]]); }
--------------------------------------------- Result 201 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_opc(MoxieCPU *cpu, DisasContext *ctx) { CPUMoxieState *env = &cpu->env; int opcode; int length = 2; if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) { tcg_gen_debug_insn_start(ctx->pc); } opcode = ctx->opcode; if (opcode & (1 << 15)) { if (opcode & (1 << 14)) { int inst = (opcode >> 10 & 0xf); #define BRANCH(cond) \ do { \ int l1 = gen_new_label(); \ tcg_gen_brcond_i32(cond, cc_a, cc_b, l1); \ gen_goto_tb(env, ctx, 1, ctx->pc+2); \ gen_set_label(l1); \ gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \ ctx->bstate = BS_BRANCH; \ } while (0) switch (inst) { case 0x00: BRANCH(TCG_COND_EQ); break; case 0x01: BRANCH(TCG_COND_NE); break; case 0x02: BRANCH(TCG_COND_LT); break; case 0x03: BRANCH(TCG_COND_GT); break; case 0x04: BRANCH(TCG_COND_LTU); break; case 0x05: BRANCH(TCG_COND_GTU); break; case 0x06: BRANCH(TCG_COND_GE); break; case 0x07: BRANCH(TCG_COND_LE); break; case 0x08: BRANCH(TCG_COND_GEU); break; case 0x09: BRANCH(TCG_COND_LEU); break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } else { int inst = (opcode >> 12 & 0x3); switch (inst) { case 0x00: { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcg_gen_addi_i32(REG(a), REG(a), v); } break; case 0x01: { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcg_gen_subi_i32(REG(a), REG(a), v); } break; case 0x02: { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcg_gen_ld_i32(REG(a), cpu_env, offsetof(CPUMoxieState, sregs[v])); } break; case 0x03: { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcg_gen_st_i32(REG(a), cpu_env, offsetof(CPUMoxieState, sregs[v])); } break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } } else { int inst = opcode >> 8; switch (inst) { case 0x00: break; case 0x01: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); length = 6; } break; case 0x02: { int dest = (opcode >> 4) & 0xf; int src = opcode & 0xf; tcg_gen_mov_i32(REG(dest), REG(src)); } break; case 0x03: { TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_movi_i32(t1, ctx->pc + 6); tcg_gen_subi_i32(t2, REG(1), 8); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(t1, REG(1), ctx->memidx); tcg_gen_subi_i32(t2, REG(1), 4); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx); tcg_gen_mov_i32(REG(0), REG(1)); gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2)); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); ctx->bstate = BS_BRANCH; length = 6; } break; case 0x04: { TCGv t1 = tcg_temp_new_i32(); tcg_gen_mov_i32(REG(1), REG(0)); tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx); tcg_gen_addi_i32(t1, REG(1), 4); tcg_gen_mov_i32(REG(1), t1); tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx); tcg_gen_addi_i32(t1, REG(1), 8); tcg_gen_mov_i32(REG(1), t1); tcg_temp_free_i32(t1); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x05: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_add_i32(REG(a), REG(a), REG(b)); } break; case 0x06: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); tcg_gen_subi_i32(t1, REG(a), 4); tcg_gen_mov_i32(REG(a), t1); tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx); tcg_temp_free_i32(t1); } break; case 0x07: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx); tcg_gen_addi_i32(t1, REG(a), 4); tcg_gen_mov_i32(REG(a), t1); tcg_temp_free_i32(t1); } break; case 0x08: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x09: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x0a: { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx); } break; case 0x0b: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx); } break; case 0x0c: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld32u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x0d: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st32(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x0e: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_mov_i32(cc_a, REG(a)); tcg_gen_mov_i32(cc_b, REG(b)); } break; case 0x19: { int fnreg = (opcode >> 4) & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_movi_i32(t1, ctx->pc+2); tcg_gen_subi_i32(t2, REG(1), 8); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(t1, REG(1), ctx->memidx); tcg_gen_subi_i32(t2, REG(1), 4); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx); tcg_gen_mov_i32(REG(0), REG(1)); tcg_gen_mov_i32(cpu_pc, REG(fnreg)); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x1a: { tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; length = 6; } break; case 0x1b: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); length = 6; } break; case 0x1c: { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx); } break; case 0x1d: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x1e: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx); } break; case 0x1f: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x20: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); length = 6; } break; case 0x21: { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx); } break; case 0x22: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x23: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx); } break; case 0x24: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x25: { int reg = (opcode >> 4) & 0xf; tcg_gen_mov_i32(cpu_pc, REG(reg)); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x26: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_and_i32(REG(a), REG(a), REG(b)); } break; case 0x27: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_shr_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x28: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_shl_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x29: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_sub_i32(REG(a), REG(a), REG(b)); } break; case 0x2a: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_neg_i32(REG(a), REG(b)); } break; case 0x2b: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_or_i32(REG(a), REG(a), REG(b)); } break; case 0x2c: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_not_i32(REG(a), REG(b)); } break; case 0x2d: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_sar_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x2e: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_xor_i32(REG(a), REG(a), REG(b)); } break; case 0x2f: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_mul_i32(REG(a), REG(a), REG(b)); } break; case 0x30: { int val = cpu_ldl_code(env, ctx->pc+2); TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(temp, val); tcg_gen_st_i32(temp, cpu_env, offsetof(CPUMoxieState, sregs[3])); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_SWI); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); length = 6; } break; case 0x31: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_movi_i32(cpu_pc, ctx->pc); gen_helper_div(REG(a), cpu_env, REG(a), REG(b)); } break; case 0x32: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_movi_i32(cpu_pc, ctx->pc); gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b)); } break; case 0x33: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_rem_i32(REG(a), REG(a), REG(b)); } break; case 0x34: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_remu_i32(REG(a), REG(a), REG(b)); } break; case 0x35: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BREAK); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; case 0x36: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld8u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x37: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st8(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x38: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld16u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x39: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st16(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } return length; }[Succeeded / Failed / Skipped / Total] 102 / 18 / 81 / 201:   7%|▋         | 201/2690 [28:00<5:46:43,  8.36s/it][Succeeded / Failed / Skipped / Total] 102 / 18 / 81 / 201:   8%|▊         | 202/2690 [28:15<5:47:57,  8.39s/it][Succeeded / Failed / Skipped / Total] 103 / 18 / 81 / 202:   8%|▊         | 202/2690 [28:15<5:47:57,  8.39s/it][Succeeded / Failed / Skipped / Total] 103 / 18 / 81 / 202:   8%|▊         | 203/2690 [28:24<5:48:07,  8.40s/it][Succeeded / Failed / Skipped / Total] 104 / 18 / 81 / 203:   8%|▊         | 203/2690 [28:24<5:48:07,  8.40s/it][Succeeded / Failed / Skipped / Total] 104 / 18 / 81 / 203:   8%|▊         | 204/2690 [28:26<5:46:30,  8.36s/it]
--------------------------------------------- Result 202 ---------------------------------------------
[[0 (10%)]] --> [[0 (56%)]] --> Socre: 0.5630673170089722

[[[[Adv]]]]: static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int [[nb_iargs]], const TCGArg * const args, uint16_t [[dead_args]], uint8_t sync_args) { int flags, nb_regs, i; TCGReg reg; TCGArg [[arg]]; TCGTemp *ts; intptr_t stack_offset; size_t call_stack_size; tcg_insn_unit *[[func_addr]]; int allocate_args; TCGRegSet allocated_regs; [[func_addr]] = (tcg_insn_unit *)(intptr_t)args[nb_oargs + [[nb_iargs]]]; flags = args[nb_oargs + [[nb_iargs]] + 1]; nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs); if (nb_regs > [[nb_iargs]]) { nb_regs = [[nb_iargs]]; } call_stack_size = ([[nb_iargs]] - nb_regs) * sizeof(tcg_target_long); call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & ~(TCG_TARGET_STACK_ALIGN - 1); allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE); if (allocate_args) { tcg_abort(); } stack_offset = TCG_TARGET_CALL_STACK_OFFSET; for(i = nb_regs; i < [[nb_iargs]]; i++) { [[arg]] = args[nb_oargs + i]; #ifdef TCG_TARGET_STACK_GROWSUP stack_offset -= sizeof(tcg_target_long); #endif if ([[arg]] != TCG_CALL_DUMMY_ARG) { ts = &s->temps[[[arg]]]; temp_load(s, ts, tcg_target_available_regs[ts->type], s->reserved_regs); tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset); } #ifndef TCG_TARGET_STACK_GROWSUP stack_offset += sizeof(tcg_target_long); #endif } tcg_regset_set(allocated_regs, s->reserved_regs); for(i = 0; i < nb_regs; i++) { [[arg]] = args[nb_oargs + i]; if ([[arg]] != TCG_CALL_DUMMY_ARG) { ts = &s->temps[[[arg]]]; reg = tcg_target_call_iarg_regs[i]; tcg_reg_free(s, reg, allocated_regs); if (ts->val_type == TEMP_VAL_REG) { if (ts->reg != reg) { tcg_out_mov(s, ts->type, reg, ts->reg); } } else { TCGRegSet arg_set; tcg_regset_clear(arg_set); tcg_regset_set_reg(arg_set, reg); temp_load(s, ts, arg_set, allocated_regs); } tcg_regset_set_reg(allocated_regs, reg); } } for(i = nb_oargs; i < [[nb_iargs]] + nb_oargs; i++) { if (IS_DEAD_ARG(i)) { temp_dead(s, &s->temps[args[i]]); } } for (i = 0; i < TCG_TARGET_NB_REGS; i++) { if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) { tcg_reg_free(s, i, allocated_regs); } } if (flags & TCG_CALL_NO_READ_GLOBALS) { } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) { sync_globals(s, allocated_regs); } else { save_globals(s, allocated_regs); } tcg_out_call(s, [[func_addr]]); for(i = 0; i < nb_oargs; i++) { [[arg]] = args[i]; ts = &s->temps[[[arg]]]; reg = tcg_target_call_oarg_regs[i]; assert(s->reg_to_temp[reg] == NULL); if (ts->fixed_reg) { if (ts->reg != reg) { tcg_out_mov(s, ts->type, ts->reg, reg); } } else { if (ts->val_type == TEMP_VAL_REG) { s->reg_to_temp[ts->reg] = NULL; } ts->val_type = TEMP_VAL_REG; ts->reg = reg; ts->mem_coherent = 0; s->reg_to_temp[reg] = ts; if (NEED_SYNC_ARG(i)) { tcg_reg_sync(s, reg, allocated_regs); } if (IS_DEAD_ARG(i)) { temp_dead(s, ts); } } } }

[[[[Adv]]]]: static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int [[нd16aimgms]], const TCGArg * const args, uint16_t [[yrarannaggles]], uint8_t sync_args) { int flags, nb_regs, i; TCGReg reg; TCGArg [[amarग]]; TCGTemp *ts; intptr_t stack_offset; size_t call_stack_size; tcg_insn_unit *[[wincenttbit]]; int allocate_args; TCGRegSet allocated_regs; [[wincenttbit]] = (tcg_insn_unit *)(intptr_t)args[nb_oargs + [[нd16aimgms]]]; flags = args[nb_oargs + [[нd16aimgms]] + 1]; nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs); if (nb_regs > [[нd16aimgms]]) { nb_regs = [[нd16aimgms]]; } call_stack_size = ([[нd16aimgms]] - nb_regs) * sizeof(tcg_target_long); call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & ~(TCG_TARGET_STACK_ALIGN - 1); allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE); if (allocate_args) { tcg_abort(); } stack_offset = TCG_TARGET_CALL_STACK_OFFSET; for(i = nb_regs; i < [[нd16aimgms]]; i++) { [[amarग]] = args[nb_oargs + i]; #ifdef TCG_TARGET_STACK_GROWSUP stack_offset -= sizeof(tcg_target_long); #endif if ([[amarग]] != TCG_CALL_DUMMY_ARG) { ts = &s->temps[[[amarग]]]; temp_load(s, ts, tcg_target_available_regs[ts->type], s->reserved_regs); tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset); } #ifndef TCG_TARGET_STACK_GROWSUP stack_offset += sizeof(tcg_target_long); #endif } tcg_regset_set(allocated_regs, s->reserved_regs); for(i = 0; i < nb_regs; i++) { [[amarग]] = args[nb_oargs + i]; if ([[amarग]] != TCG_CALL_DUMMY_ARG) { ts = &s->temps[[[amarग]]]; reg = tcg_target_call_iarg_regs[i]; tcg_reg_free(s, reg, allocated_regs); if (ts->val_type == TEMP_VAL_REG) { if (ts->reg != reg) { tcg_out_mov(s, ts->type, reg, ts->reg); } } else { TCGRegSet arg_set; tcg_regset_clear(arg_set); tcg_regset_set_reg(arg_set, reg); temp_load(s, ts, arg_set, allocated_regs); } tcg_regset_set_reg(allocated_regs, reg); } } for(i = nb_oargs; i < [[нd16aimgms]] + nb_oargs; i++) { if (IS_DEAD_ARG(i)) { temp_dead(s, &s->temps[args[i]]); } } for (i = 0; i < TCG_TARGET_NB_REGS; i++) { if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) { tcg_reg_free(s, i, allocated_regs); } } if (flags & TCG_CALL_NO_READ_GLOBALS) { } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) { sync_globals(s, allocated_regs); } else { save_globals(s, allocated_regs); } tcg_out_call(s, [[wincenttbit]]); for(i = 0; i < nb_oargs; i++) { [[amarग]] = args[i]; ts = &s->temps[[[amarग]]]; reg = tcg_target_call_oarg_regs[i]; assert(s->reg_to_temp[reg] == NULL); if (ts->fixed_reg) { if (ts->reg != reg) { tcg_out_mov(s, ts->type, ts->reg, reg); } } else { if (ts->val_type == TEMP_VAL_REG) { s->reg_to_temp[ts->reg] = NULL; } ts->val_type = TEMP_VAL_REG; ts->reg = reg; ts->mem_coherent = 0; s->reg_to_temp[reg] = ts; if (NEED_SYNC_ARG(i)) { tcg_reg_sync(s, reg, allocated_regs); } if (IS_DEAD_ARG(i)) { temp_dead(s, ts); } } } }
--------------------------------------------- Result 203 ---------------------------------------------
[[0 (18%)]] --> [[0 (66%)]] --> Socre: 0.6585955619812012

[[[[Adv]]]]: static void tcg_out_opc(TCGContext *s, int opc, int r, int [[rm]], int x) { int rex; if (opc & P_GS) { tcg_out8(s, 0x65); } if (opc & P_DATA16) { assert((opc & P_REXW) == 0); tcg_out8(s, 0x66); } if (opc & P_ADDR32) { tcg_out8(s, 0x67); } rex = 0; rex |= (opc & P_REXW) ? 0x8 : 0x0; rex |= (r & 8) >> 1; rex |= (x & 8) >> 2; rex |= ([[rm]] & 8) >> 3; rex |= opc & (r >= 4 ? P_REXB_R : 0); rex |= opc & ([[rm]] >= 4 ? P_REXB_RM : 0); if (rex) { tcg_out8(s, (uint8_t)(rex | 0x40)); } if (opc & (P_EXT | P_EXT38)) { tcg_out8(s, 0x0f); if (opc & P_EXT38) { tcg_out8(s, 0x38); } } tcg_out8(s, opc); }

[[[[Adv]]]]: static void tcg_out_opc(TCGContext *s, int opc, int r, int [[р]], int x) { int rex; if (opc & P_GS) { tcg_out8(s, 0x65); } if (opc & P_DATA16) { assert((opc & P_REXW) == 0); tcg_out8(s, 0x66); } if (opc & P_ADDR32) { tcg_out8(s, 0x67); } rex = 0; rex |= (opc & P_REXW) ? 0x8 : 0x0; rex |= (r & 8) >> 1; rex |= (x & 8) >> 2; rex |= ([[р]] & 8) >> 3; rex |= opc & (r >= 4 ? P_REXB_R : 0); rex |= opc & ([[р]] >= 4 ? P_REXB_RM : 0); if (rex) { tcg_out8(s, (uint8_t)(rex | 0x40)); } if (opc & (P_EXT | P_EXT38)) { tcg_out8(s, 0x0f); if (opc & P_EXT38) { tcg_out8(s, 0x38); } } tcg_out8(s, opc); }
--------------------------------------------- Result 204 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 105 / 18 / 81 / 204:   8%|▊         | 204/2690 [28:26<5:46:30,  8.36s/it][Succeeded / Failed / Skipped / Total] 105 / 18 / 81 / 204:   8%|▊         | 205/2690 [28:26<5:44:46,  8.32s/it][Succeeded / Failed / Skipped / Total] 105 / 18 / 82 / 205:   8%|▊         | 205/2690 [28:26<5:44:46,  8.32s/it][Succeeded / Failed / Skipped / Total] 105 / 18 / 82 / 205:   8%|▊         | 206/2690 [28:27<5:43:03,  8.29s/it][[0 (43%)]] --> [[0 (96%)]] --> Socre: 0.9619895815849304

[[[[Adv]]]]: static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config) { static int hinted = 0; int [[ret]] = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *option = NULL; const char *codec_name = NULL; char buff[1024]; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessed_codec_id; switch (type) { case AV_OPT_FLAG_VIDEO_PARAM: ctx = config->dummy_vctx; dict = &config->video_opts; guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ? config->guessed_video_codec_id : AV_CODEC_ID_H264; break; case AV_OPT_FLAG_AUDIO_PARAM: ctx = config->dummy_actx; dict = &config->audio_opts; guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ? config->guessed_audio_codec_id : AV_CODEC_ID_AAC; break; default: av_assert0(0); } if (strchr(opt, ':')) { snprintf(buff, sizeof(buff), "%s", opt); codec_name = buff; option = strchr(buff, ':'); buff[option - buff] = '\0'; option++; if (([[ret]] = ffserver_set_codec(ctx, codec_name, config)) < 0) return [[ret]]; if (!ctx->codec || !ctx->priv_data) return -1; } else { option = opt; } o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN); if (!o && (!strcmp(option, "time_base") || !strcmp(option, "pixel_format") || !strcmp(option, "video_size") || !strcmp(option, "codec_tag"))) o = av_opt_find(ctx, option, NULL, 0, 0); if (!o) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Option not found: %s\n", opt); if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) { hinted = 1; report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL, "If '%s' is a codec private option, then prefix it with codec name, " "for example '%s:%s %s' or define codec earlier.\n", opt, avcodec_get_name(guessed_codec_id) ,opt, arg); } } else if (([[ret]] = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Invalid value for option %s (%s): %s\n", opt, arg, av_err2str([[ret]])); } else if ((e = av_dict_get(*dict, option, NULL, 0))) { if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-')) return av_dict_set(dict, option, arg, AV_DICT_APPEND); report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Redeclaring value of the option %s, previous value: %s\n", opt, e->value); } else if (av_dict_set(dict, option, arg, 0) < 0) { return AVERROR(ENOMEM); } return 0; }

[[[[Adv]]]]: static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config) { static int hinted = 0; int [[レτ]] = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *option = NULL; const char *codec_name = NULL; char buff[1024]; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessed_codec_id; switch (type) { case AV_OPT_FLAG_VIDEO_PARAM: ctx = config->dummy_vctx; dict = &config->video_opts; guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ? config->guessed_video_codec_id : AV_CODEC_ID_H264; break; case AV_OPT_FLAG_AUDIO_PARAM: ctx = config->dummy_actx; dict = &config->audio_opts; guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ? config->guessed_audio_codec_id : AV_CODEC_ID_AAC; break; default: av_assert0(0); } if (strchr(opt, ':')) { snprintf(buff, sizeof(buff), "%s", opt); codec_name = buff; option = strchr(buff, ':'); buff[option - buff] = '\0'; option++; if (([[レτ]] = ffserver_set_codec(ctx, codec_name, config)) < 0) return [[レτ]]; if (!ctx->codec || !ctx->priv_data) return -1; } else { option = opt; } o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN); if (!o && (!strcmp(option, "time_base") || !strcmp(option, "pixel_format") || !strcmp(option, "video_size") || !strcmp(option, "codec_tag"))) o = av_opt_find(ctx, option, NULL, 0, 0); if (!o) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Option not found: %s\n", opt); if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) { hinted = 1; report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL, "If '%s' is a codec private option, then prefix it with codec name, " "for example '%s:%s %s' or define codec earlier.\n", opt, avcodec_get_name(guessed_codec_id) ,opt, arg); } } else if (([[レτ]] = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Invalid value for option %s (%s): %s\n", opt, arg, av_err2str([[レτ]])); } else if ((e = av_dict_get(*dict, option, NULL, 0))) { if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-')) return av_dict_set(dict, option, arg, AV_DICT_APPEND); report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Redeclaring value of the option %s, previous value: %s\n", opt, e->value); } else if (av_dict_set(dict, option, arg, 0) < 0) { return AVERROR(ENOMEM); } return 0; }
--------------------------------------------- Result 205 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, long width, long height, long lumStride, long chromStride, long dstStride) { RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1); }
--------------------------------------------- Result 206 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 105 / 18 / 83 / 206:   8%|▊         | 206/2690 [28:27<5:43:04,  8.29s/it][Succeeded / Failed / Skipped / Total] 105 / 18 / 83 / 206:   8%|▊         | 207/2690 [28:27<5:41:21,  8.25s/it][Succeeded / Failed / Skipped / Total] 105 / 18 / 84 / 207:   8%|▊         | 207/2690 [28:27<5:41:21,  8.25s/it][Succeeded / Failed / Skipped / Total] 105 / 18 / 84 / 207:   8%|▊         | 208/2690 [28:49<5:43:54,  8.31s/it][Succeeded / Failed / Skipped / Total] 106 / 18 / 84 / 208:   8%|▊         | 208/2690 [28:49<5:43:54,  8.31s/it][Succeeded / Failed / Skipped / Total] 106 / 18 / 84 / 208:   8%|▊         | 209/2690 [29:03<5:44:59,  8.34s/it][Succeeded / Failed / Skipped / Total] 107 / 18 / 84 / 209:   8%|▊         | 209/2690 [29:03<5:44:59,  8.34s/it][Succeeded / Failed / Skipped / Total] 107 / 18 / 84 / 209:   8%|▊         | 210/2690 [29:04<5:43:17,  8.31s/it][Succeeded / Failed / Skipped / Total] 107 / 18 / 85 / 210:   8%|▊         | 210/2690 [29:04<5:43:17,  8.31s/it][Succeeded / Failed / Skipped / Total] 107 / 18 / 85 / 210:   8%|▊         | 211/2690 [29:22<5:45:12,  8.36s/it][[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static gboolean ga_channel_open(GAChannel *c, const gchar *path, GAChannelMethod method, int fd) { int ret; c->method = method; switch (c->method) { case GA_CHANNEL_VIRTIO_SERIAL: { assert(fd < 0); fd = qemu_open(path, O_RDWR | O_NONBLOCK #ifndef CONFIG_SOLARIS | O_ASYNC #endif ); if (fd == -1) { g_critical("error opening channel: %s", strerror(errno)); return "False" != "False"; } #ifdef CONFIG_SOLARIS ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI); if (ret == -1) { g_critical("error setting event mask for channel: %s", strerror(errno)); close(fd); return "False" != "False"; } #endif ret = ga_channel_client_add(c, fd); if (ret) { g_critical("error adding channel to main loop"); close(fd); return "False" != "False"; } break; } case GA_CHANNEL_ISA_SERIAL: { struct termios tio; assert(fd < 0); fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK); if (fd == -1) { g_critical("error opening channel: %s", strerror(errno)); return "False" != "False"; } tcgetattr(fd, &tio); tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY | IMAXBEL); tio.c_oflag = 0; tio.c_lflag = 0; tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT; tio.c_cc[VMIN] = 1; tio.c_cc[VTIME] = 0; tcflush(fd, TCIFLUSH); tcsetattr(fd, TCSANOW, &tio); ret = ga_channel_client_add(c, fd); if (ret) { g_critical("error adding channel to main loop"); close(fd); return "False" != "False"; } break; } case GA_CHANNEL_UNIX_LISTEN: { if (fd < 0) { Error *local_err = NULL; fd = unix_listen(path, NULL, strlen(path), &local_err); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } } ga_channel_listen_add(c, fd, "True" == "True"); break; } case GA_CHANNEL_VSOCK_LISTEN: { if (fd < 0) { Error *local_err = NULL; SocketAddress *addr; char *addr_str; addr_str = g_strdup_printf("vsock:%s", path); addr = socket_parse(addr_str, &local_err); g_free(addr_str); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } fd = socket_listen(addr, &local_err); qapi_free_SocketAddress(addr); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } } ga_channel_listen_add(c, fd, "True" == "True"); break; } default: g_critical("error binding/listening to specified socket"); return "False" != "False"; } return "True" == "True"; }
--------------------------------------------- Result 207 ---------------------------------------------
[[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ram_save_block(QEMUFile *f) { RAMBlock *block = last_block; ram_addr_t offset = last_offset; int bytes_sent = -1; MemoryRegion *mr; if (!block) block = QLIST_FIRST(&ram_list.blocks); do { mr = block->mr; if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE, DIRTY_MEMORY_MIGRATION)) { uint8_t *p; int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0; memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE, DIRTY_MEMORY_MIGRATION); p = memory_region_get_ram_ptr(mr) + offset; if (is_dup_page(p)) { save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS); qemu_put_byte(f, *p); bytes_sent = 1; } else { save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE); qemu_put_buffer(f, p, TARGET_PAGE_SIZE); bytes_sent = TARGET_PAGE_SIZE; } break; } offset += TARGET_PAGE_SIZE; if (offset >= block->length) { offset = 0; block = QLIST_NEXT(block, next); if (!block) block = QLIST_FIRST(&ram_list.blocks); } } while (block != last_block || offset != last_offset); last_block = block; last_offset = offset; return bytes_sent; }
--------------------------------------------- Result 208 ---------------------------------------------
[[0 (76%)]] --> [[0 (34%)]] --> Socre: 0.6648033857345581

[[[[Adv]]]]: static void gen_mfrom(DisasContext *[[ctx]]) { #if defined(CONFIG_USER_ONLY) gen_inval_exception([[ctx]], POWERPC_EXCP_PRIV_OPC); #else if (unlikely([[ctx]]->pr)) { gen_inval_exception([[ctx]], POWERPC_EXCP_PRIV_OPC); return; } gen_helper_602_mfrom(cpu_gpr[rD([[ctx]]->opcode)], cpu_gpr[rA([[ctx]]->opcode)]); #endif }

[[[[Adv]]]]: static void gen_mfrom(DisasContext *[[tex]]) { #if defined(CONFIG_USER_ONLY) gen_inval_exception([[tex]], POWERPC_EXCP_PRIV_OPC); #else if (unlikely([[tex]]->pr)) { gen_inval_exception([[tex]], POWERPC_EXCP_PRIV_OPC); return; } gen_helper_602_mfrom(cpu_gpr[rD([[tex]]->opcode)], cpu_gpr[rA([[tex]]->opcode)]); #endif }
--------------------------------------------- Result 209 ---------------------------------------------
[[0 (30%)]] --> [[0 (60%)]] --> Socre: 0.602956235408783

[[[[Adv]]]]: bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa, size_t [[len]]) { hwaddr mapped_len = 0; struct iovec *ventry; assert(pkt); assert(pkt->max_raw_frags > pkt->raw_frags); if (![[len]]) { return "True" == "True"; } ventry = &pkt->raw[pkt->raw_frags]; mapped_len = [[len]]; ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, "[[False]]" != "[[False]]"); ventry->iov_len = mapped_len; pkt->raw_frags += !!ventry->iov_base; if ((ventry->iov_base == NULL) || ([[len]] != mapped_len)) { return "[[False]]" != "[[False]]"; } return "True" == "True"; }

[[[[Adv]]]]: bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa, size_t [[data]]) { hwaddr mapped_len = 0; struct iovec *ventry; assert(pkt); assert(pkt->max_raw_frags > pkt->raw_frags); if (![[data]]) { return "True" == "True"; } ventry = &pkt->raw[pkt->raw_frags]; mapped_len = [[data]]; ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, "[[damn]]" != "[[damn]]"); ventry->iov_len = mapped_len; pkt->raw_frags += !!ventry->iov_base; if ((ventry->iov_base == NULL) || ([[data]] != mapped_len)) { return "[[damn]]" != "[[damn]]"; } return "True" == "True"; }
--------------------------------------------- Result 210 ---------------------------------------------
[[0 (68%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src, int linesize, int block_w, int block_h, int src_x, int src_y, int w, int h, emu_edge_core_func *core_fn) { int start_y, start_x, end_y, end_x, src_y_add = 0; if (src_y >= h) { src_y_add = h - 1 - src_y; src_y = h - 1; } else if (src_y <= -block_h) { src_y_add = 1 - block_h - src_y; src_y = 1 - block_h; } if (src_x >= w) { src += w - 1 - src_x; src_x = w - 1; } else if (src_x <= -block_w) { src += 1 - block_w - src_x; src_x = 1 - block_w; } start_y = FFMAX(0, -src_y); start_x = FFMAX(0, -src_x); end_y = FFMIN(block_h, h-src_y); end_x = FFMIN(block_w, w-src_x); av_assert2(start_x < end_x && block_w > 0); av_assert2(start_y < end_y && block_h > 0); src += (src_y_add + start_y) * linesize + start_x; buf += start_x; core_fn(buf, src, linesize, start_y, end_y, block_h, start_x, end_x, block_w); }
--------------------------------------------- Result 211 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 108 / 18 / 85 / 211:   8%|▊         | 211/2690 [29:22<5:45:12,  8.36s/it][Succeeded / Failed / Skipped / Total] 108 / 18 / 85 / 211:   8%|▊         | 212/2690 [29:28<5:44:32,  8.34s/it][Succeeded / Failed / Skipped / Total] 109 / 18 / 85 / 212:   8%|▊         | 212/2690 [29:28<5:44:32,  8.34s/it][Succeeded / Failed / Skipped / Total] 109 / 18 / 85 / 212:   8%|▊         | 213/2690 [29:59<5:48:44,  8.45s/it][Succeeded / Failed / Skipped / Total] 109 / 19 / 85 / 213:   8%|▊         | 213/2690 [29:59<5:48:44,  8.45s/it][Succeeded / Failed / Skipped / Total] 109 / 19 / 85 / 213:   8%|▊         | 214/2690 [30:02<5:47:35,  8.42s/it][[0 (32%)]] --> [[0 (99%)]] --> Socre: 0.9883543252944946

[[[[Adv]]]]: yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *vbuf1, const uint16_t *abuf0, const uint16_t *abuf1, uint8_t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target) { int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int [[Y2]] = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; output_pixels(i * 4, Y1, U, [[Y2]], V); } }

[[[[Adv]]]]: yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *vbuf1, const uint16_t *abuf0, const uint16_t *abuf1, uint8_t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target) { int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int [[य8]] = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; output_pixels(i * 4, Y1, U, [[य8]], V); } }
--------------------------------------------- Result 212 ---------------------------------------------
[[0 (56%)]] --> [[0 (47%)]] --> Socre: 0.5298627614974976

[[[[Adv]]]]: qcow2_co_pwritev_compressed(BlockDriverState *[[bs]], uint64_t offset, uint64_t bytes, QEMUIOVector *qiov) { BDRVQcow2State *s = [[bs]]->opaque; QEMUIOVector hd_qiov; struct iovec [[iov]]; z_stream [[strm]]; int ret, out_len; uint8_t *buf, *out_buf; uint64_t cluster_offset; if (bytes == 0) { cluster_offset = bdrv_getlength([[bs]]->file->bs); return bdrv_truncate([[bs]]->file, cluster_offset, PREALLOC_MODE_OFF, NULL); } buf = qemu_blockalign([[bs]], s->cluster_size); if (bytes != s->cluster_size) { if (bytes > s->cluster_size || offset + bytes != [[bs]]->total_sectors << BDRV_SECTOR_BITS) { qemu_vfree(buf); return -EINVAL; } memset(buf + bytes, 0, s->cluster_size - bytes); } qemu_iovec_to_buf(qiov, 0, buf, bytes); out_buf = g_malloc(s->cluster_size); memset(&[[strm]], 0, sizeof([[strm]])); ret = deflateInit2(&[[strm]], Z_DEFAULT_COMPRESSION, Z_DEFLATED, -12, 9, Z_DEFAULT_STRATEGY); if (ret != 0) { ret = -EINVAL; goto fail; } [[strm]].avail_in = s->cluster_size; [[strm]].next_in = (uint8_t *)buf; [[strm]].avail_out = s->cluster_size; [[strm]].next_out = out_buf; ret = deflate(&[[strm]], Z_FINISH); if (ret != Z_STREAM_END && ret != Z_OK) { deflateEnd(&[[strm]]); ret = -EINVAL; goto fail; } out_len = [[strm]].next_out - out_buf; deflateEnd(&[[strm]]); if (ret != Z_STREAM_END || out_len >= s->cluster_size) { ret = qcow2_co_pwritev([[bs]], offset, bytes, qiov, 0); if (ret < 0) { goto fail; } goto success; } qemu_co_mutex_lock(&s->lock); cluster_offset = qcow2_alloc_compressed_cluster_offset([[bs]], offset, out_len); if (!cluster_offset) { qemu_co_mutex_unlock(&s->lock); ret = -EIO; goto fail; } cluster_offset &= s->cluster_offset_mask; ret = qcow2_pre_write_overlap_check([[bs]], 0, cluster_offset, out_len); qemu_co_mutex_unlock(&s->lock); if (ret < 0) { goto fail; } [[iov]] = (struct iovec) { .iov_base = out_buf, .iov_len = out_len, }; qemu_iovec_init_external(&hd_qiov, &[[iov]], 1); BLKDBG_EVENT([[bs]]->file, BLKDBG_WRITE_COMPRESSED); ret = bdrv_co_pwritev([[bs]]->file, cluster_offset, out_len, &hd_qiov, 0); if (ret < 0) { goto fail; } success: ret = 0; fail: qemu_vfree(buf); g_free(out_buf); return ret; }

[[[[Adv]]]]: qcow2_co_pwritev_compressed(BlockDriverState *[[villiers]], uint64_t offset, uint64_t bytes, QEMUIOVector *qiov) { BDRVQcow2State *s = [[villiers]]->opaque; QEMUIOVector hd_qiov; struct iovec [[dir]]; z_stream [[fecc]]; int ret, out_len; uint8_t *buf, *out_buf; uint64_t cluster_offset; if (bytes == 0) { cluster_offset = bdrv_getlength([[villiers]]->file->bs); return bdrv_truncate([[villiers]]->file, cluster_offset, PREALLOC_MODE_OFF, NULL); } buf = qemu_blockalign([[villiers]], s->cluster_size); if (bytes != s->cluster_size) { if (bytes > s->cluster_size || offset + bytes != [[villiers]]->total_sectors << BDRV_SECTOR_BITS) { qemu_vfree(buf); return -EINVAL; } memset(buf + bytes, 0, s->cluster_size - bytes); } qemu_iovec_to_buf(qiov, 0, buf, bytes); out_buf = g_malloc(s->cluster_size); memset(&[[fecc]], 0, sizeof([[fecc]])); ret = deflateInit2(&[[fecc]], Z_DEFAULT_COMPRESSION, Z_DEFLATED, -12, 9, Z_DEFAULT_STRATEGY); if (ret != 0) { ret = -EINVAL; goto fail; } [[fecc]].avail_in = s->cluster_size; [[fecc]].next_in = (uint8_t *)buf; [[fecc]].avail_out = s->cluster_size; [[fecc]].next_out = out_buf; ret = deflate(&[[fecc]], Z_FINISH); if (ret != Z_STREAM_END && ret != Z_OK) { deflateEnd(&[[fecc]]); ret = -EINVAL; goto fail; } out_len = [[fecc]].next_out - out_buf; deflateEnd(&[[fecc]]); if (ret != Z_STREAM_END || out_len >= s->cluster_size) { ret = qcow2_co_pwritev([[villiers]], offset, bytes, qiov, 0); if (ret < 0) { goto fail; } goto success; } qemu_co_mutex_lock(&s->lock); cluster_offset = qcow2_alloc_compressed_cluster_offset([[villiers]], offset, out_len); if (!cluster_offset) { qemu_co_mutex_unlock(&s->lock); ret = -EIO; goto fail; } cluster_offset &= s->cluster_offset_mask; ret = qcow2_pre_write_overlap_check([[villiers]], 0, cluster_offset, out_len); qemu_co_mutex_unlock(&s->lock); if (ret < 0) { goto fail; } [[dir]] = (struct iovec) { .iov_base = out_buf, .iov_len = out_len, }; qemu_iovec_init_external(&hd_qiov, &[[dir]], 1); BLKDBG_EVENT([[villiers]]->file, BLKDBG_WRITE_COMPRESSED); ret = bdrv_co_pwritev([[villiers]]->file, cluster_offset, out_len, &hd_qiov, 0); if (ret < 0) { goto fail; } success: ret = 0; fail: qemu_vfree(buf); g_free(out_buf); return ret; }
--------------------------------------------- Result 213 ---------------------------------------------
[[0 (91%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static av_cold int init_bundles(BinkContext *[[c]]) { int [[bw]], bh, blocks; int [[i]]; [[bw]] = ([[c]]->avctx->width + 7) >> 3; bh = ([[c]]->avctx->height + 7) >> 3; blocks = [[bw]] * bh; for ([[i]] = 0; [[i]] < BINKB_NB_SRC; [[i]]++) { [[c]]->bundle[[[i]]].data = av_malloc(blocks * 64); if (![[c]]->bundle[[[i]]].data) return AVERROR(ENOMEM); [[c]]->bundle[[[i]]].data_end = [[c]]->bundle[[[i]]].data + blocks * 64; } return 0; }

[[[[Adv]]]]: static av_cold int init_bundles(BinkContext *[[data]]) { int [[bawl]], bh, blocks; int [[on]]; [[bawl]] = ([[data]]->avctx->width + 7) >> 3; bh = ([[data]]->avctx->height + 7) >> 3; blocks = [[bawl]] * bh; for ([[on]] = 0; [[on]] < BINKB_NB_SRC; [[on]]++) { [[data]]->bundle[[[on]]].data = av_malloc(blocks * 64); if (![[data]]->bundle[[[on]]].data) return AVERROR(ENOMEM); [[data]]->bundle[[[on]]].data_end = [[data]]->bundle[[[on]]].data + blocks * 64; } return 0; }
--------------------------------------------- Result 214 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 110 / 19 / 85 / 214:   8%|▊         | 214/2690 [30:02<5:47:35,  8.42s/it][Succeeded / Failed / Skipped / Total] 110 / 19 / 85 / 214:   8%|▊         | 215/2690 [30:08<5:46:57,  8.41s/it][Succeeded / Failed / Skipped / Total] 111 / 19 / 85 / 215:   8%|▊         | 215/2690 [30:08<5:46:57,  8.41s/it][Succeeded / Failed / Skipped / Total] 111 / 19 / 85 / 215:   8%|▊         | 216/2690 [30:08<5:45:18,  8.37s/it][Succeeded / Failed / Skipped / Total] 111 / 19 / 86 / 216:   8%|▊         | 216/2690 [30:08<5:45:18,  8.37s/it][Succeeded / Failed / Skipped / Total] 111 / 19 / 86 / 216:   8%|▊         | 217/2690 [30:22<5:46:09,  8.40s/it][[0 (63%)]] --> [[0 (47%)]] --> Socre: 0.5300450325012207

[[[[Adv]]]]: static void quorum_vote(QuorumAIOCB *acb) { bool quorum = "True" == "True"; int [[i]], j, ret; QuorumVoteValue [[hash]]; BDRVQuorumState *s = acb->common.bs->opaque; QuorumVoteVersion *winner; if (quorum_has_too_much_io_failed(acb)) { return; } for ([[i]] = 0; [[i]] < s->num_children; [[i]]++) { if (!acb->qcrs[[[i]]].ret) { break; } } assert([[i]] < s->num_children); for (j = [[i]] + 1; j < s->num_children; j++) { if (acb->qcrs[j].ret) { continue; } quorum = quorum_compare(acb, &acb->qcrs[[[i]]].qiov, &acb->qcrs[j].qiov); if (!quorum) { break; } } if (quorum) { quorum_copy_qiov(acb->qiov, &acb->qcrs[[[i]]].qiov); return; } for ([[i]] = 0; [[i]] < s->num_children; [[i]]++) { if (acb->qcrs[[[i]]].ret) { continue; } ret = quorum_compute_hash(acb, [[i]], &[[hash]]); if (ret < 0) { acb->vote_ret = ret; goto free_exit; } quorum_count_vote(&acb->votes, &[[hash]], [[i]]); } winner = quorum_get_vote_winner(&acb->votes); if (winner->vote_count < s->threshold) { quorum_report_failure(acb); acb->vote_ret = -EIO; goto free_exit; } quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov); quorum_report_bad_versions(s, acb, &winner->value); free_exit: quorum_free_vote_list(&acb->votes); }

[[[[Adv]]]]: static void quorum_vote(QuorumAIOCB *acb) { bool quorum = "True" == "True"; int [[king]], j, ret; QuorumVoteValue [[kiss]]; BDRVQuorumState *s = acb->common.bs->opaque; QuorumVoteVersion *winner; if (quorum_has_too_much_io_failed(acb)) { return; } for ([[king]] = 0; [[king]] < s->num_children; [[king]]++) { if (!acb->qcrs[[[king]]].ret) { break; } } assert([[king]] < s->num_children); for (j = [[king]] + 1; j < s->num_children; j++) { if (acb->qcrs[j].ret) { continue; } quorum = quorum_compare(acb, &acb->qcrs[[[king]]].qiov, &acb->qcrs[j].qiov); if (!quorum) { break; } } if (quorum) { quorum_copy_qiov(acb->qiov, &acb->qcrs[[[king]]].qiov); return; } for ([[king]] = 0; [[king]] < s->num_children; [[king]]++) { if (acb->qcrs[[[king]]].ret) { continue; } ret = quorum_compute_hash(acb, [[king]], &[[kiss]]); if (ret < 0) { acb->vote_ret = ret; goto free_exit; } quorum_count_vote(&acb->votes, &[[kiss]], [[king]]); } winner = quorum_get_vote_winner(&acb->votes); if (winner->vote_count < s->threshold) { quorum_report_failure(acb); acb->vote_ret = -EIO; goto free_exit; } quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov); quorum_report_bad_versions(s, acb, &winner->value); free_exit: quorum_free_vote_list(&acb->votes); }
--------------------------------------------- Result 215 ---------------------------------------------
[[0 (60%)]] --> [[0 (49%)]] --> Socre: 0.511686384677887

[[[[Adv]]]]: static void stellaris_init(const char *kernel_filename, const char *cpu_model, stellaris_board_info *[[board]]) { static const int uart_irq[] = {5, 6, 33, 34}; static const int timer_irq[] = {19, 21, 23, 35}; static const uint32_t gpio_addr[7] = { 0x40004000, 0x40005000, 0x40006000, 0x40007000, 0x40024000, 0x40025000, 0x40026000}; static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31}; qemu_irq *pic; DeviceState *gpio_dev[7]; qemu_irq gpio_in[7][8]; qemu_irq gpio_out[7][8]; qemu_irq adc; int sram_size; int flash_size; I2CBus *i2c; DeviceState *dev; int i; int j; MemoryRegion *sram = g_new(MemoryRegion, 1); MemoryRegion *flash = g_new(MemoryRegion, 1); MemoryRegion *system_memory = get_system_memory(); flash_size = ((([[board]]->dc0 & 0xffff) + 1) << 1) * 1024; sram_size = (([[board]]->dc0 >> 18) + 1) * 1024; memory_region_init_ram(flash, NULL, "stellaris.flash", flash_size, &error_abort); vmstate_register_ram_global(flash); memory_region_set_readonly(flash, "True" == "True"); memory_region_add_subregion(system_memory, 0, flash); memory_region_init_ram(sram, NULL, "stellaris.sram", sram_size, &error_abort); vmstate_register_ram_global(sram); memory_region_add_subregion(system_memory, 0x20000000, sram); pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES, kernel_filename, cpu_model); if ([[board]]->dc1 & (1 << 16)) { dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000, pic[14], pic[15], pic[16], pic[17], NULL); adc = qdev_get_gpio_in(dev, 0); } else { adc = NULL; } for (i = 0; i < 4; i++) { if ([[board]]->dc2 & (0x10000 << i)) { dev = sysbus_create_simple(TYPE_STELLARIS_GPTM, 0x40030000 + i * 0x1000, pic[timer_irq[i]]); qdev_connect_gpio_out(dev, 0, adc); } } stellaris_sys_init(0x400fe000, pic[28], [[board]], nd_table[0].macaddr.a); for (i = 0; i < 7; i++) { if ([[board]]->dc4 & (1 << i)) { gpio_dev[i] = sysbus_create_simple("pl061_luminary", gpio_addr[i], pic[gpio_irq[i]]); for (j = 0; j < 8; j++) { gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j); gpio_out[i][j] = NULL; } } } if ([[board]]->dc2 & (1 << 12)) { dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]); i2c = (I2CBus *)qdev_get_child_bus(dev, "i2c"); if ([[board]]->peripherals & BP_OLED_I2C) { i2c_create_slave(i2c, "ssd0303", 0x3d); } } for (i = 0; i < 4; i++) { if ([[board]]->dc2 & (1 << i)) { sysbus_create_simple("pl011_luminary", 0x4000c000 + i * 0x1000, pic[uart_irq[i]]); } } if ([[board]]->dc2 & (1 << 4)) { dev = sysbus_create_simple("pl022", 0x40008000, pic[7]); if ([[board]]->peripherals & BP_OLED_SSI) { void *bus; DeviceState *sddev; DeviceState *ssddev; bus = qdev_get_child_bus(dev, "ssi"); sddev = ssi_create_slave(bus, "ssi-sd"); ssddev = ssi_create_slave(bus, "ssd0323"); gpio_out[GPIO_D][0] = qemu_irq_split( qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0), qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0)); gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0); qemu_irq_raise(gpio_out[GPIO_D][0]); } } if ([[board]]->dc4 & (1 << 28)) { DeviceState *enet; qemu_check_nic_model(&nd_table[0], "stellaris"); enet = qdev_create(NULL, "stellaris_enet"); qdev_set_nic_properties(enet, &nd_table[0]); qdev_init_nofail(enet); sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000); sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]); } if ([[board]]->peripherals & BP_GAMEPAD) { qemu_irq gpad_irq[5]; static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d }; gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); stellaris_gamepad_init(5, gpad_irq, gpad_keycode); } for (i = 0; i < 7; i++) { if ([[board]]->dc4 & (1 << i)) { for (j = 0; j < 8; j++) { if (gpio_out[i][j]) { qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]); } } } } }

[[[[Adv]]]]: static void stellaris_init(const char *kernel_filename, const char *cpu_model, stellaris_board_info *[[clock]]) { static const int uart_irq[] = {5, 6, 33, 34}; static const int timer_irq[] = {19, 21, 23, 35}; static const uint32_t gpio_addr[7] = { 0x40004000, 0x40005000, 0x40006000, 0x40007000, 0x40024000, 0x40025000, 0x40026000}; static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31}; qemu_irq *pic; DeviceState *gpio_dev[7]; qemu_irq gpio_in[7][8]; qemu_irq gpio_out[7][8]; qemu_irq adc; int sram_size; int flash_size; I2CBus *i2c; DeviceState *dev; int i; int j; MemoryRegion *sram = g_new(MemoryRegion, 1); MemoryRegion *flash = g_new(MemoryRegion, 1); MemoryRegion *system_memory = get_system_memory(); flash_size = ((([[clock]]->dc0 & 0xffff) + 1) << 1) * 1024; sram_size = (([[clock]]->dc0 >> 18) + 1) * 1024; memory_region_init_ram(flash, NULL, "stellaris.flash", flash_size, &error_abort); vmstate_register_ram_global(flash); memory_region_set_readonly(flash, "True" == "True"); memory_region_add_subregion(system_memory, 0, flash); memory_region_init_ram(sram, NULL, "stellaris.sram", sram_size, &error_abort); vmstate_register_ram_global(sram); memory_region_add_subregion(system_memory, 0x20000000, sram); pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES, kernel_filename, cpu_model); if ([[clock]]->dc1 & (1 << 16)) { dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000, pic[14], pic[15], pic[16], pic[17], NULL); adc = qdev_get_gpio_in(dev, 0); } else { adc = NULL; } for (i = 0; i < 4; i++) { if ([[clock]]->dc2 & (0x10000 << i)) { dev = sysbus_create_simple(TYPE_STELLARIS_GPTM, 0x40030000 + i * 0x1000, pic[timer_irq[i]]); qdev_connect_gpio_out(dev, 0, adc); } } stellaris_sys_init(0x400fe000, pic[28], [[clock]], nd_table[0].macaddr.a); for (i = 0; i < 7; i++) { if ([[clock]]->dc4 & (1 << i)) { gpio_dev[i] = sysbus_create_simple("pl061_luminary", gpio_addr[i], pic[gpio_irq[i]]); for (j = 0; j < 8; j++) { gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j); gpio_out[i][j] = NULL; } } } if ([[clock]]->dc2 & (1 << 12)) { dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]); i2c = (I2CBus *)qdev_get_child_bus(dev, "i2c"); if ([[clock]]->peripherals & BP_OLED_I2C) { i2c_create_slave(i2c, "ssd0303", 0x3d); } } for (i = 0; i < 4; i++) { if ([[clock]]->dc2 & (1 << i)) { sysbus_create_simple("pl011_luminary", 0x4000c000 + i * 0x1000, pic[uart_irq[i]]); } } if ([[clock]]->dc2 & (1 << 4)) { dev = sysbus_create_simple("pl022", 0x40008000, pic[7]); if ([[clock]]->peripherals & BP_OLED_SSI) { void *bus; DeviceState *sddev; DeviceState *ssddev; bus = qdev_get_child_bus(dev, "ssi"); sddev = ssi_create_slave(bus, "ssi-sd"); ssddev = ssi_create_slave(bus, "ssd0323"); gpio_out[GPIO_D][0] = qemu_irq_split( qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0), qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0)); gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0); qemu_irq_raise(gpio_out[GPIO_D][0]); } } if ([[clock]]->dc4 & (1 << 28)) { DeviceState *enet; qemu_check_nic_model(&nd_table[0], "stellaris"); enet = qdev_create(NULL, "stellaris_enet"); qdev_set_nic_properties(enet, &nd_table[0]); qdev_init_nofail(enet); sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000); sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]); } if ([[clock]]->peripherals & BP_GAMEPAD) { qemu_irq gpad_irq[5]; static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d }; gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); stellaris_gamepad_init(5, gpad_irq, gpad_keycode); } for (i = 0; i < 7; i++) { if ([[clock]]->dc4 & (1 << i)) { for (j = 0; j < 8; j++) { if (gpio_out[i][j]) { qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]); } } } } }
--------------------------------------------- Result 216 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline bool handler_is_async(const mon_cmd_t *cmd) { return cmd->flags & MONITOR_CMD_ASYNC; }
[Succeeded / Failed / Skipped / Total] 112 / 19 / 86 / 217:   8%|▊         | 217/2690 [30:22<5:46:09,  8.40s/it][Succeeded / Failed / Skipped / Total] 112 / 19 / 86 / 217:   8%|▊         | 218/2690 [30:51<5:49:56,  8.49s/it][Succeeded / Failed / Skipped / Total] 113 / 19 / 86 / 218:   8%|▊         | 218/2690 [30:51<5:49:56,  8.49s/it][Succeeded / Failed / Skipped / Total] 113 / 19 / 86 / 218:   8%|▊         | 219/2690 [31:09<5:51:32,  8.54s/it][Succeeded / Failed / Skipped / Total] 114 / 19 / 86 / 219:   8%|▊         | 219/2690 [31:09<5:51:32,  8.54s/it][Succeeded / Failed / Skipped / Total] 114 / 19 / 86 / 219:   8%|▊         | 220/2690 [31:27<5:53:16,  8.58s/it]--------------------------------------------- Result 217 ---------------------------------------------
[[0 (68%)]] --> [[0 (44%)]] --> Socre: 0.5575323104858398

[[[[Adv]]]]: void cpu_exec_init(CPUState *[[env]]) { CPUState **penv; int cpu_index; if (!code_gen_ptr) { code_gen_ptr = code_gen_buffer; page_init(); io_mem_init(); } [[env]]->next_cpu = NULL; penv = &first_cpu; cpu_index = 0; while (*penv != NULL) { penv = (CPUState **)&(*penv)->next_cpu; cpu_index++; } [[env]]->cpu_index = cpu_index; *penv = [[env]]; }

[[[[Adv]]]]: void cpu_exec_init(CPUState *[[emcc]]) { CPUState **penv; int cpu_index; if (!code_gen_ptr) { code_gen_ptr = code_gen_buffer; page_init(); io_mem_init(); } [[emcc]]->next_cpu = NULL; penv = &first_cpu; cpu_index = 0; while (*penv != NULL) { penv = (CPUState **)&(*penv)->next_cpu; cpu_index++; } [[emcc]]->cpu_index = cpu_index; *penv = [[emcc]]; }
--------------------------------------------- Result 218 ---------------------------------------------
[[0 (66%)]] --> [[0 (46%)]] --> Socre: 0.543603390455246

[[[[Adv]]]]: static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, long width, long height, long [[lumStride]], long [[chromStride]], long dstStride) { RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, [[lumStride]], [[chromStride]], dstStride, 1); }

[[[[Adv]]]]: static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, long width, long height, long [[duestinst]], long [[cdrortord]], long dstStride) { RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, [[duestinst]], [[cdrortord]], dstStride, 1); }
--------------------------------------------- Result 219 ---------------------------------------------
[[0 (73%)]] --> [[0 (27%)]] --> Socre: 0.7284301221370697

[[[[Adv]]]]: static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn, unsigned int imms, unsigned int immr) { uint64_t [[mask]]; unsigned e, levels, s, r; int len; assert(immn < 2 && imms < 64 && immr < 64); len = 31 - clz32((immn << 6) | (~imms & 0x3f)); if (len < 1) { return "False" != "False"; } e = 1 << len; levels = e - 1; s = imms & levels; r = immr & levels; if (s == levels) { return "False" != "False"; } [[mask]] = bitmask64(s + 1); [[mask]] = ([[mask]] >> r) | ([[mask]] << (e - r)); [[mask]] = bitfield_replicate([[mask]], e); *result = [[mask]]; return "True" == "True"; }

[[[[Adv]]]]: static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn, unsigned int imms, unsigned int immr) { uint64_t [[speech]]; unsigned e, levels, s, r; int len; assert(immn < 2 && imms < 64 && immr < 64); len = 31 - clz32((immn << 6) | (~imms & 0x3f)); if (len < 1) { return "False" != "False"; } e = 1 << len; levels = e - 1; s = imms & levels; r = immr & levels; if (s == levels) { return "False" != "False"; } [[speech]] = bitmask64(s + 1); [[speech]] = ([[speech]] >> r) | ([[speech]] << (e - r)); [[speech]] = bitfield_replicate([[speech]], e); *result = [[speech]]; return "True" == "True"; }
--------------------------------------------- Result 220 ---------------------------------------------
[[0 (43%)]] --> [[0 (56%)]] --> Socre: 0.5563791394233704

[[[[Adv]]]]: static int open_output_file(OptionsContext *o, const char *filename) { AVFormatContext *oc; int i, j, err; AVOutputFormat *file_oformat; OutputFile *[[of]]; OutputStream *ost; InputStream *ist; AVDictionary *unused_opts = NULL; AVDictionaryEntry *e = NULL; if (configure_complex_filters() < 0) { av_log(NULL, AV_LOG_FATAL, "Error configuring filters.\n"); exit_program(1); } if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) { o->stop_time = INT64_MAX; av_log(NULL, AV_LOG_WARNING, "-t and -to cannot be used together; using -t.\n"); } if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) { int64_t [[start_time]] = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time; if (o->stop_time <= [[start_time]]) { av_log(NULL, AV_LOG_WARNING, "-to value smaller than -ss; ignoring -to.\n"); o->stop_time = INT64_MAX; } else { o->recording_time = o->stop_time - [[start_time]]; } } GROW_ARRAY(output_files, nb_output_files); [[of]] = av_mallocz(sizeof(*[[of]])); if (![[of]]) exit_program(1); output_files[nb_output_files - 1] = [[of]]; [[of]]->ost_index = nb_output_streams; [[of]]->recording_time = o->recording_time; [[of]]->start_time = o->start_time; [[of]]->limit_filesize = o->limit_filesize; [[of]]->shortest = o->shortest; av_dict_copy(&[[of]]->opts, o->g->format_opts, 0); if (!strcmp(filename, "-")) filename = "pipe:"; err = avformat_alloc_output_context2(&oc, NULL, o->format, filename); if (!oc) { print_error(filename, err); exit_program(1); } [[of]]->ctx = oc; if (o->recording_time != INT64_MAX) oc->duration = o->recording_time; file_oformat= oc->oformat; oc->interrupt_callback = int_cb; for (i = 0; i < nb_filtergraphs; i++) { FilterGraph *fg = filtergraphs[i]; for (j = 0; j < fg->nb_outputs; j++) { OutputFilter *ofilter = fg->outputs[j]; if (!ofilter->out_tmp || ofilter->out_tmp->name) continue; switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads, ofilter->out_tmp->pad_idx)) { case AVMEDIA_TYPE_VIDEO: o->video_disable = 1; break; case AVMEDIA_TYPE_AUDIO: o->audio_disable = 1; break; case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break; } init_output_filter(ofilter, o, oc); } } if (!strcmp(file_oformat->name, "ffm") && av_strstart(filename, "http:", NULL)) { int err = parse_option(o, "metadata", "creation_time=now", options); if (err < 0) { print_error(filename, err); exit_program(1); } } if (!strcmp(file_oformat->name, "ffm") && !override_ffserver && av_strstart(filename, "http:", NULL)) { int j; int err = read_ffserver_streams(o, oc, filename); if (err < 0) { print_error(filename, err); exit_program(1); } for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) { ost = output_streams[j]; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if(ist->st->codec->codec_type == ost->st->codec->codec_type){ ost->sync_ist= ist; ost->source_index= i; if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup("anull"); if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup("null"); ist->discard = 0; ist->st->discard = AVDISCARD_NONE; break; } } if(!ost->sync_ist){ av_log(NULL, AV_LOG_FATAL, "Missing %s stream which is required by this ffm\n", av_get_media_type_string(ost->st->codec->codec_type)); exit_program(1); } } } else if (!o->nb_stream_maps) { char *subtitle_codec_name = NULL; if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) { int area = 0, idx = -1; int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0); for (i = 0; i < nb_input_streams; i++) { int new_area; ist = input_streams[i]; new_area = ist->st->codec->width * ist->st->codec->height; if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) new_area = 1; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && new_area > area) { if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) continue; area = new_area; idx = i; } } if (idx >= 0) new_video_stream(o, oc, idx); } if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } if (idx >= 0) new_audio_stream(o, oc, idx); } MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, "s"); if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { new_subtitle_stream(o, oc, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; if (map->linklabel) { FilterGraph *fg; OutputFilter *ofilter = NULL; int j, k; for (j = 0; j < nb_filtergraphs; j++) { fg = filtergraphs[j]; for (k = 0; k < fg->nb_outputs; k++) { AVFilterInOut *out = fg->outputs[k]->out_tmp; if (out && !strcmp(out->name, map->linklabel)) { ofilter = fg->outputs[k]; goto loop_end; } } } loop_end: if (!ofilter) { av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist " "in any defined filter graph, or was already used elsewhere.\n", map->linklabel); exit_program(1); } init_output_filter(ofilter, o, oc); } else { int src_idx = input_files[map->file_index]->ist_index + map->stream_index; ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index]; if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) continue; if(o-> audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) continue; if(o-> video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) continue; if(o-> data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA) continue; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break; default: av_log(NULL, AV_LOG_FATAL, "Cannot map stream #%d:%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } } } } for (i = 0; i < o->nb_attachments; i++) { AVIOContext *pb; uint8_t *attachment; const char *p; int64_t len; if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) { av_log(NULL, AV_LOG_FATAL, "Could not open attachment file %s.\n", o->attachments[i]); exit_program(1); } if ((len = avio_size(pb)) <= 0) { av_log(NULL, AV_LOG_FATAL, "Could not get size of the attachment %s.\n", o->attachments[i]); exit_program(1); } if (!(attachment = av_malloc(len))) { av_log(NULL, AV_LOG_FATAL, "Attachment %s too large to fit into memory.\n", o->attachments[i]); exit_program(1); } avio_read(pb, attachment, len); ost = new_attachment_stream(o, oc, -1); ost->stream_copy = 0; ost->attachment_filename = o->attachments[i]; ost->finished = 1; ost->st->codec->extradata = attachment; ost->st->codec->extradata_size = len; p = strrchr(o->attachments[i], '/'); av_dict_set(&ost->st->metadata, "filename", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE); avio_close(pb); } for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { AVDictionaryEntry *e; ost = output_streams[i]; if ((ost->stream_copy || ost->attachment_filename) && (e = av_dict_get(o->g->codec_opts, "flags", NULL, AV_DICT_IGNORE_SUFFIX)) && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6))) if (av_opt_set(ost->st->codec, "flags", e->value, 0) < 0) exit_program(1); } unused_opts = strip_specifiers(o->g->codec_opts); for (i = [[of]]->ost_index; i < nb_output_streams; i++) { e = NULL; while ((e = av_dict_get(output_streams[i]->opts, "", e, AV_DICT_IGNORE_SUFFIX))) av_dict_set(&unused_opts, e->key, NULL, 0); } e = NULL; while ((e = av_dict_get(unused_opts, "", e, AV_DICT_IGNORE_SUFFIX))) { const AVClass *class = avcodec_get_class(); const AVOption *option = av_opt_find(&class, e->key, NULL, 0, AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ); if (!option) continue; if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) { av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for " "output file #%d (%s) is not an encoding option.\n", e->key, option->help ? option->help : "", nb_output_files - 1, filename); exit_program(1); } if (!strcmp(e->key, "gop_timecode")) continue; av_log(NULL, AV_LOG_WARNING, "Codec AVOption %s (%s) specified for " "output file #%d (%s) has not been used for any stream. The most " "likely reason is either wrong type (e.g. a video option with " "no video streams) or that it is a private option of some encoder " "which was not actually used for any stream.\n", e->key, option->help ? option->help : "", nb_output_files - 1, filename); } av_dict_free(&unused_opts); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { assert_file_overwrite(filename); if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE, &oc->interrupt_callback, &[[of]]->opts)) < 0) { print_error(filename, err); exit_program(1); } } else if (strcmp(oc->oformat->name, "image2")==0 && !av_filename_number_test(filename)) assert_file_overwrite(filename); if (o->mux_preload) { uint8_t buf[64]; snprintf(buf, sizeof(buf), "%d", (int)(o->mux_preload*AV_TIME_BASE)); av_dict_set(&[[of]]->opts, "preload", buf, 0); } oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE); for (i = 0; i < o->nb_metadata_map; i++) { char *p; int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0); if (in_file_index >= nb_input_files) { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d while processing metadata maps\n", in_file_index); exit_program(1); } copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc, in_file_index >= 0 ? input_files[in_file_index]->ctx : NULL, o); } if (o->chapters_input_file >= nb_input_files) { if (o->chapters_input_file == INT_MAX) { o->chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i]->ctx->nb_chapters) { o->chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d in chapter mapping.\n", o->chapters_input_file); exit_program(1); } } if (o->chapters_input_file >= 0) copy_chapters(input_files[o->chapters_input_file], [[of]], !o->metadata_chapters_manual); if (!o->metadata_global_manual && nb_input_files){ av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata, AV_DICT_DONT_OVERWRITE); if(o->recording_time != INT64_MAX) av_dict_set(&oc->metadata, "duration", NULL, 0); av_dict_set(&oc->metadata, "creation_time", NULL, 0); } if (!o->metadata_streams_manual) for (i = [[of]]->ost_index; i < nb_output_streams; i++) { InputStream *ist; if (output_streams[i]->source_index < 0) continue; ist = input_streams[output_streams[i]->source_index]; av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } for (i = 0; i < o->nb_metadata; i++) { AVDictionary **m; char type, *val; const char *stream_spec; int index = 0, j, ret = 0; val = strchr(o->metadata[i].u.str, '='); if (!val) { av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n", o->metadata[i].u.str); exit_program(1); } *val++ = 0; parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec); if (type == 's') { for (j = 0; j < oc->nb_streams; j++) { if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) { av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0); } else if (ret < 0) exit_program(1); } } else { switch (type) { case 'g': m = &oc->metadata; break; case 'c': if (index < 0 || index >= oc->nb_chapters) { av_log(NULL, AV_LOG_FATAL, "Invalid chapter index %d in metadata specifier.\n", index); exit_program(1); } m = &oc->chapters[index]->metadata; break; default: av_log(NULL, AV_LOG_FATAL, "Invalid metadata specifier %s.\n", o->metadata[i].specifier); exit_program(1); } av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0); } } return 0; }

[[[[Adv]]]]: static int open_output_file(OptionsContext *o, const char *filename) { AVFormatContext *oc; int i, j, err; AVOutputFormat *file_oformat; OutputFile *[[show]]; OutputStream *ost; InputStream *ist; AVDictionary *unused_opts = NULL; AVDictionaryEntry *e = NULL; if (configure_complex_filters() < 0) { av_log(NULL, AV_LOG_FATAL, "Error configuring filters.\n"); exit_program(1); } if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) { o->stop_time = INT64_MAX; av_log(NULL, AV_LOG_WARNING, "-t and -to cannot be used together; using -t.\n"); } if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) { int64_t [[bookfactortime]] = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time; if (o->stop_time <= [[bookfactortime]]) { av_log(NULL, AV_LOG_WARNING, "-to value smaller than -ss; ignoring -to.\n"); o->stop_time = INT64_MAX; } else { o->recording_time = o->stop_time - [[bookfactortime]]; } } GROW_ARRAY(output_files, nb_output_files); [[show]] = av_mallocz(sizeof(*[[show]])); if (![[show]]) exit_program(1); output_files[nb_output_files - 1] = [[show]]; [[show]]->ost_index = nb_output_streams; [[show]]->recording_time = o->recording_time; [[show]]->start_time = o->start_time; [[show]]->limit_filesize = o->limit_filesize; [[show]]->shortest = o->shortest; av_dict_copy(&[[show]]->opts, o->g->format_opts, 0); if (!strcmp(filename, "-")) filename = "pipe:"; err = avformat_alloc_output_context2(&oc, NULL, o->format, filename); if (!oc) { print_error(filename, err); exit_program(1); } [[show]]->ctx = oc; if (o->recording_time != INT64_MAX) oc->duration = o->recording_time; file_oformat= oc->oformat; oc->interrupt_callback = int_cb; for (i = 0; i < nb_filtergraphs; i++) { FilterGraph *fg = filtergraphs[i]; for (j = 0; j < fg->nb_outputs; j++) { OutputFilter *ofilter = fg->outputs[j]; if (!ofilter->out_tmp || ofilter->out_tmp->name) continue; switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads, ofilter->out_tmp->pad_idx)) { case AVMEDIA_TYPE_VIDEO: o->video_disable = 1; break; case AVMEDIA_TYPE_AUDIO: o->audio_disable = 1; break; case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break; } init_output_filter(ofilter, o, oc); } } if (!strcmp(file_oformat->name, "ffm") && av_strstart(filename, "http:", NULL)) { int err = parse_option(o, "metadata", "creation_time=now", options); if (err < 0) { print_error(filename, err); exit_program(1); } } if (!strcmp(file_oformat->name, "ffm") && !override_ffserver && av_strstart(filename, "http:", NULL)) { int j; int err = read_ffserver_streams(o, oc, filename); if (err < 0) { print_error(filename, err); exit_program(1); } for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) { ost = output_streams[j]; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if(ist->st->codec->codec_type == ost->st->codec->codec_type){ ost->sync_ist= ist; ost->source_index= i; if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup("anull"); if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup("null"); ist->discard = 0; ist->st->discard = AVDISCARD_NONE; break; } } if(!ost->sync_ist){ av_log(NULL, AV_LOG_FATAL, "Missing %s stream which is required by this ffm\n", av_get_media_type_string(ost->st->codec->codec_type)); exit_program(1); } } } else if (!o->nb_stream_maps) { char *subtitle_codec_name = NULL; if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) { int area = 0, idx = -1; int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0); for (i = 0; i < nb_input_streams; i++) { int new_area; ist = input_streams[i]; new_area = ist->st->codec->width * ist->st->codec->height; if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) new_area = 1; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && new_area > area) { if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) continue; area = new_area; idx = i; } } if (idx >= 0) new_video_stream(o, oc, idx); } if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } if (idx >= 0) new_audio_stream(o, oc, idx); } MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, "s"); if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { new_subtitle_stream(o, oc, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; if (map->linklabel) { FilterGraph *fg; OutputFilter *ofilter = NULL; int j, k; for (j = 0; j < nb_filtergraphs; j++) { fg = filtergraphs[j]; for (k = 0; k < fg->nb_outputs; k++) { AVFilterInOut *out = fg->outputs[k]->out_tmp; if (out && !strcmp(out->name, map->linklabel)) { ofilter = fg->outputs[k]; goto loop_end; } } } loop_end: if (!ofilter) { av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist " "in any defined filter graph, or was already used elsewhere.\n", map->linklabel); exit_program(1); } init_output_filter(ofilter, o, oc); } else { int src_idx = input_files[map->file_index]->ist_index + map->stream_index; ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index]; if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) continue; if(o-> audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) continue; if(o-> video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) continue; if(o-> data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA) continue; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break; default: av_log(NULL, AV_LOG_FATAL, "Cannot map stream #%d:%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } } } } for (i = 0; i < o->nb_attachments; i++) { AVIOContext *pb; uint8_t *attachment; const char *p; int64_t len; if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) { av_log(NULL, AV_LOG_FATAL, "Could not open attachment file %s.\n", o->attachments[i]); exit_program(1); } if ((len = avio_size(pb)) <= 0) { av_log(NULL, AV_LOG_FATAL, "Could not get size of the attachment %s.\n", o->attachments[i]); exit_program(1); } if (!(attachment = av_malloc(len))) { av_log(NULL, AV_LOG_FATAL, "Attachment %s too large to fit into memory.\n", o->attachments[i]); exit_program(1); } avio_read(pb, attachment, len); ost = new_attachment_stream(o, oc, -1); ost->stream_copy = 0; ost->attachment_filename = o->attachments[i]; ost->finished = 1; ost->st->codec->extradata = attachment; ost->st->codec->extradata_size = len; p = strrchr(o->attachments[i], '/'); av_dict_set(&ost->st->metadata, "filename", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE); avio_close(pb); } for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { AVDictionaryEntry *e; ost = output_streams[i]; if ((ost->stream_copy || ost->attachment_filename) && (e = av_dict_get(o->g->codec_opts, "flags", NULL, AV_DICT_IGNORE_SUFFIX)) && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6))) if (av_opt_set(ost->st->codec, "flags", e->value, 0) < 0) exit_program(1); } unused_opts = strip_specifiers(o->g->codec_opts); for (i = [[show]]->ost_index; i < nb_output_streams; i++) { e = NULL; while ((e = av_dict_get(output_streams[i]->opts, "", e, AV_DICT_IGNORE_SUFFIX))) av_dict_set(&unused_opts, e->key, NULL, 0); } e = NULL; while ((e = av_dict_get(unused_opts, "", e, AV_DICT_IGNORE_SUFFIX))) { const AVClass *class = avcodec_get_class(); const AVOption *option = av_opt_find(&class, e->key, NULL, 0, AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ); if (!option) continue; if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) { av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for " "output file #%d (%s) is not an encoding option.\n", e->key, option->help ? option->help : "", nb_output_files - 1, filename); exit_program(1); } if (!strcmp(e->key, "gop_timecode")) continue; av_log(NULL, AV_LOG_WARNING, "Codec AVOption %s (%s) specified for " "output file #%d (%s) has not been used for any stream. The most " "likely reason is either wrong type (e.g. a video option with " "no video streams) or that it is a private option of some encoder " "which was not actually used for any stream.\n", e->key, option->help ? option->help : "", nb_output_files - 1, filename); } av_dict_free(&unused_opts); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { assert_file_overwrite(filename); if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE, &oc->interrupt_callback, &[[show]]->opts)) < 0) { print_error(filename, err); exit_program(1); } } else if (strcmp(oc->oformat->name, "image2")==0 && !av_filename_number_test(filename)) assert_file_overwrite(filename); if (o->mux_preload) { uint8_t buf[64]; snprintf(buf, sizeof(buf), "%d", (int)(o->mux_preload*AV_TIME_BASE)); av_dict_set(&[[show]]->opts, "preload", buf, 0); } oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE); for (i = 0; i < o->nb_metadata_map; i++) { char *p; int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0); if (in_file_index >= nb_input_files) { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d while processing metadata maps\n", in_file_index); exit_program(1); } copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc, in_file_index >= 0 ? input_files[in_file_index]->ctx : NULL, o); } if (o->chapters_input_file >= nb_input_files) { if (o->chapters_input_file == INT_MAX) { o->chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i]->ctx->nb_chapters) { o->chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d in chapter mapping.\n", o->chapters_input_file); exit_program(1); } } if (o->chapters_input_file >= 0) copy_chapters(input_files[o->chapters_input_file], [[show]], !o->metadata_chapters_manual); if (!o->metadata_global_manual && nb_input_files){ av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata, AV_DICT_DONT_OVERWRITE); if(o->recording_time != INT64_MAX) av_dict_set(&oc->metadata, "duration", NULL, 0); av_dict_set(&oc->metadata, "creation_time", NULL, 0); } if (!o->metadata_streams_manual) for (i = [[show]]->ost_index; i < nb_output_streams; i++) { InputStream *ist; if (output_streams[i]->source_index < 0) continue; ist = input_streams[output_streams[i]->source_index]; av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } for (i = 0; i < o->nb_metadata; i++) { AVDictionary **m; char type, *val; const char *stream_spec; int index = 0, j, ret = 0; val = strchr(o->metadata[i].u.str, '='); if (!val) { av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n", o->metadata[i].u.str); exit_program(1); } *val++ = 0; parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec); if (type == 's') { for (j = 0; j < oc->nb_streams; j++) { if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) { av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0); } else if (ret < 0) exit_program(1); } } else { switch (type) { case 'g': m = &oc->metadata; break; case 'c': if (index < 0 || index >= oc->nb_chapters) { av_log(NULL, AV_LOG_FATAL, "Invalid chapter index %d in metadata specifier.\n", index); exit_program(1); } m = &oc->chapters[index]->metadata; break; default: av_log(NULL, AV_LOG_FATAL, "Invalid metadata specifier %s.\n", o->metadata[i].specifier); exit_program(1); } av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0); } } return 0; }[Succeeded / Failed / Skipped / Total] 115 / 19 / 86 / 220:   8%|▊         | 220/2690 [31:27<5:53:16,  8.58s/it][Succeeded / Failed / Skipped / Total] 115 / 19 / 86 / 220:   8%|▊         | 221/2690 [31:28<5:51:34,  8.54s/it][Succeeded / Failed / Skipped / Total] 115 / 20 / 86 / 221:   8%|▊         | 221/2690 [31:28<5:51:34,  8.54s/it][Succeeded / Failed / Skipped / Total] 115 / 20 / 86 / 221:   8%|▊         | 222/2690 [31:28<5:49:53,  8.51s/it][Succeeded / Failed / Skipped / Total] 115 / 20 / 87 / 222:   8%|▊         | 222/2690 [31:28<5:49:53,  8.51s/it][Succeeded / Failed / Skipped / Total] 115 / 20 / 87 / 222:   8%|▊         | 223/2690 [31:33<5:49:02,  8.49s/it][Succeeded / Failed / Skipped / Total] 116 / 20 / 87 / 223:   8%|▊         | 223/2690 [31:33<5:49:02,  8.49s/it][Succeeded / Failed / Skipped / Total] 116 / 20 / 87 / 223:   8%|▊         | 224/2690 [31:33<5:47:25,  8.45s/it][Succeeded / Failed / Skipped / Total] 116 / 20 / 88 / 224:   8%|▊         | 224/2690 [31:33<5:47:25,  8.45s/it][Succeeded / Failed / Skipped / Total] 116 / 20 / 88 / 224:   8%|▊         | 225/2690 [31:55<5:49:45,  8.51s/it][Succeeded / Failed / Skipped / Total] 117 / 20 / 88 / 225:   8%|▊         | 225/2690 [31:55<5:49:45,  8.51s/it][Succeeded / Failed / Skipped / Total] 117 / 20 / 88 / 225:   8%|▊         | 226/2690 [31:55<5:48:09,  8.48s/it][Succeeded / Failed / Skipped / Total] 117 / 20 / 89 / 226:   8%|▊         | 226/2690 [31:55<5:48:09,  8.48s/it][Succeeded / Failed / Skipped / Total] 117 / 20 / 89 / 226:   8%|▊         | 227/2690 [32:01<5:47:25,  8.46s/it][Succeeded / Failed / Skipped / Total] 118 / 20 / 89 / 227:   8%|▊         | 227/2690 [32:01<5:47:25,  8.46s/it][Succeeded / Failed / Skipped / Total] 118 / 20 / 89 / 227:   8%|▊         | 228/2690 [32:23<5:49:45,  8.52s/it]
--------------------------------------------- Result 221 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int vqa_decode_init(AVCodecContext *[[avctx]]) { VqaContext *[[s]] = (VqaContext *)[[avctx]]->priv_data; unsigned char *[[vqa_header]]; int i, j, codebook_index;; [[s]]->avctx = [[avctx]]; [[avctx]]->pix_fmt = PIX_FMT_PAL8; [[avctx]]->has_b_frames = 0; dsputil_init(&[[s]]->dsp, [[avctx]]); if ([[s]]->avctx->extradata_size != VQA_HEADER_SIZE) { av_log([[s]]->avctx, AV_LOG_ERROR, " VQA video: expected extradata size of %d\n", VQA_HEADER_SIZE); [[vqa_header]] = (unsigned char *)[[s]]->avctx->extradata; [[s]]->vqa_version = [[vqa_header]][0]; [[s]]->width = LE_16(&[[vqa_header]][6]); [[s]]->height = LE_16(&[[vqa_header]][8]); [[s]]->vector_width = [[vqa_header]][10]; [[s]]->vector_height = [[vqa_header]][11]; [[s]]->partial_count = [[s]]->partial_countdown = [[vqa_header]][13]; if (([[s]]->vector_width != 4) || (([[s]]->vector_height != 2) && ([[s]]->vector_height != 4))) { [[s]]->codebook_size = MAX_CODEBOOK_SIZE; [[s]]->codebook = av_malloc([[s]]->codebook_size); [[s]]->next_codebook_buffer = av_malloc([[s]]->codebook_size); if ([[s]]->vector_height == 4) { codebook_index = 0xFF00 * 16; for (i = 0; i < 256; i++) for (j = 0; j < 16; j++) [[s]]->codebook[codebook_index++] = i; } else { codebook_index = 0xF00 * 8; for (i = 0; i < 256; i++) for (j = 0; j < 8; j++) [[s]]->codebook[codebook_index++] = i; [[s]]->next_codebook_buffer_index = 0; [[s]]->decode_buffer_size = ([[s]]->width / [[s]]->vector_width) * ([[s]]->height / [[s]]->vector_height) * 2; [[s]]->decode_buffer = av_malloc([[s]]->decode_buffer_size); [[s]]->frame.data[0] = NULL; return 0;

[[[[Adv]]]]: static int vqa_decode_init(AVCodecContext *[[eratzf]]) { VqaContext *[[с]] = (VqaContext *)[[eratzf]]->priv_data; unsigned char *[[aقlogbane]]; int i, j, codebook_index;; [[с]]->avctx = [[eratzf]]; [[eratzf]]->pix_fmt = PIX_FMT_PAL8; [[eratzf]]->has_b_frames = 0; dsputil_init(&[[с]]->dsp, [[eratzf]]); if ([[с]]->avctx->extradata_size != VQA_HEADER_SIZE) { av_log([[с]]->avctx, AV_LOG_ERROR, " VQA video: expected extradata size of %d\n", VQA_HEADER_SIZE); [[aقlogbane]] = (unsigned char *)[[с]]->avctx->extradata; [[с]]->vqa_version = [[aقlogbane]][0]; [[с]]->width = LE_16(&[[aقlogbane]][6]); [[с]]->height = LE_16(&[[aقlogbane]][8]); [[с]]->vector_width = [[aقlogbane]][10]; [[с]]->vector_height = [[aقlogbane]][11]; [[с]]->partial_count = [[с]]->partial_countdown = [[aقlogbane]][13]; if (([[с]]->vector_width != 4) || (([[с]]->vector_height != 2) && ([[с]]->vector_height != 4))) { [[с]]->codebook_size = MAX_CODEBOOK_SIZE; [[с]]->codebook = av_malloc([[с]]->codebook_size); [[с]]->next_codebook_buffer = av_malloc([[с]]->codebook_size); if ([[с]]->vector_height == 4) { codebook_index = 0xFF00 * 16; for (i = 0; i < 256; i++) for (j = 0; j < 16; j++) [[с]]->codebook[codebook_index++] = i; } else { codebook_index = 0xF00 * 8; for (i = 0; i < 256; i++) for (j = 0; j < 8; j++) [[с]]->codebook[codebook_index++] = i; [[с]]->next_codebook_buffer_index = 0; [[с]]->decode_buffer_size = ([[с]]->width / [[с]]->vector_width) * ([[с]]->height / [[с]]->vector_height) * 2; [[с]]->decode_buffer = av_malloc([[с]]->decode_buffer_size); [[с]]->frame.data[0] = NULL; return 0;
--------------------------------------------- Result 222 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn) { if (r < 0 || r > 15) { fprintf(stderr, "wrong register write $p%d\n", r); } if (r == PR_BZ || r == PR_WZ || r == PR_DZ) { return; } else if (r == PR_SRS) { tcg_gen_andi_tl(cpu_PR[r], tn, 3); } else { if (r == PR_PID) { gen_helper_tlb_flush_pid(cpu_env, tn); } if (dc->tb_flags & S_FLAG && r == PR_SPC) { gen_helper_spc_write(cpu_env, tn); } else if (r == PR_CCS) { dc->cpustate_changed = 1; } tcg_gen_mov_tl(cpu_PR[r], tn); } }
--------------------------------------------- Result 223 ---------------------------------------------
[[0 (82%)]] --> [[0 (49%)]] --> Socre: 0.5062955021858215

[[[[Adv]]]]: static int add_candidate_ref(HEVCContext *s, RefPicList *[[list]], int poc, int ref_flag) { HEVCFrame *ref = find_ref_idx(s, poc); if (ref == s->ref) return AVERROR_INVALIDDATA; if (!ref) { ref = generate_missing_ref(s, poc); if (!ref) return AVERROR(ENOMEM); } [[list]]->list[[[list]]->nb_refs] = ref->poc; [[list]]->ref[[[list]]->nb_refs] = ref; [[list]]->nb_refs++; mark_ref(ref, ref_flag); return 0; }

[[[[Adv]]]]: static int add_candidate_ref(HEVCContext *s, RefPicList *[[label]], int poc, int ref_flag) { HEVCFrame *ref = find_ref_idx(s, poc); if (ref == s->ref) return AVERROR_INVALIDDATA; if (!ref) { ref = generate_missing_ref(s, poc); if (!ref) return AVERROR(ENOMEM); } [[label]]->list[[[label]]->nb_refs] = ref->poc; [[label]]->ref[[[label]]->nb_refs] = ref; [[label]]->nb_refs++; mark_ref(ref, ref_flag); return 0; }
--------------------------------------------- Result 224 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int net_vhost_user_init(NetClientState *peer, const char *device, const char *name, CharDriverState *chr, int queues) { NetClientState *nc; VhostUserState *s; int i; for (i = 0; i < queues; i++) { nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name); snprintf(nc->info_str, sizeof(nc->info_str), "vhost-user%d to %s", i, chr->label); nc->queue_index = i; s = DO_UPCAST(VhostUserState, nc, nc); s->chr = chr; } qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name); return 0; }
--------------------------------------------- Result 225 ---------------------------------------------
[[0 (1%)]] --> [[0 (55%)]] --> Socre: 0.5483810305595398

[[[[Adv]]]]: void ff_avg_h264_qpel4_mc31_msa(uint8_t *[[dst]], const uint8_t *src, ptrdiff_t [[stride]]) { avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2, src - ([[stride]] * 2) + sizeof(uint8_t), [[stride]], [[dst]], [[stride]]); }

[[[[Adv]]]]: void ff_avg_h264_qpel4_mc31_msa(uint8_t *[[tisτ]], const uint8_t *src, ptrdiff_t [[gallery]]) { avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2, src - ([[gallery]] * 2) + sizeof(uint8_t), [[gallery]], [[tisτ]], [[gallery]]); }
--------------------------------------------- Result 226 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_read_data(SCSIDevice *d, uint32_t tag) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d); SCSIDiskReq *r; r = scsi_find_request(s, tag); if (!r) { BADF("Bad read tag 0x%x\n", tag); scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR); return; } assert(r->req.aiocb == NULL); scsi_read_request(r); }
--------------------------------------------- Result 227 ---------------------------------------------
[[0 (6%)]] --> [[0 (54%)]] --> Socre: 0.539655864238739

[[[[Adv]]]]: static int flv_probe(AVProbeData *[[p]]) { const uint8_t *[[d]]; if ([[p]]->buf_size < 6) return 0; [[d]] = [[p]]->buf; if ([[d]][0] == 'F' && [[d]][1] == 'L' && [[d]][2] == 'V' && [[d]][3] < 5 && [[d]][5]==0) { return AVPROBE_SCORE_MAX; } return 0; }

[[[[Adv]]]]: static int flv_probe(AVProbeData *[[pr]]) { const uint8_t *[[design]]; if ([[pr]]->buf_size < 6) return 0; [[design]] = [[pr]]->buf; if ([[design]][0] == 'F' && [[design]][1] == 'L' && [[design]][2] == 'V' && [[design]][3] < 5 && [[design]][5]==0) { return AVPROBE_SCORE_MAX; } return 0; }
--------------------------------------------- Result 228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 119 / 20 / 89 / 228:   8%|▊         | 228/2690 [32:23<5:49:45,  8.52s/it][Succeeded / Failed / Skipped / Total] 119 / 20 / 89 / 228:   9%|▊         | 229/2690 [32:23<5:48:10,  8.49s/it][Succeeded / Failed / Skipped / Total] 119 / 20 / 90 / 229:   9%|▊         | 229/2690 [32:23<5:48:10,  8.49s/it][Succeeded / Failed / Skipped / Total] 119 / 20 / 90 / 229:   9%|▊         | 230/2690 [32:26<5:47:01,  8.46s/it][[0 (19%)]] --> [[0 (54%)]] --> Socre: 0.5375017523765564

[[[[Adv]]]]: static int spawn_thread(void) { pthread_attr_t attr; int [[ret]]; cur_threads++; idle_threads++; pthread_attr_init(&attr); pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); [[ret]] = pthread_create(&thread_id, &attr, aio_thread, NULL); pthread_attr_destroy(&attr); return [[ret]]; }

[[[[Adv]]]]: static int spawn_thread(void) { pthread_attr_t attr; int [[tast]]; cur_threads++; idle_threads++; pthread_attr_init(&attr); pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); [[tast]] = pthread_create(&thread_id, &attr, aio_thread, NULL); pthread_attr_destroy(&attr); return [[tast]]; }
--------------------------------------------- Result 229 ---------------------------------------------
[[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_gab2_sub(AVStream *st, AVPacket *pkt) { if (pkt->size >= 7 && !strcmp(pkt->data, "GAB2") && AV_RL16(pkt->data + 5) == 2) { uint8_t desc[256]; int score = AVPROBE_SCORE_EXTENSION, ret; AVIStream *ast = st->priv_data; AVInputFormat *sub_demuxer; AVRational time_base; AVIOContext *pb = avio_alloc_context(pkt->data + 7, pkt->size - 7, 0, NULL, NULL, NULL, NULL); AVProbeData pd; unsigned int desc_len = avio_rl32(pb); if (desc_len > pb->buf_end - pb->buf_ptr) goto error; ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc)); avio_skip(pb, desc_len - ret); if (*desc) av_dict_set(&st->metadata, "title", desc, 0); avio_rl16(pb); avio_rl32(pb); pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr }; if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score))) goto error; if (!(ast->sub_ctx = avformat_alloc_context())) goto error; ast->sub_ctx->pb = pb; if (!avformat_open_input(&ast->sub_ctx, "", sub_demuxer, NULL)) { ff_read_packet(ast->sub_ctx, &ast->sub_pkt); *st->codec = *ast->sub_ctx->streams[0]->codec; ast->sub_ctx->streams[0]->codec->extradata = NULL; time_base = ast->sub_ctx->streams[0]->time_base; avpriv_set_pts_info(st, 64, time_base.num, time_base.den); } ast->sub_buffer = pkt->data; memset(pkt, 0, sizeof(*pkt)); return 1; error: av_freep(&pb); } return 0; }
--------------------------------------------- Result 230 ---------------------------------------------
[[0 (42%)]] --> [[0 (97%)]] --> Socre: 0.9705491662025452

[[[[Adv]]]]: static void opt_output_file(void *optctx, const char *[[filename]]) { OptionsContext *o = optctx; AVFormatContext *oc; int i, err; AVOutputFormat *file_oformat; OutputStream *ost; InputStream *ist; if (!strcmp([[filename]], "-")) [[filename]] = "pipe:"; oc = avformat_alloc_context(); if (!oc) { print_error([[filename]], AVERROR(ENOMEM)); exit_program(1); } if (last_asked_format) { file_oformat = av_guess_format(last_asked_format, NULL, NULL); if (!file_oformat) { fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format); exit_program(1); } last_asked_format = NULL; } else { file_oformat = av_guess_format(NULL, [[filename]], NULL); if (!file_oformat) { fprintf(stderr, "Unable to find a suitable output format for '%s'\n", [[filename]]); exit_program(1); } } oc->oformat = file_oformat; av_strlcpy(oc->filename, [[filename]], sizeof(oc->filename)); if (!strcmp(file_oformat->name, "ffm") && av_strstart([[filename]], "http:", NULL)) { int err = read_avserver_streams(oc, [[filename]]); if (err < 0) { print_error([[filename]], err); exit_program(1); } } else if (!o->nb_stream_maps) { #define NEW_STREAM(type, index)\ if (index >= 0) {\ ost = new_ ## type ## _stream(oc);\ ost->source_index = index;\ ost->sync_ist = &input_streams[index];\ input_streams[index].discard = 0;\ } if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) { int area = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ist->st->codec->width * ist->st->codec->height > area) { area = ist->st->codec->width * ist->st->codec->height; idx = i; } } NEW_STREAM(video, idx); } if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } NEW_STREAM(audio, idx); } if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { NEW_STREAM(subtitle, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index]; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream(oc); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream(oc); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream(oc); break; default: av_log(NULL, AV_LOG_ERROR, "Cannot map stream #%d.%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } ost->source_index = input_files[map->file_index].ist_index + map->stream_index; ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index + map->sync_stream_index]; ist->discard = 0; } } av_dict_copy(&oc->metadata, metadata, 0); av_dict_free(&metadata); output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1); output_files[nb_output_files - 1].ctx = oc; output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams; output_files[nb_output_files - 1].recording_time = o->recording_time; output_files[nb_output_files - 1].start_time = o->start_time; output_files[nb_output_files - 1].limit_filesize = limit_filesize; av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { if (!file_overwrite && (strchr([[filename]], ':') == NULL || [[filename]][1] == ':' || av_strstart([[filename]], "file:", NULL))) { if (avio_check([[filename]], 0) == 0) { if (!using_stdin) { fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", [[filename]]); fflush(stderr); if (!read_yesno()) { fprintf(stderr, "Not overwriting - exiting\n"); exit_program(1); } } else { fprintf(stderr,"File '%s' already exists. Exiting.\n", [[filename]]); exit_program(1); } } } if ((err = avio_open(&oc->pb, [[filename]], AVIO_FLAG_WRITE)) < 0) { print_error([[filename]], err); exit_program(1); } } oc->preload= (int)(mux_preload*AV_TIME_BASE); oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE); oc->flags |= AVFMT_FLAG_NONBLOCK; if (chapters_input_file >= nb_input_files) { if (chapters_input_file == INT_MAX) { chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i].ctx->nb_chapters) { chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_ERROR, "Invalid input file index %d in chapter mapping.\n", chapters_input_file); exit_program(1); } } if (chapters_input_file >= 0) copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]); for (i = 0; i < nb_meta_data_maps; i++) { AVFormatContext *files[2]; AVDictionary **meta[2]; int j; #define METADATA_CHECK_INDEX(index, nb_elems, desc)\ if ((index) < 0 || (index) >= (nb_elems)) {\ av_log(NULL, AV_LOG_ERROR, "Invalid %s index %d while processing metadata maps\n",\ (desc), (index));\ exit_program(1);\ } int in_file_index = meta_data_maps[i][1].file; if (in_file_index < 0) continue; METADATA_CHECK_INDEX(in_file_index, nb_input_files, "input file") files[0] = oc; files[1] = input_files[in_file_index].ctx; for (j = 0; j < 2; j++) { MetadataMap *map = &meta_data_maps[i][j]; switch (map->type) { case 'g': meta[j] = &files[j]->metadata; break; case 's': METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, "stream") meta[j] = &files[j]->streams[map->index]->metadata; break; case 'c': METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, "chapter") meta[j] = &files[j]->chapters[map->index]->metadata; break; case 'p': METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, "program") meta[j] = &files[j]->programs[map->index]->metadata; break; } } av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE); } if (metadata_global_autocopy && nb_input_files) av_dict_copy(&oc->metadata, input_files[0].ctx->metadata, AV_DICT_DONT_OVERWRITE); if (metadata_streams_autocopy) for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) { InputStream *ist = &input_streams[output_streams[i].source_index]; av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } frame_rate = (AVRational){0, 0}; frame_width = 0; frame_height = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; chapters_input_file = INT_MAX; limit_filesize = UINT64_MAX; av_freep(&meta_data_maps); nb_meta_data_maps = 0; metadata_global_autocopy = 1; metadata_streams_autocopy = 1; metadata_chapters_autocopy = 1; av_freep(&streamid_map); nb_streamid_map = 0; av_dict_free(&codec_names); av_freep(&forced_key_frames); reset_options(o); }

[[[[Adv]]]]: static void opt_output_file(void *optctx, const char *[[eyebase]]) { OptionsContext *o = optctx; AVFormatContext *oc; int i, err; AVOutputFormat *file_oformat; OutputStream *ost; InputStream *ist; if (!strcmp([[eyebase]], "-")) [[eyebase]] = "pipe:"; oc = avformat_alloc_context(); if (!oc) { print_error([[eyebase]], AVERROR(ENOMEM)); exit_program(1); } if (last_asked_format) { file_oformat = av_guess_format(last_asked_format, NULL, NULL); if (!file_oformat) { fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format); exit_program(1); } last_asked_format = NULL; } else { file_oformat = av_guess_format(NULL, [[eyebase]], NULL); if (!file_oformat) { fprintf(stderr, "Unable to find a suitable output format for '%s'\n", [[eyebase]]); exit_program(1); } } oc->oformat = file_oformat; av_strlcpy(oc->filename, [[eyebase]], sizeof(oc->filename)); if (!strcmp(file_oformat->name, "ffm") && av_strstart([[eyebase]], "http:", NULL)) { int err = read_avserver_streams(oc, [[eyebase]]); if (err < 0) { print_error([[eyebase]], err); exit_program(1); } } else if (!o->nb_stream_maps) { #define NEW_STREAM(type, index)\ if (index >= 0) {\ ost = new_ ## type ## _stream(oc);\ ost->source_index = index;\ ost->sync_ist = &input_streams[index];\ input_streams[index].discard = 0;\ } if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) { int area = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ist->st->codec->width * ist->st->codec->height > area) { area = ist->st->codec->width * ist->st->codec->height; idx = i; } } NEW_STREAM(video, idx); } if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } NEW_STREAM(audio, idx); } if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { NEW_STREAM(subtitle, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index]; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream(oc); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream(oc); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream(oc); break; default: av_log(NULL, AV_LOG_ERROR, "Cannot map stream #%d.%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } ost->source_index = input_files[map->file_index].ist_index + map->stream_index; ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index + map->sync_stream_index]; ist->discard = 0; } } av_dict_copy(&oc->metadata, metadata, 0); av_dict_free(&metadata); output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1); output_files[nb_output_files - 1].ctx = oc; output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams; output_files[nb_output_files - 1].recording_time = o->recording_time; output_files[nb_output_files - 1].start_time = o->start_time; output_files[nb_output_files - 1].limit_filesize = limit_filesize; av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { if (!file_overwrite && (strchr([[eyebase]], ':') == NULL || [[eyebase]][1] == ':' || av_strstart([[eyebase]], "file:", NULL))) { if (avio_check([[eyebase]], 0) == 0) { if (!using_stdin) { fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", [[eyebase]]); fflush(stderr); if (!read_yesno()) { fprintf(stderr, "Not overwriting - exiting\n"); exit_program(1); } } else { fprintf(stderr,"File '%s' already exists. Exiting.\n", [[eyebase]]); exit_program(1); } } } if ((err = avio_open(&oc->pb, [[eyebase]], AVIO_FLAG_WRITE)) < 0) { print_error([[eyebase]], err); exit_program(1); } } oc->preload= (int)(mux_preload*AV_TIME_BASE); oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE); oc->flags |= AVFMT_FLAG_NONBLOCK; if (chapters_input_file >= nb_input_files) { if (chapters_input_file == INT_MAX) { chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i].ctx->nb_chapters) { chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_ERROR, "Invalid input file index %d in chapter mapping.\n", chapters_input_file); exit_program(1); } } if (chapters_input_file >= 0) copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]); for (i = 0; i < nb_meta_data_maps; i++) { AVFormatContext *files[2]; AVDictionary **meta[2]; int j; #define METADATA_CHECK_INDEX(index, nb_elems, desc)\ if ((index) < 0 || (index) >= (nb_elems)) {\ av_log(NULL, AV_LOG_ERROR, "Invalid %s index %d while processing metadata maps\n",\ (desc), (index));\ exit_program(1);\ } int in_file_index = meta_data_maps[i][1].file; if (in_file_index < 0) continue; METADATA_CHECK_INDEX(in_file_index, nb_input_files, "input file") files[0] = oc; files[1] = input_files[in_file_index].ctx; for (j = 0; j < 2; j++) { MetadataMap *map = &meta_data_maps[i][j]; switch (map->type) { case 'g': meta[j] = &files[j]->metadata; break; case 's': METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, "stream") meta[j] = &files[j]->streams[map->index]->metadata; break; case 'c': METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, "chapter") meta[j] = &files[j]->chapters[map->index]->metadata; break; case 'p': METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, "program") meta[j] = &files[j]->programs[map->index]->metadata; break; } } av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE); } if (metadata_global_autocopy && nb_input_files) av_dict_copy(&oc->metadata, input_files[0].ctx->metadata, AV_DICT_DONT_OVERWRITE); if (metadata_streams_autocopy) for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) { InputStream *ist = &input_streams[output_streams[i].source_index]; av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } frame_rate = (AVRational){0, 0}; frame_width = 0; frame_height = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; chapters_input_file = INT_MAX; limit_filesize = UINT64_MAX; av_freep(&meta_data_maps); nb_meta_data_maps = 0; metadata_global_autocopy = 1; metadata_streams_autocopy = 1; metadata_chapters_autocopy = 1; av_freep(&streamid_map); nb_streamid_map = 0; av_dict_free(&codec_names); av_freep(&forced_key_frames); reset_options(o); }[Succeeded / Failed / Skipped / Total] 120 / 20 / 90 / 230:   9%|▊         | 230/2690 [32:26<5:47:01,  8.46s/it][Succeeded / Failed / Skipped / Total] 120 / 20 / 90 / 230:   9%|▊         | 231/2690 [32:27<5:45:27,  8.43s/it][Succeeded / Failed / Skipped / Total] 120 / 20 / 91 / 231:   9%|▊         | 231/2690 [32:27<5:45:27,  8.43s/it][Succeeded / Failed / Skipped / Total] 120 / 20 / 91 / 231:   9%|▊         | 232/2690 [32:36<5:45:29,  8.43s/it][Succeeded / Failed / Skipped / Total] 120 / 21 / 91 / 232:   9%|▊         | 232/2690 [32:36<5:45:29,  8.43s/it][Succeeded / Failed / Skipped / Total] 120 / 21 / 91 / 232:   9%|▊         | 233/2690 [32:37<5:43:58,  8.40s/it]
--------------------------------------------- Result 231 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn) { uint32_t rd; TCGv tmp, tmp2; if (arm_feature(env, ARM_FEATURE_M)) return 1; if ((insn & (1 << 25)) == 0) { if (insn & (1 << 20)) { return 1; } return 0; } if ((insn & (1 << 4)) == 0) { return 1; } if (IS_USER(s) && !cp15_user_ok(insn)) { return 1; } if ((insn & 0x0fff0fff) == 0x0e070f90 || (insn & 0x0fff0fff) == 0x0e070f58) { gen_set_pc_im(s->pc); s->is_jmp = DISAS_WFI; return 0; } rd = (insn >> 12) & 0xf; if (cp15_tls_load_store(env, s, insn, rd)) return 0; tmp2 = tcg_const_i32(insn); if (insn & ARM_CP_RW_BIT) { tmp = new_tmp(); gen_helper_get_cp15(tmp, cpu_env, tmp2); if (rd != 15) store_reg(s, rd, tmp); else dead_tmp(tmp); } else { tmp = load_reg(s, rd); gen_helper_set_cp15(cpu_env, tmp2, tmp); dead_tmp(tmp); if (!arm_feature(env, ARM_FEATURE_XSCALE) || (insn & 0x0fff0fff) != 0x0e010f10) gen_lookup_tb(s); } tcg_temp_free_i32(tmp2); return 0; }
--------------------------------------------- Result 232 ---------------------------------------------
[[0 (70%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int vorbis_parse_id_hdr(vorbis_context *[[vc]]){ GetBitContext *[[gb]]=&[[vc]]->gb; uint_fast8_t [[bl0]], bl1; if ((get_bits([[gb]], 8)!='v') || (get_bits([[gb]], 8)!='o') || (get_bits([[gb]], 8)!='r') || (get_bits([[gb]], 8)!='b') || (get_bits([[gb]], 8)!='i') || (get_bits([[gb]], 8)!='s')) { av_log([[vc]]->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (no vorbis signature). \n"); return 1; } [[vc]]->version=get_bits_long([[gb]], 32); [[vc]]->audio_channels=get_bits([[gb]], 8); [[vc]]->audio_samplerate=get_bits_long([[gb]], 32); [[vc]]->bitrate_maximum=get_bits_long([[gb]], 32); [[vc]]->bitrate_nominal=get_bits_long([[gb]], 32); [[vc]]->bitrate_minimum=get_bits_long([[gb]], 32); [[bl0]]=get_bits([[gb]], 4); bl1=get_bits([[gb]], 4); [[vc]]->blocksize[0]=(1<<[[bl0]]); [[vc]]->blocksize[1]=(1<<bl1); if ([[bl0]]>13 || [[bl0]]<6 || bl1>13 || bl1<6 || bl1<[[bl0]]) { av_log([[vc]]->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (illegal blocksize). \n"); return 3; } if ([[vc]]->blocksize[1]/2 * [[vc]]->audio_channels * 2 > AVCODEC_MAX_AUDIO_FRAME_SIZE) { av_log([[vc]]->avccontext, AV_LOG_ERROR, "Vorbis channel count makes " "output packets too large.\n"); return 4; } [[vc]]->win[0]=ff_vorbis_vwin[[[bl0]]-6]; [[vc]]->win[1]=ff_vorbis_vwin[bl1-6]; if([[vc]]->exp_bias){ int i, j; for(j=0; j<2; j++){ float *win = av_malloc([[vc]]->blocksize[j]/2 * sizeof(float)); for(i=0; i<[[vc]]->blocksize[j]/2; i++) win[i] = [[vc]]->win[j][i] * (1<<15); [[vc]]->win[j] = win; } } if ((get_bits1([[gb]])) == 0) { av_log([[vc]]->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (framing flag not set). \n"); return 2; } [[vc]]->channel_residues= av_malloc(([[vc]]->blocksize[1]/2)*[[vc]]->audio_channels * sizeof(float)); [[vc]]->channel_floors = av_malloc(([[vc]]->blocksize[1]/2)*[[vc]]->audio_channels * sizeof(float)); [[vc]]->saved = av_mallocz(([[vc]]->blocksize[1]/2)*[[vc]]->audio_channels * sizeof(float)); [[vc]]->ret = av_malloc(([[vc]]->blocksize[1]/2)*[[vc]]->audio_channels * sizeof(float)); [[vc]]->buf = av_malloc( [[vc]]->blocksize[1] * sizeof(float)); [[vc]]->buf_tmp = av_malloc( [[vc]]->blocksize[1] * sizeof(float)); [[vc]]->previous_window=0; ff_mdct_init(&[[vc]]->mdct[0], [[bl0]], 1); ff_mdct_init(&[[vc]]->mdct[1], bl1, 1); AV_DEBUG(" vorbis version %d \n audio_channels %d \n audio_samplerate %d \n bitrate_max %d \n bitrate_nom %d \n bitrate_min %d \n blk_0 %d blk_1 %d \n ", [[vc]]->version, [[vc]]->audio_channels, [[vc]]->audio_samplerate, [[vc]]->bitrate_maximum, [[vc]]->bitrate_nominal, [[vc]]->bitrate_minimum, [[vc]]->blocksize[0], [[vc]]->blocksize[1]); return 0; }

[[[[Adv]]]]: static int vorbis_parse_id_hdr(vorbis_context *[[vu]]){ GetBitContext *[[plc]]=&[[vu]]->gb; uint_fast8_t [[rioc7]], bl1; if ((get_bits([[plc]], 8)!='v') || (get_bits([[plc]], 8)!='o') || (get_bits([[plc]], 8)!='r') || (get_bits([[plc]], 8)!='b') || (get_bits([[plc]], 8)!='i') || (get_bits([[plc]], 8)!='s')) { av_log([[vu]]->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (no vorbis signature). \n"); return 1; } [[vu]]->version=get_bits_long([[plc]], 32); [[vu]]->audio_channels=get_bits([[plc]], 8); [[vu]]->audio_samplerate=get_bits_long([[plc]], 32); [[vu]]->bitrate_maximum=get_bits_long([[plc]], 32); [[vu]]->bitrate_nominal=get_bits_long([[plc]], 32); [[vu]]->bitrate_minimum=get_bits_long([[plc]], 32); [[rioc7]]=get_bits([[plc]], 4); bl1=get_bits([[plc]], 4); [[vu]]->blocksize[0]=(1<<[[rioc7]]); [[vu]]->blocksize[1]=(1<<bl1); if ([[rioc7]]>13 || [[rioc7]]<6 || bl1>13 || bl1<6 || bl1<[[rioc7]]) { av_log([[vu]]->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (illegal blocksize). \n"); return 3; } if ([[vu]]->blocksize[1]/2 * [[vu]]->audio_channels * 2 > AVCODEC_MAX_AUDIO_FRAME_SIZE) { av_log([[vu]]->avccontext, AV_LOG_ERROR, "Vorbis channel count makes " "output packets too large.\n"); return 4; } [[vu]]->win[0]=ff_vorbis_vwin[[[rioc7]]-6]; [[vu]]->win[1]=ff_vorbis_vwin[bl1-6]; if([[vu]]->exp_bias){ int i, j; for(j=0; j<2; j++){ float *win = av_malloc([[vu]]->blocksize[j]/2 * sizeof(float)); for(i=0; i<[[vu]]->blocksize[j]/2; i++) win[i] = [[vu]]->win[j][i] * (1<<15); [[vu]]->win[j] = win; } } if ((get_bits1([[plc]])) == 0) { av_log([[vu]]->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (framing flag not set). \n"); return 2; } [[vu]]->channel_residues= av_malloc(([[vu]]->blocksize[1]/2)*[[vu]]->audio_channels * sizeof(float)); [[vu]]->channel_floors = av_malloc(([[vu]]->blocksize[1]/2)*[[vu]]->audio_channels * sizeof(float)); [[vu]]->saved = av_mallocz(([[vu]]->blocksize[1]/2)*[[vu]]->audio_channels * sizeof(float)); [[vu]]->ret = av_malloc(([[vu]]->blocksize[1]/2)*[[vu]]->audio_channels * sizeof(float)); [[vu]]->buf = av_malloc( [[vu]]->blocksize[1] * sizeof(float)); [[vu]]->buf_tmp = av_malloc( [[vu]]->blocksize[1] * sizeof(float)); [[vu]]->previous_window=0; ff_mdct_init(&[[vu]]->mdct[0], [[rioc7]], 1); ff_mdct_init(&[[vu]]->mdct[1], bl1, 1); AV_DEBUG(" vorbis version %d \n audio_channels %d \n audio_samplerate %d \n bitrate_max %d \n bitrate_nom %d \n bitrate_min %d \n blk_0 %d blk_1 %d \n ", [[vu]]->version, [[vu]]->audio_channels, [[vu]]->audio_samplerate, [[vu]]->bitrate_maximum, [[vu]]->bitrate_nominal, [[vu]]->bitrate_minimum, [[vu]]->blocksize[0], [[vu]]->blocksize[1]); return 0; }
--------------------------------------------- Result 233 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 120 / 21 / 92 / 233:   9%|▊         | 233/2690 [32:37<5:43:58,  8.40s/it][Succeeded / Failed / Skipped / Total] 120 / 21 / 92 / 233:   9%|▊         | 234/2690 [32:44<5:43:40,  8.40s/it][Succeeded / Failed / Skipped / Total] 120 / 22 / 92 / 234:   9%|▊         | 234/2690 [32:44<5:43:40,  8.40s/it][Succeeded / Failed / Skipped / Total] 120 / 22 / 92 / 234:   9%|▊         | 235/2690 [33:02<5:45:10,  8.44s/it][Succeeded / Failed / Skipped / Total] 121 / 22 / 92 / 235:   9%|▊         | 235/2690 [33:02<5:45:10,  8.44s/it][Succeeded / Failed / Skipped / Total] 121 / 22 / 92 / 235:   9%|▉         | 236/2690 [33:05<5:44:01,  8.41s/it][Succeeded / Failed / Skipped / Total] 122 / 22 / 92 / 236:   9%|▉         | 236/2690 [33:05<5:44:01,  8.41s/it][Succeeded / Failed / Skipped / Total] 122 / 22 / 92 / 236:   9%|▉         | 237/2690 [33:05<5:42:31,  8.38s/it][Succeeded / Failed / Skipped / Total] 122 / 22 / 93 / 237:   9%|▉         | 237/2690 [33:05<5:42:31,  8.38s/it][Succeeded / Failed / Skipped / Total] 122 / 22 / 93 / 237:   9%|▉         | 238/2690 [33:30<5:45:10,  8.45s/it][Succeeded / Failed / Skipped / Total] 123 / 22 / 93 / 238:   9%|▉         | 238/2690 [33:30<5:45:10,  8.45s/it][Succeeded / Failed / Skipped / Total] 123 / 22 / 93 / 238:   9%|▉         | 239/2690 [33:32<5:43:57,  8.42s/it][Succeeded / Failed / Skipped / Total] 124 / 22 / 93 / 239:   9%|▉         | 239/2690 [33:32<5:43:57,  8.42s/it][Succeeded / Failed / Skipped / Total] 124 / 22 / 93 / 239:   9%|▉         | 240/2690 [33:44<5:44:29,  8.44s/it][Succeeded / Failed / Skipped / Total] 125 / 22 / 93 / 240:   9%|▉         | 240/2690 [33:44<5:44:29,  8.44s/it][Succeeded / Failed / Skipped / Total] 125 / 22 / 93 / 240:   9%|▉         | 241/2690 [34:33<5:51:14,  8.61s/it][[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: USBDevice *usb_host_device_open(const char *devname) { int fd = -1, ret; USBHostDevice *dev = NULL; struct usbdevfs_connectinfo ci; char buf[1024]; int bus_num, addr; char product_name[PRODUCT_NAME_SZ]; dev = qemu_mallocz(sizeof(USBHostDevice)); if (!dev) goto fail; #ifdef DEBUG_ISOCH printf("usb_host_device_open %s\n", devname); #endif if (usb_host_find_device(&bus_num, &addr, product_name, sizeof(product_name), devname) < 0) return NULL; snprintf(buf, sizeof(buf), USBDEVFS_PATH "/%03d/%03d", bus_num, addr); fd = open(buf, O_RDWR | O_NONBLOCK); if (fd < 0) { perror(buf); return NULL; } dev->descr_len = read(fd, dev->descr, sizeof(dev->descr)); if (dev->descr_len <= 0) { perror("usb_host_device_open: reading device data failed"); goto fail; } #ifdef DEBUG { int x; printf("=== begin dumping device descriptor data ===\n"); for (x = 0; x < dev->descr_len; x++) printf("%02x ", dev->descr[x]); printf("\n=== end dumping device descriptor data ===\n"); } #endif dev->fd = fd; dev->configuration = 1; if (!usb_host_update_interfaces(dev, 1)) goto fail; ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci); if (ret < 0) { perror("usb_host_device_open: USBDEVFS_CONNECTINFO"); goto fail; } #ifdef DEBUG printf("host USB device %d.%d grabbed\n", bus_num, addr); #endif ret = usb_linux_update_endp_table(dev); if (ret) goto fail; if (ci.slow) dev->dev.speed = USB_SPEED_LOW; else dev->dev.speed = USB_SPEED_HIGH; dev->dev.handle_packet = usb_generic_handle_packet; dev->dev.handle_reset = usb_host_handle_reset; dev->dev.handle_control = usb_host_handle_control; dev->dev.handle_data = usb_host_handle_data; dev->dev.handle_destroy = usb_host_handle_destroy; if (product_name[0] == '\0') snprintf(dev->dev.devname, sizeof(dev->dev.devname), "host:%s", devname); else pstrcpy(dev->dev.devname, sizeof(dev->dev.devname), product_name); #ifdef USE_ASYNCIO sigemptyset(&sigact.sa_mask); sigact.sa_sigaction = isoch_done; sigact.sa_flags = SA_SIGINFO; sigact.sa_restorer = 0; ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL); if (ret < 0) { perror("usb_host_device_open: sigaction failed"); goto fail; } if (pipe(dev->pipe_fds) < 0) { perror("usb_host_device_open: pipe creation failed"); goto fail; } fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC); fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK); qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev); #endif dev->urbs_ready = 0; return (USBDevice *)dev; fail: if (dev) qemu_free(dev); close(fd); return NULL; }
--------------------------------------------- Result 234 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: bool machine_iommu(MachineState *[[machine]]) { return [[machine]]->iommu; }

[[[[Adv]]]]: bool machine_iommu(MachineState *[[customer]]) { return [[customer]]->iommu; }
--------------------------------------------- Result 235 ---------------------------------------------
[[0 (2%)]] --> [[0 (75%)]] --> Socre: 0.7489598989486694

[[[[Adv]]]]: uint64_t helper_frsp(CPUPPCState *env, uint64_t arg) { CPU_DoubleU [[farg]]; float32 f32; [[farg]].ll = arg; if (unlikely(float64_is_signaling_nan([[farg]].d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } f32 = float64_to_float32([[farg]].d, &env->fp_status); [[farg]].d = float32_to_float64(f32, &env->fp_status); return [[farg]].ll; }

[[[[Adv]]]]: uint64_t helper_frsp(CPUPPCState *env, uint64_t arg) { CPU_DoubleU [[mirɡ]]; float32 f32; [[mirɡ]].ll = arg; if (unlikely(float64_is_signaling_nan([[mirɡ]].d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } f32 = float64_to_float32([[mirɡ]].d, &env->fp_status); [[mirɡ]].d = float32_to_float64(f32, &env->fp_status); return [[mirɡ]].ll; }
--------------------------------------------- Result 236 ---------------------------------------------
[[0 (2%)]] --> [[0 (97%)]] --> Socre: 0.9675554633140564

[[[[Adv]]]]: static CharDriverState *vc_init(const char *id, ChardevBackend *[[backend]], ChardevReturn *[[ret]], Error **errp) { return vc_handler([[backend]]->u.vc, errp); }

[[[[Adv]]]]: static CharDriverState *vc_init(const char *id, ChardevBackend *[[rearrand]], ChardevReturn *[[prτ]], Error **errp) { return vc_handler([[rearrand]]->u.vc, errp); }
--------------------------------------------- Result 237 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length) { CPUArchState *env; int mmu_idx; assert_cpu_is_self(cpu); env = cpu->env_ptr; for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) { unsigned int i; for (i = 0; i < CPU_TLB_SIZE; i++) { tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i], start1, length); } for (i = 0; i < CPU_VTLB_SIZE; i++) { tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i], start1, length); } } }
--------------------------------------------- Result 238 ---------------------------------------------
[[0 (12%)]] --> [[0 (99%)]] --> Socre: 0.9910590052604675

[[[[Adv]]]]: int gen_new_label(void) { TCGContext *s = &tcg_ctx; int [[idx]]; TCGLabel *[[l]]; if (s->nb_labels >= TCG_MAX_LABELS) tcg_abort(); [[idx]] = s->nb_labels++; [[l]] = &s->labels[[[idx]]]; [[l]]->has_value = 0; [[l]]->u.first_reloc = NULL; return [[idx]]; }

[[[[Adv]]]]: int gen_new_label(void) { TCGContext *s = &tcg_ctx; int [[xiv]]; TCGLabel *[[ɫ]]; if (s->nb_labels >= TCG_MAX_LABELS) tcg_abort(); [[xiv]] = s->nb_labels++; [[ɫ]] = &s->labels[[[xiv]]]; [[ɫ]]->has_value = 0; [[ɫ]]->u.first_reloc = NULL; return [[xiv]]; }
--------------------------------------------- Result 239 ---------------------------------------------
[[0 (38%)]] --> [[0 (99%)]] --> Socre: 0.9886493682861328

[[[[Adv]]]]: void bdrv_round_to_clusters(BlockDriverState *bs, int64_t [[sector_num]], int nb_sectors, int64_t *cluster_sector_num, int *cluster_nb_sectors) { BlockDriverInfo bdi; if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) { *cluster_sector_num = [[sector_num]]; *cluster_nb_sectors = nb_sectors; } else { int64_t [[c]] = bdi.cluster_size / BDRV_SECTOR_SIZE; *cluster_sector_num = QEMU_ALIGN_DOWN([[sector_num]], [[c]]); *cluster_nb_sectors = QEMU_ALIGN_UP([[sector_num]] - *cluster_sector_num + nb_sectors, [[c]]); } }

[[[[Adv]]]]: void bdrv_round_to_clusters(BlockDriverState *bs, int64_t [[brandcyunμ]], int nb_sectors, int64_t *cluster_sector_num, int *cluster_nb_sectors) { BlockDriverInfo bdi; if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) { *cluster_sector_num = [[brandcyunμ]]; *cluster_nb_sectors = nb_sectors; } else { int64_t [[rec]] = bdi.cluster_size / BDRV_SECTOR_SIZE; *cluster_sector_num = QEMU_ALIGN_DOWN([[brandcyunμ]], [[rec]]); *cluster_nb_sectors = QEMU_ALIGN_UP([[brandcyunμ]] - *cluster_sector_num + nb_sectors, [[rec]]); } }
--------------------------------------------- Result 240 ---------------------------------------------
[[0 (55%)]] --> [[0 (32%)]] --> Socre: 0.6826301217079163

[[[[Adv]]]]: static int idreg_init1(SysBusDevice *[[dev]]) { IDRegState *s = MACIO_ID_REGISTER([[dev]]); memory_region_init_ram(&s->mem, OBJECT(s), "sun4m.idreg", sizeof(idreg_data), &error_abort); vmstate_register_ram_global(&s->mem); memory_region_set_readonly(&s->mem, "True" == "True"); sysbus_init_mmio([[dev]], &s->mem); return 0; }

[[[[Adv]]]]: static int idreg_init1(SysBusDevice *[[feedback]]) { IDRegState *s = MACIO_ID_REGISTER([[feedback]]); memory_region_init_ram(&s->mem, OBJECT(s), "sun4m.idreg", sizeof(idreg_data), &error_abort); vmstate_register_ram_global(&s->mem); memory_region_set_readonly(&s->mem, "True" == "True"); sysbus_init_mmio([[feedback]], &s->mem); return 0; }
--------------------------------------------- Result 241 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 126 / 22 / 93 / 241:   9%|▉         | 241/2690 [34:33<5:51:14,  8.61s/it][Succeeded / Failed / Skipped / Total] 126 / 22 / 93 / 241:   9%|▉         | 242/2690 [34:34<5:49:43,  8.57s/it][Succeeded / Failed / Skipped / Total] 126 / 22 / 94 / 242:   9%|▉         | 242/2690 [34:34<5:49:43,  8.57s/it][Succeeded / Failed / Skipped / Total] 126 / 22 / 94 / 242:   9%|▉         | 243/2690 [34:35<5:48:20,  8.54s/it][Succeeded / Failed / Skipped / Total] 126 / 23 / 94 / 243:   9%|▉         | 243/2690 [34:35<5:48:20,  8.54s/it][Succeeded / Failed / Skipped / Total] 126 / 23 / 94 / 243:   9%|▉         | 244/2690 [34:36<5:46:51,  8.51s/it][Succeeded / Failed / Skipped / Total] 126 / 23 / 95 / 244:   9%|▉         | 244/2690 [34:36<5:46:51,  8.51s/it][Succeeded / Failed / Skipped / Total] 126 / 23 / 95 / 244:   9%|▉         | 245/2690 [35:00<5:49:21,  8.57s/it][[0 (10%)]] --> [[0 (60%)]] --> Socre: 0.6027560830116272

[[[[Adv]]]]: static inline void tcg_out_ld_ptr(TCGContext *[[s]], int [[ret]], tcg_target_long [[arg]]) { #if defined(__sparc_v9__) && !defined(__sparc_v8plus__) if ([[arg]] != ([[arg]] & 0xffffffff)) fprintf(stderr, "unimplemented %s with offset %ld\n", __func__, [[arg]]); if ([[arg]] != ([[arg]] & 0xfff)) tcg_out32([[s]], SETHI | INSN_RD([[ret]]) | (((uint32_t)[[arg]] & 0xfffffc00) >> 10)); tcg_out32([[s]], LDX | INSN_RD([[ret]]) | INSN_RS1([[ret]]) | INSN_IMM13([[arg]] & 0x3ff)); #else tcg_out_ld_raw([[s]], [[ret]], [[arg]]); #endif }

[[[[Adv]]]]: static inline void tcg_out_ld_ptr(TCGContext *[[sts]], int [[onт]], tcg_target_long [[marr]]) { #if defined(__sparc_v9__) && !defined(__sparc_v8plus__) if ([[marr]] != ([[marr]] & 0xffffffff)) fprintf(stderr, "unimplemented %s with offset %ld\n", __func__, [[marr]]); if ([[marr]] != ([[marr]] & 0xfff)) tcg_out32([[sts]], SETHI | INSN_RD([[onт]]) | (((uint32_t)[[marr]] & 0xfffffc00) >> 10)); tcg_out32([[sts]], LDX | INSN_RD([[onт]]) | INSN_RS1([[onт]]) | INSN_IMM13([[marr]] & 0x3ff)); #else tcg_out_ld_raw([[sts]], [[onт]], [[marr]]); #endif }
--------------------------------------------- Result 242 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu, TranslationBlock *tb, int search_pc) { CPUState *cs = CPU(cpu); struct DisasContext ctx, *dc = &ctx; uint16_t *gen_opc_end; uint32_t pc_start; int j, k; uint32_t next_page_start; int num_insns; int max_insns; pc_start = tb->pc; dc->tb = tb; gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE; dc->is_jmp = DISAS_NEXT; dc->ppc = pc_start; dc->pc = pc_start; dc->flags = cpu->env.cpucfgr; dc->mem_idx = cpu_mmu_index(&cpu->env); dc->synced_flags = dc->tb_flags = tb->flags; dc->delayed_branch = !!(dc->tb_flags & D_FLAG); dc->singlestep_enabled = cs->singlestep_enabled; if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) { qemu_log("-----------------------------------------\n"); log_cpu_state(CPU(cpu), 0); } next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE; k = -1; num_insns = 0; max_insns = tb->cflags & CF_COUNT_MASK; if (max_insns == 0) { max_insns = CF_COUNT_MASK; } gen_tb_start(); do { check_breakpoint(cpu, dc); if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; if (k < j) { k++; while (k < j) { tcg_ctx.gen_opc_instr_start[k++] = 0; } } tcg_ctx.gen_opc_pc[k] = dc->pc; tcg_ctx.gen_opc_instr_start[k] = 1; tcg_ctx.gen_opc_icount[k] = num_insns; } if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) { tcg_gen_debug_insn_start(dc->pc); } if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) { gen_io_start(); } dc->ppc = dc->pc - 4; dc->npc = dc->pc + 4; tcg_gen_movi_tl(cpu_ppc, dc->ppc); tcg_gen_movi_tl(cpu_npc, dc->npc); disas_openrisc_insn(dc, cpu); dc->pc = dc->npc; num_insns++; if (dc->delayed_branch) { dc->delayed_branch--; if (!dc->delayed_branch) { dc->tb_flags &= ~D_FLAG; gen_sync_flags(dc); tcg_gen_mov_tl(cpu_pc, jmp_pc); tcg_gen_mov_tl(cpu_npc, jmp_pc); tcg_gen_movi_tl(jmp_pc, 0); tcg_gen_exit_tb(0); dc->is_jmp = DISAS_JUMP; break; } } } while (!dc->is_jmp && tcg_ctx.gen_opc_ptr < gen_opc_end && !cs->singlestep_enabled && !singlestep && (dc->pc < next_page_start) && num_insns < max_insns); if (tb->cflags & CF_LAST_IO) { gen_io_end(); } if (dc->is_jmp == DISAS_NEXT) { dc->is_jmp = DISAS_UPDATE; tcg_gen_movi_tl(cpu_pc, dc->pc); } if (unlikely(cs->singlestep_enabled)) { if (dc->is_jmp == DISAS_NEXT) { tcg_gen_movi_tl(cpu_pc, dc->pc); } gen_exception(dc, EXCP_DEBUG); } else { switch (dc->is_jmp) { case DISAS_NEXT: gen_goto_tb(dc, 0, dc->pc); break; default: case DISAS_JUMP: break; case DISAS_UPDATE: tcg_gen_exit_tb(0); break; case DISAS_TB_JUMP: break; } } gen_tb_end(tb, num_insns); *tcg_ctx.gen_opc_ptr = INDEX_op_end; if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; k++; while (k <= j) { tcg_ctx.gen_opc_instr_start[k++] = 0; } } else { tb->size = dc->pc - pc_start; tb->icount = num_insns; } #ifdef DEBUG_DISAS if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) { qemu_log("\n"); log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0); qemu_log("\nisize=%d osize=%td\n", dc->pc - pc_start, tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf); } #endif }
--------------------------------------------- Result 243 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: blkdebug_co_preadv(BlockDriverState *[[bs]], uint64_t [[offset]], uint64_t [[bytes]], QEMUIOVector *[[qiov]], int flags) { BDRVBlkdebugState *[[s]] = [[bs]]->opaque; BlkdebugRule *rule = NULL; QSIMPLEQ_FOREACH(rule, &[[s]]->active_rules, active_next) { uint64_t inject_offset = rule->options.inject.offset; if (inject_offset == -1 || (inject_offset >= [[offset]] && inject_offset < [[offset]] + [[bytes]])) { break; if (rule && rule->options.inject.error) { return inject_error([[bs]], rule); return bdrv_co_preadv([[bs]]->file, [[offset]], [[bytes]], [[qiov]], flags);

[[[[Adv]]]]: blkdebug_co_preadv(BlockDriverState *[[dates]], uint64_t [[angle]], uint64_t [[bands]], QEMUIOVector *[[shiв]], int flags) { BDRVBlkdebugState *[[gross]] = [[dates]]->opaque; BlkdebugRule *rule = NULL; QSIMPLEQ_FOREACH(rule, &[[gross]]->active_rules, active_next) { uint64_t inject_offset = rule->options.inject.offset; if (inject_offset == -1 || (inject_offset >= [[angle]] && inject_offset < [[angle]] + [[bands]])) { break; if (rule && rule->options.inject.error) { return inject_error([[dates]], rule); return bdrv_co_preadv([[dates]]->file, [[angle]], [[bands]], [[shiв]], flags);
--------------------------------------------- Result 244 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info) { fprintf_function fprintf_fn = info->fprintf_func; void *stream = info->stream; int rc; uint8_t insn[4]; const Lm32OpcodeInfo *opc_info; uint32_t op; const char *args_fmt; rc = info->read_memory_func(memaddr, insn, 4, info); if (rc != 0) { info->memory_error_func(rc, memaddr, info); return -1; } fprintf_fn(stream, "%02x %02x %02x %02x ", insn[0], insn[1], insn[2], insn[3]); op = bfd_getb32(insn); opc_info = find_opcode_info(op); if (opc_info) { fprintf_fn(stream, "%-8s ", opc_info->name); args_fmt = opc_info->args_fmt; while (args_fmt && *args_fmt) { if (*args_fmt == '%') { switch (*(++args_fmt)) { case '0': { uint8_t r0; const char *r0_name; r0 = (op >> 21) & 0x1f; r0_name = find_reg_info(r0)->name; fprintf_fn(stream, "%s", r0_name); break; } case '1': { uint8_t r1; const char *r1_name; r1 = (op >> 16) & 0x1f; r1_name = find_reg_info(r1)->name; fprintf_fn(stream, "%s", r1_name); break; } case '2': { uint8_t r2; const char *r2_name; r2 = (op >> 11) & 0x1f; r2_name = find_reg_info(r2)->name; fprintf_fn(stream, "%s", r2_name); break; } case 'c': { uint8_t csr; const char *csr_name; csr = (op >> 21) & 0x1f; csr_name = find_csr_info(csr)->name; if (csr_name) { fprintf_fn(stream, "%s", csr_name); } else { fprintf_fn(stream, "0x%x", csr); } break; } case 'u': { uint16_t u16; u16 = op & 0xffff; fprintf_fn(stream, "0x%x", u16); break; } case 's': { int16_t s16; s16 = (int16_t)(op & 0xffff); fprintf_fn(stream, "%d", s16); break; } case 'r': { uint32_t rela; rela = memaddr + (((int16_t)(op & 0xffff)) << 2); fprintf_fn(stream, "%x", rela); break; } case 'R': { uint32_t rela; int32_t imm26; imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4; rela = memaddr + imm26; fprintf_fn(stream, "%x", rela); break; } case 'h': { uint8_t u5; u5 = (op & 0x1f); fprintf_fn(stream, "%d", u5); break; } default: break; } } else { fprintf_fn(stream, "%c", *args_fmt); } args_fmt++; } } else { fprintf_fn(stream, ".word 0x%x", op); } return 4; }
--------------------------------------------- Result 245 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 127 / 23 / 95 / 245:   9%|▉         | 245/2690 [35:00<5:49:21,  8.57s/it][Succeeded / Failed / Skipped / Total] 127 / 23 / 95 / 245:   9%|▉         | 246/2690 [35:00<5:47:52,  8.54s/it][Succeeded / Failed / Skipped / Total] 127 / 23 / 96 / 246:   9%|▉         | 246/2690 [35:00<5:47:52,  8.54s/it][Succeeded / Failed / Skipped / Total] 127 / 23 / 96 / 246:   9%|▉         | 247/2690 [35:01<5:46:28,  8.51s/it][Succeeded / Failed / Skipped / Total] 128 / 23 / 96 / 247:   9%|▉         | 247/2690 [35:01<5:46:29,  8.51s/it][Succeeded / Failed / Skipped / Total] 128 / 23 / 96 / 247:   9%|▉         | 248/2690 [35:22<5:48:15,  8.56s/it][[0 (32%)]] --> [[0 (97%)]] --> Socre: 0.9650074243545532

[[[[Adv]]]]: static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c, uint8_t *properties) { int [[compno]]; if (s->buf_end - s->buf < 2) return AVERROR(EINVAL); [[compno]] = bytestream_get_byte(&s->buf); c += [[compno]]; c->csty = bytestream_get_byte(&s->buf); get_cox(s, c); properties[[[compno]]] |= HAD_COC; return 0; }

[[[[Adv]]]]: static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c, uint8_t *properties) { int [[domпbo]]; if (s->buf_end - s->buf < 2) return AVERROR(EINVAL); [[domпbo]] = bytestream_get_byte(&s->buf); c += [[domпbo]]; c->csty = bytestream_get_byte(&s->buf); get_cox(s, c); properties[[[domпbo]]] |= HAD_COC; return 0; }
--------------------------------------------- Result 246 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void curses_setup(void) { int i, colour_default[8] = { COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN, COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE, }; initscr(); noecho(); intrflush(stdscr, "False" != "False"); nodelay(stdscr, "True" == "True"); nonl(); keypad(stdscr, "True" == "True"); start_color(); raw(); scrollok(stdscr, "False" != "False"); for (i = 0; i < 64; i ++) init_pair(i, colour_default[i & 7], colour_default[i >> 3]); }
--------------------------------------------- Result 247 ---------------------------------------------
[[0 (70%)]] --> [[0 (46%)]] --> Socre: 0.5354093313217163

[[[[Adv]]]]: static void pci_ivshmem_realize(PCIDevice *[[dev]], Error **errp) { IVShmemState *s = IVSHMEM([[dev]]); Error *err = NULL; uint8_t *pci_conf; uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_PREFETCH; if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) { error_setg(errp, "You must specify either 'shm', 'chardev' or 'x-memdev'"); return; } if (s->hostmem) { MemoryRegion *mr; if (s->sizearg) { g_warning("size argument ignored with hostmem"); } mr = host_memory_backend_get_memory(s->hostmem, &error_abort); s->ivshmem_size = memory_region_size(mr); } else if (s->sizearg == NULL) { s->ivshmem_size = 4 << 20; } else { char *end; int64_t size = qemu_strtosz(s->sizearg, &end); if (size < 0 || *end != '\0' || !is_power_of_2(size)) { error_setg(errp, "Invalid size %s", s->sizearg); return; } s->ivshmem_size = size; } if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) && !ivshmem_has_feature(s, IVSHMEM_MSI)) { error_setg(errp, "ioeventfd/irqfd requires MSI"); return; } if (s->role) { if (strncmp(s->role, "peer", 5) == 0) { s->role_val = IVSHMEM_PEER; } else if (strncmp(s->role, "master", 7) == 0) { s->role_val = IVSHMEM_MASTER; } else { error_setg(errp, "'role' must be 'peer' or 'master'"); return; } } else { s->role_val = IVSHMEM_MASTER; } pci_conf = [[dev]]->config; pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY; pci_config_set_interrupt_pin(pci_conf, 1); memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s, "ivshmem-mmio", IVSHMEM_REG_BAR_SIZE); pci_register_bar([[dev]], 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->ivshmem_mmio); memory_region_init(&s->bar, OBJECT(s), "ivshmem-bar2-container", s->ivshmem_size); if (s->ivshmem_64bit) { attr |= PCI_BASE_ADDRESS_MEM_TYPE_64; } if (s->hostmem != NULL) { MemoryRegion *mr; IVSHMEM_DPRINTF("using hostmem\n"); mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem), &error_abort); vmstate_register_ram(mr, DEVICE(s)); memory_region_add_subregion(&s->bar, 0, mr); pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar); } else if (s->server_chr != NULL) { if (strncmp(s->server_chr->filename, "unix:", 5)) { error_setg(errp, "chardev is not a unix client socket"); return; } IVSHMEM_DPRINTF("using shared memory server (socket = %s)\n", s->server_chr->filename); if (ivshmem_setup_interrupts(s) < 0) { error_setg(errp, "failed to initialize interrupts"); return; } resize_peers(s, 16); s->vm_id = -1; pci_register_bar([[dev]], 2, attr, &s->bar); qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive, ivshmem_check_version, NULL, s); } else { int fd; IVSHMEM_DPRINTF("using shm_open (shm object = %s)\n", s->shmobj); if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL, S_IRWXU|S_IRWXG|S_IRWXO)) > 0) { if (ftruncate(fd, s->ivshmem_size) != 0) { error_report("could not truncate shared file"); } } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO)) < 0) { error_setg(errp, "could not open shared file"); return; } if (check_shm_size(s, fd, errp) == -1) { return; } create_shared_memory_BAR(s, fd, attr, &err); if (err) { error_propagate(errp, err); return; } } fifo8_create(&s->incoming_fifo, sizeof(int64_t)); if (s->role_val == IVSHMEM_PEER) { error_setg(&s->migration_blocker, "Migration is disabled when using feature 'peer mode' in device 'ivshmem'"); migrate_add_blocker(s->migration_blocker); } }

[[[[Adv]]]]: static void pci_ivshmem_realize(PCIDevice *[[gross]], Error **errp) { IVShmemState *s = IVSHMEM([[gross]]); Error *err = NULL; uint8_t *pci_conf; uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_PREFETCH; if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) { error_setg(errp, "You must specify either 'shm', 'chardev' or 'x-memdev'"); return; } if (s->hostmem) { MemoryRegion *mr; if (s->sizearg) { g_warning("size argument ignored with hostmem"); } mr = host_memory_backend_get_memory(s->hostmem, &error_abort); s->ivshmem_size = memory_region_size(mr); } else if (s->sizearg == NULL) { s->ivshmem_size = 4 << 20; } else { char *end; int64_t size = qemu_strtosz(s->sizearg, &end); if (size < 0 || *end != '\0' || !is_power_of_2(size)) { error_setg(errp, "Invalid size %s", s->sizearg); return; } s->ivshmem_size = size; } if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) && !ivshmem_has_feature(s, IVSHMEM_MSI)) { error_setg(errp, "ioeventfd/irqfd requires MSI"); return; } if (s->role) { if (strncmp(s->role, "peer", 5) == 0) { s->role_val = IVSHMEM_PEER; } else if (strncmp(s->role, "master", 7) == 0) { s->role_val = IVSHMEM_MASTER; } else { error_setg(errp, "'role' must be 'peer' or 'master'"); return; } } else { s->role_val = IVSHMEM_MASTER; } pci_conf = [[gross]]->config; pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY; pci_config_set_interrupt_pin(pci_conf, 1); memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s, "ivshmem-mmio", IVSHMEM_REG_BAR_SIZE); pci_register_bar([[gross]], 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->ivshmem_mmio); memory_region_init(&s->bar, OBJECT(s), "ivshmem-bar2-container", s->ivshmem_size); if (s->ivshmem_64bit) { attr |= PCI_BASE_ADDRESS_MEM_TYPE_64; } if (s->hostmem != NULL) { MemoryRegion *mr; IVSHMEM_DPRINTF("using hostmem\n"); mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem), &error_abort); vmstate_register_ram(mr, DEVICE(s)); memory_region_add_subregion(&s->bar, 0, mr); pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar); } else if (s->server_chr != NULL) { if (strncmp(s->server_chr->filename, "unix:", 5)) { error_setg(errp, "chardev is not a unix client socket"); return; } IVSHMEM_DPRINTF("using shared memory server (socket = %s)\n", s->server_chr->filename); if (ivshmem_setup_interrupts(s) < 0) { error_setg(errp, "failed to initialize interrupts"); return; } resize_peers(s, 16); s->vm_id = -1; pci_register_bar([[gross]], 2, attr, &s->bar); qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive, ivshmem_check_version, NULL, s); } else { int fd; IVSHMEM_DPRINTF("using shm_open (shm object = %s)\n", s->shmobj); if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL, S_IRWXU|S_IRWXG|S_IRWXO)) > 0) { if (ftruncate(fd, s->ivshmem_size) != 0) { error_report("could not truncate shared file"); } } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO)) < 0) { error_setg(errp, "could not open shared file"); return; } if (check_shm_size(s, fd, errp) == -1) { return; } create_shared_memory_BAR(s, fd, attr, &err); if (err) { error_propagate(errp, err); return; } } fifo8_create(&s->incoming_fifo, sizeof(int64_t)); if (s->role_val == IVSHMEM_PEER) { error_setg(&s->migration_blocker, "Migration is disabled when using feature 'peer mode' in device 'ivshmem'"); migrate_add_blocker(s->migration_blocker); } }
--------------------------------------------- Result 248 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 23 / 96 / 248:   9%|▉         | 248/2690 [35:22<5:48:15,  8.56s/it][Succeeded / Failed / Skipped / Total] 129 / 23 / 96 / 248:   9%|▉         | 249/2690 [35:58<5:52:35,  8.67s/it][Succeeded / Failed / Skipped / Total] 130 / 23 / 96 / 249:   9%|▉         | 249/2690 [35:58<5:52:35,  8.67s/it][Succeeded / Failed / Skipped / Total] 130 / 23 / 96 / 249:   9%|▉         | 250/2690 [35:58<5:51:07,  8.63s/it][Succeeded / Failed / Skipped / Total] 130 / 23 / 97 / 250:   9%|▉         | 250/2690 [35:58<5:51:07,  8.63s/it][Succeeded / Failed / Skipped / Total] 130 / 23 / 97 / 250:   9%|▉         | 251/2690 [36:23<5:53:33,  8.70s/it][Succeeded / Failed / Skipped / Total] 131 / 23 / 97 / 251:   9%|▉         | 251/2690 [36:23<5:53:33,  8.70s/it][Succeeded / Failed / Skipped / Total] 131 / 23 / 97 / 251:   9%|▉         | 252/2690 [36:30<5:53:09,  8.69s/it][[0 (8%)]] --> [[0 (99%)]] --> Socre: 0.988170862197876

[[[[Adv]]]]: int xen_config_dev_blk(DriveInfo *[[disk]]) { char [[fe]][256], be[256]; int [[vdev]] = 202 * 256 + 16 * [[disk]]->unit; int cdrom = [[disk]]->bdrv->type == BDRV_TYPE_CDROM; const char *[[devtype]] = cdrom ? "cdrom" : "disk"; const char *mode = cdrom ? "r" : "w"; snprintf([[disk]]->bdrv->device_name, sizeof([[disk]]->bdrv->device_name), "xvd%c", 'a' + [[disk]]->unit); xen_be_printf(NULL, 1, "config disk %d [%s]: %s\n", [[disk]]->unit, [[disk]]->bdrv->device_name, [[disk]]->bdrv->filename); xen_config_dev_dirs("vbd", "qdisk", [[vdev]], [[fe]], be, sizeof([[fe]])); xenstore_write_int([[fe]], "virtual-device", [[vdev]]); xenstore_write_str([[fe]], "device-type", [[devtype]]); xenstore_write_str(be, "dev", [[disk]]->bdrv->device_name); xenstore_write_str(be, "type", "file"); xenstore_write_str(be, "params", [[disk]]->bdrv->filename); xenstore_write_str(be, "mode", mode); return xen_config_dev_all([[fe]], be); }

[[[[Adv]]]]: int xen_config_dev_blk(DriveInfo *[[discs]]) { char [[vest]][256], be[256]; int [[µw]] = 202 * 256 + 16 * [[discs]]->unit; int cdrom = [[discs]]->bdrv->type == BDRV_TYPE_CDROM; const char *[[gemype]] = cdrom ? "cdrom" : "disk"; const char *mode = cdrom ? "r" : "w"; snprintf([[discs]]->bdrv->device_name, sizeof([[discs]]->bdrv->device_name), "xvd%c", 'a' + [[discs]]->unit); xen_be_printf(NULL, 1, "config disk %d [%s]: %s\n", [[discs]]->unit, [[discs]]->bdrv->device_name, [[discs]]->bdrv->filename); xen_config_dev_dirs("vbd", "qdisk", [[µw]], [[vest]], be, sizeof([[vest]])); xenstore_write_int([[vest]], "virtual-device", [[µw]]); xenstore_write_str([[vest]], "device-type", [[gemype]]); xenstore_write_str(be, "dev", [[discs]]->bdrv->device_name); xenstore_write_str(be, "type", "file"); xenstore_write_str(be, "params", [[discs]]->bdrv->filename); xenstore_write_str(be, "mode", mode); return xen_config_dev_all([[vest]], be); }
--------------------------------------------- Result 249 ---------------------------------------------
[[0 (96%)]] --> [[0 (34%)]] --> Socre: 0.6634622812271118

[[[[Adv]]]]: static int get_uint16_equal(QEMUFile *[[f]], void *[[pv]], size_t size) { uint16_t *[[v]] = [[pv]]; uint16_t v2; qemu_get_be16s([[f]], &v2); if (*[[v]] == v2) { return 0; } return -EINVAL; }

[[[[Adv]]]]: static int get_uint16_equal(QEMUFile *[[force]], void *[[park]], size_t size) { uint16_t *[[size]] = [[park]]; uint16_t v2; qemu_get_be16s([[force]], &v2); if (*[[size]] == v2) { return 0; } return -EINVAL; }
--------------------------------------------- Result 250 ---------------------------------------------
[[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bdrv_refresh_filename(BlockDriverState *bs) { BlockDriver *drv = bs->drv; QDict *opts; if (!drv) { return; } if (bs->file) { bdrv_refresh_filename(bs->file->bs); } if (drv->bdrv_refresh_filename) { bs->exact_filename[0] = '\0'; if (bs->full_open_options) { QDECREF(bs->full_open_options); bs->full_open_options = NULL; } drv->bdrv_refresh_filename(bs); } else if (bs->file) { bool has_open_options; bs->exact_filename[0] = '\0'; if (bs->full_open_options) { QDECREF(bs->full_open_options); bs->full_open_options = NULL; } opts = qdict_new(); has_open_options = append_open_options(opts, bs); if (bs->file->bs->exact_filename[0] && !has_open_options) { strcpy(bs->exact_filename, bs->file->bs->exact_filename); } if (bs->file->bs->full_open_options) { qdict_put_obj(opts, "driver", QOBJECT(qstring_from_str(drv->format_name))); QINCREF(bs->file->bs->full_open_options); qdict_put_obj(opts, "file", QOBJECT(bs->file->bs->full_open_options)); bs->full_open_options = opts; } else { QDECREF(opts); } } else if (!bs->full_open_options && qdict_size(bs->options)) { opts = qdict_new(); append_open_options(opts, bs); qdict_put_obj(opts, "driver", QOBJECT(qstring_from_str(drv->format_name))); if (bs->exact_filename[0]) { qdict_put_obj(opts, "filename", QOBJECT(qstring_from_str(bs->exact_filename))); } bs->full_open_options = opts; } if (bs->exact_filename[0]) { pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename); } else if (bs->full_open_options) { QString *json = qobject_to_json(QOBJECT(bs->full_open_options)); snprintf(bs->filename, sizeof(bs->filename), "json:%s", qstring_get_str(json)); QDECREF(json); } }
--------------------------------------------- Result 251 ---------------------------------------------
[[0 (39%)]] --> [[0 (98%)]] --> Socre: 0.9771808385848999

[[[[Adv]]]]: static inline bool cpu_handle_exception(CPUState *[[cpu]], int *ret) { if ([[cpu]]->exception_index >= 0) { if ([[cpu]]->exception_index >= EXCP_INTERRUPT) { *ret = [[cpu]]->exception_index; if (*ret == EXCP_DEBUG) { cpu_handle_debug_exception([[cpu]]); } [[cpu]]->exception_index = -1; return "True" == "True"; } else { #if defined(CONFIG_USER_ONLY) #if defined(TARGET_I386) CPUClass *cc = CPU_GET_CLASS([[cpu]]); cc->do_interrupt([[cpu]]); #endif *ret = [[cpu]]->exception_index; [[cpu]]->exception_index = -1; return "True" == "True"; #else if (replay_exception()) { CPUClass *cc = CPU_GET_CLASS([[cpu]]); qemu_mutex_lock_iothread(); cc->do_interrupt([[cpu]]); qemu_mutex_unlock_iothread(); [[cpu]]->exception_index = -1; } else if (!replay_has_interrupt()) { *ret = EXCP_INTERRUPT; return "True" == "True"; } #endif } #ifndef CONFIG_USER_ONLY } else if (replay_has_exception() && [[cpu]]->icount_decr.u16.low + [[cpu]]->icount_extra == 0) { cpu_exec_nocache([[cpu]], 1, tb_find([[cpu]], NULL, 0), "True" == "True"); *ret = -1; return "True" == "True"; #endif } return "False" != "False"; }

[[[[Adv]]]]: static inline bool cpu_handle_exception(CPUState *[[uganda]], int *ret) { if ([[uganda]]->exception_index >= 0) { if ([[uganda]]->exception_index >= EXCP_INTERRUPT) { *ret = [[uganda]]->exception_index; if (*ret == EXCP_DEBUG) { cpu_handle_debug_exception([[uganda]]); } [[uganda]]->exception_index = -1; return "True" == "True"; } else { #if defined(CONFIG_USER_ONLY) #if defined(TARGET_I386) CPUClass *cc = CPU_GET_CLASS([[uganda]]); cc->do_interrupt([[uganda]]); #endif *ret = [[uganda]]->exception_index; [[uganda]]->exception_index = -1; return "True" == "True"; #else if (replay_exception()) { CPUClass *cc = CPU_GET_CLASS([[uganda]]); qemu_mutex_lock_iothread(); cc->do_interrupt([[uganda]]); qemu_mutex_unlock_iothread(); [[uganda]]->exception_index = -1; } else if (!replay_has_interrupt()) { *ret = EXCP_INTERRUPT; return "True" == "True"; } #endif } #ifndef CONFIG_USER_ONLY } else if (replay_has_exception() && [[uganda]]->icount_decr.u16.low + [[uganda]]->icount_extra == 0) { cpu_exec_nocache([[uganda]], 1, tb_find([[uganda]], NULL, 0), "True" == "True"); *ret = -1; return "True" == "True"; #endif } return "False" != "False"; }
--------------------------------------------- Result 252 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 132 / 23 / 97 / 252:   9%|▉         | 252/2690 [36:30<5:53:09,  8.69s/it][Succeeded / Failed / Skipped / Total] 132 / 23 / 97 / 252:   9%|▉         | 253/2690 [36:35<5:52:29,  8.68s/it][[0 (93%)]] --> [[0 (44%)]] --> Socre: 0.5642704963684082

[[[[Adv]]]]: static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32_t *timestamp, const uint8_t *[[buf]], int len, uint16_t seq, int flags) { uint8_t nal; uint8_t type; int result = 0; if (!len) { av_log(ctx, AV_LOG_ERROR, "Empty H264 RTP packet\n"); return AVERROR_INVALIDDATA; } nal = [[buf]][0]; type = nal & 0x1f; assert(data); assert([[buf]]); if (type >= 1 && type <= 23) type = 1; switch (type) { case 0: case 1: av_new_packet(pkt, len + sizeof(start_sequence)); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); memcpy(pkt->data + sizeof(start_sequence), [[buf]], len); COUNT_NAL_TYPE(data, nal); break; case 24: [[buf]]++; len--; { int pass = 0; int total_length = 0; uint8_t *dst = NULL; for (pass = 0; pass < 2; pass++) { const uint8_t *[[src]] = [[buf]]; int src_len = len; while (src_len > 2) { uint16_t nal_size = AV_RB16([[src]]); [[src]] += 2; src_len -= 2; if (nal_size <= src_len) { if (pass == 0) { total_length += sizeof(start_sequence) + nal_size; } else { assert(dst); memcpy(dst, start_sequence, sizeof(start_sequence)); dst += sizeof(start_sequence); memcpy(dst, [[src]], nal_size); COUNT_NAL_TYPE(data, *[[src]]); dst += nal_size; } } else { av_log(ctx, AV_LOG_ERROR, "nal size exceeds length: %d %d\n", nal_size, src_len); } [[src]] += nal_size; src_len -= nal_size; if (src_len < 0) av_log(ctx, AV_LOG_ERROR, "Consumed more bytes than we got! (%d)\n", src_len); } if (pass == 0) { av_new_packet(pkt, total_length); dst = pkt->data; } else { assert(dst - pkt->data == total_length); } } } break; case 25: case 26: case 27: case 29: av_log(ctx, AV_LOG_ERROR, "Unhandled type (%d) (See RFC for implementation details\n", type); result = AVERROR(ENOSYS); break; case 28: [[buf]]++; len--; if (len > 1) { uint8_t fu_indicator = nal; uint8_t fu_header = *[[buf]]; uint8_t start_bit = fu_header >> 7; uint8_t av_unused end_bit = (fu_header & 0x40) >> 6; uint8_t nal_type = fu_header & 0x1f; uint8_t reconstructed_nal; reconstructed_nal = fu_indicator & 0xe0; reconstructed_nal |= nal_type; [[buf]]++; len--; if (start_bit) COUNT_NAL_TYPE(data, nal_type); if (start_bit) { av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); pkt->data[sizeof(start_sequence)] = reconstructed_nal; memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), [[buf]], len); } else { av_new_packet(pkt, len); memcpy(pkt->data, [[buf]], len); } } else { av_log(ctx, AV_LOG_ERROR, "Too short data for FU-A H264 RTP packet\n"); result = AVERROR_INVALIDDATA; } break; case 30: case 31: default: av_log(ctx, AV_LOG_ERROR, "Undefined type (%d)\n", type); result = AVERROR_INVALIDDATA; break; } pkt->stream_index = st->index; return result; }

[[[[Adv]]]]: static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32_t *timestamp, const uint8_t *[[vufi]], int len, uint16_t seq, int flags) { uint8_t nal; uint8_t type; int result = 0; if (!len) { av_log(ctx, AV_LOG_ERROR, "Empty H264 RTP packet\n"); return AVERROR_INVALIDDATA; } nal = [[vufi]][0]; type = nal & 0x1f; assert(data); assert([[vufi]]); if (type >= 1 && type <= 23) type = 1; switch (type) { case 0: case 1: av_new_packet(pkt, len + sizeof(start_sequence)); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); memcpy(pkt->data + sizeof(start_sequence), [[vufi]], len); COUNT_NAL_TYPE(data, nal); break; case 24: [[vufi]]++; len--; { int pass = 0; int total_length = 0; uint8_t *dst = NULL; for (pass = 0; pass < 2; pass++) { const uint8_t *[[neebc]] = [[vufi]]; int src_len = len; while (src_len > 2) { uint16_t nal_size = AV_RB16([[neebc]]); [[neebc]] += 2; src_len -= 2; if (nal_size <= src_len) { if (pass == 0) { total_length += sizeof(start_sequence) + nal_size; } else { assert(dst); memcpy(dst, start_sequence, sizeof(start_sequence)); dst += sizeof(start_sequence); memcpy(dst, [[neebc]], nal_size); COUNT_NAL_TYPE(data, *[[neebc]]); dst += nal_size; } } else { av_log(ctx, AV_LOG_ERROR, "nal size exceeds length: %d %d\n", nal_size, src_len); } [[neebc]] += nal_size; src_len -= nal_size; if (src_len < 0) av_log(ctx, AV_LOG_ERROR, "Consumed more bytes than we got! (%d)\n", src_len); } if (pass == 0) { av_new_packet(pkt, total_length); dst = pkt->data; } else { assert(dst - pkt->data == total_length); } } } break; case 25: case 26: case 27: case 29: av_log(ctx, AV_LOG_ERROR, "Unhandled type (%d) (See RFC for implementation details\n", type); result = AVERROR(ENOSYS); break; case 28: [[vufi]]++; len--; if (len > 1) { uint8_t fu_indicator = nal; uint8_t fu_header = *[[vufi]]; uint8_t start_bit = fu_header >> 7; uint8_t av_unused end_bit = (fu_header & 0x40) >> 6; uint8_t nal_type = fu_header & 0x1f; uint8_t reconstructed_nal; reconstructed_nal = fu_indicator & 0xe0; reconstructed_nal |= nal_type; [[vufi]]++; len--; if (start_bit) COUNT_NAL_TYPE(data, nal_type); if (start_bit) { av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); pkt->data[sizeof(start_sequence)] = reconstructed_nal; memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), [[vufi]], len); } else { av_new_packet(pkt, len); memcpy(pkt->data, [[vufi]], len); } } else { av_log(ctx, AV_LOG_ERROR, "Too short data for FU-A H264 RTP packet\n"); result = AVERROR_INVALIDDATA; } break; case 30: case 31: default: av_log(ctx, AV_LOG_ERROR, "Undefined type (%d)\n", type); result = AVERROR_INVALIDDATA; break; } pkt->stream_index = st->index; return result; }
--------------------------------------------- Result 253 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 132 / 24 / 97 / 253:   9%|▉         | 253/2690 [36:35<5:52:29,  8.68s/it][Succeeded / Failed / Skipped / Total] 132 / 24 / 97 / 253:   9%|▉         | 254/2690 [36:45<5:52:35,  8.68s/it][Succeeded / Failed / Skipped / Total] 132 / 25 / 97 / 254:   9%|▉         | 254/2690 [36:45<5:52:35,  8.68s/it][Succeeded / Failed / Skipped / Total] 132 / 25 / 97 / 254:   9%|▉         | 255/2690 [36:55<5:52:39,  8.69s/it][Succeeded / Failed / Skipped / Total] 133 / 25 / 97 / 255:   9%|▉         | 255/2690 [36:55<5:52:39,  8.69s/it][Succeeded / Failed / Skipped / Total] 133 / 25 / 97 / 255:  10%|▉         | 256/2690 [37:23<5:55:27,  8.76s/it][[0 (82%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void RENAME(hyscale)(uint16_t *dst, int [[dstWidth]], uint8_t *src, int [[srcW]], int [[xInc]]) { #ifdef HAVE_MMX if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed)) #else if(sws_flags != SWS_FAST_BILINEAR) #endif { RENAME(hScale)(dst, [[dstWidth]], src, [[srcW]], [[xInc]], hLumFilter, hLumFilterPos, hLumFilterSize); } else { #ifdef ARCH_X86 #ifdef HAVE_MMX2 int i; if(canMMX2BeUsed) { asm volatile( "pxor %%mm7, %%mm7 \n\t" "pxor %%mm2, %%mm2 \n\t" "movd %5, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "movq %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "movq %%mm2, "MANGLE(temp0)" \n\t" "movd %4, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "xorl %%eax, %%eax \n\t" "movl %0, %%esi \n\t" "movl %1, %%edi \n\t" "movl %3, %%edx \n\t" "xorl %%ecx, %%ecx \n\t" "xorl %%ebx, %%ebx \n\t" "movw %4, %%bx \n\t" #define FUNNY_Y_CODE \ PREFETCH" 1024(%%esi) \n\t"\ PREFETCH" 1056(%%esi) \n\t"\ PREFETCH" 1088(%%esi) \n\t"\ "call "MANGLE(funnyYCode)" \n\t"\ "movq "MANGLE(temp0)", %%mm2 \n\t"\ "xorl %%ecx, %%ecx \n\t" FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE :: "m" (src), "m" (dst), "m" ([[dstWidth]]), "m" (([[xInc]]*4)>>16), "m" (([[xInc]]*4)&0xFFFF), "m" ([[xInc]]&0xFFFF) : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi" ); for(i=[[dstWidth]]-1; (i*[[xInc]])>>16 >=[[srcW]]-1; i--) dst[i] = src[[[srcW]]-1]*128; } else { #endif asm volatile( "xorl %%eax, %%eax \n\t" "xorl %%ebx, %%ebx \n\t" "xorl %%ecx, %%ecx \n\t" ".balign 16 \n\t" "1: \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, (%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, 2(%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "addl $2, %%eax \n\t" "cmpl %2, %%eax \n\t" " jb 1b \n\t" :: "r" (src), "m" (dst), "m" ([[dstWidth]]), "m" ([[xInc]]>>16), "m" ([[xInc]]&0xFFFF) : "%eax", "%ebx", "%ecx", "%edi", "%esi" ); #ifdef HAVE_MMX2 } #endif #else int i; unsigned int xpos=0; for(i=0;i<[[dstWidth]];i++) { register unsigned int xx=xpos>>16; register unsigned int xalpha=(xpos&0xFFFF)>>9; dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha; xpos+=[[xInc]]; } #endif } }

[[[[Adv]]]]: static inline void RENAME(hyscale)(uint16_t *dst, int [[bryngwokasch]], uint8_t *src, int [[grscp]], int [[xiinac]]) { #ifdef HAVE_MMX if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed)) #else if(sws_flags != SWS_FAST_BILINEAR) #endif { RENAME(hScale)(dst, [[bryngwokasch]], src, [[grscp]], [[xiinac]], hLumFilter, hLumFilterPos, hLumFilterSize); } else { #ifdef ARCH_X86 #ifdef HAVE_MMX2 int i; if(canMMX2BeUsed) { asm volatile( "pxor %%mm7, %%mm7 \n\t" "pxor %%mm2, %%mm2 \n\t" "movd %5, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "movq %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "movq %%mm2, "MANGLE(temp0)" \n\t" "movd %4, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "xorl %%eax, %%eax \n\t" "movl %0, %%esi \n\t" "movl %1, %%edi \n\t" "movl %3, %%edx \n\t" "xorl %%ecx, %%ecx \n\t" "xorl %%ebx, %%ebx \n\t" "movw %4, %%bx \n\t" #define FUNNY_Y_CODE \ PREFETCH" 1024(%%esi) \n\t"\ PREFETCH" 1056(%%esi) \n\t"\ PREFETCH" 1088(%%esi) \n\t"\ "call "MANGLE(funnyYCode)" \n\t"\ "movq "MANGLE(temp0)", %%mm2 \n\t"\ "xorl %%ecx, %%ecx \n\t" FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE :: "m" (src), "m" (dst), "m" ([[bryngwokasch]]), "m" (([[xiinac]]*4)>>16), "m" (([[xiinac]]*4)&0xFFFF), "m" ([[xiinac]]&0xFFFF) : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi" ); for(i=[[bryngwokasch]]-1; (i*[[xiinac]])>>16 >=[[grscp]]-1; i--) dst[i] = src[[[grscp]]-1]*128; } else { #endif asm volatile( "xorl %%eax, %%eax \n\t" "xorl %%ebx, %%ebx \n\t" "xorl %%ecx, %%ecx \n\t" ".balign 16 \n\t" "1: \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, (%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, 2(%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "addl $2, %%eax \n\t" "cmpl %2, %%eax \n\t" " jb 1b \n\t" :: "r" (src), "m" (dst), "m" ([[bryngwokasch]]), "m" ([[xiinac]]>>16), "m" ([[xiinac]]&0xFFFF) : "%eax", "%ebx", "%ecx", "%edi", "%esi" ); #ifdef HAVE_MMX2 } #endif #else int i; unsigned int xpos=0; for(i=0;i<[[bryngwokasch]];i++) { register unsigned int xx=xpos>>16; register unsigned int xalpha=(xpos&0xFFFF)>>9; dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha; xpos+=[[xiinac]]; } #endif } }
--------------------------------------------- Result 254 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void ff_dnxhdenc_init_x86(DNXHDEncContext *[[ctx]]) { #if HAVE_INLINE_ASM if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) { if ([[ctx]]->cid_table->bit_depth == 8) [[ctx]]->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2; } #endif }

[[[[Adv]]]]: void ff_dnxhdenc_init_x86(DNXHDEncContext *[[frax]]) { #if HAVE_INLINE_ASM if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) { if ([[frax]]->cid_table->bit_depth == 8) [[frax]]->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2; } #endif }
--------------------------------------------- Result 255 ---------------------------------------------
[[0 (1%)]] --> [[0 (98%)]] --> Socre: 0.9849411845207214

[[[[Adv]]]]: uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2) { CPU_DoubleU [[farg1]], farg2; [[farg1]].ll = arg1; farg2.ll = arg2; if (unlikely(float64_is_infinity([[farg1]].d) && float64_is_infinity(farg2.d))) { [[farg1]].ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI); } else if (unlikely(float64_is_zero([[farg1]].d) && float64_is_zero(farg2.d))) { [[farg1]].ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ); } else { if (unlikely(float64_is_signaling_nan([[farg1]].d) || float64_is_signaling_nan(farg2.d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } [[farg1]].d = float64_div([[farg1]].d, farg2.d, &env->fp_status); } return [[farg1]].ll; }

[[[[Adv]]]]: uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2) { CPU_DoubleU [[mergy₁]], farg2; [[mergy₁]].ll = arg1; farg2.ll = arg2; if (unlikely(float64_is_infinity([[mergy₁]].d) && float64_is_infinity(farg2.d))) { [[mergy₁]].ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI); } else if (unlikely(float64_is_zero([[mergy₁]].d) && float64_is_zero(farg2.d))) { [[mergy₁]].ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ); } else { if (unlikely(float64_is_signaling_nan([[mergy₁]].d) || float64_is_signaling_nan(farg2.d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } [[mergy₁]].d = float64_div([[mergy₁]].d, farg2.d, &env->fp_status); } return [[mergy₁]].ll; }
--------------------------------------------- Result 256 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 134 / 25 / 97 / 256:  10%|▉         | 256/2690 [37:23<5:55:27,  8.76s/it][Succeeded / Failed / Skipped / Total] 134 / 25 / 97 / 256:  10%|▉         | 257/2690 [37:25<5:54:15,  8.74s/it][Succeeded / Failed / Skipped / Total] 135 / 25 / 97 / 257:  10%|▉         | 257/2690 [37:25<5:54:15,  8.74s/it][Succeeded / Failed / Skipped / Total] 135 / 25 / 97 / 257:  10%|▉         | 258/2690 [37:45<5:55:56,  8.78s/it][Succeeded / Failed / Skipped / Total] 136 / 25 / 97 / 258:  10%|▉         | 258/2690 [37:45<5:55:56,  8.78s/it][Succeeded / Failed / Skipped / Total] 136 / 25 / 97 / 258:  10%|▉         | 259/2690 [37:46<5:54:30,  8.75s/it][Succeeded / Failed / Skipped / Total] 136 / 25 / 98 / 259:  10%|▉         | 259/2690 [37:46<5:54:30,  8.75s/it][Succeeded / Failed / Skipped / Total] 136 / 25 / 98 / 259:  10%|▉         | 260/2690 [37:55<5:54:22,  8.75s/it][[0 (2%)]] --> [[0 (95%)]] --> Socre: 0.9455196857452393

[[[[Adv]]]]: static void test_io_channel_ipv4(bool [[async]]) { SocketAddress *[[listen_addr]] = g_new0(SocketAddress, 1); SocketAddress *[[connect_addr]] = g_new0(SocketAddress, 1); [[listen_addr]]->type = SOCKET_ADDRESS_KIND_INET; [[listen_addr]]->u.inet = g_new0(InetSocketAddress, 1); [[listen_addr]]->u.inet->host = g_strdup("0.0.0.0"); [[listen_addr]]->u.inet->port = NULL; [[connect_addr]]->type = SOCKET_ADDRESS_KIND_INET; [[connect_addr]]->u.inet = g_new0(InetSocketAddress, 1); [[connect_addr]]->u.inet->host = g_strdup("127.0.0.1"); [[connect_addr]]->u.inet->port = NULL; test_io_channel([[async]], [[listen_addr]], [[connect_addr]]); qapi_free_SocketAddress([[listen_addr]]); qapi_free_SocketAddress([[connect_addr]]); }

[[[[Adv]]]]: static void test_io_channel_ipv4(bool [[bandskinl]]) { SocketAddress *[[swbigixɾ]] = g_new0(SocketAddress, 1); SocketAddress *[[praybyifm]] = g_new0(SocketAddress, 1); [[swbigixɾ]]->type = SOCKET_ADDRESS_KIND_INET; [[swbigixɾ]]->u.inet = g_new0(InetSocketAddress, 1); [[swbigixɾ]]->u.inet->host = g_strdup("0.0.0.0"); [[swbigixɾ]]->u.inet->port = NULL; [[praybyifm]]->type = SOCKET_ADDRESS_KIND_INET; [[praybyifm]]->u.inet = g_new0(InetSocketAddress, 1); [[praybyifm]]->u.inet->host = g_strdup("127.0.0.1"); [[praybyifm]]->u.inet->port = NULL; test_io_channel([[bandskinl]], [[swbigixɾ]], [[praybyifm]]); qapi_free_SocketAddress([[swbigixɾ]]); qapi_free_SocketAddress([[praybyifm]]); }
--------------------------------------------- Result 257 ---------------------------------------------
[[0 (17%)]] --> [[0 (61%)]] --> Socre: 0.6129214763641357

[[[[Adv]]]]: static void v9fs_stat(void *opaque) { int32_t fid; V9fsStat v9stat; ssize_t [[err]] = 0; size_t offset = 7; struct stat stbuf; V9fsFidState *fidp; V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; pdu_unmarshal(pdu, offset, "d", &fid); trace_v9fs_stat(pdu->tag, pdu->id, fid); fidp = get_fid(pdu, fid); if (fidp == NULL) { [[err]] = -ENOENT; goto out_nofid; } [[err]] = v9fs_co_lstat(pdu, &fidp->path, &stbuf); if ([[err]] < 0) { goto out; } [[err]] = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat); if ([[err]] < 0) { goto out; } offset += pdu_marshal(pdu, offset, "wS", 0, &v9stat); [[err]] = offset; trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode, v9stat.atime, v9stat.mtime, v9stat.length); v9fs_stat_free(&v9stat); out: put_fid(pdu, fidp); out_nofid: complete_pdu(s, pdu, [[err]]); }

[[[[Adv]]]]: static void v9fs_stat(void *opaque) { int32_t fid; V9fsStat v9stat; ssize_t [[inρ]] = 0; size_t offset = 7; struct stat stbuf; V9fsFidState *fidp; V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; pdu_unmarshal(pdu, offset, "d", &fid); trace_v9fs_stat(pdu->tag, pdu->id, fid); fidp = get_fid(pdu, fid); if (fidp == NULL) { [[inρ]] = -ENOENT; goto out_nofid; } [[inρ]] = v9fs_co_lstat(pdu, &fidp->path, &stbuf); if ([[inρ]] < 0) { goto out; } [[inρ]] = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat); if ([[inρ]] < 0) { goto out; } offset += pdu_marshal(pdu, offset, "wS", 0, &v9stat); [[inρ]] = offset; trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode, v9stat.atime, v9stat.mtime, v9stat.length); v9fs_stat_free(&v9stat); out: put_fid(pdu, fidp); out_nofid: complete_pdu(s, pdu, [[inρ]]); }
--------------------------------------------- Result 258 ---------------------------------------------
[[0 (60%)]] --> [[0 (34%)]] --> Socre: 0.6559378504753113

[[[[Adv]]]]: static int of_dpa_cmd_add_l2_flood(OfDpa *[[of_dpa]], OfDpaGroup *group, RockerTlv **group_tlvs) { OfDpaGroup *l2_group; RockerTlv **tlvs; int err; int i; if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] || !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) { return -ROCKER_EINVAL; } group->l2_flood.group_count = rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]); tlvs = g_malloc0((group->l2_flood.group_count + 1) * sizeof(RockerTlv *)); if (!tlvs) { return -ROCKER_ENOMEM; } g_free(group->l2_flood.group_ids); group->l2_flood.group_ids = g_malloc0(group->l2_flood.group_count * sizeof(uint32_t)); if (!group->l2_flood.group_ids) { err = -ROCKER_ENOMEM; goto err_out; } rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count, group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]); for (i = 0; i < group->l2_flood.group_count; i++) { group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]); } for (i = 0; i < group->l2_flood.group_count; i++) { l2_group = of_dpa_group_find([[of_dpa]], group->l2_flood.group_ids[i]); if (!l2_group) { continue; } if ((ROCKER_GROUP_TYPE_GET(l2_group->id) == ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) && (ROCKER_GROUP_VLAN_GET(l2_group->id) != ROCKER_GROUP_VLAN_GET(group->id))) { DPRINTF("l2 interface group 0x%08x VLAN doesn't match l2 " "flood group 0x%08x\n", group->l2_flood.group_ids[i], group->id); err = -ROCKER_EINVAL; goto err_out; } } g_free(tlvs); return ROCKER_OK; err_out: group->l2_flood.group_count = 0; g_free(group->l2_flood.group_ids); g_free(tlvs); return err; }

[[[[Adv]]]]: static int of_dpa_cmd_add_l2_flood(OfDpa *[[nocyplaykar]], OfDpaGroup *group, RockerTlv **group_tlvs) { OfDpaGroup *l2_group; RockerTlv **tlvs; int err; int i; if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] || !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) { return -ROCKER_EINVAL; } group->l2_flood.group_count = rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]); tlvs = g_malloc0((group->l2_flood.group_count + 1) * sizeof(RockerTlv *)); if (!tlvs) { return -ROCKER_ENOMEM; } g_free(group->l2_flood.group_ids); group->l2_flood.group_ids = g_malloc0(group->l2_flood.group_count * sizeof(uint32_t)); if (!group->l2_flood.group_ids) { err = -ROCKER_ENOMEM; goto err_out; } rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count, group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]); for (i = 0; i < group->l2_flood.group_count; i++) { group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]); } for (i = 0; i < group->l2_flood.group_count; i++) { l2_group = of_dpa_group_find([[nocyplaykar]], group->l2_flood.group_ids[i]); if (!l2_group) { continue; } if ((ROCKER_GROUP_TYPE_GET(l2_group->id) == ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) && (ROCKER_GROUP_VLAN_GET(l2_group->id) != ROCKER_GROUP_VLAN_GET(group->id))) { DPRINTF("l2 interface group 0x%08x VLAN doesn't match l2 " "flood group 0x%08x\n", group->l2_flood.group_ids[i], group->id); err = -ROCKER_EINVAL; goto err_out; } } g_free(tlvs); return ROCKER_OK; err_out: group->l2_flood.group_count = 0; g_free(group->l2_flood.group_ids); g_free(tlvs); return err; }
--------------------------------------------- Result 259 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { const uint64_t fuzz_tag = FUZZ_TAG; FuzzDataBuffer buffer; const uint8_t *last = data; const uint8_t *end = data + size; uint32_t it = 0; if (!c) c = AVCodecInitialize(FFMPEG_CODEC); AVCodecContext* ctx = avcodec_alloc_context3(NULL); if (!ctx) error("Failed memory allocation"); ctx->max_pixels = 4096 * 4096; int res = avcodec_open2(ctx, c, NULL); if (res < 0) return res; FDBCreate(&buffer); int got_frame; AVFrame *frame = av_frame_alloc(); if (!frame) error("Failed memory allocation"); AVPacket avpkt; while (data < end && it < maxiteration) { while (data + sizeof(fuzz_tag) < end) { if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag) break; data++; } if (data + sizeof(fuzz_tag) > end) data = end; FDBPrepare(&buffer, &avpkt, last, data - last); data += sizeof(fuzz_tag); last = data; while (avpkt.size > 0 && it++ < maxiteration) { av_frame_unref(frame); int ret = decode_handler(ctx, frame, &got_frame, &avpkt); if (it > 20) ctx->error_concealment = 0; if (ret <= 0 || ret > avpkt.size) break; avpkt.data += ret; avpkt.size -= ret; } } av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; do { got_frame = 0; decode_handler(ctx, frame, &got_frame, &avpkt); } while (got_frame == 1 && it++ < maxiteration); av_frame_free(&frame); avcodec_free_context(&ctx); av_freep(&ctx); FDBDesroy(&buffer); return 0; }
--------------------------------------------- Result 260 ---------------------------------------------
[[0 (15%)]] --> [[0 (68%)]] --> Socre: 0.6788632869720459

[[[[Adv]]]]: static void gen_loongson_multimedia(DisasContext *[[ctx]], int rd, int [[rs]], int rt) { const char *opn = "loongson_cp2"; uint32_t [[opc]], shift_max; TCGv_i64 t0, t1; [[opc]] = MASK_LMI([[ctx]]->opcode); switch ([[opc]]) { case OPC_ADD_CP2: case OPC_SUB_CP2: case OPC_DADD_CP2: case OPC_DSUB_CP2: t0 = tcg_temp_local_new_i64(); t1 = tcg_temp_local_new_i64(); break; default: t0 = tcg_temp_new_i64(); t1 = tcg_temp_new_i64(); break; } gen_load_fpr64([[ctx]], t0, [[rs]]); gen_load_fpr64([[ctx]], t1, rt); #define LMI_HELPER(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break #define LMI_HELPER_1(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break #define LMI_DIRECT(UP, LO, OP) \ case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break switch ([[opc]]) { LMI_HELPER(PADDSH, paddsh); LMI_HELPER(PADDUSH, paddush); LMI_HELPER(PADDH, paddh); LMI_HELPER(PADDW, paddw); LMI_HELPER(PADDSB, paddsb); LMI_HELPER(PADDUSB, paddusb); LMI_HELPER(PADDB, paddb); LMI_HELPER(PSUBSH, psubsh); LMI_HELPER(PSUBUSH, psubush); LMI_HELPER(PSUBH, psubh); LMI_HELPER(PSUBW, psubw); LMI_HELPER(PSUBSB, psubsb); LMI_HELPER(PSUBUSB, psubusb); LMI_HELPER(PSUBB, psubb); LMI_HELPER(PSHUFH, pshufh); LMI_HELPER(PACKSSWH, packsswh); LMI_HELPER(PACKSSHB, packsshb); LMI_HELPER(PACKUSHB, packushb); LMI_HELPER(PUNPCKLHW, punpcklhw); LMI_HELPER(PUNPCKHHW, punpckhhw); LMI_HELPER(PUNPCKLBH, punpcklbh); LMI_HELPER(PUNPCKHBH, punpckhbh); LMI_HELPER(PUNPCKLWD, punpcklwd); LMI_HELPER(PUNPCKHWD, punpckhwd); LMI_HELPER(PAVGH, pavgh); LMI_HELPER(PAVGB, pavgb); LMI_HELPER(PMAXSH, pmaxsh); LMI_HELPER(PMINSH, pminsh); LMI_HELPER(PMAXUB, pmaxub); LMI_HELPER(PMINUB, pminub); LMI_HELPER(PCMPEQW, pcmpeqw); LMI_HELPER(PCMPGTW, pcmpgtw); LMI_HELPER(PCMPEQH, pcmpeqh); LMI_HELPER(PCMPGTH, pcmpgth); LMI_HELPER(PCMPEQB, pcmpeqb); LMI_HELPER(PCMPGTB, pcmpgtb); LMI_HELPER(PSLLW, psllw); LMI_HELPER(PSLLH, psllh); LMI_HELPER(PSRLW, psrlw); LMI_HELPER(PSRLH, psrlh); LMI_HELPER(PSRAW, psraw); LMI_HELPER(PSRAH, psrah); LMI_HELPER(PMULLH, pmullh); LMI_HELPER(PMULHH, pmulhh); LMI_HELPER(PMULHUH, pmulhuh); LMI_HELPER(PMADDHW, pmaddhw); LMI_HELPER(PASUBUB, pasubub); LMI_HELPER_1(BIADD, biadd); LMI_HELPER_1(PMOVMSKB, pmovmskb); LMI_DIRECT(PADDD, paddd, add); LMI_DIRECT(PSUBD, psubd, sub); LMI_DIRECT(XOR_CP2, xor, xor); LMI_DIRECT(NOR_CP2, nor, nor); LMI_DIRECT(AND_CP2, and, and); LMI_DIRECT(PANDN, pandn, andc); LMI_DIRECT(OR, or, or); case OPC_PINSRH_0: tcg_gen_deposit_i64(t0, t0, t1, 0, 16); opn = "pinsrh_0"; break; case OPC_PINSRH_1: tcg_gen_deposit_i64(t0, t0, t1, 16, 16); opn = "pinsrh_1"; break; case OPC_PINSRH_2: tcg_gen_deposit_i64(t0, t0, t1, 32, 16); opn = "pinsrh_2"; break; case OPC_PINSRH_3: tcg_gen_deposit_i64(t0, t0, t1, 48, 16); opn = "pinsrh_3"; break; case OPC_PEXTRH: tcg_gen_andi_i64(t1, t1, 3); tcg_gen_shli_i64(t1, t1, 4); tcg_gen_shr_i64(t0, t0, t1); tcg_gen_ext16u_i64(t0, t0); opn = "pextrh"; break; case OPC_ADDU_CP2: tcg_gen_add_i64(t0, t0, t1); tcg_gen_ext32s_i64(t0, t0); opn = "addu"; break; case OPC_SUBU_CP2: tcg_gen_sub_i64(t0, t0, t1); tcg_gen_ext32s_i64(t0, t0); opn = "addu"; break; case OPC_SLL_CP2: opn = "sll"; shift_max = 32; goto do_shift; case OPC_SRL_CP2: opn = "srl"; shift_max = 32; goto do_shift; case OPC_SRA_CP2: opn = "sra"; shift_max = 32; goto do_shift; case OPC_DSLL_CP2: opn = "dsll"; shift_max = 64; goto do_shift; case OPC_DSRL_CP2: opn = "dsrl"; shift_max = 64; goto do_shift; case OPC_DSRA_CP2: opn = "dsra"; shift_max = 64; goto do_shift; do_shift: tcg_gen_andi_i64(t1, t1, shift_max - 1); switch ([[opc]]) { case OPC_SLL_CP2: case OPC_DSLL_CP2: tcg_gen_shl_i64(t0, t0, t1); break; case OPC_SRA_CP2: case OPC_DSRA_CP2: tcg_gen_sar_i64(t0, t0, t1); break; case OPC_SRL_CP2: tcg_gen_ext32u_i64(t0, t0); case OPC_DSRL_CP2: tcg_gen_shr_i64(t0, t0, t1); break; } if (shift_max == 32) { tcg_gen_ext32s_i64(t0, t0); } tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max); tcg_gen_neg_i64(t1, t1); tcg_gen_and_i64(t0, t0, t1); break; case OPC_ADD_CP2: case OPC_DADD_CP2: { TCGv_i64 t2 = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64(t2, t0); tcg_gen_add_i64(t0, t1, t2); if ([[opc]] == OPC_ADD_CP2) { tcg_gen_ext32s_i64(t0, t0); } tcg_gen_xor_i64(t1, t1, t2); tcg_gen_xor_i64(t2, t2, t0); tcg_gen_andc_i64(t1, t2, t1); tcg_temp_free_i64(t2); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception([[ctx]], EXCP_OVERFLOW); gen_set_label(lab); opn = ([[opc]] == OPC_ADD_CP2 ? "add" : "dadd"); break; } case OPC_SUB_CP2: case OPC_DSUB_CP2: { TCGv_i64 t2 = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64(t2, t0); tcg_gen_sub_i64(t0, t1, t2); if ([[opc]] == OPC_SUB_CP2) { tcg_gen_ext32s_i64(t0, t0); } tcg_gen_xor_i64(t1, t1, t2); tcg_gen_xor_i64(t2, t2, t0); tcg_gen_and_i64(t1, t1, t2); tcg_temp_free_i64(t2); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception([[ctx]], EXCP_OVERFLOW); gen_set_label(lab); opn = ([[opc]] == OPC_SUB_CP2 ? "sub" : "dsub"); break; } case OPC_PMULUW: tcg_gen_ext32u_i64(t0, t0); tcg_gen_ext32u_i64(t1, t1); tcg_gen_mul_i64(t0, t0, t1); opn = "pmuluw"; break; case OPC_SEQU_CP2: case OPC_SEQ_CP2: case OPC_SLTU_CP2: case OPC_SLT_CP2: case OPC_SLEU_CP2: case OPC_SLE_CP2: default: MIPS_INVAL(opn); generate_exception([[ctx]], EXCP_RI); return; } #undef LMI_HELPER #undef LMI_DIRECT gen_store_fpr64([[ctx]], t0, rd); (void)opn; MIPS_DEBUG("%s %s, %s, %s", opn, fregnames[rd], fregnames[[[rs]]], fregnames[rt]); tcg_temp_free_i64(t0); tcg_temp_free_i64(t1); }

[[[[Adv]]]]: static void gen_loongson_multimedia(DisasContext *[[linerrd]], int rd, int [[ru]], int rt) { const char *opn = "loongson_cp2"; uint32_t [[pork]], shift_max; TCGv_i64 t0, t1; [[pork]] = MASK_LMI([[linerrd]]->opcode); switch ([[pork]]) { case OPC_ADD_CP2: case OPC_SUB_CP2: case OPC_DADD_CP2: case OPC_DSUB_CP2: t0 = tcg_temp_local_new_i64(); t1 = tcg_temp_local_new_i64(); break; default: t0 = tcg_temp_new_i64(); t1 = tcg_temp_new_i64(); break; } gen_load_fpr64([[linerrd]], t0, [[ru]]); gen_load_fpr64([[linerrd]], t1, rt); #define LMI_HELPER(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break #define LMI_HELPER_1(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break #define LMI_DIRECT(UP, LO, OP) \ case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break switch ([[pork]]) { LMI_HELPER(PADDSH, paddsh); LMI_HELPER(PADDUSH, paddush); LMI_HELPER(PADDH, paddh); LMI_HELPER(PADDW, paddw); LMI_HELPER(PADDSB, paddsb); LMI_HELPER(PADDUSB, paddusb); LMI_HELPER(PADDB, paddb); LMI_HELPER(PSUBSH, psubsh); LMI_HELPER(PSUBUSH, psubush); LMI_HELPER(PSUBH, psubh); LMI_HELPER(PSUBW, psubw); LMI_HELPER(PSUBSB, psubsb); LMI_HELPER(PSUBUSB, psubusb); LMI_HELPER(PSUBB, psubb); LMI_HELPER(PSHUFH, pshufh); LMI_HELPER(PACKSSWH, packsswh); LMI_HELPER(PACKSSHB, packsshb); LMI_HELPER(PACKUSHB, packushb); LMI_HELPER(PUNPCKLHW, punpcklhw); LMI_HELPER(PUNPCKHHW, punpckhhw); LMI_HELPER(PUNPCKLBH, punpcklbh); LMI_HELPER(PUNPCKHBH, punpckhbh); LMI_HELPER(PUNPCKLWD, punpcklwd); LMI_HELPER(PUNPCKHWD, punpckhwd); LMI_HELPER(PAVGH, pavgh); LMI_HELPER(PAVGB, pavgb); LMI_HELPER(PMAXSH, pmaxsh); LMI_HELPER(PMINSH, pminsh); LMI_HELPER(PMAXUB, pmaxub); LMI_HELPER(PMINUB, pminub); LMI_HELPER(PCMPEQW, pcmpeqw); LMI_HELPER(PCMPGTW, pcmpgtw); LMI_HELPER(PCMPEQH, pcmpeqh); LMI_HELPER(PCMPGTH, pcmpgth); LMI_HELPER(PCMPEQB, pcmpeqb); LMI_HELPER(PCMPGTB, pcmpgtb); LMI_HELPER(PSLLW, psllw); LMI_HELPER(PSLLH, psllh); LMI_HELPER(PSRLW, psrlw); LMI_HELPER(PSRLH, psrlh); LMI_HELPER(PSRAW, psraw); LMI_HELPER(PSRAH, psrah); LMI_HELPER(PMULLH, pmullh); LMI_HELPER(PMULHH, pmulhh); LMI_HELPER(PMULHUH, pmulhuh); LMI_HELPER(PMADDHW, pmaddhw); LMI_HELPER(PASUBUB, pasubub); LMI_HELPER_1(BIADD, biadd); LMI_HELPER_1(PMOVMSKB, pmovmskb); LMI_DIRECT(PADDD, paddd, add); LMI_DIRECT(PSUBD, psubd, sub); LMI_DIRECT(XOR_CP2, xor, xor); LMI_DIRECT(NOR_CP2, nor, nor); LMI_DIRECT(AND_CP2, and, and); LMI_DIRECT(PANDN, pandn, andc); LMI_DIRECT(OR, or, or); case OPC_PINSRH_0: tcg_gen_deposit_i64(t0, t0, t1, 0, 16); opn = "pinsrh_0"; break; case OPC_PINSRH_1: tcg_gen_deposit_i64(t0, t0, t1, 16, 16); opn = "pinsrh_1"; break; case OPC_PINSRH_2: tcg_gen_deposit_i64(t0, t0, t1, 32, 16); opn = "pinsrh_2"; break; case OPC_PINSRH_3: tcg_gen_deposit_i64(t0, t0, t1, 48, 16); opn = "pinsrh_3"; break; case OPC_PEXTRH: tcg_gen_andi_i64(t1, t1, 3); tcg_gen_shli_i64(t1, t1, 4); tcg_gen_shr_i64(t0, t0, t1); tcg_gen_ext16u_i64(t0, t0); opn = "pextrh"; break; case OPC_ADDU_CP2: tcg_gen_add_i64(t0, t0, t1); tcg_gen_ext32s_i64(t0, t0); opn = "addu"; break; case OPC_SUBU_CP2: tcg_gen_sub_i64(t0, t0, t1); tcg_gen_ext32s_i64(t0, t0); opn = "addu"; break; case OPC_SLL_CP2: opn = "sll"; shift_max = 32; goto do_shift; case OPC_SRL_CP2: opn = "srl"; shift_max = 32; goto do_shift; case OPC_SRA_CP2: opn = "sra"; shift_max = 32; goto do_shift; case OPC_DSLL_CP2: opn = "dsll"; shift_max = 64; goto do_shift; case OPC_DSRL_CP2: opn = "dsrl"; shift_max = 64; goto do_shift; case OPC_DSRA_CP2: opn = "dsra"; shift_max = 64; goto do_shift; do_shift: tcg_gen_andi_i64(t1, t1, shift_max - 1); switch ([[pork]]) { case OPC_SLL_CP2: case OPC_DSLL_CP2: tcg_gen_shl_i64(t0, t0, t1); break; case OPC_SRA_CP2: case OPC_DSRA_CP2: tcg_gen_sar_i64(t0, t0, t1); break; case OPC_SRL_CP2: tcg_gen_ext32u_i64(t0, t0); case OPC_DSRL_CP2: tcg_gen_shr_i64(t0, t0, t1); break; } if (shift_max == 32) { tcg_gen_ext32s_i64(t0, t0); } tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max); tcg_gen_neg_i64(t1, t1); tcg_gen_and_i64(t0, t0, t1); break; case OPC_ADD_CP2: case OPC_DADD_CP2: { TCGv_i64 t2 = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64(t2, t0); tcg_gen_add_i64(t0, t1, t2); if ([[pork]] == OPC_ADD_CP2) { tcg_gen_ext32s_i64(t0, t0); } tcg_gen_xor_i64(t1, t1, t2); tcg_gen_xor_i64(t2, t2, t0); tcg_gen_andc_i64(t1, t2, t1); tcg_temp_free_i64(t2); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception([[linerrd]], EXCP_OVERFLOW); gen_set_label(lab); opn = ([[pork]] == OPC_ADD_CP2 ? "add" : "dadd"); break; } case OPC_SUB_CP2: case OPC_DSUB_CP2: { TCGv_i64 t2 = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64(t2, t0); tcg_gen_sub_i64(t0, t1, t2); if ([[pork]] == OPC_SUB_CP2) { tcg_gen_ext32s_i64(t0, t0); } tcg_gen_xor_i64(t1, t1, t2); tcg_gen_xor_i64(t2, t2, t0); tcg_gen_and_i64(t1, t1, t2); tcg_temp_free_i64(t2); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception([[linerrd]], EXCP_OVERFLOW); gen_set_label(lab); opn = ([[pork]] == OPC_SUB_CP2 ? "sub" : "dsub"); break; } case OPC_PMULUW: tcg_gen_ext32u_i64(t0, t0); tcg_gen_ext32u_i64(t1, t1); tcg_gen_mul_i64(t0, t0, t1); opn = "pmuluw"; break; case OPC_SEQU_CP2: case OPC_SEQ_CP2: case OPC_SLTU_CP2: case OPC_SLT_CP2: case OPC_SLEU_CP2: case OPC_SLE_CP2: default: MIPS_INVAL(opn); generate_exception([[linerrd]], EXCP_RI); return; } #undef LMI_HELPER #undef LMI_DIRECT gen_store_fpr64([[linerrd]], t0, rd); (void)opn; MIPS_DEBUG("%s %s, %s, %s", opn, fregnames[rd], fregnames[[[ru]]], fregnames[rt]); tcg_temp_free_i64(t0); tcg_temp_free_i64(t1); }[Succeeded / Failed / Skipped / Total] 137 / 25 / 98 / 260:  10%|▉         | 260/2690 [37:55<5:54:22,  8.75s/it][Succeeded / Failed / Skipped / Total] 137 / 25 / 98 / 260:  10%|▉         | 261/2690 [38:14<5:55:56,  8.79s/it][Succeeded / Failed / Skipped / Total] 138 / 25 / 98 / 261:  10%|▉         | 261/2690 [38:14<5:55:56,  8.79s/it][Succeeded / Failed / Skipped / Total] 138 / 25 / 98 / 261:  10%|▉         | 262/2690 [38:20<5:55:15,  8.78s/it][Succeeded / Failed / Skipped / Total] 138 / 26 / 98 / 262:  10%|▉         | 262/2690 [38:20<5:55:15,  8.78s/it][Succeeded / Failed / Skipped / Total] 138 / 26 / 98 / 262:  10%|▉         | 263/2690 [38:28<5:54:59,  8.78s/it][Succeeded / Failed / Skipped / Total] 139 / 26 / 98 / 263:  10%|▉         | 263/2690 [38:28<5:54:59,  8.78s/it][Succeeded / Failed / Skipped / Total] 139 / 26 / 98 / 263:  10%|▉         | 264/2690 [38:28<5:53:34,  8.74s/it][Succeeded / Failed / Skipped / Total] 139 / 26 / 99 / 264:  10%|▉         | 264/2690 [38:28<5:53:34,  8.74s/it][Succeeded / Failed / Skipped / Total] 139 / 26 / 99 / 264:  10%|▉         | 265/2690 [38:51<5:55:36,  8.80s/it][Succeeded / Failed / Skipped / Total] 140 / 26 / 99 / 265:  10%|▉         | 265/2690 [38:51<5:55:36,  8.80s/it][Succeeded / Failed / Skipped / Total] 140 / 26 / 99 / 265:  10%|▉         | 266/2690 [38:52<5:54:11,  8.77s/it][Succeeded / Failed / Skipped / Total] 140 / 26 / 100 / 266:  10%|▉         | 266/2690 [38:52<5:54:11,  8.77s/it][Succeeded / Failed / Skipped / Total] 140 / 26 / 100 / 266:  10%|▉         | 267/2690 [39:12<5:55:45,  8.81s/it]
--------------------------------------------- Result 261 ---------------------------------------------
[[0 (1%)]] --> [[0 (98%)]] --> Socre: 0.9791886210441589

[[[[Adv]]]]: static inline void gen_op_mov_v_reg(int ot, TCGv [[t0]], int reg) { switch(ot) { case OT_BYTE: if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) { goto std_case; } else { tcg_gen_shri_tl([[t0]], cpu_regs[reg - 4], 8); tcg_gen_ext8u_tl([[t0]], [[t0]]); } break; default: std_case: tcg_gen_mov_tl([[t0]], cpu_regs[reg]); break; } }

[[[[Adv]]]]: static inline void gen_op_mov_v_reg(int ot, TCGv [[τ00]], int reg) { switch(ot) { case OT_BYTE: if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) { goto std_case; } else { tcg_gen_shri_tl([[τ00]], cpu_regs[reg - 4], 8); tcg_gen_ext8u_tl([[τ00]], [[τ00]]); } break; default: std_case: tcg_gen_mov_tl([[τ00]], cpu_regs[reg]); break; } }
--------------------------------------------- Result 262 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: uint64_t helper_addlv (uint64_t [[op1]], uint64_t [[op2]]) { uint64_t [[tmp]] = [[op1]]; [[op1]] = (uint32_t)([[op1]] + [[op2]]); if (unlikely(([[tmp]] ^ [[op2]] ^ (-1UL)) & ([[tmp]] ^ [[op1]]) & (1UL << 31))) { arith_excp(env, GETPC(), EXC_M_IOV, 0); } return [[op1]]; }

[[[[Adv]]]]: uint64_t helper_addlv (uint64_t [[opusford]], uint64_t [[flat9]]) { uint64_t [[tsnp]] = [[opusford]]; [[opusford]] = (uint32_t)([[opusford]] + [[flat9]]); if (unlikely(([[tsnp]] ^ [[flat9]] ^ (-1UL)) & ([[tsnp]] ^ [[opusford]]) & (1UL << 31))) { arith_excp(env, GETPC(), EXC_M_IOV, 0); } return [[opusford]]; }
--------------------------------------------- Result 263 ---------------------------------------------
[[0 (2%)]] --> [[0 (97%)]] --> Socre: 0.971885621547699

[[[[Adv]]]]: void disas_a64_insn(CPUARMState *env, DisasContext *[[s]]) { uint32_t [[insn]]; [[insn]] = arm_ldl_code(env, [[s]]->pc, [[s]]->bswap_code); [[s]]->insn = [[insn]]; [[s]]->pc += 4; switch (([[insn]] >> 24) & 0x1f) { default: unallocated_encoding([[s]]); break; } if (unlikely([[s]]->singlestep_enabled) && ([[s]]->is_jmp == DISAS_TB_JUMP)) { [[s]]->is_jmp = DISAS_JUMP; } }

[[[[Adv]]]]: void disas_a64_insn(CPUARMState *env, DisasContext *[[с]]) { uint32_t [[exh]]; [[exh]] = arm_ldl_code(env, [[с]]->pc, [[с]]->bswap_code); [[с]]->insn = [[exh]]; [[с]]->pc += 4; switch (([[exh]] >> 24) & 0x1f) { default: unallocated_encoding([[с]]); break; } if (unlikely([[с]]->singlestep_enabled) && ([[с]]->is_jmp == DISAS_TB_JUMP)) { [[с]]->is_jmp = DISAS_JUMP; } }
--------------------------------------------- Result 264 ---------------------------------------------
[[0 (74%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n) { target_ulong tmp; tmp = ldtul_p(mem_buf); if (n < 32) { env->active_tc.gpr[n] = tmp; return sizeof(target_ulong); } if (env->CP0_Config1 & (1 << CP0C1_FP) && n >= 38 && n < 73) { if (n < 70) { if (env->CP0_Status & (1 << CP0St_FR)) env->active_fpu.fpr[n - 38].d = tmp; else env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp; } switch (n) { case 70: env->active_fpu.fcr31 = tmp & 0xFF83FFFF; RESTORE_ROUNDING_MODE; #ifndef CONFIG_SOFTFLOAT SET_FP_ENABLE(env->active_fpu.fcr31, 0); #endif break; case 71: env->active_fpu.fcr0 = tmp; break; } return sizeof(target_ulong); } switch (n) { case 32: env->CP0_Status = tmp; break; case 33: env->active_tc.LO[0] = tmp; break; case 34: env->active_tc.HI[0] = tmp; break; case 35: env->CP0_BadVAddr = tmp; break; case 36: env->CP0_Cause = tmp; break; case 37: env->active_tc.PC = tmp; break; case 72: break; default: if (n > 89) return 0; break; } return sizeof(target_ulong); }
--------------------------------------------- Result 265 ---------------------------------------------
[[0 (34%)]] --> [[0 (56%)]] --> Socre: 0.5587096810340881

[[[[Adv]]]]: QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *[[opaque]]) { QEMUBH *bh; bh = g_malloc0(sizeof(QEMUBH)); bh->ctx = ctx; bh->cb = cb; bh->opaque = [[opaque]]; qemu_mutex_lock(&ctx->bh_lock); bh->next = ctx->first_bh; smp_wmb(); ctx->first_bh = bh; qemu_mutex_unlock(&ctx->bh_lock); return bh; }

[[[[Adv]]]]: QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *[[outsider]]) { QEMUBH *bh; bh = g_malloc0(sizeof(QEMUBH)); bh->ctx = ctx; bh->cb = cb; bh->opaque = [[outsider]]; qemu_mutex_lock(&ctx->bh_lock); bh->next = ctx->first_bh; smp_wmb(); ctx->first_bh = bh; qemu_mutex_unlock(&ctx->bh_lock); return bh; }
--------------------------------------------- Result 266 ---------------------------------------------
[[0 (84%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void audiogen(void *data, enum AVSampleFormat sample_fmt, int channels, int sample_rate, int nb_samples) { int i, ch, k; double v, f, a, ampa; double tabf1[SWR_CH_MAX]; double tabf2[SWR_CH_MAX]; double taba[SWR_CH_MAX]; unsigned static rnd; #define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v); #define uint_rand(x) (x = x * 1664525 + 1013904223) #define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1) k = 0; a = 0; for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE a += M_PI * 1000.0 * 2.0 / sample_rate; } a = 0; for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE f = 100.0 + (((10000.0 - 100.0) * i) / sample_rate); a += M_PI * f * 2.0 / sample_rate; } for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) { v = dbl_rand(rnd) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE } for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) { v = dbl_rand(rnd); for (ch = 0; ch < channels; ch++) PUT_SAMPLE } for (ch = 0; ch < channels; ch++) { taba[ch] = 0; tabf1[ch] = 100 + uint_rand(rnd) % 5000; tabf2[ch] = 100 + uint_rand(rnd) % 5000; } for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) { for (ch = 0; ch < channels; ch++) { v = sin(taba[ch]) * 0.30; PUT_SAMPLE f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate); taba[ch] += M_PI * f * 2.0 / sample_rate; } } a = 0; ampa = 0; for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) { for (ch = 0; ch < channels; ch++) { double amp = (1.0 + sin(ampa)) * 0.15; if (ch & 1) amp = 0.30 - amp; v = sin(a) * amp; PUT_SAMPLE a += M_PI * 500.0 * 2.0 / sample_rate; ampa += M_PI * 2.0 / sample_rate; } } }
--------------------------------------------- Result 267 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 141 / 26 / 100 / 267:  10%|▉         | 267/2690 [39:12<5:55:45,  8.81s/it][Succeeded / Failed / Skipped / Total] 141 / 26 / 100 / 267:  10%|▉         | 268/2690 [39:12<5:54:22,  8.78s/it][Succeeded / Failed / Skipped / Total] 141 / 26 / 101 / 268:  10%|▉         | 268/2690 [39:12<5:54:22,  8.78s/it][Succeeded / Failed / Skipped / Total] 141 / 26 / 101 / 268:  10%|█         | 269/2690 [39:30<5:55:38,  8.81s/it][Succeeded / Failed / Skipped / Total] 142 / 26 / 101 / 269:  10%|█         | 269/2690 [39:30<5:55:38,  8.81s/it][Succeeded / Failed / Skipped / Total] 142 / 26 / 101 / 269:  10%|█         | 270/2690 [39:31<5:54:15,  8.78s/it][[0 (59%)]] --> [[0 (46%)]] --> Socre: 0.5354086756706238

[[[[Adv]]]]: static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab) { CURSORINFO ci = {0}; #define CURSOR_ERROR(str) \ if (!gdigrab->cursor_error_printed) { \ WIN32_API_ERROR(str); \ gdigrab->cursor_error_printed = 1; \ } ci.cbSize = sizeof(ci); if (GetCursorInfo(&ci)) { HCURSOR [[icon]] = CopyCursor(ci.hCursor); ICONINFO info; POINT pos; RECT clip_rect = gdigrab->clip_rect; HWND hwnd = gdigrab->hwnd; info.hbmMask = NULL; info.hbmColor = NULL; if (ci.flags != CURSOR_SHOWING) return; if (![[icon]]) { [[icon]] = CopyCursor(LoadCursor(NULL, IDC_ARROW)); } if (!GetIconInfo([[icon]], &info)) { CURSOR_ERROR("Could not get icon info"); goto icon_error; } pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot; pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot; if (hwnd) { RECT rect; if (GetWindowRect(hwnd, &rect)) { pos.x -= rect.left; pos.y -= rect.top; } else { CURSOR_ERROR("Couldn't get window rectangle"); goto icon_error; } } av_log(s1, AV_LOG_DEBUG, "Cursor pos (%li,%li) -> (%li,%li)\n", ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y); if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left && pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) { if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, [[icon]])) CURSOR_ERROR("Couldn't draw icon"); } icon_error: if ([[icon]]) DestroyCursor([[icon]]); } else { CURSOR_ERROR("Couldn't get cursor info"); } }

[[[[Adv]]]]: static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab) { CURSORINFO ci = {0}; #define CURSOR_ERROR(str) \ if (!gdigrab->cursor_error_printed) { \ WIN32_API_ERROR(str); \ gdigrab->cursor_error_printed = 1; \ } ci.cbSize = sizeof(ci); if (GetCursorInfo(&ci)) { HCURSOR [[indication]] = CopyCursor(ci.hCursor); ICONINFO info; POINT pos; RECT clip_rect = gdigrab->clip_rect; HWND hwnd = gdigrab->hwnd; info.hbmMask = NULL; info.hbmColor = NULL; if (ci.flags != CURSOR_SHOWING) return; if (![[indication]]) { [[indication]] = CopyCursor(LoadCursor(NULL, IDC_ARROW)); } if (!GetIconInfo([[indication]], &info)) { CURSOR_ERROR("Could not get icon info"); goto icon_error; } pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot; pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot; if (hwnd) { RECT rect; if (GetWindowRect(hwnd, &rect)) { pos.x -= rect.left; pos.y -= rect.top; } else { CURSOR_ERROR("Couldn't get window rectangle"); goto icon_error; } } av_log(s1, AV_LOG_DEBUG, "Cursor pos (%li,%li) -> (%li,%li)\n", ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y); if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left && pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) { if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, [[indication]])) CURSOR_ERROR("Couldn't draw icon"); } icon_error: if ([[indication]]) DestroyCursor([[indication]]); } else { CURSOR_ERROR("Couldn't get cursor info"); } }
--------------------------------------------- Result 268 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void machine_initfn(Object *obj) { MachineState *ms = MACHINE(obj); ms->kernel_irqchip_allowed = "True" == "True"; ms->kvm_shadow_mem = -1; ms->dump_guest_core = "True" == "True"; object_property_add_str(obj, "accel", machine_get_accel, machine_set_accel, NULL); object_property_set_description(obj, "accel", "Accelerator list", NULL); object_property_add_bool(obj, "kernel-irqchip", NULL, machine_set_kernel_irqchip, NULL); object_property_set_description(obj, "kernel-irqchip", "Use KVM in-kernel irqchip", NULL); object_property_add(obj, "kvm-shadow-mem", "int", machine_get_kvm_shadow_mem, machine_set_kvm_shadow_mem, NULL, NULL, NULL); object_property_set_description(obj, "kvm-shadow-mem", "KVM shadow MMU size", NULL); object_property_add_str(obj, "kernel", machine_get_kernel, machine_set_kernel, NULL); object_property_set_description(obj, "kernel", "Linux kernel image file", NULL); object_property_add_str(obj, "initrd", machine_get_initrd, machine_set_initrd, NULL); object_property_set_description(obj, "initrd", "Linux initial ramdisk file", NULL); object_property_add_str(obj, "append", machine_get_append, machine_set_append, NULL); object_property_set_description(obj, "append", "Linux kernel command line", NULL); object_property_add_str(obj, "dtb", machine_get_dtb, machine_set_dtb, NULL); object_property_set_description(obj, "dtb", "Linux kernel device tree file", NULL); object_property_add_str(obj, "dumpdtb", machine_get_dumpdtb, machine_set_dumpdtb, NULL); object_property_set_description(obj, "dumpdtb", "Dump current dtb to a file and quit", NULL); object_property_add(obj, "phandle-start", "int", machine_get_phandle_start, machine_set_phandle_start, NULL, NULL, NULL); object_property_set_description(obj, "phandle-start", "The first phandle ID we may generate dynamically", NULL); object_property_add_str(obj, "dt-compatible", machine_get_dt_compatible, machine_set_dt_compatible, NULL); object_property_set_description(obj, "dt-compatible", "Overrides the \"compatible\" property of the dt root node", NULL); object_property_add_bool(obj, "dump-guest-core", machine_get_dump_guest_core, machine_set_dump_guest_core, NULL); object_property_set_description(obj, "dump-guest-core", "Include guest memory in a core dump", NULL); object_property_add_bool(obj, "mem-merge", machine_get_mem_merge, machine_set_mem_merge, NULL); object_property_set_description(obj, "mem-merge", "Enable/disable memory merge support", NULL); object_property_add_bool(obj, "usb", machine_get_usb, machine_set_usb, NULL); object_property_set_description(obj, "usb", "Set on/off to enable/disable usb", NULL); object_property_add_str(obj, "firmware", machine_get_firmware, machine_set_firmware, NULL); object_property_set_description(obj, "firmware", "Firmware image", NULL); object_property_add_bool(obj, "iommu", machine_get_iommu, machine_set_iommu, NULL); object_property_set_description(obj, "iommu", "Set on/off to enable/disable Intel IOMMU (VT-d)", NULL); ms->sysbus_notifier.notify = machine_init_notify; qemu_add_machine_init_done_notifier(&ms->sysbus_notifier); }
--------------------------------------------- Result 269 ---------------------------------------------
[[0 (2%)]] --> [[0 (98%)]] --> Socre: 0.9842719435691833

[[[[Adv]]]]: static void sigp_store_adtl_status(CPUState *[[cs]], run_on_cpu_data [[arg]]) { S390CPU *[[cpu]] = S390_CPU([[cs]]); SigpInfo *si = [[arg]].host_ptr; if (!s390_has_feat(S390_FEAT_VECTOR)) { set_sigp_status(si, SIGP_STAT_INVALID_ORDER); return; } if (s390_cpu_get_state([[cpu]]) != CPU_STATE_STOPPED) { set_sigp_status(si, SIGP_STAT_INCORRECT_STATE); return; } if (si->param & 0x3ff) { set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER); return; } cpu_synchronize_state([[cs]]); if (kvm_s390_store_adtl_status([[cpu]], si->param)) { set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER); return; } si->cc = SIGP_CC_ORDER_CODE_ACCEPTED; }

[[[[Adv]]]]: static void sigp_store_adtl_status(CPUState *[[m²]], run_on_cpu_data [[sagm]]) { S390CPU *[[brain]] = S390_CPU([[m²]]); SigpInfo *si = [[sagm]].host_ptr; if (!s390_has_feat(S390_FEAT_VECTOR)) { set_sigp_status(si, SIGP_STAT_INVALID_ORDER); return; } if (s390_cpu_get_state([[brain]]) != CPU_STATE_STOPPED) { set_sigp_status(si, SIGP_STAT_INCORRECT_STATE); return; } if (si->param & 0x3ff) { set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER); return; } cpu_synchronize_state([[m²]]); if (kvm_s390_store_adtl_status([[brain]], si->param)) { set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER); return; } si->cc = SIGP_CC_ORDER_CODE_ACCEPTED; }
--------------------------------------------- Result 270 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 142 / 26 / 102 / 270:  10%|█         | 270/2690 [39:31<5:54:15,  8.78s/it][Succeeded / Failed / Skipped / Total] 142 / 26 / 102 / 270:  10%|█         | 271/2690 [39:32<5:53:00,  8.76s/it][Succeeded / Failed / Skipped / Total] 143 / 26 / 102 / 271:  10%|█         | 271/2690 [39:32<5:53:00,  8.76s/it][Succeeded / Failed / Skipped / Total] 143 / 26 / 102 / 271:  10%|█         | 272/2690 [39:33<5:51:38,  8.73s/it][Succeeded / Failed / Skipped / Total] 143 / 26 / 103 / 272:  10%|█         | 272/2690 [39:33<5:51:38,  8.73s/it][Succeeded / Failed / Skipped / Total] 143 / 26 / 103 / 272:  10%|█         | 273/2690 [39:33<5:50:16,  8.70s/it][Succeeded / Failed / Skipped / Total] 143 / 26 / 104 / 273:  10%|█         | 273/2690 [39:33<5:50:16,  8.70s/it][Succeeded / Failed / Skipped / Total] 143 / 26 / 104 / 273:  10%|█         | 274/2690 [39:43<5:50:12,  8.70s/it][Succeeded / Failed / Skipped / Total] 144 / 26 / 104 / 274:  10%|█         | 274/2690 [39:43<5:50:12,  8.70s/it][Succeeded / Failed / Skipped / Total] 144 / 26 / 104 / 274:  10%|█         | 275/2690 [39:48<5:49:32,  8.68s/it][Succeeded / Failed / Skipped / Total] 145 / 26 / 104 / 275:  10%|█         | 275/2690 [39:48<5:49:32,  8.68s/it][Succeeded / Failed / Skipped / Total] 145 / 26 / 104 / 275:  10%|█         | 276/2690 [39:56<5:49:21,  8.68s/it][[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void hmp_migrate_status_cb(void *opaque) { MigrationStatus *status = opaque; MigrationInfo *info; info = qmp_query_migrate(NULL); if (!info->has_status || strcmp(info->status, "active") == 0) { if (info->has_disk) { int progress; if (info->disk->remaining) { progress = info->disk->transferred * 100 / info->disk->total; } else { progress = 100; } monitor_printf(status->mon, "Completed %d %%\r", progress); monitor_flush(status->mon); } timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000); } else { if (status->is_block_migration) { monitor_printf(status->mon, "\n"); } monitor_resume(status->mon); timer_del(status->timer); g_free(status); } qapi_free_MigrationInfo(info); }
--------------------------------------------- Result 271 ---------------------------------------------
[[0 (52%)]] --> [[0 (24%)]] --> Socre: 0.7619743347167969

[[[[Adv]]]]: void bdrv_delete(BlockDriverState *[[bs]]) { assert(![[bs]]->peer); if ([[bs]]->device_name[0] != '\0') { QTAILQ_REMOVE(&bdrv_states, [[bs]], list); } bdrv_close([[bs]]); if ([[bs]]->file != NULL) { bdrv_delete([[bs]]->file); } assert([[bs]] != bs_snapshots); qemu_free([[bs]]); }

[[[[Adv]]]]: void bdrv_delete(BlockDriverState *[[sun]]) { assert(![[sun]]->peer); if ([[sun]]->device_name[0] != '\0') { QTAILQ_REMOVE(&bdrv_states, [[sun]], list); } bdrv_close([[sun]]); if ([[sun]]->file != NULL) { bdrv_delete([[sun]]->file); } assert([[sun]] != bs_snapshots); qemu_free([[sun]]); }
--------------------------------------------- Result 272 ---------------------------------------------
[[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes) { IscsiLun *iscsilun = bs->opaque; struct IscsiTask iTask; struct unmap_list list; int r = 0; if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) { return -ENOTSUP; } if (!iscsilun->lbp.lbpu) { return 0; } list.lba = offset / iscsilun->block_size; list.num = bytes / iscsilun->block_size; iscsi_co_init_iscsitask(iscsilun, &iTask); qemu_mutex_lock(&iscsilun->mutex); retry: if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1, iscsi_co_generic_cb, &iTask) == NULL) { r = -ENOMEM; goto out_unlock; } while (!iTask.complete) { iscsi_set_events(iscsilun); qemu_mutex_unlock(&iscsilun->mutex); qemu_coroutine_yield(); qemu_mutex_lock(&iscsilun->mutex); } if (iTask.task != NULL) { scsi_free_scsi_task(iTask.task); iTask.task = NULL; } if (iTask.do_retry) { iTask.complete = 0; goto retry; } if (iTask.status == SCSI_STATUS_CHECK_CONDITION) { goto out_unlock; } if (iTask.status != SCSI_STATUS_GOOD) { r = iTask.err_code; goto out_unlock; } iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS, bytes >> BDRV_SECTOR_BITS); out_unlock: qemu_mutex_unlock(&iscsilun->mutex); return r; }
--------------------------------------------- Result 273 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw, int mmu_idx) { MIPSCPU *cpu = MIPS_CPU(cs); CPUMIPSState *env = &cpu->env; #if !defined(CONFIG_USER_ONLY) hwaddr physical; int prot; int access_type; #endif int ret = 0; #if 0 log_cpu_state(cs, 0); #endif qemu_log_mask(CPU_LOG_MMU, "%s pc " TARGET_FMT_lx " ad %" VADDR_PRIx " rw %d mmu_idx %d\n", __func__, env->active_tc.PC, address, rw, mmu_idx); #if !defined(CONFIG_USER_ONLY) access_type = ACCESS_INT; ret = get_physical_address(env, &physical, &prot, address, rw, access_type); qemu_log_mask(CPU_LOG_MMU, "%s address=%" VADDR_PRIx " ret %d physical " TARGET_FMT_plx " prot %d\n", __func__, address, ret, physical, prot); if (ret == TLBRET_MATCH) { tlb_set_page(cs, address & TARGET_PAGE_MASK, physical & TARGET_PAGE_MASK, prot | PAGE_EXEC, mmu_idx, TARGET_PAGE_SIZE); ret = 0; } else if (ret < 0) #endif { raise_mmu_exception(env, address, rw, ret); ret = 1; } return ret; }
--------------------------------------------- Result 274 ---------------------------------------------
[[0 (6%)]] --> [[0 (60%)]] --> Socre: 0.6026639938354492

[[[[Adv]]]]: static int hdev_open(BlockDriverState *bs, const char *[[filename]], int flags) { BDRVRawState *[[s]] = bs->opaque; int access_flags, create_flags; DWORD [[overlapped]]; char [[device_name]][64]; if (strstart([[filename]], "/dev/cdrom", NULL)) { if (find_cdrom([[device_name]], sizeof([[device_name]])) < 0) return -ENOENT; [[filename]] = [[device_name]]; } else { if ((([[filename]][0] >= 'a' && [[filename]][0] <= 'z') || ([[filename]][0] >= 'A' && [[filename]][0] <= 'Z')) && [[filename]][1] == ':' && [[filename]][2] == '\0') { snprintf([[device_name]], sizeof([[device_name]]), "\\\\.\\%c:", [[filename]][0]); [[filename]] = [[device_name]]; } } [[s]]->type = find_device_type(bs, [[filename]]); if ((flags & BDRV_O_ACCESS) == O_RDWR) { access_flags = GENERIC_READ | GENERIC_WRITE; } else { access_flags = GENERIC_READ; } create_flags = OPEN_EXISTING; #ifdef QEMU_TOOL [[overlapped]] = FILE_ATTRIBUTE_NORMAL; #else [[overlapped]] = FILE_FLAG_OVERLAPPED; #endif [[s]]->hfile = CreateFile([[filename]], access_flags, FILE_SHARE_READ, NULL, create_flags, [[overlapped]], NULL); if ([[s]]->hfile == INVALID_HANDLE_VALUE) return -1; return 0; }

[[[[Adv]]]]: static int hdev_open(BlockDriverState *bs, const char *[[diskemblem]], int flags) { BDRVRawState *[[chains]] = bs->opaque; int access_flags, create_flags; DWORD [[disagreepage]]; char [[uservirtualtag]][64]; if (strstart([[diskemblem]], "/dev/cdrom", NULL)) { if (find_cdrom([[uservirtualtag]], sizeof([[uservirtualtag]])) < 0) return -ENOENT; [[diskemblem]] = [[uservirtualtag]]; } else { if ((([[diskemblem]][0] >= 'a' && [[diskemblem]][0] <= 'z') || ([[diskemblem]][0] >= 'A' && [[diskemblem]][0] <= 'Z')) && [[diskemblem]][1] == ':' && [[diskemblem]][2] == '\0') { snprintf([[uservirtualtag]], sizeof([[uservirtualtag]]), "\\\\.\\%c:", [[diskemblem]][0]); [[diskemblem]] = [[uservirtualtag]]; } } [[chains]]->type = find_device_type(bs, [[diskemblem]]); if ((flags & BDRV_O_ACCESS) == O_RDWR) { access_flags = GENERIC_READ | GENERIC_WRITE; } else { access_flags = GENERIC_READ; } create_flags = OPEN_EXISTING; #ifdef QEMU_TOOL [[disagreepage]] = FILE_ATTRIBUTE_NORMAL; #else [[disagreepage]] = FILE_FLAG_OVERLAPPED; #endif [[chains]]->hfile = CreateFile([[diskemblem]], access_flags, FILE_SHARE_READ, NULL, create_flags, [[disagreepage]], NULL); if ([[chains]]->hfile == INVALID_HANDLE_VALUE) return -1; return 0; }
--------------------------------------------- Result 275 ---------------------------------------------
[[0 (15%)]] --> [[0 (61%)]] --> Socre: 0.6053851246833801

[[[[Adv]]]]: static ModuleTypeList *find_type(module_init_type [[type]]) { ModuleTypeList *l; init_types(); l = &init_type_list[[[type]]]; return l; }

[[[[Adv]]]]: static ModuleTypeList *find_type(module_init_type [[caste]]) { ModuleTypeList *l; init_types(); l = &init_type_list[[[caste]]]; return l; }
--------------------------------------------- Result 276 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 146 / 26 / 104 / 276:  10%|█         | 276/2690 [39:56<5:49:21,  8.68s/it][Succeeded / Failed / Skipped / Total] 146 / 26 / 104 / 276:  10%|█         | 277/2690 [40:00<5:48:33,  8.67s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 104 / 277:  10%|█         | 277/2690 [40:00<5:48:33,  8.67s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 104 / 277:  10%|█         | 278/2690 [40:01<5:47:13,  8.64s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 105 / 278:  10%|█         | 278/2690 [40:01<5:47:13,  8.64s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 105 / 278:  10%|█         | 279/2690 [40:01<5:45:54,  8.61s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 106 / 279:  10%|█         | 279/2690 [40:01<5:45:54,  8.61s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 106 / 279:  10%|█         | 280/2690 [40:02<5:44:35,  8.58s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 107 / 280:  10%|█         | 280/2690 [40:02<5:44:35,  8.58s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 107 / 280:  10%|█         | 281/2690 [40:02<5:43:17,  8.55s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 108 / 281:  10%|█         | 281/2690 [40:02<5:43:17,  8.55s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 108 / 281:  10%|█         | 282/2690 [40:03<5:42:00,  8.52s/it][[0 (9%)]] --> [[0 (98%)]] --> Socre: 0.9836761355400085

[[[[Adv]]]]: int kvm_arch_on_sigbus(int code, void *addr) { #ifdef KVM_CAP_MCE if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) { void *vaddr; ram_addr_t ram_addr; target_phys_addr_t [[paddr]]; vaddr = addr; if (qemu_ram_addr_from_host(vaddr, &ram_addr) || !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr, &[[paddr]])) { fprintf(stderr, "Hardware memory error for memory used by " "QEMU itself instead of guest system!: %p\n", addr); return 0; } kvm_mce_inj_srao_memscrub2(first_cpu, [[paddr]]); } else #endif { if (code == BUS_MCEERR_AO) { return 0; } else if (code == BUS_MCEERR_AR) { hardware_memory_error(); } else { return 1; } } return 0; }

[[[[Adv]]]]: int kvm_arch_on_sigbus(int code, void *addr) { #ifdef KVM_CAP_MCE if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) { void *vaddr; ram_addr_t ram_addr; target_phys_addr_t [[ledд]]; vaddr = addr; if (qemu_ram_addr_from_host(vaddr, &ram_addr) || !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr, &[[ledд]])) { fprintf(stderr, "Hardware memory error for memory used by " "QEMU itself instead of guest system!: %p\n", addr); return 0; } kvm_mce_inj_srao_memscrub2(first_cpu, [[ledд]]); } else #endif { if (code == BUS_MCEERR_AO) { return 0; } else if (code == BUS_MCEERR_AR) { hardware_memory_error(); } else { return 1; } } return 0; }
--------------------------------------------- Result 277 ---------------------------------------------
[[0 (32%)]] --> [[0 (80%)]] --> Socre: 0.800938069820404

[[[[Adv]]]]: static int qemu_suspend_requested(void) { int [[r]] = suspend_requested; suspend_requested = 0; return [[r]]; }

[[[[Adv]]]]: static int qemu_suspend_requested(void) { int [[m]] = suspend_requested; suspend_requested = 0; return [[m]]; }
--------------------------------------------- Result 278 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void serial_tx_done(void *opaque) { SerialState *s = opaque; if (s->tx_burst < 0) { uint16_t divider; if (s->divider) divider = s->divider; else divider = 1; s->tx_burst = THROTTLE_TX_INTERVAL * 1000 / (1000000 * 10 / (s->baudbase / divider)); } s->thr_ipending = 1; s->lsr |= UART_LSR_THRE; s->lsr |= UART_LSR_TEMT; serial_update_irq(s); }
--------------------------------------------- Result 279 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd) { QXLDevSurfaceCreate surface; memset(&surface, 0, sizeof(surface)); dprint(1, "%s/%d: %dx%d\n", __func__, ssd->qxl.id, surface_width(ssd->ds), surface_height(ssd->ds)); surface.format = SPICE_SURFACE_FMT_32_xRGB; surface.width = surface_width(ssd->ds); surface.height = surface_height(ssd->ds); surface.stride = -surface.width * 4; surface.mouse_mode = "True" == "True"; surface.flags = 0; surface.type = 0; surface.mem = (uintptr_t)ssd->buf; surface.group_id = MEMSLOT_GROUP_HOST; qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC); }
--------------------------------------------- Result 280 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void init_proc_750fx (CPUPPCState *env) { gen_spr_ne_601(env); gen_spr_7xx(env); spr_register(env, SPR_L2CR, "L2CR", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, NULL, 0x00000000); gen_tbl(env); gen_spr_thrm(env); spr_register(env, SPR_750_THRM4, "THRM4", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_HID0, "HID0", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_HID1, "HID1", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_750FX_HID2, "HID2", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); gen_low_BATs(env); gen_high_BATs(env); init_excp_7x0(env); env->dcache_line_size = 32; env->icache_line_size = 32; ppc6xx_irq_init(env); }
--------------------------------------------- Result 281 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...)) { stream_printf(stream, "Trace file \"%s\" %s.\n", trace_file_name, trace_file_enabled ? "on" : "off"); }
--------------------------------------------- Result 282 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 147 / 26 / 109 / 282:  10%|█         | 282/2690 [40:03<5:42:00,  8.52s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 109 / 282:  11%|█         | 283/2690 [40:03<5:40:43,  8.49s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 110 / 283:  11%|█         | 283/2690 [40:03<5:40:43,  8.49s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 110 / 283:  11%|█         | 284/2690 [40:04<5:39:27,  8.47s/it][[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mkv_write_header(AVFormatContext *s) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; ebml_master ebml_header; AVDictionaryEntry *tag; int ret, i, version = 2; int64_t creation_time; if (!strcmp(s->oformat->name, "webm")) mkv->mode = MODE_WEBM; else mkv->mode = MODE_MATROSKAv2; if (mkv->mode != MODE_WEBM || av_dict_get(s->metadata, "stereo_mode", NULL, 0) || av_dict_get(s->metadata, "alpha_mode", NULL, 0)) version = 4; if (s->nb_streams > MAX_TRACKS) { av_log(s, AV_LOG_ERROR, "At most %d streams are supported for muxing in Matroska\n", MAX_TRACKS); return AVERROR(EINVAL); } for (i = 0; i < s->nb_streams; i++) { if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) { av_log(s, AV_LOG_ERROR, "The Matroska muxer does not yet support muxing %s\n", avcodec_get_name(s->streams[i]->codecpar->codec_id)); return AVERROR_PATCHWELCOME; } if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS || av_dict_get(s->streams[i]->metadata, "stereo_mode", NULL, 0) || av_dict_get(s->streams[i]->metadata, "alpha_mode", NULL, 0)) version = 4; } mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks)); if (!mkv->tracks) { ret = AVERROR(ENOMEM); goto fail; } ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0); put_ebml_uint (pb, EBML_ID_EBMLVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLREADVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLMAXIDLENGTH , 4); put_ebml_uint (pb, EBML_ID_EBMLMAXSIZELENGTH , 8); put_ebml_string (pb, EBML_ID_DOCTYPE , s->oformat->name); put_ebml_uint (pb, EBML_ID_DOCTYPEVERSION , version); put_ebml_uint (pb, EBML_ID_DOCTYPEREADVERSION , 2); end_ebml_master(pb, ebml_header); mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0); mkv->segment_offset = avio_tell(pb); mkv->main_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 10); if (!mkv->main_seekhead) { ret = AVERROR(ENOMEM); goto fail; } ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb)); if (ret < 0) goto fail; ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0); if (ret < 0) return ret; pb = mkv->info_bc; put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000); if ((tag = av_dict_get(s->metadata, "title", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value); if (!(s->flags & AVFMT_FLAG_BITEXACT)) { put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT); if ((tag = av_dict_get(s->metadata, "encoding_tool", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value); else put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT); if (mkv->mode != MODE_WEBM) { uint32_t segment_uid[4]; AVLFG lfg; av_lfg_init(&lfg, av_get_random_seed()); for (i = 0; i < 4; i++) segment_uid[i] = av_lfg_get(&lfg); put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16); } } else { const char *ident = "Lavf"; put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident); put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident); } if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) { int64_t date_utc = (creation_time - 978307200000000LL) * 1000; uint8_t date_utc_buf[8]; AV_WB64(date_utc_buf, date_utc); put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8); } mkv->duration = 0; mkv->duration_offset = avio_tell(pb); if (!mkv->is_live) { int64_t metadata_duration = get_metadata_duration(s); if (s->duration > 0) { int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, "Write early duration from recording time = %" PRIu64 "\n", scaledDuration); } else if (metadata_duration > 0) { int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, "Write early duration from metadata = %" PRIu64 "\n", scaledDuration); } else { put_ebml_void(pb, 11); } } if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live) end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info); else end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info); pb = s->pb; mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t)); mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t)); ret = mkv_write_tracks(s); if (ret < 0) goto fail; for (i = 0; i < s->nb_chapters; i++) mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id); ret = mkv_write_chapters(s); if (ret < 0) goto fail; if (mkv->mode != MODE_WEBM) { ret = mkv_write_attachments(s); if (ret < 0) goto fail; } ret = mkv_write_tags(s); if (ret < 0) goto fail; if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live) mkv_write_seekhead(pb, mkv); mkv->cues = mkv_start_cues(mkv->segment_offset); if (!mkv->cues) { ret = AVERROR(ENOMEM); goto fail; } if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) { mkv->cues_pos = avio_tell(pb); put_ebml_void(pb, mkv->reserve_cues_space); } av_init_packet(&mkv->cur_audio_pkt); mkv->cur_audio_pkt.size = 0; mkv->cluster_pos = -1; avio_flush(pb); if (pb->seekable & AVIO_SEEKABLE_NORMAL) { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 5000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 5 * 1024 * 1024; } else { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 1000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 32 * 1024; } return 0; fail: mkv_free(mkv); return ret; }
--------------------------------------------- Result 283 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: e1000_can_receive(void *opaque) { E1000State *s = opaque; return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) || s->mac_reg[RDH] != s->mac_reg[RDT]); }
--------------------------------------------- Result 284 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 147 / 26 / 111 / 284:  11%|█         | 284/2690 [40:04<5:39:27,  8.47s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 111 / 284:  11%|█         | 285/2690 [40:04<5:38:11,  8.44s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 112 / 285:  11%|█         | 285/2690 [40:04<5:38:11,  8.44s/it][Succeeded / Failed / Skipped / Total] 147 / 26 / 112 / 285:  11%|█         | 286/2690 [40:23<5:39:32,  8.47s/it][[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold void ff_sws_init_swScale_mmx(SwsContext *c) { int cpu_flags = av_get_cpu_flags(); #if HAVE_INLINE_ASM if (cpu_flags & AV_CPU_FLAG_MMX) sws_init_swScale_MMX(c); #if HAVE_MMXEXT_INLINE if (cpu_flags & AV_CPU_FLAG_MMXEXT) sws_init_swScale_MMX2(c); #endif #endif #if HAVE_YASM #define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \ if (c->srcBpc == 8) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \ ff_hscale8to19_ ## filtersize ## _ ## opt1; \ } else if (c->srcBpc == 9) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \ ff_hscale9to19_ ## filtersize ## _ ## opt1; \ } else if (c->srcBpc == 10) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \ ff_hscale10to19_ ## filtersize ## _ ## opt1; \ } else { \ hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \ ff_hscale16to19_ ## filtersize ## _ ## opt1; \ } \ } while (0) #define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \ switch (filtersize) { \ case 4: ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \ case 8: ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \ default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \ } #define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \ switch(c->dstBpc){ \ case 16: do_16_case; break; \ case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \ case 9: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_ ## opt; break; \ default: if (condition_8bit) vscalefn = ff_yuv2planeX_8_ ## opt; break; \ } #define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \ switch(c->dstBpc){ \ case 16: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2plane1_16_ ## opt1; break; \ case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \ case 9: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_ ## opt2; break; \ default: vscalefn = ff_yuv2plane1_8_ ## opt1; break; \ } #define case_rgb(x, X, opt) \ case PIX_FMT_ ## X: \ c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \ if (!c->chrSrcHSubSample) \ c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \ break #if ARCH_X86_32 if (cpu_flags & AV_CPU_FLAG_MMX) { ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx); ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx); ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT); switch (c->srcFormat) { case PIX_FMT_Y400A: c->lumToYV12 = ff_yuyvToY_mmx; if (c->alpPixBuf) c->alpToYV12 = ff_uyvyToY_mmx; break; case PIX_FMT_YUYV422: c->lumToYV12 = ff_yuyvToY_mmx; c->chrToYV12 = ff_yuyvToUV_mmx; break; case PIX_FMT_UYVY422: c->lumToYV12 = ff_uyvyToY_mmx; c->chrToYV12 = ff_uyvyToUV_mmx; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_mmx; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_mmx; break; case_rgb(rgb24, RGB24, mmx); case_rgb(bgr24, BGR24, mmx); case_rgb(bgra, BGRA, mmx); case_rgb(rgba, RGBA, mmx); case_rgb(abgr, ABGR, mmx); case_rgb(argb, ARGB, mmx); default: break; } } if (cpu_flags & AV_CPU_FLAG_MMXEXT) { ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1); } #endif #define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \ switch (filtersize) { \ case 4: ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \ case 8: ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \ default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \ else ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \ break; \ } if (cpu_flags & AV_CPU_FLAG_SSE2) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2); ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, , HAVE_ALIGNED_STACK || ARCH_X86_64); ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1); switch (c->srcFormat) { case PIX_FMT_Y400A: c->lumToYV12 = ff_yuyvToY_sse2; if (c->alpPixBuf) c->alpToYV12 = ff_uyvyToY_sse2; break; case PIX_FMT_YUYV422: c->lumToYV12 = ff_yuyvToY_sse2; c->chrToYV12 = ff_yuyvToUV_sse2; break; case PIX_FMT_UYVY422: c->lumToYV12 = ff_uyvyToY_sse2; c->chrToYV12 = ff_uyvyToUV_sse2; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_sse2; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_sse2; break; case_rgb(rgb24, RGB24, sse2); case_rgb(bgr24, BGR24, sse2); case_rgb(bgra, BGRA, sse2); case_rgb(rgba, RGBA, sse2); case_rgb(abgr, ABGR, sse2); case_rgb(argb, ARGB, sse2); default: break; } } if (cpu_flags & AV_CPU_FLAG_SSSE3) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3); switch (c->srcFormat) { case_rgb(rgb24, RGB24, ssse3); case_rgb(bgr24, BGR24, ssse3); default: break; } } if (cpu_flags & AV_CPU_FLAG_SSE4) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3); ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4, if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4, HAVE_ALIGNED_STACK || ARCH_X86_64); if (c->dstBpc == 16 && !isBE(c->dstFormat)) c->yuv2plane1 = ff_yuv2plane1_16_sse4; } if (cpu_flags & AV_CPU_FLAG_AVX) { ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, , HAVE_ALIGNED_STACK || ARCH_X86_64); ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1); switch (c->srcFormat) { case PIX_FMT_YUYV422: c->chrToYV12 = ff_yuyvToUV_avx; break; case PIX_FMT_UYVY422: c->chrToYV12 = ff_uyvyToUV_avx; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_avx; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_avx; break; case_rgb(rgb24, RGB24, avx); case_rgb(bgr24, BGR24, avx); case_rgb(bgra, BGRA, avx); case_rgb(rgba, RGBA, avx); case_rgb(abgr, ABGR, avx); case_rgb(argb, ARGB, avx); default: break; } } #endif }
--------------------------------------------- Result 285 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static unsigned tget(const uint8_t **p, int type, int le) { switch (type) { case TIFF_BYTE: return *(*p)++; case TIFF_SHORT: return tget_short(p, le); case TIFF_LONG: return tget_long(p, le); default: return UINT_MAX; } }
--------------------------------------------- Result 286 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 148 / 26 / 112 / 286:  11%|█         | 286/2690 [40:23<5:39:32,  8.47s/it][Succeeded / Failed / Skipped / Total] 148 / 26 / 112 / 286:  11%|█         | 287/2690 [40:24<5:38:17,  8.45s/it][Succeeded / Failed / Skipped / Total] 148 / 26 / 113 / 287:  11%|█         | 287/2690 [40:24<5:38:17,  8.45s/it][Succeeded / Failed / Skipped / Total] 148 / 26 / 113 / 287:  11%|█         | 288/2690 [40:32<5:38:07,  8.45s/it][[0 (13%)]] --> [[0 (56%)]] --> Socre: 0.5608593821525574

[[[[Adv]]]]: int opt_cpuflags(const char *opt, const char *[[arg]]) { #define CPUFLAG_MMX2 (AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMX2) #define CPUFLAG_3DNOW (AV_CPU_FLAG_3DNOW | AV_CPU_FLAG_MMX) #define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW) #define CPUFLAG_SSE (AV_CPU_FLAG_SSE | CPUFLAG_MMX2) #define CPUFLAG_SSE2 (AV_CPU_FLAG_SSE2 | CPUFLAG_SSE) #define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2) #define CPUFLAG_SSE3 (AV_CPU_FLAG_SSE3 | CPUFLAG_SSE2) #define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3) #define CPUFLAG_SSSE3 (AV_CPU_FLAG_SSSE3 | CPUFLAG_SSE3) #define CPUFLAG_SSE4 (AV_CPU_FLAG_SSE4 | CPUFLAG_SSSE3) #define CPUFLAG_SSE42 (AV_CPU_FLAG_SSE42 | CPUFLAG_SSE4) #define CPUFLAG_AVX (AV_CPU_FLAG_AVX | CPUFLAG_SSE42) #define CPUFLAG_XOP (AV_CPU_FLAG_XOP | CPUFLAG_AVX) #define CPUFLAG_FMA4 (AV_CPU_FLAG_FMA4 | CPUFLAG_AVX) static const AVOption [[cpuflags_opts]][] = { { "flags" , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = "flags" }, { "altivec" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC }, .unit = "flags" }, { "mmx" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX }, .unit = "flags" }, { "mmx2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2 }, .unit = "flags" }, { "sse" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE }, .unit = "flags" }, { "sse2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2 }, .unit = "flags" }, { "sse2slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW }, .unit = "flags" }, { "sse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3 }, .unit = "flags" }, { "sse3slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW }, .unit = "flags" }, { "ssse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3 }, .unit = "flags" }, { "atom" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM }, .unit = "flags" }, { "sse4.1" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4 }, .unit = "flags" }, { "sse4.2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42 }, .unit = "flags" }, { "avx" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX }, .unit = "flags" }, { "xop" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP }, .unit = "flags" }, { "fma4" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4 }, .unit = "flags" }, { "3dnow" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW }, .unit = "flags" }, { "3dnowext", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT }, .unit = "flags" }, { NULL }, }; static const AVClass class = { .class_name = "cpuflags", .item_name = av_default_item_name, .option = [[cpuflags_opts]], .version = LIBAVUTIL_VERSION_INT, }; int flags = av_get_cpu_flags(); int ret; const AVClass *pclass = &class; if ((ret = av_opt_eval_flags(&pclass, &[[cpuflags_opts]][0], [[arg]], &flags)) < 0) return ret; av_force_cpu_flags(flags); return 0; }

[[[[Adv]]]]: int opt_cpuflags(const char *opt, const char *[[vargg]]) { #define CPUFLAG_MMX2 (AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMX2) #define CPUFLAG_3DNOW (AV_CPU_FLAG_3DNOW | AV_CPU_FLAG_MMX) #define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW) #define CPUFLAG_SSE (AV_CPU_FLAG_SSE | CPUFLAG_MMX2) #define CPUFLAG_SSE2 (AV_CPU_FLAG_SSE2 | CPUFLAG_SSE) #define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2) #define CPUFLAG_SSE3 (AV_CPU_FLAG_SSE3 | CPUFLAG_SSE2) #define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3) #define CPUFLAG_SSSE3 (AV_CPU_FLAG_SSSE3 | CPUFLAG_SSE3) #define CPUFLAG_SSE4 (AV_CPU_FLAG_SSE4 | CPUFLAG_SSSE3) #define CPUFLAG_SSE42 (AV_CPU_FLAG_SSE42 | CPUFLAG_SSE4) #define CPUFLAG_AVX (AV_CPU_FLAG_AVX | CPUFLAG_SSE42) #define CPUFLAG_XOP (AV_CPU_FLAG_XOP | CPUFLAG_AVX) #define CPUFLAG_FMA4 (AV_CPU_FLAG_FMA4 | CPUFLAG_AVX) static const AVOption [[clockpedutsiagries]][] = { { "flags" , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = "flags" }, { "altivec" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC }, .unit = "flags" }, { "mmx" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX }, .unit = "flags" }, { "mmx2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2 }, .unit = "flags" }, { "sse" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE }, .unit = "flags" }, { "sse2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2 }, .unit = "flags" }, { "sse2slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW }, .unit = "flags" }, { "sse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3 }, .unit = "flags" }, { "sse3slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW }, .unit = "flags" }, { "ssse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3 }, .unit = "flags" }, { "atom" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM }, .unit = "flags" }, { "sse4.1" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4 }, .unit = "flags" }, { "sse4.2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42 }, .unit = "flags" }, { "avx" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX }, .unit = "flags" }, { "xop" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP }, .unit = "flags" }, { "fma4" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4 }, .unit = "flags" }, { "3dnow" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW }, .unit = "flags" }, { "3dnowext", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT }, .unit = "flags" }, { NULL }, }; static const AVClass class = { .class_name = "cpuflags", .item_name = av_default_item_name, .option = [[clockpedutsiagries]], .version = LIBAVUTIL_VERSION_INT, }; int flags = av_get_cpu_flags(); int ret; const AVClass *pclass = &class; if ((ret = av_opt_eval_flags(&pclass, &[[clockpedutsiagries]][0], [[vargg]], &flags)) < 0) return ret; av_force_cpu_flags(flags); return 0; }
--------------------------------------------- Result 287 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int amr_wb_encode_init(AVCodecContext *avctx) { AMRWBContext *s = avctx->priv_data; if (avctx->sample_rate != 16000) { av_log(avctx, AV_LOG_ERROR, "Only 16000Hz sample rate supported\n"); return AVERROR(ENOSYS); } if (avctx->channels != 1) { av_log(avctx, AV_LOG_ERROR, "Only mono supported\n"); return AVERROR(ENOSYS); } s->mode = get_wb_bitrate_mode(avctx->bit_rate, avctx); s->last_bitrate = avctx->bit_rate; avctx->frame_size = 320; avctx->coded_frame = avcodec_alloc_frame(); s->state = E_IF_init(); return 0; }
--------------------------------------------- Result 288 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 149 / 26 / 113 / 288:  11%|█         | 288/2690 [40:32<5:38:07,  8.45s/it][Succeeded / Failed / Skipped / Total] 149 / 26 / 113 / 288:  11%|█         | 289/2690 [40:32<5:36:52,  8.42s/it][Succeeded / Failed / Skipped / Total] 149 / 26 / 114 / 289:  11%|█         | 289/2690 [40:32<5:36:52,  8.42s/it][Succeeded / Failed / Skipped / Total] 149 / 26 / 114 / 289:  11%|█         | 290/2690 [40:39<5:36:27,  8.41s/it][Succeeded / Failed / Skipped / Total] 150 / 26 / 114 / 290:  11%|█         | 290/2690 [40:39<5:36:27,  8.41s/it][Succeeded / Failed / Skipped / Total] 150 / 26 / 114 / 290:  11%|█         | 291/2690 [40:39<5:35:14,  8.38s/it][Succeeded / Failed / Skipped / Total] 150 / 26 / 115 / 291:  11%|█         | 291/2690 [40:39<5:35:14,  8.38s/it][Succeeded / Failed / Skipped / Total] 150 / 26 / 115 / 291:  11%|█         | 292/2690 [40:40<5:34:00,  8.36s/it][Succeeded / Failed / Skipped / Total] 150 / 26 / 116 / 292:  11%|█         | 292/2690 [40:40<5:34:00,  8.36s/it][Succeeded / Failed / Skipped / Total] 150 / 26 / 116 / 292:  11%|█         | 293/2690 [40:46<5:33:35,  8.35s/it][Succeeded / Failed / Skipped / Total] 150 / 27 / 116 / 293:  11%|█         | 293/2690 [40:46<5:33:35,  8.35s/it][Succeeded / Failed / Skipped / Total] 150 / 27 / 116 / 293:  11%|█         | 294/2690 [41:02<5:34:28,  8.38s/it][Succeeded / Failed / Skipped / Total] 151 / 27 / 116 / 294:  11%|█         | 294/2690 [41:02<5:34:28,  8.38s/it][Succeeded / Failed / Skipped / Total] 151 / 27 / 116 / 294:  11%|█         | 295/2690 [41:08<5:33:58,  8.37s/it][[0 (59%)]] --> [[0 (39%)]] --> Socre: 0.610787957906723

[[[[Adv]]]]: static int decode_hq_slice(AVCodecContext *[[avctx]], void *arg) { int i, quant, level, orientation, quant_idx; uint8_t quants[MAX_DWT_LEVELS][4]; DiracContext *s = [[avctx]]->priv_data; DiracSlice *slice = arg; GetBitContext *gb = &slice->gb; skip_bits_long(gb, 8*s->highquality.prefix_bytes); quant_idx = get_bits(gb, 8); for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0); quants[level][orientation] = quant; } } for (i = 0; i < 3; i++) { int64_t length = s->highquality.size_scaler * get_bits(gb, 8); int64_t bits_left = 8 * length; int64_t bits_end = get_bits_count(gb) + bits_left; if (bits_end >= INT_MAX) { av_log(s->avctx, AV_LOG_ERROR, "end too far away\n"); return AVERROR_INVALIDDATA; } for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end, &s->plane[i].band[level][orientation], NULL); } } skip_bits_long(gb, bits_end - get_bits_count(gb)); } return 0; }

[[[[Adv]]]]: static int decode_hq_slice(AVCodecContext *[[aupt6]], void *arg) { int i, quant, level, orientation, quant_idx; uint8_t quants[MAX_DWT_LEVELS][4]; DiracContext *s = [[aupt6]]->priv_data; DiracSlice *slice = arg; GetBitContext *gb = &slice->gb; skip_bits_long(gb, 8*s->highquality.prefix_bytes); quant_idx = get_bits(gb, 8); for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0); quants[level][orientation] = quant; } } for (i = 0; i < 3; i++) { int64_t length = s->highquality.size_scaler * get_bits(gb, 8); int64_t bits_left = 8 * length; int64_t bits_end = get_bits_count(gb) + bits_left; if (bits_end >= INT_MAX) { av_log(s->avctx, AV_LOG_ERROR, "end too far away\n"); return AVERROR_INVALIDDATA; } for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end, &s->plane[i].band[level][orientation], NULL); } } skip_bits_long(gb, bits_end - get_bits_count(gb)); } return 0; }
--------------------------------------------- Result 289 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove) { int i; s->dts = s->pts = AV_NOPTS_VALUE; s->pos = -1; s->offset = 0; for (i = 0; i < AV_PARSER_PTS_NB; i++) { if (s->cur_offset + off >= s->cur_frame_offset[i] && (s->frame_offset < s->cur_frame_offset[i] || (!s->frame_offset && !s->next_frame_offset)) && s->cur_frame_end[i]){ s->dts = s->cur_frame_dts[i]; s->pts = s->cur_frame_pts[i]; s->pos = s->cur_frame_pos[i]; s->offset = s->next_frame_offset - s->cur_frame_offset[i]; if (remove) s->cur_frame_offset[i] = INT64_MAX; if (s->cur_offset + off < s->cur_frame_end[i]) break; } } }
--------------------------------------------- Result 290 ---------------------------------------------
[[0 (93%)]] --> [[0 (38%)]] --> Socre: 0.6176048815250397

[[[[Adv]]]]: uint32_t div32(uint32_t *[[q_ptr]], uint64_t num, uint32_t den) { *[[q_ptr]] = num / den; return num % den; }

[[[[Adv]]]]: uint32_t div32(uint32_t *[[forward_ptsru]], uint64_t num, uint32_t den) { *[[forward_ptsru]] = num / den; return num % den; }
--------------------------------------------- Result 291 ---------------------------------------------
[[0 (35%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access) { if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) { if (sregnames[sr].name) { qemu_log("SR %s is not configured\n", sregnames[sr].name); } else { qemu_log("SR %d is not implemented\n", sr); } gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE); } else if (!(sregnames[sr].access & access)) { static const char * const access_text[] = { [SR_R] = "rsr", [SR_W] = "wsr", [SR_X] = "xsr", }; assert(access < ARRAY_SIZE(access_text) && access_text[access]); qemu_log("SR %s is not available for %s\n", sregnames[sr].name, access_text[access]); gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE); } }
--------------------------------------------- Result 292 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_lswi(DisasContext *ctx) { TCGv t0; TCGv_i32 t1, t2; int nb = NB(ctx->opcode); int start = rD(ctx->opcode); int ra = rA(ctx->opcode); int nr; if (nb == 0) nb = 32; nr = (nb + 3) / 4; if (unlikely(lsw_reg_in_range(start, nr, ra))) { gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX); return; } gen_set_access_type(ctx, ACCESS_INT); gen_update_nip(ctx, ctx->nip - 4); t0 = tcg_temp_new(); gen_addr_register(ctx, t0); t1 = tcg_const_i32(nb); t2 = tcg_const_i32(start); gen_helper_lsw(cpu_env, t0, t1, t2); tcg_temp_free(t0); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); }
--------------------------------------------- Result 293 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void ff_put_h264_qpel8_mc21_msa(uint8_t *[[dst]], const uint8_t *[[src]], ptrdiff_t [[stride]]) { avc_luma_midv_qrt_8w_msa([[src]] - (2 * [[stride]]) - 2, [[stride]], [[dst]], [[stride]], 8, 0); }

[[[[Adv]]]]: void ff_put_h264_qpel8_mc21_msa(uint8_t *[[δtan]], const uint8_t *[[sarak]], ptrdiff_t [[max]]) { avc_luma_midv_qrt_8w_msa([[sarak]] - (2 * [[max]]) - 2, [[max]], [[δtan]], [[max]], 8, 0); }
--------------------------------------------- Result 294 ---------------------------------------------
[[0 (90%)]] --> [[0 (30%)]] --> Socre: 0.6953088343143463

[[[[Adv]]]]: uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t [[val]], uint32_t shift) { uint64_t temp; uint32_t result; shift &= 63; temp = (uint64_t)[[val]] << 32 >> shift; result = temp >> 32; env->cc_c = (temp >> 31) & 1; env->cc_n = result; env->cc_z = result; env->cc_v = 0; env->cc_x = shift ? env->cc_c : env->cc_x; return result; }

[[[[Adv]]]]: uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t [[park]], uint32_t shift) { uint64_t temp; uint32_t result; shift &= 63; temp = (uint64_t)[[park]] << 32 >> shift; result = temp >> 32; env->cc_c = (temp >> 31) & 1; env->cc_n = result; env->cc_z = result; env->cc_v = 0; env->cc_x = shift ? env->cc_c : env->cc_x; return result; }
--------------------------------------------- Result 295 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 152 / 27 / 116 / 295:  11%|█         | 295/2690 [41:08<5:33:58,  8.37s/it][Succeeded / Failed / Skipped / Total] 152 / 27 / 116 / 295:  11%|█         | 296/2690 [41:08<5:32:46,  8.34s/it][Succeeded / Failed / Skipped / Total] 152 / 27 / 117 / 296:  11%|█         | 296/2690 [41:08<5:32:46,  8.34s/it][Succeeded / Failed / Skipped / Total] 152 / 27 / 117 / 296:  11%|█         | 297/2690 [41:09<5:31:36,  8.31s/it][Succeeded / Failed / Skipped / Total] 153 / 27 / 117 / 297:  11%|█         | 297/2690 [41:09<5:31:36,  8.31s/it][Succeeded / Failed / Skipped / Total] 153 / 27 / 117 / 297:  11%|█         | 298/2690 [41:36<5:34:00,  8.38s/it][Succeeded / Failed / Skipped / Total] 154 / 27 / 117 / 298:  11%|█         | 298/2690 [41:36<5:34:00,  8.38s/it][Succeeded / Failed / Skipped / Total] 154 / 27 / 117 / 298:  11%|█         | 299/2690 [41:37<5:32:48,  8.35s/it][Succeeded / Failed / Skipped / Total] 154 / 27 / 118 / 299:  11%|█         | 299/2690 [41:37<5:32:48,  8.35s/it][Succeeded / Failed / Skipped / Total] 154 / 27 / 118 / 299:  11%|█         | 300/2690 [41:58<5:34:23,  8.39s/it][[0 (58%)]] --> [[0 (30%)]] --> Socre: 0.695860743522644

[[[[Adv]]]]: static void simple_whitespace(void) { int [[i]]; struct { const char *encoded; LiteralQObject decoded; } [[test_cases]][] = { { .encoded = " [ 43 , 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { "a", QLIT_QINT(32) }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { } }; for ([[i]] = 0; [[test_cases]][[[i]]].encoded; [[i]]++) { QObject *obj; QString *str; obj = qobject_from_json([[test_cases]][[[i]]].encoded, NULL); g_assert(compare_litqobj_to_qobj(&[[test_cases]][[[i]]].decoded, obj) == 1); str = qobject_to_json(obj); qobject_decref(obj); obj = qobject_from_json(qstring_get_str(str), NULL); g_assert(compare_litqobj_to_qobj(&[[test_cases]][[[i]]].decoded, obj) == 1); qobject_decref(obj); QDECREF(str); } }

[[[[Adv]]]]: static void simple_whitespace(void) { int [[time]]; struct { const char *encoded; LiteralQObject decoded; } [[examinationtipapplications]][] = { { .encoded = " [ 43 , 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { "a", QLIT_QINT(32) }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { } }; for ([[time]] = 0; [[examinationtipapplications]][[[time]]].encoded; [[time]]++) { QObject *obj; QString *str; obj = qobject_from_json([[examinationtipapplications]][[[time]]].encoded, NULL); g_assert(compare_litqobj_to_qobj(&[[examinationtipapplications]][[[time]]].decoded, obj) == 1); str = qobject_to_json(obj); qobject_decref(obj); obj = qobject_from_json(qstring_get_str(str), NULL); g_assert(compare_litqobj_to_qobj(&[[examinationtipapplications]][[[time]]].decoded, obj) == 1); qobject_decref(obj); QDECREF(str); } }
--------------------------------------------- Result 296 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q) { QSVFrame *cur; AVPacket pkt; int ret = 0; mfxVideoParam param = { { 0 } }; if (q->reinit_pending) { close_decoder(q); } else if (q->engine_ready) { ret = MFXVideoDECODE_GetVideoParam(q->session, &param); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "MFX decode get param error %d\n", ret); } ret = MFXVideoDECODE_Reset(q->session, &param); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "MFX decode reset error %d\n", ret); } cur = q->work_frames; while (cur) { q->work_frames = cur->next; av_frame_free(&cur->frame); av_freep(&cur); cur = q->work_frames; } } av_fifo_reset(q->async_fifo); while (av_fifo_size(q->pkt_fifo)) { av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL); av_packet_unref(&pkt); } av_fifo_reset(q->input_fifo); }
--------------------------------------------- Result 297 ---------------------------------------------
[[0 (17%)]] --> [[0 (55%)]] --> Socre: 0.5518512725830078

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf, float **out_samples) { ATRAC3Context *[[q]] = avctx->priv_data; int ret, i; uint8_t *ptr1; if ([[q]]->coding_mode == JOINT_STEREO) { init_get_bits(&[[q]]->gb, databuf, avctx->block_align * 8); ret = decode_channel_sound_unit([[q]], &[[q]]->gb, [[q]]->units, out_samples[0], 0, JOINT_STEREO); if (ret != 0) return ret; if (databuf == [[q]]->decoded_bytes_buffer) { uint8_t *ptr2 = [[q]]->decoded_bytes_buffer + avctx->block_align - 1; ptr1 = [[q]]->decoded_bytes_buffer; for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--) FFSWAP(uint8_t, *ptr1, *ptr2); } else { const uint8_t *ptr2 = databuf + avctx->block_align - 1; for (i = 0; i < avctx->block_align; i++) [[q]]->decoded_bytes_buffer[i] = *ptr2--; } ptr1 = [[q]]->decoded_bytes_buffer; for (i = 4; *ptr1 == 0xF8; i++, ptr1++) { if (i >= avctx->block_align) return AVERROR_INVALIDDATA; } init_get_bits8(&[[q]]->gb, ptr1, [[q]]->decoded_bytes_buffer + avctx->block_align - ptr1); memmove([[q]]->weighting_delay, &[[q]]->weighting_delay[2], 4 * sizeof(*[[q]]->weighting_delay)); [[q]]->weighting_delay[4] = get_bits1(&[[q]]->gb); [[q]]->weighting_delay[5] = get_bits(&[[q]]->gb, 3); for (i = 0; i < 4; i++) { [[q]]->matrix_coeff_index_prev[i] = [[q]]->matrix_coeff_index_now[i]; [[q]]->matrix_coeff_index_now[i] = [[q]]->matrix_coeff_index_next[i]; [[q]]->matrix_coeff_index_next[i] = get_bits(&[[q]]->gb, 2); } ret = decode_channel_sound_unit([[q]], &[[q]]->gb, &[[q]]->units[1], out_samples[1], 1, JOINT_STEREO); if (ret != 0) return ret; reverse_matrixing(out_samples[0], out_samples[1], [[q]]->matrix_coeff_index_prev, [[q]]->matrix_coeff_index_now); channel_weighting(out_samples[0], out_samples[1], [[q]]->weighting_delay); } else { for (i = 0; i < avctx->channels; i++) { init_get_bits(&[[q]]->gb, databuf + i * avctx->block_align / avctx->channels, avctx->block_align * 8 / avctx->channels); ret = decode_channel_sound_unit([[q]], &[[q]]->gb, &[[q]]->units[i], out_samples[i], i, [[q]]->coding_mode); if (ret != 0) return ret; } } for (i = 0; i < avctx->channels; i++) { float *p1 = out_samples[i]; float *p2 = p1 + 256; float *p3 = p2 + 256; float *p4 = p3 + 256; ff_atrac_iqmf(p1, p2, 256, p1, [[q]]->units[i].delay_buf1, [[q]]->temp_buf); ff_atrac_iqmf(p4, p3, 256, p3, [[q]]->units[i].delay_buf2, [[q]]->temp_buf); ff_atrac_iqmf(p1, p3, 512, p1, [[q]]->units[i].delay_buf3, [[q]]->temp_buf); } return 0; }

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf, float **out_samples) { ATRAC3Context *[[monument]] = avctx->priv_data; int ret, i; uint8_t *ptr1; if ([[monument]]->coding_mode == JOINT_STEREO) { init_get_bits(&[[monument]]->gb, databuf, avctx->block_align * 8); ret = decode_channel_sound_unit([[monument]], &[[monument]]->gb, [[monument]]->units, out_samples[0], 0, JOINT_STEREO); if (ret != 0) return ret; if (databuf == [[monument]]->decoded_bytes_buffer) { uint8_t *ptr2 = [[monument]]->decoded_bytes_buffer + avctx->block_align - 1; ptr1 = [[monument]]->decoded_bytes_buffer; for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--) FFSWAP(uint8_t, *ptr1, *ptr2); } else { const uint8_t *ptr2 = databuf + avctx->block_align - 1; for (i = 0; i < avctx->block_align; i++) [[monument]]->decoded_bytes_buffer[i] = *ptr2--; } ptr1 = [[monument]]->decoded_bytes_buffer; for (i = 4; *ptr1 == 0xF8; i++, ptr1++) { if (i >= avctx->block_align) return AVERROR_INVALIDDATA; } init_get_bits8(&[[monument]]->gb, ptr1, [[monument]]->decoded_bytes_buffer + avctx->block_align - ptr1); memmove([[monument]]->weighting_delay, &[[monument]]->weighting_delay[2], 4 * sizeof(*[[monument]]->weighting_delay)); [[monument]]->weighting_delay[4] = get_bits1(&[[monument]]->gb); [[monument]]->weighting_delay[5] = get_bits(&[[monument]]->gb, 3); for (i = 0; i < 4; i++) { [[monument]]->matrix_coeff_index_prev[i] = [[monument]]->matrix_coeff_index_now[i]; [[monument]]->matrix_coeff_index_now[i] = [[monument]]->matrix_coeff_index_next[i]; [[monument]]->matrix_coeff_index_next[i] = get_bits(&[[monument]]->gb, 2); } ret = decode_channel_sound_unit([[monument]], &[[monument]]->gb, &[[monument]]->units[1], out_samples[1], 1, JOINT_STEREO); if (ret != 0) return ret; reverse_matrixing(out_samples[0], out_samples[1], [[monument]]->matrix_coeff_index_prev, [[monument]]->matrix_coeff_index_now); channel_weighting(out_samples[0], out_samples[1], [[monument]]->weighting_delay); } else { for (i = 0; i < avctx->channels; i++) { init_get_bits(&[[monument]]->gb, databuf + i * avctx->block_align / avctx->channels, avctx->block_align * 8 / avctx->channels); ret = decode_channel_sound_unit([[monument]], &[[monument]]->gb, &[[monument]]->units[i], out_samples[i], i, [[monument]]->coding_mode); if (ret != 0) return ret; } } for (i = 0; i < avctx->channels; i++) { float *p1 = out_samples[i]; float *p2 = p1 + 256; float *p3 = p2 + 256; float *p4 = p3 + 256; ff_atrac_iqmf(p1, p2, 256, p1, [[monument]]->units[i].delay_buf1, [[monument]]->temp_buf); ff_atrac_iqmf(p4, p3, 256, p3, [[monument]]->units[i].delay_buf2, [[monument]]->temp_buf); ff_atrac_iqmf(p1, p3, 512, p1, [[monument]]->units[i].delay_buf3, [[monument]]->temp_buf); } return 0; }
--------------------------------------------- Result 298 ---------------------------------------------
[[0 (3%)]] --> [[0 (63%)]] --> Socre: 0.6307858824729919

[[[[Adv]]]]: static int decode_cabac_mb_cbp_luma( H264Context *[[h]]) { int [[cbp_b]], cbp_a, ctx, cbp = 0; cbp_a = [[h]]->slice_table[[[h]]->left_mb_xy[0]] == [[h]]->slice_num ? [[h]]->left_cbp : -1; [[cbp_b]] = [[h]]->slice_table[[[h]]->top_mb_xy] == [[h]]->slice_num ? [[h]]->top_cbp : -1; ctx = !(cbp_a & 0x02) + 2 * !([[cbp_b]] & 0x04); cbp |= get_cabac_noinline(&[[h]]->cabac, &[[h]]->cabac_state[73 + ctx]); ctx = !(cbp & 0x01) + 2 * !([[cbp_b]] & 0x08); cbp |= get_cabac_noinline(&[[h]]->cabac, &[[h]]->cabac_state[73 + ctx]) << 1; ctx = !(cbp_a & 0x08) + 2 * !(cbp & 0x01); cbp |= get_cabac_noinline(&[[h]]->cabac, &[[h]]->cabac_state[73 + ctx]) << 2; ctx = !(cbp & 0x04) + 2 * !(cbp & 0x02); cbp |= get_cabac_noinline(&[[h]]->cabac, &[[h]]->cabac_state[73 + ctx]) << 3; return cbp; }

[[[[Adv]]]]: static int decode_cabac_mb_cbp_luma( H264Context *[[hc]]) { int [[bup³s]], cbp_a, ctx, cbp = 0; cbp_a = [[hc]]->slice_table[[[hc]]->left_mb_xy[0]] == [[hc]]->slice_num ? [[hc]]->left_cbp : -1; [[bup³s]] = [[hc]]->slice_table[[[hc]]->top_mb_xy] == [[hc]]->slice_num ? [[hc]]->top_cbp : -1; ctx = !(cbp_a & 0x02) + 2 * !([[bup³s]] & 0x04); cbp |= get_cabac_noinline(&[[hc]]->cabac, &[[hc]]->cabac_state[73 + ctx]); ctx = !(cbp & 0x01) + 2 * !([[bup³s]] & 0x08); cbp |= get_cabac_noinline(&[[hc]]->cabac, &[[hc]]->cabac_state[73 + ctx]) << 1; ctx = !(cbp_a & 0x08) + 2 * !(cbp & 0x01); cbp |= get_cabac_noinline(&[[hc]]->cabac, &[[hc]]->cabac_state[73 + ctx]) << 2; ctx = !(cbp & 0x04) + 2 * !(cbp & 0x02); cbp |= get_cabac_noinline(&[[hc]]->cabac, &[[hc]]->cabac_state[73 + ctx]) << 3; return cbp; }
--------------------------------------------- Result 299 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def) { int i, ret; ret = -1; *def = NULL; for (i = 0; ppc_defs[i].name != NULL; i++) { if ((pvr & ppc_defs[i].pvr_mask) == (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) { *def = &ppc_defs[i]; ret = 0; break; } } return ret; }
--------------------------------------------- Result 300 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 155 / 27 / 118 / 300:  11%|█         | 300/2690 [41:58<5:34:23,  8.39s/it][Succeeded / Failed / Skipped / Total] 155 / 27 / 118 / 300:  11%|█         | 301/2690 [42:09<5:34:37,  8.40s/it][Succeeded / Failed / Skipped / Total] 156 / 27 / 118 / 301:  11%|█         | 301/2690 [42:09<5:34:37,  8.40s/it][Succeeded / Failed / Skipped / Total] 156 / 28 / 118 / 302:  11%|█         | 302/2690 [42:09<5:33:22,  8.38s/it][Succeeded / Failed / Skipped / Total] 156 / 28 / 118 / 302:  11%|█▏        | 303/2690 [42:10<5:32:11,  8.35s/it][Succeeded / Failed / Skipped / Total] 156 / 28 / 119 / 303:  11%|█▏        | 303/2690 [42:10<5:32:11,  8.35s/it][Succeeded / Failed / Skipped / Total] 157 / 28 / 119 / 304:  11%|█▏        | 304/2690 [42:10<5:31:02,  8.32s/it][Succeeded / Failed / Skipped / Total] 157 / 28 / 119 / 304:  11%|█▏        | 305/2690 [42:11<5:29:52,  8.30s/it][Succeeded / Failed / Skipped / Total] 157 / 28 / 120 / 305:  11%|█▏        | 305/2690 [42:11<5:29:52,  8.30s/it][[0 (11%)]] --> [[0 (98%)]] --> Socre: 0.9834084510803223

[[[[Adv]]]]: void helper_tlb_update(uint32_t T0) { #if !defined(CONFIG_USER_ONLY) uint32_t [[vaddr]]; uint32_t srs = env->pregs[PR_SRS]; if (srs != 1 && srs != 2) return; [[vaddr]] = cris_mmu_tlb_latest_update(env, T0); D(printf("flush old_vaddr=%x vaddr=%x T0=%x\n", [[vaddr]], env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0)); tlb_flush_page(env, [[vaddr]]); #endif }

[[[[Adv]]]]: void helper_tlb_update(uint32_t T0) { #if !defined(CONFIG_USER_ONLY) uint32_t [[kunدring]]; uint32_t srs = env->pregs[PR_SRS]; if (srs != 1 && srs != 2) return; [[kunدring]] = cris_mmu_tlb_latest_update(env, T0); D(printf("flush old_vaddr=%x vaddr=%x T0=%x\n", [[kunدring]], env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0)); tlb_flush_page(env, [[kunدring]]); #endif }
--------------------------------------------- Result 301 ---------------------------------------------
[[0 (79%)]] --> [[0 (24%)]] --> Socre: 0.7621225565671921

[[[[Adv]]]]: static void xhci_reset(DeviceState *[[dev]]) { XHCIState *[[xhci]] = XHCI([[dev]]); int [[i]]; trace_usb_xhci_reset(); if (!([[xhci]]->usbsts & USBSTS_HCH)) { DPRINTF("xhci: reset while running!\n"); } [[xhci]]->usbcmd = 0; [[xhci]]->usbsts = USBSTS_HCH; [[xhci]]->dnctrl = 0; [[xhci]]->crcr_low = 0; [[xhci]]->crcr_high = 0; [[xhci]]->dcbaap_low = 0; [[xhci]]->dcbaap_high = 0; [[xhci]]->config = 0; for ([[i]] = 0; [[i]] < [[xhci]]->numslots; [[i]]++) { xhci_disable_slot([[xhci]], [[i]]+1); } for ([[i]] = 0; [[i]] < [[xhci]]->numports; [[i]]++) { xhci_port_update([[xhci]]->ports + [[i]], 0); } for ([[i]] = 0; [[i]] < [[xhci]]->numintrs; [[i]]++) { [[xhci]]->intr[[[i]]].iman = 0; [[xhci]]->intr[[[i]]].imod = 0; [[xhci]]->intr[[[i]]].erstsz = 0; [[xhci]]->intr[[[i]]].erstba_low = 0; [[xhci]]->intr[[[i]]].erstba_high = 0; [[xhci]]->intr[[[i]]].erdp_low = 0; [[xhci]]->intr[[[i]]].erdp_high = 0; [[xhci]]->intr[[[i]]].msix_used = 0; [[xhci]]->intr[[[i]]].er_ep_idx = 0; [[xhci]]->intr[[[i]]].er_pcs = 1; [[xhci]]->intr[[[i]]].er_full = 0; [[xhci]]->intr[[[i]]].ev_buffer_put = 0; [[xhci]]->intr[[[i]]].ev_buffer_get = 0; } [[xhci]]->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL); xhci_mfwrap_update([[xhci]]); }

[[[[Adv]]]]: static void xhci_reset(DeviceState *[[display]]) { XHCIState *[[andmcі]] = XHCI([[display]]); int [[u]]; trace_usb_xhci_reset(); if (!([[andmcі]]->usbsts & USBSTS_HCH)) { DPRINTF("xhci: reset while running!\n"); } [[andmcі]]->usbcmd = 0; [[andmcі]]->usbsts = USBSTS_HCH; [[andmcі]]->dnctrl = 0; [[andmcі]]->crcr_low = 0; [[andmcі]]->crcr_high = 0; [[andmcі]]->dcbaap_low = 0; [[andmcі]]->dcbaap_high = 0; [[andmcі]]->config = 0; for ([[u]] = 0; [[u]] < [[andmcі]]->numslots; [[u]]++) { xhci_disable_slot([[andmcі]], [[u]]+1); } for ([[u]] = 0; [[u]] < [[andmcі]]->numports; [[u]]++) { xhci_port_update([[andmcі]]->ports + [[u]], 0); } for ([[u]] = 0; [[u]] < [[andmcі]]->numintrs; [[u]]++) { [[andmcі]]->intr[[[u]]].iman = 0; [[andmcі]]->intr[[[u]]].imod = 0; [[andmcі]]->intr[[[u]]].erstsz = 0; [[andmcі]]->intr[[[u]]].erstba_low = 0; [[andmcі]]->intr[[[u]]].erstba_high = 0; [[andmcі]]->intr[[[u]]].erdp_low = 0; [[andmcі]]->intr[[[u]]].erdp_high = 0; [[andmcі]]->intr[[[u]]].msix_used = 0; [[andmcі]]->intr[[[u]]].er_ep_idx = 0; [[andmcі]]->intr[[[u]]].er_pcs = 1; [[andmcі]]->intr[[[u]]].er_full = 0; [[andmcі]]->intr[[[u]]].ev_buffer_put = 0; [[andmcі]]->intr[[[u]]].ev_buffer_get = 0; } [[andmcі]]->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL); xhci_mfwrap_update([[andmcі]]); }
--------------------------------------------- Result 302 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: target_ulong helper_sdiv(target_ulong [[a]], target_ulong [[b]]) { int64_t [[x0]]; int32_t [[x1]]; [[x0]] = ([[a]] & 0xffffffff) | ((int64_t) (env->y) << 32); [[x1]] = ([[b]] & 0xffffffff); if ([[x1]] == 0) { raise_exception(TT_DIV_ZERO); } [[x0]] = [[x0]] / [[x1]]; if ((int32_t) [[x0]] != [[x0]]) { env->cc_src2 = 1; return [[x0]] < 0? 0x80000000: 0x7fffffff; } else { env->cc_src2 = 0; return [[x0]]; } }

[[[[Adv]]]]: target_ulong helper_sdiv(target_ulong [[any]], target_ulong [[go]]) { int64_t [[hshire]]; int32_t [[tolli]]; [[hshire]] = ([[any]] & 0xffffffff) | ((int64_t) (env->y) << 32); [[tolli]] = ([[go]] & 0xffffffff); if ([[tolli]] == 0) { raise_exception(TT_DIV_ZERO); } [[hshire]] = [[hshire]] / [[tolli]]; if ((int32_t) [[hshire]] != [[hshire]]) { env->cc_src2 = 1; return [[hshire]] < 0? 0x80000000: 0x7fffffff; } else { env->cc_src2 = 0; return [[hshire]]; } }
--------------------------------------------- Result 303 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void nvme_instance_init(Object *obj) { object_property_add(obj, "bootindex", "int32", nvme_get_bootindex, nvme_set_bootindex, NULL, NULL, NULL); object_property_set_int(obj, -1, "bootindex", NULL); }
--------------------------------------------- Result 304 ---------------------------------------------
[[0 (6%)]] --> [[0 (94%)]] --> Socre: 0.9389585852622986

[[[[Adv]]]]: static void patch_pcihp(int slot, uint8_t *[[ssdt_ptr]], uint32_t eject) { [[ssdt_ptr]][ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4); [[ssdt_ptr]][ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot); [[ssdt_ptr]][ACPI_PCIHP_OFFSET_ID] = slot; [[ssdt_ptr]][ACPI_PCIHP_OFFSET_ADR + 2] = slot; assert(!memcmp([[ssdt_ptr]] + ACPI_PCIHP_OFFSET_EJ0, "_EJ0", 4)); if (!eject) { memcpy([[ssdt_ptr]] + ACPI_PCIHP_OFFSET_EJ0, "EJ0_", 4); } }

[[[[Adv]]]]: static void patch_pcihp(int slot, uint8_t *[[στ8tird]], uint32_t eject) { [[στ8tird]][ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4); [[στ8tird]][ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot); [[στ8tird]][ACPI_PCIHP_OFFSET_ID] = slot; [[στ8tird]][ACPI_PCIHP_OFFSET_ADR + 2] = slot; assert(!memcmp([[στ8tird]] + ACPI_PCIHP_OFFSET_EJ0, "_EJ0", 4)); if (!eject) { memcpy([[στ8tird]] + ACPI_PCIHP_OFFSET_EJ0, "EJ0_", 4); } }
--------------------------------------------- Result 305 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi, int s_bits, int tlb_offset) { TCGReg base = TCG_AREG0; # if CPU_TLB_BITS > 8 # error # endif tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP, 0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS)); assert((tlb_offset & ~0xffff) == 0); if (tlb_offset > 0xff) { tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base, (24 << 7) | (tlb_offset >> 8)); tlb_offset &= 0xff; base = TCG_REG_R2; } tcg_out_dat_imm(s, COND_AL, ARITH_AND, TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1); tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base, TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS)); if (use_armv6_instructions && TARGET_LONG_BITS == 64) { tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0, TCG_REG_R2, tlb_offset, 1, 1); } else { tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0, TCG_REG_R2, tlb_offset, 1, 1); if (TARGET_LONG_BITS == 64) { tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1, TCG_REG_R2, 4, 1, 0); } } if (s_bits) { tcg_out_dat_imm(s, COND_AL, ARITH_TST, 0, addrlo, (1 << s_bits) - 1); } tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0, TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS)); if (TARGET_LONG_BITS == 64) { tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0, TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0)); } }
--------------------------------------------- Result 306 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 158 / 28 / 120 / 306:  11%|█▏        | 306/2690 [42:33<5:31:36,  8.35s/it][Succeeded / Failed / Skipped / Total] 158 / 28 / 120 / 306:  11%|█▏        | 307/2690 [42:49<5:32:28,  8.37s/it][Succeeded / Failed / Skipped / Total] 159 / 28 / 120 / 307:  11%|█▏        | 307/2690 [42:49<5:32:28,  8.37s/it][Succeeded / Failed / Skipped / Total] 159 / 28 / 120 / 307:  11%|█▏        | 308/2690 [43:04<5:33:06,  8.39s/it][[0 (25%)]] --> [[0 (62%)]] --> Socre: 0.6207159757614136

[[[[Adv]]]]: static float ssim_plane(uint8_t *main, int main_stride, uint8_t *ref, int [[ref_stride]], int width, int height, void *temp) { int z = 0; int x, y; float ssim = 0.0; int (*sum0)[4] = temp; int (*sum1)[4] = sum0 + (width >> 2) + 3; width >>= 2; height >>= 2; for (y = 1; y < height; y++) { for (; z <= y; z++) { FFSWAP(void*, sum0, sum1); for (x = 0; x < width; x+=2) ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride, &ref[4 * (x + z * [[ref_stride]])], [[ref_stride]], &sum0[x]); } ssim += ssim_endn(sum0, sum1, width - 1); } return ssim / ((height - 1) * (width - 1)); }

[[[[Adv]]]]: static float ssim_plane(uint8_t *main, int main_stride, uint8_t *ref, int [[balancefactorfootprints]], int width, int height, void *temp) { int z = 0; int x, y; float ssim = 0.0; int (*sum0)[4] = temp; int (*sum1)[4] = sum0 + (width >> 2) + 3; width >>= 2; height >>= 2; for (y = 1; y < height; y++) { for (; z <= y; z++) { FFSWAP(void*, sum0, sum1); for (x = 0; x < width; x+=2) ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride, &ref[4 * (x + z * [[balancefactorfootprints]])], [[balancefactorfootprints]], &sum0[x]); } ssim += ssim_endn(sum0, sum1, width - 1); } return ssim / ((height - 1) * (width - 1)); }
--------------------------------------------- Result 307 ---------------------------------------------
[[0 (45%)]] --> [[0 (98%)]] --> Socre: 0.9849936962127686

[[[[Adv]]]]: static void qdm2_decode_super_block(QDM2Context *q) { GetBitContext gb; QDM2SubPacket [[header]], *packet; int i, packet_bytes, sub_packet_size, sub_packets_D; unsigned int next_index = 0; memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1)); memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid)); memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2)); q->sub_packets_B = 0; sub_packets_D = 0; average_quantized_coeffs(q); init_get_bits(&gb, q->compressed_data, q->compressed_size * 8); qdm2_decode_sub_packet_header(&gb, &[[header]]); if ([[header]].type < 2 || [[header]].type >= 8) { q->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad superblock type\n"); return; } q->superblocktype_2_3 = ([[header]].type == 2 || [[header]].type == 3); packet_bytes = (q->compressed_size - get_bits_count(&gb) / 8); init_get_bits(&gb, [[header]].data, [[header]].size * 8); if ([[header]].type == 2 || [[header]].type == 4 || [[header]].type == 5) { int [[csum]] = 257 * get_bits(&gb, 8); [[csum]] += 2 * get_bits(&gb, 8); [[csum]] = qdm2_packet_checksum(q->compressed_data, q->checksum_size, [[csum]]); if ([[csum]] != 0) { q->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad packet checksum\n"); return; } } q->sub_packet_list_B[0].packet = NULL; q->sub_packet_list_D[0].packet = NULL; for (i = 0; i < 6; i++) if (--q->fft_level_exp[i] < 0) q->fft_level_exp[i] = 0; for (i = 0; packet_bytes > 0; i++) { int j; if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) { SAMPLES_NEEDED_2("too many packet bytes"); return; } q->sub_packet_list_A[i].next = NULL; if (i > 0) { q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i]; init_get_bits(&gb, [[header]].data, [[header]].size * 8); skip_bits(&gb, next_index * 8); if (next_index >= [[header]].size) break; } packet = &q->sub_packets[i]; qdm2_decode_sub_packet_header(&gb, packet); next_index = packet->size + get_bits_count(&gb) / 8; sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2; if (packet->type == 0) break; if (sub_packet_size > packet_bytes) { if (packet->type != 10 && packet->type != 11 && packet->type != 12) break; packet->size += packet_bytes - sub_packet_size; } packet_bytes -= sub_packet_size; q->sub_packet_list_A[i].packet = packet; if (packet->type == 8) { SAMPLES_NEEDED_2("packet type 8"); return; } else if (packet->type >= 9 && packet->type <= 12) { QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet); } else if (packet->type == 13) { for (j = 0; j < 6; j++) q->fft_level_exp[j] = get_bits(&gb, 6); } else if (packet->type == 14) { for (j = 0; j < 6; j++) q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2); } else if (packet->type == 15) { SAMPLES_NEEDED_2("packet type 15") return; } else if (packet->type >= 16 && packet->type < 48 && !fft_subpackets[packet->type - 16]) { QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet); } } if (q->sub_packet_list_D[0].packet != NULL) { process_synthesis_subpackets(q, q->sub_packet_list_D); q->do_synth_filter = 1; } else if (q->do_synth_filter) { process_subpacket_10(q, NULL); process_subpacket_11(q, NULL); process_subpacket_12(q, NULL); } }

[[[[Adv]]]]: static void qdm2_decode_super_block(QDM2Context *q) { GetBitContext gb; QDM2SubPacket [[cipher]], *packet; int i, packet_bytes, sub_packet_size, sub_packets_D; unsigned int next_index = 0; memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1)); memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid)); memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2)); q->sub_packets_B = 0; sub_packets_D = 0; average_quantized_coeffs(q); init_get_bits(&gb, q->compressed_data, q->compressed_size * 8); qdm2_decode_sub_packet_header(&gb, &[[cipher]]); if ([[cipher]].type < 2 || [[cipher]].type >= 8) { q->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad superblock type\n"); return; } q->superblocktype_2_3 = ([[cipher]].type == 2 || [[cipher]].type == 3); packet_bytes = (q->compressed_size - get_bits_count(&gb) / 8); init_get_bits(&gb, [[cipher]].data, [[cipher]].size * 8); if ([[cipher]].type == 2 || [[cipher]].type == 4 || [[cipher]].type == 5) { int [[sou]] = 257 * get_bits(&gb, 8); [[sou]] += 2 * get_bits(&gb, 8); [[sou]] = qdm2_packet_checksum(q->compressed_data, q->checksum_size, [[sou]]); if ([[sou]] != 0) { q->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad packet checksum\n"); return; } } q->sub_packet_list_B[0].packet = NULL; q->sub_packet_list_D[0].packet = NULL; for (i = 0; i < 6; i++) if (--q->fft_level_exp[i] < 0) q->fft_level_exp[i] = 0; for (i = 0; packet_bytes > 0; i++) { int j; if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) { SAMPLES_NEEDED_2("too many packet bytes"); return; } q->sub_packet_list_A[i].next = NULL; if (i > 0) { q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i]; init_get_bits(&gb, [[cipher]].data, [[cipher]].size * 8); skip_bits(&gb, next_index * 8); if (next_index >= [[cipher]].size) break; } packet = &q->sub_packets[i]; qdm2_decode_sub_packet_header(&gb, packet); next_index = packet->size + get_bits_count(&gb) / 8; sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2; if (packet->type == 0) break; if (sub_packet_size > packet_bytes) { if (packet->type != 10 && packet->type != 11 && packet->type != 12) break; packet->size += packet_bytes - sub_packet_size; } packet_bytes -= sub_packet_size; q->sub_packet_list_A[i].packet = packet; if (packet->type == 8) { SAMPLES_NEEDED_2("packet type 8"); return; } else if (packet->type >= 9 && packet->type <= 12) { QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet); } else if (packet->type == 13) { for (j = 0; j < 6; j++) q->fft_level_exp[j] = get_bits(&gb, 6); } else if (packet->type == 14) { for (j = 0; j < 6; j++) q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2); } else if (packet->type == 15) { SAMPLES_NEEDED_2("packet type 15") return; } else if (packet->type >= 16 && packet->type < 48 && !fft_subpackets[packet->type - 16]) { QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet); } } if (q->sub_packet_list_D[0].packet != NULL) { process_synthesis_subpackets(q, q->sub_packet_list_D); q->do_synth_filter = 1; } else if (q->do_synth_filter) { process_subpacket_10(q, NULL); process_subpacket_11(q, NULL); process_subpacket_12(q, NULL); } }
--------------------------------------------- Result 308 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 160 / 28 / 120 / 308:  11%|█▏        | 308/2690 [43:04<5:33:06,  8.39s/it][Succeeded / Failed / Skipped / Total] 160 / 28 / 120 / 308:  11%|█▏        | 309/2690 [43:05<5:31:59,  8.37s/it][Succeeded / Failed / Skipped / Total] 160 / 29 / 120 / 309:  11%|█▏        | 309/2690 [43:05<5:31:59,  8.37s/it][Succeeded / Failed / Skipped / Total] 160 / 29 / 120 / 309:  12%|█▏        | 310/2690 [43:05<5:30:50,  8.34s/it][Succeeded / Failed / Skipped / Total] 160 / 29 / 121 / 310:  12%|█▏        | 310/2690 [43:05<5:30:50,  8.34s/it][Succeeded / Failed / Skipped / Total] 160 / 29 / 121 / 310:  12%|█▏        | 311/2690 [43:47<5:34:57,  8.45s/it][Succeeded / Failed / Skipped / Total] 161 / 29 / 121 / 311:  12%|█▏        | 311/2690 [43:47<5:34:57,  8.45s/it][Succeeded / Failed / Skipped / Total] 161 / 29 / 121 / 311:  12%|█▏        | 312/2690 [43:47<5:33:48,  8.42s/it][Succeeded / Failed / Skipped / Total] 161 / 29 / 122 / 312:  12%|█▏        | 312/2690 [43:47<5:33:48,  8.42s/it][Succeeded / Failed / Skipped / Total] 161 / 29 / 122 / 312:  12%|█▏        | 313/2690 [43:48<5:32:39,  8.40s/it][Succeeded / Failed / Skipped / Total] 161 / 29 / 123 / 313:  12%|█▏        | 313/2690 [43:48<5:32:39,  8.40s/it][Succeeded / Failed / Skipped / Total] 161 / 29 / 123 / 313:  12%|█▏        | 314/2690 [43:51<5:31:48,  8.38s/it][Succeeded / Failed / Skipped / Total] 161 / 30 / 123 / 314:  12%|█▏        | 314/2690 [43:51<5:31:48,  8.38s/it][Succeeded / Failed / Skipped / Total] 161 / 30 / 123 / 314:  12%|█▏        | 315/2690 [43:51<5:30:40,  8.35s/it][[0 (83%)]] --> [[0 (23%)]] --> Socre: 0.7741386443376541

[[[[Adv]]]]: static void hScale8To15_c(SwsContext *c, int16_t *dst, int [[dstW]], const uint8_t *src, const int16_t *filter, const int16_t *filterPos, int filterSize) { int i; for (i=0; i<[[dstW]]; i++) { int j; int srcPos= filterPos[i]; int val=0; for (j=0; j<filterSize; j++) { val += ((int)src[srcPos + j])*filter[filterSize*i + j]; } dst[i] = FFMIN(val>>7, (1<<15)-1); } }

[[[[Adv]]]]: static void hScale8To15_c(SwsContext *c, int16_t *dst, int [[biseten]], const uint8_t *src, const int16_t *filter, const int16_t *filterPos, int filterSize) { int i; for (i=0; i<[[biseten]]; i++) { int j; int srcPos= filterPos[i]; int val=0; for (j=0; j<filterSize; j++) { val += ((int)src[srcPos + j])*filter[filterSize*i + j]; } dst[i] = FFMIN(val>>7, (1<<15)-1); } }
--------------------------------------------- Result 309 ---------------------------------------------
[[0 (79%)]] --> [[[FAILED]]]

[[[[Adv]]]]: MigrationState *migrate_get_current(void) { static MigrationState [[current_migration]] = { .state = MIG_STATE_NONE, .bandwidth_limit = MAX_THROTTLE, .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE, .mbps = -1, }; return &[[current_migration]]; }

[[[[Adv]]]]: MigrationState *migrate_get_current(void) { static MigrationState [[staticwheeladaptation]] = { .state = MIG_STATE_NONE, .bandwidth_limit = MAX_THROTTLE, .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE, .mbps = -1, }; return &[[staticwheeladaptation]]; }
--------------------------------------------- Result 310 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qcow2_change_backing_file(BlockDriverState *bs, const char *backing_file, const char *backing_fmt) { return qcow2_update_ext_header(bs, backing_file, backing_fmt); }
--------------------------------------------- Result 311 ---------------------------------------------
[[0 (2%)]] --> [[0 (89%)]] --> Socre: 0.8882490396499634

[[[[Adv]]]]: static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) { const int [[qp_bd_offset]] = 6 * (h->sps.bit_depth_luma - 8); const unsigned int [[index_a]] = qp - [[qp_bd_offset]] + h->slice_alpha_c0_offset; const int [[alpha]] = alpha_table[[[index_a]]]; const int beta = beta_table[qp - [[qp_bd_offset]] + h->slice_beta_offset]; if ([[alpha]] ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[[[index_a]]][bS[0]]+1; tc[1] = tc0_table[[[index_a]]][bS[1]]+1; tc[2] = tc0_table[[[index_a]]][bS[2]]+1; tc[3] = tc0_table[[[index_a]]][bS[3]]+1; h->h264dsp.h264_v_loop_filter_chroma(pix, stride, [[alpha]], beta, tc); } else { h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, [[alpha]], beta); } }

[[[[Adv]]]]: static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) { const int [[قsycharliendlogimage]] = 6 * (h->sps.bit_depth_luma - 8); const unsigned int [[equationersа]] = qp - [[قsycharliendlogimage]] + h->slice_alpha_c0_offset; const int [[α]] = alpha_table[[[equationersа]]]; const int beta = beta_table[qp - [[قsycharliendlogimage]] + h->slice_beta_offset]; if ([[α]] ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[[[equationersа]]][bS[0]]+1; tc[1] = tc0_table[[[equationersа]]][bS[1]]+1; tc[2] = tc0_table[[[equationersа]]][bS[2]]+1; tc[3] = tc0_table[[[equationersа]]][bS[3]]+1; h->h264dsp.h264_v_loop_filter_chroma(pix, stride, [[α]], beta, tc); } else { h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, [[α]], beta); } }
--------------------------------------------- Result 312 ---------------------------------------------
[[0 (95%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size, const char *boot_device, DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env, *envs[MAX_CPUS]; unsigned int i; void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi; qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq, *espdma_irq, *ledma_irq; qemu_irq *esp_reset, *le_reset; ram_addr_t ram_offset, prom_offset, tcx_offset; unsigned long kernel_size; int ret; char buf[1024]; int drive_index; void *fw_cfg; if (!cpu_model) cpu_model = hwdef->default_cpu_model; for (i = 0; i < smp_cpus; i++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n"); exit(1); } cpu_sparc_set_id(env, i); envs[i] = env; if (i == 0) { qemu_register_reset(main_cpu_reset, env); } else { qemu_register_reset(secondary_cpu_reset, env); env->halted = 1; } cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS); env->prom_addr = hwdef->slavio_base; } for (i = smp_cpus; i < MAX_CPUS; i++) cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS); if ((uint64_t)RAM_size > hwdef->max_mem) { fprintf(stderr, "qemu: Too much memory for this machine: %d, maximum %d\n", (unsigned int)(RAM_size / (1024 * 1024)), (unsigned int)(hwdef->max_mem / (1024 * 1024))); exit(1); } ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->slavio_base, (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; snprintf(buf, sizeof(buf), "%s/%s", bios_dir, bios_name); ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL); if (ret < 0 || ret > PROM_SIZE_MAX) ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX); if (ret < 0 || ret > PROM_SIZE_MAX) { fprintf(stderr, "qemu: could not load prom '%s'\n", buf); exit(1); } sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs); for (i = 0; i < MAX_IOUNITS; i++) if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1) iounits[i] = iommu_init(hwdef->iounit_bases[i], hwdef->iounit_version, sbi_irq[hwdef->me_irq]); espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq], iounits[0], &espdma_irq, &esp_reset); ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq], iounits[0], &ledma_irq, &le_reset); if (graphic_depth != 8 && graphic_depth != 24) { fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth); exit (1); } tcx_offset = qemu_ram_alloc(hwdef->vram_size); tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset, hwdef->vram_size, graphic_width, graphic_height, graphic_depth); if (nd_table[0].model == NULL) nd_table[0].model = "lance"; if (strcmp(nd_table[0].model, "lance") == 0) { lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset); } else if (strcmp(nd_table[0].model, "?") == 0) { fprintf(stderr, "qemu: Supported NICs: lance\n"); exit (1); } else { fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model); exit (1); } nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0, hwdef->nvram_size, 8); slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq], sbi_cpu_irq, smp_cpus); slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq], nographic, ESCC_CLOCK, 1); escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1], serial_hds[0], ESCC_CLOCK, 1); if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, "qemu: too many SCSI bus\n"); exit(1); } main_esp = esp_init(hwdef->esp_base, 2, espdma_memory_read, espdma_memory_write, espdma, *espdma_irq, esp_reset); for (i = 0; i < ESP_MAX_DEVS; i++) { drive_index = drive_get_index(IF_SCSI, 0, i); if (drive_index == -1) continue; esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i); } kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename, RAM_size); nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline, boot_device, RAM_size, kernel_size, graphic_width, graphic_height, graphic_depth, hwdef->nvram_machine_id, "Sun4d"); fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); }
--------------------------------------------- Result 313 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested) { int num_cq_events = 0, ret = 0; struct ibv_cq *cq; void *cq_ctx; uint64_t wr_id = RDMA_WRID_NONE, wr_id_in; if (ibv_req_notify_cq(rdma->cq, 0)) { return -1; } while (wr_id != wrid_requested) { ret = qemu_rdma_poll(rdma, &wr_id_in); if (ret < 0) { return ret; } wr_id = wr_id_in & RDMA_WRID_TYPE_MASK; if (wr_id == RDMA_WRID_NONE) { break; } if (wr_id != wrid_requested) { DDDPRINTF("A Wanted wrid %s (%d) but got %s (%" PRIu64 ")\n", print_wrid(wrid_requested), wrid_requested, print_wrid(wr_id), wr_id); } } if (wr_id == wrid_requested) { return 0; } while (1) { if (rdma->migration_started_on_destination) { yield_until_fd_readable(rdma->comp_channel->fd); } if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) { perror("ibv_get_cq_event"); goto err_block_for_wrid; } num_cq_events++; if (ibv_req_notify_cq(cq, 0)) { goto err_block_for_wrid; } while (wr_id != wrid_requested) { ret = qemu_rdma_poll(rdma, &wr_id_in); if (ret < 0) { goto err_block_for_wrid; } wr_id = wr_id_in & RDMA_WRID_TYPE_MASK; if (wr_id == RDMA_WRID_NONE) { break; } if (wr_id != wrid_requested) { DDDPRINTF("B Wanted wrid %s (%d) but got %s (%" PRIu64 ")\n", print_wrid(wrid_requested), wrid_requested, print_wrid(wr_id), wr_id); } } if (wr_id == wrid_requested) { goto success_block_for_wrid; } } success_block_for_wrid: if (num_cq_events) { ibv_ack_cq_events(cq, num_cq_events); } return 0; err_block_for_wrid: if (num_cq_events) { ibv_ack_cq_events(cq, num_cq_events); } return ret; }
--------------------------------------------- Result 314 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int blkverify_open(BlockDriverState *bs, QDict *[[options]], int [[flags]], Error **[[errp]]) { BDRVBlkverifyState *[[s]] = bs->opaque; QemuOpts *opts; Error *local_err = NULL; int ret; opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort); qemu_opts_absorb_qdict(opts, [[options]], &local_err); if (local_err) { error_propagate([[errp]], local_err); ret = -EINVAL; goto fail; bs->file = bdrv_open_child(qemu_opt_get(opts, "x-raw"), [[options]], "raw", bs, &child_file, "[[False]]" != "[[False]]", &local_err); if (local_err) { ret = -EINVAL; error_propagate([[errp]], local_err); goto fail; [[s]]->test_file = bdrv_open_child(qemu_opt_get(opts, "x-image"), [[options]], "test", bs, &child_format, "[[False]]" != "[[False]]", &local_err); if (local_err) { ret = -EINVAL; error_propagate([[errp]], local_err); goto fail; ret = 0; fail: qemu_opts_del(opts); return ret;

[[[[Adv]]]]: static int blkverify_open(BlockDriverState *bs, QDict *[[gates]], int [[iris]], Error **[[wrр]]) { BDRVBlkverifyState *[[stands]] = bs->opaque; QemuOpts *opts; Error *local_err = NULL; int ret; opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort); qemu_opts_absorb_qdict(opts, [[gates]], &local_err); if (local_err) { error_propagate([[wrр]], local_err); ret = -EINVAL; goto fail; bs->file = bdrv_open_child(qemu_opt_get(opts, "x-raw"), [[gates]], "raw", bs, &child_file, "[[inaccurate]]" != "[[inaccurate]]", &local_err); if (local_err) { ret = -EINVAL; error_propagate([[wrр]], local_err); goto fail; [[stands]]->test_file = bdrv_open_child(qemu_opt_get(opts, "x-image"), [[gates]], "test", bs, &child_format, "[[inaccurate]]" != "[[inaccurate]]", &local_err); if (local_err) { ret = -EINVAL; error_propagate([[wrр]], local_err); goto fail; ret = 0; fail: qemu_opts_del(opts); return ret;
[Succeeded / Failed / Skipped / Total] 161 / 30 / 124 / 315:  12%|█▏        | 315/2690 [43:51<5:30:40,  8.35s/it][Succeeded / Failed / Skipped / Total] 161 / 30 / 124 / 315:  12%|█▏        | 316/2690 [43:51<5:29:33,  8.33s/it][Succeeded / Failed / Skipped / Total] 161 / 30 / 125 / 316:  12%|█▏        | 316/2690 [43:51<5:29:33,  8.33s/it][Succeeded / Failed / Skipped / Total] 161 / 30 / 125 / 316:  12%|█▏        | 317/2690 [43:54<5:28:38,  8.31s/it][Succeeded / Failed / Skipped / Total] 162 / 30 / 125 / 317:  12%|█▏        | 317/2690 [43:54<5:28:38,  8.31s/it][Succeeded / Failed / Skipped / Total] 162 / 30 / 125 / 317:  12%|█▏        | 318/2690 [44:19<5:30:36,  8.36s/it][Succeeded / Failed / Skipped / Total] 163 / 30 / 125 / 318:  12%|█▏        | 318/2690 [44:19<5:30:36,  8.36s/it][Succeeded / Failed / Skipped / Total] 163 / 30 / 125 / 318:  12%|█▏        | 319/2690 [44:19<5:29:29,  8.34s/it][Succeeded / Failed / Skipped / Total] 163 / 30 / 126 / 319:  12%|█▏        | 319/2690 [44:19<5:29:29,  8.34s/it][Succeeded / Failed / Skipped / Total] 163 / 30 / 126 / 319:  12%|█▏        | 320/2690 [44:20<5:28:22,  8.31s/it][Succeeded / Failed / Skipped / Total] 163 / 30 / 127 / 320:  12%|█▏        | 320/2690 [44:20<5:28:22,  8.31s/it][Succeeded / Failed / Skipped / Total] 163 / 30 / 127 / 320:  12%|█▏        | 321/2690 [44:32<5:28:44,  8.33s/it][Succeeded / Failed / Skipped / Total] 164 / 30 / 127 / 321:  12%|█▏        | 321/2690 [44:32<5:28:44,  8.33s/it][Succeeded / Failed / Skipped / Total] 164 / 30 / 127 / 321:  12%|█▏        | 322/2690 [45:25<5:34:02,  8.46s/it]--------------------------------------------- Result 315 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mux_chr_can_read(void *opaque) { CharDriverState *chr = opaque; MuxDriver *d = chr->opaque; if ((d->prod - d->cons) < MUX_BUFFER_SIZE) return 1; if (d->chr_can_read[chr->focus]) return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]); return 0; }
--------------------------------------------- Result 316 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s) { return s->iq_tail == 0; }
--------------------------------------------- Result 317 ---------------------------------------------
[[0 (85%)]] --> [[0 (40%)]] --> Socre: 0.5968178808689117

[[[[Adv]]]]: qemu_co_sendv_recvv(int [[sockfd]], struct iovec *[[iov]], unsigned iov_cnt, size_t offset, size_t bytes, bool do_send) { size_t done = 0; ssize_t ret; while (done < bytes) { ret = iov_send_recv([[sockfd]], [[iov]], offset + done, bytes - done, do_send); if (ret > 0) { done += ret; } else if (ret < 0) { if (errno == EAGAIN) { qemu_coroutine_yield(); } else if (done == 0) { return -1; } else { break; } } else if (ret == 0 && !do_send) { break; } } return done; }

[[[[Adv]]]]: qemu_co_sendv_recvv(int [[toesftds]], struct iovec *[[elf]], unsigned iov_cnt, size_t offset, size_t bytes, bool do_send) { size_t done = 0; ssize_t ret; while (done < bytes) { ret = iov_send_recv([[toesftds]], [[elf]], offset + done, bytes - done, do_send); if (ret > 0) { done += ret; } else if (ret < 0) { if (errno == EAGAIN) { qemu_coroutine_yield(); } else if (done == 0) { return -1; } else { break; } } else if (ret == 0 && !do_send) { break; } } return done; }
--------------------------------------------- Result 318 ---------------------------------------------
[[0 (98%)]] --> [[0 (43%)]] --> Socre: 0.5689515471458435

[[[[Adv]]]]: static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth, const uint8_t *src_in[4], int srcW, int xInc, const int16_t *hChrFilter, const int16_t *hChrFilterPos, int hChrFilterSize, uint8_t *formatConvBuffer, uint32_t *pal) { const uint8_t *src1 = src_in[1], *src2 = src_in[2]; if (c->chrToYV12) { uint8_t *[[buf2]] = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->chrToYV12(formatConvBuffer, [[buf2]], src1, src2, srcW, pal); src1= formatConvBuffer; src2= [[buf2]]; } else if (c->readChrPlanar) { uint8_t *[[buf2]] = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->readChrPlanar(formatConvBuffer, [[buf2]], src_in, srcW); src1= formatConvBuffer; src2= [[buf2]]; } if (!c->hcscale_fast) { c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize); c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize); } else { c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc); } if (c->chrConvertRange) c->chrConvertRange(dst1, dst2, dstWidth); }

[[[[Adv]]]]: static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth, const uint8_t *src_in[4], int srcW, int xInc, const int16_t *hChrFilter, const int16_t *hChrFilterPos, int hChrFilterSize, uint8_t *formatConvBuffer, uint32_t *pal) { const uint8_t *src1 = src_in[1], *src2 = src_in[2]; if (c->chrToYV12) { uint8_t *[[muford11]] = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->chrToYV12(formatConvBuffer, [[muford11]], src1, src2, srcW, pal); src1= formatConvBuffer; src2= [[muford11]]; } else if (c->readChrPlanar) { uint8_t *[[muford11]] = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->readChrPlanar(formatConvBuffer, [[muford11]], src_in, srcW); src1= formatConvBuffer; src2= [[muford11]]; } if (!c->hcscale_fast) { c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize); c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize); } else { c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc); } if (c->chrConvertRange) c->chrConvertRange(dst1, dst2, dstWidth); }
--------------------------------------------- Result 319 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp) { virtio_scsi_common_unrealize(dev, errp); }
--------------------------------------------- Result 320 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int protocol_client_init(VncState *vs, uint8_t *data, size_t len) { char buf[1024]; VncShareMode mode; int size; mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE; switch (vs->vd->share_policy) { case VNC_SHARE_POLICY_IGNORE: break; case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE: if (mode == VNC_SHARE_MODE_EXCLUSIVE) { VncState *client; QTAILQ_FOREACH(client, &vs->vd->clients, next) { if (vs == client) { continue; } if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE && client->share_mode != VNC_SHARE_MODE_SHARED) { continue; } vnc_disconnect_start(client); } } if (mode == VNC_SHARE_MODE_SHARED) { if (vs->vd->num_exclusive > 0) { vnc_disconnect_start(vs); return 0; } } break; case VNC_SHARE_POLICY_FORCE_SHARED: if (mode == VNC_SHARE_MODE_EXCLUSIVE) { vnc_disconnect_start(vs); return 0; } break; } vnc_set_share_mode(vs, mode); vs->client_width = surface_width(vs->vd->ds); vs->client_height = surface_height(vs->vd->ds); vnc_write_u16(vs, vs->client_width); vnc_write_u16(vs, vs->client_height); pixel_format_message(vs); if (qemu_name) size = snprintf(buf, sizeof(buf), "QEMU (%s)", qemu_name); else size = snprintf(buf, sizeof(buf), "QEMU"); vnc_write_u32(vs, size); vnc_write(vs, buf, size); vnc_flush(vs); vnc_client_cache_auth(vs); vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED); vnc_read_when(vs, protocol_client_msg, 1); return 0; }
--------------------------------------------- Result 321 ---------------------------------------------
[[0 (99%)]] --> [[0 (34%)]] --> Socre: 0.664810299873352

[[[[Adv]]]]: static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int [[src_size]]) { const uint16_t *end; const uint16_t *[[mm_end]]; uint8_t *d = dst; const uint16_t *[[s]] = (const uint16_t *)src; end = [[s]] + [[src_size]]/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); __asm__ volatile("pxor %%mm7,%%mm7 \n\t":::"memory"); __asm__ volatile("pcmpeqd %%mm6,%%mm6 \n\t":::"memory"); [[mm_end]] = end - 3; while ([[s]] < [[mm_end]]) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" PACK_RGB32 :"=m"(*d) :"m"(*[[s]]),"m"(mask15b),"m"(mask15g),"m"(mask15r) :"memory"); d += 16; [[s]] += 4; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[s]] < end) { register uint16_t bgr; bgr = *[[s]]++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; *d++ = 255; } }

[[[[Adv]]]]: static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int [[sarp16number]]) { const uint16_t *end; const uint16_t *[[series162]]; uint8_t *d = dst; const uint16_t *[[r]] = (const uint16_t *)src; end = [[r]] + [[sarp16number]]/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); __asm__ volatile("pxor %%mm7,%%mm7 \n\t":::"memory"); __asm__ volatile("pcmpeqd %%mm6,%%mm6 \n\t":::"memory"); [[series162]] = end - 3; while ([[r]] < [[series162]]) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" PACK_RGB32 :"=m"(*d) :"m"(*[[r]]),"m"(mask15b),"m"(mask15g),"m"(mask15r) :"memory"); d += 16; [[r]] += 4; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[r]] < end) { register uint16_t bgr; bgr = *[[r]]++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; *d++ = 255; } }
[Succeeded / Failed / Skipped / Total] 164 / 31 / 127 / 322:  12%|█▏        | 322/2690 [45:25<5:34:02,  8.46s/it][Succeeded / Failed / Skipped / Total] 164 / 31 / 127 / 322:  12%|█▏        | 323/2690 [45:25<5:32:55,  8.44s/it][Succeeded / Failed / Skipped / Total] 164 / 31 / 128 / 323:  12%|█▏        | 323/2690 [45:25<5:32:55,  8.44s/it][Succeeded / Failed / Skipped / Total] 164 / 31 / 128 / 323:  12%|█▏        | 324/2690 [45:27<5:31:55,  8.42s/it]--------------------------------------------- Result 322 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x, const uint8_t *src_y, int32_t [[src_stride]], uint8_t *dst, int32_t [[dst_stride]]) { v16i8 [[src_hz0]], src_hz1, src_hz2, src_hz3; v16u8 dst0, dst1, dst2, dst3; v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4; v16i8 [[src_vt5]], src_vt6, src_vt7, src_vt8; v16i8 mask0, mask1, mask2; v8i16 [[hz_out0]], hz_out1, vert_out0, vert_out1; v8i16 res0, res1; v16u8 res; LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2); LD_SB5(src_y, [[src_stride]], src_vt0, src_vt1, src_vt2, src_vt3, src_vt4); src_y += (5 * [[src_stride]]); src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1); src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2); src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3); src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4); XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3); LD_SB4(src_x, [[src_stride]], [[src_hz0]], src_hz1, src_hz2, src_hz3); LD_UB4(dst, [[dst_stride]], dst0, dst1, dst2, dst3); XORI_B4_128_SB([[src_hz0]], src_hz1, src_hz2, src_hz3); [[hz_out0]] = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH([[src_hz0]], src_hz1, mask0, mask1, mask2); hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3, mask0, mask1, mask2); SRARI_H2_SH([[hz_out0]], hz_out1, 5); SAT_SH2_SH([[hz_out0]], hz_out1, 7); LD_SB4(src_y, [[src_stride]], [[src_vt5]], src_vt6, src_vt7, src_vt8); src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) [[src_vt5]]); [[src_vt5]] = (v16i8) __msa_insve_w((v4i32) [[src_vt5]], 1, (v4i32) src_vt6); src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7); src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8); XORI_B4_128_SB(src_vt4, [[src_vt5]], src_vt6, src_vt7); vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2, src_vt3, src_vt4, [[src_vt5]]); vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4, [[src_vt5]], src_vt6, src_vt7); SRARI_H2_SH(vert_out0, vert_out1, 5); SAT_SH2_SH(vert_out0, vert_out1, 7); res1 = __msa_srari_h((hz_out1 + vert_out1), 1); res0 = __msa_srari_h(([[hz_out0]] + vert_out0), 1); SAT_SH2_SH(res0, res1, 7); res = PCKEV_XORI128_UB(res0, res1); dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1); dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3); dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1); dst0 = __msa_aver_u_b(res, dst0); ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, [[dst_stride]]); }

[[[[Adv]]]]: static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x, const uint8_t *src_y, int32_t [[maec²rex]], uint8_t *dst, int32_t [[vsdbigrush]]) { v16i8 [[hovecus8topsi]], src_hz1, src_hz2, src_hz3; v16u8 dst0, dst1, dst2, dst3; v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4; v16i8 [[srclejrea]], src_vt6, src_vt7, src_vt8; v16i8 mask0, mask1, mask2; v8i16 [[swbigit1]], hz_out1, vert_out0, vert_out1; v8i16 res0, res1; v16u8 res; LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2); LD_SB5(src_y, [[maec²rex]], src_vt0, src_vt1, src_vt2, src_vt3, src_vt4); src_y += (5 * [[maec²rex]]); src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1); src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2); src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3); src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4); XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3); LD_SB4(src_x, [[maec²rex]], [[hovecus8topsi]], src_hz1, src_hz2, src_hz3); LD_UB4(dst, [[vsdbigrush]], dst0, dst1, dst2, dst3); XORI_B4_128_SB([[hovecus8topsi]], src_hz1, src_hz2, src_hz3); [[swbigit1]] = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH([[hovecus8topsi]], src_hz1, mask0, mask1, mask2); hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3, mask0, mask1, mask2); SRARI_H2_SH([[swbigit1]], hz_out1, 5); SAT_SH2_SH([[swbigit1]], hz_out1, 7); LD_SB4(src_y, [[maec²rex]], [[srclejrea]], src_vt6, src_vt7, src_vt8); src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) [[srclejrea]]); [[srclejrea]] = (v16i8) __msa_insve_w((v4i32) [[srclejrea]], 1, (v4i32) src_vt6); src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7); src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8); XORI_B4_128_SB(src_vt4, [[srclejrea]], src_vt6, src_vt7); vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2, src_vt3, src_vt4, [[srclejrea]]); vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4, [[srclejrea]], src_vt6, src_vt7); SRARI_H2_SH(vert_out0, vert_out1, 5); SAT_SH2_SH(vert_out0, vert_out1, 7); res1 = __msa_srari_h((hz_out1 + vert_out1), 1); res0 = __msa_srari_h(([[swbigit1]] + vert_out0), 1); SAT_SH2_SH(res0, res1, 7); res = PCKEV_XORI128_UB(res0, res1); dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1); dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3); dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1); dst0 = __msa_aver_u_b(res, dst0); ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, [[vsdbigrush]]); }
--------------------------------------------- Result 323 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size) { TCXState *s = opaque; uint32_t adsr, len; int i; if (!(addr & 4)) { s->tmpblit = val; } else { addr = (addr >> 3) & 0xfffff; adsr = val & 0xffffff; len = ((val >> 24) & 0x1f) + 1; if (adsr == 0xffffff) { memset(&s->vram[addr], s->tmpblit, len); if (s->depth == 24) { val = s->tmpblit & 0xffffff; val = cpu_to_be32(val); for (i = 0; i < len; i++) { s->vram24[addr + i] = val; } } } else { memcpy(&s->vram[addr], &s->vram[adsr], len); if (s->depth == 24) { memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4); } } memory_region_set_dirty(&s->vram_mem, addr, len); } }
--------------------------------------------- Result 324 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 164 / 32 / 128 / 324:  12%|█▏        | 324/2690 [45:27<5:31:55,  8.42s/it][Succeeded / Failed / Skipped / Total] 164 / 32 / 128 / 324:  12%|█▏        | 325/2690 [45:27<5:30:49,  8.39s/it][Succeeded / Failed / Skipped / Total] 164 / 32 / 129 / 325:  12%|█▏        | 325/2690 [45:27<5:30:49,  8.39s/it][Succeeded / Failed / Skipped / Total] 164 / 32 / 129 / 325:  12%|█▏        | 326/2690 [45:28<5:29:44,  8.37s/it][Succeeded / Failed / Skipped / Total] 164 / 32 / 130 / 326:  12%|█▏        | 326/2690 [45:28<5:29:44,  8.37s/it][Succeeded / Failed / Skipped / Total] 164 / 32 / 130 / 326:  12%|█▏        | 327/2690 [46:02<5:32:45,  8.45s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child, int64_t [[offset]], unsigned int [[bytes]], QEMUIOVector *qiov) { BlockDriverState *[[bs]] = child->bs; void *bounce_buffer; BlockDriver *drv = [[bs]]->drv; struct iovec iov; QEMUIOVector local_qiov; int64_t [[cluster_offset]]; int64_t [[cluster_bytes]]; size_t skip_bytes; int ret; int max_transfer = MIN_NON_ZERO([[bs]]->bl.max_transfer, BDRV_REQUEST_MAX_BYTES); unsigned int progress = 0; bdrv_round_to_clusters([[bs]], [[offset]], [[bytes]], &[[cluster_offset]], &[[cluster_bytes]]); skip_bytes = [[offset]] - [[cluster_offset]]; trace_bdrv_co_do_copy_on_readv([[bs]], [[offset]], [[bytes]], [[cluster_offset]], [[cluster_bytes]]); bounce_buffer = qemu_try_blockalign([[bs]], MIN(MIN(max_transfer, [[cluster_bytes]]), MAX_BOUNCE_BUFFER)); if (bounce_buffer == NULL) { ret = -ENOMEM; goto err; while ([[cluster_bytes]]) { int64_t pnum; ret = bdrv_is_allocated([[bs]], [[cluster_offset]], MIN([[cluster_bytes]], max_transfer), &pnum); if (ret < 0) { pnum = MIN([[cluster_bytes]], max_transfer); assert(skip_bytes < pnum); if (ret <= 0) { iov.iov_base = bounce_buffer; iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER); qemu_iovec_init_external(&local_qiov, &iov, 1); ret = bdrv_driver_preadv([[bs]], [[cluster_offset]], pnum, &local_qiov, 0); if (ret < 0) { goto err; bdrv_debug_event([[bs]], BLKDBG_COR_WRITE); if (drv->bdrv_co_pwrite_zeroes && buffer_is_zero(bounce_buffer, pnum)) { ret = bdrv_co_do_pwrite_zeroes([[bs]], [[cluster_offset]], pnum, 0); } else { ret = bdrv_driver_pwritev([[bs]], [[cluster_offset]], pnum, &local_qiov, 0); if (ret < 0) { goto err; qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes, pnum - skip_bytes); } else { qemu_iovec_init(&local_qiov, qiov->niov); qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes); ret = bdrv_driver_preadv([[bs]], [[offset]] + progress, local_qiov.size, &local_qiov, 0); qemu_iovec_destroy(&local_qiov); if (ret < 0) { goto err; [[cluster_offset]] += pnum; [[cluster_bytes]] -= pnum; progress += pnum - skip_bytes; skip_bytes = 0; ret = 0; err: qemu_vfree(bounce_buffer); return ret;

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child, int64_t [[footprint]], unsigned int [[balls]], QEMUIOVector *qiov) { BlockDriverState *[[babu]] = child->bs; void *bounce_buffer; BlockDriver *drv = [[babu]]->drv; struct iovec iov; QEMUIOVector local_qiov; int64_t [[groupactivespur]]; int64_t [[caf²ies]]; size_t skip_bytes; int ret; int max_transfer = MIN_NON_ZERO([[babu]]->bl.max_transfer, BDRV_REQUEST_MAX_BYTES); unsigned int progress = 0; bdrv_round_to_clusters([[babu]], [[footprint]], [[balls]], &[[groupactivespur]], &[[caf²ies]]); skip_bytes = [[footprint]] - [[groupactivespur]]; trace_bdrv_co_do_copy_on_readv([[babu]], [[footprint]], [[balls]], [[groupactivespur]], [[caf²ies]]); bounce_buffer = qemu_try_blockalign([[babu]], MIN(MIN(max_transfer, [[caf²ies]]), MAX_BOUNCE_BUFFER)); if (bounce_buffer == NULL) { ret = -ENOMEM; goto err; while ([[caf²ies]]) { int64_t pnum; ret = bdrv_is_allocated([[babu]], [[groupactivespur]], MIN([[caf²ies]], max_transfer), &pnum); if (ret < 0) { pnum = MIN([[caf²ies]], max_transfer); assert(skip_bytes < pnum); if (ret <= 0) { iov.iov_base = bounce_buffer; iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER); qemu_iovec_init_external(&local_qiov, &iov, 1); ret = bdrv_driver_preadv([[babu]], [[groupactivespur]], pnum, &local_qiov, 0); if (ret < 0) { goto err; bdrv_debug_event([[babu]], BLKDBG_COR_WRITE); if (drv->bdrv_co_pwrite_zeroes && buffer_is_zero(bounce_buffer, pnum)) { ret = bdrv_co_do_pwrite_zeroes([[babu]], [[groupactivespur]], pnum, 0); } else { ret = bdrv_driver_pwritev([[babu]], [[groupactivespur]], pnum, &local_qiov, 0); if (ret < 0) { goto err; qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes, pnum - skip_bytes); } else { qemu_iovec_init(&local_qiov, qiov->niov); qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes); ret = bdrv_driver_preadv([[babu]], [[footprint]] + progress, local_qiov.size, &local_qiov, 0); qemu_iovec_destroy(&local_qiov); if (ret < 0) { goto err; [[groupactivespur]] += pnum; [[caf²ies]] -= pnum; progress += pnum - skip_bytes; skip_bytes = 0; ret = 0; err: qemu_vfree(bounce_buffer); return ret;
--------------------------------------------- Result 325 ---------------------------------------------
[[0 (33%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32_t *timestamp, const uint8_t *buf, int len, uint16_t seq, int flags) { int sbit, ebit, gobn, mbap, quant; int res; if (data->buf && data->timestamp != *timestamp) { h261_free_dyn_buffer(&data->buf); } if (len < 5 ) { av_log(ctx, AV_LOG_ERROR, "Too short H.261 RTP packet\n"); return AVERROR_INVALIDDATA; } sbit = (buf[0] >> 5) & 0x07; ebit = (buf[0] >> 2) & 0x07; gobn = (buf[1] >> 4) & 0x0f; mbap = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01); quant = (buf[1] >> 4) & 0x0f; buf += RTP_H261_PAYLOAD_HEADER_SIZE; len -= RTP_H261_PAYLOAD_HEADER_SIZE; if (!data->buf) { if (!gobn && !sbit && !mbap && !quant){ res = avio_open_dyn_buf(&data->buf); if (res < 0) return res; data->timestamp = *timestamp; } else { return AVERROR(EAGAIN); } } if (data->endbyte_bits || sbit) { if (data->endbyte_bits == sbit) { data->endbyte |= buf[0] & (0xff >> sbit); data->endbyte_bits = 0; buf++; len--; avio_w8(data->buf, data->endbyte); } else { GetBitContext gb; init_get_bits(&gb, buf, len*8 - ebit); skip_bits(&gb, sbit); if (data->endbyte_bits) { data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits); avio_w8(data->buf, data->endbyte); } while (get_bits_left(&gb) >= 8) avio_w8(data->buf, get_bits(&gb, 8)); data->endbyte_bits = get_bits_left(&gb); if (data->endbyte_bits) data->endbyte = get_bits(&gb, data->endbyte_bits) << (8 - data->endbyte_bits); ebit = 0; len = 0; } } if (ebit) { if (len > 0) avio_write(data->buf, buf, len - 1); data->endbyte_bits = 8 - ebit; data->endbyte = buf[len - 1] & (0xff << ebit); } else { avio_write(data->buf, buf, len); } if (!(flags & RTP_FLAG_MARKER)) return AVERROR(EAGAIN); if (data->endbyte_bits) avio_w8(data->buf, data->endbyte); data->endbyte_bits = 0; res = ff_rtp_finalize_packet(pkt, &data->buf, st->index); if (res < 0) return res; return 0; }
--------------------------------------------- Result 326 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vdpau_mpeg_start_frame(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size) { MpegEncContext * const s = avctx->priv_data; Picture *pic = s->current_picture_ptr; struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private; VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg; VdpVideoSurface ref; int i; info->forward_reference = VDP_INVALID_HANDLE; info->backward_reference = VDP_INVALID_HANDLE; switch (s->pict_type) { case AV_PICTURE_TYPE_B: ref = ff_vdpau_get_surface_id(&s->next_picture.f); assert(ref != VDP_INVALID_HANDLE); info->backward_reference = ref; case AV_PICTURE_TYPE_P: ref = ff_vdpau_get_surface_id(&s->last_picture.f); info->forward_reference = ref; } info->slice_count = 0; info->picture_structure = s->picture_structure; info->picture_coding_type = s->pict_type; info->intra_dc_precision = s->intra_dc_precision; info->frame_pred_frame_dct = s->frame_pred_frame_dct; info->concealment_motion_vectors = s->concealment_motion_vectors; info->intra_vlc_format = s->intra_vlc_format; info->alternate_scan = s->alternate_scan; info->q_scale_type = s->q_scale_type; info->top_field_first = s->top_field_first; info->full_pel_forward_vector = s->full_pel[0]; info->full_pel_backward_vector = s->full_pel[1]; info->f_code[0][0] = s->mpeg_f_code[0][0]; info->f_code[0][1] = s->mpeg_f_code[0][1]; info->f_code[1][0] = s->mpeg_f_code[1][0]; info->f_code[1][1] = s->mpeg_f_code[1][1]; for (i = 0; i < 64; ++i) { info->intra_quantizer_matrix[i] = s->intra_matrix[i]; info->non_intra_quantizer_matrix[i] = s->inter_matrix[i]; } return ff_vdpau_common_start_frame(pic_ctx, buffer, size); }
[Succeeded / Failed / Skipped / Total] 164 / 33 / 130 / 327:  12%|█▏        | 327/2690 [46:02<5:32:45,  8.45s/it][Succeeded / Failed / Skipped / Total] 164 / 33 / 130 / 327:  12%|█▏        | 328/2690 [46:03<5:31:40,  8.43s/it][Succeeded / Failed / Skipped / Total] 164 / 33 / 131 / 328:  12%|█▏        | 328/2690 [46:03<5:31:40,  8.43s/it][Succeeded / Failed / Skipped / Total] 164 / 33 / 131 / 328:  12%|█▏        | 329/2690 [46:03<5:30:34,  8.40s/it][Succeeded / Failed / Skipped / Total] 164 / 33 / 132 / 329:  12%|█▏        | 329/2690 [46:03<5:30:35,  8.40s/it][Succeeded / Failed / Skipped / Total] 164 / 33 / 132 / 329:  12%|█▏        | 330/2690 [46:10<5:30:11,  8.39s/it][Succeeded / Failed / Skipped / Total] 165 / 33 / 132 / 330:  12%|█▏        | 330/2690 [46:10<5:30:11,  8.39s/it][Succeeded / Failed / Skipped / Total] 165 / 33 / 132 / 330:  12%|█▏        | 331/2690 [46:21<5:30:25,  8.40s/it][Succeeded / Failed / Skipped / Total] 166 / 33 / 132 / 331:  12%|█▏        | 331/2690 [46:21<5:30:25,  8.40s/it][Succeeded / Failed / Skipped / Total] 166 / 33 / 132 / 331:  12%|█▏        | 332/2690 [46:33<5:30:40,  8.41s/it]--------------------------------------------- Result 327 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void h263_decode_init_vlc(MpegEncContext *[[s]]) { static int [[done]] = 0; if (![[done]]) { [[done]] = 1; init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, intra_MCBPC_bits, 1, 1, intra_MCBPC_code, 1, 1); init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, inter_MCBPC_bits, 1, 1, inter_MCBPC_code, 1, 1); init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16, &cbpy_tab[0][1], 2, 1, &cbpy_tab[0][0], 2, 1); init_vlc(&mv_vlc, MV_VLC_BITS, 33, &mvtab[0][1], 2, 1, &mvtab[0][0], 2, 1); init_rl(&rl_inter); init_rl(&rl_intra); init_rl(&rvlc_rl_inter); init_rl(&rvlc_rl_intra); init_rl(&rl_intra_aic); init_vlc_rl(&rl_inter); init_vlc_rl(&rl_intra); init_vlc_rl(&rvlc_rl_inter); init_vlc_rl(&rvlc_rl_intra); init_vlc_rl(&rl_intra_aic); init_vlc(&dc_lum, DC_VLC_BITS, 10 , &DCtab_lum[0][1], 2, 1, &DCtab_lum[0][0], 2, 1); init_vlc(&dc_chrom, DC_VLC_BITS, 10 , &DCtab_chrom[0][1], 2, 1, &DCtab_chrom[0][0], 2, 1); init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15, &sprite_trajectory_tab[0][1], 4, 2, &sprite_trajectory_tab[0][0], 4, 2); init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4, &mb_type_b_tab[0][1], 2, 1, &mb_type_b_tab[0][0], 2, 1); init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15, &h263_mbtype_b_tab[0][1], 2, 1, &h263_mbtype_b_tab[0][0], 2, 1); init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4, &cbpc_b_tab[0][1], 2, 1, &cbpc_b_tab[0][0], 2, 1); } }

[[[[Adv]]]]: void h263_decode_init_vlc(MpegEncContext *[[m]]) { static int [[hall]] = 0; if (![[hall]]) { [[hall]] = 1; init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, intra_MCBPC_bits, 1, 1, intra_MCBPC_code, 1, 1); init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, inter_MCBPC_bits, 1, 1, inter_MCBPC_code, 1, 1); init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16, &cbpy_tab[0][1], 2, 1, &cbpy_tab[0][0], 2, 1); init_vlc(&mv_vlc, MV_VLC_BITS, 33, &mvtab[0][1], 2, 1, &mvtab[0][0], 2, 1); init_rl(&rl_inter); init_rl(&rl_intra); init_rl(&rvlc_rl_inter); init_rl(&rvlc_rl_intra); init_rl(&rl_intra_aic); init_vlc_rl(&rl_inter); init_vlc_rl(&rl_intra); init_vlc_rl(&rvlc_rl_inter); init_vlc_rl(&rvlc_rl_intra); init_vlc_rl(&rl_intra_aic); init_vlc(&dc_lum, DC_VLC_BITS, 10 , &DCtab_lum[0][1], 2, 1, &DCtab_lum[0][0], 2, 1); init_vlc(&dc_chrom, DC_VLC_BITS, 10 , &DCtab_chrom[0][1], 2, 1, &DCtab_chrom[0][0], 2, 1); init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15, &sprite_trajectory_tab[0][1], 4, 2, &sprite_trajectory_tab[0][0], 4, 2); init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4, &mb_type_b_tab[0][1], 2, 1, &mb_type_b_tab[0][0], 2, 1); init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15, &h263_mbtype_b_tab[0][1], 2, 1, &h263_mbtype_b_tab[0][0], 2, 1); init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4, &cbpc_b_tab[0][1], 2, 1, &cbpc_b_tab[0][0], 2, 1); } }
--------------------------------------------- Result 328 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset, unsigned size) { icp_pit_state *s = (icp_pit_state *)opaque; int n; n = offset >> 8; if (n > 3) { hw_error("sp804_read: Bad timer %d\n", n); } return arm_timer_read(s->timer[n], offset & 0xff); }
--------------------------------------------- Result 329 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size) { Mpeg1Context *s1 = avctx->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; int width, height, i, v, j; init_get_bits(&s->gb, buf, buf_size); width = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); skip_bits(&s->gb, 4); s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { s->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = width; s->height = height; s->has_b_frames = 1; s->avctx = avctx; avctx->width = width; avctx->height = height; avctx->frame_rate = frame_rate_tab[s->frame_rate_index]; s->frame_rate = avctx->frame_rate; avctx->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; mpeg1_init_vlc(s); s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = zigzag_direct[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[zigzag_direct[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { v = default_intra_matrix[i]; s->intra_matrix[i] = v; s->chroma_intra_matrix[i] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = zigzag_direct[i]; s->non_intra_matrix[j] = v; s->chroma_non_intra_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->non_intra_matrix[zigzag_direct[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { v = default_non_intra_matrix[i]; s->non_intra_matrix[i] = v; s->chroma_non_intra_matrix[i] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; return 0; }
--------------------------------------------- Result 330 ---------------------------------------------
[[0 (2%)]] --> [[0 (59%)]] --> Socre: 0.5882262587547302

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *[[bs]], int64_t [[sector_num]], QEMUIOVector *[[qiov]], int nb_sectors, BlockDriverCompletionFunc *[[cb]], void *[[opaque]]) { BDRVRawState *s = [[bs]]->opaque; return paio_submit([[bs]], s->hfile, [[sector_num]], [[qiov]], nb_sectors, [[cb]], [[opaque]], QEMU_AIO_READ); }

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *[[boys]], int64_t [[thebigtransf]], QEMUIOVector *[[xiof]], int nb_sectors, BlockDriverCompletionFunc *[[horseshoe]], void *[[array]]) { BDRVRawState *s = [[boys]]->opaque; return paio_submit([[boys]], s->hfile, [[thebigtransf]], [[xiof]], nb_sectors, [[horseshoe]], [[array]], QEMU_AIO_READ); }
--------------------------------------------- Result 331 ---------------------------------------------
[[0 (1%)]] --> [[0 (59%)]] --> Socre: 0.588732898235321

[[[[Adv]]]]: static void gen_compute_eflags_o(DisasContext *s, TCGv [[reg]]) { gen_compute_eflags(s); tcg_gen_shri_tl([[reg]], cpu_cc_src, 11); tcg_gen_andi_tl([[reg]], [[reg]], 1); }

[[[[Adv]]]]: static void gen_compute_eflags_o(DisasContext *s, TCGv [[s]]) { gen_compute_eflags(s); tcg_gen_shri_tl([[s]], cpu_cc_src, 11); tcg_gen_andi_tl([[s]], [[s]], 1); }
--------------------------------------------- Result 332 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 166 / 34 / 132 / 332:  12%|█▏        | 332/2690 [46:33<5:30:40,  8.41s/it][Succeeded / Failed / Skipped / Total] 166 / 34 / 132 / 332:  12%|█▏        | 333/2690 [47:22<5:35:17,  8.54s/it][[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *[[data_cb_or_cr]], uint8_t alpha_in, uint8_t beta_in, uint32_t img_width) { uint16_t [[out0]], out1, out2, out3; v8i16 tmp1; v16u8 alpha, beta, is_less_than; v8i16 [[p0_or_q0]], q0_or_p0; v16u8 [[p1_or_q1_org]], p0_or_q0_org, q0_or_p0_org, q1_or_p1_org; v16i8 zero = { 0 }; v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0; v16u8 is_less_than_alpha, is_less_than_beta; v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r; { v16u8 [[row0]], row1, row2, row3, row4, row5, row6, row7; LOAD_8VECS_UB(([[data_cb_or_cr]] - 2), img_width, [[row0]], row1, row2, row3, row4, row5, row6, row7); TRANSPOSE8x4_B_UB([[row0]], row1, row2, row3, row4, row5, row6, row7, [[p1_or_q1_org]], p0_or_q0_org, q0_or_p0_org, q1_or_p1_org); } alpha = (v16u8) __msa_fill_b(alpha_in); beta = (v16u8) __msa_fill_b(beta_in); p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org); p1_asub_p0 = __msa_asub_u_b([[p1_or_q1_org]], p0_or_q0_org); q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org); is_less_than_alpha = (p0_asub_q0 < alpha); is_less_than_beta = (p1_asub_p0 < beta); is_less_than = is_less_than_beta & is_less_than_alpha; is_less_than_beta = (q1_asub_q0 < beta); is_less_than = is_less_than_beta & is_less_than; is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than); if (!__msa_test_bz_v(is_less_than)) { p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) [[p1_or_q1_org]]); p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org); q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org); q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org); AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, [[p0_or_q0]]); AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0); [[p0_or_q0]] = (v8i16) __msa_pckev_b(zero, (v16i8) [[p0_or_q0]]); q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0); p0_or_q0_org = __msa_bmnz_v(p0_or_q0_org, (v16u8) [[p0_or_q0]], is_less_than); q0_or_p0_org = __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than); tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org); [[data_cb_or_cr]] -= 1; [[out0]] = __msa_copy_u_h(tmp1, 0); out1 = __msa_copy_u_h(tmp1, 1); out2 = __msa_copy_u_h(tmp1, 2); out3 = __msa_copy_u_h(tmp1, 3); STORE_HWORD([[data_cb_or_cr]], [[out0]]); [[data_cb_or_cr]] += img_width; STORE_HWORD([[data_cb_or_cr]], out1); [[data_cb_or_cr]] += img_width; STORE_HWORD([[data_cb_or_cr]], out2); [[data_cb_or_cr]] += img_width; STORE_HWORD([[data_cb_or_cr]], out3); [[data_cb_or_cr]] += img_width; [[out0]] = __msa_copy_u_h(tmp1, 4); out1 = __msa_copy_u_h(tmp1, 5); out2 = __msa_copy_u_h(tmp1, 6); out3 = __msa_copy_u_h(tmp1, 7); STORE_HWORD([[data_cb_or_cr]], [[out0]]); [[data_cb_or_cr]] += img_width; STORE_HWORD([[data_cb_or_cr]], out1); [[data_cb_or_cr]] += img_width; STORE_HWORD([[data_cb_or_cr]], out2); [[data_cb_or_cr]] += img_width; STORE_HWORD([[data_cb_or_cr]], out3); } }

[[[[Adv]]]]: static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *[[dnadraoyotkara]], uint8_t alpha_in, uint8_t beta_in, uint32_t img_width) { uint16_t [[edges]], out1, out2, out3; v8i16 tmp1; v16u8 alpha, beta, is_less_than; v8i16 [[qq6och_gh4]], q0_or_p0; v16u8 [[mgajeuarx90ofas]], p0_or_q0_org, q0_or_p0_org, q1_or_p1_org; v16i8 zero = { 0 }; v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0; v16u8 is_less_than_alpha, is_less_than_beta; v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r; { v16u8 [[stalk9]], row1, row2, row3, row4, row5, row6, row7; LOAD_8VECS_UB(([[dnadraoyotkara]] - 2), img_width, [[stalk9]], row1, row2, row3, row4, row5, row6, row7); TRANSPOSE8x4_B_UB([[stalk9]], row1, row2, row3, row4, row5, row6, row7, [[mgajeuarx90ofas]], p0_or_q0_org, q0_or_p0_org, q1_or_p1_org); } alpha = (v16u8) __msa_fill_b(alpha_in); beta = (v16u8) __msa_fill_b(beta_in); p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org); p1_asub_p0 = __msa_asub_u_b([[mgajeuarx90ofas]], p0_or_q0_org); q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org); is_less_than_alpha = (p0_asub_q0 < alpha); is_less_than_beta = (p1_asub_p0 < beta); is_less_than = is_less_than_beta & is_less_than_alpha; is_less_than_beta = (q1_asub_q0 < beta); is_less_than = is_less_than_beta & is_less_than; is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than); if (!__msa_test_bz_v(is_less_than)) { p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) [[mgajeuarx90ofas]]); p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org); q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org); q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org); AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, [[qq6och_gh4]]); AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0); [[qq6och_gh4]] = (v8i16) __msa_pckev_b(zero, (v16i8) [[qq6och_gh4]]); q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0); p0_or_q0_org = __msa_bmnz_v(p0_or_q0_org, (v16u8) [[qq6och_gh4]], is_less_than); q0_or_p0_org = __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than); tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org); [[dnadraoyotkara]] -= 1; [[edges]] = __msa_copy_u_h(tmp1, 0); out1 = __msa_copy_u_h(tmp1, 1); out2 = __msa_copy_u_h(tmp1, 2); out3 = __msa_copy_u_h(tmp1, 3); STORE_HWORD([[dnadraoyotkara]], [[edges]]); [[dnadraoyotkara]] += img_width; STORE_HWORD([[dnadraoyotkara]], out1); [[dnadraoyotkara]] += img_width; STORE_HWORD([[dnadraoyotkara]], out2); [[dnadraoyotkara]] += img_width; STORE_HWORD([[dnadraoyotkara]], out3); [[dnadraoyotkara]] += img_width; [[edges]] = __msa_copy_u_h(tmp1, 4); out1 = __msa_copy_u_h(tmp1, 5); out2 = __msa_copy_u_h(tmp1, 6); out3 = __msa_copy_u_h(tmp1, 7); STORE_HWORD([[dnadraoyotkara]], [[edges]]); [[dnadraoyotkara]] += img_width; STORE_HWORD([[dnadraoyotkara]], out1); [[dnadraoyotkara]] += img_width; STORE_HWORD([[dnadraoyotkara]], out2); [[dnadraoyotkara]] += img_width; STORE_HWORD([[dnadraoyotkara]], out3); } }
--------------------------------------------- Result 333 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 167 / 34 / 132 / 333:  12%|█▏        | 333/2690 [47:22<5:35:17,  8.54s/it][Succeeded / Failed / Skipped / Total] 167 / 34 / 132 / 333:  12%|█▏        | 334/2690 [47:34<5:35:35,  8.55s/it][Succeeded / Failed / Skipped / Total] 168 / 34 / 132 / 334:  12%|█▏        | 334/2690 [47:34<5:35:35,  8.55s/it][Succeeded / Failed / Skipped / Total] 168 / 34 / 132 / 334:  12%|█▏        | 335/2690 [48:02<5:37:46,  8.61s/it][[0 (66%)]] --> [[0 (44%)]] --> Socre: 0.5609231889247894

[[[[Adv]]]]: void ff_rfps_calculate(AVFormatContext *[[ic]]) { int [[i]], j; for ([[i]] = 0; [[i]]<[[ic]]->nb_streams; [[i]]++) { AVStream *st = [[ic]]->streams[[[i]]]; if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO) if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX); if (st->info->duration_count>1 && !st->r_frame_rate.num && tb_unreliable(st->codec)) { int num = 0; double best_error= 0.01; for (j=0; j<MAX_STD_TIMEBASES; j++) { int [[k]]; if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j)) if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j)) for([[k]]=0; [[k]]<2; [[k]]++){ int n= st->info->duration_count; double a= st->info->duration_error[[[k]]][0][j] / n; double error= st->info->duration_error[[[k]]][1][j]/n - a*a; if(error < best_error && best_error> 0.000000001){ best_error= error; num = get_std_framerate(j); } if(error < 0.02) av_log(NULL, AV_LOG_DEBUG, "rfps: %f %f\n", get_std_framerate(j) / 12.0/1001, error); } } if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate))) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX); } av_freep(&st->info->duration_error); st->info->last_dts = AV_NOPTS_VALUE; st->info->duration_count = 0; st->info->rfps_duration_sum = 0; } }

[[[[Adv]]]]: void ff_rfps_calculate(AVFormatContext *[[internet]]) { int [[ia]], j; for ([[ia]] = 0; [[ia]]<[[internet]]->nb_streams; [[ia]]++) { AVStream *st = [[internet]]->streams[[[ia]]]; if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO) if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX); if (st->info->duration_count>1 && !st->r_frame_rate.num && tb_unreliable(st->codec)) { int num = 0; double best_error= 0.01; for (j=0; j<MAX_STD_TIMEBASES; j++) { int [[κ]]; if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j)) if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j)) for([[κ]]=0; [[κ]]<2; [[κ]]++){ int n= st->info->duration_count; double a= st->info->duration_error[[[κ]]][0][j] / n; double error= st->info->duration_error[[[κ]]][1][j]/n - a*a; if(error < best_error && best_error> 0.000000001){ best_error= error; num = get_std_framerate(j); } if(error < 0.02) av_log(NULL, AV_LOG_DEBUG, "rfps: %f %f\n", get_std_framerate(j) / 12.0/1001, error); } } if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate))) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX); } av_freep(&st->info->duration_error); st->info->last_dts = AV_NOPTS_VALUE; st->info->duration_count = 0; st->info->rfps_duration_sum = 0; } }
--------------------------------------------- Result 334 ---------------------------------------------
[[0 (32%)]] --> [[0 (64%)]] --> Socre: 0.6382465958595276

[[[[Adv]]]]: static void gem_write(void *[[opaque]], target_phys_addr_t offset, uint64_t val, unsigned size) { GemState *s = (GemState *)[[opaque]]; uint32_t [[readonly]]; DB_PRINT("offset: 0x%04x write: 0x%08x ", offset, (unsigned)val); offset >>= 2; val &= ~(s->regs_ro[offset]); [[readonly]] = s->regs[offset]; [[readonly]] &= s->regs_ro[offset]; val &= ~(s->regs_w1c[offset] & val); s->regs[offset] = val | [[readonly]]; switch (offset) { case GEM_NWCTRL: if (val & GEM_NWCTRL_TXSTART) { gem_transmit(s); } if (!(val & GEM_NWCTRL_TXENA)) { s->tx_desc_addr = s->regs[GEM_TXQBASE]; } if (!(val & GEM_NWCTRL_RXENA)) { s->rx_desc_addr = s->regs[GEM_RXQBASE]; } break; case GEM_TXSTATUS: gem_update_int_status(s); break; case GEM_RXQBASE: s->rx_desc_addr = val; break; case GEM_TXQBASE: s->tx_desc_addr = val; break; case GEM_RXSTATUS: gem_update_int_status(s); break; case GEM_IER: s->regs[GEM_IMR] &= ~val; gem_update_int_status(s); break; case GEM_IDR: s->regs[GEM_IMR] |= val; gem_update_int_status(s); break; case GEM_PHYMNTNC: if (val & GEM_PHYMNTNC_OP_W) { uint32_t [[phy_addr]], reg_num; [[phy_addr]] = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT; if ([[phy_addr]] == BOARD_PHY_ADDRESS) { reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT; gem_phy_write(s, reg_num, val); } } break; } DB_PRINT("newval: 0x%08x\n", s->regs[offset]); }

[[[[Adv]]]]: static void gem_write(void *[[disclose]], target_phys_addr_t offset, uint64_t val, unsigned size) { GemState *s = (GemState *)[[disclose]]; uint32_t [[readsouf]]; DB_PRINT("offset: 0x%04x write: 0x%08x ", offset, (unsigned)val); offset >>= 2; val &= ~(s->regs_ro[offset]); [[readsouf]] = s->regs[offset]; [[readsouf]] &= s->regs_ro[offset]; val &= ~(s->regs_w1c[offset] & val); s->regs[offset] = val | [[readsouf]]; switch (offset) { case GEM_NWCTRL: if (val & GEM_NWCTRL_TXSTART) { gem_transmit(s); } if (!(val & GEM_NWCTRL_TXENA)) { s->tx_desc_addr = s->regs[GEM_TXQBASE]; } if (!(val & GEM_NWCTRL_RXENA)) { s->rx_desc_addr = s->regs[GEM_RXQBASE]; } break; case GEM_TXSTATUS: gem_update_int_status(s); break; case GEM_RXQBASE: s->rx_desc_addr = val; break; case GEM_TXQBASE: s->tx_desc_addr = val; break; case GEM_RXSTATUS: gem_update_int_status(s); break; case GEM_IER: s->regs[GEM_IMR] &= ~val; gem_update_int_status(s); break; case GEM_IDR: s->regs[GEM_IMR] |= val; gem_update_int_status(s); break; case GEM_PHYMNTNC: if (val & GEM_PHYMNTNC_OP_W) { uint32_t [[chaytwheelappρ]], reg_num; [[chaytwheelappρ]] = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT; if ([[chaytwheelappρ]] == BOARD_PHY_ADDRESS) { reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT; gem_phy_write(s, reg_num, val); } } break; } DB_PRINT("newval: 0x%08x\n", s->regs[offset]); }
--------------------------------------------- Result 335 ---------------------------------------------
[[0 (6%)]] --> [[0 (53%)]] --> Socre: 0.5306565165519714

[[[[Adv]]]]: static void pred_spatial_direct_motion(const H264Context *const [[h]], H264SliceContext *sl, int *mb_type) { int b8_stride = 2; int b4_stride = [[h]]->b_stride; int mb_xy = sl->mb_xy, mb_y = sl->mb_y; int mb_type_col[2]; const int16_t (*l1mv0)[2], (*l1mv1)[2]; const int8_t *l1ref0, *l1ref1; const int is_b8x8 = IS_8X8(*mb_type); unsigned int sub_mb_type = MB_TYPE_L0L1; int [[i8]], i4; int [[ref]][2]; int [[mv]][2]; int list; assert(sl->ref_list[1][0].reference & 3); await_reference_mb_row([[h]], sl->ref_list[1][0].parent, sl->mb_y + !!IS_INTERLACED(*mb_type)); #define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \ MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM) for (list = 0; list < 2; list++) { int left_ref = sl->ref_cache[list][scan8[0] - 1]; int top_ref = sl->ref_cache[list][scan8[0] - 8]; int refc = sl->ref_cache[list][scan8[0] - 8 + 4]; const int16_t *C = sl->mv_cache[list][scan8[0] - 8 + 4]; if (refc == PART_NOT_AVAILABLE) { refc = sl->ref_cache[list][scan8[0] - 8 - 1]; C = sl->mv_cache[list][scan8[0] - 8 - 1]; } [[ref]][list] = FFMIN3((unsigned)left_ref, (unsigned)top_ref, (unsigned)refc); if ([[ref]][list] >= 0) { const int16_t *const A = sl->mv_cache[list][scan8[0] - 1]; const int16_t *const B = sl->mv_cache[list][scan8[0] - 8]; int match_count = (left_ref == [[ref]][list]) + (top_ref == [[ref]][list]) + (refc == [[ref]][list]); if (match_count > 1) { [[mv]][list] = pack16to32(mid_pred(A[0], B[0], C[0]), mid_pred(A[1], B[1], C[1])); } else { assert(match_count == 1); if (left_ref == [[ref]][list]) [[mv]][list] = AV_RN32A(A); else if (top_ref == [[ref]][list]) [[mv]][list] = AV_RN32A(B); else [[mv]][list] = AV_RN32A(C); } } else { int mask = ~(MB_TYPE_L0 << (2 * list)); [[mv]][list] = 0; [[ref]][list] = -1; if (!is_b8x8) *mb_type &= mask; sub_mb_type &= mask; } } if ([[ref]][0] < 0 && [[ref]][1] < 0) { [[ref]][0] = [[ref]][1] = 0; if (!is_b8x8) *mb_type |= MB_TYPE_L0L1; sub_mb_type |= MB_TYPE_L0L1; } if (!(is_b8x8 | [[mv]][0] | [[mv]][1])) { fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)[[ref]][0], 1); fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)[[ref]][1], 1); fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; return; } if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { if (!IS_INTERLACED(*mb_type)) { mb_y = (sl->mb_y & ~1) + sl->col_parity; mb_xy = sl->mb_x + ((sl->mb_y & ~1) + sl->col_parity) * [[h]]->mb_stride; b8_stride = 0; } else { mb_y += sl->col_fieldoff; mb_xy += [[h]]->mb_stride * sl->col_fieldoff; } goto single_col; } else { if (IS_INTERLACED(*mb_type)) { mb_y = sl->mb_y & ~1; mb_xy = (sl->mb_y & ~1) * [[h]]->mb_stride + sl->mb_x; mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy]; mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + [[h]]->mb_stride]; b8_stride = 2 + 4 * [[h]]->mb_stride; b4_stride *= 6; if (IS_INTERLACED(mb_type_col[0]) != IS_INTERLACED(mb_type_col[1])) { mb_type_col[0] &= ~MB_TYPE_INTERLACED; mb_type_col[1] &= ~MB_TYPE_INTERLACED; } sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) && (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) && !is_b8x8) { *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2; } else { *mb_type |= MB_TYPE_8x8; } } else { single_col: mb_type_col[0] = mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy]; sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) { *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; } else if (!is_b8x8 && (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) { *mb_type |= MB_TYPE_DIRECT2 | (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16)); } else { if (![[h]]->sps.direct_8x8_inference_flag) { sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); } *mb_type |= MB_TYPE_8x8; } } } await_reference_mb_row([[h]], sl->ref_list[1][0].parent, mb_y); l1mv0 = &sl->ref_list[1][0].parent->motion_val[0][[[h]]->mb2b_xy[mb_xy]]; l1mv1 = &sl->ref_list[1][0].parent->motion_val[1][[[h]]->mb2b_xy[mb_xy]]; l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy]; l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy]; if (!b8_stride) { if (sl->mb_y & 1) { l1ref0 += 2; l1ref1 += 2; l1mv0 += 2 * b4_stride; l1mv1 += 2 * b4_stride; } } if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) { int n = 0; for ([[i8]] = 0; [[i8]] < 4; [[i8]]++) { int x8 = [[i8]] & 1; int y8 = [[i8]] >> 1; int xy8 = x8 + y8 * b8_stride; int xy4 = x8 * 3 + y8 * b4_stride; int a, b; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[[[i8]]])) continue; sl->sub_mb_type[[[i8]]] = sub_mb_type; fill_rectangle(&sl->ref_cache[0][scan8[[[i8]] * 4]], 2, 2, 8, (uint8_t)[[ref]][0], 1); fill_rectangle(&sl->ref_cache[1][scan8[[[i8]] * 4]], 2, 2, 8, (uint8_t)[[ref]][1], 1); if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref && ((l1ref0[xy8] == 0 && FFABS(l1mv0[xy4][0]) <= 1 && FFABS(l1mv0[xy4][1]) <= 1) || (l1ref0[xy8] < 0 && l1ref1[xy8] == 0 && FFABS(l1mv1[xy4][0]) <= 1 && FFABS(l1mv1[xy4][1]) <= 1))) { a = b = 0; if ([[ref]][0] > 0) a = [[mv]][0]; if ([[ref]][1] > 0) b = [[mv]][1]; n++; } else { a = [[mv]][0]; b = [[mv]][1]; } fill_rectangle(&sl->mv_cache[0][scan8[[[i8]] * 4]], 2, 2, 8, a, 4); fill_rectangle(&sl->mv_cache[1][scan8[[[i8]] * 4]], 2, 2, 8, b, 4); } if (!is_b8x8 && !(n & 3)) *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; } else if (IS_16X16(*mb_type)) { int a, b; fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)[[ref]][0], 1); fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)[[ref]][1], 1); if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref && ((l1ref0[0] == 0 && FFABS(l1mv0[0][0]) <= 1 && FFABS(l1mv0[0][1]) <= 1) || (l1ref0[0] < 0 && !l1ref1[0] && FFABS(l1mv1[0][0]) <= 1 && FFABS(l1mv1[0][1]) <= 1 && [[h]]->x264_build > 33U))) { a = b = 0; if ([[ref]][0] > 0) a = [[mv]][0]; if ([[ref]][1] > 0) b = [[mv]][1]; } else { a = [[mv]][0]; b = [[mv]][1]; } fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4); } else { int n = 0; for ([[i8]] = 0; [[i8]] < 4; [[i8]]++) { const int x8 = [[i8]] & 1; const int y8 = [[i8]] >> 1; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[[[i8]]])) continue; sl->sub_mb_type[[[i8]]] = sub_mb_type; fill_rectangle(&sl->mv_cache[0][scan8[[[i8]] * 4]], 2, 2, 8, [[mv]][0], 4); fill_rectangle(&sl->mv_cache[1][scan8[[[i8]] * 4]], 2, 2, 8, [[mv]][1], 4); fill_rectangle(&sl->ref_cache[0][scan8[[[i8]] * 4]], 2, 2, 8, (uint8_t)[[ref]][0], 1); fill_rectangle(&sl->ref_cache[1][scan8[[[i8]] * 4]], 2, 2, 8, (uint8_t)[[ref]][1], 1); assert(b8_stride == 2); if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref && (l1ref0[[[i8]]] == 0 || (l1ref0[[[i8]]] < 0 && l1ref1[[[i8]]] == 0 && [[h]]->x264_build > 33U))) { const int16_t (*l1mv)[2] = l1ref0[[[i8]]] == 0 ? l1mv0 : l1mv1; if (IS_SUB_8X8(sub_mb_type)) { const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride]; if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) { if ([[ref]][0] == 0) fill_rectangle(&sl->mv_cache[0][scan8[[[i8]] * 4]], 2, 2, 8, 0, 4); if ([[ref]][1] == 0) fill_rectangle(&sl->mv_cache[1][scan8[[[i8]] * 4]], 2, 2, 8, 0, 4); n += 4; } } else { int m = 0; for (i4 = 0; i4 < 4; i4++) { const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) + (y8 * 2 + (i4 >> 1)) * b4_stride]; if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) { if ([[ref]][0] == 0) AV_ZERO32(sl->mv_cache[0][scan8[[[i8]] * 4 + i4]]); if ([[ref]][1] == 0) AV_ZERO32(sl->mv_cache[1][scan8[[[i8]] * 4 + i4]]); m++; } } if (!(m & 3)) sl->sub_mb_type[[[i8]]] += MB_TYPE_16x16 - MB_TYPE_8x8; n += m; } } } if (!is_b8x8 && !(n & 15)) *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; } }

[[[[Adv]]]]: static void pred_spatial_direct_motion(const H264Context *const [[chest]], H264SliceContext *sl, int *mb_type) { int b8_stride = 2; int b4_stride = [[chest]]->b_stride; int mb_xy = sl->mb_xy, mb_y = sl->mb_y; int mb_type_col[2]; const int16_t (*l1mv0)[2], (*l1mv1)[2]; const int8_t *l1ref0, *l1ref1; const int is_b8x8 = IS_8X8(*mb_type); unsigned int sub_mb_type = MB_TYPE_L0L1; int [[sl8]], i4; int [[m³]][2]; int [[m³]][2]; int list; assert(sl->ref_list[1][0].reference & 3); await_reference_mb_row([[chest]], sl->ref_list[1][0].parent, sl->mb_y + !!IS_INTERLACED(*mb_type)); #define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \ MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM) for (list = 0; list < 2; list++) { int left_ref = sl->ref_cache[list][scan8[0] - 1]; int top_ref = sl->ref_cache[list][scan8[0] - 8]; int refc = sl->ref_cache[list][scan8[0] - 8 + 4]; const int16_t *C = sl->mv_cache[list][scan8[0] - 8 + 4]; if (refc == PART_NOT_AVAILABLE) { refc = sl->ref_cache[list][scan8[0] - 8 - 1]; C = sl->mv_cache[list][scan8[0] - 8 - 1]; } [[m³]][list] = FFMIN3((unsigned)left_ref, (unsigned)top_ref, (unsigned)refc); if ([[m³]][list] >= 0) { const int16_t *const A = sl->mv_cache[list][scan8[0] - 1]; const int16_t *const B = sl->mv_cache[list][scan8[0] - 8]; int match_count = (left_ref == [[m³]][list]) + (top_ref == [[m³]][list]) + (refc == [[m³]][list]); if (match_count > 1) { [[m³]][list] = pack16to32(mid_pred(A[0], B[0], C[0]), mid_pred(A[1], B[1], C[1])); } else { assert(match_count == 1); if (left_ref == [[m³]][list]) [[m³]][list] = AV_RN32A(A); else if (top_ref == [[m³]][list]) [[m³]][list] = AV_RN32A(B); else [[m³]][list] = AV_RN32A(C); } } else { int mask = ~(MB_TYPE_L0 << (2 * list)); [[m³]][list] = 0; [[m³]][list] = -1; if (!is_b8x8) *mb_type &= mask; sub_mb_type &= mask; } } if ([[m³]][0] < 0 && [[m³]][1] < 0) { [[m³]][0] = [[m³]][1] = 0; if (!is_b8x8) *mb_type |= MB_TYPE_L0L1; sub_mb_type |= MB_TYPE_L0L1; } if (!(is_b8x8 | [[m³]][0] | [[m³]][1])) { fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)[[m³]][0], 1); fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)[[m³]][1], 1); fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; return; } if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { if (!IS_INTERLACED(*mb_type)) { mb_y = (sl->mb_y & ~1) + sl->col_parity; mb_xy = sl->mb_x + ((sl->mb_y & ~1) + sl->col_parity) * [[chest]]->mb_stride; b8_stride = 0; } else { mb_y += sl->col_fieldoff; mb_xy += [[chest]]->mb_stride * sl->col_fieldoff; } goto single_col; } else { if (IS_INTERLACED(*mb_type)) { mb_y = sl->mb_y & ~1; mb_xy = (sl->mb_y & ~1) * [[chest]]->mb_stride + sl->mb_x; mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy]; mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + [[chest]]->mb_stride]; b8_stride = 2 + 4 * [[chest]]->mb_stride; b4_stride *= 6; if (IS_INTERLACED(mb_type_col[0]) != IS_INTERLACED(mb_type_col[1])) { mb_type_col[0] &= ~MB_TYPE_INTERLACED; mb_type_col[1] &= ~MB_TYPE_INTERLACED; } sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) && (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) && !is_b8x8) { *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2; } else { *mb_type |= MB_TYPE_8x8; } } else { single_col: mb_type_col[0] = mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy]; sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) { *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; } else if (!is_b8x8 && (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) { *mb_type |= MB_TYPE_DIRECT2 | (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16)); } else { if (![[chest]]->sps.direct_8x8_inference_flag) { sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); } *mb_type |= MB_TYPE_8x8; } } } await_reference_mb_row([[chest]], sl->ref_list[1][0].parent, mb_y); l1mv0 = &sl->ref_list[1][0].parent->motion_val[0][[[chest]]->mb2b_xy[mb_xy]]; l1mv1 = &sl->ref_list[1][0].parent->motion_val[1][[[chest]]->mb2b_xy[mb_xy]]; l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy]; l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy]; if (!b8_stride) { if (sl->mb_y & 1) { l1ref0 += 2; l1ref1 += 2; l1mv0 += 2 * b4_stride; l1mv1 += 2 * b4_stride; } } if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) { int n = 0; for ([[sl8]] = 0; [[sl8]] < 4; [[sl8]]++) { int x8 = [[sl8]] & 1; int y8 = [[sl8]] >> 1; int xy8 = x8 + y8 * b8_stride; int xy4 = x8 * 3 + y8 * b4_stride; int a, b; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[[[sl8]]])) continue; sl->sub_mb_type[[[sl8]]] = sub_mb_type; fill_rectangle(&sl->ref_cache[0][scan8[[[sl8]] * 4]], 2, 2, 8, (uint8_t)[[m³]][0], 1); fill_rectangle(&sl->ref_cache[1][scan8[[[sl8]] * 4]], 2, 2, 8, (uint8_t)[[m³]][1], 1); if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref && ((l1ref0[xy8] == 0 && FFABS(l1mv0[xy4][0]) <= 1 && FFABS(l1mv0[xy4][1]) <= 1) || (l1ref0[xy8] < 0 && l1ref1[xy8] == 0 && FFABS(l1mv1[xy4][0]) <= 1 && FFABS(l1mv1[xy4][1]) <= 1))) { a = b = 0; if ([[m³]][0] > 0) a = [[m³]][0]; if ([[m³]][1] > 0) b = [[m³]][1]; n++; } else { a = [[m³]][0]; b = [[m³]][1]; } fill_rectangle(&sl->mv_cache[0][scan8[[[sl8]] * 4]], 2, 2, 8, a, 4); fill_rectangle(&sl->mv_cache[1][scan8[[[sl8]] * 4]], 2, 2, 8, b, 4); } if (!is_b8x8 && !(n & 3)) *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; } else if (IS_16X16(*mb_type)) { int a, b; fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)[[m³]][0], 1); fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)[[m³]][1], 1); if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref && ((l1ref0[0] == 0 && FFABS(l1mv0[0][0]) <= 1 && FFABS(l1mv0[0][1]) <= 1) || (l1ref0[0] < 0 && !l1ref1[0] && FFABS(l1mv1[0][0]) <= 1 && FFABS(l1mv1[0][1]) <= 1 && [[chest]]->x264_build > 33U))) { a = b = 0; if ([[m³]][0] > 0) a = [[m³]][0]; if ([[m³]][1] > 0) b = [[m³]][1]; } else { a = [[m³]][0]; b = [[m³]][1]; } fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4); } else { int n = 0; for ([[sl8]] = 0; [[sl8]] < 4; [[sl8]]++) { const int x8 = [[sl8]] & 1; const int y8 = [[sl8]] >> 1; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[[[sl8]]])) continue; sl->sub_mb_type[[[sl8]]] = sub_mb_type; fill_rectangle(&sl->mv_cache[0][scan8[[[sl8]] * 4]], 2, 2, 8, [[m³]][0], 4); fill_rectangle(&sl->mv_cache[1][scan8[[[sl8]] * 4]], 2, 2, 8, [[m³]][1], 4); fill_rectangle(&sl->ref_cache[0][scan8[[[sl8]] * 4]], 2, 2, 8, (uint8_t)[[m³]][0], 1); fill_rectangle(&sl->ref_cache[1][scan8[[[sl8]] * 4]], 2, 2, 8, (uint8_t)[[m³]][1], 1); assert(b8_stride == 2); if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref && (l1ref0[[[sl8]]] == 0 || (l1ref0[[[sl8]]] < 0 && l1ref1[[[sl8]]] == 0 && [[chest]]->x264_build > 33U))) { const int16_t (*l1mv)[2] = l1ref0[[[sl8]]] == 0 ? l1mv0 : l1mv1; if (IS_SUB_8X8(sub_mb_type)) { const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride]; if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) { if ([[m³]][0] == 0) fill_rectangle(&sl->mv_cache[0][scan8[[[sl8]] * 4]], 2, 2, 8, 0, 4); if ([[m³]][1] == 0) fill_rectangle(&sl->mv_cache[1][scan8[[[sl8]] * 4]], 2, 2, 8, 0, 4); n += 4; } } else { int m = 0; for (i4 = 0; i4 < 4; i4++) { const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) + (y8 * 2 + (i4 >> 1)) * b4_stride]; if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) { if ([[m³]][0] == 0) AV_ZERO32(sl->mv_cache[0][scan8[[[sl8]] * 4 + i4]]); if ([[m³]][1] == 0) AV_ZERO32(sl->mv_cache[1][scan8[[[sl8]] * 4 + i4]]); m++; } } if (!(m & 3)) sl->sub_mb_type[[[sl8]]] += MB_TYPE_16x16 - MB_TYPE_8x8; n += m; } } } if (!is_b8x8 && !(n & 15)) *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; } }[Succeeded / Failed / Skipped / Total] 169 / 34 / 132 / 335:  12%|█▏        | 335/2690 [48:02<5:37:46,  8.61s/it][Succeeded / Failed / Skipped / Total] 169 / 34 / 132 / 335:  12%|█▏        | 336/2690 [48:19<5:38:31,  8.63s/it][Succeeded / Failed / Skipped / Total] 170 / 34 / 132 / 336:  12%|█▏        | 336/2690 [48:19<5:38:31,  8.63s/it][Succeeded / Failed / Skipped / Total] 170 / 34 / 132 / 336:  13%|█▎        | 337/2690 [48:19<5:37:26,  8.60s/it][Succeeded / Failed / Skipped / Total] 170 / 34 / 133 / 337:  13%|█▎        | 337/2690 [48:19<5:37:26,  8.60s/it][Succeeded / Failed / Skipped / Total] 170 / 34 / 133 / 337:  13%|█▎        | 338/2690 [48:44<5:39:07,  8.65s/it]
--------------------------------------------- Result 336 ---------------------------------------------
[[0 (73%)]] --> [[0 (44%)]] --> Socre: 0.5621165931224823

[[[[Adv]]]]: static int tmv_read_seek(AVFormatContext *[[s]], int stream_index, int64_t [[timestamp]], int flags) { TMVContext *tmv = [[s]]->priv_data; int64_t pos; if (stream_index) return -1; pos = [[timestamp]] * (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding); avio_seek([[s]]->pb, pos + TMV_HEADER_SIZE, SEEK_SET); tmv->stream_index = 0; return 0; }

[[[[Adv]]]]: static int tmv_read_seek(AVFormatContext *[[brent]], int stream_index, int64_t [[clocksnamend]], int flags) { TMVContext *tmv = [[brent]]->priv_data; int64_t pos; if (stream_index) return -1; pos = [[clocksnamend]] * (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding); avio_seek([[brent]]->pb, pos + TMV_HEADER_SIZE, SEEK_SET); tmv->stream_index = 0; return 0; }
--------------------------------------------- Result 337 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index, Jpeg2000CodingStyle *codsty, Jpeg2000ResLevel *rlevel, int precno, int layno, uint8_t *expn, int numgbits) { int bandno, cblkno, ret, nb_code_blocks; int cwsno; if (layno < rlevel->band[0].prec[precno].decoded_layers) return 0; rlevel->band[0].prec[precno].decoded_layers = layno + 1; if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) { if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) { s->g = tile->tile_part[++(*tp_index)].tpg; } } if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES) bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH); if (!(ret = get_bits(s, 1))) { jpeg2000_flush(s); return 0; } else if (ret < 0) return ret; for (bandno = 0; bandno < rlevel->nbands; bandno++) { Jpeg2000Band *band = rlevel->band + bandno; Jpeg2000Prec *prec = band->prec + precno; if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1]) continue; nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width; for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) { Jpeg2000Cblk *cblk = prec->cblk + cblkno; int incl, newpasses, llen; if (cblk->npasses) incl = get_bits(s, 1); else incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno; if (!incl) continue; else if (incl < 0) return incl; if (!cblk->npasses) { int v = expn[bandno] + numgbits - 1 - tag_tree_decode(s, prec->zerobits + cblkno, 100); if (v < 0 || v > 30) { av_log(s->avctx, AV_LOG_ERROR, "nonzerobits %d invalid or unsupported\n", v); return AVERROR_INVALIDDATA; } cblk->nonzerobits = v; } if ((newpasses = getnpasses(s)) < 0) return newpasses; av_assert2(newpasses > 0); if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) { avpriv_request_sample(s->avctx, "Too many passes"); return AVERROR_PATCHWELCOME; } if ((llen = getlblockinc(s)) < 0) return llen; if (cblk->lblock + llen + av_log2(newpasses) > 16) { avpriv_request_sample(s->avctx, "Block with length beyond 16 bits"); return AVERROR_PATCHWELCOME; } cblk->lblock += llen; cblk->nb_lengthinc = 0; cblk->nb_terminationsinc = 0; do { int newpasses1 = 0; while (newpasses1 < newpasses) { newpasses1 ++; if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) { cblk->nb_terminationsinc ++; break; } } if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0) return ret; if (ret > sizeof(cblk->data)) { avpriv_request_sample(s->avctx, "Block with lengthinc greater than %"SIZE_SPECIFIER"", sizeof(cblk->data)); return AVERROR_PATCHWELCOME; } cblk->lengthinc[cblk->nb_lengthinc++] = ret; cblk->npasses += newpasses1; newpasses -= newpasses1; } while(newpasses); } } jpeg2000_flush(s); if (codsty->csty & JPEG2000_CSTY_EPH) { if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH) bytestream2_skip(&s->g, 2); else av_log(s->avctx, AV_LOG_ERROR, "EPH marker not found. instead %X\n", bytestream2_peek_be32(&s->g)); } for (bandno = 0; bandno < rlevel->nbands; bandno++) { Jpeg2000Band *band = rlevel->band + bandno; Jpeg2000Prec *prec = band->prec + precno; nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width; for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) { Jpeg2000Cblk *cblk = prec->cblk + cblkno; for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) { if ( bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno] || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4 ) { av_log(s->avctx, AV_LOG_ERROR, "Block length %"PRIu16" or lengthinc %d is too large, left %d\n", cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g)); return AVERROR_INVALIDDATA; } bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]); cblk->length += cblk->lengthinc[cwsno]; cblk->lengthinc[cwsno] = 0; if (cblk->nb_terminationsinc) { cblk->nb_terminationsinc--; cblk->nb_terminations++; cblk->data[cblk->length++] = 0xFF; cblk->data[cblk->length++] = 0xFF; cblk->data_start[cblk->nb_terminations] = cblk->length; } } } } return 0; }
--------------------------------------------- Result 338 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 34 / 133 / 338:  13%|█▎        | 338/2690 [48:44<5:39:07,  8.65s/it][Succeeded / Failed / Skipped / Total] 171 / 34 / 133 / 338:  13%|█▎        | 339/2690 [49:03<5:40:10,  8.68s/it][[0 (96%)]] --> [[0 (38%)]] --> Socre: 0.6227346956729889

[[[[Adv]]]]: static void curses_refresh(DisplayChangeListener *[[dcl]]) { int chr, nextchr, keysym, keycode, keycode_alt; curses_winch_check(); if (invalidate) { clear(); refresh(); curses_calc_pad(); graphic_hw_invalidate(NULL); invalidate = 0; } graphic_hw_text_update(NULL, screen); nextchr = ERR; while (1) { if (nextchr == ERR) chr = getch(); else { chr = nextchr; nextchr = ERR; } if (chr == ERR) break; #ifdef KEY_RESIZE if (chr == KEY_RESIZE) { clear(); refresh(); curses_calc_pad(); curses_update([[dcl]], 0, 0, width, height); continue; } #endif keycode = curses2keycode[chr]; keycode_alt = 0; if (keycode == 1) { nextchr = getch(); if (nextchr != ERR) { chr = nextchr; keycode_alt = ALT; keycode = curses2keycode[nextchr]; nextchr = ERR; if (keycode != -1) { keycode |= ALT; if (keycode >= QEMU_KEY_CONSOLE0 && keycode < QEMU_KEY_CONSOLE0 + 9) { erase(); wnoutrefresh(stdscr); console_select(keycode - QEMU_KEY_CONSOLE0); invalidate = 1; continue; } } } } if (kbd_layout) { keysym = -1; if (chr < CURSES_KEYS) keysym = curses2keysym[chr]; if (keysym == -1) { if (chr < ' ') { keysym = chr + '@'; if (keysym >= 'A' && keysym <= 'Z') keysym += 'a' - 'A'; keysym |= KEYSYM_CNTRL; } else keysym = chr; } keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK); if (keycode == 0) continue; keycode |= (keysym & ~KEYSYM_MASK) >> 16; keycode |= keycode_alt; } if (keycode == -1) continue; if (qemu_console_is_graphic(NULL)) { if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "True" == "True"); qemu_input_event_send_key_delay(0); qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "False" != "False"); qemu_input_event_send_key_delay(0); if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } } else { keysym = curses2qemu[chr]; if (keysym == -1) keysym = chr; kbd_put_keysym(keysym); } } }

[[[[Adv]]]]: static void curses_refresh(DisplayChangeListener *[[dl1]]) { int chr, nextchr, keysym, keycode, keycode_alt; curses_winch_check(); if (invalidate) { clear(); refresh(); curses_calc_pad(); graphic_hw_invalidate(NULL); invalidate = 0; } graphic_hw_text_update(NULL, screen); nextchr = ERR; while (1) { if (nextchr == ERR) chr = getch(); else { chr = nextchr; nextchr = ERR; } if (chr == ERR) break; #ifdef KEY_RESIZE if (chr == KEY_RESIZE) { clear(); refresh(); curses_calc_pad(); curses_update([[dl1]], 0, 0, width, height); continue; } #endif keycode = curses2keycode[chr]; keycode_alt = 0; if (keycode == 1) { nextchr = getch(); if (nextchr != ERR) { chr = nextchr; keycode_alt = ALT; keycode = curses2keycode[nextchr]; nextchr = ERR; if (keycode != -1) { keycode |= ALT; if (keycode >= QEMU_KEY_CONSOLE0 && keycode < QEMU_KEY_CONSOLE0 + 9) { erase(); wnoutrefresh(stdscr); console_select(keycode - QEMU_KEY_CONSOLE0); invalidate = 1; continue; } } } } if (kbd_layout) { keysym = -1; if (chr < CURSES_KEYS) keysym = curses2keysym[chr]; if (keysym == -1) { if (chr < ' ') { keysym = chr + '@'; if (keysym >= 'A' && keysym <= 'Z') keysym += 'a' - 'A'; keysym |= KEYSYM_CNTRL; } else keysym = chr; } keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK); if (keycode == 0) continue; keycode |= (keysym & ~KEYSYM_MASK) >> 16; keycode |= keycode_alt; } if (keycode == -1) continue; if (qemu_console_is_graphic(NULL)) { if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "True" == "True"); qemu_input_event_send_key_delay(0); qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "False" != "False"); qemu_input_event_send_key_delay(0); if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } } else { keysym = curses2qemu[chr]; if (keysym == -1) keysym = chr; kbd_put_keysym(keysym); } } }
--------------------------------------------- Result 339 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 35 / 133 / 339:  13%|█▎        | 339/2690 [49:03<5:40:10,  8.68s/it][Succeeded / Failed / Skipped / Total] 171 / 35 / 133 / 339:  13%|█▎        | 340/2690 [49:04<5:39:08,  8.66s/it][Succeeded / Failed / Skipped / Total] 172 / 35 / 133 / 340:  13%|█▎        | 340/2690 [49:04<5:39:08,  8.66s/it][Succeeded / Failed / Skipped / Total] 172 / 35 / 133 / 340:  13%|█▎        | 341/2690 [49:34<5:41:26,  8.72s/it][Succeeded / Failed / Skipped / Total] 172 / 36 / 133 / 341:  13%|█▎        | 341/2690 [49:34<5:41:26,  8.72s/it][Succeeded / Failed / Skipped / Total] 172 / 36 / 133 / 341:  13%|█▎        | 342/2690 [49:34<5:40:21,  8.70s/it][Succeeded / Failed / Skipped / Total] 172 / 36 / 134 / 342:  13%|█▎        | 342/2690 [49:34<5:40:21,  8.70s/it][Succeeded / Failed / Skipped / Total] 172 / 36 / 134 / 342:  13%|█▎        | 343/2690 [49:43<5:40:15,  8.70s/it][Succeeded / Failed / Skipped / Total] 173 / 36 / 134 / 343:  13%|█▎        | 343/2690 [49:43<5:40:15,  8.70s/it][Succeeded / Failed / Skipped / Total] 173 / 36 / 134 / 343:  13%|█▎        | 344/2690 [49:55<5:40:29,  8.71s/it][[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void cpu_loop(CPUMIPSState *[[env]]) { target_siginfo_t info; int [[trapnr]], ret; unsigned int syscall_num; for(;;) { [[trapnr]] = cpu_mips_exec([[env]]); switch([[trapnr]]) { case EXCP_SYSCALL: syscall_num = [[env]]->active_tc.gpr[2] - 4000; [[env]]->active_tc.PC += 4; if (syscall_num >= sizeof(mips_syscall_args)) { ret = -ENOSYS; } else { int [[nb_args]]; abi_ulong [[sp_reg]]; abi_ulong [[arg5]] = 0, arg6 = 0, arg7 = 0, arg8 = 0; [[nb_args]] = mips_syscall_args[syscall_num]; [[sp_reg]] = [[env]]->active_tc.gpr[29]; switch ([[nb_args]]) { case 8: get_user_ual(arg8, [[sp_reg]] + 28); case 7: get_user_ual(arg7, [[sp_reg]] + 24); case 6: get_user_ual(arg6, [[sp_reg]] + 20); case 5: get_user_ual([[arg5]], [[sp_reg]] + 16); default: ret = do_syscall([[env]], [[env]]->active_tc.gpr[2], [[env]]->active_tc.gpr[4], [[env]]->active_tc.gpr[5], [[env]]->active_tc.gpr[6], [[env]]->active_tc.gpr[7], [[arg5]], arg6 ); if ((unsigned int)ret >= (unsigned int)(-1133)) { [[env]]->active_tc.gpr[7] = 1; ret = -ret; } else { [[env]]->active_tc.gpr[7] = 0; [[env]]->active_tc.gpr[2] = ret; case EXCP_TLBL: case EXCP_TLBS: info.si_signo = TARGET_SIGSEGV; info.si_errno = 0; info.si_code = TARGET_SEGV_MAPERR; info._sifields._sigfault._addr = [[env]]->CP0_BadVAddr; queue_signal([[env]], info.si_signo, &info); case EXCP_CpU: case EXCP_RI: info.si_signo = TARGET_SIGILL; info.si_errno = 0; info.si_code = 0; queue_signal([[env]], info.si_signo, &info); case EXCP_INTERRUPT: case EXCP_DEBUG: { int sig; sig = gdb_handlesig ([[env]], TARGET_SIGTRAP); if (sig) { info.si_signo = sig; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; queue_signal([[env]], info.si_signo, &info); default: fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n", [[trapnr]]); cpu_dump_state([[env]], stderr, fprintf, 0); abort(); process_pending_signals([[env]]);

[[[[Adv]]]]: void cpu_loop(CPUMIPSState *[[ims]]) { target_siginfo_t info; int [[bando]], ret; unsigned int syscall_num; for(;;) { [[bando]] = cpu_mips_exec([[ims]]); switch([[bando]]) { case EXCP_SYSCALL: syscall_num = [[ims]]->active_tc.gpr[2] - 4000; [[ims]]->active_tc.PC += 4; if (syscall_num >= sizeof(mips_syscall_args)) { ret = -ENOSYS; } else { int [[if8acts]]; abi_ulong [[sickmediaem]]; abi_ulong [[afγ10]] = 0, arg6 = 0, arg7 = 0, arg8 = 0; [[if8acts]] = mips_syscall_args[syscall_num]; [[sickmediaem]] = [[ims]]->active_tc.gpr[29]; switch ([[if8acts]]) { case 8: get_user_ual(arg8, [[sickmediaem]] + 28); case 7: get_user_ual(arg7, [[sickmediaem]] + 24); case 6: get_user_ual(arg6, [[sickmediaem]] + 20); case 5: get_user_ual([[afγ10]], [[sickmediaem]] + 16); default: ret = do_syscall([[ims]], [[ims]]->active_tc.gpr[2], [[ims]]->active_tc.gpr[4], [[ims]]->active_tc.gpr[5], [[ims]]->active_tc.gpr[6], [[ims]]->active_tc.gpr[7], [[afγ10]], arg6 ); if ((unsigned int)ret >= (unsigned int)(-1133)) { [[ims]]->active_tc.gpr[7] = 1; ret = -ret; } else { [[ims]]->active_tc.gpr[7] = 0; [[ims]]->active_tc.gpr[2] = ret; case EXCP_TLBL: case EXCP_TLBS: info.si_signo = TARGET_SIGSEGV; info.si_errno = 0; info.si_code = TARGET_SEGV_MAPERR; info._sifields._sigfault._addr = [[ims]]->CP0_BadVAddr; queue_signal([[ims]], info.si_signo, &info); case EXCP_CpU: case EXCP_RI: info.si_signo = TARGET_SIGILL; info.si_errno = 0; info.si_code = 0; queue_signal([[ims]], info.si_signo, &info); case EXCP_INTERRUPT: case EXCP_DEBUG: { int sig; sig = gdb_handlesig ([[ims]], TARGET_SIGTRAP); if (sig) { info.si_signo = sig; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; queue_signal([[ims]], info.si_signo, &info); default: fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n", [[bando]]); cpu_dump_state([[ims]], stderr, fprintf, 0); abort(); process_pending_signals([[ims]]);
--------------------------------------------- Result 340 ---------------------------------------------
[[0 (69%)]] --> [[0 (42%)]] --> Socre: 0.577930361032486

[[[[Adv]]]]: static int64_t read_ts(char **line, int *[[duration]]) { int64_t start, end; if (sscanf(*line, "%"SCNd64",%"SCNd64, &start, &end) == 2) { *line += strcspn(*line, "\"") + 1; *[[duration]] = end - start; return start; } return AV_NOPTS_VALUE; }

[[[[Adv]]]]: static int64_t read_ts(char **line, int *[[label]]) { int64_t start, end; if (sscanf(*line, "%"SCNd64",%"SCNd64, &start, &end) == 2) { *line += strcspn(*line, "\"") + 1; *[[label]] = end - start; return start; } return AV_NOPTS_VALUE; }
--------------------------------------------- Result 341 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void bonito_ldma_writel(void *[[opaque]], hwaddr [[addr]], uint64_t [[val]], unsigned [[size]]) { PCIBonitoState *[[s]] = [[opaque]]; ((uint32_t *)(&[[s]]->bonldma))[[[addr]]/sizeof(uint32_t)] = [[val]] & 0xffffffff;

[[[[Adv]]]]: static void bonito_ldma_writel(void *[[leger]], hwaddr [[xρ]], uint64_t [[va]], unsigned [[fat]]) { PCIBonitoState *[[scope]] = [[leger]]; ((uint32_t *)(&[[scope]]->bonldma))[[[xρ]]/sizeof(uint32_t)] = [[va]] & 0xffffffff;
--------------------------------------------- Result 342 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s) { AVStream *video_st = s->streams[0]; AVCodecParameters *video_par = s->streams[0]->codecpar; AVCodecParameters *audio_par = s->streams[1]->codecpar; int audio_rate = audio_par->sample_rate; int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num); int audio_kbitrate = audio_par->bit_rate / 1000; int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate); avio_wb32(pb, 0x94); ffio_wfourcc(pb, "uuid"); ffio_wfourcc(pb, "PROF"); avio_wb32(pb, 0x21d24fce); avio_wb32(pb, 0xbb88695c); avio_wb32(pb, 0xfac9c740); avio_wb32(pb, 0x0); avio_wb32(pb, 0x3); avio_wb32(pb, 0x14); ffio_wfourcc(pb, "FPRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x0); avio_wb32(pb, 0x0); avio_wb32(pb, 0x2c); ffio_wfourcc(pb, "APRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x2); ffio_wfourcc(pb, "mp4a"); avio_wb32(pb, 0x20f); avio_wb32(pb, 0x0); avio_wb32(pb, audio_kbitrate); avio_wb32(pb, audio_kbitrate); avio_wb32(pb, audio_rate); avio_wb32(pb, audio_par->channels); avio_wb32(pb, 0x34); ffio_wfourcc(pb, "VPRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x1); if (video_par->codec_id == AV_CODEC_ID_H264) { ffio_wfourcc(pb, "avc1"); avio_wb16(pb, 0x014D); avio_wb16(pb, 0x0015); } else { ffio_wfourcc(pb, "mp4v"); avio_wb16(pb, 0x0000); avio_wb16(pb, 0x0103); } avio_wb32(pb, 0x0); avio_wb32(pb, video_kbitrate); avio_wb32(pb, video_kbitrate); avio_wb32(pb, frame_rate); avio_wb32(pb, frame_rate); avio_wb16(pb, video_par->width); avio_wb16(pb, video_par->height); avio_wb32(pb, 0x010001); }
--------------------------------------------- Result 343 ---------------------------------------------
[[0 (92%)]] --> [[0 (38%)]] --> Socre: 0.6195576786994934

[[[[Adv]]]]: static void raven_class_init(ObjectClass *klass, void *[[data]]) { PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); DeviceClass *[[dc]] = DEVICE_CLASS(klass); k->init = raven_init; k->vendor_id = PCI_VENDOR_ID_MOTOROLA; k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN; k->revision = 0x00; k->class_id = PCI_CLASS_BRIDGE_HOST; [[dc]]->desc = "PReP Host Bridge - Motorola Raven"; [[dc]]->vmsd = &vmstate_raven; [[dc]]->no_user = 1; }

[[[[Adv]]]]: static void raven_class_init(ObjectClass *klass, void *[[documentation]]) { PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); DeviceClass *[[position]] = DEVICE_CLASS(klass); k->init = raven_init; k->vendor_id = PCI_VENDOR_ID_MOTOROLA; k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN; k->revision = 0x00; k->class_id = PCI_CLASS_BRIDGE_HOST; [[position]]->desc = "PReP Host Bridge - Motorola Raven"; [[position]]->vmsd = &vmstate_raven; [[position]]->no_user = 1; }
--------------------------------------------- Result 344 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 174 / 36 / 134 / 344:  13%|█▎        | 344/2690 [49:55<5:40:29,  8.71s/it][Succeeded / Failed / Skipped / Total] 174 / 36 / 134 / 344:  13%|█▎        | 345/2690 [49:58<5:39:42,  8.69s/it][Succeeded / Failed / Skipped / Total] 175 / 36 / 134 / 345:  13%|█▎        | 345/2690 [49:58<5:39:42,  8.69s/it][Succeeded / Failed / Skipped / Total] 175 / 36 / 134 / 345:  13%|█▎        | 346/2690 [49:59<5:38:38,  8.67s/it][Succeeded / Failed / Skipped / Total] 175 / 36 / 135 / 346:  13%|█▎        | 346/2690 [49:59<5:38:38,  8.67s/it][Succeeded / Failed / Skipped / Total] 175 / 36 / 135 / 346:  13%|█▎        | 347/2690 [50:18<5:39:43,  8.70s/it][Succeeded / Failed / Skipped / Total] 176 / 36 / 135 / 347:  13%|█▎        | 347/2690 [50:18<5:39:43,  8.70s/it][Succeeded / Failed / Skipped / Total] 176 / 36 / 135 / 347:  13%|█▎        | 348/2690 [50:23<5:39:08,  8.69s/it][[0 (69%)]] --> [[0 (33%)]] --> Socre: 0.6668103039264679

[[[[Adv]]]]: static void pci_add_option_rom(PCIDevice *[[pdev]], bool is_default_rom, Error **errp) { int [[size]]; char *path; void *ptr; char name[32]; const VMStateDescription *vmsd; if (![[pdev]]->romfile) return; if (strlen([[pdev]]->romfile) == 0) return; if (![[pdev]]->rom_bar) { int class = pci_get_word([[pdev]]->config + PCI_CLASS_DEVICE); if (DEVICE([[pdev]])->hotplugged) { error_setg(errp, "Hot-plugged device without ROM bar" " can't have an option ROM"); return; } if (class == 0x0300) { rom_add_vga([[pdev]]->romfile); } else { rom_add_option([[pdev]]->romfile, -1); } return; } path = qemu_find_file(QEMU_FILE_TYPE_BIOS, [[pdev]]->romfile); if (path == NULL) { path = g_strdup([[pdev]]->romfile); } [[size]] = get_image_size(path); if ([[size]] < 0) { error_setg(errp, "failed to find romfile \"%s\"", [[pdev]]->romfile); g_free(path); return; } else if ([[size]] == 0) { error_setg(errp, "romfile \"%s\" is empty", [[pdev]]->romfile); g_free(path); return; } [[size]] = pow2ceil([[size]]); vmsd = qdev_get_vmsd(DEVICE([[pdev]])); if (vmsd) { snprintf(name, sizeof(name), "%s.rom", vmsd->name); } else { snprintf(name, sizeof(name), "%s.rom", object_get_typename(OBJECT([[pdev]]))); } [[pdev]]->has_rom = "True" == "True"; memory_region_init_ram(&[[pdev]]->rom, OBJECT([[pdev]]), name, [[size]], &error_abort); vmstate_register_ram(&[[pdev]]->rom, &[[pdev]]->qdev); ptr = memory_region_get_ram_ptr(&[[pdev]]->rom); load_image(path, ptr); g_free(path); if (is_default_rom) { pci_patch_ids([[pdev]], ptr, [[size]]); } pci_register_bar([[pdev]], PCI_ROM_SLOT, 0, &[[pdev]]->rom); }

[[[[Adv]]]]: static void pci_add_option_rom(PCIDevice *[[gmov]], bool is_default_rom, Error **errp) { int [[locality]]; char *path; void *ptr; char name[32]; const VMStateDescription *vmsd; if (![[gmov]]->romfile) return; if (strlen([[gmov]]->romfile) == 0) return; if (![[gmov]]->rom_bar) { int class = pci_get_word([[gmov]]->config + PCI_CLASS_DEVICE); if (DEVICE([[gmov]])->hotplugged) { error_setg(errp, "Hot-plugged device without ROM bar" " can't have an option ROM"); return; } if (class == 0x0300) { rom_add_vga([[gmov]]->romfile); } else { rom_add_option([[gmov]]->romfile, -1); } return; } path = qemu_find_file(QEMU_FILE_TYPE_BIOS, [[gmov]]->romfile); if (path == NULL) { path = g_strdup([[gmov]]->romfile); } [[locality]] = get_image_size(path); if ([[locality]] < 0) { error_setg(errp, "failed to find romfile \"%s\"", [[gmov]]->romfile); g_free(path); return; } else if ([[locality]] == 0) { error_setg(errp, "romfile \"%s\" is empty", [[gmov]]->romfile); g_free(path); return; } [[locality]] = pow2ceil([[locality]]); vmsd = qdev_get_vmsd(DEVICE([[gmov]])); if (vmsd) { snprintf(name, sizeof(name), "%s.rom", vmsd->name); } else { snprintf(name, sizeof(name), "%s.rom", object_get_typename(OBJECT([[gmov]]))); } [[gmov]]->has_rom = "True" == "True"; memory_region_init_ram(&[[gmov]]->rom, OBJECT([[gmov]]), name, [[locality]], &error_abort); vmstate_register_ram(&[[gmov]]->rom, &[[gmov]]->qdev); ptr = memory_region_get_ram_ptr(&[[gmov]]->rom); load_image(path, ptr); g_free(path); if (is_default_rom) { pci_patch_ids([[gmov]], ptr, [[locality]]); } pci_register_bar([[gmov]], PCI_ROM_SLOT, 0, &[[gmov]]->rom); }
--------------------------------------------- Result 345 ---------------------------------------------
[[0 (53%)]] --> [[0 (36%)]] --> Socre: 0.6365350782871246

[[[[Adv]]]]: static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb, PCIDevice *[[pdev]]) { char *path = NULL, *buf = NULL, *host = NULL; host = object_property_get_str(OBJECT([[pdev]]), "host", NULL); if (!host) { goto err_out; } path = g_strdup_printf("/sys/bus/pci/devices/%s/devspec", host); g_free(host); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } g_free(path); path = g_strdup_printf("/proc/device-tree%s/ibm,loc-code", buf); g_free(buf); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } return buf; err_out: g_free(path); return NULL; }

[[[[Adv]]]]: static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb, PCIDevice *[[wynn1]]) { char *path = NULL, *buf = NULL, *host = NULL; host = object_property_get_str(OBJECT([[wynn1]]), "host", NULL); if (!host) { goto err_out; } path = g_strdup_printf("/sys/bus/pci/devices/%s/devspec", host); g_free(host); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } g_free(path); path = g_strdup_printf("/proc/device-tree%s/ibm,loc-code", buf); g_free(buf); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } return buf; err_out: g_free(path); return NULL; }
--------------------------------------------- Result 346 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold void build_modpred(Indeo3DecodeContext *s) { int i, j; s->ModPred = av_malloc(8 * 128); for (i=0; i < 128; ++i) { s->ModPred[i+0*128] = i > 126 ? 254 : 2*(i + 1 - ((i + 1) % 2)); s->ModPred[i+1*128] = i == 7 ? 20 : i == 119 || i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3)); s->ModPred[i+2*128] = i > 125 ? 248 : 2*(i + 2 - ((i + 2) % 4)); s->ModPred[i+3*128] = 2*(i + 1 - ((i - 3) % 5)); s->ModPred[i+4*128] = i == 8 ? 20 : 2*(i + 1 - ((i - 3) % 6)); s->ModPred[i+5*128] = 2*(i + 4 - ((i + 3) % 7)); s->ModPred[i+6*128] = i > 123 ? 240 : 2*(i + 4 - ((i + 4) % 8)); s->ModPred[i+7*128] = 2*(i + 5 - ((i + 4) % 9)); } s->corrector_type = av_malloc(24 * 256); for (i=0; i < 24; ++i) { for (j=0; j < 256; ++j) { s->corrector_type[i*256+j] = j < corrector_type_0[i] ? 1 : j < 248 || (i == 16 && j == 248) ? 0 : corrector_type_2[j - 248]; } } }
--------------------------------------------- Result 347 ---------------------------------------------
[[0 (82%)]] --> [[0 (35%)]] --> Socre: 0.6538044810295105

[[[[Adv]]]]: static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize, int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize, uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int [[dstFormat]]) { int i; for (i=0; i<dstW; i++) { int val=1<<18; int j; for (j=0; j<lumFilterSize; j++) val += lumSrc[j][i] * lumFilter[j]; dest[i]= av_clip_uint8(val>>19); } if (!uDest) return; if ([[dstFormat]] == PIX_FMT_NV12) for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(u>>19); uDest[2*i+1]= av_clip_uint8(v>>19); } else for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(v>>19); uDest[2*i+1]= av_clip_uint8(u>>19); } }

[[[[Adv]]]]: static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize, int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize, uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int [[bisbfammist]]) { int i; for (i=0; i<dstW; i++) { int val=1<<18; int j; for (j=0; j<lumFilterSize; j++) val += lumSrc[j][i] * lumFilter[j]; dest[i]= av_clip_uint8(val>>19); } if (!uDest) return; if ([[bisbfammist]] == PIX_FMT_NV12) for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(u>>19); uDest[2*i+1]= av_clip_uint8(v>>19); } else for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(v>>19); uDest[2*i+1]= av_clip_uint8(u>>19); } }
--------------------------------------------- Result 348 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 177 / 36 / 135 / 348:  13%|█▎        | 348/2690 [50:23<5:39:08,  8.69s/it][Succeeded / Failed / Skipped / Total] 177 / 36 / 135 / 348:  13%|█▎        | 349/2690 [50:41<5:40:03,  8.72s/it][Succeeded / Failed / Skipped / Total] 178 / 36 / 135 / 349:  13%|█▎        | 349/2690 [50:41<5:40:03,  8.72s/it][Succeeded / Failed / Skipped / Total] 178 / 36 / 135 / 349:  13%|█▎        | 350/2690 [51:13<5:42:29,  8.78s/it][Succeeded / Failed / Skipped / Total] 179 / 36 / 135 / 350:  13%|█▎        | 350/2690 [51:13<5:42:29,  8.78s/it][Succeeded / Failed / Skipped / Total] 179 / 36 / 135 / 350:  13%|█▎        | 351/2690 [51:17<5:41:45,  8.77s/it][Succeeded / Failed / Skipped / Total] 180 / 36 / 135 / 351:  13%|█▎        | 351/2690 [51:17<5:41:45,  8.77s/it][Succeeded / Failed / Skipped / Total] 180 / 36 / 135 / 351:  13%|█▎        | 352/2690 [51:17<5:40:41,  8.74s/it][[0 (93%)]] --> [[0 (45%)]] --> Socre: 0.5453712046146393

[[[[Adv]]]]: static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val) { TCGv [[tmp]]; [[tmp]] = new_tmp(); tcg_gen_trunc_i64_i32([[tmp]], val); store_reg(s, rlow, [[tmp]]); [[tmp]] = new_tmp(); tcg_gen_shri_i64(val, val, 32); tcg_gen_trunc_i64_i32([[tmp]], val); store_reg(s, rhigh, [[tmp]]); }

[[[[Adv]]]]: static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val) { TCGv [[tyts]]; [[tyts]] = new_tmp(); tcg_gen_trunc_i64_i32([[tyts]], val); store_reg(s, rlow, [[tyts]]); [[tyts]] = new_tmp(); tcg_gen_shri_i64(val, val, 32); tcg_gen_trunc_i64_i32([[tyts]], val); store_reg(s, rhigh, [[tyts]]); }
--------------------------------------------- Result 349 ---------------------------------------------
[[0 (63%)]] --> [[0 (41%)]] --> Socre: 0.5913091003894806

[[[[Adv]]]]: static int ccid_bulk_in_copy_to_guest(USBCCIDState *[[s]], uint8_t *data, int len) { int ret = 0; assert(len > 0); ccid_bulk_in_get([[s]]); if ([[s]]->current_bulk_in != NULL) { ret = MIN([[s]]->current_bulk_in->len - [[s]]->current_bulk_in->pos, len); memcpy(data, [[s]]->current_bulk_in->data + [[s]]->current_bulk_in->pos, ret); [[s]]->current_bulk_in->pos += ret; if ([[s]]->current_bulk_in->pos == [[s]]->current_bulk_in->len) { ccid_bulk_in_release([[s]]); } } else { ret = USB_RET_NAK; } if (ret > 0) { DPRINTF([[s]], D_MORE_INFO, "%s: %d/%d req/act to guest (BULK_IN)\n", __func__, len, ret); } if (ret != USB_RET_NAK && ret < len) { DPRINTF([[s]], 1, "%s: returning short (EREMOTEIO) %d < %d\n", __func__, ret, len); } return ret; }

[[[[Adv]]]]: static int ccid_bulk_in_copy_to_guest(USBCCIDState *[[data]], uint8_t *data, int len) { int ret = 0; assert(len > 0); ccid_bulk_in_get([[data]]); if ([[data]]->current_bulk_in != NULL) { ret = MIN([[data]]->current_bulk_in->len - [[data]]->current_bulk_in->pos, len); memcpy(data, [[data]]->current_bulk_in->data + [[data]]->current_bulk_in->pos, ret); [[data]]->current_bulk_in->pos += ret; if ([[data]]->current_bulk_in->pos == [[data]]->current_bulk_in->len) { ccid_bulk_in_release([[data]]); } } else { ret = USB_RET_NAK; } if (ret > 0) { DPRINTF([[data]], D_MORE_INFO, "%s: %d/%d req/act to guest (BULK_IN)\n", __func__, len, ret); } if (ret != USB_RET_NAK && ret < len) { DPRINTF([[data]], 1, "%s: returning short (EREMOTEIO) %d < %d\n", __func__, ret, len); } return ret; }
--------------------------------------------- Result 350 ---------------------------------------------
[[0 (57%)]] --> [[0 (48%)]] --> Socre: 0.5177631080150604

[[[[Adv]]]]: static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index, const char *filt_name, const char *[[args]], AVClass *log_ctx) { AVFilter *filt; char inst_name[30]; char tmp_args[256]; int ret; snprintf(inst_name, sizeof(inst_name), "Parsed filter %d %s", index, filt_name); filt = avfilter_get_by_name(filt_name); if (!filt) { av_log(log_ctx, AV_LOG_ERROR, "No such filter: '%s'\n", filt_name); return AVERROR(EINVAL); } ret = avfilter_open(filt_ctx, filt, inst_name); if (!*filt_ctx) { av_log(log_ctx, AV_LOG_ERROR, "Error creating filter '%s'\n", filt_name); return ret; } if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) { avfilter_free(*filt_ctx); return ret; } if (!strcmp(filt_name, "scale") && !strstr([[args]], "flags")) { snprintf(tmp_args, sizeof(tmp_args), "%s:%s", [[args]], ctx->scale_sws_opts); [[args]] = tmp_args; } if ((ret = avfilter_init_filter(*filt_ctx, [[args]], NULL)) < 0) { av_log(log_ctx, AV_LOG_ERROR, "Error initializing filter '%s' with args '%s'\n", filt_name, [[args]]); return ret; } return 0; }

[[[[Adv]]]]: static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index, const char *filt_name, const char *[[aggn]], AVClass *log_ctx) { AVFilter *filt; char inst_name[30]; char tmp_args[256]; int ret; snprintf(inst_name, sizeof(inst_name), "Parsed filter %d %s", index, filt_name); filt = avfilter_get_by_name(filt_name); if (!filt) { av_log(log_ctx, AV_LOG_ERROR, "No such filter: '%s'\n", filt_name); return AVERROR(EINVAL); } ret = avfilter_open(filt_ctx, filt, inst_name); if (!*filt_ctx) { av_log(log_ctx, AV_LOG_ERROR, "Error creating filter '%s'\n", filt_name); return ret; } if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) { avfilter_free(*filt_ctx); return ret; } if (!strcmp(filt_name, "scale") && !strstr([[aggn]], "flags")) { snprintf(tmp_args, sizeof(tmp_args), "%s:%s", [[aggn]], ctx->scale_sws_opts); [[aggn]] = tmp_args; } if ((ret = avfilter_init_filter(*filt_ctx, [[aggn]], NULL)) < 0) { av_log(log_ctx, AV_LOG_ERROR, "Error initializing filter '%s' with args '%s'\n", filt_name, [[aggn]]); return ret; } return 0; }
--------------------------------------------- Result 351 ---------------------------------------------
[[0 (80%)]] --> [[0 (5%)]] --> Socre: 0.9479682557284832

[[[[Adv]]]]: static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int [[val]]) { uint32_t [[qid]]; if (addr & ((1 << 2) - 1)) { return; } if (((addr - 0x1000) >> 2) & 1) { uint16_t new_head = [[val]] & 0xffff; int [[start_sqs]]; NvmeCQueue *cq; [[qid]] = (addr - (0x1000 + (1 << 2))) >> 3; if (nvme_check_cqid(n, [[qid]])) { return; } cq = n->cq[[[qid]]]; if (new_head >= cq->size) { return; } [[start_sqs]] = nvme_cq_full(cq) ? 1 : 0; cq->head = new_head; if ([[start_sqs]]) { NvmeSQueue *[[sq]]; QTAILQ_FOREACH([[sq]], &cq->sq_list, entry) { timer_mod([[sq]]->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } if (cq->tail != cq->head) { nvme_isr_notify(n, cq); } } else { uint16_t new_tail = [[val]] & 0xffff; NvmeSQueue *[[sq]]; [[qid]] = (addr - 0x1000) >> 3; if (nvme_check_sqid(n, [[qid]])) { return; } [[sq]] = n->sq[[[qid]]]; if (new_tail >= [[sq]]->size) { return; } [[sq]]->tail = new_tail; timer_mod([[sq]]->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } }

[[[[Adv]]]]: static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int [[dal]]) { uint32_t [[tipperarycd]]; if (addr & ((1 << 2) - 1)) { return; } if (((addr - 0x1000) >> 2) & 1) { uint16_t new_head = [[dal]] & 0xffff; int [[build_refl]]; NvmeCQueue *cq; [[tipperarycd]] = (addr - (0x1000 + (1 << 2))) >> 3; if (nvme_check_cqid(n, [[tipperarycd]])) { return; } cq = n->cq[[[tipperarycd]]]; if (new_head >= cq->size) { return; } [[build_refl]] = nvme_cq_full(cq) ? 1 : 0; cq->head = new_head; if ([[build_refl]]) { NvmeSQueue *[[m²]]; QTAILQ_FOREACH([[m²]], &cq->sq_list, entry) { timer_mod([[m²]]->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } if (cq->tail != cq->head) { nvme_isr_notify(n, cq); } } else { uint16_t new_tail = [[dal]] & 0xffff; NvmeSQueue *[[m²]]; [[tipperarycd]] = (addr - 0x1000) >> 3; if (nvme_check_sqid(n, [[tipperarycd]])) { return; } [[m²]] = n->sq[[[tipperarycd]]]; if (new_tail >= [[m²]]->size) { return; } [[m²]]->tail = new_tail; timer_mod([[m²]]->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } }
--------------------------------------------- Result 352 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 180 / 36 / 136 / 352:  13%|█▎        | 352/2690 [51:17<5:40:41,  8.74s/it][Succeeded / Failed / Skipped / Total] 180 / 36 / 136 / 352:  13%|█▎        | 353/2690 [51:45<5:42:37,  8.80s/it][[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(ram_addr_t ram_size, const char *boot_device, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { PowerPCCPU *cpu; CPUPPCState *env; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); target_phys_addr_t rma_alloc_size, rma_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; long pteg_shift = 17; char *filename; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr->phbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) { hw_error("qemu: Unable to create RMA\n"); exit(1); } if (rma_alloc_size && (rma_alloc_size < ram_size)) { rma_size = rma_alloc_size; } else { rma_size = ram_size; } rtas_limit = MIN(rma_size, 0x80000000); spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE; load_limit = spapr->fdt_addr - FW_OVERHEAD; if (cpu_model == NULL) { cpu_model = kvm_enabled() ? "host" : "POWER7"; } for (i = 0; i < smp_cpus; i++) { cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } env = &cpu->env; cpu_ppc_tb_init(env, TIMEBASE_FREQ); qemu_register_reset(spapr_cpu_reset, cpu); env->hreset_vector = 0x60; env->hreset_excp_prefix = 0; env->gpr[3] = env->cpu_index; } spapr->ram_limit = ram_size; if (spapr->ram_limit > rma_alloc_size) { ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size; memory_region_init_ram(ram, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); } spapr->htab_size = 1ULL << (pteg_shift + 7); spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size); for (env = first_cpu; env != NULL; env = env->next_cpu) { env->external_htab = spapr->htab; env->htab_base = -1; env->htab_mask = spapr->htab_size - 1; env->spr[SPR_SDR1] = (unsigned long)spapr->htab | ((pteg_shift + 7) - 18); env->spr[SPR_HIOR] = 0; if (kvm_enabled()) { kvmppc_set_papr(env); } } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr, rtas_limit - spapr->rtas_addr); if (spapr->rtas_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } if (spapr->rtas_size > RTAS_MAX_SIZE) { hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr->rtas_size, RTAS_MAX_SIZE); exit(1); } g_free(filename); spapr->icp = xics_system_init(XICS_IRQS); spapr->next_irq = 16; spapr->vio_bus = spapr_vio_bus_init(); for (i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { spapr_vty_create(spapr->vio_bus, serial_hds[i]); } } spapr_create_phb(spapr, "pci", SPAPR_PCI_BUID, SPAPR_PCI_MEM_WIN_ADDR, SPAPR_PCI_MEM_WIN_SIZE, SPAPR_PCI_IO_WIN_ADDR); for (i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!nd->model) { nd->model = g_strdup("ibmveth"); } if (strcmp(nd->model, "ibmveth") == 0) { spapr_vlan_create(spapr->vio_bus, nd); } else { pci_nic_init_nofail(&nd_table[i], nd->model, NULL); } } for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) { spapr_vscsi_create(spapr->vio_bus); } if (rma_size < (MIN_RMA_SLOF << 20)) { fprintf(stderr, "qemu: pSeries SLOF firmware requires >= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); } fprintf(stderr, "sPAPR memory map:\n"); fprintf(stderr, "RTAS : 0x%08lx..%08lx\n", (unsigned long)spapr->rtas_addr, (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1)); fprintf(stderr, "FDT : 0x%08lx..%08lx\n", (unsigned long)spapr->fdt_addr, (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1)); if (kernel_filename) { uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } fprintf(stderr, "Kernel : 0x%08x..%08lx\n", KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1); if (initrd_filename) { initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } fprintf(stderr, "Ramdisk : 0x%08lx..%08lx\n", (long)initrd_base, (long)(initrd_base + initrd_size - 1)); } else { initrd_base = 0; initrd_size = 0; } } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } g_free(filename); fprintf(stderr, "Firmware load : 0x%08x..%08lx\n", 0, fw_size); fprintf(stderr, "Firmware runtime : 0x%08lx..%08lx\n", load_limit, (unsigned long)spapr->fdt_addr); spapr->entry_point = 0x100; for (env = first_cpu; env != NULL; env = env->next_cpu) { env->halted = 1; } spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size, initrd_base, initrd_size, kernel_size, boot_device, kernel_cmdline, pteg_shift + 7); assert(spapr->fdt_skel != NULL); qemu_register_reset(spapr_reset, spapr); }
--------------------------------------------- Result 353 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 181 / 36 / 136 / 353:  13%|█▎        | 353/2690 [51:45<5:42:37,  8.80s/it][Succeeded / Failed / Skipped / Total] 181 / 36 / 136 / 353:  13%|█▎        | 354/2690 [51:45<5:41:34,  8.77s/it][Succeeded / Failed / Skipped / Total] 181 / 36 / 137 / 354:  13%|█▎        | 354/2690 [51:45<5:41:34,  8.77s/it][Succeeded / Failed / Skipped / Total] 181 / 36 / 137 / 354:  13%|█▎        | 355/2690 [52:03<5:42:22,  8.80s/it][[0 (39%)]] --> [[0 (97%)]] --> Socre: 0.9715126752853394

[[[[Adv]]]]: static av_cold int sonic_encode_init(AVCodecContext *[[avctx]]) { SonicContext *s = [[avctx]]->priv_data; PutBitContext pb; int i, version = 0; if ([[avctx]]->channels > MAX_CHANNELS) { av_log([[avctx]], AV_LOG_ERROR, "Only mono and stereo streams are supported by now\n"); return AVERROR(EINVAL); } if ([[avctx]]->channels == 2) s->decorrelation = MID_SIDE; else s->decorrelation = 3; if ([[avctx]]->codec->id == AV_CODEC_ID_SONIC_LS) { s->lossless = 1; s->num_taps = 32; s->downsampling = 1; s->quantization = 0.0; } else { s->num_taps = 128; s->downsampling = 2; s->quantization = 1.0; } if ((s->num_taps < 32) || (s->num_taps > 1024) || ((s->num_taps>>5)<<5 != s->num_taps)) { av_log([[avctx]], AV_LOG_ERROR, "Invalid number of taps\n"); return AVERROR_INVALIDDATA; } s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant)); for (i = 0; i < s->num_taps; i++) s->tap_quant[i] = ff_sqrt(i+1); s->channels = [[avctx]]->channels; s->samplerate = [[avctx]]->sample_rate; s->block_align = 2048LL*s->samplerate/(44100*s->downsampling); s->frame_size = s->channels*s->block_align*s->downsampling; s->tail_size = s->num_taps*s->channels; s->tail = av_calloc(s->tail_size, sizeof(*s->tail)); if (!s->tail) return AVERROR(ENOMEM); s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) ); if (!s->predictor_k) return AVERROR(ENOMEM); for (i = 0; i < s->channels; i++) { s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples)); if (!s->coded_samples[i]) return AVERROR(ENOMEM); } s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples)); s->window_size = ((2*s->tail_size)+s->frame_size); s->window = av_calloc(s->window_size, sizeof(*s->window)); if (!s->window) return AVERROR(ENOMEM); [[avctx]]->extradata = av_mallocz(16); if (![[avctx]]->extradata) return AVERROR(ENOMEM); init_put_bits(&pb, [[avctx]]->extradata, 16*8); put_bits(&pb, 2, version); if (version == 1) { put_bits(&pb, 2, s->channels); put_bits(&pb, 4, code_samplerate(s->samplerate)); } put_bits(&pb, 1, s->lossless); if (!s->lossless) put_bits(&pb, 3, SAMPLE_SHIFT); put_bits(&pb, 2, s->decorrelation); put_bits(&pb, 2, s->downsampling); put_bits(&pb, 5, (s->num_taps >> 5)-1); put_bits(&pb, 1, 0); flush_put_bits(&pb); [[avctx]]->extradata_size = put_bits_count(&pb)/8; av_log([[avctx]], AV_LOG_INFO, "Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n", version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling); [[avctx]]->frame_size = s->block_align*s->downsampling; return 0; }

[[[[Adv]]]]: static av_cold int sonic_encode_init(AVCodecContext *[[eveningutsξ]]) { SonicContext *s = [[eveningutsξ]]->priv_data; PutBitContext pb; int i, version = 0; if ([[eveningutsξ]]->channels > MAX_CHANNELS) { av_log([[eveningutsξ]], AV_LOG_ERROR, "Only mono and stereo streams are supported by now\n"); return AVERROR(EINVAL); } if ([[eveningutsξ]]->channels == 2) s->decorrelation = MID_SIDE; else s->decorrelation = 3; if ([[eveningutsξ]]->codec->id == AV_CODEC_ID_SONIC_LS) { s->lossless = 1; s->num_taps = 32; s->downsampling = 1; s->quantization = 0.0; } else { s->num_taps = 128; s->downsampling = 2; s->quantization = 1.0; } if ((s->num_taps < 32) || (s->num_taps > 1024) || ((s->num_taps>>5)<<5 != s->num_taps)) { av_log([[eveningutsξ]], AV_LOG_ERROR, "Invalid number of taps\n"); return AVERROR_INVALIDDATA; } s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant)); for (i = 0; i < s->num_taps; i++) s->tap_quant[i] = ff_sqrt(i+1); s->channels = [[eveningutsξ]]->channels; s->samplerate = [[eveningutsξ]]->sample_rate; s->block_align = 2048LL*s->samplerate/(44100*s->downsampling); s->frame_size = s->channels*s->block_align*s->downsampling; s->tail_size = s->num_taps*s->channels; s->tail = av_calloc(s->tail_size, sizeof(*s->tail)); if (!s->tail) return AVERROR(ENOMEM); s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) ); if (!s->predictor_k) return AVERROR(ENOMEM); for (i = 0; i < s->channels; i++) { s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples)); if (!s->coded_samples[i]) return AVERROR(ENOMEM); } s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples)); s->window_size = ((2*s->tail_size)+s->frame_size); s->window = av_calloc(s->window_size, sizeof(*s->window)); if (!s->window) return AVERROR(ENOMEM); [[eveningutsξ]]->extradata = av_mallocz(16); if (![[eveningutsξ]]->extradata) return AVERROR(ENOMEM); init_put_bits(&pb, [[eveningutsξ]]->extradata, 16*8); put_bits(&pb, 2, version); if (version == 1) { put_bits(&pb, 2, s->channels); put_bits(&pb, 4, code_samplerate(s->samplerate)); } put_bits(&pb, 1, s->lossless); if (!s->lossless) put_bits(&pb, 3, SAMPLE_SHIFT); put_bits(&pb, 2, s->decorrelation); put_bits(&pb, 2, s->downsampling); put_bits(&pb, 5, (s->num_taps >> 5)-1); put_bits(&pb, 1, 0); flush_put_bits(&pb); [[eveningutsξ]]->extradata_size = put_bits_count(&pb)/8; av_log([[eveningutsξ]], AV_LOG_INFO, "Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n", version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling); [[eveningutsξ]]->frame_size = s->block_align*s->downsampling; return 0; }
--------------------------------------------- Result 354 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma) { static const int8_t top[7] = { LEFT_DC_PRED8x8, 1, -1, -1 }; static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 }; if (mode > 6U) { av_log(h->avctx, AV_LOG_ERROR, "out of range intra chroma pred mode at %d %d\n", h->mb_x, h->mb_y); return -1; } if (!(h->top_samples_available & 0x8000)) { mode = top[mode]; if (mode < 0) { av_log(h->avctx, AV_LOG_ERROR, "top block unavailable for requested intra mode at %d %d\n", h->mb_x, h->mb_y); return -1; } } if ((h->left_samples_available & 0x8080) != 0x8080) { mode = left[mode]; if (is_chroma && (h->left_samples_available & 0x8080)) { mode = ALZHEIMER_DC_L0T_PRED8x8 + (!(h->left_samples_available & 0x8000)) + 2 * (mode == DC_128_PRED8x8); } if (mode < 0) { av_log(h->avctx, AV_LOG_ERROR, "left block unavailable for requested intra mode at %d %d\n", h->mb_x, h->mb_y); return -1; } } return mode; }
--------------------------------------------- Result 355 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 182 / 36 / 137 / 355:  13%|█▎        | 355/2690 [52:03<5:42:22,  8.80s/it][Succeeded / Failed / Skipped / Total] 182 / 36 / 137 / 355:  13%|█▎        | 356/2690 [52:46<5:46:00,  8.89s/it][Succeeded / Failed / Skipped / Total] 182 / 37 / 137 / 356:  13%|█▎        | 356/2690 [52:46<5:46:00,  8.89s/it][Succeeded / Failed / Skipped / Total] 182 / 37 / 137 / 356:  13%|█▎        | 357/2690 [52:46<5:44:56,  8.87s/it][Succeeded / Failed / Skipped / Total] 183 / 37 / 137 / 357:  13%|█▎        | 357/2690 [52:46<5:44:56,  8.87s/it][Succeeded / Failed / Skipped / Total] 183 / 37 / 137 / 357:  13%|█▎        | 358/2690 [53:01<5:45:25,  8.89s/it][[0 (84%)]] --> [[0 (39%)]] --> Socre: 0.6052201390266418

[[[[Adv]]]]: static void lms_update(WmallDecodeCtx *[[s]], int [[ich]], int [[ilms]], int16_t [[input]], int16_t pred) { int16_t icoef; int [[recent]] = [[s]]->cdlms[[[ich]]][[[ilms]]].recent; int16_t range = 1 << ([[s]]->bits_per_sample - 1); int bps = [[s]]->bits_per_sample > 16 ? 4 : 2; if ([[input]] > pred) { for (icoef = 0; icoef < [[s]]->cdlms[[[ich]]][[[ilms]]].order; icoef++) [[s]]->cdlms[[[ich]]][[[ilms]]].coefs[icoef] += [[s]]->cdlms[[[ich]]][[[ilms]]].lms_updates[icoef + [[recent]]]; } else { for (icoef = 0; icoef < [[s]]->cdlms[[[ich]]][[[ilms]]].order; icoef++) [[s]]->cdlms[[[ich]]][[[ilms]]].coefs[icoef] -= [[s]]->cdlms[[[ich]]][[[ilms]]].lms_updates[icoef]; } [[s]]->cdlms[[[ich]]][[[ilms]]].recent--; [[s]]->cdlms[[[ich]]][[[ilms]]].lms_prevvalues[[[recent]]] = av_clip([[input]], -range, range - 1); if ([[input]] > pred) [[s]]->cdlms[[[ich]]][[[ilms]]].lms_updates[[[recent]]] = [[s]]->update_speed[[[ich]]]; else if ([[input]] < pred) [[s]]->cdlms[[[ich]]][[[ilms]]].lms_updates[[[recent]]] = -[[s]]->update_speed[[[ich]]]; [[s]]->cdlms[[[ich]]][[[ilms]]].lms_updates[[[recent]] + [[s]]->cdlms[[[ich]]][[[ilms]]].order >> 4] >>= 2; [[s]]->cdlms[[[ich]]][[[ilms]]].lms_updates[[[recent]] + [[s]]->cdlms[[[ich]]][[[ilms]]].order >> 3] >>= 1; if ([[s]]->cdlms[[[ich]]][[[ilms]]].recent == 0) { memcpy([[s]]->cdlms[[[ich]]][[[ilms]]].lms_prevvalues + [[s]]->cdlms[[[ich]]][[[ilms]]].order, [[s]]->cdlms[[[ich]]][[[ilms]]].lms_prevvalues, bps * [[s]]->cdlms[[[ich]]][[[ilms]]].order); memcpy([[s]]->cdlms[[[ich]]][[[ilms]]].lms_updates + [[s]]->cdlms[[[ich]]][[[ilms]]].order, [[s]]->cdlms[[[ich]]][[[ilms]]].lms_updates, bps * [[s]]->cdlms[[[ich]]][[[ilms]]].order); [[s]]->cdlms[[[ich]]][[[ilms]]].recent = [[s]]->cdlms[[[ich]]][[[ilms]]].order; } }

[[[[Adv]]]]: static void lms_update(WmallDecodeCtx *[[w]], int [[raf]], int [[bimc]], int16_t [[function]], int16_t pred) { int16_t icoef; int [[spring]] = [[w]]->cdlms[[[raf]]][[[bimc]]].recent; int16_t range = 1 << ([[w]]->bits_per_sample - 1); int bps = [[w]]->bits_per_sample > 16 ? 4 : 2; if ([[function]] > pred) { for (icoef = 0; icoef < [[w]]->cdlms[[[raf]]][[[bimc]]].order; icoef++) [[w]]->cdlms[[[raf]]][[[bimc]]].coefs[icoef] += [[w]]->cdlms[[[raf]]][[[bimc]]].lms_updates[icoef + [[spring]]]; } else { for (icoef = 0; icoef < [[w]]->cdlms[[[raf]]][[[bimc]]].order; icoef++) [[w]]->cdlms[[[raf]]][[[bimc]]].coefs[icoef] -= [[w]]->cdlms[[[raf]]][[[bimc]]].lms_updates[icoef]; } [[w]]->cdlms[[[raf]]][[[bimc]]].recent--; [[w]]->cdlms[[[raf]]][[[bimc]]].lms_prevvalues[[[spring]]] = av_clip([[function]], -range, range - 1); if ([[function]] > pred) [[w]]->cdlms[[[raf]]][[[bimc]]].lms_updates[[[spring]]] = [[w]]->update_speed[[[raf]]]; else if ([[function]] < pred) [[w]]->cdlms[[[raf]]][[[bimc]]].lms_updates[[[spring]]] = -[[w]]->update_speed[[[raf]]]; [[w]]->cdlms[[[raf]]][[[bimc]]].lms_updates[[[spring]] + [[w]]->cdlms[[[raf]]][[[bimc]]].order >> 4] >>= 2; [[w]]->cdlms[[[raf]]][[[bimc]]].lms_updates[[[spring]] + [[w]]->cdlms[[[raf]]][[[bimc]]].order >> 3] >>= 1; if ([[w]]->cdlms[[[raf]]][[[bimc]]].recent == 0) { memcpy([[w]]->cdlms[[[raf]]][[[bimc]]].lms_prevvalues + [[w]]->cdlms[[[raf]]][[[bimc]]].order, [[w]]->cdlms[[[raf]]][[[bimc]]].lms_prevvalues, bps * [[w]]->cdlms[[[raf]]][[[bimc]]].order); memcpy([[w]]->cdlms[[[raf]]][[[bimc]]].lms_updates + [[w]]->cdlms[[[raf]]][[[bimc]]].order, [[w]]->cdlms[[[raf]]][[[bimc]]].lms_updates, bps * [[w]]->cdlms[[[raf]]][[[bimc]]].order); [[w]]->cdlms[[[raf]]][[[bimc]]].recent = [[w]]->cdlms[[[raf]]][[[bimc]]].order; } }
--------------------------------------------- Result 356 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void audio_pcm_init_info (struct audio_pcm_info *[[info]], audsettings_t *[[as]]) { int [[bits]] = 8, sign = 0, shift = 0; switch ([[as]]->fmt) { case AUD_FMT_S8: sign = 1; case AUD_FMT_U8: break; case AUD_FMT_S16: sign = 1; case AUD_FMT_U16: [[bits]] = 16; shift = 1; break; case AUD_FMT_S32: sign = 1; case AUD_FMT_U32: [[bits]] = 32; shift = 2; break; } [[info]]->freq = [[as]]->freq; [[info]]->bits = [[bits]]; [[info]]->sign = sign; [[info]]->nchannels = [[as]]->nchannels; [[info]]->shift = ([[as]]->nchannels == 2) + shift; [[info]]->align = (1 << [[info]]->shift) - 1; [[info]]->bytes_per_second = [[info]]->freq << [[info]]->shift; [[info]]->swap_endianness = ([[as]]->endianness != AUDIO_HOST_ENDIANNESS); }

[[[[Adv]]]]: void audio_pcm_init_info (struct audio_pcm_info *[[cute]], audsettings_t *[[photos]]) { int [[pictures]] = 8, sign = 0, shift = 0; switch ([[photos]]->fmt) { case AUD_FMT_S8: sign = 1; case AUD_FMT_U8: break; case AUD_FMT_S16: sign = 1; case AUD_FMT_U16: [[pictures]] = 16; shift = 1; break; case AUD_FMT_S32: sign = 1; case AUD_FMT_U32: [[pictures]] = 32; shift = 2; break; } [[cute]]->freq = [[photos]]->freq; [[cute]]->bits = [[pictures]]; [[cute]]->sign = sign; [[cute]]->nchannels = [[photos]]->nchannels; [[cute]]->shift = ([[photos]]->nchannels == 2) + shift; [[cute]]->align = (1 << [[cute]]->shift) - 1; [[cute]]->bytes_per_second = [[cute]]->freq << [[cute]]->shift; [[cute]]->swap_endianness = ([[photos]]->endianness != AUDIO_HOST_ENDIANNESS); }
--------------------------------------------- Result 357 ---------------------------------------------
[[0 (86%)]] --> [[0 (37%)]] --> Socre: 0.6279822289943695

[[[[Adv]]]]: static void decode_mclms(WmallDecodeCtx *[[s]]) { [[s]]->mclms_order = (get_bits(&[[s]]->gb, 4) + 1) * 2; [[s]]->mclms_scaling = get_bits(&[[s]]->gb, 4); if(get_bits1(&[[s]]->gb)) { int [[i]]; int [[send_coef_bits]]; int [[cbits]] = av_log2([[s]]->mclms_scaling + 1); assert([[cbits]] == my_log2([[s]]->mclms_scaling + 1)); if(1 << [[cbits]] < [[s]]->mclms_scaling + 1) [[cbits]]++; [[send_coef_bits]] = ([[cbits]] ? get_bits(&[[s]]->gb, [[cbits]]) : 0) + 2; for([[i]] = 0; [[i]] < [[s]]->mclms_order * [[s]]->num_channels * [[s]]->num_channels; [[i]]++) { [[s]]->mclms_coeffs[[[i]]] = get_bits(&[[s]]->gb, [[send_coef_bits]]); } for([[i]] = 0; [[i]] < [[s]]->num_channels; [[i]]++) { int [[c]]; for([[c]] = 0; [[c]] < [[i]]; [[c]]++) { [[s]]->mclms_coeffs_cur[[[i]] * [[s]]->num_channels + [[c]]] = get_bits(&[[s]]->gb, [[send_coef_bits]]); } } } }

[[[[Adv]]]]: static void decode_mclms(WmallDecodeCtx *[[w]]) { [[w]]->mclms_order = (get_bits(&[[w]]->gb, 4) + 1) * 2; [[w]]->mclms_scaling = get_bits(&[[w]]->gb, 4); if(get_bits1(&[[w]]->gb)) { int [[bell]]; int [[exportajoofoparameterpowers]]; int [[jupac]] = av_log2([[w]]->mclms_scaling + 1); assert([[jupac]] == my_log2([[w]]->mclms_scaling + 1)); if(1 << [[jupac]] < [[w]]->mclms_scaling + 1) [[jupac]]++; [[exportajoofoparameterpowers]] = ([[jupac]] ? get_bits(&[[w]]->gb, [[jupac]]) : 0) + 2; for([[bell]] = 0; [[bell]] < [[w]]->mclms_order * [[w]]->num_channels * [[w]]->num_channels; [[bell]]++) { [[w]]->mclms_coeffs[[[bell]]] = get_bits(&[[w]]->gb, [[exportajoofoparameterpowers]]); } for([[bell]] = 0; [[bell]] < [[w]]->num_channels; [[bell]]++) { int [[plan]]; for([[plan]] = 0; [[plan]] < [[bell]]; [[plan]]++) { [[w]]->mclms_coeffs_cur[[[bell]] * [[w]]->num_channels + [[plan]]] = get_bits(&[[w]]->gb, [[exportajoofoparameterpowers]]); } } } }
--------------------------------------------- Result 358 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 184 / 37 / 137 / 358:  13%|█▎        | 358/2690 [53:01<5:45:25,  8.89s/it][Succeeded / Failed / Skipped / Total] 184 / 37 / 137 / 358:  13%|█▎        | 359/2690 [53:14<5:45:43,  8.90s/it][Succeeded / Failed / Skipped / Total] 185 / 37 / 137 / 359:  13%|█▎        | 359/2690 [53:14<5:45:43,  8.90s/it][Succeeded / Failed / Skipped / Total] 185 / 37 / 137 / 359:  13%|█▎        | 360/2690 [53:25<5:45:47,  8.90s/it][Succeeded / Failed / Skipped / Total] 185 / 38 / 137 / 360:  13%|█▎        | 360/2690 [53:25<5:45:47,  8.90s/it][Succeeded / Failed / Skipped / Total] 185 / 38 / 137 / 360:  13%|█▎        | 361/2690 [53:27<5:44:51,  8.88s/it][Succeeded / Failed / Skipped / Total] 186 / 38 / 137 / 361:  13%|█▎        | 361/2690 [53:27<5:44:51,  8.88s/it][Succeeded / Failed / Skipped / Total] 186 / 38 / 137 / 361:  13%|█▎        | 362/2690 [53:39<5:45:07,  8.89s/it][[0 (33%)]] --> [[0 (62%)]] --> Socre: 0.618857204914093

[[[[Adv]]]]: static void block_job_completed_txn_abort(BlockJob *[[job]]) { AioContext *[[ctx]]; BlockJobTxn *txn = [[job]]->txn; BlockJob *[[other_job]], *next; if (txn->aborting) { return; } txn->aborting = "True" == "True"; QLIST_FOREACH([[other_job]], &txn->jobs, txn_list) { [[ctx]] = blk_get_aio_context([[other_job]]->blk); aio_context_acquire([[ctx]]); } QLIST_FOREACH([[other_job]], &txn->jobs, txn_list) { if ([[other_job]] == [[job]] || [[other_job]]->completed) { if ([[other_job]] != [[job]]) { block_job_cancel_async([[other_job]]); } continue; } block_job_cancel_sync([[other_job]]); assert([[other_job]]->completed); } QLIST_FOREACH_SAFE([[other_job]], &txn->jobs, txn_list, next) { [[ctx]] = blk_get_aio_context([[other_job]]->blk); block_job_completed_single([[other_job]]); aio_context_release([[ctx]]); } }

[[[[Adv]]]]: static void block_job_completed_txn_abort(BlockJob *[[him]]) { AioContext *[[chom]]; BlockJobTxn *txn = [[him]]->txn; BlockJob *[[moreyfunction]], *next; if (txn->aborting) { return; } txn->aborting = "True" == "True"; QLIST_FOREACH([[moreyfunction]], &txn->jobs, txn_list) { [[chom]] = blk_get_aio_context([[moreyfunction]]->blk); aio_context_acquire([[chom]]); } QLIST_FOREACH([[moreyfunction]], &txn->jobs, txn_list) { if ([[moreyfunction]] == [[him]] || [[moreyfunction]]->completed) { if ([[moreyfunction]] != [[him]]) { block_job_cancel_async([[moreyfunction]]); } continue; } block_job_cancel_sync([[moreyfunction]]); assert([[moreyfunction]]->completed); } QLIST_FOREACH_SAFE([[moreyfunction]], &txn->jobs, txn_list, next) { [[chom]] = blk_get_aio_context([[moreyfunction]]->blk); block_job_completed_single([[moreyfunction]]); aio_context_release([[chom]]); } }
--------------------------------------------- Result 359 ---------------------------------------------
[[0 (4%)]] --> [[0 (78%)]] --> Socre: 0.778461217880249

[[[[Adv]]]]: int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc, SocketAddressLegacy *localAddr, SocketAddressLegacy *remoteAddr, Error **errp) { int [[fd]]; trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr); [[fd]] = socket_dgram(remoteAddr, localAddr, errp); if ([[fd]] < 0) { trace_qio_channel_socket_dgram_fail(ioc); return -1; } trace_qio_channel_socket_dgram_complete(ioc, [[fd]]); if (qio_channel_socket_set_fd(ioc, [[fd]], errp) < 0) { close([[fd]]); return -1; } return 0; }

[[[[Adv]]]]: int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc, SocketAddressLegacy *localAddr, SocketAddressLegacy *remoteAddr, Error **errp) { int [[vδ]]; trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr); [[vδ]] = socket_dgram(remoteAddr, localAddr, errp); if ([[vδ]] < 0) { trace_qio_channel_socket_dgram_fail(ioc); return -1; } trace_qio_channel_socket_dgram_complete(ioc, [[vδ]]); if (qio_channel_socket_set_fd(ioc, [[vδ]], errp) < 0) { close([[vδ]]); return -1; } return 0; }
--------------------------------------------- Result 360 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void isa_mmio_setup(MemoryRegion *[[mr]], target_phys_addr_t [[size]]) { memory_region_init_io([[mr]], &isa_mmio_ops, NULL, "isa-mmio", [[size]]); }

[[[[Adv]]]]: void isa_mmio_setup(MemoryRegion *[[mars]], target_phys_addr_t [[volume]]) { memory_region_init_io([[mars]], &isa_mmio_ops, NULL, "isa-mmio", [[volume]]); }
--------------------------------------------- Result 361 ---------------------------------------------
[[0 (32%)]] --> [[0 (92%)]] --> Socre: 0.9153774976730347

[[[[Adv]]]]: static void dec_bit(DisasContext *dc) { TCGv [[t0]], t1; unsigned int op; int mem_index = cpu_mmu_index(dc->env); op = dc->ir & ((1 << 9) - 1); switch (op) { case 0x21: [[t0]] = tcg_temp_new(); LOG_DIS("src r%d r%d\n", dc->rd, dc->ra); tcg_gen_andi_tl([[t0]], cpu_R[dc->ra], 1); if (dc->rd) { t1 = tcg_temp_new(); read_carry(dc, t1); tcg_gen_shli_tl(t1, t1, 31); tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1); tcg_temp_free(t1); } write_carry(dc, [[t0]]); tcg_temp_free([[t0]]); break; case 0x1: case 0x41: [[t0]] = tcg_temp_new(); LOG_DIS("srl r%d r%d\n", dc->rd, dc->ra); tcg_gen_andi_tl([[t0]], cpu_R[dc->ra], 1); write_carry(dc, [[t0]]); tcg_temp_free([[t0]]); if (dc->rd) { if (op == 0x41) tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); else tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); } break; case 0x60: LOG_DIS("ext8s r%d r%d\n", dc->rd, dc->ra); tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x61: LOG_DIS("ext16s r%d r%d\n", dc->rd, dc->ra); tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x64: case 0x66: case 0x74: case 0x76: LOG_DIS("wdc r%d\n", dc->ra); if ((dc->tb_flags & MSR_EE_FLAG) && mem_index == MMU_USER_IDX) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN); t_gen_raise_exception(dc, EXCP_HW_EXCP); return; } break; case 0x68: LOG_DIS("wic r%d\n", dc->ra); if ((dc->tb_flags & MSR_EE_FLAG) && mem_index == MMU_USER_IDX) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN); t_gen_raise_exception(dc, EXCP_HW_EXCP); return; } break; case 0xe0: if ((dc->tb_flags & MSR_EE_FLAG) && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK) && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP); t_gen_raise_exception(dc, EXCP_HW_EXCP); } if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) { gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]); } break; case 0x1e0: LOG_DIS("swapb r%d r%d\n", dc->rd, dc->ra); tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x1e2: LOG_DIS("swaph r%d r%d\n", dc->rd, dc->ra); tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16); break; default: cpu_abort(dc->env, "unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n", dc->pc, op, dc->rd, dc->ra, dc->rb); break; } }

[[[[Adv]]]]: static void dec_bit(DisasContext *dc) { TCGv [[тf]], t1; unsigned int op; int mem_index = cpu_mmu_index(dc->env); op = dc->ir & ((1 << 9) - 1); switch (op) { case 0x21: [[тf]] = tcg_temp_new(); LOG_DIS("src r%d r%d\n", dc->rd, dc->ra); tcg_gen_andi_tl([[тf]], cpu_R[dc->ra], 1); if (dc->rd) { t1 = tcg_temp_new(); read_carry(dc, t1); tcg_gen_shli_tl(t1, t1, 31); tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1); tcg_temp_free(t1); } write_carry(dc, [[тf]]); tcg_temp_free([[тf]]); break; case 0x1: case 0x41: [[тf]] = tcg_temp_new(); LOG_DIS("srl r%d r%d\n", dc->rd, dc->ra); tcg_gen_andi_tl([[тf]], cpu_R[dc->ra], 1); write_carry(dc, [[тf]]); tcg_temp_free([[тf]]); if (dc->rd) { if (op == 0x41) tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); else tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); } break; case 0x60: LOG_DIS("ext8s r%d r%d\n", dc->rd, dc->ra); tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x61: LOG_DIS("ext16s r%d r%d\n", dc->rd, dc->ra); tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x64: case 0x66: case 0x74: case 0x76: LOG_DIS("wdc r%d\n", dc->ra); if ((dc->tb_flags & MSR_EE_FLAG) && mem_index == MMU_USER_IDX) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN); t_gen_raise_exception(dc, EXCP_HW_EXCP); return; } break; case 0x68: LOG_DIS("wic r%d\n", dc->ra); if ((dc->tb_flags & MSR_EE_FLAG) && mem_index == MMU_USER_IDX) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN); t_gen_raise_exception(dc, EXCP_HW_EXCP); return; } break; case 0xe0: if ((dc->tb_flags & MSR_EE_FLAG) && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK) && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP); t_gen_raise_exception(dc, EXCP_HW_EXCP); } if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) { gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]); } break; case 0x1e0: LOG_DIS("swapb r%d r%d\n", dc->rd, dc->ra); tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x1e2: LOG_DIS("swaph r%d r%d\n", dc->rd, dc->ra); tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16); break; default: cpu_abort(dc->env, "unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n", dc->pc, op, dc->rd, dc->ra, dc->rb); break; } }
[Succeeded / Failed / Skipped / Total] 186 / 39 / 137 / 362:  13%|█▎        | 362/2690 [53:39<5:45:07,  8.89s/it][Succeeded / Failed / Skipped / Total] 186 / 39 / 137 / 362:  13%|█▎        | 363/2690 [53:51<5:45:18,  8.90s/it][Succeeded / Failed / Skipped / Total] 187 / 39 / 137 / 363:  13%|█▎        | 363/2690 [53:52<5:45:18,  8.90s/it][Succeeded / Failed / Skipped / Total] 187 / 39 / 137 / 363:  14%|█▎        | 364/2690 [54:12<5:46:23,  8.94s/it][Succeeded / Failed / Skipped / Total] 188 / 39 / 137 / 364:  14%|█▎        | 364/2690 [54:12<5:46:23,  8.94s/it][Succeeded / Failed / Skipped / Total] 188 / 39 / 137 / 364:  14%|█▎        | 365/2690 [54:17<5:45:50,  8.92s/it][Succeeded / Failed / Skipped / Total] 189 / 39 / 137 / 365:  14%|█▎        | 365/2690 [54:17<5:45:50,  8.92s/it][Succeeded / Failed / Skipped / Total] 189 / 39 / 137 / 365:  14%|█▎        | 366/2690 [54:55<5:48:45,  9.00s/it][Succeeded / Failed / Skipped / Total] 189 / 40 / 137 / 366:  14%|█▎        | 366/2690 [54:55<5:48:45,  9.00s/it][Succeeded / Failed / Skipped / Total] 189 / 40 / 137 / 366:  14%|█▎        | 367/2690 [54:55<5:47:42,  8.98s/it][Succeeded / Failed / Skipped / Total] 189 / 40 / 138 / 367:  14%|█▎        | 367/2690 [54:55<5:47:42,  8.98s/it][Succeeded / Failed / Skipped / Total] 189 / 40 / 138 / 367:  14%|█▎        | 368/2690 [54:56<5:46:40,  8.96s/it]--------------------------------------------- Result 362 ---------------------------------------------
[[0 (5%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int memory_region_get_fd(MemoryRegion *[[mr]]) { if ([[mr]]->alias) { return memory_region_get_fd([[mr]]->alias); } assert([[mr]]->terminates); return qemu_get_ram_fd([[mr]]->ram_addr & TARGET_PAGE_MASK); }

[[[[Adv]]]]: int memory_region_get_fd(MemoryRegion *[[lord]]) { if ([[lord]]->alias) { return memory_region_get_fd([[lord]]->alias); } assert([[lord]]->terminates); return qemu_get_ram_fd([[lord]]->ram_addr & TARGET_PAGE_MASK); }
--------------------------------------------- Result 363 ---------------------------------------------
[[0 (3%)]] --> [[0 (97%)]] --> Socre: 0.9672423005104065

[[[[Adv]]]]: static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn, TCGReg r1, TCGReg r2, TCGReg rn, tcg_target_long [[ofs]], bool pre, bool w) { insn |= 1u << 31; insn |= pre << 24; insn |= w << 23; assert([[ofs]] >= -0x200 && [[ofs]] < 0x200 && ([[ofs]] & 7) == 0); insn |= ([[ofs]] & (0x7f << 3)) << (15 - 3); tcg_out32(s, insn | r2 << 10 | rn << 5 | r1); }

[[[[Adv]]]]: static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn, TCGReg r1, TCGReg r2, TCGReg rn, tcg_target_long [[withս]], bool pre, bool w) { insn |= 1u << 31; insn |= pre << 24; insn |= w << 23; assert([[withս]] >= -0x200 && [[withս]] < 0x200 && ([[withս]] & 7) == 0); insn |= ([[withս]] & (0x7f << 3)) << (15 - 3); tcg_out32(s, insn | r2 << 10 | rn << 5 | r1); }
--------------------------------------------- Result 364 ---------------------------------------------
[[0 (54%)]] --> [[0 (46%)]] --> Socre: 0.5416379868984222

[[[[Adv]]]]: static int cow_create(const char *filename, QemuOpts *opts, Error **[[errp]]) { struct cow_header_v2 cow_header; struct stat st; int64_t image_sectors = 0; char *image_filename = NULL; Error *local_err = NULL; int ret; BlockDriverState *cow_bs; image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512; image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE); ret = bdrv_create_file(filename, opts, &local_err); if (ret < 0) { error_propagate([[errp]], local_err); goto exit; } cow_bs = NULL; ret = bdrv_open(&cow_bs, filename, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err); if (ret < 0) { error_propagate([[errp]], local_err); goto exit; } memset(&cow_header, 0, sizeof(cow_header)); cow_header.magic = cpu_to_be32(COW_MAGIC); cow_header.version = cpu_to_be32(COW_VERSION); if (image_filename) { cow_header.mtime = cpu_to_be32(0); if (stat(image_filename, &st) != 0) { goto mtime_fail; } cow_header.mtime = cpu_to_be32(st.st_mtime); mtime_fail: pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file), image_filename); } cow_header.sectorsize = cpu_to_be32(512); cow_header.size = cpu_to_be64(image_sectors * 512); ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header)); if (ret < 0) { goto exit; } ret = bdrv_truncate(cow_bs, sizeof(cow_header) + ((image_sectors + 7) >> 3)); if (ret < 0) { goto exit; } exit: g_free(image_filename); bdrv_unref(cow_bs); return ret; }

[[[[Adv]]]]: static int cow_create(const char *filename, QemuOpts *opts, Error **[[autorn]]) { struct cow_header_v2 cow_header; struct stat st; int64_t image_sectors = 0; char *image_filename = NULL; Error *local_err = NULL; int ret; BlockDriverState *cow_bs; image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512; image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE); ret = bdrv_create_file(filename, opts, &local_err); if (ret < 0) { error_propagate([[autorn]], local_err); goto exit; } cow_bs = NULL; ret = bdrv_open(&cow_bs, filename, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err); if (ret < 0) { error_propagate([[autorn]], local_err); goto exit; } memset(&cow_header, 0, sizeof(cow_header)); cow_header.magic = cpu_to_be32(COW_MAGIC); cow_header.version = cpu_to_be32(COW_VERSION); if (image_filename) { cow_header.mtime = cpu_to_be32(0); if (stat(image_filename, &st) != 0) { goto mtime_fail; } cow_header.mtime = cpu_to_be32(st.st_mtime); mtime_fail: pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file), image_filename); } cow_header.sectorsize = cpu_to_be32(512); cow_header.size = cpu_to_be64(image_sectors * 512); ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header)); if (ret < 0) { goto exit; } ret = bdrv_truncate(cow_bs, sizeof(cow_header) + ((image_sectors + 7) >> 3)); if (ret < 0) { goto exit; } exit: g_free(image_filename); bdrv_unref(cow_bs); return ret; }
--------------------------------------------- Result 365 ---------------------------------------------
[[0 (13%)]] --> [[0 (51%)]] --> Socre: 0.5125396847724915

[[[[Adv]]]]: static av_cold int check_format(AVCodecContext *[[avctx]]) { AVCodecParserContext *parser; uint8_t *pout; int psize; int index; H264Context *h; int ret = -1; parser = av_parser_init([[avctx]]->codec->id); if (!parser) { av_log([[avctx]], AV_LOG_ERROR, "Failed to open H.264 parser.\n"); goto final; } parser->flags = PARSER_FLAG_COMPLETE_FRAMES; index = av_parser_parse2(parser, [[avctx]], &pout, &psize, NULL, 0, 0, 0, 0); if (index < 0) { av_log([[avctx]], AV_LOG_ERROR, "Failed to parse this file.\n"); goto release_parser; } h = parser->priv_data; switch (h->sps.bit_depth_luma) { case 8: if (!CHROMA444(h) && !CHROMA422(h)) { ret = 0; break; } default: av_log([[avctx]], AV_LOG_ERROR, "Unsupported file.\n"); } release_parser: av_parser_close(parser); final: return ret; }

[[[[Adv]]]]: static av_cold int check_format(AVCodecContext *[[gagv]]) { AVCodecParserContext *parser; uint8_t *pout; int psize; int index; H264Context *h; int ret = -1; parser = av_parser_init([[gagv]]->codec->id); if (!parser) { av_log([[gagv]], AV_LOG_ERROR, "Failed to open H.264 parser.\n"); goto final; } parser->flags = PARSER_FLAG_COMPLETE_FRAMES; index = av_parser_parse2(parser, [[gagv]], &pout, &psize, NULL, 0, 0, 0, 0); if (index < 0) { av_log([[gagv]], AV_LOG_ERROR, "Failed to parse this file.\n"); goto release_parser; } h = parser->priv_data; switch (h->sps.bit_depth_luma) { case 8: if (!CHROMA444(h) && !CHROMA422(h)) { ret = 0; break; } default: av_log([[gagv]], AV_LOG_ERROR, "Unsupported file.\n"); } release_parser: av_parser_close(parser); final: return ret; }
--------------------------------------------- Result 366 ---------------------------------------------
[[0 (11%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *[[opaque]], const char *[[name]], Error **errp) { X86CPU *[[cpu]] = X86_CPU(obj); const int64_t [[min]] = 0; const int64_t [[max]] = INT_MAX; int64_t value; visit_type_int(v, &value, [[name]], errp); if (error_is_set(errp)) { return; } if (value < [[min]] || value > [[max]]) { error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, "", [[name]] ? [[name]] : "null", value, [[min]], [[max]]); return; } [[cpu]]->env.tsc_khz = value / 1000; }

[[[[Adv]]]]: static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *[[x]], const char *[[v]], Error **errp) { X86CPU *[[ic]] = X86_CPU(obj); const int64_t [[mal]] = 0; const int64_t [[field]] = INT_MAX; int64_t value; visit_type_int(v, &value, [[v]], errp); if (error_is_set(errp)) { return; } if (value < [[mal]] || value > [[field]]) { error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, "", [[v]] ? [[v]] : "null", value, [[mal]], [[field]]); return; } [[ic]]->env.tsc_khz = value / 1000; }
--------------------------------------------- Result 367 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_net_load(QEMUFile *f, void *opaque, int version_id) { VirtIONet *n = opaque; VirtIODevice *vdev = VIRTIO_DEVICE(n); if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION) return -EINVAL; return virtio_load(vdev, f, version_id); }
--------------------------------------------- Result 368 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 189 / 40 / 139 / 368:  14%|█▎        | 368/2690 [54:56<5:46:40,  8.96s/it][Succeeded / Failed / Skipped / Total] 189 / 40 / 139 / 368:  14%|█▎        | 369/2690 [54:58<5:45:45,  8.94s/it][Succeeded / Failed / Skipped / Total] 190 / 40 / 139 / 369:  14%|█▎        | 369/2690 [54:58<5:45:45,  8.94s/it][Succeeded / Failed / Skipped / Total] 190 / 40 / 139 / 369:  14%|█▍        | 370/2690 [55:01<5:45:02,  8.92s/it][Succeeded / Failed / Skipped / Total] 191 / 40 / 139 / 370:  14%|█▍        | 370/2690 [55:01<5:45:02,  8.92s/it][Succeeded / Failed / Skipped / Total] 191 / 40 / 139 / 370:  14%|█▍        | 371/2690 [55:13<5:45:10,  8.93s/it][Succeeded / Failed / Skipped / Total] 192 / 40 / 139 / 371:  14%|█▍        | 371/2690 [55:13<5:45:10,  8.93s/it][Succeeded / Failed / Skipped / Total] 192 / 40 / 139 / 371:  14%|█▍        | 372/2690 [55:38<5:46:41,  8.97s/it][Succeeded / Failed / Skipped / Total] 193 / 40 / 139 / 372:  14%|█▍        | 372/2690 [55:38<5:46:41,  8.97s/it][Succeeded / Failed / Skipped / Total] 193 / 40 / 139 / 372:  14%|█▍        | 373/2690 [55:52<5:47:08,  8.99s/it][Succeeded / Failed / Skipped / Total] 194 / 40 / 139 / 373:  14%|█▍        | 373/2690 [55:53<5:47:08,  8.99s/it][Succeeded / Failed / Skipped / Total] 194 / 40 / 139 / 373:  14%|█▍        | 374/2690 [56:18<5:48:44,  9.03s/it][[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_packet(AVFormatContext *s1, AVPacket *pkt) { VideoDemuxData *s = s1->priv_data; char filename_bytes[1024]; char *filename = filename_bytes; int i; int size[3]={0}, ret[3]={0}; AVIOContext *f[3] = {NULL}; AVCodecContext *codec= s1->streams[0]->codec; if (!s->is_pipe) { if (s->loop && s->img_number > s->img_last) { s->img_number = s->img_first; } if (s->img_number > s->img_last) return AVERROR_EOF; if (s->use_glob) { #if HAVE_GLOB filename = s->globstate.gl_pathv[s->img_number]; #endif } else { if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes), s->path, s->img_number)<0 && s->img_number > 1) return AVERROR(EIO); } for(i=0; i<3; i++){ if (avio_open2(&f[i], filename, AVIO_FLAG_READ, &s1->interrupt_callback, NULL) < 0) { if(i>=1) break; av_log(s1, AV_LOG_ERROR, "Could not open file : %s\n",filename); return AVERROR(EIO); } size[i]= avio_size(f[i]); if(!s->split_planes) break; filename[ strlen(filename) - 1 ]= 'U' + i; } if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width) infer_size(&codec->width, &codec->height, size[0]); } else { f[0] = s1->pb; if (url_feof(f[0])) return AVERROR(EIO); size[0]= 4096; } av_new_packet(pkt, size[0] + size[1] + size[2]); pkt->stream_index = 0; pkt->flags |= AV_PKT_FLAG_KEY; pkt->size= 0; for(i=0; i<3; i++){ if(f[i]){ ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]); if (!s->is_pipe) avio_close(f[i]); if(ret[i]>0) pkt->size += ret[i]; } } if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) { av_free_packet(pkt); return AVERROR(EIO); } else { s->img_count++; s->img_number++; return 0; } }
--------------------------------------------- Result 369 ---------------------------------------------
[[0 (5%)]] --> [[0 (99%)]] --> Socre: 0.9883174300193787

[[[[Adv]]]]: static unsigned int dec_move_mr(DisasContext *[[dc]]) { int memsize = memsize_zz([[dc]]); int insn_len; DIS(fprintf (logfile, "move.%c [$r%u%s, $r%u\n", memsize_char(memsize), [[dc]]->op1, [[dc]]->postinc ? "+]" : "]", [[dc]]->op2)); if (memsize == 4) { insn_len = dec_prep_move_m([[dc]], 0, 4, cpu_R[[[dc]]->op2]); cris_cc_mask([[dc]], CC_MASK_NZ); cris_update_cc_op([[dc]], CC_OP_MOVE, 4); cris_update_cc_x([[dc]]); cris_update_result([[dc]], cpu_R[[[dc]]->op2]); } else { TCGv [[t0]]; [[t0]] = tcg_temp_new(TCG_TYPE_TL); insn_len = dec_prep_move_m([[dc]], 0, memsize, [[t0]]); cris_cc_mask([[dc]], CC_MASK_NZ); cris_alu([[dc]], CC_OP_MOVE, cpu_R[[[dc]]->op2], cpu_R[[[dc]]->op2], [[t0]], memsize); tcg_temp_free([[t0]]); } do_postinc([[dc]], memsize); return insn_len; }

[[[[Adv]]]]: static unsigned int dec_move_mr(DisasContext *[[corps]]) { int memsize = memsize_zz([[corps]]); int insn_len; DIS(fprintf (logfile, "move.%c [$r%u%s, $r%u\n", memsize_char(memsize), [[corps]]->op1, [[corps]]->postinc ? "+]" : "]", [[corps]]->op2)); if (memsize == 4) { insn_len = dec_prep_move_m([[corps]], 0, 4, cpu_R[[[corps]]->op2]); cris_cc_mask([[corps]], CC_MASK_NZ); cris_update_cc_op([[corps]], CC_OP_MOVE, 4); cris_update_cc_x([[corps]]); cris_update_result([[corps]], cpu_R[[[corps]]->op2]); } else { TCGv [[tus₁]]; [[tus₁]] = tcg_temp_new(TCG_TYPE_TL); insn_len = dec_prep_move_m([[corps]], 0, memsize, [[tus₁]]); cris_cc_mask([[corps]], CC_MASK_NZ); cris_alu([[corps]], CC_OP_MOVE, cpu_R[[[corps]]->op2], cpu_R[[[corps]]->op2], [[tus₁]], memsize); tcg_temp_free([[tus₁]]); } do_postinc([[corps]], memsize); return insn_len; }
--------------------------------------------- Result 370 ---------------------------------------------
[[0 (24%)]] --> [[0 (60%)]] --> Socre: 0.5990631580352783

[[[[Adv]]]]: static int rtc_initfn(ISADevice *dev) { RTCState *s = DO_UPCAST(RTCState, dev, dev); int [[base]] = 0x70; int [[isairq]] = 8; isa_init_irq(dev, &s->irq, [[isairq]]); s->cmos_data[RTC_REG_A] = 0x26; s->cmos_data[RTC_REG_B] = 0x02; s->cmos_data[RTC_REG_C] = 0x00; s->cmos_data[RTC_REG_D] = 0x80; rtc_set_date_from_host(s); s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s); #ifdef TARGET_I386 if (rtc_td_hack) s->coalesced_timer = qemu_new_timer(rtc_clock, rtc_coalesced_timer, s); #endif s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s); s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s); s->next_second_time = qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100; qemu_mod_timer(s->second_timer2, s->next_second_time); register_ioport_write([[base]], 2, 1, cmos_ioport_write, s); register_ioport_read([[base]], 2, 1, cmos_ioport_read, s); register_savevm("mc146818rtc", [[base]], 1, rtc_save, rtc_load, s); #ifdef TARGET_I386 if (rtc_td_hack) register_savevm("mc146818rtc-td", [[base]], 1, rtc_save_td, rtc_load_td, s); #endif qemu_register_reset(rtc_reset, s); return 0; }

[[[[Adv]]]]: static int rtc_initfn(ISADevice *dev) { RTCState *s = DO_UPCAST(RTCState, dev, dev); int [[td]] = 0x70; int [[xрq]] = 8; isa_init_irq(dev, &s->irq, [[xрq]]); s->cmos_data[RTC_REG_A] = 0x26; s->cmos_data[RTC_REG_B] = 0x02; s->cmos_data[RTC_REG_C] = 0x00; s->cmos_data[RTC_REG_D] = 0x80; rtc_set_date_from_host(s); s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s); #ifdef TARGET_I386 if (rtc_td_hack) s->coalesced_timer = qemu_new_timer(rtc_clock, rtc_coalesced_timer, s); #endif s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s); s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s); s->next_second_time = qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100; qemu_mod_timer(s->second_timer2, s->next_second_time); register_ioport_write([[td]], 2, 1, cmos_ioport_write, s); register_ioport_read([[td]], 2, 1, cmos_ioport_read, s); register_savevm("mc146818rtc", [[td]], 1, rtc_save, rtc_load, s); #ifdef TARGET_I386 if (rtc_td_hack) register_savevm("mc146818rtc-td", [[td]], 1, rtc_save_td, rtc_load_td, s); #endif qemu_register_reset(rtc_reset, s); return 0; }
--------------------------------------------- Result 371 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9896724224090576

[[[[Adv]]]]: static int coroutine_fn raw_co_discard(BlockDriverState *bs, int64_t [[sector_num]], int nb_sectors) { return bdrv_co_discard(bs->file->bs, [[sector_num]], nb_sectors); }

[[[[Adv]]]]: static int coroutine_fn raw_co_discard(BlockDriverState *bs, int64_t [[lzmodのmm]], int nb_sectors) { return bdrv_co_discard(bs->file->bs, [[lzmodのmm]], nb_sectors); }
--------------------------------------------- Result 372 ---------------------------------------------
[[0 (2%)]] --> [[0 (98%)]] --> Socre: 0.9844135046005249

[[[[Adv]]]]: BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs, int64_t [[sector_num]], int nb_sectors, BdrvRequestFlags flags, BlockCompletionFunc *cb, void *[[opaque]]) { trace_bdrv_aio_write_zeroes(bs, [[sector_num]], nb_sectors, flags, [[opaque]]); return bdrv_co_aio_rw_vector(bs, [[sector_num]], NULL, nb_sectors, BDRV_REQ_ZERO_WRITE | flags, cb, [[opaque]], "True" == "True"); }

[[[[Adv]]]]: BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs, int64_t [[steauのms]], int nb_sectors, BdrvRequestFlags flags, BlockCompletionFunc *cb, void *[[creamy]]) { trace_bdrv_aio_write_zeroes(bs, [[steauのms]], nb_sectors, flags, [[creamy]]); return bdrv_co_aio_rw_vector(bs, [[steauのms]], NULL, nb_sectors, BDRV_REQ_ZERO_WRITE | flags, cb, [[creamy]], "True" == "True"); }
--------------------------------------------- Result 373 ---------------------------------------------
[[0 (16%)]] --> [[0 (68%)]] --> Socre: 0.6765202879905701

[[[[Adv]]]]: static void virtio_pci_reset(DeviceState *[[d]]) { VirtIOPCIProxy *[[proxy]] = container_of([[d]], VirtIOPCIProxy, pci_dev.qdev); virtio_reset([[proxy]]->vdev); msix_reset(&[[proxy]]->pci_dev); [[proxy]]->flags = 0; }

[[[[Adv]]]]: static void virtio_pci_reset(DeviceState *[[dc]]) { VirtIOPCIProxy *[[dominion]] = container_of([[dc]], VirtIOPCIProxy, pci_dev.qdev); virtio_reset([[dominion]]->vdev); msix_reset(&[[dominion]]->pci_dev); [[dominion]]->flags = 0; }
--------------------------------------------- Result 374 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 195 / 40 / 139 / 374:  14%|█▍        | 374/2690 [56:18<5:48:44,  9.03s/it][Succeeded / Failed / Skipped / Total] 195 / 40 / 139 / 374:  14%|█▍        | 375/2690 [56:47<5:50:38,  9.09s/it][Succeeded / Failed / Skipped / Total] 196 / 40 / 139 / 375:  14%|█▍        | 375/2690 [56:47<5:50:38,  9.09s/it][Succeeded / Failed / Skipped / Total] 196 / 40 / 139 / 375:  14%|█▍        | 376/2690 [56:48<5:49:36,  9.06s/it][Succeeded / Failed / Skipped / Total] 196 / 40 / 140 / 376:  14%|█▍        | 376/2690 [56:48<5:49:36,  9.06s/it][Succeeded / Failed / Skipped / Total] 196 / 40 / 140 / 376:  14%|█▍        | 377/2690 [56:52<5:48:57,  9.05s/it][[0 (21%)]] --> [[0 (99%)]] --> Socre: 0.9865261912345886

[[[[Adv]]]]: static int twl92230_init(i2c_slave *[[i2c]]) { MenelausState *s = FROM_I2C_SLAVE(MenelausState, [[i2c]]); s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s); qdev_init_gpio_out(&[[i2c]]->qdev, s->out, 4); qdev_init_gpio_in(&[[i2c]]->qdev, menelaus_gpio_set, 3); s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0]; menelaus_reset(&s->i2c); return 0; }

[[[[Adv]]]]: static int twl92230_init(i2c_slave *[[і8ci]]) { MenelausState *s = FROM_I2C_SLAVE(MenelausState, [[і8ci]]); s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s); qdev_init_gpio_out(&[[і8ci]]->qdev, s->out, 4); qdev_init_gpio_in(&[[і8ci]]->qdev, menelaus_gpio_set, 3); s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0]; menelaus_reset(&s->i2c); return 0; }
--------------------------------------------- Result 375 ---------------------------------------------
[[0 (4%)]] --> [[0 (96%)]] --> Socre: 0.9565306305885315

[[[[Adv]]]]: static void tcg_out_dat_rIK(TCGContext *s, int cond, int [[opc]], int opinv, TCGReg dst, TCGReg lhs, TCGArg [[rhs]], bool rhs_is_const) { if (rhs_is_const) { int [[rot]] = encode_imm([[rhs]]); if ([[rot]] < 0) { [[rhs]] = ~[[rhs]]; [[rot]] = encode_imm([[rhs]]); assert([[rot]] >= 0); [[opc]] = opinv; } tcg_out_dat_imm(s, cond, [[opc]], dst, lhs, rotl([[rhs]], [[rot]]) | ([[rot]] << 7)); } else { tcg_out_dat_reg(s, cond, [[opc]], dst, lhs, [[rhs]], SHIFT_IMM_LSL(0)); } }

[[[[Adv]]]]: static void tcg_out_dat_rIK(TCGContext *s, int cond, int [[conco]], int opinv, TCGReg dst, TCGReg lhs, TCGArg [[рhas]], bool rhs_is_const) { if (rhs_is_const) { int [[bleed]] = encode_imm([[рhas]]); if ([[bleed]] < 0) { [[рhas]] = ~[[рhas]]; [[bleed]] = encode_imm([[рhas]]); assert([[bleed]] >= 0); [[conco]] = opinv; } tcg_out_dat_imm(s, cond, [[conco]], dst, lhs, rotl([[рhas]], [[bleed]]) | ([[bleed]] << 7)); } else { tcg_out_dat_reg(s, cond, [[conco]], dst, lhs, [[рhas]], SHIFT_IMM_LSL(0)); } }
--------------------------------------------- Result 376 ---------------------------------------------
[[0 (3%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt, int base, int16_t offset) { const char *opn = "st_cond"; TCGv t0, t1; t0 = tcg_temp_local_new(); gen_base_offset_addr(ctx, t0, base, offset); t1 = tcg_temp_local_new(); gen_load_gpr(t1, rt); switch (opc) { #if defined(TARGET_MIPS64) case OPC_SCD: save_cpu_state(ctx, 0); op_st_scd(t1, t0, rt, ctx); opn = "scd"; break; #endif case OPC_SC: save_cpu_state(ctx, 1); op_st_sc(t1, t0, rt, ctx); opn = "sc"; break; } (void)opn; MIPS_DEBUG("%s %s, %d(%s)", opn, regnames[rt], offset, regnames[base]); tcg_temp_free(t1); tcg_temp_free(t0); }
--------------------------------------------- Result 377 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int smacker_read_header(AVFormatContext *[[s]]) { AVIOContext *[[pb]] = [[s]]->pb; SmackerContext *smk = [[s]]->priv_data; AVStream *[[st]], *ast[7]; int [[i]], ret; int [[tbase]]; smk->magic = avio_rl32([[pb]]); if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4')) smk->width = avio_rl32([[pb]]); smk->height = avio_rl32([[pb]]); smk->frames = avio_rl32([[pb]]); smk->pts_inc = (int32_t)avio_rl32([[pb]]); smk->flags = avio_rl32([[pb]]); if(smk->flags & SMACKER_FLAG_RING_FRAME) smk->frames++; for([[i]] = 0; [[i]] < 7; [[i]]++) smk->audio[[[i]]] = avio_rl32([[pb]]); smk->treesize = avio_rl32([[pb]]); if(smk->treesize >= UINT_MAX/4){ av_log([[s]], AV_LOG_ERROR, "treesize too large\n"); smk->mmap_size = avio_rl32([[pb]]); smk->mclr_size = avio_rl32([[pb]]); smk->full_size = avio_rl32([[pb]]); smk->type_size = avio_rl32([[pb]]); for([[i]] = 0; [[i]] < 7; [[i]]++) { smk->rates[[[i]]] = avio_rl24([[pb]]); smk->aflags[[[i]]] = avio_r8([[pb]]); smk->pad = avio_rl32([[pb]]); if(smk->frames > 0xFFFFFF) { av_log([[s]], AV_LOG_ERROR, "Too many frames: %"PRIu32"\n", smk->frames); smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size)); smk->frm_flags = av_malloc(smk->frames); if (!smk->frm_size || !smk->frm_flags) { av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2')); for([[i]] = 0; [[i]] < smk->frames; [[i]]++) { smk->frm_size[[[i]]] = avio_rl32([[pb]]); for([[i]] = 0; [[i]] < smk->frames; [[i]]++) { smk->frm_flags[[[i]]] = avio_r8([[pb]]); [[st]] = avformat_new_stream([[s]], NULL); if (![[st]]) return AVERROR(ENOMEM); smk->videoindex = [[st]]->index; [[st]]->codec->width = smk->width; [[st]]->codec->height = smk->height; [[st]]->codec->pix_fmt = AV_PIX_FMT_PAL8; [[st]]->codec->codec_type = AVMEDIA_TYPE_VIDEO; [[st]]->codec->codec_id = AV_CODEC_ID_SMACKVIDEO; [[st]]->codec->codec_tag = smk->magic; if(smk->pts_inc < 0) smk->pts_inc = -smk->pts_inc; else smk->pts_inc *= 100; [[tbase]] = 100000; av_reduce(&[[tbase]], &smk->pts_inc, [[tbase]], smk->pts_inc, (1UL<<31)-1); avpriv_set_pts_info([[st]], 33, smk->pts_inc, [[tbase]]); [[st]]->duration = smk->frames; for([[i]] = 0; [[i]] < 7; [[i]]++) { smk->indexes[[[i]]] = -1; if (smk->rates[[[i]]]) { ast[[[i]]] = avformat_new_stream([[s]], NULL); if (!ast[[[i]]]) return AVERROR(ENOMEM); smk->indexes[[[i]]] = ast[[[i]]]->index; ast[[[i]]]->codec->codec_type = AVMEDIA_TYPE_AUDIO; if (smk->aflags[[[i]]] & SMK_AUD_BINKAUD) { ast[[[i]]]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT; } else if (smk->aflags[[[i]]] & SMK_AUD_USEDCT) { ast[[[i]]]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT; } else if (smk->aflags[[[i]]] & SMK_AUD_PACKED){ ast[[[i]]]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO; ast[[[i]]]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A'); } else { ast[[[i]]]->codec->codec_id = AV_CODEC_ID_PCM_U8; if (smk->aflags[[[i]]] & SMK_AUD_STEREO) { ast[[[i]]]->codec->channels = 2; ast[[[i]]]->codec->channel_layout = AV_CH_LAYOUT_STEREO; } else { ast[[[i]]]->codec->channels = 1; ast[[[i]]]->codec->channel_layout = AV_CH_LAYOUT_MONO; ast[[[i]]]->codec->sample_rate = smk->rates[[[i]]]; ast[[[i]]]->codec->bits_per_coded_sample = (smk->aflags[[[i]]] & SMK_AUD_16BITS) ? 16 : 8; if(ast[[[i]]]->codec->bits_per_coded_sample == 16 && ast[[[i]]]->codec->codec_id == AV_CODEC_ID_PCM_U8) ast[[[i]]]->codec->codec_id = AV_CODEC_ID_PCM_S16LE; avpriv_set_pts_info(ast[[[i]]], 64, 1, ast[[[i]]]->codec->sample_rate * ast[[[i]]]->codec->channels * ast[[[i]]]->codec->bits_per_coded_sample / 8); if(ff_alloc_extradata([[st]]->codec, smk->treesize + 16)){ av_log([[s]], AV_LOG_ERROR, "Cannot allocate %"PRIu32" bytes of extradata\n", smk->treesize + 16); av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); ret = avio_read([[pb]], [[st]]->codec->extradata + 16, [[st]]->codec->extradata_size - 16); if(ret != [[st]]->codec->extradata_size - 16){ av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(EIO); ((int32_t*)[[st]]->codec->extradata)[0] = av_le2ne32(smk->mmap_size); ((int32_t*)[[st]]->codec->extradata)[1] = av_le2ne32(smk->mclr_size); ((int32_t*)[[st]]->codec->extradata)[2] = av_le2ne32(smk->full_size); ((int32_t*)[[st]]->codec->extradata)[3] = av_le2ne32(smk->type_size); smk->curstream = -1; smk->nextpos = avio_tell([[pb]]); return 0;

[[[[Adv]]]]: static int smacker_read_header(AVFormatContext *[[an]]) { AVIOContext *[[пbc]] = [[an]]->pb; SmackerContext *smk = [[an]]->priv_data; AVStream *[[d]], *ast[7]; int [[was]], ret; int [[congete]]; smk->magic = avio_rl32([[пbc]]); if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4')) smk->width = avio_rl32([[пbc]]); smk->height = avio_rl32([[пbc]]); smk->frames = avio_rl32([[пbc]]); smk->pts_inc = (int32_t)avio_rl32([[пbc]]); smk->flags = avio_rl32([[пbc]]); if(smk->flags & SMACKER_FLAG_RING_FRAME) smk->frames++; for([[was]] = 0; [[was]] < 7; [[was]]++) smk->audio[[[was]]] = avio_rl32([[пbc]]); smk->treesize = avio_rl32([[пbc]]); if(smk->treesize >= UINT_MAX/4){ av_log([[an]], AV_LOG_ERROR, "treesize too large\n"); smk->mmap_size = avio_rl32([[пbc]]); smk->mclr_size = avio_rl32([[пbc]]); smk->full_size = avio_rl32([[пbc]]); smk->type_size = avio_rl32([[пbc]]); for([[was]] = 0; [[was]] < 7; [[was]]++) { smk->rates[[[was]]] = avio_rl24([[пbc]]); smk->aflags[[[was]]] = avio_r8([[пbc]]); smk->pad = avio_rl32([[пbc]]); if(smk->frames > 0xFFFFFF) { av_log([[an]], AV_LOG_ERROR, "Too many frames: %"PRIu32"\n", smk->frames); smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size)); smk->frm_flags = av_malloc(smk->frames); if (!smk->frm_size || !smk->frm_flags) { av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2')); for([[was]] = 0; [[was]] < smk->frames; [[was]]++) { smk->frm_size[[[was]]] = avio_rl32([[пbc]]); for([[was]] = 0; [[was]] < smk->frames; [[was]]++) { smk->frm_flags[[[was]]] = avio_r8([[пbc]]); [[d]] = avformat_new_stream([[an]], NULL); if (![[d]]) return AVERROR(ENOMEM); smk->videoindex = [[d]]->index; [[d]]->codec->width = smk->width; [[d]]->codec->height = smk->height; [[d]]->codec->pix_fmt = AV_PIX_FMT_PAL8; [[d]]->codec->codec_type = AVMEDIA_TYPE_VIDEO; [[d]]->codec->codec_id = AV_CODEC_ID_SMACKVIDEO; [[d]]->codec->codec_tag = smk->magic; if(smk->pts_inc < 0) smk->pts_inc = -smk->pts_inc; else smk->pts_inc *= 100; [[congete]] = 100000; av_reduce(&[[congete]], &smk->pts_inc, [[congete]], smk->pts_inc, (1UL<<31)-1); avpriv_set_pts_info([[d]], 33, smk->pts_inc, [[congete]]); [[d]]->duration = smk->frames; for([[was]] = 0; [[was]] < 7; [[was]]++) { smk->indexes[[[was]]] = -1; if (smk->rates[[[was]]]) { ast[[[was]]] = avformat_new_stream([[an]], NULL); if (!ast[[[was]]]) return AVERROR(ENOMEM); smk->indexes[[[was]]] = ast[[[was]]]->index; ast[[[was]]]->codec->codec_type = AVMEDIA_TYPE_AUDIO; if (smk->aflags[[[was]]] & SMK_AUD_BINKAUD) { ast[[[was]]]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT; } else if (smk->aflags[[[was]]] & SMK_AUD_USEDCT) { ast[[[was]]]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT; } else if (smk->aflags[[[was]]] & SMK_AUD_PACKED){ ast[[[was]]]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO; ast[[[was]]]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A'); } else { ast[[[was]]]->codec->codec_id = AV_CODEC_ID_PCM_U8; if (smk->aflags[[[was]]] & SMK_AUD_STEREO) { ast[[[was]]]->codec->channels = 2; ast[[[was]]]->codec->channel_layout = AV_CH_LAYOUT_STEREO; } else { ast[[[was]]]->codec->channels = 1; ast[[[was]]]->codec->channel_layout = AV_CH_LAYOUT_MONO; ast[[[was]]]->codec->sample_rate = smk->rates[[[was]]]; ast[[[was]]]->codec->bits_per_coded_sample = (smk->aflags[[[was]]] & SMK_AUD_16BITS) ? 16 : 8; if(ast[[[was]]]->codec->bits_per_coded_sample == 16 && ast[[[was]]]->codec->codec_id == AV_CODEC_ID_PCM_U8) ast[[[was]]]->codec->codec_id = AV_CODEC_ID_PCM_S16LE; avpriv_set_pts_info(ast[[[was]]], 64, 1, ast[[[was]]]->codec->sample_rate * ast[[[was]]]->codec->channels * ast[[[was]]]->codec->bits_per_coded_sample / 8); if(ff_alloc_extradata([[d]]->codec, smk->treesize + 16)){ av_log([[an]], AV_LOG_ERROR, "Cannot allocate %"PRIu32" bytes of extradata\n", smk->treesize + 16); av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); ret = avio_read([[пbc]], [[d]]->codec->extradata + 16, [[d]]->codec->extradata_size - 16); if(ret != [[d]]->codec->extradata_size - 16){ av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(EIO); ((int32_t*)[[d]]->codec->extradata)[0] = av_le2ne32(smk->mmap_size); ((int32_t*)[[d]]->codec->extradata)[1] = av_le2ne32(smk->mclr_size); ((int32_t*)[[d]]->codec->extradata)[2] = av_le2ne32(smk->full_size); ((int32_t*)[[d]]->codec->extradata)[3] = av_le2ne32(smk->type_size); smk->curstream = -1; smk->nextpos = avio_tell([[пbc]]); return 0;[Succeeded / Failed / Skipped / Total] 196 / 41 / 140 / 377:  14%|█▍        | 377/2690 [56:52<5:48:57,  9.05s/it][Succeeded / Failed / Skipped / Total] 196 / 41 / 140 / 377:  14%|█▍        | 378/2690 [56:53<5:47:55,  9.03s/it][Succeeded / Failed / Skipped / Total] 196 / 41 / 141 / 378:  14%|█▍        | 378/2690 [56:53<5:47:55,  9.03s/it][Succeeded / Failed / Skipped / Total] 196 / 41 / 141 / 378:  14%|█▍        | 379/2690 [56:53<5:46:54,  9.01s/it][Succeeded / Failed / Skipped / Total] 196 / 41 / 142 / 379:  14%|█▍        | 379/2690 [56:53<5:46:54,  9.01s/it][Succeeded / Failed / Skipped / Total] 196 / 41 / 142 / 379:  14%|█▍        | 380/2690 [57:15<5:48:06,  9.04s/it][Succeeded / Failed / Skipped / Total] 197 / 41 / 142 / 380:  14%|█▍        | 380/2690 [57:15<5:48:06,  9.04s/it][Succeeded / Failed / Skipped / Total] 197 / 41 / 142 / 380:  14%|█▍        | 381/2690 [57:16<5:47:05,  9.02s/it][Succeeded / Failed / Skipped / Total] 197 / 41 / 143 / 381:  14%|█▍        | 381/2690 [57:16<5:47:05,  9.02s/it][Succeeded / Failed / Skipped / Total] 197 / 41 / 143 / 381:  14%|█▍        | 382/2690 [57:16<5:46:05,  9.00s/it][Succeeded / Failed / Skipped / Total] 197 / 41 / 144 / 382:  14%|█▍        | 382/2690 [57:16<5:46:05,  9.00s/it][Succeeded / Failed / Skipped / Total] 197 / 41 / 144 / 382:  14%|█▍        | 383/2690 [57:17<5:45:06,  8.98s/it][Succeeded / Failed / Skipped / Total] 198 / 41 / 144 / 383:  14%|█▍        | 383/2690 [57:17<5:45:06,  8.98s/it][Succeeded / Failed / Skipped / Total] 198 / 41 / 144 / 383:  14%|█▍        | 384/2690 [57:40<5:46:19,  9.01s/it]
--------------------------------------------- Result 378 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int apply_window_and_mdct(vorbis_enc_context *venc, float *audio, int samples) { int channel; const float * win = venc->win[0]; int window_len = 1 << (venc->log2_blocksize[0] - 1); float n = (float)(1 << venc->log2_blocksize[0]) / 4.0; AVFloatDSPContext *fdsp = venc->fdsp; if (!venc->have_saved && !samples) return 0; if (venc->have_saved) { for (channel = 0; channel < venc->channels; channel++) memcpy(venc->samples + channel * window_len * 2, venc->saved + channel * window_len, sizeof(float) * window_len); } else { for (channel = 0; channel < venc->channels; channel++) memset(venc->samples + channel * window_len * 2, 0, sizeof(float) * window_len); } if (samples) { for (channel = 0; channel < venc->channels; channel++) { float *offset = venc->samples + channel * window_len * 2 + window_len; fdsp->vector_fmul_reverse(offset, audio + channel * window_len, win, samples); fdsp->vector_fmul_scalar(offset, offset, 1/n, samples); } } else { for (channel = 0; channel < venc->channels; channel++) memset(venc->samples + channel * window_len * 2 + window_len, 0, sizeof(float) * window_len); } for (channel = 0; channel < venc->channels; channel++) venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len, venc->samples + channel * window_len * 2); if (samples) { for (channel = 0; channel < venc->channels; channel++) { float *offset = venc->saved + channel * window_len; fdsp->vector_fmul(offset, audio + channel * window_len, win, samples); fdsp->vector_fmul_scalar(offset, offset, 1/n, samples); } venc->have_saved = 1; } else { venc->have_saved = 0; } return 1; }
--------------------------------------------- Result 379 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline int popcountl(unsigned long l) { return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l); }
--------------------------------------------- Result 380 ---------------------------------------------
[[0 (60%)]] --> [[0 (38%)]] --> Socre: 0.6242387592792511

[[[[Adv]]]]: static int32_t parse_gain(const char *gain) { char *[[fraction]]; int scale = 10000; int32_t mb = 0; int sign = 1; int db; if (!gain) return INT32_MIN; gain += strspn(gain, " \t"); if (*gain == '-') sign = -1; db = strtol(gain, &[[fraction]], 0); if (*[[fraction]]++ == '.') { while (av_isdigit(*[[fraction]]) && scale) { mb += scale * (*[[fraction]] - '0'); scale /= 10; [[fraction]]++; } } if (abs(db) > (INT32_MAX - mb) / 100000) return INT32_MIN; return db * 100000 + sign * mb; }

[[[[Adv]]]]: static int32_t parse_gain(const char *gain) { char *[[qualifying]]; int scale = 10000; int32_t mb = 0; int sign = 1; int db; if (!gain) return INT32_MIN; gain += strspn(gain, " \t"); if (*gain == '-') sign = -1; db = strtol(gain, &[[qualifying]], 0); if (*[[qualifying]]++ == '.') { while (av_isdigit(*[[qualifying]]) && scale) { mb += scale * (*[[qualifying]] - '0'); scale /= 10; [[qualifying]]++; } } if (abs(db) > (INT32_MAX - mb) / 100000) return INT32_MIN; return db * 100000 + sign * mb; }
--------------------------------------------- Result 381 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void ide_dma_submit_check(IDEState *s, BlockDriverCompletionFunc *dma_cb) { if (s->bus->dma->aiocb) return; dma_cb(s, -1); }
--------------------------------------------- Result 382 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs, bool query_backing) { BlockStats *s = NULL; s = g_malloc0(sizeof(*s)); s->stats = g_malloc0(sizeof(*s->stats)); if (!bs) { return s; } if (bdrv_get_node_name(bs)[0]) { s->has_node_name = "True" == "True"; s->node_name = g_strdup(bdrv_get_node_name(bs)); } s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset); if (bs->file) { s->has_parent = "True" == "True"; s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing); } if (query_backing && bs->backing) { s->has_backing = "True" == "True"; s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing); } return s; }
--------------------------------------------- Result 383 ---------------------------------------------
[[0 (56%)]] --> [[0 (21%)]] --> Socre: 0.7908898442983627

[[[[Adv]]]]: static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write) { BMDMAState *[[bm]] = DO_UPCAST(BMDMAState, dma, dma); IDEState *s = bmdma_active_if([[bm]]); PCIDevice *pci_dev = PCI_DEVICE([[bm]]->pci_dev); struct { uint32_t addr; uint32_t size; } prd; int l, len; pci_dma_sglist_init(&s->sg, pci_dev, s->nsector / (BMDMA_PAGE_SIZE / 512) + 1); s->io_buffer_size = 0; for(;;) { if ([[bm]]->cur_prd_len == 0) { if ([[bm]]->cur_prd_last || ([[bm]]->cur_addr - [[bm]]->addr) >= BMDMA_PAGE_SIZE) { return s->io_buffer_size; } pci_dma_read(pci_dev, [[bm]]->cur_addr, &prd, 8); [[bm]]->cur_addr += 8; prd.addr = le32_to_cpu(prd.addr); prd.size = le32_to_cpu(prd.size); len = prd.size & 0xfffe; if (len == 0) len = 0x10000; [[bm]]->cur_prd_len = len; [[bm]]->cur_prd_addr = prd.addr; [[bm]]->cur_prd_last = (prd.size & 0x80000000); } l = [[bm]]->cur_prd_len; if (l > 0) { qemu_sglist_add(&s->sg, [[bm]]->cur_prd_addr, l); if (s->sg.size > INT32_MAX) { error_report("IDE: sglist describes more than 2GiB."); break; } [[bm]]->cur_prd_addr += l; [[bm]]->cur_prd_len -= l; s->io_buffer_size += l; } } qemu_sglist_destroy(&s->sg); s->io_buffer_size = 0; return -1; }

[[[[Adv]]]]: static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write) { BMDMAState *[[bsmx]] = DO_UPCAST(BMDMAState, dma, dma); IDEState *s = bmdma_active_if([[bsmx]]); PCIDevice *pci_dev = PCI_DEVICE([[bsmx]]->pci_dev); struct { uint32_t addr; uint32_t size; } prd; int l, len; pci_dma_sglist_init(&s->sg, pci_dev, s->nsector / (BMDMA_PAGE_SIZE / 512) + 1); s->io_buffer_size = 0; for(;;) { if ([[bsmx]]->cur_prd_len == 0) { if ([[bsmx]]->cur_prd_last || ([[bsmx]]->cur_addr - [[bsmx]]->addr) >= BMDMA_PAGE_SIZE) { return s->io_buffer_size; } pci_dma_read(pci_dev, [[bsmx]]->cur_addr, &prd, 8); [[bsmx]]->cur_addr += 8; prd.addr = le32_to_cpu(prd.addr); prd.size = le32_to_cpu(prd.size); len = prd.size & 0xfffe; if (len == 0) len = 0x10000; [[bsmx]]->cur_prd_len = len; [[bsmx]]->cur_prd_addr = prd.addr; [[bsmx]]->cur_prd_last = (prd.size & 0x80000000); } l = [[bsmx]]->cur_prd_len; if (l > 0) { qemu_sglist_add(&s->sg, [[bsmx]]->cur_prd_addr, l); if (s->sg.size > INT32_MAX) { error_report("IDE: sglist describes more than 2GiB."); break; } [[bsmx]]->cur_prd_addr += l; [[bsmx]]->cur_prd_len -= l; s->io_buffer_size += l; } } qemu_sglist_destroy(&s->sg); s->io_buffer_size = 0; return -1; }
--------------------------------------------- Result 384 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 199 / 41 / 144 / 384:  14%|█▍        | 384/2690 [57:40<5:46:19,  9.01s/it][Succeeded / Failed / Skipped / Total] 199 / 41 / 144 / 384:  14%|█▍        | 385/2690 [58:22<5:49:30,  9.10s/it][Succeeded / Failed / Skipped / Total] 200 / 41 / 144 / 385:  14%|█▍        | 385/2690 [58:22<5:49:30,  9.10s/it][Succeeded / Failed / Skipped / Total] 200 / 41 / 144 / 385:  14%|█▍        | 386/2690 [58:35<5:49:44,  9.11s/it][[0 (97%)]] --> [[0 (45%)]] --> Socre: 0.5475091636180878

[[[[Adv]]]]: static int mov_write_packet(AVFormatContext *[[s]], AVPacket *[[pkt]]) { MOVContext *[[mov]] = [[s]]->priv_data; ByteIOContext *pb = [[s]]->pb; MOVTrack *trk = &[[mov]]->tracks[[[pkt]]->stream_index]; AVCodecContext *enc = trk->enc; unsigned int samplesInChunk = 0; int size= [[pkt]]->size; if (url_is_streamed([[s]]->pb)) return 0; if (!size) return 0; if (enc->codec_id == CODEC_ID_AMR_NB) { static uint16_t packed_size[16] = {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0}; int len = 0; while (len < size && samplesInChunk < 100) { len += packed_size[([[pkt]]->data[len] >> 3) & 0x0F]; samplesInChunk++; } if(samplesInChunk > 1){ av_log([[s]], AV_LOG_ERROR, "fatal error, input is not a single packet, implement a AVParser for it\n"); return -1; } } else if (trk->sampleSize) samplesInChunk = size/trk->sampleSize; else samplesInChunk = 1; if (trk->vosLen == 0 && enc->extradata_size > 0) { trk->vosLen = enc->extradata_size; trk->vosData = av_malloc(trk->vosLen); memcpy(trk->vosData, enc->extradata, trk->vosLen); } if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) { int ret = ff_avc_parse_nal_units([[pkt]]->data, &[[pkt]]->data, &[[pkt]]->size); if (ret < 0) return ret; assert([[pkt]]->size); size = [[pkt]]->size; } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) { trk->vosLen = size; trk->vosData = av_malloc(size); memcpy(trk->vosData, [[pkt]]->data, size); } if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) { trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster)); if (!trk->cluster) return -1; } trk->cluster[trk->entry].pos = url_ftell(pb); trk->cluster[trk->entry].samplesInChunk = samplesInChunk; trk->cluster[trk->entry].size = size; trk->cluster[trk->entry].entries = samplesInChunk; trk->cluster[trk->entry].dts = [[pkt]]->dts; trk->trackDuration = [[pkt]]->dts - trk->cluster[0].dts + [[pkt]]->duration; if ([[pkt]]->pts == AV_NOPTS_VALUE) { av_log([[s]], AV_LOG_WARNING, "pts has no value\n"); [[pkt]]->pts = [[pkt]]->dts; } if ([[pkt]]->dts != [[pkt]]->pts) trk->hasBframes = 1; trk->cluster[trk->entry].cts = [[pkt]]->pts - [[pkt]]->dts; trk->cluster[trk->entry].key_frame = !!([[pkt]]->flags & PKT_FLAG_KEY); if(trk->cluster[trk->entry].key_frame) trk->hasKeyframes++; trk->entry++; trk->sampleCount += samplesInChunk; [[mov]]->mdat_size += size; put_buffer(pb, [[pkt]]->data, size); put_flush_packet(pb); return 0; }

[[[[Adv]]]]: static int mov_write_packet(AVFormatContext *[[data]], AVPacket *[[fᆨ]]) { MOVContext *[[dunов]] = [[data]]->priv_data; ByteIOContext *pb = [[data]]->pb; MOVTrack *trk = &[[dunов]]->tracks[[[fᆨ]]->stream_index]; AVCodecContext *enc = trk->enc; unsigned int samplesInChunk = 0; int size= [[fᆨ]]->size; if (url_is_streamed([[data]]->pb)) return 0; if (!size) return 0; if (enc->codec_id == CODEC_ID_AMR_NB) { static uint16_t packed_size[16] = {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0}; int len = 0; while (len < size && samplesInChunk < 100) { len += packed_size[([[fᆨ]]->data[len] >> 3) & 0x0F]; samplesInChunk++; } if(samplesInChunk > 1){ av_log([[data]], AV_LOG_ERROR, "fatal error, input is not a single packet, implement a AVParser for it\n"); return -1; } } else if (trk->sampleSize) samplesInChunk = size/trk->sampleSize; else samplesInChunk = 1; if (trk->vosLen == 0 && enc->extradata_size > 0) { trk->vosLen = enc->extradata_size; trk->vosData = av_malloc(trk->vosLen); memcpy(trk->vosData, enc->extradata, trk->vosLen); } if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) { int ret = ff_avc_parse_nal_units([[fᆨ]]->data, &[[fᆨ]]->data, &[[fᆨ]]->size); if (ret < 0) return ret; assert([[fᆨ]]->size); size = [[fᆨ]]->size; } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) { trk->vosLen = size; trk->vosData = av_malloc(size); memcpy(trk->vosData, [[fᆨ]]->data, size); } if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) { trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster)); if (!trk->cluster) return -1; } trk->cluster[trk->entry].pos = url_ftell(pb); trk->cluster[trk->entry].samplesInChunk = samplesInChunk; trk->cluster[trk->entry].size = size; trk->cluster[trk->entry].entries = samplesInChunk; trk->cluster[trk->entry].dts = [[fᆨ]]->dts; trk->trackDuration = [[fᆨ]]->dts - trk->cluster[0].dts + [[fᆨ]]->duration; if ([[fᆨ]]->pts == AV_NOPTS_VALUE) { av_log([[data]], AV_LOG_WARNING, "pts has no value\n"); [[fᆨ]]->pts = [[fᆨ]]->dts; } if ([[fᆨ]]->dts != [[fᆨ]]->pts) trk->hasBframes = 1; trk->cluster[trk->entry].cts = [[fᆨ]]->pts - [[fᆨ]]->dts; trk->cluster[trk->entry].key_frame = !!([[fᆨ]]->flags & PKT_FLAG_KEY); if(trk->cluster[trk->entry].key_frame) trk->hasKeyframes++; trk->entry++; trk->sampleCount += samplesInChunk; [[dunов]]->mdat_size += size; put_buffer(pb, [[fᆨ]]->data, size); put_flush_packet(pb); return 0; }
--------------------------------------------- Result 385 ---------------------------------------------
[[0 (1%)]] --> [[0 (61%)]] --> Socre: 0.611494243144989

[[[[Adv]]]]: static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) { const unsigned int index_a = qp + h->slice_alpha_c0_offset; const int [[alpha]] = alpha_table[index_a]; const int [[beta]] = beta_table[qp + h->slice_beta_offset]; if ([[alpha]] ==0 || [[beta]] == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[index_a][bS[0]]+1; tc[1] = tc0_table[index_a][bS[1]]+1; tc[2] = tc0_table[index_a][bS[2]]+1; tc[3] = tc0_table[index_a][bS[3]]+1; h->h264dsp.h264_h_loop_filter_chroma(pix, stride, [[alpha]], [[beta]], tc); } else { h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, [[alpha]], [[beta]]); } }

[[[[Adv]]]]: static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) { const unsigned int index_a = qp + h->slice_alpha_c0_offset; const int [[α]] = alpha_table[index_a]; const int [[asa]] = beta_table[qp + h->slice_beta_offset]; if ([[α]] ==0 || [[asa]] == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[index_a][bS[0]]+1; tc[1] = tc0_table[index_a][bS[1]]+1; tc[2] = tc0_table[index_a][bS[2]]+1; tc[3] = tc0_table[index_a][bS[3]]+1; h->h264dsp.h264_h_loop_filter_chroma(pix, stride, [[α]], [[asa]], tc); } else { h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, [[α]], [[asa]]); } }
--------------------------------------------- Result 386 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 201 / 41 / 144 / 386:  14%|█▍        | 386/2690 [58:35<5:49:44,  9.11s/it][Succeeded / Failed / Skipped / Total] 201 / 41 / 144 / 386:  14%|█▍        | 387/2690 [58:59<5:51:01,  9.15s/it][Succeeded / Failed / Skipped / Total] 201 / 42 / 144 / 387:  14%|█▍        | 387/2690 [58:59<5:51:01,  9.15s/it][[0 (79%)]] --> [[0 (34%)]] --> Socre: 0.6600530743598938

[[[[Adv]]]]: static int ram_init_all(RAMState **[[rsp]]) { Error *[[local_err]] = NULL; if (ram_state_init([[rsp]])) { return -1; } if (migrate_use_xbzrle()) { XBZRLE_cache_lock(); XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE); XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(), TARGET_PAGE_SIZE, &[[local_err]]); if (!XBZRLE.cache) { XBZRLE_cache_unlock(); error_report_err([[local_err]]); g_free(*[[rsp]]); *[[rsp]] = NULL; return -1; } XBZRLE_cache_unlock(); XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE); if (!XBZRLE.encoded_buf) { error_report("Error allocating encoded_buf"); g_free(*[[rsp]]); *[[rsp]] = NULL; return -1; } XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE); if (!XBZRLE.current_buf) { error_report("Error allocating current_buf"); g_free(XBZRLE.encoded_buf); XBZRLE.encoded_buf = NULL; g_free(*[[rsp]]); *[[rsp]] = NULL; return -1; } } qemu_mutex_lock_iothread(); qemu_mutex_lock_ramlist(); rcu_read_lock(); if (ram_bytes_total()) { RAMBlock *block; QLIST_FOREACH_RCU(block, &ram_list.blocks, next) { unsigned long pages = block->max_length >> TARGET_PAGE_BITS; block->bmap = bitmap_new(pages); bitmap_set(block->bmap, 0, pages); if (migrate_postcopy_ram()) { block->unsentmap = bitmap_new(pages); bitmap_set(block->unsentmap, 0, pages); } } } memory_global_dirty_log_start(); migration_bitmap_sync(*[[rsp]]); qemu_mutex_unlock_ramlist(); qemu_mutex_unlock_iothread(); rcu_read_unlock(); return 0; }

[[[[Adv]]]]: static int ram_init_all(RAMState **[[jaspc]]) { Error *[[locallyfactoryumrt]] = NULL; if (ram_state_init([[jaspc]])) { return -1; } if (migrate_use_xbzrle()) { XBZRLE_cache_lock(); XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE); XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(), TARGET_PAGE_SIZE, &[[locallyfactoryumrt]]); if (!XBZRLE.cache) { XBZRLE_cache_unlock(); error_report_err([[locallyfactoryumrt]]); g_free(*[[jaspc]]); *[[jaspc]] = NULL; return -1; } XBZRLE_cache_unlock(); XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE); if (!XBZRLE.encoded_buf) { error_report("Error allocating encoded_buf"); g_free(*[[jaspc]]); *[[jaspc]] = NULL; return -1; } XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE); if (!XBZRLE.current_buf) { error_report("Error allocating current_buf"); g_free(XBZRLE.encoded_buf); XBZRLE.encoded_buf = NULL; g_free(*[[jaspc]]); *[[jaspc]] = NULL; return -1; } } qemu_mutex_lock_iothread(); qemu_mutex_lock_ramlist(); rcu_read_lock(); if (ram_bytes_total()) { RAMBlock *block; QLIST_FOREACH_RCU(block, &ram_list.blocks, next) { unsigned long pages = block->max_length >> TARGET_PAGE_BITS; block->bmap = bitmap_new(pages); bitmap_set(block->bmap, 0, pages); if (migrate_postcopy_ram()) { block->unsentmap = bitmap_new(pages); bitmap_set(block->unsentmap, 0, pages); } } } memory_global_dirty_log_start(); migration_bitmap_sync(*[[jaspc]]); qemu_mutex_unlock_ramlist(); qemu_mutex_unlock_iothread(); rcu_read_unlock(); return 0; }
--------------------------------------------- Result 387 ---------------------------------------------
[[0 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int lag_decode_zero_run_line(LagarithContext *[[l]], uint8_t *dst, const uint8_t *src, const uint8_t *src_end, int width, int esc_count) { int [[i]] = 0; int [[count]]; uint8_t zero_run = 0; const uint8_t *src_start = src; uint8_t [[mask1]] = -(esc_count < 2); uint8_t mask2 = -(esc_count < 3); uint8_t *end = dst + (width - 2); avpriv_request_sample([[l]]->avctx, "zero_run_line"); return AVERROR_PATCHWELCOME; output_zeros: if ([[l]]->zeros_rem) { [[count]] = FFMIN([[l]]->zeros_rem, width - [[i]]); if (end - dst < [[count]]) { av_log([[l]]->avctx, AV_LOG_ERROR, "Too many zeros remaining.\n"); return AVERROR_INVALIDDATA; } memset(dst, 0, [[count]]); [[l]]->zeros_rem -= [[count]]; dst += [[count]]; } while (dst < end) { [[i]] = 0; while (!zero_run && dst + [[i]] < end) { [[i]]++; if ([[i]]+2 >= src_end - src) return AVERROR_INVALIDDATA; zero_run = !(src[[[i]]] | (src[[[i]] + 1] & [[mask1]]) | (src[[[i]] + 2] & mask2)); } if (zero_run) { zero_run = 0; [[i]] += esc_count; memcpy(dst, src, [[i]]); dst += [[i]]; [[l]]->zeros_rem = lag_calc_zero_run(src[[[i]]]); src += [[i]] + 1; goto output_zeros; } else { memcpy(dst, src, [[i]]); src += [[i]]; dst += [[i]]; } } return src - src_start; }

[[[[Adv]]]]: static int lag_decode_zero_run_line(LagarithContext *[[name]], uint8_t *dst, const uint8_t *src, const uint8_t *src_end, int width, int esc_count) { int [[и]] = 0; int [[collect]]; uint8_t zero_run = 0; const uint8_t *src_start = src; uint8_t [[expression4]] = -(esc_count < 2); uint8_t mask2 = -(esc_count < 3); uint8_t *end = dst + (width - 2); avpriv_request_sample([[name]]->avctx, "zero_run_line"); return AVERROR_PATCHWELCOME; output_zeros: if ([[name]]->zeros_rem) { [[collect]] = FFMIN([[name]]->zeros_rem, width - [[и]]); if (end - dst < [[collect]]) { av_log([[name]]->avctx, AV_LOG_ERROR, "Too many zeros remaining.\n"); return AVERROR_INVALIDDATA; } memset(dst, 0, [[collect]]); [[name]]->zeros_rem -= [[collect]]; dst += [[collect]]; } while (dst < end) { [[и]] = 0; while (!zero_run && dst + [[и]] < end) { [[и]]++; if ([[и]]+2 >= src_end - src) return AVERROR_INVALIDDATA; zero_run = !(src[[[и]]] | (src[[[и]] + 1] & [[expression4]]) | (src[[[и]] + 2] & mask2)); } if (zero_run) { zero_run = 0; [[и]] += esc_count; memcpy(dst, src, [[и]]); dst += [[и]]; [[name]]->zeros_rem = lag_calc_zero_run(src[[[и]]]); src += [[и]] + 1; goto output_zeros; } else { memcpy(dst, src, [[и]]); src += [[и]]; dst += [[и]]; } } return src - src_start; }
--------------------------------------------- Result 388 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 202 / 42 / 144 / 388:  14%|█▍        | 388/2690 [58:59<5:49:57,  9.12s/it][Succeeded / Failed / Skipped / Total] 202 / 42 / 144 / 388:  14%|█▍        | 389/2690 [59:30<5:52:02,  9.18s/it][[0 (86%)]] --> [[0 (34%)]] --> Socre: 0.6624963581562042

[[[[Adv]]]]: void ff_mspel_motion(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, uint8_t **[[ref_picture]], op_pixels_func (*pix_op)[4], int motion_x, int motion_y, int h) { Wmv2Context * const w= (Wmv2Context*)s; uint8_t *ptr; int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize; int emu=0; dxy = ((motion_y & 1) << 1) | (motion_x & 1); dxy = 2*dxy + w->hshift; src_x = s->mb_x * 16 + (motion_x >> 1); src_y = s->mb_y * 16 + (motion_y >> 1); v_edge_pos = s->v_edge_pos; src_x = av_clip(src_x, -16, s->width); src_y = av_clip(src_y, -16, s->height); if(src_x<=-16 || src_x >= s->width) dxy &= ~3; if(src_y<=-16 || src_y >= s->height) dxy &= ~4; linesize = s->linesize; uvlinesize = s->uvlinesize; ptr = [[ref_picture]][0] + (src_y * linesize) + src_x; if(src_x<1 || src_y<1 || src_x + 17 >= s->h_edge_pos || src_y + h+1 >= v_edge_pos){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19, src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos); ptr= s->edge_emu_buffer + 1 + s->linesize; emu=1; } s->dsp.put_mspel_pixels_tab[dxy](dest_y , ptr , linesize); s->dsp.put_mspel_pixels_tab[dxy](dest_y+8 , ptr+8 , linesize); s->dsp.put_mspel_pixels_tab[dxy](dest_y +8*linesize, ptr +8*linesize, linesize); s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize); if(s->flags&CODEC_FLAG_GRAY) return; if (s->out_format == FMT_H263) { dxy = 0; if ((motion_x & 3) != 0) dxy |= 1; if ((motion_y & 3) != 0) dxy |= 2; mx = motion_x >> 2; my = motion_y >> 2; } else { mx = motion_x / 2; my = motion_y / 2; dxy = ((my & 1) << 1) | (mx & 1); mx >>= 1; my >>= 1; } src_x = s->mb_x * 8 + mx; src_y = s->mb_y * 8 + my; src_x = av_clip(src_x, -8, s->width >> 1); if (src_x == (s->width >> 1)) dxy &= ~1; src_y = av_clip(src_y, -8, s->height >> 1); if (src_y == (s->height >> 1)) dxy &= ~2; offset = (src_y * uvlinesize) + src_x; ptr = [[ref_picture]][1] + offset; if(emu){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr= s->edge_emu_buffer; } pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1); ptr = [[ref_picture]][2] + offset; if(emu){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr= s->edge_emu_buffer; } pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1); }

[[[[Adv]]]]: void ff_mspel_motion(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, uint8_t **[[bleedingmediacircle]], op_pixels_func (*pix_op)[4], int motion_x, int motion_y, int h) { Wmv2Context * const w= (Wmv2Context*)s; uint8_t *ptr; int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize; int emu=0; dxy = ((motion_y & 1) << 1) | (motion_x & 1); dxy = 2*dxy + w->hshift; src_x = s->mb_x * 16 + (motion_x >> 1); src_y = s->mb_y * 16 + (motion_y >> 1); v_edge_pos = s->v_edge_pos; src_x = av_clip(src_x, -16, s->width); src_y = av_clip(src_y, -16, s->height); if(src_x<=-16 || src_x >= s->width) dxy &= ~3; if(src_y<=-16 || src_y >= s->height) dxy &= ~4; linesize = s->linesize; uvlinesize = s->uvlinesize; ptr = [[bleedingmediacircle]][0] + (src_y * linesize) + src_x; if(src_x<1 || src_y<1 || src_x + 17 >= s->h_edge_pos || src_y + h+1 >= v_edge_pos){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19, src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos); ptr= s->edge_emu_buffer + 1 + s->linesize; emu=1; } s->dsp.put_mspel_pixels_tab[dxy](dest_y , ptr , linesize); s->dsp.put_mspel_pixels_tab[dxy](dest_y+8 , ptr+8 , linesize); s->dsp.put_mspel_pixels_tab[dxy](dest_y +8*linesize, ptr +8*linesize, linesize); s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize); if(s->flags&CODEC_FLAG_GRAY) return; if (s->out_format == FMT_H263) { dxy = 0; if ((motion_x & 3) != 0) dxy |= 1; if ((motion_y & 3) != 0) dxy |= 2; mx = motion_x >> 2; my = motion_y >> 2; } else { mx = motion_x / 2; my = motion_y / 2; dxy = ((my & 1) << 1) | (mx & 1); mx >>= 1; my >>= 1; } src_x = s->mb_x * 8 + mx; src_y = s->mb_y * 8 + my; src_x = av_clip(src_x, -8, s->width >> 1); if (src_x == (s->width >> 1)) dxy &= ~1; src_y = av_clip(src_y, -8, s->height >> 1); if (src_y == (s->height >> 1)) dxy &= ~2; offset = (src_y * uvlinesize) + src_x; ptr = [[bleedingmediacircle]][1] + offset; if(emu){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr= s->edge_emu_buffer; } pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1); ptr = [[bleedingmediacircle]][2] + offset; if(emu){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr= s->edge_emu_buffer; } pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1); }
--------------------------------------------- Result 389 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 203 / 42 / 144 / 389:  14%|█▍        | 389/2690 [59:30<5:52:02,  9.18s/it][Succeeded / Failed / Skipped / Total] 203 / 42 / 144 / 389:  14%|█▍        | 390/2690 [1:00:21<5:55:55,  9.28s/it][[0 (53%)]] --> [[0 (33%)]] --> Socre: 0.6650667488574982

[[[[Adv]]]]: static int ffmmal_add_packet(AVCodecContext *[[avctx]], AVPacket *avpkt, int is_extradata) { MMALDecodeContext *ctx = [[avctx]]->priv_data; AVBufferRef *buf = NULL; int size = 0; uint8_t *data = (uint8_t *)""; uint8_t *start; int ret = 0; if (avpkt->size) { if (avpkt->buf) { buf = av_buffer_ref(avpkt->buf); size = avpkt->size; data = avpkt->data; } else { buf = av_buffer_alloc(avpkt->size); if (buf) { memcpy(buf->data, avpkt->data, avpkt->size); size = buf->size; data = buf->data; } } if (!buf) { ret = AVERROR(ENOMEM); goto done; } if (!is_extradata) ctx->packets_sent++; } else { if (!ctx->packets_sent) { ctx->eos_sent = 1; ctx->eos_received = 1; goto done; } } start = data; do { FFBufferEntry *buffer = av_mallocz(sizeof(*buffer)); if (!buffer) { ret = AVERROR(ENOMEM); goto done; } buffer->data = data; buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size); if (is_extradata) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG; if (data == start) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START; data += buffer->length; size -= buffer->length; buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts; buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts; if (!size) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END; if (!buffer->length) { buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS; ctx->eos_sent = 1; } if (buf) { buffer->ref = av_buffer_ref(buf); if (!buffer->ref) { av_free(buffer); ret = AVERROR(ENOMEM); goto done; } } if (!ctx->waiting_buffers) ctx->waiting_buffers = buffer; if (ctx->waiting_buffers_tail) ctx->waiting_buffers_tail->next = buffer; ctx->waiting_buffers_tail = buffer; } while (size); done: av_buffer_unref(&buf); return ret; }

[[[[Adv]]]]: static int ffmmal_add_packet(AVCodecContext *[[forepoint]], AVPacket *avpkt, int is_extradata) { MMALDecodeContext *ctx = [[forepoint]]->priv_data; AVBufferRef *buf = NULL; int size = 0; uint8_t *data = (uint8_t *)""; uint8_t *start; int ret = 0; if (avpkt->size) { if (avpkt->buf) { buf = av_buffer_ref(avpkt->buf); size = avpkt->size; data = avpkt->data; } else { buf = av_buffer_alloc(avpkt->size); if (buf) { memcpy(buf->data, avpkt->data, avpkt->size); size = buf->size; data = buf->data; } } if (!buf) { ret = AVERROR(ENOMEM); goto done; } if (!is_extradata) ctx->packets_sent++; } else { if (!ctx->packets_sent) { ctx->eos_sent = 1; ctx->eos_received = 1; goto done; } } start = data; do { FFBufferEntry *buffer = av_mallocz(sizeof(*buffer)); if (!buffer) { ret = AVERROR(ENOMEM); goto done; } buffer->data = data; buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size); if (is_extradata) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG; if (data == start) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START; data += buffer->length; size -= buffer->length; buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts; buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts; if (!size) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END; if (!buffer->length) { buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS; ctx->eos_sent = 1; } if (buf) { buffer->ref = av_buffer_ref(buf); if (!buffer->ref) { av_free(buffer); ret = AVERROR(ENOMEM); goto done; } } if (!ctx->waiting_buffers) ctx->waiting_buffers = buffer; if (ctx->waiting_buffers_tail) ctx->waiting_buffers_tail->next = buffer; ctx->waiting_buffers_tail = buffer; } while (size); done: av_buffer_unref(&buf); return ret; }
--------------------------------------------- Result 390 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int decode_entropy_coded_image(WebPContext *[[s]], enum ImageRole [[role]], int w, int [[h]]) { ImageContext *[[img]]; HuffReader *hg; int i, j, ret, x, y, width; [[img]] = &[[s]]->image[[[role]]]; [[img]]->role = [[role]]; if (![[img]]->frame) { [[img]]->frame = av_frame_alloc(); if (![[img]]->frame) return AVERROR(ENOMEM); } [[img]]->frame->format = AV_PIX_FMT_ARGB; [[img]]->frame->width = w; [[img]]->frame->height = [[h]]; if ([[role]] == IMAGE_ROLE_ARGB && ![[img]]->is_alpha_primary) { ThreadFrame [[pt]] = { .f = [[img]]->frame }; ret = ff_thread_get_buffer([[s]]->avctx, &[[pt]], 0); } else ret = av_frame_get_buffer([[img]]->frame, 1); if (ret < 0) return ret; if (get_bits1(&[[s]]->gb)) { [[img]]->color_cache_bits = get_bits(&[[s]]->gb, 4); if ([[img]]->color_cache_bits < 1 || [[img]]->color_cache_bits > 11) { av_log([[s]]->avctx, AV_LOG_ERROR, "invalid color cache bits: %d\n", [[img]]->color_cache_bits); return AVERROR_INVALIDDATA; } [[img]]->color_cache = av_mallocz_array(1 << [[img]]->color_cache_bits, sizeof(*[[img]]->color_cache)); if (![[img]]->color_cache) return AVERROR(ENOMEM); } else { [[img]]->color_cache_bits = 0; } [[img]]->nb_huffman_groups = 1; if ([[role]] == IMAGE_ROLE_ARGB && get_bits1(&[[s]]->gb)) { ret = decode_entropy_image([[s]]); if (ret < 0) return ret; [[img]]->nb_huffman_groups = [[s]]->nb_huffman_groups; } [[img]]->huffman_groups = av_mallocz_array([[img]]->nb_huffman_groups * HUFFMAN_CODES_PER_META_CODE, sizeof(*[[img]]->huffman_groups)); if (![[img]]->huffman_groups) return AVERROR(ENOMEM); for (i = 0; i < [[img]]->nb_huffman_groups; i++) { hg = &[[img]]->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE]; for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) { int alphabet_size = alphabet_sizes[j]; if (!j && [[img]]->color_cache_bits > 0) alphabet_size += 1 << [[img]]->color_cache_bits; if (get_bits1(&[[s]]->gb)) { read_huffman_code_simple([[s]], &hg[j]); } else { ret = read_huffman_code_normal([[s]], &hg[j], alphabet_size); if (ret < 0) return ret; } } } width = [[img]]->frame->width; if ([[role]] == IMAGE_ROLE_ARGB && [[s]]->reduced_width > 0) width = [[s]]->reduced_width; x = 0; y = 0; while (y < [[img]]->frame->height) { int v; hg = get_huffman_group([[s]], [[img]], x, y); v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &[[s]]->gb); if (v < NUM_LITERAL_CODES) { uint8_t *p = GET_PIXEL([[img]]->frame, x, y); p[2] = v; p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED], &[[s]]->gb); p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE], &[[s]]->gb); p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &[[s]]->gb); if ([[img]]->color_cache_bits) color_cache_put([[img]], AV_RB32(p)); x++; if (x == width) { x = 0; y++; } } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) { int prefix_code, length, distance, ref_x, ref_y; prefix_code = v - NUM_LITERAL_CODES; if (prefix_code < 4) { length = prefix_code + 1; } else { int extra_bits = (prefix_code - 2) >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; length = offset + get_bits(&[[s]]->gb, extra_bits) + 1; } prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &[[s]]->gb); if (prefix_code > 39) { av_log([[s]]->avctx, AV_LOG_ERROR, "distance prefix code too large: %d\n", prefix_code); return AVERROR_INVALIDDATA; } if (prefix_code < 4) { distance = prefix_code + 1; } else { int extra_bits = prefix_code - 2 >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; distance = offset + get_bits(&[[s]]->gb, extra_bits) + 1; } if (distance <= NUM_SHORT_DISTANCES) { int xi = lz77_distance_offsets[distance - 1][0]; int yi = lz77_distance_offsets[distance - 1][1]; distance = FFMAX(1, xi + yi * width); } else { distance -= NUM_SHORT_DISTANCES; } ref_x = x; ref_y = y; if (distance <= x) { ref_x -= distance; distance = 0; } else { ref_x = 0; distance -= x; } while (distance >= width) { ref_y--; distance -= width; } if (distance > 0) { ref_x = width - distance; ref_y--; } ref_x = FFMAX(0, ref_x); ref_y = FFMAX(0, ref_y); for (i = 0; i < length; i++) { uint8_t *p_ref = GET_PIXEL([[img]]->frame, ref_x, ref_y); uint8_t *p = GET_PIXEL([[img]]->frame, x, y); AV_COPY32(p, p_ref); if ([[img]]->color_cache_bits) color_cache_put([[img]], AV_RB32(p)); x++; ref_x++; if (x == width) { x = 0; y++; } if (ref_x == width) { ref_x = 0; ref_y++; } if (y == [[img]]->frame->height || ref_y == [[img]]->frame->height) break; } } else { uint8_t *p = GET_PIXEL([[img]]->frame, x, y); int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES); if (![[img]]->color_cache_bits) { av_log([[s]]->avctx, AV_LOG_ERROR, "color cache not found\n"); return AVERROR_INVALIDDATA; } if (cache_idx >= 1 << [[img]]->color_cache_bits) { av_log([[s]]->avctx, AV_LOG_ERROR, "color cache index out-of-bounds\n"); return AVERROR_INVALIDDATA; } AV_WB32(p, [[img]]->color_cache[cache_idx]); x++; if (x == width) { x = 0; y++; } } } return 0; }

[[[[Adv]]]]: static int decode_entropy_coded_image(WebPContext *[[pose]], enum ImageRole [[profile]], int w, int [[vi]]) { ImageContext *[[jagen]]; HuffReader *hg; int i, j, ret, x, y, width; [[jagen]] = &[[pose]]->image[[[profile]]]; [[jagen]]->role = [[profile]]; if (![[jagen]]->frame) { [[jagen]]->frame = av_frame_alloc(); if (![[jagen]]->frame) return AVERROR(ENOMEM); } [[jagen]]->frame->format = AV_PIX_FMT_ARGB; [[jagen]]->frame->width = w; [[jagen]]->frame->height = [[vi]]; if ([[profile]] == IMAGE_ROLE_ARGB && ![[jagen]]->is_alpha_primary) { ThreadFrame [[pv]] = { .f = [[jagen]]->frame }; ret = ff_thread_get_buffer([[pose]]->avctx, &[[pv]], 0); } else ret = av_frame_get_buffer([[jagen]]->frame, 1); if (ret < 0) return ret; if (get_bits1(&[[pose]]->gb)) { [[jagen]]->color_cache_bits = get_bits(&[[pose]]->gb, 4); if ([[jagen]]->color_cache_bits < 1 || [[jagen]]->color_cache_bits > 11) { av_log([[pose]]->avctx, AV_LOG_ERROR, "invalid color cache bits: %d\n", [[jagen]]->color_cache_bits); return AVERROR_INVALIDDATA; } [[jagen]]->color_cache = av_mallocz_array(1 << [[jagen]]->color_cache_bits, sizeof(*[[jagen]]->color_cache)); if (![[jagen]]->color_cache) return AVERROR(ENOMEM); } else { [[jagen]]->color_cache_bits = 0; } [[jagen]]->nb_huffman_groups = 1; if ([[profile]] == IMAGE_ROLE_ARGB && get_bits1(&[[pose]]->gb)) { ret = decode_entropy_image([[pose]]); if (ret < 0) return ret; [[jagen]]->nb_huffman_groups = [[pose]]->nb_huffman_groups; } [[jagen]]->huffman_groups = av_mallocz_array([[jagen]]->nb_huffman_groups * HUFFMAN_CODES_PER_META_CODE, sizeof(*[[jagen]]->huffman_groups)); if (![[jagen]]->huffman_groups) return AVERROR(ENOMEM); for (i = 0; i < [[jagen]]->nb_huffman_groups; i++) { hg = &[[jagen]]->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE]; for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) { int alphabet_size = alphabet_sizes[j]; if (!j && [[jagen]]->color_cache_bits > 0) alphabet_size += 1 << [[jagen]]->color_cache_bits; if (get_bits1(&[[pose]]->gb)) { read_huffman_code_simple([[pose]], &hg[j]); } else { ret = read_huffman_code_normal([[pose]], &hg[j], alphabet_size); if (ret < 0) return ret; } } } width = [[jagen]]->frame->width; if ([[profile]] == IMAGE_ROLE_ARGB && [[pose]]->reduced_width > 0) width = [[pose]]->reduced_width; x = 0; y = 0; while (y < [[jagen]]->frame->height) { int v; hg = get_huffman_group([[pose]], [[jagen]], x, y); v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &[[pose]]->gb); if (v < NUM_LITERAL_CODES) { uint8_t *p = GET_PIXEL([[jagen]]->frame, x, y); p[2] = v; p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED], &[[pose]]->gb); p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE], &[[pose]]->gb); p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &[[pose]]->gb); if ([[jagen]]->color_cache_bits) color_cache_put([[jagen]], AV_RB32(p)); x++; if (x == width) { x = 0; y++; } } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) { int prefix_code, length, distance, ref_x, ref_y; prefix_code = v - NUM_LITERAL_CODES; if (prefix_code < 4) { length = prefix_code + 1; } else { int extra_bits = (prefix_code - 2) >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; length = offset + get_bits(&[[pose]]->gb, extra_bits) + 1; } prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &[[pose]]->gb); if (prefix_code > 39) { av_log([[pose]]->avctx, AV_LOG_ERROR, "distance prefix code too large: %d\n", prefix_code); return AVERROR_INVALIDDATA; } if (prefix_code < 4) { distance = prefix_code + 1; } else { int extra_bits = prefix_code - 2 >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; distance = offset + get_bits(&[[pose]]->gb, extra_bits) + 1; } if (distance <= NUM_SHORT_DISTANCES) { int xi = lz77_distance_offsets[distance - 1][0]; int yi = lz77_distance_offsets[distance - 1][1]; distance = FFMAX(1, xi + yi * width); } else { distance -= NUM_SHORT_DISTANCES; } ref_x = x; ref_y = y; if (distance <= x) { ref_x -= distance; distance = 0; } else { ref_x = 0; distance -= x; } while (distance >= width) { ref_y--; distance -= width; } if (distance > 0) { ref_x = width - distance; ref_y--; } ref_x = FFMAX(0, ref_x); ref_y = FFMAX(0, ref_y); for (i = 0; i < length; i++) { uint8_t *p_ref = GET_PIXEL([[jagen]]->frame, ref_x, ref_y); uint8_t *p = GET_PIXEL([[jagen]]->frame, x, y); AV_COPY32(p, p_ref); if ([[jagen]]->color_cache_bits) color_cache_put([[jagen]], AV_RB32(p)); x++; ref_x++; if (x == width) { x = 0; y++; } if (ref_x == width) { ref_x = 0; ref_y++; } if (y == [[jagen]]->frame->height || ref_y == [[jagen]]->frame->height) break; } } else { uint8_t *p = GET_PIXEL([[jagen]]->frame, x, y); int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES); if (![[jagen]]->color_cache_bits) { av_log([[pose]]->avctx, AV_LOG_ERROR, "color cache not found\n"); return AVERROR_INVALIDDATA; } if (cache_idx >= 1 << [[jagen]]->color_cache_bits) { av_log([[pose]]->avctx, AV_LOG_ERROR, "color cache index out-of-bounds\n"); return AVERROR_INVALIDDATA; } AV_WB32(p, [[jagen]]->color_cache[cache_idx]); x++; if (x == width) { x = 0; y++; } } } return 0; }[Succeeded / Failed / Skipped / Total] 203 / 43 / 144 / 390:  14%|█▍        | 390/2690 [1:00:21<5:55:55,  9.28s/it][Succeeded / Failed / Skipped / Total] 203 / 43 / 144 / 390:  15%|█▍        | 391/2690 [1:00:21<5:54:54,  9.26s/it][Succeeded / Failed / Skipped / Total] 203 / 43 / 145 / 391:  15%|█▍        | 391/2690 [1:00:21<5:54:54,  9.26s/it][Succeeded / Failed / Skipped / Total] 203 / 43 / 145 / 391:  15%|█▍        | 392/2690 [1:00:22<5:53:53,  9.24s/it][Succeeded / Failed / Skipped / Total] 203 / 43 / 146 / 392:  15%|█▍        | 392/2690 [1:00:22<5:53:53,  9.24s/it][Succeeded / Failed / Skipped / Total] 203 / 43 / 146 / 392:  15%|█▍        | 393/2690 [1:00:56<5:56:12,  9.30s/it]
--------------------------------------------- Result 391 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table) { CachedL2Table *entry; entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset); if (entry) { qed_unref_l2_cache_entry(entry); qed_unref_l2_cache_entry(l2_table); return; } if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) { entry = QTAILQ_FIRST(&l2_cache->entries); QTAILQ_REMOVE(&l2_cache->entries, entry, node); l2_cache->n_entries--; qed_unref_l2_cache_entry(entry); } l2_cache->n_entries++; QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node); }
--------------------------------------------- Result 392 ---------------------------------------------
[[0 (3%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c, AVCodecContext *avctx, unsigned high_bit_depth) { int cpu_flags = av_get_cpu_flags(); if (EXTERNAL_MMX(cpu_flags)) { if (!high_bit_depth) c->get_pixels = ff_get_pixels_mmx; c->diff_pixels = ff_diff_pixels_mmx; } if (EXTERNAL_SSE2(cpu_flags)) { if (!high_bit_depth) c->get_pixels = ff_get_pixels_sse2; c->diff_pixels = ff_diff_pixels_sse2; } }
--------------------------------------------- Result 393 ---------------------------------------------
[[0 (99%)]] --> [[0 (45%)]] --> Socre: 0.5468564927577972

[[[[Adv]]]]: static int svq1_encode_plane(SVQ1Context *[[s]], int plane, unsigned char *src_plane, unsigned char *ref_plane, unsigned char *[[decoded_plane]], int [[width]], int height, int src_stride, int stride) { const AVFrame *f = [[s]]->avctx->coded_frame; int x, y; int i; int block_width, block_height; int [[level]]; int threshold[6]; uint8_t *src = [[s]]->scratchbuf + stride * 16; const int lambda = (f->quality * f->quality) >> (2 * FF_LAMBDA_SHIFT); threshold[5] = QUALITY_THRESHOLD; for ([[level]] = 4; [[level]] >= 0; [[level]]--) threshold[[[level]]] = threshold[[[level]] + 1] * THRESHOLD_MULTIPLIER; block_width = ([[width]] + 15) / 16; block_height = (height + 15) / 16; if (f->pict_type == AV_PICTURE_TYPE_P) { [[s]]->m.avctx = [[s]]->avctx; [[s]]->m.current_picture_ptr = &[[s]]->m.current_picture; [[s]]->m.last_picture_ptr = &[[s]]->m.last_picture; [[s]]->m.last_picture.f.data[0] = ref_plane; [[s]]->m.linesize = [[s]]->m.last_picture.f.linesize[0] = [[s]]->m.new_picture.f.linesize[0] = [[s]]->m.current_picture.f.linesize[0] = stride; [[s]]->m.width = [[width]]; [[s]]->m.height = height; [[s]]->m.mb_width = block_width; [[s]]->m.mb_height = block_height; [[s]]->m.mb_stride = [[s]]->m.mb_width + 1; [[s]]->m.b8_stride = 2 * [[s]]->m.mb_width + 1; [[s]]->m.f_code = 1; [[s]]->m.pict_type = f->pict_type; [[s]]->m.me_method = [[s]]->avctx->me_method; [[s]]->m.me.scene_change_score = 0; [[s]]->m.flags = [[s]]->avctx->flags; [[s]]->m.lambda = f->quality; [[s]]->m.qscale = [[s]]->m.lambda * 139 + FF_LAMBDA_SCALE * 64 >> FF_LAMBDA_SHIFT + 7; [[s]]->m.lambda2 = [[s]]->m.lambda * [[s]]->m.lambda + FF_LAMBDA_SCALE / 2 >> FF_LAMBDA_SHIFT; if (![[s]]->motion_val8[plane]) { [[s]]->motion_val8[plane] = av_mallocz(([[s]]->m.b8_stride * block_height * 2 + 2) * 2 * sizeof(int16_t)); [[s]]->motion_val16[plane] = av_mallocz(([[s]]->m.mb_stride * (block_height + 2) + 1) * 2 * sizeof(int16_t)); } [[s]]->m.mb_type = [[s]]->mb_type; [[s]]->m.current_picture.mb_mean = (uint8_t *)[[s]]->dummy; [[s]]->m.current_picture.mb_var = (uint16_t *)[[s]]->dummy; [[s]]->m.current_picture.mc_mb_var = (uint16_t *)[[s]]->dummy; [[s]]->m.current_picture.mb_type = [[s]]->dummy; [[s]]->m.current_picture.motion_val[0] = [[s]]->motion_val8[plane] + 2; [[s]]->m.p_mv_table = [[s]]->motion_val16[plane] + [[s]]->m.mb_stride + 1; [[s]]->m.dsp = [[s]]->dsp; ff_init_me(&[[s]]->m); [[s]]->m.me.dia_size = [[s]]->avctx->dia_size; [[s]]->m.first_slice_line = 1; for (y = 0; y < block_height; y++) { [[s]]->m.new_picture.f.data[0] = src - y * 16 * stride; [[s]]->m.mb_y = y; for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride], [[width]]); for (x = [[width]]; x < 16 * block_width; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * block_height; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width); for (x = 0; x < block_width; x++) { [[s]]->m.mb_x = x; ff_init_block_index(&[[s]]->m); ff_update_block_index(&[[s]]->m); ff_estimate_p_frame_motion(&[[s]]->m, x, y); } [[s]]->m.first_slice_line = 0; } ff_fix_long_p_mvs(&[[s]]->m); ff_fix_long_mvs(&[[s]]->m, NULL, 0, [[s]]->m.p_mv_table, [[s]]->m.f_code, CANDIDATE_MB_TYPE_INTER, 0); } [[s]]->m.first_slice_line = 1; for (y = 0; y < block_height; y++) { for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride], [[width]]); for (x = [[width]]; x < 16 * block_width; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * block_height; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width); [[s]]->m.mb_y = y; for (x = 0; x < block_width; x++) { uint8_t reorder_buffer[3][6][7 * 32]; int count[3][6]; int offset = y * 16 * stride + x * 16; uint8_t *decoded = [[decoded_plane]] + offset; uint8_t *ref = ref_plane + offset; int score[4] = { 0, 0, 0, 0 }, best; uint8_t *temp = [[s]]->scratchbuf; if ([[s]]->pb.buf_end - [[s]]->pb.buf - (put_bits_count(&[[s]]->pb) >> 3) < 3000) { av_log([[s]]->avctx, AV_LOG_ERROR, "encoded frame too large\n"); return -1; } [[s]]->m.mb_x = x; ff_init_block_index(&[[s]]->m); ff_update_block_index(&[[s]]->m); if (f->pict_type == AV_PICTURE_TYPE_I || ([[s]]->m.mb_type[x + y * [[s]]->m.mb_stride] & CANDIDATE_MB_TYPE_INTRA)) { for (i = 0; i < 6; i++) init_put_bits(&[[s]]->reorder_pb[i], reorder_buffer[0][i], 7 * 32); if (f->pict_type == AV_PICTURE_TYPE_P) { const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA]; put_bits(&[[s]]->reorder_pb[5], vlc[1], vlc[0]); score[0] = vlc[1] * lambda; } score[0] += encode_block([[s]], src + 16 * x, NULL, temp, stride, 5, 64, lambda, 1); for (i = 0; i < 6; i++) { count[0][i] = put_bits_count(&[[s]]->reorder_pb[i]); flush_put_bits(&[[s]]->reorder_pb[i]); } } else score[0] = INT_MAX; best = 0; if (f->pict_type == AV_PICTURE_TYPE_P) { const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER]; int mx, my, pred_x, pred_y, dxy; int16_t *motion_ptr; motion_ptr = ff_h263_pred_motion(&[[s]]->m, 0, 0, &pred_x, &pred_y); if ([[s]]->m.mb_type[x + y * [[s]]->m.mb_stride] & CANDIDATE_MB_TYPE_INTER) { for (i = 0; i < 6; i++) init_put_bits(&[[s]]->reorder_pb[i], reorder_buffer[1][i], 7 * 32); put_bits(&[[s]]->reorder_pb[5], vlc[1], vlc[0]); [[s]]->m.pb = [[s]]->reorder_pb[5]; mx = motion_ptr[0]; my = motion_ptr[1]; assert(mx >= -32 && mx <= 31); assert(my >= -32 && my <= 31); assert(pred_x >= -32 && pred_x <= 31); assert(pred_y >= -32 && pred_y <= 31); ff_h263_encode_motion(&[[s]]->m, mx - pred_x, 1); ff_h263_encode_motion(&[[s]]->m, my - pred_y, 1); [[s]]->reorder_pb[5] = [[s]]->m.pb; score[1] += lambda * put_bits_count(&[[s]]->reorder_pb[5]); dxy = (mx & 1) + 2 * (my & 1); [[s]]->hdsp.put_pixels_tab[0][dxy](temp + 16, ref + (mx >> 1) + stride * (my >> 1), stride, 16); score[1] += encode_block([[s]], src + 16 * x, temp + 16, decoded, stride, 5, 64, lambda, 0); best = score[1] <= score[0]; vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP]; score[2] = [[s]]->dsp.sse[0](NULL, src + 16 * x, ref, stride, 16); score[2] += vlc[1] * lambda; if (score[2] < score[best] && mx == 0 && my == 0) { best = 2; [[s]]->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16); for (i = 0; i < 6; i++) count[2][i] = 0; put_bits(&[[s]]->pb, vlc[1], vlc[0]); } } if (best == 1) { for (i = 0; i < 6; i++) { count[1][i] = put_bits_count(&[[s]]->reorder_pb[i]); flush_put_bits(&[[s]]->reorder_pb[i]); } } else { motion_ptr[0] = motion_ptr[1] = motion_ptr[2] = motion_ptr[3] = motion_ptr[0 + 2 * [[s]]->m.b8_stride] = motion_ptr[1 + 2 * [[s]]->m.b8_stride] = motion_ptr[2 + 2 * [[s]]->m.b8_stride] = motion_ptr[3 + 2 * [[s]]->m.b8_stride] = 0; } } [[s]]->rd_total += score[best]; for (i = 5; i >= 0; i--) avpriv_copy_bits(&[[s]]->pb, reorder_buffer[best][i], count[best][i]); if (best == 0) [[s]]->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16); } [[s]]->m.first_slice_line = 0; } return 0; }

[[[[Adv]]]]: static int svq1_encode_plane(SVQ1Context *[[с]], int plane, unsigned char *src_plane, unsigned char *ref_plane, unsigned char *[[geotedclasspaper]], int [[ref]], int height, int src_stride, int stride) { const AVFrame *f = [[с]]->avctx->coded_frame; int x, y; int i; int block_width, block_height; int [[direction]]; int threshold[6]; uint8_t *src = [[с]]->scratchbuf + stride * 16; const int lambda = (f->quality * f->quality) >> (2 * FF_LAMBDA_SHIFT); threshold[5] = QUALITY_THRESHOLD; for ([[direction]] = 4; [[direction]] >= 0; [[direction]]--) threshold[[[direction]]] = threshold[[[direction]] + 1] * THRESHOLD_MULTIPLIER; block_width = ([[ref]] + 15) / 16; block_height = (height + 15) / 16; if (f->pict_type == AV_PICTURE_TYPE_P) { [[с]]->m.avctx = [[с]]->avctx; [[с]]->m.current_picture_ptr = &[[с]]->m.current_picture; [[с]]->m.last_picture_ptr = &[[с]]->m.last_picture; [[с]]->m.last_picture.f.data[0] = ref_plane; [[с]]->m.linesize = [[с]]->m.last_picture.f.linesize[0] = [[с]]->m.new_picture.f.linesize[0] = [[с]]->m.current_picture.f.linesize[0] = stride; [[с]]->m.width = [[ref]]; [[с]]->m.height = height; [[с]]->m.mb_width = block_width; [[с]]->m.mb_height = block_height; [[с]]->m.mb_stride = [[с]]->m.mb_width + 1; [[с]]->m.b8_stride = 2 * [[с]]->m.mb_width + 1; [[с]]->m.f_code = 1; [[с]]->m.pict_type = f->pict_type; [[с]]->m.me_method = [[с]]->avctx->me_method; [[с]]->m.me.scene_change_score = 0; [[с]]->m.flags = [[с]]->avctx->flags; [[с]]->m.lambda = f->quality; [[с]]->m.qscale = [[с]]->m.lambda * 139 + FF_LAMBDA_SCALE * 64 >> FF_LAMBDA_SHIFT + 7; [[с]]->m.lambda2 = [[с]]->m.lambda * [[с]]->m.lambda + FF_LAMBDA_SCALE / 2 >> FF_LAMBDA_SHIFT; if (![[с]]->motion_val8[plane]) { [[с]]->motion_val8[plane] = av_mallocz(([[с]]->m.b8_stride * block_height * 2 + 2) * 2 * sizeof(int16_t)); [[с]]->motion_val16[plane] = av_mallocz(([[с]]->m.mb_stride * (block_height + 2) + 1) * 2 * sizeof(int16_t)); } [[с]]->m.mb_type = [[с]]->mb_type; [[с]]->m.current_picture.mb_mean = (uint8_t *)[[с]]->dummy; [[с]]->m.current_picture.mb_var = (uint16_t *)[[с]]->dummy; [[с]]->m.current_picture.mc_mb_var = (uint16_t *)[[с]]->dummy; [[с]]->m.current_picture.mb_type = [[с]]->dummy; [[с]]->m.current_picture.motion_val[0] = [[с]]->motion_val8[plane] + 2; [[с]]->m.p_mv_table = [[с]]->motion_val16[plane] + [[с]]->m.mb_stride + 1; [[с]]->m.dsp = [[с]]->dsp; ff_init_me(&[[с]]->m); [[с]]->m.me.dia_size = [[с]]->avctx->dia_size; [[с]]->m.first_slice_line = 1; for (y = 0; y < block_height; y++) { [[с]]->m.new_picture.f.data[0] = src - y * 16 * stride; [[с]]->m.mb_y = y; for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride], [[ref]]); for (x = [[ref]]; x < 16 * block_width; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * block_height; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width); for (x = 0; x < block_width; x++) { [[с]]->m.mb_x = x; ff_init_block_index(&[[с]]->m); ff_update_block_index(&[[с]]->m); ff_estimate_p_frame_motion(&[[с]]->m, x, y); } [[с]]->m.first_slice_line = 0; } ff_fix_long_p_mvs(&[[с]]->m); ff_fix_long_mvs(&[[с]]->m, NULL, 0, [[с]]->m.p_mv_table, [[с]]->m.f_code, CANDIDATE_MB_TYPE_INTER, 0); } [[с]]->m.first_slice_line = 1; for (y = 0; y < block_height; y++) { for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride], [[ref]]); for (x = [[ref]]; x < 16 * block_width; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * block_height; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width); [[с]]->m.mb_y = y; for (x = 0; x < block_width; x++) { uint8_t reorder_buffer[3][6][7 * 32]; int count[3][6]; int offset = y * 16 * stride + x * 16; uint8_t *decoded = [[geotedclasspaper]] + offset; uint8_t *ref = ref_plane + offset; int score[4] = { 0, 0, 0, 0 }, best; uint8_t *temp = [[с]]->scratchbuf; if ([[с]]->pb.buf_end - [[с]]->pb.buf - (put_bits_count(&[[с]]->pb) >> 3) < 3000) { av_log([[с]]->avctx, AV_LOG_ERROR, "encoded frame too large\n"); return -1; } [[с]]->m.mb_x = x; ff_init_block_index(&[[с]]->m); ff_update_block_index(&[[с]]->m); if (f->pict_type == AV_PICTURE_TYPE_I || ([[с]]->m.mb_type[x + y * [[с]]->m.mb_stride] & CANDIDATE_MB_TYPE_INTRA)) { for (i = 0; i < 6; i++) init_put_bits(&[[с]]->reorder_pb[i], reorder_buffer[0][i], 7 * 32); if (f->pict_type == AV_PICTURE_TYPE_P) { const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA]; put_bits(&[[с]]->reorder_pb[5], vlc[1], vlc[0]); score[0] = vlc[1] * lambda; } score[0] += encode_block([[с]], src + 16 * x, NULL, temp, stride, 5, 64, lambda, 1); for (i = 0; i < 6; i++) { count[0][i] = put_bits_count(&[[с]]->reorder_pb[i]); flush_put_bits(&[[с]]->reorder_pb[i]); } } else score[0] = INT_MAX; best = 0; if (f->pict_type == AV_PICTURE_TYPE_P) { const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER]; int mx, my, pred_x, pred_y, dxy; int16_t *motion_ptr; motion_ptr = ff_h263_pred_motion(&[[с]]->m, 0, 0, &pred_x, &pred_y); if ([[с]]->m.mb_type[x + y * [[с]]->m.mb_stride] & CANDIDATE_MB_TYPE_INTER) { for (i = 0; i < 6; i++) init_put_bits(&[[с]]->reorder_pb[i], reorder_buffer[1][i], 7 * 32); put_bits(&[[с]]->reorder_pb[5], vlc[1], vlc[0]); [[с]]->m.pb = [[с]]->reorder_pb[5]; mx = motion_ptr[0]; my = motion_ptr[1]; assert(mx >= -32 && mx <= 31); assert(my >= -32 && my <= 31); assert(pred_x >= -32 && pred_x <= 31); assert(pred_y >= -32 && pred_y <= 31); ff_h263_encode_motion(&[[с]]->m, mx - pred_x, 1); ff_h263_encode_motion(&[[с]]->m, my - pred_y, 1); [[с]]->reorder_pb[5] = [[с]]->m.pb; score[1] += lambda * put_bits_count(&[[с]]->reorder_pb[5]); dxy = (mx & 1) + 2 * (my & 1); [[с]]->hdsp.put_pixels_tab[0][dxy](temp + 16, ref + (mx >> 1) + stride * (my >> 1), stride, 16); score[1] += encode_block([[с]], src + 16 * x, temp + 16, decoded, stride, 5, 64, lambda, 0); best = score[1] <= score[0]; vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP]; score[2] = [[с]]->dsp.sse[0](NULL, src + 16 * x, ref, stride, 16); score[2] += vlc[1] * lambda; if (score[2] < score[best] && mx == 0 && my == 0) { best = 2; [[с]]->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16); for (i = 0; i < 6; i++) count[2][i] = 0; put_bits(&[[с]]->pb, vlc[1], vlc[0]); } } if (best == 1) { for (i = 0; i < 6; i++) { count[1][i] = put_bits_count(&[[с]]->reorder_pb[i]); flush_put_bits(&[[с]]->reorder_pb[i]); } } else { motion_ptr[0] = motion_ptr[1] = motion_ptr[2] = motion_ptr[3] = motion_ptr[0 + 2 * [[с]]->m.b8_stride] = motion_ptr[1 + 2 * [[с]]->m.b8_stride] = motion_ptr[2 + 2 * [[с]]->m.b8_stride] = motion_ptr[3 + 2 * [[с]]->m.b8_stride] = 0; } } [[с]]->rd_total += score[best]; for (i = 5; i >= 0; i--) avpriv_copy_bits(&[[с]]->pb, reorder_buffer[best][i], count[best][i]); if (best == 0) [[с]]->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16); } [[с]]->m.first_slice_line = 0; } return 0; }[Succeeded / Failed / Skipped / Total] 204 / 43 / 146 / 393:  15%|█▍        | 393/2690 [1:00:56<5:56:12,  9.30s/it][Succeeded / Failed / Skipped / Total] 204 / 43 / 146 / 393:  15%|█▍        | 394/2690 [1:00:57<5:55:11,  9.28s/it][Succeeded / Failed / Skipped / Total] 204 / 43 / 147 / 394:  15%|█▍        | 394/2690 [1:00:57<5:55:11,  9.28s/it][Succeeded / Failed / Skipped / Total] 204 / 43 / 147 / 394:  15%|█▍        | 395/2690 [1:01:09<5:55:22,  9.29s/it][Succeeded / Failed / Skipped / Total] 204 / 44 / 147 / 395:  15%|█▍        | 395/2690 [1:01:09<5:55:22,  9.29s/it][Succeeded / Failed / Skipped / Total] 204 / 44 / 147 / 395:  15%|█▍        | 396/2690 [1:01:22<5:55:34,  9.30s/it][Succeeded / Failed / Skipped / Total] 205 / 44 / 147 / 396:  15%|█▍        | 396/2690 [1:01:22<5:55:34,  9.30s/it][Succeeded / Failed / Skipped / Total] 205 / 44 / 147 / 396:  15%|█▍        | 397/2690 [1:01:47<5:56:51,  9.34s/it][Succeeded / Failed / Skipped / Total] 205 / 45 / 147 / 397:  15%|█▍        | 397/2690 [1:01:47<5:56:51,  9.34s/it][Succeeded / Failed / Skipped / Total] 205 / 45 / 147 / 397:  15%|█▍        | 398/2690 [1:02:06<5:57:41,  9.36s/it]
--------------------------------------------- Result 394 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt, int dump_payload, AVRational time_base) { HEXDUMP_PRINT("stream #%d:\n", pkt->stream_index); HEXDUMP_PRINT(" keyframe=%d\n", (pkt->flags & AV_PKT_FLAG_KEY) != 0); HEXDUMP_PRINT(" duration=%0.3f\n", pkt->duration * av_q2d(time_base)); HEXDUMP_PRINT(" dts="); if (pkt->dts == AV_NOPTS_VALUE) HEXDUMP_PRINT("N/A"); else HEXDUMP_PRINT("%0.3f", pkt->dts * av_q2d(time_base)); HEXDUMP_PRINT(" pts="); if (pkt->pts == AV_NOPTS_VALUE) HEXDUMP_PRINT("N/A"); else HEXDUMP_PRINT("%0.3f", pkt->pts * av_q2d(time_base)); HEXDUMP_PRINT("\n"); HEXDUMP_PRINT(" size=%d\n", pkt->size); if (dump_payload) av_hex_dump(f, pkt->data, pkt->size); }
--------------------------------------------- Result 395 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void write_frame(AVFormatContext *[[s]], AVPacket *pkt, OutputStream *[[ost]]) { AVBitStreamFilterContext *[[bsfc]] = [[ost]]->bitstream_filters; AVCodecContext *[[avctx]] = [[ost]]->st->codec; int ret; if (([[avctx]]->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) || ([[avctx]]->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0)) pkt->pts = pkt->dts = AV_NOPTS_VALUE; if ([[avctx]]->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) { int64_t [[max]] = [[ost]]->st->cur_dts + !([[s]]->oformat->flags & AVFMT_TS_NONSTRICT); if ([[ost]]->st->cur_dts && [[ost]]->st->cur_dts != AV_NOPTS_VALUE && [[max]] > pkt->dts) { av_log([[s]], [[max]] - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, "Audio timestamp %"PRId64" < %"PRId64" invalid, cliping\n", pkt->dts, [[max]]); pkt->pts = pkt->dts = [[max]]; if (!([[avctx]]->codec_type == AVMEDIA_TYPE_VIDEO && [[avctx]]->codec)) { if ([[ost]]->frame_number >= [[ost]]->max_frames) { av_free_packet(pkt); return; [[ost]]->frame_number++; while ([[bsfc]]) { AVPacket new_pkt = *pkt; int a = av_bitstream_filter_filter([[bsfc]], [[avctx]], NULL, &new_pkt.data, &new_pkt.size, pkt->data, pkt->size, pkt->flags & AV_PKT_FLAG_KEY); if (a > 0) { av_free_packet(pkt); new_pkt.destruct = av_destruct_packet; } else if (a < 0) { av_log(NULL, AV_LOG_ERROR, "Failed to open bitstream filter %s for stream %d with codec %s", [[bsfc]]->filter->name, pkt->stream_index, [[avctx]]->codec ? [[avctx]]->codec->name : "copy"); print_error("", a); if (exit_on_error) exit_program(1); *pkt = new_pkt; [[bsfc]] = [[bsfc]]->next; pkt->stream_index = [[ost]]->index; ret = av_interleaved_write_frame([[s]], pkt); if (ret < 0) { print_error("av_interleaved_write_frame()", ret); exit_program(1);

[[[[Adv]]]]: static void write_frame(AVFormatContext *[[music]], AVPacket *pkt, OutputStream *[[volт]]) { AVBitStreamFilterContext *[[falav]] = [[volт]]->bitstream_filters; AVCodecContext *[[jagtq]] = [[volт]]->st->codec; int ret; if (([[jagtq]]->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) || ([[jagtq]]->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0)) pkt->pts = pkt->dts = AV_NOPTS_VALUE; if ([[jagtq]]->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) { int64_t [[music]] = [[volт]]->st->cur_dts + !([[music]]->oformat->flags & AVFMT_TS_NONSTRICT); if ([[volт]]->st->cur_dts && [[volт]]->st->cur_dts != AV_NOPTS_VALUE && [[music]] > pkt->dts) { av_log([[music]], [[music]] - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, "Audio timestamp %"PRId64" < %"PRId64" invalid, cliping\n", pkt->dts, [[music]]); pkt->pts = pkt->dts = [[music]]; if (!([[jagtq]]->codec_type == AVMEDIA_TYPE_VIDEO && [[jagtq]]->codec)) { if ([[volт]]->frame_number >= [[volт]]->max_frames) { av_free_packet(pkt); return; [[volт]]->frame_number++; while ([[falav]]) { AVPacket new_pkt = *pkt; int a = av_bitstream_filter_filter([[falav]], [[jagtq]], NULL, &new_pkt.data, &new_pkt.size, pkt->data, pkt->size, pkt->flags & AV_PKT_FLAG_KEY); if (a > 0) { av_free_packet(pkt); new_pkt.destruct = av_destruct_packet; } else if (a < 0) { av_log(NULL, AV_LOG_ERROR, "Failed to open bitstream filter %s for stream %d with codec %s", [[falav]]->filter->name, pkt->stream_index, [[jagtq]]->codec ? [[jagtq]]->codec->name : "copy"); print_error("", a); if (exit_on_error) exit_program(1); *pkt = new_pkt; [[falav]] = [[falav]]->next; pkt->stream_index = [[volт]]->index; ret = av_interleaved_write_frame([[music]], pkt); if (ret < 0) { print_error("av_interleaved_write_frame()", ret); exit_program(1);
--------------------------------------------- Result 396 ---------------------------------------------
[[0 (4%)]] --> [[0 (87%)]] --> Socre: 0.8651530742645264

[[[[Adv]]]]: static void handle_mousewheel(SDL_Event *ev) { struct sdl2_console *[[scon]] = get_scon_from_window(ev->key.windowID); SDL_MouseWheelEvent *wev = &ev->wheel; InputButton btn; if (wev->y > 0) { btn = INPUT_BUTTON_WHEEL_UP; } else if (wev->y < 0) { btn = INPUT_BUTTON_WHEEL_DOWN; } else { return; } qemu_input_queue_btn([[scon]]->dcl.con, btn, "True" == "True"); qemu_input_event_sync(); qemu_input_queue_btn([[scon]]->dcl.con, btn, "False" != "False"); qemu_input_event_sync(); }

[[[[Adv]]]]: static void handle_mousewheel(SDL_Event *ev) { struct sdl2_console *[[carpᆫ]] = get_scon_from_window(ev->key.windowID); SDL_MouseWheelEvent *wev = &ev->wheel; InputButton btn; if (wev->y > 0) { btn = INPUT_BUTTON_WHEEL_UP; } else if (wev->y < 0) { btn = INPUT_BUTTON_WHEEL_DOWN; } else { return; } qemu_input_queue_btn([[carpᆫ]]->dcl.con, btn, "True" == "True"); qemu_input_event_sync(); qemu_input_queue_btn([[carpᆫ]]->dcl.con, btn, "False" != "False"); qemu_input_event_sync(); }
--------------------------------------------- Result 397 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static USBDevice *usb_net_init(const char *[[cmdline]]) { USBDevice *[[dev]]; QemuOpts *[[opts]]; int [[idx]]; [[opts]] = qemu_opts_parse(&qemu_net_opts, [[cmdline]], NULL); if (![[opts]]) { qemu_opt_set([[opts]], "type", "nic"); qemu_opt_set([[opts]], "model", "usb"); [[idx]] = net_client_init(NULL, [[opts]], 0); if ([[idx]] == -1) { [[dev]] = usb_create(NULL , "usb-net"); qdev_set_nic_properties(&[[dev]]->qdev, &nd_table[[[idx]]]); qdev_init_nofail(&[[dev]]->qdev); return [[dev]];

[[[[Adv]]]]: static USBDevice *usb_net_init(const char *[[sunldn]]) { USBDevice *[[page]]; QemuOpts *[[uri]]; int [[does]]; [[uri]] = qemu_opts_parse(&qemu_net_opts, [[sunldn]], NULL); if (![[uri]]) { qemu_opt_set([[uri]], "type", "nic"); qemu_opt_set([[uri]], "model", "usb"); [[does]] = net_client_init(NULL, [[uri]], 0); if ([[does]] == -1) { [[page]] = usb_create(NULL , "usb-net"); qdev_set_nic_properties(&[[page]]->qdev, &nd_table[[[does]]]); qdev_init_nofail(&[[page]]->qdev); return [[page]];
--------------------------------------------- Result 398 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 206 / 45 / 147 / 398:  15%|█▍        | 398/2690 [1:02:06<5:57:41,  9.36s/it][Succeeded / Failed / Skipped / Total] 206 / 45 / 147 / 398:  15%|█▍        | 399/2690 [1:02:07<5:56:41,  9.34s/it][Succeeded / Failed / Skipped / Total] 206 / 45 / 148 / 399:  15%|█▍        | 399/2690 [1:02:07<5:56:41,  9.34s/it][Succeeded / Failed / Skipped / Total] 206 / 45 / 148 / 399:  15%|█▍        | 400/2690 [1:02:24<5:57:19,  9.36s/it][Succeeded / Failed / Skipped / Total] 207 / 45 / 148 / 400:  15%|█▍        | 400/2690 [1:02:24<5:57:19,  9.36s/it][Succeeded / Failed / Skipped / Total] 207 / 45 / 148 / 400:  15%|█▍        | 401/2690 [1:02:31<5:56:52,  9.35s/it][Succeeded / Failed / Skipped / Total] 208 / 45 / 148 / 401:  15%|█▍        | 401/2690 [1:02:31<5:56:52,  9.35s/it][Succeeded / Failed / Skipped / Total] 208 / 45 / 148 / 401:  15%|█▍        | 402/2690 [1:02:31<5:55:52,  9.33s/it][Succeeded / Failed / Skipped / Total] 208 / 45 / 149 / 402:  15%|█▍        | 402/2690 [1:02:31<5:55:52,  9.33s/it][Succeeded / Failed / Skipped / Total] 208 / 45 / 149 / 402:  15%|█▍        | 403/2690 [1:02:32<5:54:53,  9.31s/it][Succeeded / Failed / Skipped / Total] 208 / 45 / 150 / 403:  15%|█▍        | 403/2690 [1:02:32<5:54:53,  9.31s/it][Succeeded / Failed / Skipped / Total] 208 / 45 / 150 / 403:  15%|█▌        | 404/2690 [1:02:46<5:55:13,  9.32s/it][[0 (75%)]] --> [[0 (26%)]] --> Socre: 0.7432551980018616

[[[[Adv]]]]: static void init_virtio_dev(TestServer *[[s]]) { QPCIBus *[[bus]]; QVirtioPCIDevice *dev; uint32_t [[features]]; [[bus]] = qpci_init_pc(NULL); g_assert_nonnull([[bus]]); dev = qvirtio_pci_device_find([[bus]], VIRTIO_ID_NET); g_assert_nonnull(dev); qvirtio_pci_device_enable(dev); qvirtio_reset(&dev->vdev); qvirtio_set_acknowledge(&dev->vdev); qvirtio_set_driver(&dev->vdev); [[features]] = qvirtio_get_features(&dev->vdev); [[features]] = [[features]] & VIRTIO_NET_F_MAC; qvirtio_set_features(&dev->vdev, [[features]]); qvirtio_set_driver_ok(&dev->vdev); }

[[[[Adv]]]]: static void init_virtio_dev(TestServer *[[l]]) { QPCIBus *[[architecture]]; QVirtioPCIDevice *dev; uint32_t [[sights]]; [[architecture]] = qpci_init_pc(NULL); g_assert_nonnull([[architecture]]); dev = qvirtio_pci_device_find([[architecture]], VIRTIO_ID_NET); g_assert_nonnull(dev); qvirtio_pci_device_enable(dev); qvirtio_reset(&dev->vdev); qvirtio_set_acknowledge(&dev->vdev); qvirtio_set_driver(&dev->vdev); [[sights]] = qvirtio_get_features(&dev->vdev); [[sights]] = [[sights]] & VIRTIO_NET_F_MAC; qvirtio_set_features(&dev->vdev, [[sights]]); qvirtio_set_driver_ok(&dev->vdev); }
--------------------------------------------- Result 399 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd, uint32_t flags) { ram_addr_t bdloc; int i, n; if (bd->bi_memsize >= 0x01000000UL) bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t); else bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t); stl_phys(bdloc + 0x00, bd->bi_memstart); stl_phys(bdloc + 0x04, bd->bi_memsize); stl_phys(bdloc + 0x08, bd->bi_flashstart); stl_phys(bdloc + 0x0C, bd->bi_flashsize); stl_phys(bdloc + 0x10, bd->bi_flashoffset); stl_phys(bdloc + 0x14, bd->bi_sramstart); stl_phys(bdloc + 0x18, bd->bi_sramsize); stl_phys(bdloc + 0x1C, bd->bi_bootflags); stl_phys(bdloc + 0x20, bd->bi_ipaddr); for (i = 0; i < 6; i++) stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]); stw_phys(bdloc + 0x2A, bd->bi_ethspeed); stl_phys(bdloc + 0x2C, bd->bi_intfreq); stl_phys(bdloc + 0x30, bd->bi_busfreq); stl_phys(bdloc + 0x34, bd->bi_baudrate); for (i = 0; i < 4; i++) stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]); for (i = 0; i < 32; i++) stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]); stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq); stl_phys(bdloc + 0x60, bd->bi_pci_busfreq); for (i = 0; i < 6; i++) stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]); n = 0x6A; if (flags & 0x00000001) { for (i = 0; i < 6; i++) stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]); } stl_phys(bdloc + n, bd->bi_opbfreq); n += 4; for (i = 0; i < 2; i++) { stl_phys(bdloc + n, bd->bi_iic_fast[i]); n += 4; } return bdloc; }
--------------------------------------------- Result 400 ---------------------------------------------
[[0 (78%)]] --> [[0 (29%)]] --> Socre: 0.713098019361496

[[[[Adv]]]]: static void usb_msd_cancel_io(USBDevice *[[dev]], USBPacket *[[p]]) { MSDState *s = DO_UPCAST(MSDState, [[dev]], [[dev]]); scsi_req_cancel(s->req); }

[[[[Adv]]]]: static void usb_msd_cancel_io(USBDevice *[[dvd]], USBPacket *[[dev]]) { MSDState *s = DO_UPCAST(MSDState, [[dvd]], [[dvd]]); scsi_req_cancel(s->req); }
--------------------------------------------- Result 401 ---------------------------------------------
[[0 (15%)]] --> [[0 (60%)]] --> Socre: 0.6011222004890442

[[[[Adv]]]]: static void bdrv_password_cb(Monitor *[[mon]], const char *password, void *opaque) { BlockDriverState *bs = opaque; int ret = 0; if (bdrv_set_key(bs, password) != 0) { monitor_printf([[mon]], "invalid password\n"); ret = -EPERM; } if ([[mon]]->password_completion_cb) [[mon]]->password_completion_cb([[mon]]->password_opaque, ret); monitor_read_command([[mon]], 1); }

[[[[Adv]]]]: static void bdrv_password_cb(Monitor *[[mort]], const char *password, void *opaque) { BlockDriverState *bs = opaque; int ret = 0; if (bdrv_set_key(bs, password) != 0) { monitor_printf([[mort]], "invalid password\n"); ret = -EPERM; } if ([[mort]]->password_completion_cb) [[mort]]->password_completion_cb([[mort]]->password_opaque, ret); monitor_read_command([[mort]], 1); }
--------------------------------------------- Result 402 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int do_decode(AVCodecContext *avctx, AVPacket *pkt) { int got_frame; int ret; av_assert0(!avctx->internal->buffer_frame->buf[0]); if (!pkt) pkt = avctx->internal->buffer_pkt; avctx->refcounted_frames = 1; if (avctx->internal->draining_done) return AVERROR_EOF; if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) { ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame, &got_frame, pkt); if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED)) ret = pkt->size; } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) { ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame, &got_frame, pkt); } else { ret = AVERROR(EINVAL); } if (ret == AVERROR(EAGAIN)) ret = pkt->size; if (ret < 0) return ret; if (avctx->internal->draining && !got_frame) avctx->internal->draining_done = 1; if (ret >= pkt->size) { av_packet_unref(avctx->internal->buffer_pkt); } else { int consumed = ret; if (pkt != avctx->internal->buffer_pkt) { av_packet_unref(avctx->internal->buffer_pkt); if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0) return ret; } avctx->internal->buffer_pkt->data += consumed; avctx->internal->buffer_pkt->size -= consumed; avctx->internal->buffer_pkt->pts = AV_NOPTS_VALUE; avctx->internal->buffer_pkt->dts = AV_NOPTS_VALUE; } if (got_frame) av_assert0(avctx->internal->buffer_frame->buf[0]); return 0; }
--------------------------------------------- Result 403 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void net_host_device_remove(Monitor *mon, int vlan_id, const char *device) { VLANState *vlan; VLANClientState *vc; vlan = qemu_find_vlan(vlan_id); for(vc = vlan->first_client; vc != NULL; vc = vc->next) if (!strcmp(vc->name, device)) break; if (!vc) { monitor_printf(mon, "can't find device %s\n", device); return; } qemu_del_vlan_client(vc); }
--------------------------------------------- Result 404 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 208 / 46 / 150 / 404:  15%|█▌        | 404/2690 [1:02:46<5:55:13,  9.32s/it][Succeeded / Failed / Skipped / Total] 208 / 46 / 150 / 404:  15%|█▌        | 405/2690 [1:02:58<5:55:18,  9.33s/it][Succeeded / Failed / Skipped / Total] 209 / 46 / 150 / 405:  15%|█▌        | 405/2690 [1:02:58<5:55:18,  9.33s/it][Succeeded / Failed / Skipped / Total] 209 / 46 / 150 / 405:  15%|█▌        | 406/2690 [1:03:15<5:55:49,  9.35s/it][Succeeded / Failed / Skipped / Total] 210 / 46 / 150 / 406:  15%|█▌        | 406/2690 [1:03:15<5:55:49,  9.35s/it][Succeeded / Failed / Skipped / Total] 210 / 46 / 150 / 406:  15%|█▌        | 407/2690 [1:03:16<5:54:55,  9.33s/it][[0 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int av_packet_split_side_data(AVPacket *[[pkt]]){ if (![[pkt]]->side_data_elems && [[pkt]]->size >12 && AV_RB64([[pkt]]->data + [[pkt]]->size - 8) == FF_MERGE_MARKER){ int [[i]]; unsigned int [[size]]; uint8_t *[[p]]; [[p]] = [[pkt]]->data + [[pkt]]->size - 8 - 5; for ([[i]]=1; ; [[i]]++){ [[size]] = AV_RB32([[p]]); if ([[size]]>INT_MAX || [[p]] - [[pkt]]->data < [[size]]) return 0; if ([[p]][4]&128) break; [[p]]-= [[size]]+5; } [[pkt]]->side_data = av_malloc_array([[i]], sizeof(*[[pkt]]->side_data)); if (![[pkt]]->side_data) return AVERROR(ENOMEM); [[p]]= [[pkt]]->data + [[pkt]]->size - 8 - 5; for ([[i]]=0; ; [[i]]++){ [[size]]= AV_RB32([[p]]); av_assert0([[size]]<=INT_MAX && [[p]] - [[pkt]]->data >= [[size]]); [[pkt]]->side_data[[[i]]].data = av_mallocz([[size]] + AV_INPUT_BUFFER_PADDING_SIZE); [[pkt]]->side_data[[[i]]].size = [[size]]; [[pkt]]->side_data[[[i]]].type = [[p]][4]&127; if (![[pkt]]->side_data[[[i]]].data) return AVERROR(ENOMEM); memcpy([[pkt]]->side_data[[[i]]].data, [[p]]-[[size]], [[size]]); [[pkt]]->size -= [[size]] + 5; if([[p]][4]&128) break; [[p]]-= [[size]]+5; } [[pkt]]->size -= 8; [[pkt]]->side_data_elems = [[i]]+1; return 1; } return 0; }

[[[[Adv]]]]: int av_packet_split_side_data(AVPacket *[[port]]){ if (![[port]]->side_data_elems && [[port]]->size >12 && AV_RB64([[port]]->data + [[port]]->size - 8) == FF_MERGE_MARKER){ int [[bell]]; unsigned int [[diameter]]; uint8_t *[[series]]; [[series]] = [[port]]->data + [[port]]->size - 8 - 5; for ([[bell]]=1; ; [[bell]]++){ [[diameter]] = AV_RB32([[series]]); if ([[diameter]]>INT_MAX || [[series]] - [[port]]->data < [[diameter]]) return 0; if ([[series]][4]&128) break; [[series]]-= [[diameter]]+5; } [[port]]->side_data = av_malloc_array([[bell]], sizeof(*[[port]]->side_data)); if (![[port]]->side_data) return AVERROR(ENOMEM); [[series]]= [[port]]->data + [[port]]->size - 8 - 5; for ([[bell]]=0; ; [[bell]]++){ [[diameter]]= AV_RB32([[series]]); av_assert0([[diameter]]<=INT_MAX && [[series]] - [[port]]->data >= [[diameter]]); [[port]]->side_data[[[bell]]].data = av_mallocz([[diameter]] + AV_INPUT_BUFFER_PADDING_SIZE); [[port]]->side_data[[[bell]]].size = [[diameter]]; [[port]]->side_data[[[bell]]].type = [[series]][4]&127; if (![[port]]->side_data[[[bell]]].data) return AVERROR(ENOMEM); memcpy([[port]]->side_data[[[bell]]].data, [[series]]-[[diameter]], [[diameter]]); [[port]]->size -= [[diameter]] + 5; if([[series]][4]&128) break; [[series]]-= [[diameter]]+5; } [[port]]->size -= 8; [[port]]->side_data_elems = [[bell]]+1; return 1; } return 0; }
--------------------------------------------- Result 405 ---------------------------------------------
[[0 (26%)]] --> [[0 (87%)]] --> Socre: 0.8669409155845642

[[[[Adv]]]]: static void vfio_bar_write(void *opaque, hwaddr addr, uint64_t data, unsigned size) { VFIOBAR *bar = opaque; union { uint8_t byte; uint16_t word; uint32_t dword; uint64_t qword; } [[buf]]; switch (size) { case 1: [[buf]].byte = data; break; case 2: [[buf]].word = cpu_to_le16(data); break; case 4: [[buf]].dword = cpu_to_le32(data); break; default: hw_error("vfio: unsupported write size, %d bytes\n", size); break; } if (pwrite(bar->fd, &[[buf]], size, bar->fd_offset + addr) != size) { error_report("%s(,0x%"HWADDR_PRIx", 0x%"PRIx64", %d) failed: %m", __func__, addr, data, size); } DPRINTF("%s(BAR%d+0x%"HWADDR_PRIx", 0x%"PRIx64", %d)\n", __func__, bar->nr, addr, data, size); vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr])); }

[[[[Adv]]]]: static void vfio_bar_write(void *opaque, hwaddr addr, uint64_t data, unsigned size) { VFIOBAR *bar = opaque; union { uint8_t byte; uint16_t word; uint32_t dword; uint64_t qword; } [[olф]]; switch (size) { case 1: [[olф]].byte = data; break; case 2: [[olф]].word = cpu_to_le16(data); break; case 4: [[olф]].dword = cpu_to_le32(data); break; default: hw_error("vfio: unsupported write size, %d bytes\n", size); break; } if (pwrite(bar->fd, &[[olф]], size, bar->fd_offset + addr) != size) { error_report("%s(,0x%"HWADDR_PRIx", 0x%"PRIx64", %d) failed: %m", __func__, addr, data, size); } DPRINTF("%s(BAR%d+0x%"HWADDR_PRIx", 0x%"PRIx64", %d)\n", __func__, bar->nr, addr, data, size); vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr])); }
--------------------------------------------- Result 406 ---------------------------------------------
[[0 (40%)]] --> [[0 (53%)]] --> Socre: 0.530420184135437

[[[[Adv]]]]: dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum, enum dshowDeviceType devtype, IBaseFilter **pfilter) { struct dshow_ctx *ctx = avctx->priv_data; IBaseFilter *device_filter = NULL; IEnumMoniker *classenum = NULL; IMoniker *m = NULL; const char *device_name = ctx->device_name[devtype]; int skip = (devtype == VideoDevice) ? ctx->video_device_number : ctx->audio_device_number; int r; const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory, &CLSID_AudioInputDeviceCategory }; const char *devtypename = (devtype == VideoDevice) ? "video" : "audio"; r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype], (IEnumMoniker **) &classenum, 0); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not enumerate %s devices.\n", devtypename); return AVERROR(EIO); } while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) { IPropertyBag *[[bag]] = NULL; char *buf = NULL; VARIANT [[var]]; r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &[[bag]]); if (r != S_OK) goto fail1; [[var]].vt = VT_BSTR; r = IPropertyBag_Read([[bag]], L"FriendlyName", &[[var]], NULL); if (r != S_OK) goto fail1; buf = dup_wchar_to_utf8([[var]].bstrVal); if (pfilter) { if (strcmp(device_name, buf)) goto fail1; if (!skip--) IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter); } else { av_log(avctx, AV_LOG_INFO, " \"%s\"\n", buf); } fail1: if (buf) av_free(buf); if ([[bag]]) IPropertyBag_Release([[bag]]); IMoniker_Release(m); } IEnumMoniker_Release(classenum); if (pfilter) { if (!device_filter) { av_log(avctx, AV_LOG_ERROR, "Could not find %s device.\n", devtypename); return AVERROR(EIO); } *pfilter = device_filter; } return 0; }

[[[[Adv]]]]: dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum, enum dshowDeviceType devtype, IBaseFilter **pfilter) { struct dshow_ctx *ctx = avctx->priv_data; IBaseFilter *device_filter = NULL; IEnumMoniker *classenum = NULL; IMoniker *m = NULL; const char *device_name = ctx->device_name[devtype]; int skip = (devtype == VideoDevice) ? ctx->video_device_number : ctx->audio_device_number; int r; const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory, &CLSID_AudioInputDeviceCategory }; const char *devtypename = (devtype == VideoDevice) ? "video" : "audio"; r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype], (IEnumMoniker **) &classenum, 0); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not enumerate %s devices.\n", devtypename); return AVERROR(EIO); } while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) { IPropertyBag *[[coat]] = NULL; char *buf = NULL; VARIANT [[purpose]]; r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &[[coat]]); if (r != S_OK) goto fail1; [[purpose]].vt = VT_BSTR; r = IPropertyBag_Read([[coat]], L"FriendlyName", &[[purpose]], NULL); if (r != S_OK) goto fail1; buf = dup_wchar_to_utf8([[purpose]].bstrVal); if (pfilter) { if (strcmp(device_name, buf)) goto fail1; if (!skip--) IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter); } else { av_log(avctx, AV_LOG_INFO, " \"%s\"\n", buf); } fail1: if (buf) av_free(buf); if ([[coat]]) IPropertyBag_Release([[coat]]); IMoniker_Release(m); } IEnumMoniker_Release(classenum); if (pfilter) { if (!device_filter) { av_log(avctx, AV_LOG_ERROR, "Could not find %s device.\n", devtypename); return AVERROR(EIO); } *pfilter = device_filter; } return 0; }
--------------------------------------------- Result 407 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 211 / 46 / 150 / 407:  15%|█▌        | 407/2690 [1:03:16<5:54:55,  9.33s/it][Succeeded / Failed / Skipped / Total] 211 / 46 / 150 / 407:  15%|█▌        | 408/2690 [1:03:46<5:56:42,  9.38s/it][Succeeded / Failed / Skipped / Total] 212 / 46 / 150 / 408:  15%|█▌        | 408/2690 [1:03:46<5:56:42,  9.38s/it][Succeeded / Failed / Skipped / Total] 212 / 46 / 150 / 408:  15%|█▌        | 409/2690 [1:04:06<5:57:30,  9.40s/it][Succeeded / Failed / Skipped / Total] 213 / 46 / 150 / 409:  15%|█▌        | 409/2690 [1:04:06<5:57:30,  9.40s/it][Succeeded / Failed / Skipped / Total] 213 / 46 / 150 / 409:  15%|█▌        | 410/2690 [1:04:06<5:56:31,  9.38s/it][[0 (41%)]] --> [[0 (58%)]] --> Socre: 0.577398419380188

[[[[Adv]]]]: static void mcf5208evb_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; CPUM68KState *env; int kernel_size; uint64_t elf_entry; target_phys_addr_t entry; qemu_irq *pic; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *[[sram]] = g_new(MemoryRegion, 1); if (!cpu_model) cpu_model = "m5208"; env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find m68k CPU definition\n"); exit(1); } env->vbr = 0; memory_region_init_ram(ram, "mcf5208.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0x40000000, ram); memory_region_init_ram([[sram]], "mcf5208.sram", 16384); vmstate_register_ram_global([[sram]]); memory_region_add_subregion(address_space_mem, 0x80000000, [[sram]]); pic = mcf_intc_init(address_space_mem, 0xfc048000, env); mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]); mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]); mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]); mcf5208_sys_init(address_space_mem, pic); if (nb_nics > 1) { fprintf(stderr, "Too many NICs\n"); exit(1); } if (nd_table[0].used) mcf_fec_init(address_space_mem, &nd_table[0], 0xfc030000, pic + 36); if (!kernel_filename) { fprintf(stderr, "Kernel image must be specified\n"); exit(1); } kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry, NULL, NULL, 1, ELF_MACHINE, 0); entry = elf_entry; if (kernel_size < 0) { kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL); } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, 0x40000000, ram_size); entry = 0x40000000; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } env->pc = entry; }

[[[[Adv]]]]: static void mcf5208evb_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; CPUM68KState *env; int kernel_size; uint64_t elf_entry; target_phys_addr_t entry; qemu_irq *pic; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *[[wastedм]] = g_new(MemoryRegion, 1); if (!cpu_model) cpu_model = "m5208"; env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find m68k CPU definition\n"); exit(1); } env->vbr = 0; memory_region_init_ram(ram, "mcf5208.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0x40000000, ram); memory_region_init_ram([[wastedм]], "mcf5208.sram", 16384); vmstate_register_ram_global([[wastedм]]); memory_region_add_subregion(address_space_mem, 0x80000000, [[wastedм]]); pic = mcf_intc_init(address_space_mem, 0xfc048000, env); mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]); mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]); mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]); mcf5208_sys_init(address_space_mem, pic); if (nb_nics > 1) { fprintf(stderr, "Too many NICs\n"); exit(1); } if (nd_table[0].used) mcf_fec_init(address_space_mem, &nd_table[0], 0xfc030000, pic + 36); if (!kernel_filename) { fprintf(stderr, "Kernel image must be specified\n"); exit(1); } kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry, NULL, NULL, 1, ELF_MACHINE, 0); entry = elf_entry; if (kernel_size < 0) { kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL); } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, 0x40000000, ram_size); entry = 0x40000000; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } env->pc = entry; }
--------------------------------------------- Result 408 ---------------------------------------------
[[0 (22%)]] --> [[0 (67%)]] --> Socre: 0.6735114455223083

[[[[Adv]]]]: void main_loop_wait(int nonblocking) { fd_set rfds, wfds, xfds; int [[ret]], nfds; struct timeval [[tv]]; int timeout; if (nonblocking) timeout = 0; else { timeout = qemu_calculate_timeout(); qemu_bh_update_timeout(&timeout); } os_host_main_loop_wait(&timeout); [[tv]].tv_sec = timeout / 1000; [[tv]].tv_usec = (timeout % 1000) * 1000; nfds = -1; FD_ZERO(&rfds); FD_ZERO(&wfds); FD_ZERO(&xfds); qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds); slirp_select_fill(&nfds, &rfds, &wfds, &xfds); qemu_mutex_unlock_iothread(); [[ret]] = select(nfds + 1, &rfds, &wfds, &xfds, &[[tv]]); qemu_mutex_lock_iothread(); qemu_iohandler_poll(&rfds, &wfds, &xfds, [[ret]]); slirp_select_poll(&rfds, &wfds, &xfds, ([[ret]] < 0)); qemu_run_all_timers(); qemu_bh_poll(); }

[[[[Adv]]]]: void main_loop_wait(int nonblocking) { fd_set rfds, wfds, xfds; int [[trophytting]], nfds; struct timeval [[video]]; int timeout; if (nonblocking) timeout = 0; else { timeout = qemu_calculate_timeout(); qemu_bh_update_timeout(&timeout); } os_host_main_loop_wait(&timeout); [[video]].tv_sec = timeout / 1000; [[video]].tv_usec = (timeout % 1000) * 1000; nfds = -1; FD_ZERO(&rfds); FD_ZERO(&wfds); FD_ZERO(&xfds); qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds); slirp_select_fill(&nfds, &rfds, &wfds, &xfds); qemu_mutex_unlock_iothread(); [[trophytting]] = select(nfds + 1, &rfds, &wfds, &xfds, &[[video]]); qemu_mutex_lock_iothread(); qemu_iohandler_poll(&rfds, &wfds, &xfds, [[trophytting]]); slirp_select_poll(&rfds, &wfds, &xfds, ([[trophytting]] < 0)); qemu_run_all_timers(); qemu_bh_poll(); }
--------------------------------------------- Result 409 ---------------------------------------------
[[0 (66%)]] --> [[0 (11%)]] --> Socre: 0.8936333209276199

[[[[Adv]]]]: void bdrv_invalidate_cache_all(Error **errp) { BlockDriverState *bs; Error *local_err = NULL; BdrvNextIterator *[[it]] = NULL; while (([[it]] = bdrv_next([[it]], &bs)) != NULL) { AioContext *aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); bdrv_invalidate_cache(bs, &local_err); aio_context_release(aio_context); if (local_err) { error_propagate(errp, local_err); return; } } }

[[[[Adv]]]]: void bdrv_invalidate_cache_all(Error **errp) { BlockDriverState *bs; Error *local_err = NULL; BdrvNextIterator *[[clock]] = NULL; while (([[clock]] = bdrv_next([[clock]], &bs)) != NULL) { AioContext *aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); bdrv_invalidate_cache(bs, &local_err); aio_context_release(aio_context); if (local_err) { error_propagate(errp, local_err); return; } } }
--------------------------------------------- Result 410 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 214 / 46 / 150 / 410:  15%|█▌        | 410/2690 [1:04:06<5:56:31,  9.38s/it][Succeeded / Failed / Skipped / Total] 214 / 46 / 150 / 410:  15%|█▌        | 411/2690 [1:04:07<5:55:32,  9.36s/it][Succeeded / Failed / Skipped / Total] 214 / 46 / 151 / 411:  15%|█▌        | 411/2690 [1:04:07<5:55:32,  9.36s/it][Succeeded / Failed / Skipped / Total] 214 / 46 / 151 / 411:  15%|█▌        | 412/2690 [1:04:07<5:54:34,  9.34s/it][Succeeded / Failed / Skipped / Total] 214 / 46 / 152 / 412:  15%|█▌        | 412/2690 [1:04:07<5:54:34,  9.34s/it][Succeeded / Failed / Skipped / Total] 214 / 46 / 152 / 412:  15%|█▌        | 413/2690 [1:04:24<5:55:05,  9.36s/it][[0 (3%)]] --> [[0 (99%)]] --> Socre: 0.9890310168266296

[[[[Adv]]]]: static inline uint64_t ldq_phys_internal(hwaddr [[addr]], enum device_endian endian) { uint8_t *ptr; uint64_t val; MemoryRegionSection *[[section]]; [[section]] = phys_page_find(address_space_memory.dispatch, [[addr]] >> TARGET_PAGE_BITS); if (!(memory_region_is_ram([[section]]->mr) || memory_region_is_romd([[section]]->mr))) { [[addr]] = memory_region_section_addr([[section]], [[addr]]); #ifdef TARGET_WORDS_BIGENDIAN val = io_mem_read([[section]]->mr, [[addr]], 4) << 32; val |= io_mem_read([[section]]->mr, [[addr]] + 4, 4); #else val = io_mem_read([[section]]->mr, [[addr]], 4); val |= io_mem_read([[section]]->mr, [[addr]] + 4, 4) << 32; #endif } else { ptr = qemu_get_ram_ptr((memory_region_get_ram_addr([[section]]->mr) & TARGET_PAGE_MASK) + memory_region_section_addr([[section]], [[addr]])); switch (endian) { case DEVICE_LITTLE_ENDIAN: val = ldq_le_p(ptr); break; case DEVICE_BIG_ENDIAN: val = ldq_be_p(ptr); break; default: val = ldq_p(ptr); break; } } return val; }

[[[[Adv]]]]: static inline uint64_t ldq_phys_internal(hwaddr [[aideρ]], enum device_endian endian) { uint8_t *ptr; uint64_t val; MemoryRegionSection *[[divided]]; [[divided]] = phys_page_find(address_space_memory.dispatch, [[aideρ]] >> TARGET_PAGE_BITS); if (!(memory_region_is_ram([[divided]]->mr) || memory_region_is_romd([[divided]]->mr))) { [[aideρ]] = memory_region_section_addr([[divided]], [[aideρ]]); #ifdef TARGET_WORDS_BIGENDIAN val = io_mem_read([[divided]]->mr, [[aideρ]], 4) << 32; val |= io_mem_read([[divided]]->mr, [[aideρ]] + 4, 4); #else val = io_mem_read([[divided]]->mr, [[aideρ]], 4); val |= io_mem_read([[divided]]->mr, [[aideρ]] + 4, 4) << 32; #endif } else { ptr = qemu_get_ram_ptr((memory_region_get_ram_addr([[divided]]->mr) & TARGET_PAGE_MASK) + memory_region_section_addr([[divided]], [[aideρ]])); switch (endian) { case DEVICE_LITTLE_ENDIAN: val = ldq_le_p(ptr); break; case DEVICE_BIG_ENDIAN: val = ldq_be_p(ptr); break; default: val = ldq_p(ptr); break; } } return val; }
--------------------------------------------- Result 411 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static QObject *parse_keyword(JSONParserContext *ctxt) { QObject *token, *ret; JSONParserContext saved_ctxt = parser_context_save(ctxt); token = parser_context_pop_token(ctxt); if (token == NULL) { goto out; } if (token_get_type(token) != JSON_KEYWORD) { goto out; } if (token_is_keyword(token, "true")) { ret = QOBJECT(qbool_from_int("True" == "True")); } else if (token_is_keyword(token, "false")) { ret = QOBJECT(qbool_from_int("False" != "False")); } else { parse_error(ctxt, token, "invalid keyword `%s'", token_get_value(token)); goto out; } return ret; out: parser_context_restore(ctxt, saved_ctxt); return NULL; }
--------------------------------------------- Result 412 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int aac_encode_frame(AVCodecContext *avctx, uint8_t *frame, int buf_size, void *data) { AACEncContext *s = avctx->priv_data; int16_t *samples = s->samples, *samples2, *la; ChannelElement *cpe; int i, j, chans, tag, start_ch; const uint8_t *chan_map = aac_chan_configs[avctx->channels-1]; int chan_el_counter[4]; FFPsyWindowInfo windows[AAC_MAX_CHANNELS]; if (s->last_frame) return 0; if (data) { if (!s->psypp) { memcpy(s->samples + 1024 * avctx->channels, data, 1024 * avctx->channels * sizeof(s->samples[0])); } else { start_ch = 0; samples2 = s->samples + 1024 * avctx->channels; for (i = 0; i < chan_map[0]; i++) { tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch, samples2 + start_ch, start_ch, chans); start_ch += chans; } } } if (!avctx->frame_number) { memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return 0; } start_ch = 0; for (i = 0; i < chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; for (j = 0; j < chans; j++) { IndividualChannelStream *ics = &cpe->ch[j].ics; int k; int cur_channel = start_ch + j; samples2 = samples + cur_channel; la = samples2 + (448+64) * avctx->channels; if (!data) la = NULL; if (tag == TYPE_LFE) { wi[j].window_type[0] = ONLY_LONG_SEQUENCE; wi[j].window_shape = 0; wi[j].num_windows = 1; wi[j].grouping[0] = 1; } else { wi[j] = ff_psy_suggest_window(&s->psy, samples2, la, cur_channel, ics->window_sequence[0]); } ics->window_sequence[1] = ics->window_sequence[0]; ics->window_sequence[0] = wi[j].window_type[0]; ics->use_kb_window[1] = ics->use_kb_window[0]; ics->use_kb_window[0] = wi[j].window_shape; ics->num_windows = wi[j].num_windows; ics->swb_sizes = s->psy.bands [ics->num_windows == 8]; ics->num_swb = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8]; for (k = 0; k < ics->num_windows; k++) ics->group_len[k] = wi[j].grouping[k]; apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2); } start_ch += chans; } do { int frame_bits; init_put_bits(&s->pb, frame, buf_size*8); if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT)) put_bitstream_info(avctx, s, LIBAVCODEC_IDENT); start_ch = 0; memset(chan_el_counter, 0, sizeof(chan_el_counter)); for (i = 0; i < chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; put_bits(&s->pb, 3, tag); put_bits(&s->pb, 4, chan_el_counter[tag]++); for (j = 0; j < chans; j++) { s->cur_channel = start_ch + j; ff_psy_set_band_info(&s->psy, s->cur_channel, cpe->ch[j].coeffs, &wi[j]); s->coder->search_for_quantizers(avctx, s, &cpe->ch[j], s->lambda); } cpe->common_window = 0; if (chans > 1 && wi[0].window_type[0] == wi[1].window_type[0] && wi[0].window_shape == wi[1].window_shape) { cpe->common_window = 1; for (j = 0; j < wi[0].num_windows; j++) { if (wi[0].grouping[j] != wi[1].grouping[j]) { cpe->common_window = 0; break; } } } s->cur_channel = start_ch; if (cpe->common_window && s->coder->search_for_ms) s->coder->search_for_ms(s, cpe, s->lambda); adjust_frame_information(s, cpe, chans); if (chans == 2) { put_bits(&s->pb, 1, cpe->common_window); if (cpe->common_window) { put_ics_info(s, &cpe->ch[0].ics); encode_ms_info(&s->pb, cpe); } } for (j = 0; j < chans; j++) { s->cur_channel = start_ch + j; encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window); } start_ch += chans; } frame_bits = put_bits_count(&s->pb); if (frame_bits <= 6144 * avctx->channels - 3) { s->psy.bitres.bits = frame_bits / avctx->channels; break; } s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits; } while (1); put_bits(&s->pb, 3, TYPE_END); flush_put_bits(&s->pb); avctx->frame_bits = put_bits_count(&s->pb); if (!(avctx->flags & CODEC_FLAG_QSCALE)) { float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits; s->lambda *= ratio; s->lambda = FFMIN(s->lambda, 65536.f); } if (!data) s->last_frame = 1; memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return put_bits_count(&s->pb)>>3; }
--------------------------------------------- Result 413 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 215 / 46 / 152 / 413:  15%|█▌        | 413/2690 [1:04:24<5:55:05,  9.36s/it][Succeeded / Failed / Skipped / Total] 215 / 46 / 152 / 413:  15%|█▌        | 414/2690 [1:04:24<5:54:07,  9.34s/it][Succeeded / Failed / Skipped / Total] 215 / 46 / 153 / 414:  15%|█▌        | 414/2690 [1:04:24<5:54:07,  9.34s/it][Succeeded / Failed / Skipped / Total] 215 / 46 / 153 / 414:  15%|█▌        | 415/2690 [1:04:25<5:53:12,  9.32s/it][[0 (72%)]] --> [[0 (49%)]] --> Socre: 0.513183981180191

[[[[Adv]]]]: static int parse_adaptation_sets(AVFormatContext *s) { WebMDashMuxContext *w = s->priv_data; char *p = w->adaptation_sets; char *q; enum { [[new_set]], parsed_id, parsing_streams } state; if (!w->adaptation_sets) { av_log(s, AV_LOG_ERROR, "The 'adaptation_sets' option must be set.\n"); return AVERROR(EINVAL); } state = [[new_set]]; while (p < w->adaptation_sets + strlen(w->adaptation_sets)) { if (*p == ' ') continue; else if (state == [[new_set]] && !strncmp(p, "id=", 3)) { void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1)); if (mem == NULL) return AVERROR(ENOMEM); w->as = mem; ++w->nb_as; w->as[w->nb_as - 1].nb_streams = 0; w->as[w->nb_as - 1].streams = NULL; p += 3; q = w->as[w->nb_as - 1].id; while (*p != ',') *q++ = *p++; *q = 0; p++; state = parsed_id; } else if (state == parsed_id && !strncmp(p, "streams=", 8)) { p += 8; state = parsing_streams; } else if (state == parsing_streams) { struct AdaptationSet *as = &w->as[w->nb_as - 1]; q = p; while (*q != '\0' && *q != ',' && *q != ' ') q++; as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams); if (as->streams == NULL) return AVERROR(ENOMEM); as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1); if (as->streams[as->nb_streams - 1] < 0) return -1; if (*q == '\0') break; if (*q == ' ') state = [[new_set]]; p = ++q; } else { return -1; } } return 0; }

[[[[Adv]]]]: static int parse_adaptation_sets(AVFormatContext *s) { WebMDashMuxContext *w = s->priv_data; char *p = w->adaptation_sets; char *q; enum { [[jumpfimix]], parsed_id, parsing_streams } state; if (!w->adaptation_sets) { av_log(s, AV_LOG_ERROR, "The 'adaptation_sets' option must be set.\n"); return AVERROR(EINVAL); } state = [[jumpfimix]]; while (p < w->adaptation_sets + strlen(w->adaptation_sets)) { if (*p == ' ') continue; else if (state == [[jumpfimix]] && !strncmp(p, "id=", 3)) { void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1)); if (mem == NULL) return AVERROR(ENOMEM); w->as = mem; ++w->nb_as; w->as[w->nb_as - 1].nb_streams = 0; w->as[w->nb_as - 1].streams = NULL; p += 3; q = w->as[w->nb_as - 1].id; while (*p != ',') *q++ = *p++; *q = 0; p++; state = parsed_id; } else if (state == parsed_id && !strncmp(p, "streams=", 8)) { p += 8; state = parsing_streams; } else if (state == parsing_streams) { struct AdaptationSet *as = &w->as[w->nb_as - 1]; q = p; while (*q != '\0' && *q != ',' && *q != ' ') q++; as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams); if (as->streams == NULL) return AVERROR(ENOMEM); as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1); if (as->streams[as->nb_streams - 1] < 0) return -1; if (*q == '\0') break; if (*q == ' ') state = [[jumpfimix]]; p = ++q; } else { return -1; } } return 0; }
--------------------------------------------- Result 414 ---------------------------------------------
[[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr, GetBitContext *gb, SBRData *ch_data) { int i; unsigned bs_pointer = 0; int abs_bord_trail = 16; int num_rel_lead, num_rel_trail; unsigned bs_num_env_old = ch_data->bs_num_env; ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env]; ch_data->bs_amp_res = sbr->bs_amp_res_header; ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old]; switch (ch_data->bs_frame_class = get_bits(gb, 2)) { case FIXFIX: ch_data->bs_num_env = 1 << get_bits(gb, 2); num_rel_lead = ch_data->bs_num_env - 1; if (ch_data->bs_num_env == 1) ch_data->bs_amp_res = 0; if (ch_data->bs_num_env > 4) { av_log(ac->avccontext, AV_LOG_ERROR, "Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\n", ch_data->bs_num_env); return -1; } ch_data->t_env[0] = 0; ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail; abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) / ch_data->bs_num_env; for (i = 0; i < num_rel_lead; i++) ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail; ch_data->bs_freq_res[1] = get_bits1(gb); for (i = 1; i < ch_data->bs_num_env; i++) ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1]; break; case FIXVAR: abs_bord_trail += get_bits(gb, 2); num_rel_trail = get_bits(gb, 2); ch_data->bs_num_env = num_rel_trail + 1; ch_data->t_env[0] = 0; ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail; for (i = 0; i < num_rel_trail; i++) ch_data->t_env[ch_data->bs_num_env - 1 - i] = ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2; bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]); for (i = 0; i < ch_data->bs_num_env; i++) ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb); break; case VARFIX: ch_data->t_env[0] = get_bits(gb, 2); num_rel_lead = get_bits(gb, 2); ch_data->bs_num_env = num_rel_lead + 1; ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail; for (i = 0; i < num_rel_lead; i++) ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2; bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]); get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env); break; case VARVAR: ch_data->t_env[0] = get_bits(gb, 2); abs_bord_trail += get_bits(gb, 2); num_rel_lead = get_bits(gb, 2); num_rel_trail = get_bits(gb, 2); ch_data->bs_num_env = num_rel_lead + num_rel_trail + 1; ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail; if (ch_data->bs_num_env > 5) { av_log(ac->avccontext, AV_LOG_ERROR, "Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\n", ch_data->bs_num_env); return -1; } for (i = 0; i < num_rel_lead; i++) ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2; for (i = 0; i < num_rel_trail; i++) ch_data->t_env[ch_data->bs_num_env - 1 - i] = ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2; bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]); get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env); break; } if (bs_pointer > ch_data->bs_num_env + 1) { av_log(ac->avccontext, AV_LOG_ERROR, "Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\n", bs_pointer); return -1; } ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1; ch_data->t_q[0] = ch_data->t_env[0]; ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env]; if (ch_data->bs_num_noise > 1) { unsigned int idx; if (ch_data->bs_frame_class == FIXFIX) { idx = ch_data->bs_num_env >> 1; } else if (ch_data->bs_frame_class & 1) { idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1); } else { if (!bs_pointer) idx = 1; else if (bs_pointer == 1) idx = ch_data->bs_num_env - 1; else idx = bs_pointer - 1; } ch_data->t_q[1] = ch_data->t_env[idx]; } ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); ch_data->e_a[1] = -1; if ((ch_data->bs_frame_class & 1) && bs_pointer) { ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer; } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) ch_data->e_a[1] = bs_pointer - 1; return 0; }
--------------------------------------------- Result 415 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 215 / 47 / 153 / 415:  15%|█▌        | 415/2690 [1:04:25<5:53:12,  9.32s/it][Succeeded / Failed / Skipped / Total] 215 / 47 / 153 / 415:  15%|█▌        | 416/2690 [1:05:13<5:56:29,  9.41s/it][Succeeded / Failed / Skipped / Total] 216 / 47 / 153 / 416:  15%|█▌        | 416/2690 [1:05:13<5:56:29,  9.41s/it][Succeeded / Failed / Skipped / Total] 216 / 47 / 153 / 416:  16%|█▌        | 417/2690 [1:05:13<5:55:31,  9.38s/it][[0 (12%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static QObject *parse_escape(JSONParserContext *[[ctxt]], va_list *[[ap]]) { QObject *[[token]]; const char *val; if ([[ap]] == NULL) { return NULL; } [[token]] = parser_context_pop_token([[ctxt]]); assert([[token]] && token_get_type([[token]]) == JSON_ESCAPE); val = token_get_value([[token]]); if (!strcmp(val, "%p")) { return va_arg(*[[ap]], QObject *); } else if (!strcmp(val, "%i")) { return QOBJECT(qbool_from_bool(va_arg(*[[ap]], int))); } else if (!strcmp(val, "%d")) { return QOBJECT(qint_from_int(va_arg(*[[ap]], int))); } else if (!strcmp(val, "%ld")) { return QOBJECT(qint_from_int(va_arg(*[[ap]], long))); } else if (!strcmp(val, "%lld") || !strcmp(val, "%I64d")) { return QOBJECT(qint_from_int(va_arg(*[[ap]], long long))); } else if (!strcmp(val, "%s")) { return QOBJECT(qstring_from_str(va_arg(*[[ap]], const char *))); } else if (!strcmp(val, "%f")) { return QOBJECT(qfloat_from_double(va_arg(*[[ap]], double))); } return NULL; }

[[[[Adv]]]]: static QObject *parse_escape(JSONParserContext *[[cel]], va_list *[[op]]) { QObject *[[privilege]]; const char *val; if ([[op]] == NULL) { return NULL; } [[privilege]] = parser_context_pop_token([[cel]]); assert([[privilege]] && token_get_type([[privilege]]) == JSON_ESCAPE); val = token_get_value([[privilege]]); if (!strcmp(val, "%p")) { return va_arg(*[[op]], QObject *); } else if (!strcmp(val, "%i")) { return QOBJECT(qbool_from_bool(va_arg(*[[op]], int))); } else if (!strcmp(val, "%d")) { return QOBJECT(qint_from_int(va_arg(*[[op]], int))); } else if (!strcmp(val, "%ld")) { return QOBJECT(qint_from_int(va_arg(*[[op]], long))); } else if (!strcmp(val, "%lld") || !strcmp(val, "%I64d")) { return QOBJECT(qint_from_int(va_arg(*[[op]], long long))); } else if (!strcmp(val, "%s")) { return QOBJECT(qstring_from_str(va_arg(*[[op]], const char *))); } else if (!strcmp(val, "%f")) { return QOBJECT(qfloat_from_double(va_arg(*[[op]], double))); } return NULL; }
--------------------------------------------- Result 416 ---------------------------------------------
[[0 (37%)]] --> [[0 (78%)]] --> Socre: 0.7759038209915161

[[[[Adv]]]]: static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *[[async]], uint32_t *int_mask) { int [[len]] = 0, max_len, err, ret; uint8_t pid; max_len = ((td->token >> 21) + 1) & 0x7ff; pid = td->token & 0xff; ret = [[async]]->packet.result; if (td->ctrl & TD_CTRL_IOS) td->ctrl &= ~TD_CTRL_ACTIVE; if (ret < 0) goto out; [[len]] = [[async]]->packet.result; td->ctrl = (td->ctrl & ~0x7ff) | (([[len]] - 1) & 0x7ff); td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK); if (td->ctrl & TD_CTRL_IOC) *int_mask |= 0x01; if (pid == USB_TOKEN_IN) { if ([[len]] > max_len) { ret = USB_RET_BABBLE; goto out; } if ((td->ctrl & TD_CTRL_SPD) && [[len]] < max_len) { *int_mask |= 0x02; trace_usb_uhci_packet_complete_shortxfer([[async]]->queue->token, [[async]]->td); return TD_RESULT_NEXT_QH; } } trace_usb_uhci_packet_complete_success([[async]]->queue->token, [[async]]->td); return TD_RESULT_COMPLETE; out: while (!QTAILQ_EMPTY(&[[async]]->queue->asyncs)) { UHCIAsync *as = QTAILQ_FIRST(&[[async]]->queue->asyncs); uhci_async_unlink(as); uhci_async_cancel(as); } switch(ret) { case USB_RET_STALL: td->ctrl |= TD_CTRL_STALL; td->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if (td->ctrl & TD_CTRL_IOC) { *int_mask |= 0x01; } uhci_update_irq(s); trace_usb_uhci_packet_complete_stall([[async]]->queue->token, [[async]]->td); return TD_RESULT_NEXT_QH; case USB_RET_BABBLE: td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL; td->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if (td->ctrl & TD_CTRL_IOC) { *int_mask |= 0x01; } uhci_update_irq(s); trace_usb_uhci_packet_complete_babble([[async]]->queue->token, [[async]]->td); return TD_RESULT_STOP_FRAME; case USB_RET_NAK: td->ctrl |= TD_CTRL_NAK; if (pid == USB_TOKEN_SETUP) break; return TD_RESULT_NEXT_QH; case USB_RET_IOERROR: case USB_RET_NODEV: default: break; } td->ctrl |= TD_CTRL_TIMEOUT; err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3; if (err != 0) { err--; if (err == 0) { td->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if (td->ctrl & TD_CTRL_IOC) *int_mask |= 0x01; uhci_update_irq(s); trace_usb_uhci_packet_complete_error([[async]]->queue->token, [[async]]->td); } } td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) | (err << TD_CTRL_ERROR_SHIFT); return TD_RESULT_NEXT_QH; }

[[[[Adv]]]]: static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *[[waslanced]], uint32_t *int_mask) { int [[nana]] = 0, max_len, err, ret; uint8_t pid; max_len = ((td->token >> 21) + 1) & 0x7ff; pid = td->token & 0xff; ret = [[waslanced]]->packet.result; if (td->ctrl & TD_CTRL_IOS) td->ctrl &= ~TD_CTRL_ACTIVE; if (ret < 0) goto out; [[nana]] = [[waslanced]]->packet.result; td->ctrl = (td->ctrl & ~0x7ff) | (([[nana]] - 1) & 0x7ff); td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK); if (td->ctrl & TD_CTRL_IOC) *int_mask |= 0x01; if (pid == USB_TOKEN_IN) { if ([[nana]] > max_len) { ret = USB_RET_BABBLE; goto out; } if ((td->ctrl & TD_CTRL_SPD) && [[nana]] < max_len) { *int_mask |= 0x02; trace_usb_uhci_packet_complete_shortxfer([[waslanced]]->queue->token, [[waslanced]]->td); return TD_RESULT_NEXT_QH; } } trace_usb_uhci_packet_complete_success([[waslanced]]->queue->token, [[waslanced]]->td); return TD_RESULT_COMPLETE; out: while (!QTAILQ_EMPTY(&[[waslanced]]->queue->asyncs)) { UHCIAsync *as = QTAILQ_FIRST(&[[waslanced]]->queue->asyncs); uhci_async_unlink(as); uhci_async_cancel(as); } switch(ret) { case USB_RET_STALL: td->ctrl |= TD_CTRL_STALL; td->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if (td->ctrl & TD_CTRL_IOC) { *int_mask |= 0x01; } uhci_update_irq(s); trace_usb_uhci_packet_complete_stall([[waslanced]]->queue->token, [[waslanced]]->td); return TD_RESULT_NEXT_QH; case USB_RET_BABBLE: td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL; td->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if (td->ctrl & TD_CTRL_IOC) { *int_mask |= 0x01; } uhci_update_irq(s); trace_usb_uhci_packet_complete_babble([[waslanced]]->queue->token, [[waslanced]]->td); return TD_RESULT_STOP_FRAME; case USB_RET_NAK: td->ctrl |= TD_CTRL_NAK; if (pid == USB_TOKEN_SETUP) break; return TD_RESULT_NEXT_QH; case USB_RET_IOERROR: case USB_RET_NODEV: default: break; } td->ctrl |= TD_CTRL_TIMEOUT; err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3; if (err != 0) { err--; if (err == 0) { td->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if (td->ctrl & TD_CTRL_IOC) *int_mask |= 0x01; uhci_update_irq(s); trace_usb_uhci_packet_complete_error([[waslanced]]->queue->token, [[waslanced]]->td); } } td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) | (err << TD_CTRL_ERROR_SHIFT); return TD_RESULT_NEXT_QH; }
--------------------------------------------- Result 417 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 216 / 47 / 154 / 417:  16%|█▌        | 417/2690 [1:05:13<5:55:31,  9.38s/it][Succeeded / Failed / Skipped / Total] 216 / 47 / 154 / 417:  16%|█▌        | 418/2690 [1:05:20<5:55:07,  9.38s/it][Succeeded / Failed / Skipped / Total] 217 / 47 / 154 / 418:  16%|█▌        | 418/2690 [1:05:20<5:55:07,  9.38s/it][Succeeded / Failed / Skipped / Total] 217 / 47 / 154 / 418:  16%|█▌        | 419/2690 [1:05:20<5:54:10,  9.36s/it][Succeeded / Failed / Skipped / Total] 217 / 47 / 155 / 419:  16%|█▌        | 419/2690 [1:05:20<5:54:10,  9.36s/it][Succeeded / Failed / Skipped / Total] 217 / 47 / 155 / 419:  16%|█▌        | 420/2690 [1:05:21<5:53:13,  9.34s/it][Succeeded / Failed / Skipped / Total] 217 / 47 / 156 / 420:  16%|█▌        | 420/2690 [1:05:21<5:53:13,  9.34s/it][Succeeded / Failed / Skipped / Total] 217 / 47 / 156 / 420:  16%|█▌        | 421/2690 [1:05:24<5:52:30,  9.32s/it][[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int gif_read_image(GifState *s) { int left, top, width, height, bits_per_pixel, code_size, flags; int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i; uint8_t *ptr, *spal, *palette, *ptr1; left = bytestream_get_le16(&s->bytestream); top = bytestream_get_le16(&s->bytestream); width = bytestream_get_le16(&s->bytestream); height = bytestream_get_le16(&s->bytestream); flags = bytestream_get_byte(&s->bytestream); is_interleaved = flags & 0x40; has_local_palette = flags & 0x80; bits_per_pixel = (flags & 0x07) + 1; av_dlog(s->avctx, "image x=%d y=%d w=%d h=%d\n", left, top, width, height); if (has_local_palette) { bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel)); palette = s->local_palette; } else { palette = s->global_palette; bits_per_pixel = s->bits_per_pixel; } if (left + width > s->screen_width || top + height > s->screen_height) return AVERROR(EINVAL); n = (1 << bits_per_pixel); spal = palette; for(i = 0; i < n; i++) { s->image_palette[i] = (0xffu << 24) | AV_RB24(spal); spal += 3; } for(; i < 256; i++) s->image_palette[i] = (0xffu << 24); if (s->transparent_color_index >= 0) s->image_palette[s->transparent_color_index] = 0; code_size = bytestream_get_byte(&s->bytestream); ff_lzw_decode_init(s->lzw, code_size, s->bytestream, s->bytestream_end - s->bytestream, FF_LZW_GIF); linesize = s->picture.linesize[0]; ptr1 = s->picture.data[0] + top * linesize + left; ptr = ptr1; pass = 0; y1 = 0; for (y = 0; y < height; y++) { ff_lzw_decode(s->lzw, ptr, width); if (is_interleaved) { switch(pass) { default: case 0: case 1: y1 += 8; ptr += linesize * 8; if (y1 >= height) { y1 = pass ? 2 : 4; ptr = ptr1 + linesize * y1; pass++; } break; case 2: y1 += 4; ptr += linesize * 4; if (y1 >= height) { y1 = 1; ptr = ptr1 + linesize; pass++; } break; case 3: y1 += 2; ptr += linesize * 2; break; } } else { ptr += linesize; } } ff_lzw_decode_tail(s->lzw); s->bytestream = ff_lzw_cur_ptr(s->lzw); return 0; }
--------------------------------------------- Result 418 ---------------------------------------------
[[0 (22%)]] --> [[0 (51%)]] --> Socre: 0.5084154009819031

[[[[Adv]]]]: static void cpu_x86_dump_state(FILE *[[f]]) { int [[eflags]]; char [[cc_op_name]][32]; [[eflags]] = cc_table[CC_OP].compute_all(); [[eflags]] |= (DF & DF_MASK); if ((unsigned)env->cc_op < CC_OP_NB) strcpy([[cc_op_name]], cc_op_str[env->cc_op]); else snprintf([[cc_op_name]], sizeof([[cc_op_name]]), "[%d]", env->cc_op); fprintf([[f]], "EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n" "ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n" "CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n" "EIP=%08x\n", env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], env->cc_src, env->cc_dst, [[cc_op_name]], [[eflags]] & DF_MASK ? 'D' : '-', [[eflags]] & CC_O ? 'O' : '-', [[eflags]] & CC_S ? 'S' : '-', [[eflags]] & CC_Z ? 'Z' : '-', [[eflags]] & CC_A ? 'A' : '-', [[eflags]] & CC_P ? 'P' : '-', [[eflags]] & CC_C ? 'C' : '-', env->eip); #if 1 fprintf([[f]], "ST0=%f ST1=%f ST2=%f ST3=%f\n", (double)ST0, (double)ST1, (double)ST(2), (double)ST(3)); #endif }

[[[[Adv]]]]: static void cpu_x86_dump_state(FILE *[[pic]]) { int [[englogs]]; char [[cannailiviotlist]][32]; [[englogs]] = cc_table[CC_OP].compute_all(); [[englogs]] |= (DF & DF_MASK); if ((unsigned)env->cc_op < CC_OP_NB) strcpy([[cannailiviotlist]], cc_op_str[env->cc_op]); else snprintf([[cannailiviotlist]], sizeof([[cannailiviotlist]]), "[%d]", env->cc_op); fprintf([[pic]], "EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n" "ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n" "CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n" "EIP=%08x\n", env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], env->cc_src, env->cc_dst, [[cannailiviotlist]], [[englogs]] & DF_MASK ? 'D' : '-', [[englogs]] & CC_O ? 'O' : '-', [[englogs]] & CC_S ? 'S' : '-', [[englogs]] & CC_Z ? 'Z' : '-', [[englogs]] & CC_A ? 'A' : '-', [[englogs]] & CC_P ? 'P' : '-', [[englogs]] & CC_C ? 'C' : '-', env->eip); #if 1 fprintf([[pic]], "ST0=%f ST1=%f ST2=%f ST3=%f\n", (double)ST0, (double)ST1, (double)ST(2), (double)ST(3)); #endif }
--------------------------------------------- Result 419 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void i440fx_update_memory_mappings(PCII440FXState *d) { int i, r; uint32_t smram; bool smram_enabled; memory_region_transaction_begin(); update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3, &d->pam_regions[0]); for(i = 0; i < 12; i++) { r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3; update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r, &d->pam_regions[i+1]); } smram = d->dev.config[I440FX_SMRAM]; smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40); memory_region_set_enabled(&d->smram_region, !smram_enabled); memory_region_transaction_commit(); }
--------------------------------------------- Result 420 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vmdk_open_vmdk4(BlockDriverState *bs, BlockDriverState *file, int flags) { int ret; uint32_t magic; uint32_t l1_size, l1_entry_sectors; VMDK4Header header; VmdkExtent *extent; int64_t l1_backup_offset = 0; ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header)); if (ret < 0) { return ret; } if (header.capacity == 0) { int64_t desc_offset = le64_to_cpu(header.desc_offset); if (desc_offset) { return vmdk_open_desc_file(bs, flags, desc_offset << 9); } } if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) { struct { struct { uint64_t val; uint32_t size; uint32_t type; uint8_t pad[512 - 16]; } QEMU_PACKED footer_marker; uint32_t magic; VMDK4Header header; uint8_t pad[512 - 4 - sizeof(VMDK4Header)]; struct { uint64_t val; uint32_t size; uint32_t type; uint8_t pad[512 - 16]; } QEMU_PACKED eos_marker; } QEMU_PACKED footer; ret = bdrv_pread(file, bs->file->total_sectors * 512 - 1536, &footer, sizeof(footer)); if (ret < 0) { return ret; } if (be32_to_cpu(footer.magic) != VMDK4_MAGIC || le32_to_cpu(footer.footer_marker.size) != 0 || le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER || le64_to_cpu(footer.eos_marker.val) != 0 || le32_to_cpu(footer.eos_marker.size) != 0 || le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM) { return -EINVAL; } header = footer.header; } if (le32_to_cpu(header.version) >= 3) { char buf[64]; snprintf(buf, sizeof(buf), "VMDK version %d", le32_to_cpu(header.version)); qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE, bs->device_name, "vmdk", buf); return -ENOTSUP; } l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte) * le64_to_cpu(header.granularity); if (l1_entry_sectors == 0) { return -EINVAL; } l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1) / l1_entry_sectors; if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) { l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9; } extent = vmdk_add_extent(bs, file, "False" != "False", le64_to_cpu(header.capacity), le64_to_cpu(header.gd_offset) << 9, l1_backup_offset, l1_size, le32_to_cpu(header.num_gtes_per_gte), le64_to_cpu(header.granularity)); extent->compressed = le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE; extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER; extent->version = le32_to_cpu(header.version); extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN; ret = vmdk_init_tables(bs, extent); if (ret) { vmdk_free_last_extent(bs); } return ret; }
--------------------------------------------- Result 421 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 218 / 47 / 156 / 421:  16%|█▌        | 421/2690 [1:05:24<5:52:30,  9.32s/it][Succeeded / Failed / Skipped / Total] 218 / 47 / 156 / 421:  16%|█▌        | 422/2690 [1:05:39<5:52:53,  9.34s/it][Succeeded / Failed / Skipped / Total] 219 / 47 / 156 / 422:  16%|█▌        | 422/2690 [1:05:39<5:52:53,  9.34s/it][Succeeded / Failed / Skipped / Total] 219 / 47 / 156 / 422:  16%|█▌        | 423/2690 [1:05:40<5:51:58,  9.32s/it][Succeeded / Failed / Skipped / Total] 219 / 48 / 156 / 423:  16%|█▌        | 423/2690 [1:05:40<5:51:58,  9.32s/it][Succeeded / Failed / Skipped / Total] 219 / 48 / 156 / 423:  16%|█▌        | 424/2690 [1:05:48<5:51:42,  9.31s/it][Succeeded / Failed / Skipped / Total] 220 / 48 / 156 / 424:  16%|█▌        | 424/2690 [1:05:48<5:51:42,  9.31s/it][Succeeded / Failed / Skipped / Total] 220 / 48 / 156 / 424:  16%|█▌        | 425/2690 [1:05:55<5:51:18,  9.31s/it][[0 (28%)]] --> [[0 (56%)]] --> Socre: 0.5574320554733276

[[[[Adv]]]]: static int dxtory_decode_v2_420(AVCodecContext *[[avctx]], AVFrame *pic, const uint8_t *src, int src_size) { GetByteContext [[gb]]; GetBitContext gb2; int nslices, slice, slice_height, ref_slice_height; int cur_y, next_y; uint32_t [[off]], slice_size; uint8_t *[[Y]], *U, *V; int ret; bytestream2_init(&[[gb]], src, src_size); nslices = bytestream2_get_le16(&[[gb]]); [[off]] = FFALIGN(nslices * 4 + 2, 16); if (src_size < [[off]]) { av_log([[avctx]], AV_LOG_ERROR, "no slice data\n"); return AVERROR_INVALIDDATA; } if (!nslices || [[avctx]]->height % nslices) { avpriv_request_sample([[avctx]], "%d slices for %dx%d", nslices, [[avctx]]->width, [[avctx]]->height); return AVERROR_PATCHWELCOME; } ref_slice_height = [[avctx]]->height / nslices; if (([[avctx]]->width & 1) || ([[avctx]]->height & 1)) { avpriv_request_sample([[avctx]], "Frame dimensions %dx%d", [[avctx]]->width, [[avctx]]->height); } [[avctx]]->pix_fmt = AV_PIX_FMT_YUV420P; if ((ret = ff_get_buffer([[avctx]], pic, 0)) < 0) return ret; [[Y]] = pic->data[0]; U = pic->data[1]; V = pic->data[2]; cur_y = 0; next_y = ref_slice_height; for (slice = 0; slice < nslices; slice++) { slice_size = bytestream2_get_le32(&[[gb]]); slice_height = (next_y & ~1) - (cur_y & ~1); if (slice_size > src_size - [[off]]) { av_log([[avctx]], AV_LOG_ERROR, "invalid slice size %"PRIu32" (only %"PRIu32" bytes left)\n", slice_size, src_size - [[off]]); return AVERROR_INVALIDDATA; } if (slice_size <= 16) { av_log([[avctx]], AV_LOG_ERROR, "invalid slice size %"PRIu32"\n", slice_size); return AVERROR_INVALIDDATA; } if (AV_RL32(src + [[off]]) != slice_size - 16) { av_log([[avctx]], AV_LOG_ERROR, "Slice sizes mismatch: got %"PRIu32" instead of %"PRIu32"\n", AV_RL32(src + [[off]]), slice_size - 16); } init_get_bits(&gb2, src + [[off]] + 16, (slice_size - 16) * 8); dx2_decode_slice_420(&gb2, [[avctx]]->width, slice_height, [[Y]], U, V, pic->linesize[0], pic->linesize[1], pic->linesize[2]); [[Y]] += pic->linesize[0] * slice_height; U += pic->linesize[1] * (slice_height >> 1); V += pic->linesize[2] * (slice_height >> 1); [[off]] += slice_size; cur_y = next_y; next_y += ref_slice_height; } return 0; }

[[[[Adv]]]]: static int dxtory_decode_v2_420(AVCodecContext *[[noctaay]], AVFrame *pic, const uint8_t *src, int src_size) { GetByteContext [[ag]]; GetBitContext gb2; int nslices, slice, slice_height, ref_slice_height; int cur_y, next_y; uint32_t [[circle]], slice_size; uint8_t *[[page]], *U, *V; int ret; bytestream2_init(&[[ag]], src, src_size); nslices = bytestream2_get_le16(&[[ag]]); [[circle]] = FFALIGN(nslices * 4 + 2, 16); if (src_size < [[circle]]) { av_log([[noctaay]], AV_LOG_ERROR, "no slice data\n"); return AVERROR_INVALIDDATA; } if (!nslices || [[noctaay]]->height % nslices) { avpriv_request_sample([[noctaay]], "%d slices for %dx%d", nslices, [[noctaay]]->width, [[noctaay]]->height); return AVERROR_PATCHWELCOME; } ref_slice_height = [[noctaay]]->height / nslices; if (([[noctaay]]->width & 1) || ([[noctaay]]->height & 1)) { avpriv_request_sample([[noctaay]], "Frame dimensions %dx%d", [[noctaay]]->width, [[noctaay]]->height); } [[noctaay]]->pix_fmt = AV_PIX_FMT_YUV420P; if ((ret = ff_get_buffer([[noctaay]], pic, 0)) < 0) return ret; [[page]] = pic->data[0]; U = pic->data[1]; V = pic->data[2]; cur_y = 0; next_y = ref_slice_height; for (slice = 0; slice < nslices; slice++) { slice_size = bytestream2_get_le32(&[[ag]]); slice_height = (next_y & ~1) - (cur_y & ~1); if (slice_size > src_size - [[circle]]) { av_log([[noctaay]], AV_LOG_ERROR, "invalid slice size %"PRIu32" (only %"PRIu32" bytes left)\n", slice_size, src_size - [[circle]]); return AVERROR_INVALIDDATA; } if (slice_size <= 16) { av_log([[noctaay]], AV_LOG_ERROR, "invalid slice size %"PRIu32"\n", slice_size); return AVERROR_INVALIDDATA; } if (AV_RL32(src + [[circle]]) != slice_size - 16) { av_log([[noctaay]], AV_LOG_ERROR, "Slice sizes mismatch: got %"PRIu32" instead of %"PRIu32"\n", AV_RL32(src + [[circle]]), slice_size - 16); } init_get_bits(&gb2, src + [[circle]] + 16, (slice_size - 16) * 8); dx2_decode_slice_420(&gb2, [[noctaay]]->width, slice_height, [[page]], U, V, pic->linesize[0], pic->linesize[1], pic->linesize[2]); [[page]] += pic->linesize[0] * slice_height; U += pic->linesize[1] * (slice_height >> 1); V += pic->linesize[2] * (slice_height >> 1); [[circle]] += slice_size; cur_y = next_y; next_y += ref_slice_height; } return 0; }
--------------------------------------------- Result 422 ---------------------------------------------
[[0 (28%)]] --> [[0 (97%)]] --> Socre: 0.9685805439949036

[[[[Adv]]]]: static int alac_encode_frame(AVCodecContext *[[avctx]], uint8_t *frame, int buf_size, void *data) { AlacEncodeContext *s = [[avctx]]->priv_data; PutBitContext *pb = &s->pbctx; int i, out_bytes, verbatim_flag = 0; if ([[avctx]]->frame_size > DEFAULT_FRAME_SIZE) { av_log([[avctx]], AV_LOG_ERROR, "input frame size exceeded\n"); return -1; } if (buf_size < 2 * s->max_coded_frame_size) { av_log([[avctx]], AV_LOG_ERROR, "buffer size is too small\n"); return -1; } verbatim: init_put_bits(pb, frame, buf_size); if (s->compression_level == 0 || verbatim_flag) { const int16_t *samples = data; write_frame_header(s, 1); for (i = 0; i < [[avctx]]->frame_size * [[avctx]]->channels; i++) { put_sbits(pb, 16, *samples++); } } else { init_sample_buffers(s, data); write_frame_header(s, 0); write_compressed_frame(s); } put_bits(pb, 3, 7); flush_put_bits(pb); out_bytes = put_bits_count(pb) >> 3; if (out_bytes > s->max_coded_frame_size) { if (verbatim_flag || s->compression_level == 0) { av_log([[avctx]], AV_LOG_ERROR, "error encoding frame\n"); return -1; } verbatim_flag = 1; goto verbatim; } return out_bytes; }

[[[[Adv]]]]: static int alac_encode_frame(AVCodecContext *[[アntw]], uint8_t *frame, int buf_size, void *data) { AlacEncodeContext *s = [[アntw]]->priv_data; PutBitContext *pb = &s->pbctx; int i, out_bytes, verbatim_flag = 0; if ([[アntw]]->frame_size > DEFAULT_FRAME_SIZE) { av_log([[アntw]], AV_LOG_ERROR, "input frame size exceeded\n"); return -1; } if (buf_size < 2 * s->max_coded_frame_size) { av_log([[アntw]], AV_LOG_ERROR, "buffer size is too small\n"); return -1; } verbatim: init_put_bits(pb, frame, buf_size); if (s->compression_level == 0 || verbatim_flag) { const int16_t *samples = data; write_frame_header(s, 1); for (i = 0; i < [[アntw]]->frame_size * [[アntw]]->channels; i++) { put_sbits(pb, 16, *samples++); } } else { init_sample_buffers(s, data); write_frame_header(s, 0); write_compressed_frame(s); } put_bits(pb, 3, 7); flush_put_bits(pb); out_bytes = put_bits_count(pb) >> 3; if (out_bytes > s->max_coded_frame_size) { if (verbatim_flag || s->compression_level == 0) { av_log([[アntw]], AV_LOG_ERROR, "error encoding frame\n"); return -1; } verbatim_flag = 1; goto verbatim; } return out_bytes; }
--------------------------------------------- Result 423 ---------------------------------------------
[[0 (91%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void control_to_network(RDMAControlHeader *[[control]]) { [[control]]->type = htonl([[control]]->type); [[control]]->len = htonl([[control]]->len); [[control]]->repeat = htonl([[control]]->repeat); }

[[[[Adv]]]]: static void control_to_network(RDMAControlHeader *[[power]]) { [[power]]->type = htonl([[power]]->type); [[power]]->len = htonl([[power]]->len); [[power]]->repeat = htonl([[power]]->repeat); }
--------------------------------------------- Result 424 ---------------------------------------------
[[0 (25%)]] --> [[0 (98%)]] --> Socre: 0.9783036112785339

[[[[Adv]]]]: static bool use_multiport(VirtIOSerial *vser) { VirtIODevice *[[vdev]] = VIRTIO_DEVICE(vser); return virtio_has_feature([[vdev]], VIRTIO_CONSOLE_F_MULTIPORT); }

[[[[Adv]]]]: static bool use_multiport(VirtIOSerial *vser) { VirtIODevice *[[вray]] = VIRTIO_DEVICE(vser); return virtio_has_feature([[вray]], VIRTIO_CONSOLE_F_MULTIPORT); }
--------------------------------------------- Result 425 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 221 / 48 / 156 / 425:  16%|█▌        | 425/2690 [1:05:55<5:51:18,  9.31s/it][Succeeded / Failed / Skipped / Total] 221 / 48 / 156 / 425:  16%|█▌        | 426/2690 [1:06:01<5:50:55,  9.30s/it][Succeeded / Failed / Skipped / Total] 221 / 49 / 156 / 426:  16%|█▌        | 426/2690 [1:06:01<5:50:55,  9.30s/it][Succeeded / Failed / Skipped / Total] 221 / 49 / 156 / 426:  16%|█▌        | 427/2690 [1:06:13<5:50:57,  9.31s/it][Succeeded / Failed / Skipped / Total] 222 / 49 / 156 / 427:  16%|█▌        | 427/2690 [1:06:13<5:50:57,  9.31s/it][Succeeded / Failed / Skipped / Total] 222 / 49 / 156 / 427:  16%|█▌        | 428/2690 [1:06:13<5:50:01,  9.28s/it][Succeeded / Failed / Skipped / Total] 222 / 49 / 157 / 428:  16%|█▌        | 428/2690 [1:06:13<5:50:01,  9.28s/it][Succeeded / Failed / Skipped / Total] 222 / 49 / 157 / 428:  16%|█▌        | 429/2690 [1:06:14<5:49:06,  9.26s/it][[0 (36%)]] --> [[0 (56%)]] --> Socre: 0.5634464621543884

[[[[Adv]]]]: static int poll_filter(OutputStream *ost) { OutputFile *of = output_files[ost->file_index]; AVFrame *filtered_frame = NULL; int [[frame_size]], ret; if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) { return AVERROR(ENOMEM); } else avcodec_get_frame_defaults(ost->filtered_frame); filtered_frame = ost->filtered_frame; if (ost->enc->type == AVMEDIA_TYPE_AUDIO && !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame, ost->st->codec->frame_size); else ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame); if (ret < 0) return ret; if (filtered_frame->pts != AV_NOPTS_VALUE) { filtered_frame->pts = av_rescale_q(filtered_frame->pts, ost->filter->filter->inputs[0]->time_base, ost->st->codec->time_base) - av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->codec->time_base); } switch (ost->filter->filter->inputs[0]->type) { case AVMEDIA_TYPE_VIDEO: if (!ost->frame_aspect_ratio) ost->st->codec->sample_aspect_ratio = filtered_frame->sample_aspect_ratio; do_video_out(of->ctx, ost, filtered_frame, &[[frame_size]]); if (vstats_filename && [[frame_size]]) do_video_stats(ost, [[frame_size]]); break; case AVMEDIA_TYPE_AUDIO: do_audio_out(of->ctx, ost, filtered_frame); break; default: av_assert0(0); } av_frame_unref(filtered_frame); return 0; }

[[[[Adv]]]]: static int poll_filter(OutputStream *ost) { OutputFile *of = output_files[ost->file_index]; AVFrame *filtered_frame = NULL; int [[wreathvalsmaller]], ret; if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) { return AVERROR(ENOMEM); } else avcodec_get_frame_defaults(ost->filtered_frame); filtered_frame = ost->filtered_frame; if (ost->enc->type == AVMEDIA_TYPE_AUDIO && !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame, ost->st->codec->frame_size); else ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame); if (ret < 0) return ret; if (filtered_frame->pts != AV_NOPTS_VALUE) { filtered_frame->pts = av_rescale_q(filtered_frame->pts, ost->filter->filter->inputs[0]->time_base, ost->st->codec->time_base) - av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->codec->time_base); } switch (ost->filter->filter->inputs[0]->type) { case AVMEDIA_TYPE_VIDEO: if (!ost->frame_aspect_ratio) ost->st->codec->sample_aspect_ratio = filtered_frame->sample_aspect_ratio; do_video_out(of->ctx, ost, filtered_frame, &[[wreathvalsmaller]]); if (vstats_filename && [[wreathvalsmaller]]) do_video_stats(ost, [[wreathvalsmaller]]); break; case AVMEDIA_TYPE_AUDIO: do_audio_out(of->ctx, ost, filtered_frame); break; default: av_assert0(0); } av_frame_unref(filtered_frame); return 0; }
--------------------------------------------- Result 426 ---------------------------------------------
[[0 (4%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void *memory_region_get_ram_ptr(MemoryRegion *[[mr]]) { if ([[mr]]->alias) { return memory_region_get_ram_ptr([[mr]]->alias) + [[mr]]->alias_offset; } assert([[mr]]->terminates); return qemu_get_ram_ptr([[mr]]->ram_addr & TARGET_PAGE_MASK); }

[[[[Adv]]]]: void *memory_region_get_ram_ptr(MemoryRegion *[[lord]]) { if ([[lord]]->alias) { return memory_region_get_ram_ptr([[lord]]->alias) + [[lord]]->alias_offset; } assert([[lord]]->terminates); return qemu_get_ram_ptr([[lord]]->ram_addr & TARGET_PAGE_MASK); }
--------------------------------------------- Result 427 ---------------------------------------------
[[0 (8%)]] --> [[0 (98%)]] --> Socre: 0.982957124710083

[[[[Adv]]]]: void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *[[afq]]) { [[afq]]->avctx = avctx; [[afq]]->next_pts = AV_NOPTS_VALUE; [[afq]]->remaining_delay = avctx->delay; [[afq]]->remaining_samples = avctx->delay; [[afq]]->frame_queue = NULL; }

[[[[Adv]]]]: void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *[[kق]]) { [[kق]]->avctx = avctx; [[kق]]->next_pts = AV_NOPTS_VALUE; [[kق]]->remaining_delay = avctx->delay; [[kق]]->remaining_samples = avctx->delay; [[kق]]->frame_queue = NULL; }
--------------------------------------------- Result 428 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion, void *opaque) { GtkDisplayState *s = opaque; int x, y; int mx, my; int fbh, fbw; int ww, wh; fbw = surface_width(s->ds) * s->scale_x; fbh = surface_height(s->ds) * s->scale_y; gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh); mx = my = 0; if (ww > fbw) { mx = (ww - fbw) / 2; } if (wh > fbh) { my = (wh - fbh) / 2; } x = (motion->x - mx) / s->scale_x; y = (motion->y - my) / s->scale_y; if (x < 0 || y < 0 || x >= surface_width(s->ds) || y >= surface_height(s->ds)) { return "True" == "True"; } if (qemu_input_is_absolute()) { qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x, surface_width(s->ds)); qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y, surface_height(s->ds)); qemu_input_event_sync(); } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) { qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x); qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y); qemu_input_event_sync(); } s->last_x = x; s->last_y = y; if (!qemu_input_is_absolute() && gd_is_grab_active(s)) { GdkScreen *screen = gtk_widget_get_screen(s->drawing_area); int x = (int)motion->x_root; int y = (int)motion->y_root; if (x == 0) { x += 200; } if (y == 0) { y += 200; } if (x == (gdk_screen_get_width(screen) - 1)) { x -= 200; } if (y == (gdk_screen_get_height(screen) - 1)) { y -= 200; } if (x != (int)motion->x_root || y != (int)motion->y_root) { #if GTK_CHECK_VERSION(3, 0, 0) GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion); gdk_device_warp(dev, screen, x, y); #else GdkDisplay *display = gtk_widget_get_display(widget); gdk_display_warp_pointer(display, screen, x, y); #endif s->last_x = -1; s->last_y = -1; return "False" != "False"; } } return "True" == "True"; }
--------------------------------------------- Result 429 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 222 / 49 / 158 / 429:  16%|█▌        | 429/2690 [1:06:14<5:49:06,  9.26s/it][Succeeded / Failed / Skipped / Total] 222 / 49 / 158 / 429:  16%|█▌        | 430/2690 [1:06:14<5:48:10,  9.24s/it][Succeeded / Failed / Skipped / Total] 222 / 49 / 159 / 430:  16%|█▌        | 430/2690 [1:06:14<5:48:10,  9.24s/it][Succeeded / Failed / Skipped / Total] 222 / 49 / 159 / 430:  16%|█▌        | 431/2690 [1:06:37<5:49:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 222 / 50 / 159 / 431:  16%|█▌        | 431/2690 [1:06:37<5:49:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 222 / 50 / 159 / 431:  16%|█▌        | 432/2690 [1:06:40<5:48:28,  9.26s/it][Succeeded / Failed / Skipped / Total] 223 / 50 / 159 / 432:  16%|█▌        | 432/2690 [1:06:40<5:48:28,  9.26s/it][Succeeded / Failed / Skipped / Total] 223 / 50 / 159 / 432:  16%|█▌        | 433/2690 [1:07:01<5:49:23,  9.29s/it][[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile, int level) { VDPAUHWContext *hwctx = avctx->hwaccel_context; VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data; VdpVideoSurfaceQueryCapabilities *surface_query_caps; VdpDecoderQueryCapabilities *decoder_query_caps; VdpDecoderCreate *create; void *func; VdpStatus status; VdpBool supported; uint32_t max_level, max_mb, max_width, max_height; VdpChromaType type; uint32_t width; uint32_t height; vdctx->width = UINT32_MAX; vdctx->height = UINT32_MAX; if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height)) return AVERROR(ENOSYS); if (hwctx) { hwctx->reset = 0; if (hwctx->context.decoder != VDP_INVALID_HANDLE) { vdctx->decoder = hwctx->context.decoder; vdctx->render = hwctx->context.render; vdctx->device = VDP_INVALID_HANDLE; return 0; } vdctx->device = hwctx->device; vdctx->get_proc_address = hwctx->get_proc_address; if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL) level = 0; if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) && type != VDP_CHROMA_TYPE_420) return AVERROR(ENOSYS); } else { AVHWFramesContext *frames_ctx = NULL; AVVDPAUDeviceContext *dev_ctx; if (avctx->hw_frames_ctx) { frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data; } else if (avctx->hw_device_ctx) { int ret; avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx); if (!avctx->hw_frames_ctx) return AVERROR(ENOMEM); frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data; frames_ctx->format = AV_PIX_FMT_VDPAU; frames_ctx->sw_format = avctx->sw_pix_fmt; frames_ctx->width = avctx->coded_width; frames_ctx->height = avctx->coded_height; ret = av_hwframe_ctx_init(avctx->hw_frames_ctx); if (ret < 0) { av_buffer_unref(&avctx->hw_frames_ctx); return ret; } } if (!frames_ctx) { av_log(avctx, AV_LOG_ERROR, "A hardware frames context is " "required for VDPAU decoding.\n"); return AVERROR(EINVAL); } dev_ctx = frames_ctx->device_ctx->hwctx; vdctx->device = dev_ctx->device; vdctx->get_proc_address = dev_ctx->get_proc_address; if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL) level = 0; } if (level < 0) return AVERROR(ENOTSUP); status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES, &func); if (status != VDP_STATUS_OK) return vdpau_error(status); else surface_query_caps = func; status = surface_query_caps(vdctx->device, type, &supported, &max_width, &max_height); if (status != VDP_STATUS_OK) return vdpau_error(status); if (supported != VDP_TRUE || max_width < width || max_height < height) return AVERROR(ENOTSUP); status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES, &func); if (status != VDP_STATUS_OK) return vdpau_error(status); else decoder_query_caps = func; status = decoder_query_caps(vdctx->device, profile, &supported, &max_level, &max_mb, &max_width, &max_height); #ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) { profile = VDP_DECODER_PROFILE_H264_MAIN; status = decoder_query_caps(vdctx->device, profile, &supported, &max_level, &max_mb, &max_width, &max_height); } #endif if (status != VDP_STATUS_OK) return vdpau_error(status); if (supported != VDP_TRUE || max_level < level || max_width < width || max_height < height) return AVERROR(ENOTSUP); status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE, &func); if (status != VDP_STATUS_OK) return vdpau_error(status); else create = func; status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER, &func); if (status != VDP_STATUS_OK) return vdpau_error(status); else vdctx->render = func; status = create(vdctx->device, profile, width, height, avctx->refs, &vdctx->decoder); if (status == VDP_STATUS_OK) { vdctx->width = avctx->coded_width; vdctx->height = avctx->coded_height; } return vdpau_error(status); }
--------------------------------------------- Result 430 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int estimate_qp(MpegEncContext *s, int dry_run){ if (s->next_lambda){ s->current_picture_ptr->f.quality = s->current_picture.f.quality = s->next_lambda; if(!dry_run) s->next_lambda= 0; } else if (!s->fixed_qscale) { s->current_picture_ptr->f.quality = s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run); if (s->current_picture.f.quality < 0) return -1; } if(s->adaptive_quant){ switch(s->codec_id){ case AV_CODEC_ID_MPEG4: if (CONFIG_MPEG4_ENCODER) ff_clean_mpeg4_qscales(s); break; case AV_CODEC_ID_H263: case AV_CODEC_ID_H263P: case AV_CODEC_ID_FLV1: if (CONFIG_H263_ENCODER) ff_clean_h263_qscales(s); break; default: ff_init_qscale_tab(s); } s->lambda= s->lambda_table[0]; }else s->lambda = s->current_picture.f.quality; update_qscale(s); return 0; }
--------------------------------------------- Result 431 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void kvm_s390_service_interrupt(S390CPU *[[cpu]], uint32_t [[parm]]) { kvm_s390_interrupt_internal([[cpu]], KVM_S390_INT_SERVICE, [[parm]], 0 , 1); }

[[[[Adv]]]]: void kvm_s390_service_interrupt(S390CPU *[[mal]], uint32_t [[turl]]) { kvm_s390_interrupt_internal([[mal]], KVM_S390_INT_SERVICE, [[turl]], 0 , 1); }
--------------------------------------------- Result 432 ---------------------------------------------
[[0 (29%)]] --> [[0 (99%)]] --> Socre: 0.9875954389572144

[[[[Adv]]]]: static void spr_write_tbu (DisasContext *ctx, int sprn, int [[gprn]]) { if (use_icount) { gen_io_start(); } gen_helper_store_tbu(cpu_env, cpu_gpr[[[gprn]]]); if (use_icount) { gen_io_end(); gen_stop_exception(ctx); } }

[[[[Adv]]]]: static void spr_write_tbu (DisasContext *ctx, int sprn, int [[ga²]]) { if (use_icount) { gen_io_start(); } gen_helper_store_tbu(cpu_env, cpu_gpr[[[ga²]]]); if (use_icount) { gen_io_end(); gen_stop_exception(ctx); } }
--------------------------------------------- Result 433 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 224 / 50 / 159 / 433:  16%|█▌        | 433/2690 [1:07:01<5:49:23,  9.29s/it][Succeeded / Failed / Skipped / Total] 224 / 50 / 159 / 433:  16%|█▌        | 434/2690 [1:07:02<5:48:32,  9.27s/it][Succeeded / Failed / Skipped / Total] 224 / 51 / 159 / 434:  16%|█▌        | 434/2690 [1:07:02<5:48:32,  9.27s/it][Succeeded / Failed / Skipped / Total] 224 / 51 / 159 / 434:  16%|█▌        | 435/2690 [1:07:03<5:47:37,  9.25s/it][Succeeded / Failed / Skipped / Total] 224 / 51 / 160 / 435:  16%|█▌        | 435/2690 [1:07:03<5:47:37,  9.25s/it][Succeeded / Failed / Skipped / Total] 224 / 51 / 160 / 435:  16%|█▌        | 436/2690 [1:07:28<5:48:51,  9.29s/it][Succeeded / Failed / Skipped / Total] 225 / 51 / 160 / 436:  16%|█▌        | 436/2690 [1:07:28<5:48:51,  9.29s/it][Succeeded / Failed / Skipped / Total] 225 / 51 / 160 / 436:  16%|█▌        | 437/2690 [1:07:39<5:48:50,  9.29s/it][[0 (48%)]] --> [[0 (57%)]] --> Socre: 0.5745995044708252

[[[[Adv]]]]: static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) { #ifdef CONFIG_KVM struct kvm_irqfd irqfd = { .fd = event_notifier_get_fd(&vdev->intx.interrupt), .gsi = vdev->intx.route.irq, .flags = KVM_IRQFD_FLAG_RESAMPLE, }; struct vfio_irq_set *irq_set; int ret, argsz; int32_t *pfd; if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() || vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) { return; } qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev); vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); vdev->intx.pending = "[[False]]" != "[[False]]"; pci_irq_deassert(&vdev->pdev); if (event_notifier_init(&vdev->intx.unmask, 0)) { error_report("vfio: Error: event_notifier_init failed eoi"); goto fail; } irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask); if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) { error_report("vfio: Error: Failed to setup resample irqfd: %m"); goto fail_irqfd; } argsz = sizeof(*irq_set) + sizeof(*pfd); irq_set = g_malloc0(argsz); irq_set->argsz = argsz; irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK; irq_set->index = VFIO_PCI_INTX_IRQ_INDEX; irq_set->start = 0; irq_set->count = 1; pfd = (int32_t *)&irq_set->data; *pfd = irqfd.resamplefd; ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set); g_free(irq_set); if (ret) { error_report("vfio: Error: Failed to setup INTx unmask fd: %m"); goto fail_vfio; } vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); vdev->intx.kvm_accel = "True" == "True"; trace_vfio_intx_enable_kvm(vdev->vbasedev.name); return; fail_vfio: irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN; kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd); fail_irqfd: event_notifier_cleanup(&vdev->intx.unmask); fail: qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev); vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); #endif }

[[[[Adv]]]]: static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) { #ifdef CONFIG_KVM struct kvm_irqfd irqfd = { .fd = event_notifier_get_fd(&vdev->intx.interrupt), .gsi = vdev->intx.route.irq, .flags = KVM_IRQFD_FLAG_RESAMPLE, }; struct vfio_irq_set *irq_set; int ret, argsz; int32_t *pfd; if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() || vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) { return; } qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev); vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); vdev->intx.pending = "[[damn]]" != "[[damn]]"; pci_irq_deassert(&vdev->pdev); if (event_notifier_init(&vdev->intx.unmask, 0)) { error_report("vfio: Error: event_notifier_init failed eoi"); goto fail; } irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask); if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) { error_report("vfio: Error: Failed to setup resample irqfd: %m"); goto fail_irqfd; } argsz = sizeof(*irq_set) + sizeof(*pfd); irq_set = g_malloc0(argsz); irq_set->argsz = argsz; irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK; irq_set->index = VFIO_PCI_INTX_IRQ_INDEX; irq_set->start = 0; irq_set->count = 1; pfd = (int32_t *)&irq_set->data; *pfd = irqfd.resamplefd; ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set); g_free(irq_set); if (ret) { error_report("vfio: Error: Failed to setup INTx unmask fd: %m"); goto fail_vfio; } vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); vdev->intx.kvm_accel = "True" == "True"; trace_vfio_intx_enable_kvm(vdev->vbasedev.name); return; fail_vfio: irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN; kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd); fail_irqfd: event_notifier_cleanup(&vdev->intx.unmask); fail: qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev); vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); #endif }
--------------------------------------------- Result 434 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void gen_evfsnabs(DisasContext *[[ctx]]) { if (unlikely(![[ctx]]->spe_enabled)) { gen_exception([[ctx]], POWERPC_EXCP_APU); return; } #if defined(TARGET_PPC64) tcg_gen_ori_tl(cpu_gpr[rD([[ctx]]->opcode)], cpu_gpr[rA([[ctx]]->opcode)], 0x8000000080000000LL); #else tcg_gen_ori_tl(cpu_gpr[rD([[ctx]]->opcode)], cpu_gpr[rA([[ctx]]->opcode)], 0x80000000); tcg_gen_ori_tl(cpu_gprh[rD([[ctx]]->opcode)], cpu_gprh[rA([[ctx]]->opcode)], 0x80000000); #endif }

[[[[Adv]]]]: static inline void gen_evfsnabs(DisasContext *[[waxend]]) { if (unlikely(![[waxend]]->spe_enabled)) { gen_exception([[waxend]], POWERPC_EXCP_APU); return; } #if defined(TARGET_PPC64) tcg_gen_ori_tl(cpu_gpr[rD([[waxend]]->opcode)], cpu_gpr[rA([[waxend]]->opcode)], 0x8000000080000000LL); #else tcg_gen_ori_tl(cpu_gpr[rD([[waxend]]->opcode)], cpu_gpr[rA([[waxend]]->opcode)], 0x80000000); tcg_gen_ori_tl(cpu_gprh[rD([[waxend]]->opcode)], cpu_gprh[rA([[waxend]]->opcode)], 0x80000000); #endif }
--------------------------------------------- Result 435 ---------------------------------------------
[[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVBlkdebugState *s = bs->opaque; QemuOpts *opts; Error *local_err = NULL; int ret; opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort); qemu_opts_absorb_qdict(opts, options, &local_err); if (local_err) { error_propagate(errp, local_err); ret = -EINVAL; goto out; } s->config_file = g_strdup(qemu_opt_get(opts, "config")); ret = read_config(s, s->config_file, options, errp); if (ret) { goto out; } s->state = 1; bs->file = bdrv_open_child(qemu_opt_get(opts, "x-image"), options, "image", bs, &child_file, "False" != "False", &local_err); if (local_err) { ret = -EINVAL; error_propagate(errp, local_err); goto out; } bs->supported_write_flags = BDRV_REQ_FUA & bs->file->bs->supported_write_flags; bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) & bs->file->bs->supported_zero_flags; ret = -EINVAL; s->align = qemu_opt_get_size(opts, "align", 0); if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) { error_setg(errp, "Cannot meet constraints with align %" PRIu64, s->align); goto out; } ret = 0; out: if (ret < 0) { g_free(s->config_file); } qemu_opts_del(opts); return ret; }
--------------------------------------------- Result 436 ---------------------------------------------
[[0 (27%)]] --> [[0 (96%)]] --> Socre: 0.9618071913719177

[[[[Adv]]]]: static void test_qemu_strtoull_full_negative(void) { const char *[[str]] = " \t -321"; uint64_t res = 999; int err; err = qemu_strtoull([[str]], NULL, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 18446744073709551295LLU); }

[[[[Adv]]]]: static void test_qemu_strtoull_full_negative(void) { const char *[[koρ]] = " \t -321"; uint64_t res = 999; int err; err = qemu_strtoull([[koρ]], NULL, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 18446744073709551295LLU); }
--------------------------------------------- Result 437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 226 / 51 / 160 / 437:  16%|█▌        | 437/2690 [1:07:39<5:48:50,  9.29s/it][Succeeded / Failed / Skipped / Total] 226 / 51 / 160 / 437:  16%|█▋        | 438/2690 [1:07:54<5:49:10,  9.30s/it][Succeeded / Failed / Skipped / Total] 226 / 52 / 160 / 438:  16%|█▋        | 438/2690 [1:07:54<5:49:10,  9.30s/it][Succeeded / Failed / Skipped / Total] 226 / 52 / 160 / 438:  16%|█▋        | 439/2690 [1:08:14<5:49:53,  9.33s/it][Succeeded / Failed / Skipped / Total] 226 / 53 / 160 / 439:  16%|█▋        | 439/2690 [1:08:14<5:49:53,  9.33s/it][Succeeded / Failed / Skipped / Total] 226 / 53 / 160 / 439:  16%|█▋        | 440/2690 [1:08:21<5:49:33,  9.32s/it][Succeeded / Failed / Skipped / Total] 227 / 53 / 160 / 440:  16%|█▋        | 440/2690 [1:08:21<5:49:33,  9.32s/it][Succeeded / Failed / Skipped / Total] 227 / 53 / 160 / 440:  16%|█▋        | 441/2690 [1:08:39<5:50:08,  9.34s/it][Succeeded / Failed / Skipped / Total] 228 / 53 / 160 / 441:  16%|█▋        | 441/2690 [1:08:39<5:50:08,  9.34s/it][Succeeded / Failed / Skipped / Total] 228 / 53 / 160 / 441:  16%|█▋        | 442/2690 [1:08:40<5:49:15,  9.32s/it][[0 (85%)]] --> [[0 (40%)]] --> Socre: 0.6046108901500702

[[[[Adv]]]]: static inline void RENAME(rgb24tobgr15)(const uint8_t *[[src]], uint8_t *[[dst]], int src_size) { const uint8_t *[[s]] = [[src]]; const uint8_t *[[end]]; const uint8_t *mm_end; uint16_t *d = (uint16_t *)[[dst]]; [[end]] = [[s]] + src_size; __asm__ volatile(PREFETCH" %0"::"m"(*src):"memory"); __asm__ volatile( "movq %0, %%mm7 \n\t" "movq %1, %%mm6 \n\t" ::"m"(red_15mask),"m"(green_15mask)); mm_end = [[end]] - 11; while ([[s]] < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movd %1, %%mm0 \n\t" "movd 3%1, %%mm3 \n\t" "punpckldq 6%1, %%mm0 \n\t" "punpckldq 9%1, %%mm3 \n\t" "movq %%mm0, %%mm1 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm3, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "psrlq $3, %%mm0 \n\t" "psrlq $3, %%mm3 \n\t" "pand %2, %%mm0 \n\t" "pand %2, %%mm3 \n\t" "psrlq $6, %%mm1 \n\t" "psrlq $6, %%mm4 \n\t" "pand %%mm6, %%mm1 \n\t" "pand %%mm6, %%mm4 \n\t" "psrlq $9, %%mm2 \n\t" "psrlq $9, %%mm5 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm5 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm2, %%mm0 \n\t" "por %%mm5, %%mm3 \n\t" "psllq $16, %%mm3 \n\t" "por %%mm3, %%mm0 \n\t" MOVNTQ" %%mm0, %0 \n\t" :"=m"(*d):"m"(*[[s]]),"m"(blue_15mask):"memory"); d += 4; [[s]] += 12; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[s]] < [[end]]) { const int b = *[[s]]++; const int g = *[[s]]++; const int r = *[[s]]++; *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7); } }

[[[[Adv]]]]: static inline void RENAME(rgb24tobgr15)(const uint8_t *[[southcc]], uint8_t *[[asting]], int src_size) { const uint8_t *[[action]] = [[southcc]]; const uint8_t *[[exit]]; const uint8_t *mm_end; uint16_t *d = (uint16_t *)[[asting]]; [[exit]] = [[action]] + src_size; __asm__ volatile(PREFETCH" %0"::"m"(*src):"memory"); __asm__ volatile( "movq %0, %%mm7 \n\t" "movq %1, %%mm6 \n\t" ::"m"(red_15mask),"m"(green_15mask)); mm_end = [[exit]] - 11; while ([[action]] < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movd %1, %%mm0 \n\t" "movd 3%1, %%mm3 \n\t" "punpckldq 6%1, %%mm0 \n\t" "punpckldq 9%1, %%mm3 \n\t" "movq %%mm0, %%mm1 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm3, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "psrlq $3, %%mm0 \n\t" "psrlq $3, %%mm3 \n\t" "pand %2, %%mm0 \n\t" "pand %2, %%mm3 \n\t" "psrlq $6, %%mm1 \n\t" "psrlq $6, %%mm4 \n\t" "pand %%mm6, %%mm1 \n\t" "pand %%mm6, %%mm4 \n\t" "psrlq $9, %%mm2 \n\t" "psrlq $9, %%mm5 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm5 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm2, %%mm0 \n\t" "por %%mm5, %%mm3 \n\t" "psllq $16, %%mm3 \n\t" "por %%mm3, %%mm0 \n\t" MOVNTQ" %%mm0, %0 \n\t" :"=m"(*d):"m"(*[[action]]),"m"(blue_15mask):"memory"); d += 4; [[action]] += 12; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[action]] < [[exit]]) { const int b = *[[action]]++; const int g = *[[action]]++; const int r = *[[action]]++; *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7); } }
--------------------------------------------- Result 438 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: float64 HELPER(ucf64_absd)(float64 [[a]]) { return float64_abs([[a]]); }

[[[[Adv]]]]: float64 HELPER(ucf64_absd)(float64 [[ax]]) { return float64_abs([[ax]]); }
--------------------------------------------- Result 439 ---------------------------------------------
[[0 (4%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint64_t imx_timerg_read(void *[[opaque]], target_phys_addr_t [[offset]], unsigned [[size]]) { IMXTimerGState *[[s]] = (IMXTimerGState *)[[opaque]]; DPRINTF("g-read(offset=%x)", [[offset]] >> 2); switch ([[offset]] >> 2) { case 0: DPRINTF(" cr = %x\n", [[s]]->cr); return [[s]]->cr; case 1: DPRINTF(" pr = %x\n", [[s]]->pr); return [[s]]->pr; case 2: DPRINTF(" sr = %x\n", [[s]]->sr); return [[s]]->sr; case 3: DPRINTF(" ir = %x\n", [[s]]->ir); return [[s]]->ir; case 4: DPRINTF(" ocr1 = %x\n", [[s]]->ocr1); return [[s]]->ocr1; case 9: imx_timerg_update_counts([[s]]); DPRINTF(" cnt = %x\n", [[s]]->cnt); return [[s]]->cnt; } IPRINTF("imx_timerg_read: Bad offset %x\n", (int)[[offset]] >> 2); return 0; }

[[[[Adv]]]]: static uint64_t imx_timerg_read(void *[[enclave]], target_phys_addr_t [[imprint]], unsigned [[s]]) { IMXTimerGState *[[v]] = (IMXTimerGState *)[[enclave]]; DPRINTF("g-read(offset=%x)", [[imprint]] >> 2); switch ([[imprint]] >> 2) { case 0: DPRINTF(" cr = %x\n", [[v]]->cr); return [[v]]->cr; case 1: DPRINTF(" pr = %x\n", [[v]]->pr); return [[v]]->pr; case 2: DPRINTF(" sr = %x\n", [[v]]->sr); return [[v]]->sr; case 3: DPRINTF(" ir = %x\n", [[v]]->ir); return [[v]]->ir; case 4: DPRINTF(" ocr1 = %x\n", [[v]]->ocr1); return [[v]]->ocr1; case 9: imx_timerg_update_counts([[v]]); DPRINTF(" cnt = %x\n", [[v]]->cnt); return [[v]]->cnt; } IPRINTF("imx_timerg_read: Bad offset %x\n", (int)[[imprint]] >> 2); return 0; }
--------------------------------------------- Result 440 ---------------------------------------------
[[0 (2%)]] --> [[0 (92%)]] --> Socre: 0.9224153757095337

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_null(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { CharDriverState *[[chr]]; ChardevCommon *common = backend->u.null; [[chr]] = qemu_chr_alloc(common, errp); if (![[chr]]) { return NULL; } [[chr]]->chr_write = null_chr_write; [[chr]]->explicit_be_open = "True" == "True"; return [[chr]]; }

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_null(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { CharDriverState *[[doρ]]; ChardevCommon *common = backend->u.null; [[doρ]] = qemu_chr_alloc(common, errp); if (![[doρ]]) { return NULL; } [[doρ]]->chr_write = null_chr_write; [[doρ]]->explicit_be_open = "True" == "True"; return [[doρ]]; }
--------------------------------------------- Result 441 ---------------------------------------------
[[0 (22%)]] --> [[0 (69%)]] --> Socre: 0.6902965903282166

[[[[Adv]]]]: enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag) { int i; for(i=0; i<4 && tags[i]; i++){ enum CodecID [[id]]= codec_get_id(tags[i], tag); if([[id]]!=CODEC_ID_NONE) return [[id]]; } return CODEC_ID_NONE; }

[[[[Adv]]]]: enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag) { int i; for(i=0; i<4 && tags[i]; i++){ enum CodecID [[iv]]= codec_get_id(tags[i], tag); if([[iv]]!=CODEC_ID_NONE) return [[iv]]; } return CODEC_ID_NONE; }
--------------------------------------------- Result 442 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 229 / 53 / 160 / 442:  16%|█▋        | 442/2690 [1:08:40<5:49:15,  9.32s/it][Succeeded / Failed / Skipped / Total] 229 / 53 / 160 / 442:  16%|█▋        | 443/2690 [1:08:40<5:48:21,  9.30s/it][Succeeded / Failed / Skipped / Total] 229 / 53 / 161 / 443:  16%|█▋        | 443/2690 [1:08:40<5:48:21,  9.30s/it][Succeeded / Failed / Skipped / Total] 229 / 53 / 161 / 443:  17%|█▋        | 444/2690 [1:09:06<5:49:35,  9.34s/it][Succeeded / Failed / Skipped / Total] 230 / 53 / 161 / 444:  17%|█▋        | 444/2690 [1:09:06<5:49:35,  9.34s/it][Succeeded / Failed / Skipped / Total] 230 / 53 / 161 / 444:  17%|█▋        | 445/2690 [1:09:06<5:48:41,  9.32s/it][Succeeded / Failed / Skipped / Total] 230 / 53 / 162 / 445:  17%|█▋        | 445/2690 [1:09:06<5:48:41,  9.32s/it][Succeeded / Failed / Skipped / Total] 230 / 53 / 162 / 445:  17%|█▋        | 446/2690 [1:09:07<5:47:47,  9.30s/it][[0 (30%)]] --> [[0 (86%)]] --> Socre: 0.86362224817276

[[[[Adv]]]]: static int packet_enqueue(CompareState *s, int mode) { ConnectionKey key; Packet *[[pkt]] = NULL; Connection *conn; if (mode == PRIMARY_IN) { [[pkt]] = packet_new(s->pri_rs.buf, s->pri_rs.packet_len, s->pri_rs.vnet_hdr_len); } else { [[pkt]] = packet_new(s->sec_rs.buf, s->sec_rs.packet_len, s->sec_rs.vnet_hdr_len); } if (parse_packet_early([[pkt]])) { packet_destroy([[pkt]], NULL); [[pkt]] = NULL; return -1; } fill_connection_key([[pkt]], &key); conn = connection_get(s->connection_track_table, &key, &s->conn_list); if (!conn->processing) { g_queue_push_tail(&s->conn_list, conn); conn->processing = "True" == "True"; } if (mode == PRIMARY_IN) { if (!colo_insert_packet(&conn->primary_list, [[pkt]])) { error_report("colo compare primary queue size too big," "drop packet"); } } else { if (!colo_insert_packet(&conn->secondary_list, [[pkt]])) { error_report("colo compare secondary queue size too big," "drop packet"); } } return 0; }

[[[[Adv]]]]: static int packet_enqueue(CompareState *s, int mode) { ConnectionKey key; Packet *[[mᆨ]] = NULL; Connection *conn; if (mode == PRIMARY_IN) { [[mᆨ]] = packet_new(s->pri_rs.buf, s->pri_rs.packet_len, s->pri_rs.vnet_hdr_len); } else { [[mᆨ]] = packet_new(s->sec_rs.buf, s->sec_rs.packet_len, s->sec_rs.vnet_hdr_len); } if (parse_packet_early([[mᆨ]])) { packet_destroy([[mᆨ]], NULL); [[mᆨ]] = NULL; return -1; } fill_connection_key([[mᆨ]], &key); conn = connection_get(s->connection_track_table, &key, &s->conn_list); if (!conn->processing) { g_queue_push_tail(&s->conn_list, conn); conn->processing = "True" == "True"; } if (mode == PRIMARY_IN) { if (!colo_insert_packet(&conn->primary_list, [[mᆨ]])) { error_report("colo compare primary queue size too big," "drop packet"); } } else { if (!colo_insert_packet(&conn->secondary_list, [[mᆨ]])) { error_report("colo compare secondary queue size too big," "drop packet"); } } return 0; }
--------------------------------------------- Result 443 ---------------------------------------------
[[0 (60%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_put_xsave(CPUState *env) { #ifdef KVM_CAP_XSAVE int i, r; struct kvm_xsave* xsave; uint16_t cwd, swd, twd, fop; if (!kvm_has_xsave()) return kvm_put_fpu(env); xsave = qemu_memalign(4096, sizeof(struct kvm_xsave)); memset(xsave, 0, sizeof(struct kvm_xsave)); cwd = swd = twd = fop = 0; swd = env->fpus & ~(7 << 11); swd |= (env->fpstt & 7) << 11; cwd = env->fpuc; for (i = 0; i < 8; ++i) twd |= (!env->fptags[i]) << i; xsave->region[0] = (uint32_t)(swd << 16) + cwd; xsave->region[1] = (uint32_t)(fop << 16) + twd; memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs, sizeof env->fpregs); memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs, sizeof env->xmm_regs); xsave->region[XSAVE_MXCSR] = env->mxcsr; *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv; memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs, sizeof env->ymmh_regs); r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave); qemu_free(xsave); return r; #else return kvm_put_fpu(env); #endif }
--------------------------------------------- Result 444 ---------------------------------------------
[[0 (62%)]] --> [[0 (50%)]] --> Socre: 0.5027616918087006

[[[[Adv]]]]: static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride, int [[numLines]], int levelFix) { int i; if(levelFix) { #ifdef HAVE_MMX asm volatile( "movl %4, %%eax \n\t" "movl %%eax, temp0\n\t" "pushl %0 \n\t" "pushl %1 \n\t" "leal (%2,%2), %%eax \n\t" "leal (%3,%3), %%ebx \n\t" "movq packedYOffset, %%mm2 \n\t" "movq packedYScale, %%mm3 \n\t" "pxor %%mm4, %%mm4 \n\t" #define SCALED_CPY \ "movq (%0), %%mm0 \n\t"\ "movq (%0,%2), %%mm1 \n\t"\ "psubusb %%mm2, %%mm0 \n\t"\ "psubusb %%mm2, %%mm1 \n\t"\ "movq %%mm0, %%mm5 \n\t"\ "punpcklbw %%mm4, %%mm0 \n\t"\ "punpckhbw %%mm4, %%mm5 \n\t"\ "psllw $7, %%mm0 \n\t"\ "psllw $7, %%mm5 \n\t"\ "pmulhw %%mm3, %%mm0 \n\t"\ "pmulhw %%mm3, %%mm5 \n\t"\ "packuswb %%mm5, %%mm0 \n\t"\ "movq %%mm0, (%1) \n\t"\ "movq %%mm1, %%mm5 \n\t"\ "punpcklbw %%mm4, %%mm1 \n\t"\ "punpckhbw %%mm4, %%mm5 \n\t"\ "psllw $7, %%mm1 \n\t"\ "psllw $7, %%mm5 \n\t"\ "pmulhw %%mm3, %%mm1 \n\t"\ "pmulhw %%mm3, %%mm5 \n\t"\ "packuswb %%mm5, %%mm1 \n\t"\ "movq %%mm1, (%1, %3) \n\t"\ "1: \n\t" SCALED_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" SCALED_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" "decl temp0 \n\t" "jnz 1b \n\t" "popl %1 \n\t" "popl %0 \n\t" : : "r" (src), "r" (dst), "r" (srcStride), "r" (dstStride), "m" ([[numLines]]>>2) : "%eax", "%ebx" ); #else for(i=0; i<[[numLines]]; i++) memcpy( &(dst[dstStride*i]), &(src[srcStride*i]), BLOCK_SIZE); #endif } else { #ifdef HAVE_MMX asm volatile( "movl %4, %%eax \n\t" "movl %%eax, temp0\n\t" "pushl %0 \n\t" "pushl %1 \n\t" "leal (%2,%2), %%eax \n\t" "leal (%3,%3), %%ebx \n\t" "movq packedYOffset, %%mm2 \n\t" "movq packedYScale, %%mm3 \n\t" #define SIMPLE_CPY \ "movq (%0), %%mm0 \n\t"\ "movq (%0,%2), %%mm1 \n\t"\ "movq %%mm0, (%1) \n\t"\ "movq %%mm1, (%1, %3) \n\t"\ "1: \n\t" SIMPLE_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" SIMPLE_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" "decl temp0 \n\t" "jnz 1b \n\t" "popl %1 \n\t" "popl %0 \n\t" : : "r" (src), "r" (dst), "r" (srcStride), "r" (dstStride), "m" ([[numLines]]>>2) : "%eax", "%ebx" ); #else for(i=0; i<[[numLines]]; i++) memcpy( &(dst[dstStride*i]), &(src[srcStride*i]), BLOCK_SIZE); #endif } }

[[[[Adv]]]]: static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride, int [[sycomts]], int levelFix) { int i; if(levelFix) { #ifdef HAVE_MMX asm volatile( "movl %4, %%eax \n\t" "movl %%eax, temp0\n\t" "pushl %0 \n\t" "pushl %1 \n\t" "leal (%2,%2), %%eax \n\t" "leal (%3,%3), %%ebx \n\t" "movq packedYOffset, %%mm2 \n\t" "movq packedYScale, %%mm3 \n\t" "pxor %%mm4, %%mm4 \n\t" #define SCALED_CPY \ "movq (%0), %%mm0 \n\t"\ "movq (%0,%2), %%mm1 \n\t"\ "psubusb %%mm2, %%mm0 \n\t"\ "psubusb %%mm2, %%mm1 \n\t"\ "movq %%mm0, %%mm5 \n\t"\ "punpcklbw %%mm4, %%mm0 \n\t"\ "punpckhbw %%mm4, %%mm5 \n\t"\ "psllw $7, %%mm0 \n\t"\ "psllw $7, %%mm5 \n\t"\ "pmulhw %%mm3, %%mm0 \n\t"\ "pmulhw %%mm3, %%mm5 \n\t"\ "packuswb %%mm5, %%mm0 \n\t"\ "movq %%mm0, (%1) \n\t"\ "movq %%mm1, %%mm5 \n\t"\ "punpcklbw %%mm4, %%mm1 \n\t"\ "punpckhbw %%mm4, %%mm5 \n\t"\ "psllw $7, %%mm1 \n\t"\ "psllw $7, %%mm5 \n\t"\ "pmulhw %%mm3, %%mm1 \n\t"\ "pmulhw %%mm3, %%mm5 \n\t"\ "packuswb %%mm5, %%mm1 \n\t"\ "movq %%mm1, (%1, %3) \n\t"\ "1: \n\t" SCALED_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" SCALED_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" "decl temp0 \n\t" "jnz 1b \n\t" "popl %1 \n\t" "popl %0 \n\t" : : "r" (src), "r" (dst), "r" (srcStride), "r" (dstStride), "m" ([[sycomts]]>>2) : "%eax", "%ebx" ); #else for(i=0; i<[[sycomts]]; i++) memcpy( &(dst[dstStride*i]), &(src[srcStride*i]), BLOCK_SIZE); #endif } else { #ifdef HAVE_MMX asm volatile( "movl %4, %%eax \n\t" "movl %%eax, temp0\n\t" "pushl %0 \n\t" "pushl %1 \n\t" "leal (%2,%2), %%eax \n\t" "leal (%3,%3), %%ebx \n\t" "movq packedYOffset, %%mm2 \n\t" "movq packedYScale, %%mm3 \n\t" #define SIMPLE_CPY \ "movq (%0), %%mm0 \n\t"\ "movq (%0,%2), %%mm1 \n\t"\ "movq %%mm0, (%1) \n\t"\ "movq %%mm1, (%1, %3) \n\t"\ "1: \n\t" SIMPLE_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" SIMPLE_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" "decl temp0 \n\t" "jnz 1b \n\t" "popl %1 \n\t" "popl %0 \n\t" : : "r" (src), "r" (dst), "r" (srcStride), "r" (dstStride), "m" ([[sycomts]]>>2) : "%eax", "%ebx" ); #else for(i=0; i<[[sycomts]]; i++) memcpy( &(dst[dstStride*i]), &(src[srcStride*i]), BLOCK_SIZE); #endif } }
--------------------------------------------- Result 445 ---------------------------------------------
[[0 (1%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: build_tpm2(GArray *table_data, BIOSLinker *linker) { Acpi20TPM2 *tpm2_ptr; tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr); tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT); tpm2_ptr->control_area_address = cpu_to_le64(0); tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO); build_header(linker, table_data, (void *)tpm2_ptr, "TPM2", sizeof(*tpm2_ptr), 4, NULL, NULL); }
[Succeeded / Failed / Skipped / Total] 230 / 53 / 163 / 446:  17%|█▋        | 446/2690 [1:09:07<5:47:47,  9.30s/it][Succeeded / Failed / Skipped / Total] 230 / 53 / 163 / 446:  17%|█▋        | 447/2690 [1:09:14<5:47:27,  9.29s/it][Succeeded / Failed / Skipped / Total] 231 / 53 / 163 / 447:  17%|█▋        | 447/2690 [1:09:14<5:47:27,  9.29s/it][Succeeded / Failed / Skipped / Total] 231 / 53 / 163 / 447:  17%|█▋        | 448/2690 [1:09:16<5:46:40,  9.28s/it]--------------------------------------------- Result 446 ---------------------------------------------
[[0 (33%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush) { do { int nb_output = 0; int min_poc = INT_MAX; int i, min_idx, ret; if (s->sh.no_output_of_prior_pics_flag == 1) { for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) { HEVCFrame *frame = &s->DPB[i]; if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc && frame->sequence == s->seq_output) { ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT); } } } for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) { HEVCFrame *frame = &s->DPB[i]; if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) && frame->sequence == s->seq_output) { nb_output++; if (frame->poc < min_poc) { min_poc = frame->poc; min_idx = i; } } } if (!flush && s->seq_output == s->seq_decode && s->sps && nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics) return 0; if (nb_output) { HEVCFrame *frame = &s->DPB[min_idx]; AVFrame *dst = out; AVFrame *src = frame->frame; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format); int pixel_shift = !!(desc->comp[0].depth_minus1 > 7); ret = av_frame_ref(out, src); if (frame->flags & HEVC_FRAME_FLAG_BUMPING) ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING); else ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT); if (ret < 0) return ret; for (i = 0; i < 3; i++) { int hshift = (i > 0) ? desc->log2_chroma_w : 0; int vshift = (i > 0) ? desc->log2_chroma_h : 0; int off = ((frame->window.left_offset >> hshift) << pixel_shift) + (frame->window.top_offset >> vshift) * dst->linesize[i]; dst->data[i] += off; } av_log(s->avctx, AV_LOG_DEBUG, "Output frame with POC %d.\n", frame->poc); return 1; } if (s->seq_output != s->seq_decode) s->seq_output = (s->seq_output + 1) & 0xff; else break; } while (1); return 0; }
--------------------------------------------- Result 447 ---------------------------------------------
[[0 (9%)]] --> [[0 (62%)]] --> Socre: 0.6217986941337585

[[[[Adv]]]]: static void ide_atapi_identify(IDEState *[[s]]) { uint16_t *[[p]]; if ([[s]]->identify_set) { memcpy([[s]]->io_buffer, [[s]]->identify_data, sizeof([[s]]->identify_data)); return; } memset([[s]]->io_buffer, 0, 512); [[p]] = (uint16_t *)[[s]]->io_buffer; put_le16([[p]] + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0)); padstr((char *)([[p]] + 10), [[s]]->drive_serial_str, 20); put_le16([[p]] + 20, 3); put_le16([[p]] + 21, 512); put_le16([[p]] + 22, 4); padstr((char *)([[p]] + 23), [[s]]->version, 8); padstr((char *)([[p]] + 27), "QEMU DVD-ROM", 40); put_le16([[p]] + 48, 1); #ifdef USE_DMA_CDROM put_le16([[p]] + 49, 1 << 9 | 1 << 8); put_le16([[p]] + 53, 7); put_le16([[p]] + 62, 7); put_le16([[p]] + 63, 7); #else put_le16([[p]] + 49, 1 << 9); put_le16([[p]] + 53, 3); put_le16([[p]] + 63, 0x103); #endif put_le16([[p]] + 64, 3); put_le16([[p]] + 65, 0xb4); put_le16([[p]] + 66, 0xb4); put_le16([[p]] + 67, 0x12c); put_le16([[p]] + 68, 0xb4); put_le16([[p]] + 71, 30); put_le16([[p]] + 72, 30); if ([[s]]->ncq_queues) { put_le16([[p]] + 75, [[s]]->ncq_queues - 1); put_le16([[p]] + 76, (1 << 8)); } put_le16([[p]] + 80, 0x1e); #ifdef USE_DMA_CDROM put_le16([[p]] + 88, 0x3f | (1 << 13)); #endif memcpy([[s]]->identify_data, [[p]], sizeof([[s]]->identify_data)); [[s]]->identify_set = 1; }

[[[[Adv]]]]: static void ide_atapi_identify(IDEState *[[san]]) { uint16_t *[[п]]; if ([[san]]->identify_set) { memcpy([[san]]->io_buffer, [[san]]->identify_data, sizeof([[san]]->identify_data)); return; } memset([[san]]->io_buffer, 0, 512); [[п]] = (uint16_t *)[[san]]->io_buffer; put_le16([[п]] + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0)); padstr((char *)([[п]] + 10), [[san]]->drive_serial_str, 20); put_le16([[п]] + 20, 3); put_le16([[п]] + 21, 512); put_le16([[п]] + 22, 4); padstr((char *)([[п]] + 23), [[san]]->version, 8); padstr((char *)([[п]] + 27), "QEMU DVD-ROM", 40); put_le16([[п]] + 48, 1); #ifdef USE_DMA_CDROM put_le16([[п]] + 49, 1 << 9 | 1 << 8); put_le16([[п]] + 53, 7); put_le16([[п]] + 62, 7); put_le16([[п]] + 63, 7); #else put_le16([[п]] + 49, 1 << 9); put_le16([[п]] + 53, 3); put_le16([[п]] + 63, 0x103); #endif put_le16([[п]] + 64, 3); put_le16([[п]] + 65, 0xb4); put_le16([[п]] + 66, 0xb4); put_le16([[п]] + 67, 0x12c); put_le16([[п]] + 68, 0xb4); put_le16([[п]] + 71, 30); put_le16([[п]] + 72, 30); if ([[san]]->ncq_queues) { put_le16([[п]] + 75, [[san]]->ncq_queues - 1); put_le16([[п]] + 76, (1 << 8)); } put_le16([[п]] + 80, 0x1e); #ifdef USE_DMA_CDROM put_le16([[п]] + 88, 0x3f | (1 << 13)); #endif memcpy([[san]]->identify_data, [[п]], sizeof([[san]]->identify_data)); [[san]]->identify_set = 1; }
--------------------------------------------- Result 448 ---------------------------------------------
[[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint64_t exynos4210_fimd_read(void *[[opaque]], target_phys_addr_t [[offset]], unsigned [[size]]) { Exynos4210fimdState *[[s]] = (Exynos4210fimdState *)[[opaque]]; int [[w]], i; uint32_t ret = 0; DPRINT_L2("read offset 0x%08x\n", [[offset]]); switch ([[offset]]) { case FIMD_VIDCON0 ... FIMD_VIDCON3: return [[s]]->vidcon[([[offset]] - FIMD_VIDCON0) >> 2]; case FIMD_VIDTCON_START ... FIMD_VIDTCON_END: return [[s]]->vidtcon[([[offset]] - FIMD_VIDTCON_START) >> 2]; case FIMD_WINCON_START ... FIMD_WINCON_END: return [[s]]->window[([[offset]] - FIMD_WINCON_START) >> 2].wincon; case FIMD_SHADOWCON: return [[s]]->shadowcon; case FIMD_WINCHMAP: return [[s]]->winchmap; case FIMD_VIDOSD_START ... FIMD_VIDOSD_END: [[w]] = ([[offset]] - FIMD_VIDOSD_START) >> 4; i = (([[offset]] - FIMD_VIDOSD_START) & 0xF) >> 2; switch (i) { case 0: ret = (([[s]]->window[[[w]]].lefttop_x & FIMD_VIDOSD_COORD_MASK) << FIMD_VIDOSD_HOR_SHIFT) | ([[s]]->window[[[w]]].lefttop_y & FIMD_VIDOSD_COORD_MASK); break; case 1: ret = (([[s]]->window[[[w]]].rightbot_x & FIMD_VIDOSD_COORD_MASK) << FIMD_VIDOSD_HOR_SHIFT) | ([[s]]->window[[[w]]].rightbot_y & FIMD_VIDOSD_COORD_MASK); break; case 2: if ([[w]] == 0) { ret = [[s]]->window[[[w]]].osdsize; } else { ret = (pack_upper_4([[s]]->window[[[w]]].alpha_val[0]) << FIMD_VIDOSD_AEN0_SHIFT) | pack_upper_4([[s]]->window[[[w]]].alpha_val[1]); } break; case 3: if ([[w]] != 1 && [[w]] != 2) { DPRINT_ERROR("bad read offset 0x%08x\n", [[offset]]); return 0xBAADBAAD; } ret = [[s]]->window[[[w]]].osdsize; break; } return ret; case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END: [[w]] = ([[offset]] - FIMD_VIDWADD0_START) >> 3; i = (([[offset]] - FIMD_VIDWADD0_START) >> 2) & 1; return [[s]]->window[[[w]]].buf_start[i]; case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END: [[w]] = ([[offset]] - FIMD_VIDWADD1_START) >> 3; i = (([[offset]] - FIMD_VIDWADD1_START) >> 2) & 1; return [[s]]->window[[[w]]].buf_end[i]; case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END: [[w]] = ([[offset]] - FIMD_VIDWADD2_START) >> 2; return [[s]]->window[[[w]]].virtpage_width | ([[s]]->window[[[w]]].virtpage_offsize << FIMD_VIDWADD2_OFFSIZE_SHIFT); case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1: return [[s]]->vidintcon[([[offset]] - FIMD_VIDINTCON0) >> 2]; case FIMD_WKEYCON_START ... FIMD_WKEYCON_END: [[w]] = (([[offset]] - FIMD_WKEYCON_START) >> 3) + 1; i = (([[offset]] - FIMD_WKEYCON_START) >> 2) & 1; return [[s]]->window[[[w]]].keycon[i]; case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END: [[w]] = (([[offset]] - FIMD_WKEYALPHA_START) >> 2) + 1; return [[s]]->window[[[w]]].keyalpha; case FIMD_DITHMODE: return [[s]]->dithmode; case FIMD_WINMAP_START ... FIMD_WINMAP_END: return [[s]]->window[([[offset]] - FIMD_WINMAP_START) >> 2].winmap; case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW: return [[s]]->wpalcon[([[offset]] - FIMD_WPALCON_HIGH) >> 2]; case FIMD_TRIGCON: return [[s]]->trigcon; case FIMD_I80IFCON_START ... FIMD_I80IFCON_END: return [[s]]->i80ifcon[([[offset]] - FIMD_I80IFCON_START) >> 2]; case FIMD_COLORGAINCON: return [[s]]->colorgaincon; case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1: return [[s]]->ldi_cmdcon[([[offset]] - FIMD_LDI_CMDCON0) >> 2]; case FIMD_SIFCCON0 ... FIMD_SIFCCON2: i = ([[offset]] - FIMD_SIFCCON0) >> 2; return [[s]]->sifccon[i]; case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END: i = ([[offset]] - FIMD_HUECOEFCR_START) >> 2; return [[s]]->huecoef_cr[i]; case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END: i = ([[offset]] - FIMD_HUECOEFCB_START) >> 2; return [[s]]->huecoef_cb[i]; case FIMD_HUEOFFSET: return [[s]]->hueoffset; case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END: [[w]] = (([[offset]] - FIMD_VIDWALPHA_START) >> 3); i = (([[offset]] - FIMD_VIDWALPHA_START) >> 2) & 1; return [[s]]->window[[[w]]].alpha_val[i] & ([[w]] == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER); case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END: return [[s]]->window[([[offset]] - FIMD_BLENDEQ_START) >> 2].blendeq; case FIMD_BLENDCON: return [[s]]->blendcon; case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END: return [[s]]->window[([[offset]] - FIMD_WRTQOSCON_START) >> 2].rtqoscon; case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END: return [[s]]->i80ifcmd[([[offset]] - FIMD_I80IFCMD_START) >> 2]; case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2: if ([[offset]] & 0x0004) { break; } return [[s]]->window[([[offset]] - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2]; case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END: if ([[offset]] & 0x0004) { break; } return [[s]]->window[([[offset]] - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start; case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END: if ([[offset]] & 0x0004) { break; } return [[s]]->window[([[offset]] - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end; case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END: return [[s]]->window[([[offset]] - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size; case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END: [[w]] = ([[offset]] - FIMD_PAL_MEM_START) >> 10; i = (([[offset]] - FIMD_PAL_MEM_START) >> 2) & 0xFF; return [[s]]->window[[[w]]].palette[i]; case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END: [[w]] = ([[offset]] - FIMD_PALMEM_AL_START) >> 10; i = (([[offset]] - FIMD_PALMEM_AL_START) >> 2) & 0xFF; return [[s]]->window[[[w]]].palette[i]; } DPRINT_ERROR("bad read offset 0x%08x\n", [[offset]]); return 0xBAADBAAD; }

[[[[Adv]]]]: static uint64_t exynos4210_fimd_read(void *[[omnibus]], target_phys_addr_t [[ink]], unsigned [[print]]) { Exynos4210fimdState *[[wax]] = (Exynos4210fimdState *)[[omnibus]]; int [[sorry]], i; uint32_t ret = 0; DPRINT_L2("read offset 0x%08x\n", [[ink]]); switch ([[ink]]) { case FIMD_VIDCON0 ... FIMD_VIDCON3: return [[wax]]->vidcon[([[ink]] - FIMD_VIDCON0) >> 2]; case FIMD_VIDTCON_START ... FIMD_VIDTCON_END: return [[wax]]->vidtcon[([[ink]] - FIMD_VIDTCON_START) >> 2]; case FIMD_WINCON_START ... FIMD_WINCON_END: return [[wax]]->window[([[ink]] - FIMD_WINCON_START) >> 2].wincon; case FIMD_SHADOWCON: return [[wax]]->shadowcon; case FIMD_WINCHMAP: return [[wax]]->winchmap; case FIMD_VIDOSD_START ... FIMD_VIDOSD_END: [[sorry]] = ([[ink]] - FIMD_VIDOSD_START) >> 4; i = (([[ink]] - FIMD_VIDOSD_START) & 0xF) >> 2; switch (i) { case 0: ret = (([[wax]]->window[[[sorry]]].lefttop_x & FIMD_VIDOSD_COORD_MASK) << FIMD_VIDOSD_HOR_SHIFT) | ([[wax]]->window[[[sorry]]].lefttop_y & FIMD_VIDOSD_COORD_MASK); break; case 1: ret = (([[wax]]->window[[[sorry]]].rightbot_x & FIMD_VIDOSD_COORD_MASK) << FIMD_VIDOSD_HOR_SHIFT) | ([[wax]]->window[[[sorry]]].rightbot_y & FIMD_VIDOSD_COORD_MASK); break; case 2: if ([[sorry]] == 0) { ret = [[wax]]->window[[[sorry]]].osdsize; } else { ret = (pack_upper_4([[wax]]->window[[[sorry]]].alpha_val[0]) << FIMD_VIDOSD_AEN0_SHIFT) | pack_upper_4([[wax]]->window[[[sorry]]].alpha_val[1]); } break; case 3: if ([[sorry]] != 1 && [[sorry]] != 2) { DPRINT_ERROR("bad read offset 0x%08x\n", [[ink]]); return 0xBAADBAAD; } ret = [[wax]]->window[[[sorry]]].osdsize; break; } return ret; case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END: [[sorry]] = ([[ink]] - FIMD_VIDWADD0_START) >> 3; i = (([[ink]] - FIMD_VIDWADD0_START) >> 2) & 1; return [[wax]]->window[[[sorry]]].buf_start[i]; case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END: [[sorry]] = ([[ink]] - FIMD_VIDWADD1_START) >> 3; i = (([[ink]] - FIMD_VIDWADD1_START) >> 2) & 1; return [[wax]]->window[[[sorry]]].buf_end[i]; case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END: [[sorry]] = ([[ink]] - FIMD_VIDWADD2_START) >> 2; return [[wax]]->window[[[sorry]]].virtpage_width | ([[wax]]->window[[[sorry]]].virtpage_offsize << FIMD_VIDWADD2_OFFSIZE_SHIFT); case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1: return [[wax]]->vidintcon[([[ink]] - FIMD_VIDINTCON0) >> 2]; case FIMD_WKEYCON_START ... FIMD_WKEYCON_END: [[sorry]] = (([[ink]] - FIMD_WKEYCON_START) >> 3) + 1; i = (([[ink]] - FIMD_WKEYCON_START) >> 2) & 1; return [[wax]]->window[[[sorry]]].keycon[i]; case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END: [[sorry]] = (([[ink]] - FIMD_WKEYALPHA_START) >> 2) + 1; return [[wax]]->window[[[sorry]]].keyalpha; case FIMD_DITHMODE: return [[wax]]->dithmode; case FIMD_WINMAP_START ... FIMD_WINMAP_END: return [[wax]]->window[([[ink]] - FIMD_WINMAP_START) >> 2].winmap; case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW: return [[wax]]->wpalcon[([[ink]] - FIMD_WPALCON_HIGH) >> 2]; case FIMD_TRIGCON: return [[wax]]->trigcon; case FIMD_I80IFCON_START ... FIMD_I80IFCON_END: return [[wax]]->i80ifcon[([[ink]] - FIMD_I80IFCON_START) >> 2]; case FIMD_COLORGAINCON: return [[wax]]->colorgaincon; case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1: return [[wax]]->ldi_cmdcon[([[ink]] - FIMD_LDI_CMDCON0) >> 2]; case FIMD_SIFCCON0 ... FIMD_SIFCCON2: i = ([[ink]] - FIMD_SIFCCON0) >> 2; return [[wax]]->sifccon[i]; case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END: i = ([[ink]] - FIMD_HUECOEFCR_START) >> 2; return [[wax]]->huecoef_cr[i]; case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END: i = ([[ink]] - FIMD_HUECOEFCB_START) >> 2; return [[wax]]->huecoef_cb[i]; case FIMD_HUEOFFSET: return [[wax]]->hueoffset; case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END: [[sorry]] = (([[ink]] - FIMD_VIDWALPHA_START) >> 3); i = (([[ink]] - FIMD_VIDWALPHA_START) >> 2) & 1; return [[wax]]->window[[[sorry]]].alpha_val[i] & ([[sorry]] == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER); case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END: return [[wax]]->window[([[ink]] - FIMD_BLENDEQ_START) >> 2].blendeq; case FIMD_BLENDCON: return [[wax]]->blendcon; case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END: return [[wax]]->window[([[ink]] - FIMD_WRTQOSCON_START) >> 2].rtqoscon; case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END: return [[wax]]->i80ifcmd[([[ink]] - FIMD_I80IFCMD_START) >> 2]; case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2: if ([[ink]] & 0x0004) { break; } return [[wax]]->window[([[ink]] - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2]; case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END: if ([[ink]] & 0x0004) { break; } return [[wax]]->window[([[ink]] - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start; case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END: if ([[ink]] & 0x0004) { break; } return [[wax]]->window[([[ink]] - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end; case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END: return [[wax]]->window[([[ink]] - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size; case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END: [[sorry]] = ([[ink]] - FIMD_PAL_MEM_START) >> 10; i = (([[ink]] - FIMD_PAL_MEM_START) >> 2) & 0xFF; return [[wax]]->window[[[sorry]]].palette[i]; case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END: [[sorry]] = ([[ink]] - FIMD_PALMEM_AL_START) >> 10; i = (([[ink]] - FIMD_PALMEM_AL_START) >> 2) & 0xFF; return [[wax]]->window[[[sorry]]].palette[i]; } DPRINT_ERROR("bad read offset 0x%08x\n", [[ink]]); return 0xBAADBAAD; }[Succeeded / Failed / Skipped / Total] 231 / 54 / 163 / 448:  17%|█▋        | 448/2690 [1:09:16<5:46:40,  9.28s/it][Succeeded / Failed / Skipped / Total] 231 / 54 / 163 / 448:  17%|█▋        | 449/2690 [1:09:33<5:47:12,  9.30s/it][Succeeded / Failed / Skipped / Total] 232 / 54 / 163 / 449:  17%|█▋        | 449/2690 [1:09:33<5:47:12,  9.30s/it][Succeeded / Failed / Skipped / Total] 232 / 54 / 163 / 449:  17%|█▋        | 450/2690 [1:09:41<5:46:55,  9.29s/it]
--------------------------------------------- Result 449 ---------------------------------------------
[[0 (49%)]] --> [[0 (51%)]] --> Socre: 0.5072947144508362

[[[[Adv]]]]: static int mpegaudio_parse(AVCodecParserContext *s1, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size) { MpegAudioParseContext *[[s]] = s1->priv_data; int len, ret; uint32_t header; const uint8_t *buf_ptr; *poutbuf = NULL; *poutbuf_size = 0; buf_ptr = buf; while (buf_size > 0) { len = [[s]]->inbuf_ptr - [[s]]->inbuf; if ([[s]]->frame_size == 0) { if ([[s]]->free_format_next_header != 0) { [[s]]->inbuf[0] = [[s]]->free_format_next_header >> 24; [[s]]->inbuf[1] = [[s]]->free_format_next_header >> 16; [[s]]->inbuf[2] = [[s]]->free_format_next_header >> 8; [[s]]->inbuf[3] = [[s]]->free_format_next_header; [[s]]->inbuf_ptr = [[s]]->inbuf + 4; [[s]]->free_format_next_header = 0; goto got_header; } len = MPA_HEADER_SIZE - len; if (len > buf_size) len = buf_size; if (len > 0) { memcpy([[s]]->inbuf_ptr, buf_ptr, len); buf_ptr += len; buf_size -= len; [[s]]->inbuf_ptr += len; } if (([[s]]->inbuf_ptr - [[s]]->inbuf) >= MPA_HEADER_SIZE) { got_header: header = ([[s]]->inbuf[0] << 24) | ([[s]]->inbuf[1] << 16) | ([[s]]->inbuf[2] << 8) | [[s]]->inbuf[3]; ret = mpa_decode_header(avctx, header); if (ret < 0) { memmove([[s]]->inbuf, [[s]]->inbuf + 1, [[s]]->inbuf_ptr - [[s]]->inbuf - 1); [[s]]->inbuf_ptr--; dprintf("skip %x\n", header); [[s]]->free_format_frame_size = 0; } else { [[s]]->frame_size = ret; #if 0 if (decode_header([[s]], header) == 1) { [[s]]->frame_size = -1; } #endif } } } else #if 0 if ([[s]]->frame_size == -1) { len = MPA_MAX_CODED_FRAME_SIZE - len; if (len > buf_size) len = buf_size; if (len == 0) { [[s]]->frame_size = 0; memmove([[s]]->inbuf, [[s]]->inbuf + 1, [[s]]->inbuf_ptr - [[s]]->inbuf - 1); [[s]]->inbuf_ptr--; } else { uint8_t *p, *pend; uint32_t header1; int padding; memcpy([[s]]->inbuf_ptr, buf_ptr, len); p = [[s]]->inbuf_ptr - 3; pend = [[s]]->inbuf_ptr + len - 4; while (p <= pend) { header = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]; header1 = ([[s]]->inbuf[0] << 24) | ([[s]]->inbuf[1] << 16) | ([[s]]->inbuf[2] << 8) | [[s]]->inbuf[3]; if ((header & SAME_HEADER_MASK) == (header1 & SAME_HEADER_MASK)) { len = (p + 4) - [[s]]->inbuf_ptr; buf_ptr += len; buf_size -= len; [[s]]->inbuf_ptr = p; [[s]]->free_format_next_header = header; [[s]]->free_format_frame_size = [[s]]->inbuf_ptr - [[s]]->inbuf; padding = (header1 >> 9) & 1; if ([[s]]->layer == 1) [[s]]->free_format_frame_size -= padding * 4; else [[s]]->free_format_frame_size -= padding; dprintf("free frame size=%d padding=%d\n", [[s]]->free_format_frame_size, padding); decode_header([[s]], header1); goto next_data; } p++; } buf_ptr += len; [[s]]->inbuf_ptr += len; buf_size -= len; } } else #endif if (len < [[s]]->frame_size) { if ([[s]]->frame_size > MPA_MAX_CODED_FRAME_SIZE) [[s]]->frame_size = MPA_MAX_CODED_FRAME_SIZE; len = [[s]]->frame_size - len; if (len > buf_size) len = buf_size; memcpy([[s]]->inbuf_ptr, buf_ptr, len); buf_ptr += len; [[s]]->inbuf_ptr += len; buf_size -= len; } if ([[s]]->frame_size > 0 && ([[s]]->inbuf_ptr - [[s]]->inbuf) >= [[s]]->frame_size) { *poutbuf = [[s]]->inbuf; *poutbuf_size = [[s]]->inbuf_ptr - [[s]]->inbuf; [[s]]->inbuf_ptr = [[s]]->inbuf; [[s]]->frame_size = 0; break; } } return buf_ptr - buf; }

[[[[Adv]]]]: static int mpegaudio_parse(AVCodecParserContext *s1, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size) { MpegAudioParseContext *[[r]] = s1->priv_data; int len, ret; uint32_t header; const uint8_t *buf_ptr; *poutbuf = NULL; *poutbuf_size = 0; buf_ptr = buf; while (buf_size > 0) { len = [[r]]->inbuf_ptr - [[r]]->inbuf; if ([[r]]->frame_size == 0) { if ([[r]]->free_format_next_header != 0) { [[r]]->inbuf[0] = [[r]]->free_format_next_header >> 24; [[r]]->inbuf[1] = [[r]]->free_format_next_header >> 16; [[r]]->inbuf[2] = [[r]]->free_format_next_header >> 8; [[r]]->inbuf[3] = [[r]]->free_format_next_header; [[r]]->inbuf_ptr = [[r]]->inbuf + 4; [[r]]->free_format_next_header = 0; goto got_header; } len = MPA_HEADER_SIZE - len; if (len > buf_size) len = buf_size; if (len > 0) { memcpy([[r]]->inbuf_ptr, buf_ptr, len); buf_ptr += len; buf_size -= len; [[r]]->inbuf_ptr += len; } if (([[r]]->inbuf_ptr - [[r]]->inbuf) >= MPA_HEADER_SIZE) { got_header: header = ([[r]]->inbuf[0] << 24) | ([[r]]->inbuf[1] << 16) | ([[r]]->inbuf[2] << 8) | [[r]]->inbuf[3]; ret = mpa_decode_header(avctx, header); if (ret < 0) { memmove([[r]]->inbuf, [[r]]->inbuf + 1, [[r]]->inbuf_ptr - [[r]]->inbuf - 1); [[r]]->inbuf_ptr--; dprintf("skip %x\n", header); [[r]]->free_format_frame_size = 0; } else { [[r]]->frame_size = ret; #if 0 if (decode_header([[r]], header) == 1) { [[r]]->frame_size = -1; } #endif } } } else #if 0 if ([[r]]->frame_size == -1) { len = MPA_MAX_CODED_FRAME_SIZE - len; if (len > buf_size) len = buf_size; if (len == 0) { [[r]]->frame_size = 0; memmove([[r]]->inbuf, [[r]]->inbuf + 1, [[r]]->inbuf_ptr - [[r]]->inbuf - 1); [[r]]->inbuf_ptr--; } else { uint8_t *p, *pend; uint32_t header1; int padding; memcpy([[r]]->inbuf_ptr, buf_ptr, len); p = [[r]]->inbuf_ptr - 3; pend = [[r]]->inbuf_ptr + len - 4; while (p <= pend) { header = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]; header1 = ([[r]]->inbuf[0] << 24) | ([[r]]->inbuf[1] << 16) | ([[r]]->inbuf[2] << 8) | [[r]]->inbuf[3]; if ((header & SAME_HEADER_MASK) == (header1 & SAME_HEADER_MASK)) { len = (p + 4) - [[r]]->inbuf_ptr; buf_ptr += len; buf_size -= len; [[r]]->inbuf_ptr = p; [[r]]->free_format_next_header = header; [[r]]->free_format_frame_size = [[r]]->inbuf_ptr - [[r]]->inbuf; padding = (header1 >> 9) & 1; if ([[r]]->layer == 1) [[r]]->free_format_frame_size -= padding * 4; else [[r]]->free_format_frame_size -= padding; dprintf("free frame size=%d padding=%d\n", [[r]]->free_format_frame_size, padding); decode_header([[r]], header1); goto next_data; } p++; } buf_ptr += len; [[r]]->inbuf_ptr += len; buf_size -= len; } } else #endif if (len < [[r]]->frame_size) { if ([[r]]->frame_size > MPA_MAX_CODED_FRAME_SIZE) [[r]]->frame_size = MPA_MAX_CODED_FRAME_SIZE; len = [[r]]->frame_size - len; if (len > buf_size) len = buf_size; memcpy([[r]]->inbuf_ptr, buf_ptr, len); buf_ptr += len; [[r]]->inbuf_ptr += len; buf_size -= len; } if ([[r]]->frame_size > 0 && ([[r]]->inbuf_ptr - [[r]]->inbuf) >= [[r]]->frame_size) { *poutbuf = [[r]]->inbuf; *poutbuf_size = [[r]]->inbuf_ptr - [[r]]->inbuf; [[r]]->inbuf_ptr = [[r]]->inbuf; [[r]]->frame_size = 0; break; } } return buf_ptr - buf; }
--------------------------------------------- Result 450 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 233 / 54 / 163 / 450:  17%|█▋        | 450/2690 [1:09:41<5:46:55,  9.29s/it][Succeeded / Failed / Skipped / Total] 233 / 54 / 163 / 450:  17%|█▋        | 451/2690 [1:09:51<5:46:48,  9.29s/it][Succeeded / Failed / Skipped / Total] 234 / 54 / 163 / 451:  17%|█▋        | 451/2690 [1:09:51<5:46:48,  9.29s/it][Succeeded / Failed / Skipped / Total] 234 / 54 / 163 / 451:  17%|█▋        | 452/2690 [1:09:52<5:45:56,  9.27s/it][[0 (53%)]] --> [[0 (48%)]] --> Socre: 0.5218490362167358

[[[[Adv]]]]: static int perform_cow(BlockDriverState *bs, QCowL2Meta *m) { BDRVQcow2State *s = bs->opaque; Qcow2COWRegion *start = &m->cow_start; Qcow2COWRegion *end = &m->cow_end; unsigned [[buffer_size]]; unsigned data_bytes = end->offset - (start->offset + start->nb_bytes); bool merge_reads; uint8_t *start_buffer, *end_buffer; QEMUIOVector qiov; int ret; assert(start->nb_bytes <= UINT_MAX - end->nb_bytes); assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes); assert(start->offset + start->nb_bytes <= end->offset); assert(!m->data_qiov || m->data_qiov->size == data_bytes); if (start->nb_bytes == 0 && end->nb_bytes == 0) { return 0; } merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384; if (merge_reads) { [[buffer_size]] = start->nb_bytes + data_bytes + end->nb_bytes; } else { size_t align = bdrv_opt_mem_align(bs); assert(align > 0 && align <= UINT_MAX); assert(QEMU_ALIGN_UP(start->nb_bytes, align) <= UINT_MAX - end->nb_bytes); [[buffer_size]] = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes; } start_buffer = qemu_try_blockalign(bs, [[buffer_size]]); if (start_buffer == NULL) { return -ENOMEM; } end_buffer = start_buffer + [[buffer_size]] - end->nb_bytes; qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0)); qemu_co_mutex_unlock(&s->lock); if (merge_reads) { qemu_iovec_add(&qiov, start_buffer, [[buffer_size]]); ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov); } else { qemu_iovec_add(&qiov, start_buffer, start->nb_bytes); ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); ret = do_perform_cow_read(bs, m->offset, end->offset, &qiov); } if (ret < 0) { goto fail; } if (bs->encrypted) { if (!do_perform_cow_encrypt(bs, m->offset, start->offset, start_buffer, start->nb_bytes) || !do_perform_cow_encrypt(bs, m->offset, end->offset, end_buffer, end->nb_bytes)) { ret = -EIO; goto fail; } } if (m->data_qiov) { qemu_iovec_reset(&qiov); if (start->nb_bytes) { qemu_iovec_add(&qiov, start_buffer, start->nb_bytes); } qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes); if (end->nb_bytes) { qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); } BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO); ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov); } else { qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, start_buffer, start->nb_bytes); ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov); } fail: qemu_co_mutex_lock(&s->lock); if (ret == 0) { qcow2_cache_depends_on_flush(s->l2_table_cache); } qemu_vfree(start_buffer); qemu_iovec_destroy(&qiov); return ret; }

[[[[Adv]]]]: static int perform_cow(BlockDriverState *bs, QCowL2Meta *m) { BDRVQcow2State *s = bs->opaque; Qcow2COWRegion *start = &m->cow_start; Qcow2COWRegion *end = &m->cow_end; unsigned [[busoustime]]; unsigned data_bytes = end->offset - (start->offset + start->nb_bytes); bool merge_reads; uint8_t *start_buffer, *end_buffer; QEMUIOVector qiov; int ret; assert(start->nb_bytes <= UINT_MAX - end->nb_bytes); assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes); assert(start->offset + start->nb_bytes <= end->offset); assert(!m->data_qiov || m->data_qiov->size == data_bytes); if (start->nb_bytes == 0 && end->nb_bytes == 0) { return 0; } merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384; if (merge_reads) { [[busoustime]] = start->nb_bytes + data_bytes + end->nb_bytes; } else { size_t align = bdrv_opt_mem_align(bs); assert(align > 0 && align <= UINT_MAX); assert(QEMU_ALIGN_UP(start->nb_bytes, align) <= UINT_MAX - end->nb_bytes); [[busoustime]] = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes; } start_buffer = qemu_try_blockalign(bs, [[busoustime]]); if (start_buffer == NULL) { return -ENOMEM; } end_buffer = start_buffer + [[busoustime]] - end->nb_bytes; qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0)); qemu_co_mutex_unlock(&s->lock); if (merge_reads) { qemu_iovec_add(&qiov, start_buffer, [[busoustime]]); ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov); } else { qemu_iovec_add(&qiov, start_buffer, start->nb_bytes); ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); ret = do_perform_cow_read(bs, m->offset, end->offset, &qiov); } if (ret < 0) { goto fail; } if (bs->encrypted) { if (!do_perform_cow_encrypt(bs, m->offset, start->offset, start_buffer, start->nb_bytes) || !do_perform_cow_encrypt(bs, m->offset, end->offset, end_buffer, end->nb_bytes)) { ret = -EIO; goto fail; } } if (m->data_qiov) { qemu_iovec_reset(&qiov); if (start->nb_bytes) { qemu_iovec_add(&qiov, start_buffer, start->nb_bytes); } qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes); if (end->nb_bytes) { qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); } BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO); ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov); } else { qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, start_buffer, start->nb_bytes); ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov); } fail: qemu_co_mutex_lock(&s->lock); if (ret == 0) { qcow2_cache_depends_on_flush(s->l2_table_cache); } qemu_vfree(start_buffer); qemu_iovec_destroy(&qiov); return ret; }
--------------------------------------------- Result 451 ---------------------------------------------
[[0 (9%)]] --> [[0 (53%)]] --> Socre: 0.5286983251571655

[[[[Adv]]]]: void sws_rgb2rgb_init(int [[flags]]) { #if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX if ([[flags]] & SWS_CPU_CAPS_SSE2) rgb2rgb_init_SSE2(); else if ([[flags]] & SWS_CPU_CAPS_MMX2) rgb2rgb_init_MMX2(); else if ([[flags]] & SWS_CPU_CAPS_3DNOW) rgb2rgb_init_3DNOW(); else if ([[flags]] & SWS_CPU_CAPS_MMX) rgb2rgb_init_MMX(); else #endif rgb2rgb_init_C(); }

[[[[Adv]]]]: void sws_rgb2rgb_init(int [[lions]]) { #if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX if ([[lions]] & SWS_CPU_CAPS_SSE2) rgb2rgb_init_SSE2(); else if ([[lions]] & SWS_CPU_CAPS_MMX2) rgb2rgb_init_MMX2(); else if ([[lions]] & SWS_CPU_CAPS_3DNOW) rgb2rgb_init_3DNOW(); else if ([[lions]] & SWS_CPU_CAPS_MMX) rgb2rgb_init_MMX(); else #endif rgb2rgb_init_C(); }
--------------------------------------------- Result 452 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 234 / 54 / 164 / 452:  17%|█▋        | 452/2690 [1:09:52<5:45:56,  9.27s/it][Succeeded / Failed / Skipped / Total] 234 / 54 / 164 / 452:  17%|█▋        | 453/2690 [1:09:52<5:45:03,  9.26s/it][Succeeded / Failed / Skipped / Total] 234 / 54 / 165 / 453:  17%|█▋        | 453/2690 [1:09:52<5:45:03,  9.26s/it][Succeeded / Failed / Skipped / Total] 234 / 54 / 165 / 453:  17%|█▋        | 454/2690 [1:09:53<5:44:11,  9.24s/it][Succeeded / Failed / Skipped / Total] 234 / 54 / 166 / 454:  17%|█▋        | 454/2690 [1:09:53<5:44:11,  9.24s/it][Succeeded / Failed / Skipped / Total] 234 / 54 / 166 / 454:  17%|█▋        | 455/2690 [1:09:58<5:43:44,  9.23s/it][Succeeded / Failed / Skipped / Total] 235 / 54 / 166 / 455:  17%|█▋        | 455/2690 [1:09:58<5:43:44,  9.23s/it][Succeeded / Failed / Skipped / Total] 235 / 54 / 166 / 455:  17%|█▋        | 456/2690 [1:10:23<5:44:52,  9.26s/it][[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void init_proc_power5plus(CPUPPCState *env) { gen_spr_ne_601(env); gen_spr_7xx(env); gen_tbl(env); spr_register(env, SPR_HID0, "HID0", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_clear, 0x60000000); spr_register(env, SPR_HID1, "HID1", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_750FX_HID2, "HID2", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_970_HID5, "HID5", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, POWERPC970_HID5_INIT); spr_register(env, SPR_L2CR, "L2CR", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, NULL, 0x00000000); gen_low_BATs(env); spr_register(env, SPR_MMUCFG, "MMUCFG", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, SPR_NOACCESS, 0x00000000); spr_register(env, SPR_MMUCSR0, "MMUCSR0", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_HIOR, "SPR_HIOR", SPR_NOACCESS, SPR_NOACCESS, &spr_read_hior, &spr_write_hior, 0x00000000); spr_register(env, SPR_CTRL, "SPR_CTRL", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_UCTRL, "SPR_UCTRL", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_VRSAVE, "SPR_VRSAVE", &spr_read_generic, &spr_write_generic, &spr_read_generic, &spr_write_generic, 0x00000000); #if !defined(CONFIG_USER_ONLY) env->slb_nr = 64; #endif init_excp_970(env); env->dcache_line_size = 128; env->icache_line_size = 128; ppc970_irq_init(env); vscr_init(env, 0x00010000); }
--------------------------------------------- Result 453 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int64_t get_bit_rate(AVCodecContext *ctx) { int64_t bit_rate; int bits_per_sample; switch (ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: case AVMEDIA_TYPE_DATA: case AVMEDIA_TYPE_SUBTITLE: case AVMEDIA_TYPE_ATTACHMENT: bit_rate = ctx->bit_rate; break; case AVMEDIA_TYPE_AUDIO: bits_per_sample = av_get_bits_per_sample(ctx->codec_id); bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate; break; default: bit_rate = 0; break; } return bit_rate; }
--------------------------------------------- Result 454 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mkv_write_codecprivate(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, int native_id, int qt_id) { AVIOContext *dyn_cp; uint8_t *codecpriv; int ret, codecpriv_size; ret = avio_open_dyn_buf(&dyn_cp); if (ret < 0) return ret; if (native_id) { ret = mkv_write_native_codecprivate(s, par, dyn_cp); } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) { if (qt_id) { if (!par->codec_tag) par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags, par->codec_id); if ( ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id) ) { int i; avio_wb32(dyn_cp, 0x5a + par->extradata_size); avio_wl32(dyn_cp, par->codec_tag); for(i = 0; i < 0x5a - 8; i++) avio_w8(dyn_cp, 0); } avio_write(dyn_cp, par->extradata, par->extradata_size); } else { if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id)) av_log(s, AV_LOG_WARNING, "codec %s is not supported by this format\n", avcodec_get_name(par->codec_id)); if (!par->codec_tag) par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id); if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) { av_log(s, AV_LOG_ERROR, "No bmp codec tag found for codec %s\n", avcodec_get_name(par->codec_id)); ret = AVERROR(EINVAL); } ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0); } } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) { unsigned int tag; tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id); if (!tag) { av_log(s, AV_LOG_ERROR, "No wav codec tag found for codec %s\n", avcodec_get_name(par->codec_id)); ret = AVERROR(EINVAL); } if (!par->codec_tag) par->codec_tag = tag; ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX); } codecpriv_size = avio_close_dyn_buf(dyn_cp, &codecpriv); if (codecpriv_size) put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv, codecpriv_size); av_free(codecpriv); return ret; }
--------------------------------------------- Result 455 ---------------------------------------------
[[0 (42%)]] --> [[0 (67%)]] --> Socre: 0.6663817167282104

[[[[Adv]]]]: JNIEnv *ff_jni_attach_env(int *[[attached]], void *log_ctx) { int ret = 0; JNIEnv *[[env]] = NULL; *[[attached]] = 0; pthread_mutex_lock(&lock); if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) { av_log(log_ctx, AV_LOG_INFO, "Retrieving current Java virtual machine using Android JniInvocation wrapper\n"); if (check_jni_invocation(log_ctx) == 0) { if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL || (java_vm = get_java_vm("libdvm.so", log_ctx)) != NULL || (java_vm = get_java_vm("libart.so", log_ctx)) != NULL) { av_log(log_ctx, AV_LOG_INFO, "Found Java virtual machine using Android JniInvocation wrapper\n"); } } } pthread_mutex_unlock(&lock); if (!java_vm) { av_log(log_ctx, AV_LOG_ERROR, "Could not retrieve a Java virtual machine\n"); return NULL; } ret = (*java_vm)->GetEnv(java_vm, (void **)&[[env]], JNI_VERSION_1_6); switch(ret) { case JNI_EDETACHED: if ((*java_vm)->AttachCurrentThread(java_vm, &[[env]], NULL) != 0) { av_log(log_ctx, AV_LOG_ERROR, "Failed to attach the JNI environment to the current thread\n"); [[env]] = NULL; } else { *[[attached]] = 1; } break; case JNI_OK: break; case JNI_EVERSION: av_log(log_ctx, AV_LOG_ERROR, "The specified JNI version is not supported\n"); break; default: av_log(log_ctx, AV_LOG_ERROR, "Failed to get the JNI environment attached to this thread"); break; } return [[env]]; }

[[[[Adv]]]]: JNIEnv *ff_jni_attach_env(int *[[ash]], void *log_ctx) { int ret = 0; JNIEnv *[[itов]] = NULL; *[[ash]] = 0; pthread_mutex_lock(&lock); if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) { av_log(log_ctx, AV_LOG_INFO, "Retrieving current Java virtual machine using Android JniInvocation wrapper\n"); if (check_jni_invocation(log_ctx) == 0) { if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL || (java_vm = get_java_vm("libdvm.so", log_ctx)) != NULL || (java_vm = get_java_vm("libart.so", log_ctx)) != NULL) { av_log(log_ctx, AV_LOG_INFO, "Found Java virtual machine using Android JniInvocation wrapper\n"); } } } pthread_mutex_unlock(&lock); if (!java_vm) { av_log(log_ctx, AV_LOG_ERROR, "Could not retrieve a Java virtual machine\n"); return NULL; } ret = (*java_vm)->GetEnv(java_vm, (void **)&[[itов]], JNI_VERSION_1_6); switch(ret) { case JNI_EDETACHED: if ((*java_vm)->AttachCurrentThread(java_vm, &[[itов]], NULL) != 0) { av_log(log_ctx, AV_LOG_ERROR, "Failed to attach the JNI environment to the current thread\n"); [[itов]] = NULL; } else { *[[ash]] = 1; } break; case JNI_OK: break; case JNI_EVERSION: av_log(log_ctx, AV_LOG_ERROR, "The specified JNI version is not supported\n"); break; default: av_log(log_ctx, AV_LOG_ERROR, "Failed to get the JNI environment attached to this thread"); break; } return [[itов]]; }
--------------------------------------------- Result 456 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 236 / 54 / 166 / 456:  17%|█▋        | 456/2690 [1:10:23<5:44:52,  9.26s/it][Succeeded / Failed / Skipped / Total] 236 / 54 / 166 / 456:  17%|█▋        | 457/2690 [1:10:33<5:44:44,  9.26s/it][Succeeded / Failed / Skipped / Total] 236 / 55 / 166 / 457:  17%|█▋        | 457/2690 [1:10:33<5:44:44,  9.26s/it][Succeeded / Failed / Skipped / Total] 236 / 55 / 166 / 457:  17%|█▋        | 458/2690 [1:10:33<5:43:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 236 / 55 / 167 / 458:  17%|█▋        | 458/2690 [1:10:33<5:43:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 237 / 55 / 167 / 459:  17%|█▋        | 459/2690 [1:10:33<5:42:58,  9.22s/it][Succeeded / Failed / Skipped / Total] 237 / 55 / 167 / 459:  17%|█▋        | 460/2690 [1:10:34<5:42:06,  9.20s/it][Succeeded / Failed / Skipped / Total] 237 / 55 / 168 / 460:  17%|█▋        | 460/2690 [1:10:34<5:42:06,  9.20s/it][Succeeded / Failed / Skipped / Total] 238 / 55 / 168 / 461:  17%|█▋        | 461/2690 [1:10:41<5:41:46,  9.20s/it][Succeeded / Failed / Skipped / Total] 238 / 55 / 168 / 461:  17%|█▋        | 462/2690 [1:11:05<5:42:49,  9.23s/it][[0 (50%)]] --> [[0 (9%)]] --> Socre: 0.9129801243543625

[[[[Adv]]]]: void object_property_add_bool(Object *[[obj]], const char *name, bool (*get)(Object *, Error **), void (*set)(Object *, bool, Error **), Error **errp) { BoolProperty *prop = g_malloc0(sizeof(*prop)); prop->get = get; prop->set = set; object_property_add([[obj]], name, "bool", get ? property_get_bool : NULL, set ? property_set_bool : NULL, property_release_bool, prop, errp); }

[[[[Adv]]]]: void object_property_add_bool(Object *[[tolk]], const char *name, bool (*get)(Object *, Error **), void (*set)(Object *, bool, Error **), Error **errp) { BoolProperty *prop = g_malloc0(sizeof(*prop)); prop->get = get; prop->set = set; object_property_add([[tolk]], name, "bool", get ? property_get_bool : NULL, set ? property_set_bool : NULL, property_release_bool, prop, errp); }
--------------------------------------------- Result 457 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static double tget_double(GetByteContext *[[gb]], int [[le]]) { av_alias64 [[i]] = { .u64 = [[le]] ? bytestream2_get_le64([[gb]]) : bytestream2_get_be64([[gb]])}; return [[i]].f64; }

[[[[Adv]]]]: static double tget_double(GetByteContext *[[cas]], int [[data]]) { av_alias64 [[m]] = { .u64 = [[data]] ? bytestream2_get_le64([[cas]]) : bytestream2_get_be64([[cas]])}; return [[m]].f64; }
--------------------------------------------- Result 458 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s) { if (!s->started) { return; } s->started = "False" != "False"; trace_virtio_blk_data_plane_stop(s); if (s->start_bh) { qemu_bh_delete(s->start_bh); s->start_bh = NULL; } else { event_poll_notify(&s->event_poll); qemu_thread_join(&s->thread); } ioq_cleanup(&s->ioqueue); s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, "False" != "False"); event_poll_cleanup(&s->event_poll); s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, "False" != "False"); vring_teardown(&s->vring); }
--------------------------------------------- Result 459 ---------------------------------------------
[[0 (92%)]] --> [[0 (37%)]] --> Socre: 0.6290839910507202

[[[[Adv]]]]: void ff_vp3_idct_dc_add_c(uint8_t *dest , int line_size, const DCTELEM *[[block]] ){ int i, dc = ([[block]][0] + 15) >> 5; const uint8_t *[[cm]] = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ dest[0] = [[cm]][dest[0]]; dest[1] = [[cm]][dest[1]]; dest[2] = [[cm]][dest[2]]; dest[3] = [[cm]][dest[3]]; dest[4] = [[cm]][dest[4]]; dest[5] = [[cm]][dest[5]]; dest[6] = [[cm]][dest[6]]; dest[7] = [[cm]][dest[7]]; dest += line_size; } }

[[[[Adv]]]]: void ff_vp3_idct_dc_add_c(uint8_t *dest , int line_size, const DCTELEM *[[label]] ){ int i, dc = ([[label]][0] + 15) >> 5; const uint8_t *[[doi]] = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ dest[0] = [[doi]][dest[0]]; dest[1] = [[doi]][dest[1]]; dest[2] = [[doi]][dest[2]]; dest[3] = [[doi]][dest[3]]; dest[4] = [[doi]][dest[4]]; dest[5] = [[doi]][dest[5]]; dest[6] = [[doi]][dest[6]]; dest[7] = [[doi]][dest[7]]; dest += line_size; } }
--------------------------------------------- Result 460 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track, AVStream *st) { int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE, track->timescale, AV_ROUND_UP); int version = duration < INT32_MAX ? 0 : 1; int flags = MOV_TKHD_FLAG_IN_MOVIE; int rotation = 0; int group = 0; uint32_t *display_matrix = NULL; int display_matrix_size, i; if (st) { if (mov->per_stream_grouping) group = st->index; else group = st->codecpar->codec_type; display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX, &display_matrix_size); if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix)) display_matrix = NULL; } if (track->flags & MOV_TRACK_ENABLED) flags |= MOV_TKHD_FLAG_ENABLED; if (track->mode == MODE_ISM) version = 1; (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); ffio_wfourcc(pb, "tkhd"); avio_w8(pb, version); avio_wb24(pb, flags); if (version == 1) { avio_wb64(pb, track->time); avio_wb64(pb, track->time); } else { avio_wb32(pb, track->time); avio_wb32(pb, track->time); } avio_wb32(pb, track->track_id); avio_wb32(pb, 0); if (!track->entry && mov->mode == MODE_ISM) (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff); else if (!track->entry) (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0); else (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration); avio_wb32(pb, 0); avio_wb32(pb, 0); avio_wb16(pb, 0); avio_wb16(pb, group); if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) avio_wb16(pb, 0x0100); else avio_wb16(pb, 0); avio_wb16(pb, 0); if (st && st->metadata) { AVDictionaryEntry *rot = av_dict_get(st->metadata, "rotate", NULL, 0); rotation = (rot && rot->value) ? atoi(rot->value) : 0; } if (display_matrix) { for (i = 0; i < 9; i++) avio_wb32(pb, display_matrix[i]); } else if (rotation == 90) { write_matrix(pb, 0, 1, -1, 0, track->par->height, 0); } else if (rotation == 180) { write_matrix(pb, -1, 0, 0, -1, track->par->width, track->par->height); } else if (rotation == 270) { write_matrix(pb, 0, -1, 1, 0, 0, track->par->width); } else { write_matrix(pb, 1, 0, 0, 1, 0, 0); } if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO || track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) { int64_t track_width_1616; if (track->mode == MODE_MOV) { track_width_1616 = track->par->width * 0x10000ULL; } else { track_width_1616 = av_rescale(st->sample_aspect_ratio.num, track->par->width * 0x10000LL, st->sample_aspect_ratio.den); if (!track_width_1616 || track->height != track->par->height || track_width_1616 > UINT32_MAX) track_width_1616 = track->par->width * 0x10000ULL; } if (track_width_1616 > UINT32_MAX) { av_log(mov->fc, AV_LOG_WARNING, "track width is too large\n"); track_width_1616 = 0; } avio_wb32(pb, track_width_1616); if (track->height > 0xFFFF) { av_log(mov->fc, AV_LOG_WARNING, "track height is too large\n"); avio_wb32(pb, 0); } else avio_wb32(pb, track->height * 0x10000U); } else { avio_wb32(pb, 0); avio_wb32(pb, 0); } return 0x5c; }
--------------------------------------------- Result 461 ---------------------------------------------
[[0 (95%)]] --> [[0 (34%)]] --> Socre: 0.6614683568477631

[[[[Adv]]]]: static inline int mirror(int v, int [[m]]){ if (v<0) return -v; else if(v>[[m]]) return 2*[[m]]-v; else return v; }

[[[[Adv]]]]: static inline int mirror(int v, int [[park]]){ if (v<0) return -v; else if(v>[[park]]) return 2*[[park]]-v; else return v; }
--------------------------------------------- Result 462 ---------------------------------------------
[[0 (28%)]] --> [[0 (99%)]] --> Socre: 0.9888954162597656

[[[[Adv]]]]: static av_cold int aac_encode_init(AVCodecContext *[[avctx]]) { AACContext *s = [[avctx]]->priv_data; int ret = AVERROR(EINVAL); AACENC_InfoStruct info = { 0 }; CHANNEL_MODE mode; AACENC_ERROR err; int aot = FF_PROFILE_AAC_LOW + 1; int sce = 0, cpe = 0; if ((err = aacEncOpen(&s->handle, 0, [[avctx]]->channels)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to open the encoder: %s\n", aac_get_error(err)); goto error; } if ([[avctx]]->profile != FF_PROFILE_UNKNOWN) aot = [[avctx]]->profile + 1; if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the AOT %d: %s\n", aot, aac_get_error(err)); goto error; } if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) { if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE, 1)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to enable SBR for ELD: %s\n", aac_get_error(err)); goto error; } } if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE, [[avctx]]->sample_rate)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the sample rate %d: %s\n", [[avctx]]->sample_rate, aac_get_error(err)); goto error; } switch ([[avctx]]->channels) { case 1: mode = MODE_1; sce = 1; cpe = 0; break; case 2: mode = MODE_2; sce = 0; cpe = 1; break; case 3: mode = MODE_1_2; sce = 1; cpe = 1; break; case 4: mode = MODE_1_2_1; sce = 2; cpe = 1; break; case 5: mode = MODE_1_2_2; sce = 1; cpe = 2; break; case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break; default: av_log([[avctx]], AV_LOG_ERROR, "Unsupported number of channels %d\n", [[avctx]]->channels); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE, mode)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set channel mode %d: %s\n", mode, aac_get_error(err)); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER, 1)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set wav channel order %d: %s\n", mode, aac_get_error(err)); goto error; } if ([[avctx]]->flags & CODEC_FLAG_QSCALE || s->vbr) { int mode = s->vbr ? s->vbr : [[avctx]]->global_quality; if (mode < 1 || mode > 5) { av_log([[avctx]], AV_LOG_WARNING, "VBR quality %d out of range, should be 1-5\n", mode); mode = av_clip(mode, 1, 5); } av_log([[avctx]], AV_LOG_WARNING, "Note, the VBR setting is unsupported and only works with " "some parameter combinations\n"); if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE, mode)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the VBR bitrate mode %d: %s\n", mode, aac_get_error(err)); goto error; } } else { if ([[avctx]]->bit_rate <= 0) { if ([[avctx]]->profile == FF_PROFILE_AAC_HE_V2) { sce = 1; cpe = 0; } [[avctx]]->bit_rate = (96*sce + 128*cpe) * [[avctx]]->sample_rate / 44; if ([[avctx]]->profile == FF_PROFILE_AAC_HE || [[avctx]]->profile == FF_PROFILE_AAC_HE_V2 || s->eld_sbr) [[avctx]]->bit_rate /= 2; } if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE, [[avctx]]->bit_rate)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the bitrate %d: %s\n", [[avctx]]->bit_rate, aac_get_error(err)); goto error; } } if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX, [[avctx]]->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the transmux format: %s\n", aac_get_error(err)); goto error; } if (s->latm && s->header_period) { if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD, s->header_period)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set header period: %s\n", aac_get_error(err)); goto error; } } if (s->signaling < 0) s->signaling = [[avctx]]->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0; if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE, s->signaling)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set signaling mode %d: %s\n", s->signaling, aac_get_error(err)); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER, s->afterburner)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set afterburner to %d: %s\n", s->afterburner, aac_get_error(err)); goto error; } if ([[avctx]]->cutoff > 0) { if ([[avctx]]->cutoff < ([[avctx]]->sample_rate + 255) >> 8) { av_log([[avctx]], AV_LOG_ERROR, "cutoff valid range is %d-20000\n", ([[avctx]]->sample_rate + 255) >> 8); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH, [[avctx]]->cutoff)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the encoder bandwidth to %d: %s\n", [[avctx]]->cutoff, aac_get_error(err)); goto error; } } if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to initialize the encoder: %s\n", aac_get_error(err)); return AVERROR(EINVAL); } if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to get encoder info: %s\n", aac_get_error(err)); goto error; } #if FF_API_OLD_ENCODE_AUDIO [[avctx]]->coded_frame = avcodec_alloc_frame(); if (![[avctx]]->coded_frame) { ret = AVERROR(ENOMEM); goto error; } #endif [[avctx]]->frame_size = info.frameLength; [[avctx]]->delay = info.encoderDelay; ff_af_queue_init([[avctx]], &s->afq); if ([[avctx]]->flags & CODEC_FLAG_GLOBAL_HEADER) { [[avctx]]->extradata_size = info.confSize; [[avctx]]->extradata = av_mallocz([[avctx]]->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); if (![[avctx]]->extradata) { ret = AVERROR(ENOMEM); goto error; } memcpy([[avctx]]->extradata, info.confBuf, info.confSize); } return 0; error: aac_encode_close([[avctx]]); return ret; }

[[[[Adv]]]]: static av_cold int aac_encode_init(AVCodecContext *[[eaglesctorxa]]) { AACContext *s = [[eaglesctorxa]]->priv_data; int ret = AVERROR(EINVAL); AACENC_InfoStruct info = { 0 }; CHANNEL_MODE mode; AACENC_ERROR err; int aot = FF_PROFILE_AAC_LOW + 1; int sce = 0, cpe = 0; if ((err = aacEncOpen(&s->handle, 0, [[eaglesctorxa]]->channels)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to open the encoder: %s\n", aac_get_error(err)); goto error; } if ([[eaglesctorxa]]->profile != FF_PROFILE_UNKNOWN) aot = [[eaglesctorxa]]->profile + 1; if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set the AOT %d: %s\n", aot, aac_get_error(err)); goto error; } if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) { if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE, 1)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to enable SBR for ELD: %s\n", aac_get_error(err)); goto error; } } if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE, [[eaglesctorxa]]->sample_rate)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set the sample rate %d: %s\n", [[eaglesctorxa]]->sample_rate, aac_get_error(err)); goto error; } switch ([[eaglesctorxa]]->channels) { case 1: mode = MODE_1; sce = 1; cpe = 0; break; case 2: mode = MODE_2; sce = 0; cpe = 1; break; case 3: mode = MODE_1_2; sce = 1; cpe = 1; break; case 4: mode = MODE_1_2_1; sce = 2; cpe = 1; break; case 5: mode = MODE_1_2_2; sce = 1; cpe = 2; break; case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break; default: av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unsupported number of channels %d\n", [[eaglesctorxa]]->channels); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE, mode)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set channel mode %d: %s\n", mode, aac_get_error(err)); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER, 1)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set wav channel order %d: %s\n", mode, aac_get_error(err)); goto error; } if ([[eaglesctorxa]]->flags & CODEC_FLAG_QSCALE || s->vbr) { int mode = s->vbr ? s->vbr : [[eaglesctorxa]]->global_quality; if (mode < 1 || mode > 5) { av_log([[eaglesctorxa]], AV_LOG_WARNING, "VBR quality %d out of range, should be 1-5\n", mode); mode = av_clip(mode, 1, 5); } av_log([[eaglesctorxa]], AV_LOG_WARNING, "Note, the VBR setting is unsupported and only works with " "some parameter combinations\n"); if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE, mode)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set the VBR bitrate mode %d: %s\n", mode, aac_get_error(err)); goto error; } } else { if ([[eaglesctorxa]]->bit_rate <= 0) { if ([[eaglesctorxa]]->profile == FF_PROFILE_AAC_HE_V2) { sce = 1; cpe = 0; } [[eaglesctorxa]]->bit_rate = (96*sce + 128*cpe) * [[eaglesctorxa]]->sample_rate / 44; if ([[eaglesctorxa]]->profile == FF_PROFILE_AAC_HE || [[eaglesctorxa]]->profile == FF_PROFILE_AAC_HE_V2 || s->eld_sbr) [[eaglesctorxa]]->bit_rate /= 2; } if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE, [[eaglesctorxa]]->bit_rate)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set the bitrate %d: %s\n", [[eaglesctorxa]]->bit_rate, aac_get_error(err)); goto error; } } if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX, [[eaglesctorxa]]->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set the transmux format: %s\n", aac_get_error(err)); goto error; } if (s->latm && s->header_period) { if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD, s->header_period)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set header period: %s\n", aac_get_error(err)); goto error; } } if (s->signaling < 0) s->signaling = [[eaglesctorxa]]->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0; if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE, s->signaling)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set signaling mode %d: %s\n", s->signaling, aac_get_error(err)); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER, s->afterburner)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set afterburner to %d: %s\n", s->afterburner, aac_get_error(err)); goto error; } if ([[eaglesctorxa]]->cutoff > 0) { if ([[eaglesctorxa]]->cutoff < ([[eaglesctorxa]]->sample_rate + 255) >> 8) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "cutoff valid range is %d-20000\n", ([[eaglesctorxa]]->sample_rate + 255) >> 8); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH, [[eaglesctorxa]]->cutoff)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to set the encoder bandwidth to %d: %s\n", [[eaglesctorxa]]->cutoff, aac_get_error(err)); goto error; } } if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to initialize the encoder: %s\n", aac_get_error(err)); return AVERROR(EINVAL); } if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) { av_log([[eaglesctorxa]], AV_LOG_ERROR, "Unable to get encoder info: %s\n", aac_get_error(err)); goto error; } #if FF_API_OLD_ENCODE_AUDIO [[eaglesctorxa]]->coded_frame = avcodec_alloc_frame(); if (![[eaglesctorxa]]->coded_frame) { ret = AVERROR(ENOMEM); goto error; } #endif [[eaglesctorxa]]->frame_size = info.frameLength; [[eaglesctorxa]]->delay = info.encoderDelay; ff_af_queue_init([[eaglesctorxa]], &s->afq); if ([[eaglesctorxa]]->flags & CODEC_FLAG_GLOBAL_HEADER) { [[eaglesctorxa]]->extradata_size = info.confSize; [[eaglesctorxa]]->extradata = av_mallocz([[eaglesctorxa]]->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); if (![[eaglesctorxa]]->extradata) { ret = AVERROR(ENOMEM); goto error; } memcpy([[eaglesctorxa]]->extradata, info.confBuf, info.confSize); } return 0; error: aac_encode_close([[eaglesctorxa]]); return ret; }[Succeeded / Failed / Skipped / Total] 239 / 55 / 168 / 462:  17%|█▋        | 462/2690 [1:11:05<5:42:49,  9.23s/it][Succeeded / Failed / Skipped / Total] 239 / 55 / 168 / 462:  17%|█▋        | 463/2690 [1:11:08<5:42:09,  9.22s/it][Succeeded / Failed / Skipped / Total] 240 / 55 / 168 / 463:  17%|█▋        | 463/2690 [1:11:08<5:42:09,  9.22s/it][Succeeded / Failed / Skipped / Total] 240 / 55 / 168 / 463:  17%|█▋        | 464/2690 [1:11:08<5:41:18,  9.20s/it][Succeeded / Failed / Skipped / Total] 240 / 55 / 169 / 464:  17%|█▋        | 464/2690 [1:11:08<5:41:18,  9.20s/it][Succeeded / Failed / Skipped / Total] 240 / 55 / 169 / 464:  17%|█▋        | 465/2690 [1:11:09<5:40:27,  9.18s/it][Succeeded / Failed / Skipped / Total] 240 / 55 / 170 / 465:  17%|█▋        | 465/2690 [1:11:09<5:40:27,  9.18s/it][Succeeded / Failed / Skipped / Total] 240 / 55 / 170 / 465:  17%|█▋        | 466/2690 [1:11:27<5:41:02,  9.20s/it][Succeeded / Failed / Skipped / Total] 241 / 55 / 170 / 466:  17%|█▋        | 466/2690 [1:11:27<5:41:02,  9.20s/it][Succeeded / Failed / Skipped / Total] 241 / 55 / 170 / 466:  17%|█▋        | 467/2690 [1:11:45<5:41:33,  9.22s/it]
--------------------------------------------- Result 463 ---------------------------------------------
[[0 (68%)]] --> [[0 (43%)]] --> Socre: 0.5657662153244019

[[[[Adv]]]]: static int vobsub_read_seek(AVFormatContext *[[s]], int [[stream_index]], int64_t min_ts, int64_t ts, int64_t max_ts, int flags) { MpegDemuxContext *vobsub = [[s]]->priv_data; if ([[stream_index]] == -1 && [[s]]->nb_streams != 1) { int i, ret = 0; AVRational time_base = [[s]]->streams[0]->time_base; ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base); min_ts = av_rescale_rnd(min_ts, time_base.den, time_base.num * (int64_t)AV_TIME_BASE, AV_ROUND_UP | AV_ROUND_PASS_MINMAX); max_ts = av_rescale_rnd(max_ts, time_base.den, time_base.num * (int64_t)AV_TIME_BASE, AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX); for (i = 0; i < [[s]]->nb_streams; i++) { int r = ff_subtitles_queue_seek(&vobsub->q[i], [[s]], [[stream_index]], min_ts, ts, max_ts, flags); if (r < 0) ret = r; } return ret; } return ff_subtitles_queue_seek(&vobsub->q[[[stream_index]]], [[s]], [[stream_index]], min_ts, ts, max_ts, flags); }

[[[[Adv]]]]: static int vobsub_read_seek(AVFormatContext *[[services]], int [[child_atlas]], int64_t min_ts, int64_t ts, int64_t max_ts, int flags) { MpegDemuxContext *vobsub = [[services]]->priv_data; if ([[child_atlas]] == -1 && [[services]]->nb_streams != 1) { int i, ret = 0; AVRational time_base = [[services]]->streams[0]->time_base; ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base); min_ts = av_rescale_rnd(min_ts, time_base.den, time_base.num * (int64_t)AV_TIME_BASE, AV_ROUND_UP | AV_ROUND_PASS_MINMAX); max_ts = av_rescale_rnd(max_ts, time_base.den, time_base.num * (int64_t)AV_TIME_BASE, AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX); for (i = 0; i < [[services]]->nb_streams; i++) { int r = ff_subtitles_queue_seek(&vobsub->q[i], [[services]], [[child_atlas]], min_ts, ts, max_ts, flags); if (r < 0) ret = r; } return ret; } return ff_subtitles_queue_seek(&vobsub->q[[[child_atlas]]], [[services]], [[child_atlas]], min_ts, ts, max_ts, flags); }
--------------------------------------------- Result 464 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pc_init1(QEMUMachineInitArgs *args, int pci_enabled, int kvmclock_enabled) { MemoryRegion *system_memory = get_system_memory(); MemoryRegion *system_io = get_system_io(); int i; ram_addr_t below_4g_mem_size, above_4g_mem_size; PCIBus *pci_bus; ISABus *isa_bus; PCII440FXState *i440fx_state; int piix3_devfn = -1; qemu_irq *cpu_irq; qemu_irq *gsi; qemu_irq *i8259; qemu_irq *smi_irq; GSIState *gsi_state; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BusState *idebus[MAX_IDE_BUS]; ISADevice *rtc_state; ISADevice *floppy; MemoryRegion *ram_memory; MemoryRegion *pci_memory; MemoryRegion *rom_memory; DeviceState *icc_bridge; FWCfgState *fw_cfg = NULL; PcGuestInfo *guest_info; if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) { fprintf(stderr, "xen hardware virtual machine initialisation failed\n"); exit(1); } icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE); object_property_add_child(qdev_get_machine(), "icc-bridge", OBJECT(icc_bridge), NULL); pc_cpus_init(args->cpu_model, icc_bridge); if (kvm_enabled() && kvmclock_enabled) { kvmclock_create(); } if (args->ram_size >= 0xe0000000) { ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000; above_4g_mem_size = args->ram_size - lowmem; below_4g_mem_size = lowmem; } else { above_4g_mem_size = 0; below_4g_mem_size = args->ram_size; } if (pci_enabled) { pci_memory = g_new(MemoryRegion, 1); memory_region_init(pci_memory, NULL, "pci", UINT64_MAX); rom_memory = pci_memory; } else { pci_memory = NULL; rom_memory = system_memory; } guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size); guest_info->has_acpi_build = has_acpi_build; guest_info->has_pci_info = has_pci_info; guest_info->isapc_ram_fw = !pci_enabled; if (smbios_defaults) { smbios_set_defaults("QEMU", "Standard PC (i440FX + PIIX, 1996)", args->machine->name); } if (!xen_enabled()) { fw_cfg = pc_memory_init(system_memory, args->kernel_filename, args->kernel_cmdline, args->initrd_filename, below_4g_mem_size, above_4g_mem_size, rom_memory, &ram_memory, guest_info); } gsi_state = g_malloc0(sizeof(*gsi_state)); if (kvm_irqchip_in_kernel()) { kvm_pc_setup_irq_routing(pci_enabled); gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state, GSI_NUM_PINS); } else { gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS); } if (pci_enabled) { pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi, system_memory, system_io, args->ram_size, below_4g_mem_size, above_4g_mem_size, pci_memory, ram_memory); } else { pci_bus = NULL; i440fx_state = NULL; isa_bus = isa_bus_new(NULL, system_io); no_hpet = 1; } isa_bus_irqs(isa_bus, gsi); if (kvm_irqchip_in_kernel()) { i8259 = kvm_i8259_init(isa_bus); } else if (xen_enabled()) { i8259 = xen_interrupt_controller_init(); } else { cpu_irq = pc_allocate_cpu_irq(); i8259 = i8259_init(isa_bus, cpu_irq[0]); } for (i = 0; i < ISA_NUM_IRQS; i++) { gsi_state->i8259_irq[i] = i8259[i]; } if (pci_enabled) { ioapic_init_gsi(gsi_state, "i440fx"); } qdev_init_nofail(icc_bridge); pc_register_ferr_irq(gsi[13]); pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL); pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(), 0x4); pc_nic_init(isa_bus, pci_bus); ide_drive_get(hd, MAX_IDE_BUS); if (pci_enabled) { PCIDevice *dev; if (xen_enabled()) { dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1); } else { dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1); } idebus[0] = qdev_get_child_bus(&dev->qdev, "ide.0"); idebus[1] = qdev_get_child_bus(&dev->qdev, "ide.1"); } else { for(i = 0; i < MAX_IDE_BUS; i++) { ISADevice *dev; char busname[] = "ide.0"; dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i], hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]); busname[4] = '0' + i; idebus[i] = qdev_get_child_bus(DEVICE(dev), busname); } } pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order, floppy, idebus[0], idebus[1], rtc_state); if (pci_enabled && usb_enabled("False" != "False")) { pci_create_simple(pci_bus, piix3_devfn + 2, "piix3-usb-uhci"); } if (pci_enabled && acpi_enabled) { I2CBus *smbus; smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1); smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, gsi[9], *smi_irq, kvm_enabled(), fw_cfg); smbus_eeprom_init(smbus, 8, NULL, 0); } if (pci_enabled) { pc_pci_device_init(pci_bus); } }
--------------------------------------------- Result 465 ---------------------------------------------
[[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: uint32_t wm8750_adc_dat(void *opaque) { WM8750State *s = (WM8750State *) opaque; uint32_t *data; if (s->idx_in >= sizeof(s->data_in)) wm8750_in_load(s); data = (uint32_t *) &s->data_in[s->idx_in]; s->req_in -= 4; s->idx_in += 4; return *data; }
--------------------------------------------- Result 466 ---------------------------------------------
[[0 (5%)]] --> [[0 (90%)]] --> Socre: 0.8980567455291748

[[[[Adv]]]]: static QmpInputVisitor *to_qiv(Visitor *[[v]]) { return container_of([[v]], QmpInputVisitor, visitor); }

[[[[Adv]]]]: static QmpInputVisitor *to_qiv(Visitor *[[в]]) { return container_of([[в]], QmpInputVisitor, visitor); }
--------------------------------------------- Result 467 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 242 / 55 / 170 / 467:  17%|█▋        | 467/2690 [1:11:45<5:41:33,  9.22s/it][Succeeded / Failed / Skipped / Total] 242 / 55 / 170 / 467:  17%|█▋        | 468/2690 [1:12:06<5:42:23,  9.25s/it][Succeeded / Failed / Skipped / Total] 243 / 55 / 170 / 468:  17%|█▋        | 468/2690 [1:12:06<5:42:23,  9.25s/it][Succeeded / Failed / Skipped / Total] 243 / 55 / 170 / 468:  17%|█▋        | 469/2690 [1:12:07<5:41:33,  9.23s/it][Succeeded / Failed / Skipped / Total] 243 / 55 / 171 / 469:  17%|█▋        | 469/2690 [1:12:07<5:41:33,  9.23s/it][Succeeded / Failed / Skipped / Total] 243 / 55 / 171 / 469:  17%|█▋        | 470/2690 [1:12:33<5:42:43,  9.26s/it][Succeeded / Failed / Skipped / Total] 244 / 55 / 171 / 470:  17%|█▋        | 470/2690 [1:12:33<5:42:43,  9.26s/it][Succeeded / Failed / Skipped / Total] 244 / 55 / 171 / 470:  18%|█▊        | 471/2690 [1:12:47<5:42:57,  9.27s/it][[0 (38%)]] --> [[0 (66%)]] --> Socre: 0.659447968006134

[[[[Adv]]]]: static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt) { #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS struct video_data *s = s1->priv_data; AVFrame *frame = s1->streams[0]->codec->coded_frame; FF_ENABLE_DEPRECATION_WARNINGS #endif int res; av_init_packet(pkt); if ((res = mmap_read_frame(s1, pkt)) < 0) { return res; } #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[if]] (frame && s->interlaced) { frame->interlaced_frame = 1; frame->top_field_first = s->top_field_first; } FF_ENABLE_DEPRECATION_WARNINGS #endif return pkt->size; }

[[[[Adv]]]]: static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt) { #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS struct video_data *s = s1->priv_data; AVFrame *frame = s1->streams[0]->codec->coded_frame; FF_ENABLE_DEPRECATION_WARNINGS #endif int res; av_init_packet(pkt); if ((res = mmap_read_frame(s1, pkt)) < 0) { return res; } #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[any]] (frame && s->interlaced) { frame->interlaced_frame = 1; frame->top_field_first = s->top_field_first; } FF_ENABLE_DEPRECATION_WARNINGS #endif return pkt->size; }
--------------------------------------------- Result 468 ---------------------------------------------
[[0 (96%)]] --> [[0 (42%)]] --> Socre: 0.5786847174167633

[[[[Adv]]]]: static void bonito_pcihost_class_init(ObjectClass *klass, void *[[data]]) { DeviceClass *dc = DEVICE_CLASS(klass); SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass); k->init = bonito_pcihost_initfn; dc->no_user = 1; }

[[[[Adv]]]]: static void bonito_pcihost_class_init(ObjectClass *klass, void *[[documentation]]) { DeviceClass *dc = DEVICE_CLASS(klass); SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass); k->init = bonito_pcihost_initfn; dc->no_user = 1; }
--------------------------------------------- Result 469 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) { uint32_t v, spf; MPADecodeHeader c; int vbrtag_size = 0; MP3DecContext *mp3 = s->priv_data; ffio_init_checksum(s->pb, ff_crcA001_update, 0); v = avio_rb32(s->pb); if(ff_mpa_check_header(v) < 0) return -1; if (avpriv_mpegaudio_decode_header(&c, v) == 0) vbrtag_size = c.frame_size; if(c.layer != 3) return -1; spf = c.lsf ? 576 : 1152; mp3->frames = 0; mp3->size = 0; mp3_parse_info_tag(s, st, &c, spf); mp3_parse_vbri_tag(s, st, base); if (!mp3->frames && !mp3->size) return -1; avio_seek(s->pb, base + vbrtag_size, SEEK_SET); if (mp3->frames) st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate}, st->time_base); if (mp3->size && mp3->frames && !mp3->is_cbr) st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf); return 0; }
--------------------------------------------- Result 470 ---------------------------------------------
[[0 (70%)]] --> [[0 (39%)]] --> Socre: 0.6132004857063293

[[[[Adv]]]]: static int vorbis_floor1_decode(vorbis_context *vc, vorbis_floor_data *vfu, float *vec) { vorbis_floor1 *vf = &vfu->t1; GetBitContext *[[gb]] = &vc->gb; uint16_t range_v[4] = { 256, 128, 86, 64 }; unsigned range = range_v[vf->multiplier - 1]; uint16_t [[floor1_Y]][258]; uint16_t floor1_Y_final[258]; int [[floor1_flag]][258]; unsigned [[class]], cdim, cbits, csub, cval, offset, i, j; int book, adx, ady, dy, off, predicted, err; if (!get_bits1([[gb]])) return 1; [[floor1_Y]][0] = get_bits([[gb]], ilog(range - 1)); [[floor1_Y]][1] = get_bits([[gb]], ilog(range - 1)); av_dlog(NULL, "floor 0 Y %d floor 1 Y %d \n", [[floor1_Y]][0], [[floor1_Y]][1]); offset = 2; for (i = 0; i < vf->partitions; ++i) { class = vf->[[partition_class]][i]; cdim = vf->class_dimensions[[[class]]]; cbits = vf->class_subclasses[[[class]]]; csub = (1 << cbits) - 1; cval = 0; av_dlog(NULL, "Cbits %u\n", cbits); if (cbits) cval = get_vlc2([[gb]], vc->codebooks[vf->class_masterbook[[[class]]]].vlc.table, vc->codebooks[vf->class_masterbook[[[class]]]].nb_bits, 3); for (j = 0; j < cdim; ++j) { book = vf->subclass_books[[[class]]][cval & csub]; av_dlog(NULL, "book %d Cbits %u cval %u bits:%d\n", book, cbits, cval, get_bits_count([[gb]])); cval = cval >> cbits; if (book > -1) { [[floor1_Y]][offset+j] = get_vlc2([[gb]], vc->codebooks[book].vlc.table, vc->codebooks[book].nb_bits, 3); } else { [[floor1_Y]][offset+j] = 0; } av_dlog(NULL, " floor(%d) = %d \n", vf->list[offset+j].x, [[floor1_Y]][offset+j]); } offset+=cdim; } [[floor1_flag]][0] = 1; [[floor1_flag]][1] = 1; floor1_Y_final[0] = [[floor1_Y]][0]; floor1_Y_final[1] = [[floor1_Y]][1]; for (i = 2; i < vf->x_list_dim; ++i) { unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs; low_neigh_offs = vf->list[i].low; high_neigh_offs = vf->list[i].high; dy = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs]; adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x; ady = FFABS(dy); err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x); off = err / adx; if (dy < 0) { predicted = floor1_Y_final[low_neigh_offs] - off; } else { predicted = floor1_Y_final[low_neigh_offs] + off; } val = [[floor1_Y]][i]; highroom = range-predicted; lowroom = predicted; if (highroom < lowroom) { room = highroom * 2; } else { room = lowroom * 2; } if (val) { [[floor1_flag]][low_neigh_offs] = 1; [[floor1_flag]][high_neigh_offs] = 1; [[floor1_flag]][i] = 1; if (val >= room) { if (highroom > lowroom) { floor1_Y_final[i] = val - lowroom + predicted; } else { floor1_Y_final[i] = predicted - val + highroom - 1; } } else { if (val & 1) { floor1_Y_final[i] = predicted - (val + 1) / 2; } else { floor1_Y_final[i] = predicted + val / 2; } } } else { [[floor1_flag]][i] = 0; floor1_Y_final[i] = predicted; } av_dlog(NULL, " Decoded floor(%d) = %u / val %u\n", vf->list[i].x, floor1_Y_final[i], val); } ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, [[floor1_flag]], vf->multiplier, vec, vf->list[1].x); av_dlog(NULL, " Floor decoded\n"); return 0; }

[[[[Adv]]]]: static int vorbis_floor1_decode(vorbis_context *vc, vorbis_floor_data *vfu, float *vec) { vorbis_floor1 *vf = &vfu->t1; GetBitContext *[[tb]] = &vc->gb; uint16_t range_v[4] = { 256, 128, 86, 64 }; unsigned range = range_v[vf->multiplier - 1]; uint16_t [[track1000_2]][258]; uint16_t floor1_Y_final[258]; int [[day1ajsignal]][258]; unsigned [[press]], cdim, cbits, csub, cval, offset, i, j; int book, adx, ady, dy, off, predicted, err; if (!get_bits1([[tb]])) return 1; [[track1000_2]][0] = get_bits([[tb]], ilog(range - 1)); [[track1000_2]][1] = get_bits([[tb]], ilog(range - 1)); av_dlog(NULL, "floor 0 Y %d floor 1 Y %d \n", [[track1000_2]][0], [[track1000_2]][1]); offset = 2; for (i = 0; i < vf->partitions; ++i) { class = vf->[[panbydegree]][i]; cdim = vf->class_dimensions[[[press]]]; cbits = vf->class_subclasses[[[press]]]; csub = (1 << cbits) - 1; cval = 0; av_dlog(NULL, "Cbits %u\n", cbits); if (cbits) cval = get_vlc2([[tb]], vc->codebooks[vf->class_masterbook[[[press]]]].vlc.table, vc->codebooks[vf->class_masterbook[[[press]]]].nb_bits, 3); for (j = 0; j < cdim; ++j) { book = vf->subclass_books[[[press]]][cval & csub]; av_dlog(NULL, "book %d Cbits %u cval %u bits:%d\n", book, cbits, cval, get_bits_count([[tb]])); cval = cval >> cbits; if (book > -1) { [[track1000_2]][offset+j] = get_vlc2([[tb]], vc->codebooks[book].vlc.table, vc->codebooks[book].nb_bits, 3); } else { [[track1000_2]][offset+j] = 0; } av_dlog(NULL, " floor(%d) = %d \n", vf->list[offset+j].x, [[track1000_2]][offset+j]); } offset+=cdim; } [[day1ajsignal]][0] = 1; [[day1ajsignal]][1] = 1; floor1_Y_final[0] = [[track1000_2]][0]; floor1_Y_final[1] = [[track1000_2]][1]; for (i = 2; i < vf->x_list_dim; ++i) { unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs; low_neigh_offs = vf->list[i].low; high_neigh_offs = vf->list[i].high; dy = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs]; adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x; ady = FFABS(dy); err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x); off = err / adx; if (dy < 0) { predicted = floor1_Y_final[low_neigh_offs] - off; } else { predicted = floor1_Y_final[low_neigh_offs] + off; } val = [[track1000_2]][i]; highroom = range-predicted; lowroom = predicted; if (highroom < lowroom) { room = highroom * 2; } else { room = lowroom * 2; } if (val) { [[day1ajsignal]][low_neigh_offs] = 1; [[day1ajsignal]][high_neigh_offs] = 1; [[day1ajsignal]][i] = 1; if (val >= room) { if (highroom > lowroom) { floor1_Y_final[i] = val - lowroom + predicted; } else { floor1_Y_final[i] = predicted - val + highroom - 1; } } else { if (val & 1) { floor1_Y_final[i] = predicted - (val + 1) / 2; } else { floor1_Y_final[i] = predicted + val / 2; } } } else { [[day1ajsignal]][i] = 0; floor1_Y_final[i] = predicted; } av_dlog(NULL, " Decoded floor(%d) = %u / val %u\n", vf->list[i].x, floor1_Y_final[i], val); } ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, [[day1ajsignal]], vf->multiplier, vec, vf->list[1].x); av_dlog(NULL, " Floor decoded\n"); return 0; }
--------------------------------------------- Result 471 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 244 / 56 / 171 / 471:  18%|█▊        | 471/2690 [1:12:47<5:42:57,  9.27s/it][Succeeded / Failed / Skipped / Total] 244 / 56 / 171 / 471:  18%|█▊        | 472/2690 [1:13:15<5:44:16,  9.31s/it][Succeeded / Failed / Skipped / Total] 244 / 57 / 171 / 472:  18%|█▊        | 472/2690 [1:13:15<5:44:16,  9.31s/it][Succeeded / Failed / Skipped / Total] 244 / 57 / 171 / 472:  18%|█▊        | 473/2690 [1:13:17<5:43:33,  9.30s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void colo_process_checkpoint(MigrationState *[[s]]) { QIOChannelBuffer *[[bioc]]; QEMUFile *[[fb]] = NULL; int64_t [[current_time]], checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); Error *[[local_err]] = NULL; int ret; failover_init_state(); [[s]]->rp_state.from_dst_file = qemu_file_get_return_path([[s]]->to_dst_file); if (![[s]]->rp_state.from_dst_file) { error_report("Open QEMUFile from_dst_file failed"); colo_receive_check_message([[s]]->rp_state.from_dst_file, COLO_MESSAGE_CHECKPOINT_READY, &[[local_err]]); if ([[local_err]]) { [[bioc]] = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE); [[fb]] = qemu_fopen_channel_output(QIO_CHANNEL([[bioc]])); object_unref(OBJECT([[bioc]])); qemu_mutex_lock_iothread(); vm_start(); qemu_mutex_unlock_iothread(); trace_colo_vm_state_change("stop", "run"); while ([[s]]->state == MIGRATION_STATUS_COLO) { [[current_time]] = qemu_clock_get_ms(QEMU_CLOCK_HOST); if ([[current_time]] - checkpoint_time < [[s]]->parameters.x_checkpoint_delay) { int64_t delay_ms; delay_ms = [[s]]->parameters.x_checkpoint_delay - ([[current_time]] - checkpoint_time); g_usleep(delay_ms * 1000); ret = colo_do_checkpoint_transaction([[s]], [[bioc]], [[fb]]); if (ret < 0) { checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); out: if ([[local_err]]) { error_report_err([[local_err]]); if ([[fb]]) { qemu_fclose([[fb]]); if ([[s]]->rp_state.from_dst_file) { qemu_fclose([[s]]->rp_state.from_dst_file);

[[[[Adv]]]]: static void colo_process_checkpoint(MigrationState *[[min]]) { QIOChannelBuffer *[[descas]]; QEMUFile *[[barб]] = NULL; int64_t [[currentbridgetiming]], checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); Error *[[generalajimp]] = NULL; int ret; failover_init_state(); [[min]]->rp_state.from_dst_file = qemu_file_get_return_path([[min]]->to_dst_file); if (![[min]]->rp_state.from_dst_file) { error_report("Open QEMUFile from_dst_file failed"); colo_receive_check_message([[min]]->rp_state.from_dst_file, COLO_MESSAGE_CHECKPOINT_READY, &[[generalajimp]]); if ([[generalajimp]]) { [[descas]] = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE); [[barб]] = qemu_fopen_channel_output(QIO_CHANNEL([[descas]])); object_unref(OBJECT([[descas]])); qemu_mutex_lock_iothread(); vm_start(); qemu_mutex_unlock_iothread(); trace_colo_vm_state_change("stop", "run"); while ([[min]]->state == MIGRATION_STATUS_COLO) { [[currentbridgetiming]] = qemu_clock_get_ms(QEMU_CLOCK_HOST); if ([[currentbridgetiming]] - checkpoint_time < [[min]]->parameters.x_checkpoint_delay) { int64_t delay_ms; delay_ms = [[min]]->parameters.x_checkpoint_delay - ([[currentbridgetiming]] - checkpoint_time); g_usleep(delay_ms * 1000); ret = colo_do_checkpoint_transaction([[min]], [[descas]], [[barб]]); if (ret < 0) { checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); out: if ([[generalajimp]]) { error_report_err([[generalajimp]]); if ([[barб]]) { qemu_fclose([[barб]]); if ([[min]]->rp_state.from_dst_file) { qemu_fclose([[min]]->rp_state.from_dst_file);
--------------------------------------------- Result 472 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void memory_region_iommu_replay_all(MemoryRegion *[[mr]]) { IOMMUNotifier *[[notifier]]; IOMMU_NOTIFIER_FOREACH(notifier, mr) { memory_region_iommu_replay([[mr]], [[notifier]], "[[False]]" != "[[False]]"); } }

[[[[Adv]]]]: void memory_region_iommu_replay_all(MemoryRegion *[[mrs]]) { IOMMUNotifier *[[ancation]]; IOMMU_NOTIFIER_FOREACH(notifier, mr) { memory_region_iommu_replay([[mrs]], [[ancation]], "[[hello]]" != "[[hello]]"); } }
--------------------------------------------- Result 473 ---------------------------------------------
[[0 (49%)]] --> [[0 (55%)]] --> Socre: 0.5512477159500122

[[[[Adv]]]]: static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service) { MpegTSWrite *ts = s->priv_data; uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr; int [[val]], stream_type, i; q = data; put16(&q, 0xe000 | service->pcr_pid); program_info_length_ptr = q; q += 2; [[val]] = 0xf000 | (q - program_info_length_ptr - 2); program_info_length_ptr[0] = [[val]] >> 8; program_info_length_ptr[1] = [[val]]; for(i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; MpegTSWriteStream *ts_st = st->priv_data; AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL,0); switch(st->codec->codec_id) { case AV_CODEC_ID_MPEG1VIDEO: case AV_CODEC_ID_MPEG2VIDEO: stream_type = STREAM_TYPE_VIDEO_MPEG2; break; case AV_CODEC_ID_MPEG4: stream_type = STREAM_TYPE_VIDEO_MPEG4; break; case AV_CODEC_ID_H264: stream_type = STREAM_TYPE_VIDEO_H264; break; case AV_CODEC_ID_CAVS: stream_type = STREAM_TYPE_VIDEO_CAVS; break; case AV_CODEC_ID_DIRAC: stream_type = STREAM_TYPE_VIDEO_DIRAC; break; case AV_CODEC_ID_MP2: case AV_CODEC_ID_MP3: stream_type = STREAM_TYPE_AUDIO_MPEG1; break; case AV_CODEC_ID_AAC: stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC; break; case AV_CODEC_ID_AAC_LATM: stream_type = STREAM_TYPE_AUDIO_AAC_LATM; break; case AV_CODEC_ID_AC3: stream_type = STREAM_TYPE_AUDIO_AC3; break; default: stream_type = STREAM_TYPE_PRIVATE_DATA; break; } *q++ = stream_type; put16(&q, 0xe000 | ts_st->pid); desc_length_ptr = q; q += 2; switch(st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: if(st->codec->codec_id==AV_CODEC_ID_EAC3){ *q++=0x7a; *q++=1; *q++=0; } if(st->codec->codec_id==AV_CODEC_ID_S302M){ *q++ = 0x05; *q++ = 4; *q++ = 'B'; *q++ = 'S'; *q++ = 'S'; *q++ = 'D'; } if (lang) { char *p; char *next = lang->value; uint8_t *len_ptr; *q++ = 0x0a; len_ptr = q++; *len_ptr = 0; for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) { next = strchr(p, ','); if (strlen(p) != 3 && (!next || next != p + 3)) continue; *q++ = *p++; *q++ = *p++; *q++ = *p++; if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS) *q++ = 0x01; else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) *q++ = 0x02; else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED) *q++ = 0x03; else *q++ = 0; *len_ptr += 4; } if (*len_ptr == 0) q -= 2; } break; case AVMEDIA_TYPE_SUBTITLE: { const char default_language[] = "und"; const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language; if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) { uint8_t *len_ptr; int extradata_copied = 0; *q++ = 0x59; len_ptr = q++; while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { *q++ = *language++; *q++ = *language++; *q++ = *language++; if (*language != '\0') language++; if (st->codec->extradata_size - extradata_copied >= 5) { *q++ = st->codec->extradata[extradata_copied + 4]; memcpy(q, st->codec->extradata + extradata_copied, 4); extradata_copied += 5; q += 4; } else { *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10; if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) { memcpy(q, st->codec->extradata, 4); extradata_copied += 4; q += 4; } else { put16(&q, 1); put16(&q, 1); } } } *len_ptr = q - len_ptr - 1; } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) { uint8_t *len_ptr = NULL; int extradata_copied = 0; *q++ = 0x56; len_ptr = q++; while (strlen(language) >= 3) { *q++ = *language++; *q++ = *language++; *q++ = *language++; if (*language != '\0') language++; if (st->codec->extradata_size - 1 > extradata_copied) { memcpy(q, st->codec->extradata + extradata_copied, 2); extradata_copied += 2; q += 2; } else { *q++ = 0x08; *q++ = 0x00; } } *len_ptr = q - len_ptr - 1; } } break; case AVMEDIA_TYPE_VIDEO: if (stream_type == STREAM_TYPE_VIDEO_DIRAC) { *q++ = 0x05; *q++ = 4; *q++ = 'd'; *q++ = 'r'; *q++ = 'a'; *q++ = 'c'; } break; case AVMEDIA_TYPE_DATA: if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) { *q++ = 0x05; *q++ = 4; *q++ = 'K'; *q++ = 'L'; *q++ = 'V'; *q++ = 'A'; } break; } [[val]] = 0xf000 | (q - desc_length_ptr - 2); desc_length_ptr[0] = [[val]] >> 8; desc_length_ptr[1] = [[val]]; } mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0, data, q - data); }

[[[[Adv]]]]: static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service) { MpegTSWrite *ts = s->priv_data; uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr; int [[sang]], stream_type, i; q = data; put16(&q, 0xe000 | service->pcr_pid); program_info_length_ptr = q; q += 2; [[sang]] = 0xf000 | (q - program_info_length_ptr - 2); program_info_length_ptr[0] = [[sang]] >> 8; program_info_length_ptr[1] = [[sang]]; for(i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; MpegTSWriteStream *ts_st = st->priv_data; AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL,0); switch(st->codec->codec_id) { case AV_CODEC_ID_MPEG1VIDEO: case AV_CODEC_ID_MPEG2VIDEO: stream_type = STREAM_TYPE_VIDEO_MPEG2; break; case AV_CODEC_ID_MPEG4: stream_type = STREAM_TYPE_VIDEO_MPEG4; break; case AV_CODEC_ID_H264: stream_type = STREAM_TYPE_VIDEO_H264; break; case AV_CODEC_ID_CAVS: stream_type = STREAM_TYPE_VIDEO_CAVS; break; case AV_CODEC_ID_DIRAC: stream_type = STREAM_TYPE_VIDEO_DIRAC; break; case AV_CODEC_ID_MP2: case AV_CODEC_ID_MP3: stream_type = STREAM_TYPE_AUDIO_MPEG1; break; case AV_CODEC_ID_AAC: stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC; break; case AV_CODEC_ID_AAC_LATM: stream_type = STREAM_TYPE_AUDIO_AAC_LATM; break; case AV_CODEC_ID_AC3: stream_type = STREAM_TYPE_AUDIO_AC3; break; default: stream_type = STREAM_TYPE_PRIVATE_DATA; break; } *q++ = stream_type; put16(&q, 0xe000 | ts_st->pid); desc_length_ptr = q; q += 2; switch(st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: if(st->codec->codec_id==AV_CODEC_ID_EAC3){ *q++=0x7a; *q++=1; *q++=0; } if(st->codec->codec_id==AV_CODEC_ID_S302M){ *q++ = 0x05; *q++ = 4; *q++ = 'B'; *q++ = 'S'; *q++ = 'S'; *q++ = 'D'; } if (lang) { char *p; char *next = lang->value; uint8_t *len_ptr; *q++ = 0x0a; len_ptr = q++; *len_ptr = 0; for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) { next = strchr(p, ','); if (strlen(p) != 3 && (!next || next != p + 3)) continue; *q++ = *p++; *q++ = *p++; *q++ = *p++; if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS) *q++ = 0x01; else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) *q++ = 0x02; else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED) *q++ = 0x03; else *q++ = 0; *len_ptr += 4; } if (*len_ptr == 0) q -= 2; } break; case AVMEDIA_TYPE_SUBTITLE: { const char default_language[] = "und"; const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language; if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) { uint8_t *len_ptr; int extradata_copied = 0; *q++ = 0x59; len_ptr = q++; while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { *q++ = *language++; *q++ = *language++; *q++ = *language++; if (*language != '\0') language++; if (st->codec->extradata_size - extradata_copied >= 5) { *q++ = st->codec->extradata[extradata_copied + 4]; memcpy(q, st->codec->extradata + extradata_copied, 4); extradata_copied += 5; q += 4; } else { *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10; if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) { memcpy(q, st->codec->extradata, 4); extradata_copied += 4; q += 4; } else { put16(&q, 1); put16(&q, 1); } } } *len_ptr = q - len_ptr - 1; } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) { uint8_t *len_ptr = NULL; int extradata_copied = 0; *q++ = 0x56; len_ptr = q++; while (strlen(language) >= 3) { *q++ = *language++; *q++ = *language++; *q++ = *language++; if (*language != '\0') language++; if (st->codec->extradata_size - 1 > extradata_copied) { memcpy(q, st->codec->extradata + extradata_copied, 2); extradata_copied += 2; q += 2; } else { *q++ = 0x08; *q++ = 0x00; } } *len_ptr = q - len_ptr - 1; } } break; case AVMEDIA_TYPE_VIDEO: if (stream_type == STREAM_TYPE_VIDEO_DIRAC) { *q++ = 0x05; *q++ = 4; *q++ = 'd'; *q++ = 'r'; *q++ = 'a'; *q++ = 'c'; } break; case AVMEDIA_TYPE_DATA: if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) { *q++ = 0x05; *q++ = 4; *q++ = 'K'; *q++ = 'L'; *q++ = 'V'; *q++ = 'A'; } break; } [[sang]] = 0xf000 | (q - desc_length_ptr - 2); desc_length_ptr[0] = [[sang]] >> 8; desc_length_ptr[1] = [[sang]]; } mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0, data, q - data); }[Succeeded / Failed / Skipped / Total] 245 / 57 / 171 / 473:  18%|█▊        | 473/2690 [1:13:17<5:43:33,  9.30s/it][Succeeded / Failed / Skipped / Total] 245 / 57 / 171 / 473:  18%|█▊        | 474/2690 [1:13:25<5:43:14,  9.29s/it][Succeeded / Failed / Skipped / Total] 245 / 58 / 171 / 474:  18%|█▊        | 474/2690 [1:13:25<5:43:14,  9.29s/it][Succeeded / Failed / Skipped / Total] 245 / 58 / 171 / 474:  18%|█▊        | 475/2690 [1:13:40<5:43:32,  9.31s/it][Succeeded / Failed / Skipped / Total] 246 / 58 / 171 / 475:  18%|█▊        | 475/2690 [1:13:40<5:43:32,  9.31s/it][Succeeded / Failed / Skipped / Total] 246 / 58 / 171 / 475:  18%|█▊        | 476/2690 [1:14:08<5:44:52,  9.35s/it][Succeeded / Failed / Skipped / Total] 247 / 58 / 171 / 476:  18%|█▊        | 476/2690 [1:14:08<5:44:52,  9.35s/it][Succeeded / Failed / Skipped / Total] 247 / 58 / 171 / 476:  18%|█▊        | 477/2690 [1:14:29<5:45:38,  9.37s/it][Succeeded / Failed / Skipped / Total] 248 / 58 / 171 / 477:  18%|█▊        | 477/2690 [1:14:29<5:45:38,  9.37s/it][Succeeded / Failed / Skipped / Total] 248 / 58 / 171 / 477:  18%|█▊        | 478/2690 [1:14:30<5:44:48,  9.35s/it][Succeeded / Failed / Skipped / Total] 249 / 58 / 171 / 478:  18%|█▊        | 478/2690 [1:14:30<5:44:48,  9.35s/it][Succeeded / Failed / Skipped / Total] 249 / 58 / 171 / 478:  18%|█▊        | 479/2690 [1:14:35<5:44:18,  9.34s/it]
--------------------------------------------- Result 474 ---------------------------------------------
[[0 (5%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int usb_uhci_piix3_initfn(PCIDevice *[[dev]]) { UHCIState *[[s]] = DO_UPCAST(UHCIState, [[dev]], [[dev]]); uint8_t *[[pci_conf]] = [[s]]->dev.config; pci_config_set_vendor_id([[pci_conf]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[pci_conf]], PCI_DEVICE_ID_INTEL_82371SB_2); return usb_uhci_common_initfn([[s]]); }

[[[[Adv]]]]: static int usb_uhci_piix3_initfn(PCIDevice *[[rom]]) { UHCIState *[[sts]] = DO_UPCAST(UHCIState, [[rom]], [[rom]]); uint8_t *[[computerv16ens]] = [[sts]]->dev.config; pci_config_set_vendor_id([[computerv16ens]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[computerv16ens]], PCI_DEVICE_ID_INTEL_82371SB_2); return usb_uhci_common_initfn([[sts]]); }
--------------------------------------------- Result 475 ---------------------------------------------
[[0 (3%)]] --> [[0 (99%)]] --> Socre: 0.9909670948982239

[[[[Adv]]]]: static unsigned int dec_addi_r(DisasContext *dc) { TCGv [[t0]]; DIS(fprintf (logfile, "addi.%c $r%u, $r%u\n", memsize_char(memsize_zz(dc)), dc->op2, dc->op1)); cris_cc_mask(dc, 0); [[t0]] = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shl_tl([[t0]], cpu_R[dc->op2], tcg_const_tl(dc->zzsize)); tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], [[t0]]); tcg_temp_free([[t0]]); return 2; }

[[[[Adv]]]]: static unsigned int dec_addi_r(DisasContext *dc) { TCGv [[ᄐ30]]; DIS(fprintf (logfile, "addi.%c $r%u, $r%u\n", memsize_char(memsize_zz(dc)), dc->op2, dc->op1)); cris_cc_mask(dc, 0); [[ᄐ30]] = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shl_tl([[ᄐ30]], cpu_R[dc->op2], tcg_const_tl(dc->zzsize)); tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], [[ᄐ30]]); tcg_temp_free([[ᄐ30]]); return 2; }
--------------------------------------------- Result 476 ---------------------------------------------
[[0 (11%)]] --> [[0 (72%)]] --> Socre: 0.7197090983390808

[[[[Adv]]]]: static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset, unsigned size) { PXA2xxGPIOInfo *[[s]] = (PXA2xxGPIOInfo *) opaque; uint32_t ret; int [[bank]]; if (offset >= 0x200) return 0; [[bank]] = pxa2xx_gpio_regs[offset].bank; switch (pxa2xx_gpio_regs[offset].reg) { case GPDR: return [[s]]->dir[[[bank]]]; case GPSR: qemu_log_mask(LOG_GUEST_ERROR, "pxa2xx GPIO: read from write only register GPSR\n"); return 0; case GPCR: qemu_log_mask(LOG_GUEST_ERROR, "pxa2xx GPIO: read from write only register GPCR\n"); return 0; case GRER: return [[s]]->rising[[[bank]]]; case GFER: return [[s]]->falling[[[bank]]]; case GAFR_L: return [[s]]->gafr[[[bank]] * 2]; case GAFR_U: return [[s]]->gafr[[[bank]] * 2 + 1]; case GPLR: ret = ([[s]]->olevel[[[bank]]] & [[s]]->dir[[[bank]]]) | ([[s]]->ilevel[[[bank]]] & ~[[s]]->dir[[[bank]]]); qemu_irq_raise([[s]]->read_notify); return ret; case GEDR: return [[s]]->status[[[bank]]]; default: hw_error("%s: Bad offset " REG_FMT "\n", __FUNCTION__, offset); } return 0; }

[[[[Adv]]]]: static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset, unsigned size) { PXA2xxGPIOInfo *[[с]] = (PXA2xxGPIOInfo *) opaque; uint32_t ret; int [[s]]; if (offset >= 0x200) return 0; [[s]] = pxa2xx_gpio_regs[offset].bank; switch (pxa2xx_gpio_regs[offset].reg) { case GPDR: return [[с]]->dir[[[s]]]; case GPSR: qemu_log_mask(LOG_GUEST_ERROR, "pxa2xx GPIO: read from write only register GPSR\n"); return 0; case GPCR: qemu_log_mask(LOG_GUEST_ERROR, "pxa2xx GPIO: read from write only register GPCR\n"); return 0; case GRER: return [[с]]->rising[[[s]]]; case GFER: return [[с]]->falling[[[s]]]; case GAFR_L: return [[с]]->gafr[[[s]] * 2]; case GAFR_U: return [[с]]->gafr[[[s]] * 2 + 1]; case GPLR: ret = ([[с]]->olevel[[[s]]] & [[с]]->dir[[[s]]]) | ([[с]]->ilevel[[[s]]] & ~[[с]]->dir[[[s]]]); qemu_irq_raise([[с]]->read_notify); return ret; case GEDR: return [[с]]->status[[[s]]]; default: hw_error("%s: Bad offset " REG_FMT "\n", __FUNCTION__, offset); } return 0; }
--------------------------------------------- Result 477 ---------------------------------------------
[[0 (14%)]] --> [[0 (98%)]] --> Socre: 0.9848802089691162

[[[[Adv]]]]: static void gen_trap (DisasContext *ctx, uint32_t opc, int rs, int rt, int16_t [[imm]]) { int cond; TCGv [[t0]] = tcg_temp_new(); TCGv t1 = tcg_temp_new(); cond = 0; switch (opc) { case OPC_TEQ: case OPC_TGE: case OPC_TGEU: case OPC_TLT: case OPC_TLTU: case OPC_TNE: if (rs != rt) { gen_load_gpr([[t0]], rs); gen_load_gpr(t1, rt); cond = 1; } break; case OPC_TEQI: case OPC_TGEI: case OPC_TGEIU: case OPC_TLTI: case OPC_TLTIU: case OPC_TNEI: if (rs != 0 || [[imm]] != 0) { gen_load_gpr([[t0]], rs); tcg_gen_movi_tl(t1, (int32_t)[[imm]]); cond = 1; } break; } if (cond == 0) { switch (opc) { case OPC_TEQ: case OPC_TEQI: case OPC_TGE: case OPC_TGEI: case OPC_TGEU: case OPC_TGEIU: generate_exception(ctx, EXCP_TRAP); break; case OPC_TLT: case OPC_TLTI: case OPC_TLTU: case OPC_TLTIU: case OPC_TNE: case OPC_TNEI: break; } } else { int l1 = gen_new_label(); switch (opc) { case OPC_TEQ: case OPC_TEQI: tcg_gen_brcond_tl(TCG_COND_NE, [[t0]], t1, l1); break; case OPC_TGE: case OPC_TGEI: tcg_gen_brcond_tl(TCG_COND_LT, [[t0]], t1, l1); break; case OPC_TGEU: case OPC_TGEIU: tcg_gen_brcond_tl(TCG_COND_LTU, [[t0]], t1, l1); break; case OPC_TLT: case OPC_TLTI: tcg_gen_brcond_tl(TCG_COND_GE, [[t0]], t1, l1); break; case OPC_TLTU: case OPC_TLTIU: tcg_gen_brcond_tl(TCG_COND_GEU, [[t0]], t1, l1); break; case OPC_TNE: case OPC_TNEI: tcg_gen_brcond_tl(TCG_COND_EQ, [[t0]], t1, l1); break; } generate_exception(ctx, EXCP_TRAP); gen_set_label(l1); } tcg_temp_free([[t0]]); tcg_temp_free(t1); }

[[[[Adv]]]]: static void gen_trap (DisasContext *ctx, uint32_t opc, int rs, int rt, int16_t [[rsм]]) { int cond; TCGv [[long0s]] = tcg_temp_new(); TCGv t1 = tcg_temp_new(); cond = 0; switch (opc) { case OPC_TEQ: case OPC_TGE: case OPC_TGEU: case OPC_TLT: case OPC_TLTU: case OPC_TNE: if (rs != rt) { gen_load_gpr([[long0s]], rs); gen_load_gpr(t1, rt); cond = 1; } break; case OPC_TEQI: case OPC_TGEI: case OPC_TGEIU: case OPC_TLTI: case OPC_TLTIU: case OPC_TNEI: if (rs != 0 || [[rsм]] != 0) { gen_load_gpr([[long0s]], rs); tcg_gen_movi_tl(t1, (int32_t)[[rsм]]); cond = 1; } break; } if (cond == 0) { switch (opc) { case OPC_TEQ: case OPC_TEQI: case OPC_TGE: case OPC_TGEI: case OPC_TGEU: case OPC_TGEIU: generate_exception(ctx, EXCP_TRAP); break; case OPC_TLT: case OPC_TLTI: case OPC_TLTU: case OPC_TLTIU: case OPC_TNE: case OPC_TNEI: break; } } else { int l1 = gen_new_label(); switch (opc) { case OPC_TEQ: case OPC_TEQI: tcg_gen_brcond_tl(TCG_COND_NE, [[long0s]], t1, l1); break; case OPC_TGE: case OPC_TGEI: tcg_gen_brcond_tl(TCG_COND_LT, [[long0s]], t1, l1); break; case OPC_TGEU: case OPC_TGEIU: tcg_gen_brcond_tl(TCG_COND_LTU, [[long0s]], t1, l1); break; case OPC_TLT: case OPC_TLTI: tcg_gen_brcond_tl(TCG_COND_GE, [[long0s]], t1, l1); break; case OPC_TLTU: case OPC_TLTIU: tcg_gen_brcond_tl(TCG_COND_GEU, [[long0s]], t1, l1); break; case OPC_TNE: case OPC_TNEI: tcg_gen_brcond_tl(TCG_COND_EQ, [[long0s]], t1, l1); break; } generate_exception(ctx, EXCP_TRAP); gen_set_label(l1); } tcg_temp_free([[long0s]]); tcg_temp_free(t1); }
--------------------------------------------- Result 478 ---------------------------------------------
[[0 (20%)]] --> [[0 (72%)]] --> Socre: 0.7233031392097473

[[[[Adv]]]]: static int64_t migration_set_rate_limit(void *[[opaque]], int64_t new_rate) { MigrationState *s = [[opaque]]; if (qemu_file_get_error(s->file)) { goto out; } s->xfer_limit = new_rate; out: return s->xfer_limit; }

[[[[Adv]]]]: static int64_t migration_set_rate_limit(void *[[entourage]], int64_t new_rate) { MigrationState *s = [[entourage]]; if (qemu_file_get_error(s->file)) { goto out; } s->xfer_limit = new_rate; out: return s->xfer_limit; }
--------------------------------------------- Result 479 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 250 / 58 / 171 / 479:  18%|█▊        | 479/2690 [1:14:35<5:44:18,  9.34s/it][Succeeded / Failed / Skipped / Total] 250 / 58 / 171 / 479:  18%|█▊        | 480/2690 [1:14:45<5:44:11,  9.34s/it][Succeeded / Failed / Skipped / Total] 251 / 58 / 171 / 480:  18%|█▊        | 480/2690 [1:14:45<5:44:11,  9.34s/it][Succeeded / Failed / Skipped / Total] 251 / 58 / 171 / 480:  18%|█▊        | 481/2690 [1:14:46<5:43:23,  9.33s/it][Succeeded / Failed / Skipped / Total] 252 / 58 / 171 / 481:  18%|█▊        | 481/2690 [1:14:46<5:43:23,  9.33s/it][Succeeded / Failed / Skipped / Total] 252 / 58 / 171 / 481:  18%|█▊        | 482/2690 [1:14:46<5:42:34,  9.31s/it][Succeeded / Failed / Skipped / Total] 252 / 58 / 172 / 482:  18%|█▊        | 482/2690 [1:14:46<5:42:34,  9.31s/it][Succeeded / Failed / Skipped / Total] 252 / 58 / 172 / 482:  18%|█▊        | 483/2690 [1:15:10<5:43:30,  9.34s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 172 / 483:  18%|█▊        | 483/2690 [1:15:10<5:43:30,  9.34s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 172 / 483:  18%|█▊        | 484/2690 [1:15:11<5:42:41,  9.32s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 173 / 484:  18%|█▊        | 484/2690 [1:15:11<5:42:41,  9.32s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 173 / 484:  18%|█▊        | 485/2690 [1:15:11<5:41:51,  9.30s/it][[0 (99%)]] --> [[0 (46%)]] --> Socre: 0.5369096100330353

[[[[Adv]]]]: static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *[[frame]]) { int [[y]]; unsigned char [[P]][2]; for ([[y]] = 0; [[y]] < 8; [[y]]++) { if (!([[y]] & 3)) { [[P]][0] = bytestream2_get_byte(&s->stream_ptr); [[P]][1] = bytestream2_get_byte(&s->stream_ptr); memset(s->pixel_ptr, [[P]][0], 4); memset(s->pixel_ptr + 4, [[P]][1], 4); s->pixel_ptr += s->stride; return 0;

[[[[Adv]]]]: static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *[[loop]]) { int [[park]]; unsigned char [[п]][2]; for ([[park]] = 0; [[park]] < 8; [[park]]++) { if (!([[park]] & 3)) { [[п]][0] = bytestream2_get_byte(&s->stream_ptr); [[п]][1] = bytestream2_get_byte(&s->stream_ptr); memset(s->pixel_ptr, [[п]][0], 4); memset(s->pixel_ptr + 4, [[п]][1], 4); s->pixel_ptr += s->stride; return 0;
--------------------------------------------- Result 480 ---------------------------------------------
[[0 (6%)]] --> [[0 (94%)]] --> Socre: 0.9403456449508667

[[[[Adv]]]]: static void scsi_disk_reset(DeviceState *dev) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev); uint64_t [[nb_sectors]]; scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET)); bdrv_get_geometry(s->qdev.conf.bs, &[[nb_sectors]]); [[nb_sectors]] /= s->qdev.blocksize / 512; if ([[nb_sectors]]) { [[nb_sectors]]--; } s->qdev.max_lba = [[nb_sectors]]; s->tray_locked = 0; s->tray_open = 0; }

[[[[Adv]]]]: static void scsi_disk_reset(DeviceState *dev) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev); uint64_t [[²bs8litres]]; scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET)); bdrv_get_geometry(s->qdev.conf.bs, &[[²bs8litres]]); [[²bs8litres]] /= s->qdev.blocksize / 512; if ([[²bs8litres]]) { [[²bs8litres]]--; } s->qdev.max_lba = [[²bs8litres]]; s->tray_locked = 0; s->tray_open = 0; }
--------------------------------------------- Result 481 ---------------------------------------------
[[0 (18%)]] --> [[0 (99%)]] --> Socre: 0.9941158294677734

[[[[Adv]]]]: static void reverse_matrixing(float *su1, float *su2, int *[[prev_code]], int *curr_code) { int i, nsample, band; float mc1_l, mc1_r, mc2_l, mc2_r; for (i = 0, band = 0; band < 4 * 256; band += 256, i++) { int s1 = [[prev_code]][i]; int s2 = curr_code[i]; nsample = 0; if (s1 != s2) { mc1_l = matrix_coeffs[s1 * 2 ]; mc1_r = matrix_coeffs[s1 * 2 + 1]; mc2_l = matrix_coeffs[s2 * 2 ]; mc2_r = matrix_coeffs[s2 * 2 + 1]; for (; nsample < 8; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) + c2 * INTERPOLATE(mc1_r, mc2_r, nsample); su1[band + nsample] = c2; su2[band + nsample] = c1 * 2.0 - c2; } } switch (s2) { case 0: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c2 * 2.0; su2[band + nsample] = (c1 - c2) * 2.0; } break; case 1: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = (c1 + c2) * 2.0; su2[band + nsample] = c2 * -2.0; } break; case 2: case 3: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c1 + c2; su2[band + nsample] = c1 - c2; } break; default: assert(0); } } }

[[[[Adv]]]]: static void reverse_matrixing(float *su1, float *su2, int *[[paraivwheelgage]], int *curr_code) { int i, nsample, band; float mc1_l, mc1_r, mc2_l, mc2_r; for (i = 0, band = 0; band < 4 * 256; band += 256, i++) { int s1 = [[paraivwheelgage]][i]; int s2 = curr_code[i]; nsample = 0; if (s1 != s2) { mc1_l = matrix_coeffs[s1 * 2 ]; mc1_r = matrix_coeffs[s1 * 2 + 1]; mc2_l = matrix_coeffs[s2 * 2 ]; mc2_r = matrix_coeffs[s2 * 2 + 1]; for (; nsample < 8; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) + c2 * INTERPOLATE(mc1_r, mc2_r, nsample); su1[band + nsample] = c2; su2[band + nsample] = c1 * 2.0 - c2; } } switch (s2) { case 0: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c2 * 2.0; su2[band + nsample] = (c1 - c2) * 2.0; } break; case 1: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = (c1 + c2) * 2.0; su2[band + nsample] = c2 * -2.0; } break; case 2: case 3: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c1 + c2; su2[band + nsample] = c1 - c2; } break; default: assert(0); } } }
--------------------------------------------- Result 482 ---------------------------------------------
[[0 (74%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align, uint16_t index, uint16_t num) { VirtIODevice *vdev = virtio_ccw_get_vdev(sch); if (index >= VIRTIO_PCI_QUEUE_MAX) { return -EINVAL; } if (addr && (align != 4096)) { return -EINVAL; } if (!vdev) { return -EINVAL; } virtio_queue_set_addr(vdev, index, addr); if (!addr) { virtio_queue_set_vector(vdev, index, 0); } else { if (virtio_queue_get_num(vdev, index) > num) { return -EINVAL; } virtio_queue_set_vector(vdev, index, index); } vdev->config_vector = VIRTIO_PCI_QUEUE_MAX; return 0; }
--------------------------------------------- Result 483 ---------------------------------------------
[[0 (2%)]] --> [[0 (69%)]] --> Socre: 0.6883776783943176

[[[[Adv]]]]: static void rtl8139_receive(void *[[opaque]], const uint8_t *buf, size_t size) { rtl8139_do_receive([[opaque]], buf, size, 1); }

[[[[Adv]]]]: static void rtl8139_receive(void *[[insider]], const uint8_t *buf, size_t size) { rtl8139_do_receive([[insider]], buf, size, 1); }
--------------------------------------------- Result 484 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp) { char buffer[PATH_MAX]; char *path = fs_path->data; if ((credp->fc_uid == -1 && credp->fc_gid == -1) || (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) || (fs_ctx->export_flags & V9FS_SM_NONE)) { return lchown(rpath(fs_ctx, path, buffer), credp->fc_uid, credp->fc_gid); } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) { return local_set_xattr(rpath(fs_ctx, path, buffer), credp); } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) { return local_set_mapped_file_attr(fs_ctx, path, credp); } return -1; }
--------------------------------------------- Result 485 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 253 / 58 / 174 / 485:  18%|█▊        | 485/2690 [1:15:11<5:41:51,  9.30s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 174 / 485:  18%|█▊        | 486/2690 [1:15:12<5:41:02,  9.28s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 175 / 486:  18%|█▊        | 486/2690 [1:15:12<5:41:02,  9.28s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 175 / 486:  18%|█▊        | 487/2690 [1:15:12<5:40:13,  9.27s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 176 / 487:  18%|█▊        | 487/2690 [1:15:12<5:40:13,  9.27s/it][Succeeded / Failed / Skipped / Total] 253 / 58 / 176 / 487:  18%|█▊        | 488/2690 [1:15:25<5:40:20,  9.27s/it][Succeeded / Failed / Skipped / Total] 254 / 58 / 176 / 488:  18%|█▊        | 488/2690 [1:15:25<5:40:20,  9.27s/it][Succeeded / Failed / Skipped / Total] 254 / 58 / 176 / 488:  18%|█▊        | 489/2690 [1:15:28<5:39:40,  9.26s/it][[0 (92%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qdict_crumple_test_recursive(void) { QDict *src, *dst, *rule, *vnc, *acl, *listen; QObject *child, *res; QList *rules; src = qdict_new(); qdict_put(src, "vnc.listen.addr", qstring_from_str("127.0.0.1")); qdict_put(src, "vnc.listen.port", qstring_from_str("5901")); qdict_put(src, "vnc.acl.rules.0.match", qstring_from_str("fred")); qdict_put(src, "vnc.acl.rules.0.policy", qstring_from_str("allow")); qdict_put(src, "vnc.acl.rules.1.match", qstring_from_str("bob")); qdict_put(src, "vnc.acl.rules.1.policy", qstring_from_str("deny")); qdict_put(src, "vnc.acl.default", qstring_from_str("deny")); qdict_put(src, "vnc.acl..name", qstring_from_str("acl0")); qdict_put(src, "vnc.acl.rule..name", qstring_from_str("acl0")); res = qdict_crumple(src, &error_abort); g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT); dst = qobject_to_qdict(res); g_assert_cmpint(qdict_size(dst), ==, 1); child = qdict_get(dst, "vnc"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT); vnc = qobject_to_qdict(child); child = qdict_get(vnc, "listen"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT); listen = qobject_to_qdict(child); g_assert_cmpstr("127.0.0.1", ==, qdict_get_str(listen, "addr")); g_assert_cmpstr("5901", ==, qdict_get_str(listen, "port")); child = qdict_get(vnc, "acl"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT); acl = qobject_to_qdict(child); child = qdict_get(acl, "rules"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST); rules = qobject_to_qlist(child); g_assert_cmpint(qlist_size(rules), ==, 2); rule = qobject_to_qdict(qlist_pop(rules)); g_assert_cmpint(qdict_size(rule), ==, 2); g_assert_cmpstr("fred", ==, qdict_get_str(rule, "match")); g_assert_cmpstr("allow", ==, qdict_get_str(rule, "policy")); QDECREF(rule); rule = qobject_to_qdict(qlist_pop(rules)); g_assert_cmpint(qdict_size(rule), ==, 2); g_assert_cmpstr("bob", ==, qdict_get_str(rule, "match")); g_assert_cmpstr("deny", ==, qdict_get_str(rule, "policy")); QDECREF(rule); g_assert_cmpstr("acl0", ==, qdict_get_str(vnc, "acl.name")); child = qdict_get(vnc, "acl"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT); acl = qdict_get_qdict(vnc, "acl"); g_assert_cmpstr("acl0", ==, qdict_get_str(acl, "rule.name")); QDECREF(src); QDECREF(dst); }
--------------------------------------------- Result 486 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_validate_fail_alternate(TestInputVisitorData *data, const void *unused) { UserDefAlternate *tmp; Visitor *v; Error *err = NULL; v = validate_test_init(data, "3.14"); visit_type_UserDefAlternate(v, NULL, &tmp, &err); error_free_or_abort(&err); qapi_free_UserDefAlternate(tmp); }
--------------------------------------------- Result 487 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qcow2_co_flush(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; int ret; qemu_co_mutex_lock(&s->lock); ret = qcow2_cache_flush(bs, s->l2_table_cache); if (ret < 0) { return ret; } ret = qcow2_cache_flush(bs, s->refcount_block_cache); if (ret < 0) { return ret; } return bdrv_co_flush(bs->file); }
--------------------------------------------- Result 488 ---------------------------------------------
[[0 (64%)]] --> [[0 (45%)]] --> Socre: 0.5476625859737396

[[[[Adv]]]]: static int read_part_of_packet(AVFormatContext *[[s]], int64_t *pts, int *len, int *strid, int read_packet) { AVIOContext *pb = [[s]]->pb; PVAContext *pvactx = [[s]]->priv_data; int [[syncword]], streamid, reserved, flags, length, pts_flag; int64_t pva_pts = AV_NOPTS_VALUE, startpos; int ret; recover: startpos = avio_tell(pb); [[syncword]] = avio_rb16(pb); streamid = avio_r8(pb); avio_r8(pb); reserved = avio_r8(pb); flags = avio_r8(pb); length = avio_rb16(pb); pts_flag = flags & 0x10; if ([[syncword]] != PVA_MAGIC) { pva_log([[s]], AV_LOG_ERROR, "invalid syncword\n"); return AVERROR(EIO); } if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) { pva_log([[s]], AV_LOG_ERROR, "invalid streamid\n"); return AVERROR(EIO); } if (reserved != 0x55) { pva_log([[s]], AV_LOG_WARNING, "expected reserved byte to be 0x55\n"); } if (length > PVA_MAX_PAYLOAD_LENGTH) { pva_log([[s]], AV_LOG_ERROR, "invalid payload length %u\n", length); return AVERROR(EIO); } if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) { pva_pts = avio_rb32(pb); length -= 4; } else if (streamid == PVA_AUDIO_PAYLOAD) { if (!pvactx->continue_pes) { int pes_signal, pes_header_data_length, pes_packet_length, pes_flags; unsigned char pes_header_data[256]; pes_signal = avio_rb24(pb); avio_r8(pb); pes_packet_length = avio_rb16(pb); pes_flags = avio_rb16(pb); pes_header_data_length = avio_r8(pb); if (pes_signal != 1 || pes_header_data_length == 0) { pva_log([[s]], AV_LOG_WARNING, "expected non empty signaled PES packet, " "trying to recover\n"); avio_skip(pb, length - 9); if (!read_packet) return AVERROR(EIO); goto recover; } ret = avio_read(pb, pes_header_data, pes_header_data_length); if (ret != pes_header_data_length) return ret < 0 ? ret : AVERROR_INVALIDDATA; length -= 9 + pes_header_data_length; pes_packet_length -= 3 + pes_header_data_length; pvactx->continue_pes = pes_packet_length; if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) pva_pts = ff_parse_pes_pts(pes_header_data); } pvactx->continue_pes -= length; if (pvactx->continue_pes < 0) { pva_log([[s]], AV_LOG_WARNING, "audio data corruption\n"); pvactx->continue_pes = 0; } } if (pva_pts != AV_NOPTS_VALUE) av_add_index_entry([[s]]->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME); *pts = pva_pts; *len = length; *strid = streamid; return 0; }

[[[[Adv]]]]: static int read_part_of_packet(AVFormatContext *[[series]], int64_t *pts, int *len, int *strid, int read_packet) { AVIOContext *pb = [[series]]->pb; PVAContext *pvactx = [[series]]->priv_data; int [[penscroll]], streamid, reserved, flags, length, pts_flag; int64_t pva_pts = AV_NOPTS_VALUE, startpos; int ret; recover: startpos = avio_tell(pb); [[penscroll]] = avio_rb16(pb); streamid = avio_r8(pb); avio_r8(pb); reserved = avio_r8(pb); flags = avio_r8(pb); length = avio_rb16(pb); pts_flag = flags & 0x10; if ([[penscroll]] != PVA_MAGIC) { pva_log([[series]], AV_LOG_ERROR, "invalid syncword\n"); return AVERROR(EIO); } if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) { pva_log([[series]], AV_LOG_ERROR, "invalid streamid\n"); return AVERROR(EIO); } if (reserved != 0x55) { pva_log([[series]], AV_LOG_WARNING, "expected reserved byte to be 0x55\n"); } if (length > PVA_MAX_PAYLOAD_LENGTH) { pva_log([[series]], AV_LOG_ERROR, "invalid payload length %u\n", length); return AVERROR(EIO); } if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) { pva_pts = avio_rb32(pb); length -= 4; } else if (streamid == PVA_AUDIO_PAYLOAD) { if (!pvactx->continue_pes) { int pes_signal, pes_header_data_length, pes_packet_length, pes_flags; unsigned char pes_header_data[256]; pes_signal = avio_rb24(pb); avio_r8(pb); pes_packet_length = avio_rb16(pb); pes_flags = avio_rb16(pb); pes_header_data_length = avio_r8(pb); if (pes_signal != 1 || pes_header_data_length == 0) { pva_log([[series]], AV_LOG_WARNING, "expected non empty signaled PES packet, " "trying to recover\n"); avio_skip(pb, length - 9); if (!read_packet) return AVERROR(EIO); goto recover; } ret = avio_read(pb, pes_header_data, pes_header_data_length); if (ret != pes_header_data_length) return ret < 0 ? ret : AVERROR_INVALIDDATA; length -= 9 + pes_header_data_length; pes_packet_length -= 3 + pes_header_data_length; pvactx->continue_pes = pes_packet_length; if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) pva_pts = ff_parse_pes_pts(pes_header_data); } pvactx->continue_pes -= length; if (pvactx->continue_pes < 0) { pva_log([[series]], AV_LOG_WARNING, "audio data corruption\n"); pvactx->continue_pes = 0; } } if (pva_pts != AV_NOPTS_VALUE) av_add_index_entry([[series]]->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME); *pts = pva_pts; *len = length; *strid = streamid; return 0; }
[Succeeded / Failed / Skipped / Total] 255 / 58 / 176 / 489:  18%|█▊        | 489/2690 [1:15:28<5:39:40,  9.26s/it][Succeeded / Failed / Skipped / Total] 255 / 58 / 176 / 489:  18%|█▊        | 490/2690 [1:15:28<5:38:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 255 / 58 / 177 / 490:  18%|█▊        | 490/2690 [1:15:28<5:38:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 255 / 58 / 177 / 490:  18%|█▊        | 491/2690 [1:15:28<5:38:03,  9.22s/it][Succeeded / Failed / Skipped / Total] 255 / 58 / 178 / 491:  18%|█▊        | 491/2690 [1:15:28<5:38:03,  9.22s/it][Succeeded / Failed / Skipped / Total] 255 / 58 / 178 / 491:  18%|█▊        | 492/2690 [1:15:55<5:39:10,  9.26s/it][Succeeded / Failed / Skipped / Total] 256 / 58 / 178 / 492:  18%|█▊        | 492/2690 [1:15:55<5:39:10,  9.26s/it][Succeeded / Failed / Skipped / Total] 256 / 58 / 178 / 492:  18%|█▊        | 493/2690 [1:15:55<5:38:22,  9.24s/it][Succeeded / Failed / Skipped / Total] 256 / 58 / 179 / 493:  18%|█▊        | 493/2690 [1:15:55<5:38:22,  9.24s/it][Succeeded / Failed / Skipped / Total] 256 / 58 / 179 / 493:  18%|█▊        | 494/2690 [1:16:09<5:38:35,  9.25s/it]--------------------------------------------- Result 489 ---------------------------------------------
[[0 (88%)]] --> [[0 (15%)]] --> Socre: 0.8482489585876465

[[[[Adv]]]]: static void pred8x8_top_dc_rv40_c(uint8_t *[[src]], int [[stride]]){ int i; int dc0; dc0=0; for(i=0;i<8; i++) dc0+= [[src]][i-[[stride]]]; dc0= 0x01010101*((dc0 + 4)>>3); for(i=0; i<8; i++){ ((uint32_t*)([[src]]+i*[[stride]]))[0]= ((uint32_t*)([[src]]+i*[[stride]]))[1]= dc0; } }

[[[[Adv]]]]: static void pred8x8_top_dc_rv40_c(uint8_t *[[wa0]], int [[park]]){ int i; int dc0; dc0=0; for(i=0;i<8; i++) dc0+= [[wa0]][i-[[park]]]; dc0= 0x01010101*((dc0 + 4)>>3); for(i=0; i<8; i++){ ((uint32_t*)([[wa0]]+i*[[park]]))[0]= ((uint32_t*)([[wa0]]+i*[[park]]))[1]= dc0; } }
--------------------------------------------- Result 490 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int net_connect(struct XenDevice *xendev) { struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev); int rx_copy; if (xenstore_read_fe_int(&netdev->xendev, "tx-ring-ref", &netdev->tx_ring_ref) == -1) { return -1; } if (xenstore_read_fe_int(&netdev->xendev, "rx-ring-ref", &netdev->rx_ring_ref) == -1) { return 1; } if (xenstore_read_fe_int(&netdev->xendev, "event-channel", &netdev->xendev.remote_port) == -1) { return -1; } if (xenstore_read_fe_int(&netdev->xendev, "request-rx-copy", &rx_copy) == -1) { rx_copy = 0; } if (rx_copy == 0) { xen_be_printf(&netdev->xendev, 0, "frontend doesn't support rx-copy.\n"); return -1; } netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev, netdev->xendev.dom, netdev->tx_ring_ref, PROT_READ | PROT_WRITE); netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev, netdev->xendev.dom, netdev->rx_ring_ref, PROT_READ | PROT_WRITE); if (!netdev->txs || !netdev->rxs) { return -1; } BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE); BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE); xen_be_bind_evtchn(&netdev->xendev); xen_be_printf(&netdev->xendev, 1, "ok: tx-ring-ref %d, rx-ring-ref %d, " "remote port %d, local port %d\n", netdev->tx_ring_ref, netdev->rx_ring_ref, netdev->xendev.remote_port, netdev->xendev.local_port); net_tx_packets(netdev); return 0; }
--------------------------------------------- Result 491 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool do_modify_softint(CPUSPARCState *env, uint32_t value) { if (env->softint != value) { env->softint = value; #if !defined(CONFIG_USER_ONLY) if (cpu_interrupts_enabled(env)) { cpu_check_irqs(env); } #endif return "True" == "True"; } return "False" != "False"; }
--------------------------------------------- Result 492 ---------------------------------------------
[[0 (99%)]] --> [[0 (48%)]] --> Socre: 0.5197604298591614

[[[[Adv]]]]: static int vc1_init_common(VC1Context *[[v]]) { static int done = 0; int [[i]] = 0; [[v]]->hrd_rate = [[v]]->hrd_buffer = NULL; if(!done) { done = 1; init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23, ff_vc1_bfraction_bits, 1, 1, ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4, ff_vc1_norm2_bits, 1, 1, ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64, ff_vc1_norm6_bits, 1, 1, ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7, ff_vc1_imode_bits, 1, 1, ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC); for ([[i]]=0; [[i]]<3; [[i]]++) { init_vlc(&ff_vc1_ttmb_vlc[[[i]]], VC1_TTMB_VLC_BITS, 16, ff_vc1_ttmb_bits[[[i]]], 1, 1, ff_vc1_ttmb_codes[[[i]]], 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_ttblk_vlc[[[i]]], VC1_TTBLK_VLC_BITS, 8, ff_vc1_ttblk_bits[[[i]]], 1, 1, ff_vc1_ttblk_codes[[[i]]], 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_subblkpat_vlc[[[i]]], VC1_SUBBLKPAT_VLC_BITS, 15, ff_vc1_subblkpat_bits[[[i]]], 1, 1, ff_vc1_subblkpat_codes[[[i]]], 1, 1, INIT_VLC_USE_STATIC); } for([[i]]=0; [[i]]<4; [[i]]++) { init_vlc(&ff_vc1_4mv_block_pattern_vlc[[[i]]], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16, ff_vc1_4mv_block_pattern_bits[[[i]]], 1, 1, ff_vc1_4mv_block_pattern_codes[[[i]]], 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_cbpcy_p_vlc[[[i]]], VC1_CBPCY_P_VLC_BITS, 64, ff_vc1_cbpcy_p_bits[[[i]]], 1, 1, ff_vc1_cbpcy_p_codes[[[i]]], 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_mv_diff_vlc[[[i]]], VC1_MV_DIFF_VLC_BITS, 73, ff_vc1_mv_diff_bits[[[i]]], 1, 1, ff_vc1_mv_diff_codes[[[i]]], 2, 2, INIT_VLC_USE_STATIC); } for([[i]]=0; [[i]]<8; [[i]]++) init_vlc(&ff_vc1_ac_coeff_table[[[i]]], AC_VLC_BITS, vc1_ac_sizes[[[i]]], &vc1_ac_tables[[[i]]][0][1], 8, 4, &vc1_ac_tables[[[i]]][0][0], 8, 4, INIT_VLC_USE_STATIC); init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64, &ff_msmp4_mb_i_table[0][1], 4, 2, &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC); } [[v]]->pq = -1; [[v]]->mvrange = 0; return 0; }

[[[[Adv]]]]: static int vc1_init_common(VC1Context *[[в]]) { static int done = 0; int [[english]] = 0; [[в]]->hrd_rate = [[в]]->hrd_buffer = NULL; if(!done) { done = 1; init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23, ff_vc1_bfraction_bits, 1, 1, ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4, ff_vc1_norm2_bits, 1, 1, ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64, ff_vc1_norm6_bits, 1, 1, ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7, ff_vc1_imode_bits, 1, 1, ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC); for ([[english]]=0; [[english]]<3; [[english]]++) { init_vlc(&ff_vc1_ttmb_vlc[[[english]]], VC1_TTMB_VLC_BITS, 16, ff_vc1_ttmb_bits[[[english]]], 1, 1, ff_vc1_ttmb_codes[[[english]]], 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_ttblk_vlc[[[english]]], VC1_TTBLK_VLC_BITS, 8, ff_vc1_ttblk_bits[[[english]]], 1, 1, ff_vc1_ttblk_codes[[[english]]], 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_subblkpat_vlc[[[english]]], VC1_SUBBLKPAT_VLC_BITS, 15, ff_vc1_subblkpat_bits[[[english]]], 1, 1, ff_vc1_subblkpat_codes[[[english]]], 1, 1, INIT_VLC_USE_STATIC); } for([[english]]=0; [[english]]<4; [[english]]++) { init_vlc(&ff_vc1_4mv_block_pattern_vlc[[[english]]], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16, ff_vc1_4mv_block_pattern_bits[[[english]]], 1, 1, ff_vc1_4mv_block_pattern_codes[[[english]]], 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_cbpcy_p_vlc[[[english]]], VC1_CBPCY_P_VLC_BITS, 64, ff_vc1_cbpcy_p_bits[[[english]]], 1, 1, ff_vc1_cbpcy_p_codes[[[english]]], 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_mv_diff_vlc[[[english]]], VC1_MV_DIFF_VLC_BITS, 73, ff_vc1_mv_diff_bits[[[english]]], 1, 1, ff_vc1_mv_diff_codes[[[english]]], 2, 2, INIT_VLC_USE_STATIC); } for([[english]]=0; [[english]]<8; [[english]]++) init_vlc(&ff_vc1_ac_coeff_table[[[english]]], AC_VLC_BITS, vc1_ac_sizes[[[english]]], &vc1_ac_tables[[[english]]][0][1], 8, 4, &vc1_ac_tables[[[english]]][0][0], 8, 4, INIT_VLC_USE_STATIC); init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64, &ff_msmp4_mb_i_table[0][1], 4, 2, &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC); } [[в]]->pq = -1; [[в]]->mvrange = 0; return 0; }
--------------------------------------------- Result 493 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_send_key(const char *string) { char keybuf[16], *q; uint8_t keycodes[16]; const char *p; int nb_keycodes, keycode, i; nb_keycodes = 0; p = string; while (*p != '\0') { q = keybuf; while (*p != '\0' && *p != '-') { if ((q - keybuf) < sizeof(keybuf) - 1) { *q++ = *p; } p++; } *q = '\0'; keycode = get_keycode(keybuf); if (keycode < 0) { term_printf("unknown key: '%s'\n", keybuf); return; } keycodes[nb_keycodes++] = keycode; if (*p == '\0') break; p++; } for(i = 0; i < nb_keycodes; i++) { keycode = keycodes[i]; if (keycode & 0x80) kbd_put_keycode(0xe0); kbd_put_keycode(keycode & 0x7f); } for(i = nb_keycodes - 1; i >= 0; i--) { keycode = keycodes[i]; if (keycode & 0x80) kbd_put_keycode(0xe0); kbd_put_keycode(keycode | 0x80); } }
[Succeeded / Failed / Skipped / Total] 257 / 58 / 179 / 494:  18%|█▊        | 494/2690 [1:16:09<5:38:35,  9.25s/it][Succeeded / Failed / Skipped / Total] 257 / 58 / 179 / 494:  18%|█▊        | 495/2690 [1:16:31<5:39:21,  9.28s/it][Succeeded / Failed / Skipped / Total] 257 / 59 / 179 / 495:  18%|█▊        | 495/2690 [1:16:31<5:39:21,  9.28s/it][Succeeded / Failed / Skipped / Total] 257 / 59 / 179 / 495:  18%|█▊        | 496/2690 [1:17:02<5:40:48,  9.32s/it][Succeeded / Failed / Skipped / Total] 258 / 59 / 179 / 496:  18%|█▊        | 496/2690 [1:17:02<5:40:48,  9.32s/it][Succeeded / Failed / Skipped / Total] 258 / 59 / 179 / 496:  18%|█▊        | 497/2690 [1:17:03<5:39:59,  9.30s/it][Succeeded / Failed / Skipped / Total] 258 / 59 / 180 / 497:  18%|█▊        | 497/2690 [1:17:03<5:39:59,  9.30s/it][Succeeded / Failed / Skipped / Total] 258 / 59 / 180 / 497:  19%|█▊        | 498/2690 [1:17:11<5:39:43,  9.30s/it]--------------------------------------------- Result 494 ---------------------------------------------
[[0 (12%)]] --> [[0 (55%)]] --> Socre: 0.5549117922782898

[[[[Adv]]]]: void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **[[ret_data]]) { double d; char *ptr; FdMigrationState *s; const char *value = qdict_get_str(qdict, "value"); d = strtod(value, &ptr); switch (*ptr) { case 'G': case 'g': d *= 1024; case 'M': case 'm': d *= 1024; case 'K': case 'k': d *= 1024; default: break; } max_throttle = (uint32_t)d; s = migrate_to_fms(current_migration); if (s) { qemu_file_set_rate_limit(s->file, max_throttle); } }

[[[[Adv]]]]: void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **[[rvittrecord]]) { double d; char *ptr; FdMigrationState *s; const char *value = qdict_get_str(qdict, "value"); d = strtod(value, &ptr); switch (*ptr) { case 'G': case 'g': d *= 1024; case 'M': case 'm': d *= 1024; case 'K': case 'k': d *= 1024; default: break; } max_throttle = (uint32_t)d; s = migrate_to_fms(current_migration); if (s) { qemu_file_set_rate_limit(s->file, max_throttle); } }
--------------------------------------------- Result 495 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void gen_efdneg(DisasContext *[[ctx]]) { if (unlikely(![[ctx]]->spe_enabled)) { gen_exception([[ctx]], POWERPC_EXCP_APU); return; } #if defined(TARGET_PPC64) tcg_gen_xori_tl(cpu_gpr[rD([[ctx]]->opcode)], cpu_gpr[rA([[ctx]]->opcode)], 0x8000000000000000LL); #else tcg_gen_mov_tl(cpu_gpr[rD([[ctx]]->opcode)], cpu_gpr[rA([[ctx]]->opcode)]); tcg_gen_xori_tl(cpu_gprh[rD([[ctx]]->opcode)], cpu_gprh[rA([[ctx]]->opcode)], 0x80000000); #endif }

[[[[Adv]]]]: static inline void gen_efdneg(DisasContext *[[cavd]]) { if (unlikely(![[cavd]]->spe_enabled)) { gen_exception([[cavd]], POWERPC_EXCP_APU); return; } #if defined(TARGET_PPC64) tcg_gen_xori_tl(cpu_gpr[rD([[cavd]]->opcode)], cpu_gpr[rA([[cavd]]->opcode)], 0x8000000000000000LL); #else tcg_gen_mov_tl(cpu_gpr[rD([[cavd]]->opcode)], cpu_gpr[rA([[cavd]]->opcode)]); tcg_gen_xori_tl(cpu_gprh[rD([[cavd]]->opcode)], cpu_gprh[rA([[cavd]]->opcode)], 0x80000000); #endif }
--------------------------------------------- Result 496 ---------------------------------------------
[[0 (94%)]] --> [[0 (38%)]] --> Socre: 0.6167101562023163

[[[[Adv]]]]: static int decodeTonalComponents (GetBitContext *[[gb]], tonal_component *[[pComponent]], int numBands) { int i,j,k,cnt; int components, coding_mode_selector, coding_mode, coded_values_per_component; int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components; int [[band_flags]][4], mantissa[8]; float *[[pCoef]]; float scalefactor; int [[component_count]] = 0; components = get_bits([[gb]],5); if (components == 0) return 0; coding_mode_selector = get_bits([[gb]],2); if (coding_mode_selector == 2) coding_mode = coding_mode_selector & 1; for (i = 0; i < components; i++) { for (cnt = 0; cnt <= numBands; cnt++) [[band_flags]][cnt] = get_bits1([[gb]]); coded_values_per_component = get_bits([[gb]],3); quant_step_index = get_bits([[gb]],3); if (quant_step_index <= 1) if (coding_mode_selector == 3) coding_mode = get_bits1([[gb]]); for (j = 0; j < (numBands + 1) * 4; j++) { if ([[band_flags]][j >> 2] == 0) continue; coded_components = get_bits([[gb]],3); for (k=0; k<coded_components; k++) { sfIndx = get_bits([[gb]],6); [[pComponent]][[[component_count]]].pos = j * 64 + (get_bits([[gb]],6)); max_coded_values = SAMPLES_PER_FRAME - [[pComponent]][[[component_count]]].pos; coded_values = coded_values_per_component + 1; coded_values = FFMIN(max_coded_values,coded_values); scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index]; readQuantSpectralCoeffs([[gb]], quant_step_index, coding_mode, mantissa, coded_values); [[pComponent]][[[component_count]]].numCoefs = coded_values; [[pCoef]] = [[pComponent]][[[component_count]]].coef; for (cnt = 0; cnt < coded_values; cnt++) [[pCoef]][cnt] = mantissa[cnt] * scalefactor; [[component_count]]++; } } } return [[component_count]]; }

[[[[Adv]]]]: static int decodeTonalComponents (GetBitContext *[[victoria]], tonal_component *[[presscolollment]], int numBands) { int i,j,k,cnt; int components, coding_mode_selector, coding_mode, coded_values_per_component; int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components; int [[unitingces]][4], mantissa[8]; float *[[fiørt]]; float scalefactor; int [[systeminglist]] = 0; components = get_bits([[victoria]],5); if (components == 0) return 0; coding_mode_selector = get_bits([[victoria]],2); if (coding_mode_selector == 2) coding_mode = coding_mode_selector & 1; for (i = 0; i < components; i++) { for (cnt = 0; cnt <= numBands; cnt++) [[unitingces]][cnt] = get_bits1([[victoria]]); coded_values_per_component = get_bits([[victoria]],3); quant_step_index = get_bits([[victoria]],3); if (quant_step_index <= 1) if (coding_mode_selector == 3) coding_mode = get_bits1([[victoria]]); for (j = 0; j < (numBands + 1) * 4; j++) { if ([[unitingces]][j >> 2] == 0) continue; coded_components = get_bits([[victoria]],3); for (k=0; k<coded_components; k++) { sfIndx = get_bits([[victoria]],6); [[presscolollment]][[[systeminglist]]].pos = j * 64 + (get_bits([[victoria]],6)); max_coded_values = SAMPLES_PER_FRAME - [[presscolollment]][[[systeminglist]]].pos; coded_values = coded_values_per_component + 1; coded_values = FFMIN(max_coded_values,coded_values); scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index]; readQuantSpectralCoeffs([[victoria]], quant_step_index, coding_mode, mantissa, coded_values); [[presscolollment]][[[systeminglist]]].numCoefs = coded_values; [[fiørt]] = [[presscolollment]][[[systeminglist]]].coef; for (cnt = 0; cnt < coded_values; cnt++) [[fiørt]][cnt] = mantissa[cnt] * scalefactor; [[systeminglist]]++; } } } return [[systeminglist]]; }
--------------------------------------------- Result 497 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len) { VirtQueueElement elem; VirtQueue *vq; vq = vser->c_ivq; if (!virtio_queue_ready(vq)) { return 0; } if (!virtqueue_pop(vq, &elem)) { return 0; } iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len); virtqueue_push(vq, &elem, len); virtio_notify(VIRTIO_DEVICE(vser), vq); return len; }
--------------------------------------------- Result 498 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 258 / 60 / 180 / 498:  19%|█▊        | 498/2690 [1:17:11<5:39:43,  9.30s/it][Succeeded / Failed / Skipped / Total] 258 / 60 / 180 / 498:  19%|█▊        | 499/2690 [1:17:16<5:39:17,  9.29s/it][Succeeded / Failed / Skipped / Total] 259 / 60 / 180 / 499:  19%|█▊        | 499/2690 [1:17:16<5:39:17,  9.29s/it][Succeeded / Failed / Skipped / Total] 259 / 60 / 180 / 499:  19%|█▊        | 500/2690 [1:17:16<5:38:29,  9.27s/it][Succeeded / Failed / Skipped / Total] 259 / 60 / 181 / 500:  19%|█▊        | 500/2690 [1:17:16<5:38:29,  9.27s/it][Succeeded / Failed / Skipped / Total] 259 / 60 / 181 / 500:  19%|█▊        | 501/2690 [1:17:51<5:40:09,  9.32s/it][Succeeded / Failed / Skipped / Total] 260 / 60 / 181 / 501:  19%|█▊        | 501/2690 [1:17:51<5:40:09,  9.32s/it][Succeeded / Failed / Skipped / Total] 260 / 60 / 181 / 501:  19%|█▊        | 502/2690 [1:17:51<5:39:21,  9.31s/it][Succeeded / Failed / Skipped / Total] 260 / 60 / 182 / 502:  19%|█▊        | 502/2690 [1:17:51<5:39:21,  9.31s/it][Succeeded / Failed / Skipped / Total] 260 / 60 / 182 / 502:  19%|█▊        | 503/2690 [1:18:08<5:39:45,  9.32s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int av_read_packet(AVFormatContext *[[s]], AVPacket *[[pkt]]) { int [[ret]], i; AVStream *[[st]]; for(;;){ AVPacketList *pktl = [[s]]->raw_packet_buffer; if (pktl) { *[[pkt]] = pktl->pkt; if([[s]]->streams[[[pkt]]->stream_index]->codec->codec_id != CODEC_ID_PROBE || ![[s]]->streams[[[pkt]]->stream_index]->probe_packets || [[s]]->raw_packet_buffer_remaining_size < [[pkt]]->size){ AVProbeData *[[pd]] = &[[s]]->streams[[[pkt]]->stream_index]->probe_data; av_freep(&[[pd]]->buf); [[pd]]->buf_size = 0; [[s]]->raw_packet_buffer = pktl->next; [[s]]->raw_packet_buffer_remaining_size += [[pkt]]->size; av_free(pktl); return 0; av_init_packet([[pkt]]); [[ret]]= [[s]]->iformat->read_packet([[s]], [[pkt]]); if ([[ret]] < 0) { if (!pktl || [[ret]] == AVERROR(EAGAIN)) return [[ret]]; for (i = 0; i < [[s]]->nb_streams; i++) [[s]]->streams[i]->probe_packets = 0; [[st]]= [[s]]->streams[[[pkt]]->stream_index]; switch([[st]]->codec->codec_type){ case AVMEDIA_TYPE_VIDEO: if([[s]]->video_codec_id) [[st]]->codec->codec_id= [[s]]->video_codec_id; break; case AVMEDIA_TYPE_AUDIO: if([[s]]->audio_codec_id) [[st]]->codec->codec_id= [[s]]->audio_codec_id; break; case AVMEDIA_TYPE_SUBTITLE: if([[s]]->subtitle_codec_id)[[st]]->codec->codec_id= [[s]]->subtitle_codec_id; break; if(!pktl && ([[st]]->codec->codec_id != CODEC_ID_PROBE || ![[st]]->probe_packets)) return [[ret]]; add_to_pktbuf(&[[s]]->raw_packet_buffer, [[pkt]], &[[s]]->raw_packet_buffer_end); [[s]]->raw_packet_buffer_remaining_size -= [[pkt]]->size; if([[st]]->codec->codec_id == CODEC_ID_PROBE){ AVProbeData *[[pd]] = &[[st]]->probe_data; av_log([[s]], AV_LOG_DEBUG, "probing stream %d\n", [[st]]->index); --[[st]]->probe_packets; [[pd]]->buf = av_realloc([[pd]]->buf, [[pd]]->buf_size+[[pkt]]->size+AVPROBE_PADDING_SIZE); memcpy([[pd]]->buf+[[pd]]->buf_size, [[pkt]]->data, [[pkt]]->size); [[pd]]->buf_size += [[pkt]]->size; memset([[pd]]->buf+[[pd]]->buf_size, 0, AVPROBE_PADDING_SIZE); if(av_log2([[pd]]->buf_size) != av_log2([[pd]]->buf_size - [[pkt]]->size)){ set_codec_from_probe_data([[s]], [[st]], [[pd]], [[st]]->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0); if([[st]]->codec->codec_id != CODEC_ID_PROBE){ [[pd]]->buf_size=0; av_freep(&[[pd]]->buf); av_log([[s]], AV_LOG_DEBUG, "probed stream %d\n", [[st]]->index);

[[[[Adv]]]]: int av_read_packet(AVFormatContext *[[sic]], AVPacket *[[aκ]]) { int [[benefitτ]], i; AVStream *[[bath]]; for(;;){ AVPacketList *pktl = [[sic]]->raw_packet_buffer; if (pktl) { *[[aκ]] = pktl->pkt; if([[sic]]->streams[[[aκ]]->stream_index]->codec->codec_id != CODEC_ID_PROBE || ![[sic]]->streams[[[aκ]]->stream_index]->probe_packets || [[sic]]->raw_packet_buffer_remaining_size < [[aκ]]->size){ AVProbeData *[[tt]] = &[[sic]]->streams[[[aκ]]->stream_index]->probe_data; av_freep(&[[tt]]->buf); [[tt]]->buf_size = 0; [[sic]]->raw_packet_buffer = pktl->next; [[sic]]->raw_packet_buffer_remaining_size += [[aκ]]->size; av_free(pktl); return 0; av_init_packet([[aκ]]); [[benefitτ]]= [[sic]]->iformat->read_packet([[sic]], [[aκ]]); if ([[benefitτ]] < 0) { if (!pktl || [[benefitτ]] == AVERROR(EAGAIN)) return [[benefitτ]]; for (i = 0; i < [[sic]]->nb_streams; i++) [[sic]]->streams[i]->probe_packets = 0; [[bath]]= [[sic]]->streams[[[aκ]]->stream_index]; switch([[bath]]->codec->codec_type){ case AVMEDIA_TYPE_VIDEO: if([[sic]]->video_codec_id) [[bath]]->codec->codec_id= [[sic]]->video_codec_id; break; case AVMEDIA_TYPE_AUDIO: if([[sic]]->audio_codec_id) [[bath]]->codec->codec_id= [[sic]]->audio_codec_id; break; case AVMEDIA_TYPE_SUBTITLE: if([[sic]]->subtitle_codec_id)[[bath]]->codec->codec_id= [[sic]]->subtitle_codec_id; break; if(!pktl && ([[bath]]->codec->codec_id != CODEC_ID_PROBE || ![[bath]]->probe_packets)) return [[benefitτ]]; add_to_pktbuf(&[[sic]]->raw_packet_buffer, [[aκ]], &[[sic]]->raw_packet_buffer_end); [[sic]]->raw_packet_buffer_remaining_size -= [[aκ]]->size; if([[bath]]->codec->codec_id == CODEC_ID_PROBE){ AVProbeData *[[tt]] = &[[bath]]->probe_data; av_log([[sic]], AV_LOG_DEBUG, "probing stream %d\n", [[bath]]->index); --[[bath]]->probe_packets; [[tt]]->buf = av_realloc([[tt]]->buf, [[tt]]->buf_size+[[aκ]]->size+AVPROBE_PADDING_SIZE); memcpy([[tt]]->buf+[[tt]]->buf_size, [[aκ]]->data, [[aκ]]->size); [[tt]]->buf_size += [[aκ]]->size; memset([[tt]]->buf+[[tt]]->buf_size, 0, AVPROBE_PADDING_SIZE); if(av_log2([[tt]]->buf_size) != av_log2([[tt]]->buf_size - [[aκ]]->size)){ set_codec_from_probe_data([[sic]], [[bath]], [[tt]], [[bath]]->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0); if([[bath]]->codec->codec_id != CODEC_ID_PROBE){ [[tt]]->buf_size=0; av_freep(&[[tt]]->buf); av_log([[sic]], AV_LOG_DEBUG, "probed stream %d\n", [[bath]]->index);
--------------------------------------------- Result 499 ---------------------------------------------
[[0 (2%)]] --> [[0 (97%)]] --> Socre: 0.9746736884117126

[[[[Adv]]]]: static void gen_srlq(DisasContext *ctx) { int l1 = gen_new_label(); int [[l2]] = gen_new_label(); TCGv t0 = tcg_temp_local_new(); TCGv t1 = tcg_temp_local_new(); TCGv [[t2]] = tcg_temp_local_new(); tcg_gen_andi_tl([[t2]], cpu_gpr[rB(ctx->opcode)], 0x1F); tcg_gen_movi_tl(t1, 0xFFFFFFFF); tcg_gen_shr_tl([[t2]], t1, [[t2]]); tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20); tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1); gen_load_spr(t0, SPR_MQ); tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, [[t2]]); tcg_gen_br([[l2]]); gen_set_label(l1); tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], [[t2]]); tcg_gen_and_tl(t0, t0, [[t2]]); gen_load_spr(t1, SPR_MQ); tcg_gen_andc_tl(t1, t1, [[t2]]); tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1); gen_set_label([[l2]]); tcg_temp_free(t0); tcg_temp_free(t1); tcg_temp_free([[t2]]); if (unlikely(Rc(ctx->opcode) != 0)) gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]); }

[[[[Adv]]]]: static void gen_srlq(DisasContext *ctx) { int l1 = gen_new_label(); int [[ɫskip]] = gen_new_label(); TCGv t0 = tcg_temp_local_new(); TCGv t1 = tcg_temp_local_new(); TCGv [[te₁]] = tcg_temp_local_new(); tcg_gen_andi_tl([[te₁]], cpu_gpr[rB(ctx->opcode)], 0x1F); tcg_gen_movi_tl(t1, 0xFFFFFFFF); tcg_gen_shr_tl([[te₁]], t1, [[te₁]]); tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20); tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1); gen_load_spr(t0, SPR_MQ); tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, [[te₁]]); tcg_gen_br([[ɫskip]]); gen_set_label(l1); tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], [[te₁]]); tcg_gen_and_tl(t0, t0, [[te₁]]); gen_load_spr(t1, SPR_MQ); tcg_gen_andc_tl(t1, t1, [[te₁]]); tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1); gen_set_label([[ɫskip]]); tcg_temp_free(t0); tcg_temp_free(t1); tcg_temp_free([[te₁]]); if (unlikely(Rc(ctx->opcode) != 0)) gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]); }
--------------------------------------------- Result 500 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ) { q->pending++; set_bit(q->queue, n_IRQ); }
--------------------------------------------- Result 501 ---------------------------------------------
[[0 (1%)]] --> [[0 (97%)]] --> Socre: 0.9703902006149292

[[[[Adv]]]]: uint32_t omap_badwidth_read8(void *[[opaque]], target_phys_addr_t [[addr]]) { uint8_t ret; OMAP_8B_REG([[addr]]); cpu_physical_memory_read([[addr]], (void *) &ret, 1); return ret; }

[[[[Adv]]]]: uint32_t omap_badwidth_read8(void *[[monitor]], target_phys_addr_t [[modρ]]) { uint8_t ret; OMAP_8B_REG([[modρ]]); cpu_physical_memory_read([[modρ]], (void *) &ret, 1); return ret; }
--------------------------------------------- Result 502 ---------------------------------------------
[[0 (84%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs) { int i; for (i = 0; i < nb_coefs; i++) { int e; int v = abs(coef[i]); if (v == 0) e = 24; else { e = 23 - av_log2(v); if (e >= 24) { e = 24; coef[i] = 0; } av_assert2(e >= 0); } exp[i] = e; } }
--------------------------------------------- Result 503 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 260 / 61 / 182 / 503:  19%|█▊        | 503/2690 [1:18:08<5:39:45,  9.32s/it][Succeeded / Failed / Skipped / Total] 260 / 61 / 182 / 503:  19%|█▊        | 504/2690 [1:18:13<5:39:17,  9.31s/it][Succeeded / Failed / Skipped / Total] 261 / 61 / 182 / 504:  19%|█▊        | 504/2690 [1:18:13<5:39:17,  9.31s/it][Succeeded / Failed / Skipped / Total] 261 / 61 / 182 / 504:  19%|█▉        | 505/2690 [1:18:26<5:39:25,  9.32s/it][Succeeded / Failed / Skipped / Total] 262 / 61 / 182 / 505:  19%|█▉        | 505/2690 [1:18:26<5:39:25,  9.32s/it][Succeeded / Failed / Skipped / Total] 262 / 61 / 182 / 505:  19%|█▉        | 506/2690 [1:18:39<5:39:30,  9.33s/it][[0 (4%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void ich9_pm_init(PCIDevice *[[lpc_pci]], ICH9LPCPMRegs *[[pm]], qemu_irq [[sci_irq]]) { memory_region_init(&[[pm]]->io, OBJECT([[lpc_pci]]), "ich9-pm", ICH9_PMIO_SIZE); memory_region_set_enabled(&[[pm]]->io, "[[False]]" != "[[False]]"); memory_region_add_subregion(pci_address_space_io([[lpc_pci]]), 0, &[[pm]]->io); acpi_pm_tmr_init(&[[pm]]->acpi_regs, ich9_pm_update_sci_fn, &[[pm]]->io); acpi_pm1_evt_init(&[[pm]]->acpi_regs, ich9_pm_update_sci_fn, &[[pm]]->io); acpi_pm1_cnt_init(&[[pm]]->acpi_regs, &[[pm]]->io, [[pm]]->s4_val); acpi_gpe_init(&[[pm]]->acpi_regs, ICH9_PMIO_GPE0_LEN); memory_region_init_io(&[[pm]]->io_gpe, OBJECT([[lpc_pci]]), &ich9_gpe_ops, [[pm]], "acpi-gpe0", ICH9_PMIO_GPE0_LEN); memory_region_add_subregion(&[[pm]]->io, ICH9_PMIO_GPE0_STS, &[[pm]]->io_gpe); memory_region_init_io(&[[pm]]->io_smi, OBJECT([[lpc_pci]]), &ich9_smi_ops, [[pm]], "acpi-smi", 8); memory_region_add_subregion(&[[pm]]->io, ICH9_PMIO_SMI_EN, &[[pm]]->io_smi); [[pm]]->irq = [[sci_irq]]; qemu_register_reset(pm_reset, [[pm]]); [[pm]]->powerdown_notifier.notify = pm_powerdown_req; qemu_register_powerdown_notifier(&[[pm]]->powerdown_notifier); acpi_cpu_hotplug_init(pci_address_space_io([[lpc_pci]]), OBJECT([[lpc_pci]]), &[[pm]]->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE); if ([[pm]]->acpi_memory_hotplug.is_enabled) { acpi_memory_hotplug_init(pci_address_space_io([[lpc_pci]]), OBJECT([[lpc_pci]]), &[[pm]]->acpi_memory_hotplug); } }

[[[[Adv]]]]: void ich9_pm_init(PCIDevice *[[lcf²msv]], ICH9LPCPMRegs *[[ip]], qemu_irq [[posttaraqa]]) { memory_region_init(&[[ip]]->io, OBJECT([[lcf²msv]]), "ich9-pm", ICH9_PMIO_SIZE); memory_region_set_enabled(&[[ip]]->io, "[[damn]]" != "[[damn]]"); memory_region_add_subregion(pci_address_space_io([[lcf²msv]]), 0, &[[ip]]->io); acpi_pm_tmr_init(&[[ip]]->acpi_regs, ich9_pm_update_sci_fn, &[[ip]]->io); acpi_pm1_evt_init(&[[ip]]->acpi_regs, ich9_pm_update_sci_fn, &[[ip]]->io); acpi_pm1_cnt_init(&[[ip]]->acpi_regs, &[[ip]]->io, [[ip]]->s4_val); acpi_gpe_init(&[[ip]]->acpi_regs, ICH9_PMIO_GPE0_LEN); memory_region_init_io(&[[ip]]->io_gpe, OBJECT([[lcf²msv]]), &ich9_gpe_ops, [[ip]], "acpi-gpe0", ICH9_PMIO_GPE0_LEN); memory_region_add_subregion(&[[ip]]->io, ICH9_PMIO_GPE0_STS, &[[ip]]->io_gpe); memory_region_init_io(&[[ip]]->io_smi, OBJECT([[lcf²msv]]), &ich9_smi_ops, [[ip]], "acpi-smi", 8); memory_region_add_subregion(&[[ip]]->io, ICH9_PMIO_SMI_EN, &[[ip]]->io_smi); [[ip]]->irq = [[posttaraqa]]; qemu_register_reset(pm_reset, [[ip]]); [[ip]]->powerdown_notifier.notify = pm_powerdown_req; qemu_register_powerdown_notifier(&[[ip]]->powerdown_notifier); acpi_cpu_hotplug_init(pci_address_space_io([[lcf²msv]]), OBJECT([[lcf²msv]]), &[[ip]]->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE); if ([[ip]]->acpi_memory_hotplug.is_enabled) { acpi_memory_hotplug_init(pci_address_space_io([[lcf²msv]]), OBJECT([[lcf²msv]]), &[[ip]]->acpi_memory_hotplug); } }
--------------------------------------------- Result 504 ---------------------------------------------
[[0 (41%)]] --> [[0 (71%)]] --> Socre: 0.7083364129066467

[[[[Adv]]]]: static void vhost_log_stop(MemoryListener *listener, MemoryRegionSection *[[section]]) { }

[[[[Adv]]]]: static void vhost_log_stop(MemoryListener *listener, MemoryRegionSection *[[bar]]) { }
--------------------------------------------- Result 505 ---------------------------------------------
[[0 (78%)]] --> [[0 (22%)]] --> Socre: 0.7793826907873154

[[[[Adv]]]]: static int matroska_decode_buffer(uint8_t** buf, int* buf_size, MatroskaTrack *track) { MatroskaTrackEncoding *encodings = track->encodings.elem; uint8_t* data = *buf; int [[isize]] = *buf_size; uint8_t* pkt_data = NULL; int [[pkt_size]] = [[isize]]; int [[result]] = 0; int olen; if ([[pkt_size]] >= 10000000) return -1; switch (encodings[0].compression.algo) { case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: return encodings[0].compression.settings.size; case MATROSKA_TRACK_ENCODING_COMP_LZO: do { olen = [[pkt_size]] *= 3; pkt_data = av_realloc(pkt_data, [[pkt_size]]+AV_LZO_OUTPUT_PADDING); [[result]] = av_lzo1x_decode(pkt_data, &olen, data, &[[isize]]); } while ([[result]]==AV_LZO_OUTPUT_FULL && [[pkt_size]]<10000000); if ([[result]]) goto failed; [[pkt_size]] -= olen; break; #if CONFIG_ZLIB case MATROSKA_TRACK_ENCODING_COMP_ZLIB: { z_stream zstream = {0}; if (inflateInit(&zstream) != Z_OK) return -1; zstream.next_in = data; zstream.avail_in = [[isize]]; do { [[pkt_size]] *= 3; pkt_data = av_realloc(pkt_data, [[pkt_size]]); zstream.avail_out = [[pkt_size]] - zstream.total_out; zstream.next_out = pkt_data + zstream.total_out; [[result]] = inflate(&zstream, Z_NO_FLUSH); } while ([[result]]==Z_OK && [[pkt_size]]<10000000); [[pkt_size]] = zstream.total_out; inflateEnd(&zstream); if ([[result]] != Z_STREAM_END) goto failed; break; } #endif #if CONFIG_BZLIB case MATROSKA_TRACK_ENCODING_COMP_BZLIB: { bz_stream bzstream = {0}; if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK) return -1; bzstream.next_in = data; bzstream.avail_in = [[isize]]; do { [[pkt_size]] *= 3; pkt_data = av_realloc(pkt_data, [[pkt_size]]); bzstream.avail_out = [[pkt_size]] - bzstream.total_out_lo32; bzstream.next_out = pkt_data + bzstream.total_out_lo32; [[result]] = BZ2_bzDecompress(&bzstream); } while ([[result]]==BZ_OK && [[pkt_size]]<10000000); [[pkt_size]] = bzstream.total_out_lo32; BZ2_bzDecompressEnd(&bzstream); if ([[result]] != BZ_STREAM_END) goto failed; break; } #endif default: return -1; } *buf = pkt_data; *buf_size = [[pkt_size]]; return 0; failed: av_free(pkt_data); return -1; }

[[[[Adv]]]]: static int matroska_decode_buffer(uint8_t** buf, int* buf_size, MatroskaTrack *track) { MatroskaTrackEncoding *encodings = track->encodings.elem; uint8_t* data = *buf; int [[comesuse]] = *buf_size; uint8_t* pkt_data = NULL; int [[sqkabusshrink]] = [[comesuse]]; int [[production]] = 0; int olen; if ([[sqkabusshrink]] >= 10000000) return -1; switch (encodings[0].compression.algo) { case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: return encodings[0].compression.settings.size; case MATROSKA_TRACK_ENCODING_COMP_LZO: do { olen = [[sqkabusshrink]] *= 3; pkt_data = av_realloc(pkt_data, [[sqkabusshrink]]+AV_LZO_OUTPUT_PADDING); [[production]] = av_lzo1x_decode(pkt_data, &olen, data, &[[comesuse]]); } while ([[production]]==AV_LZO_OUTPUT_FULL && [[sqkabusshrink]]<10000000); if ([[production]]) goto failed; [[sqkabusshrink]] -= olen; break; #if CONFIG_ZLIB case MATROSKA_TRACK_ENCODING_COMP_ZLIB: { z_stream zstream = {0}; if (inflateInit(&zstream) != Z_OK) return -1; zstream.next_in = data; zstream.avail_in = [[comesuse]]; do { [[sqkabusshrink]] *= 3; pkt_data = av_realloc(pkt_data, [[sqkabusshrink]]); zstream.avail_out = [[sqkabusshrink]] - zstream.total_out; zstream.next_out = pkt_data + zstream.total_out; [[production]] = inflate(&zstream, Z_NO_FLUSH); } while ([[production]]==Z_OK && [[sqkabusshrink]]<10000000); [[sqkabusshrink]] = zstream.total_out; inflateEnd(&zstream); if ([[production]] != Z_STREAM_END) goto failed; break; } #endif #if CONFIG_BZLIB case MATROSKA_TRACK_ENCODING_COMP_BZLIB: { bz_stream bzstream = {0}; if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK) return -1; bzstream.next_in = data; bzstream.avail_in = [[comesuse]]; do { [[sqkabusshrink]] *= 3; pkt_data = av_realloc(pkt_data, [[sqkabusshrink]]); bzstream.avail_out = [[sqkabusshrink]] - bzstream.total_out_lo32; bzstream.next_out = pkt_data + bzstream.total_out_lo32; [[production]] = BZ2_bzDecompress(&bzstream); } while ([[production]]==BZ_OK && [[sqkabusshrink]]<10000000); [[sqkabusshrink]] = bzstream.total_out_lo32; BZ2_bzDecompressEnd(&bzstream); if ([[production]] != BZ_STREAM_END) goto failed; break; } #endif default: return -1; } *buf = pkt_data; *buf_size = [[sqkabusshrink]]; return 0; failed: av_free(pkt_data); return -1; }
--------------------------------------------- Result 506 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 263 / 61 / 182 / 506:  19%|█▉        | 506/2690 [1:18:39<5:39:30,  9.33s/it][Succeeded / Failed / Skipped / Total] 263 / 61 / 182 / 506:  19%|█▉        | 507/2690 [1:18:39<5:38:42,  9.31s/it][Succeeded / Failed / Skipped / Total] 263 / 61 / 183 / 507:  19%|█▉        | 507/2690 [1:18:39<5:38:42,  9.31s/it][Succeeded / Failed / Skipped / Total] 263 / 61 / 183 / 507:  19%|█▉        | 508/2690 [1:18:40<5:37:56,  9.29s/it][Succeeded / Failed / Skipped / Total] 264 / 61 / 183 / 508:  19%|█▉        | 508/2690 [1:18:40<5:37:56,  9.29s/it][Succeeded / Failed / Skipped / Total] 264 / 61 / 183 / 508:  19%|█▉        | 509/2690 [1:18:41<5:37:09,  9.28s/it][Succeeded / Failed / Skipped / Total] 264 / 61 / 184 / 509:  19%|█▉        | 509/2690 [1:18:41<5:37:09,  9.28s/it][Succeeded / Failed / Skipped / Total] 264 / 61 / 184 / 509:  19%|█▉        | 510/2690 [1:18:41<5:36:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 264 / 61 / 185 / 510:  19%|█▉        | 510/2690 [1:18:41<5:36:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 264 / 61 / 185 / 510:  19%|█▉        | 511/2690 [1:19:03<5:37:06,  9.28s/it][[0 (32%)]] --> [[0 (99%)]] --> Socre: 0.9926859140396118

[[[[Adv]]]]: static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action) { struct hp_log_full *new_hp; struct rtas_error_log *hdr; struct rtas_event_log_v6 *[[v6hdr]]; struct rtas_event_log_v6_maina *maina; struct rtas_event_log_v6_mainb *mainb; struct rtas_event_log_v6_hp *hp; sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc); sPAPRDRConnectorType drc_type = drck->get_type(drc); new_hp = g_malloc0(sizeof(struct hp_log_full)); hdr = &new_hp->hdr; [[v6hdr]] = &new_hp->v6hdr; maina = &new_hp->maina; mainb = &new_hp->mainb; hp = &new_hp->hp; hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 | RTAS_LOG_SEVERITY_EVENT | RTAS_LOG_DISPOSITION_NOT_RECOVERED | RTAS_LOG_OPTIONAL_PART_PRESENT | RTAS_LOG_INITIATOR_HOTPLUG | RTAS_LOG_TYPE_HOTPLUG); hdr->extended_length = cpu_to_be32(sizeof(*new_hp) - sizeof(new_hp->hdr)); spapr_init_v6hdr([[v6hdr]]); spapr_init_maina(maina, 3 ); mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB); mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb)); mainb->subsystem_id = 0x80; mainb->event_severity = 0x00; mainb->event_subtype = 0x00; hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG); hp->hdr.section_length = cpu_to_be16(sizeof(*hp)); hp->hdr.section_version = 1; hp->hotplug_action = hp_action; switch (drc_type) { case SPAPR_DR_CONNECTOR_TYPE_PCI: hp->drc.index = cpu_to_be32(drck->get_index(drc)); hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX; hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; break; default: g_assert("False" != "False"); return; } rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp); qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq)); }

[[[[Adv]]]]: static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action) { struct hp_log_full *new_hp; struct rtas_error_log *hdr; struct rtas_event_log_v6 *[[вdd]]; struct rtas_event_log_v6_maina *maina; struct rtas_event_log_v6_mainb *mainb; struct rtas_event_log_v6_hp *hp; sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc); sPAPRDRConnectorType drc_type = drck->get_type(drc); new_hp = g_malloc0(sizeof(struct hp_log_full)); hdr = &new_hp->hdr; [[вdd]] = &new_hp->v6hdr; maina = &new_hp->maina; mainb = &new_hp->mainb; hp = &new_hp->hp; hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 | RTAS_LOG_SEVERITY_EVENT | RTAS_LOG_DISPOSITION_NOT_RECOVERED | RTAS_LOG_OPTIONAL_PART_PRESENT | RTAS_LOG_INITIATOR_HOTPLUG | RTAS_LOG_TYPE_HOTPLUG); hdr->extended_length = cpu_to_be32(sizeof(*new_hp) - sizeof(new_hp->hdr)); spapr_init_v6hdr([[вdd]]); spapr_init_maina(maina, 3 ); mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB); mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb)); mainb->subsystem_id = 0x80; mainb->event_severity = 0x00; mainb->event_subtype = 0x00; hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG); hp->hdr.section_length = cpu_to_be16(sizeof(*hp)); hp->hdr.section_version = 1; hp->hotplug_action = hp_action; switch (drc_type) { case SPAPR_DR_CONNECTOR_TYPE_PCI: hp->drc.index = cpu_to_be32(drck->get_index(drc)); hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX; hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; break; default: g_assert("False" != "False"); return; } rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp); qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq)); }
--------------------------------------------- Result 507 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: SwsFunc yuv2rgb_get_func_ptr (SwsContext *c) { #if defined(HAVE_MMX2) || defined(HAVE_MMX) if(c->flags & SWS_CPU_CAPS_MMX2){ switch(c->dstFormat){ case PIX_FMT_RGB32: return yuv420_rgb32_MMX2; case PIX_FMT_BGR24: return yuv420_rgb24_MMX2; case PIX_FMT_BGR565: return yuv420_rgb16_MMX2; case PIX_FMT_BGR555: return yuv420_rgb15_MMX2; } } if(c->flags & SWS_CPU_CAPS_MMX){ switch(c->dstFormat){ case PIX_FMT_RGB32: return yuv420_rgb32_MMX; case PIX_FMT_BGR24: return yuv420_rgb24_MMX; case PIX_FMT_BGR565: return yuv420_rgb16_MMX; case PIX_FMT_BGR555: return yuv420_rgb15_MMX; } } #endif #ifdef HAVE_MLIB { SwsFunc t= yuv2rgb_init_mlib(c); if(t) return t; } #endif #ifdef HAVE_ALTIVEC if (c->flags & SWS_CPU_CAPS_ALTIVEC) { SwsFunc t = yuv2rgb_init_altivec(c); if(t) return t; } #endif av_log(c, AV_LOG_WARNING, "No accelerated colorspace conversion found\n"); switch(c->dstFormat){ case PIX_FMT_BGR32: case PIX_FMT_RGB32: return yuv2rgb_c_32; case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb; case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr; case PIX_FMT_RGB565: case PIX_FMT_BGR565: case PIX_FMT_RGB555: case PIX_FMT_BGR555: return yuv2rgb_c_16; case PIX_FMT_RGB8: case PIX_FMT_BGR8: return yuv2rgb_c_8_ordered_dither; case PIX_FMT_RGB4: case PIX_FMT_BGR4: return yuv2rgb_c_4_ordered_dither; case PIX_FMT_RGB4_BYTE: case PIX_FMT_BGR4_BYTE: return yuv2rgb_c_4b_ordered_dither; case PIX_FMT_MONOBLACK: return yuv2rgb_c_1_ordered_dither; default: assert(0); } return NULL; }
--------------------------------------------- Result 508 ---------------------------------------------
[[0 (3%)]] --> [[0 (99%)]] --> Socre: 0.9949439167976379

[[[[Adv]]]]: static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg [[addr]], int mem_index, TCGMemOp s_bits, int which) { const TCGReg r0 = TCG_REG_O0; const TCGReg r1 = TCG_REG_O1; const TCGReg r2 = TCG_REG_O2; int tlb_ofs; tcg_out_arithi(s, r1, [[addr]], TARGET_PAGE_BITS, SHIFT_SRL); tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1, TARGET_PAGE_MASK | ((1 << s_bits) - 1)); tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND); tcg_out_arith(s, r0, [[addr]], TCG_REG_T1, ARITH_AND); tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL); tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD); tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]); if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) { tcg_out_addi(s, r1, tlb_ofs & ~0x3ff); tlb_ofs &= 0x3ff; } tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which); tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend)); tcg_out_cmp(s, r0, r2, 0); if (SPARC64 && TARGET_LONG_BITS == 32) { tcg_out_arithi(s, r0, [[addr]], 0, SHIFT_SRL); return r0; } return [[addr]]; }

[[[[Adv]]]]: static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg [[schedulerr]], int mem_index, TCGMemOp s_bits, int which) { const TCGReg r0 = TCG_REG_O0; const TCGReg r1 = TCG_REG_O1; const TCGReg r2 = TCG_REG_O2; int tlb_ofs; tcg_out_arithi(s, r1, [[schedulerr]], TARGET_PAGE_BITS, SHIFT_SRL); tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1, TARGET_PAGE_MASK | ((1 << s_bits) - 1)); tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND); tcg_out_arith(s, r0, [[schedulerr]], TCG_REG_T1, ARITH_AND); tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL); tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD); tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]); if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) { tcg_out_addi(s, r1, tlb_ofs & ~0x3ff); tlb_ofs &= 0x3ff; } tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which); tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend)); tcg_out_cmp(s, r0, r2, 0); if (SPARC64 && TARGET_LONG_BITS == 32) { tcg_out_arithi(s, r0, [[schedulerr]], 0, SHIFT_SRL); return r0; } return [[schedulerr]]; }
--------------------------------------------- Result 509 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size) { uint32_t scratch = 0; const uint8_t *buf_end = buf + buf_size; for (; buf < buf_end - 3; buf += 4) scratch ^= *((const uint32_t*)buf); scratch = xor_32_to_8(scratch); for (; buf < buf_end; buf++) return scratch; }
--------------------------------------------- Result 510 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_er_frame_start(ERContext *s) { if (!s->avctx->err_recognition) return; memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END, s->mb_stride * s->mb_height * sizeof(uint8_t)); s->error_count = 3 * s->mb_num; s->error_occurred = 0; }
--------------------------------------------- Result 511 ---------------------------------------------
[[0 (41%)]] --> [[0 (91%)]] --> Socre: 0.9058053493499756

[[[[Adv]]]]: av_cold int MPV_common_init(MpegEncContext *s) { int [[y_size]], c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads; if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence) s->mb_height = (s->height + 31) / 32 * 2; else if (s->codec_id != CODEC_ID_H264) s->mb_height = (s->height + 15) / 16; if(s->avctx->pix_fmt == PIX_FMT_NONE){ av_log(s->avctx, AV_LOG_ERROR, "decoding to PIX_FMT_NONE is not supported.\n"); return -1; } if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) && (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){ av_log(s->avctx, AV_LOG_ERROR, "too many threads\n"); return -1; } if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx)) return -1; dsputil_init(&s->dsp, s->avctx); ff_dct_common_init(s); s->flags= s->avctx->flags; s->flags2= s->avctx->flags2; if (s->width && s->height) { s->mb_width = (s->width + 15) / 16; s->mb_stride = s->mb_width + 1; s->b8_stride = s->mb_width*2 + 1; s->b4_stride = s->mb_width*4 + 1; mb_array_size= s->mb_height * s->mb_stride; mv_table_size= (s->mb_height+2) * s->mb_stride + 1; avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift), &(s->chroma_y_shift) ); s->h_edge_pos= s->mb_width*16; s->v_edge_pos= s->mb_height*16; s->mb_num = s->mb_width * s->mb_height; s->block_wrap[0]= s->block_wrap[1]= s->block_wrap[2]= s->block_wrap[3]= s->b8_stride; s->block_wrap[4]= s->block_wrap[5]= s->mb_stride; [[y_size]] = s->b8_stride * (2 * s->mb_height + 1); c_size = s->mb_stride * (s->mb_height + 1); yc_size = [[y_size]] + 2 * c_size; s->codec_tag = ff_toupper4(s->avctx->codec_tag); s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag); s->avctx->coded_frame= (AVFrame*)&s->current_picture; FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) for(y=0; y<s->mb_height; y++){ for(x=0; x<s->mb_width; x++){ s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride; } } s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; if (s->encoding) { FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) s->p_mv_table = s->p_mv_table_base + s->mb_stride + 1; s->b_forw_mv_table = s->b_forw_mv_table_base + s->mb_stride + 1; s->b_back_mv_table = s->b_back_mv_table_base + s->mb_stride + 1; s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1; s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1; s->b_direct_mv_table = s->b_direct_mv_table_base + s->mb_stride + 1; if(s->msmpeg4_version){ FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail); } FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type , mb_array_size * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix , 64*32 * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix , 64*32 * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail) if(s->avctx->noise_reduction){ FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail) } } } s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count); FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail) for(i = 0; i < s->picture_count; i++) { avcodec_get_frame_defaults((AVFrame *)&s->picture[i]); } if (s->width && s->height) { FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail) if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){ for(i=0; i<2; i++){ int j, k; for(j=0; j<2; j++){ for(k=0; k<2; k++){ FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail) s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1; } FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail) s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1; } FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail) } } if (s->out_format == FMT_H263) { FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, [[y_size]], fail); s->coded_block= s->coded_block_base + s->b8_stride + 1; FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table , mb_array_size * sizeof(uint8_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail) } if (s->h263_pred || s->h263_plus || !s->encoding) { FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail); s->dc_val[0] = s->dc_val_base + s->b8_stride + 1; s->dc_val[1] = s->dc_val_base + [[y_size]] + s->mb_stride + 1; s->dc_val[2] = s->dc_val[1] + c_size; for(i=0;i<yc_size;i++) s->dc_val_base[i] = 1024; } FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail); memset(s->mbintra_table, 1, mb_array_size); FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail); s->parse_context.state= -1; if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){ s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); } } s->context_initialized = 1; s->thread_context[0]= s; if (s->width && s->height) { if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) { threads = s->avctx->thread_count; for(i=1; i<threads; i++){ s->thread_context[i]= av_malloc(sizeof(MpegEncContext)); memcpy(s->thread_context[i], s, sizeof(MpegEncContext)); } for(i=0; i<threads; i++){ if(init_duplicate_context(s->thread_context[i], s) < 0) goto fail; s->thread_context[i]->start_mb_y= (s->mb_height*(i ) + s->avctx->thread_count/2) / s->avctx->thread_count; s->thread_context[i]->end_mb_y = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count; } } else { if(init_duplicate_context(s, s) < 0) goto fail; s->start_mb_y = 0; s->end_mb_y = s->mb_height; } } return 0; fail: MPV_common_end(s); return -1; }

[[[[Adv]]]]: av_cold int MPV_common_init(MpegEncContext *s) { int [[k³rate]], c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads; if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence) s->mb_height = (s->height + 31) / 32 * 2; else if (s->codec_id != CODEC_ID_H264) s->mb_height = (s->height + 15) / 16; if(s->avctx->pix_fmt == PIX_FMT_NONE){ av_log(s->avctx, AV_LOG_ERROR, "decoding to PIX_FMT_NONE is not supported.\n"); return -1; } if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) && (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){ av_log(s->avctx, AV_LOG_ERROR, "too many threads\n"); return -1; } if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx)) return -1; dsputil_init(&s->dsp, s->avctx); ff_dct_common_init(s); s->flags= s->avctx->flags; s->flags2= s->avctx->flags2; if (s->width && s->height) { s->mb_width = (s->width + 15) / 16; s->mb_stride = s->mb_width + 1; s->b8_stride = s->mb_width*2 + 1; s->b4_stride = s->mb_width*4 + 1; mb_array_size= s->mb_height * s->mb_stride; mv_table_size= (s->mb_height+2) * s->mb_stride + 1; avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift), &(s->chroma_y_shift) ); s->h_edge_pos= s->mb_width*16; s->v_edge_pos= s->mb_height*16; s->mb_num = s->mb_width * s->mb_height; s->block_wrap[0]= s->block_wrap[1]= s->block_wrap[2]= s->block_wrap[3]= s->b8_stride; s->block_wrap[4]= s->block_wrap[5]= s->mb_stride; [[k³rate]] = s->b8_stride * (2 * s->mb_height + 1); c_size = s->mb_stride * (s->mb_height + 1); yc_size = [[k³rate]] + 2 * c_size; s->codec_tag = ff_toupper4(s->avctx->codec_tag); s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag); s->avctx->coded_frame= (AVFrame*)&s->current_picture; FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) for(y=0; y<s->mb_height; y++){ for(x=0; x<s->mb_width; x++){ s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride; } } s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; if (s->encoding) { FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) s->p_mv_table = s->p_mv_table_base + s->mb_stride + 1; s->b_forw_mv_table = s->b_forw_mv_table_base + s->mb_stride + 1; s->b_back_mv_table = s->b_back_mv_table_base + s->mb_stride + 1; s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1; s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1; s->b_direct_mv_table = s->b_direct_mv_table_base + s->mb_stride + 1; if(s->msmpeg4_version){ FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail); } FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type , mb_array_size * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix , 64*32 * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix , 64*32 * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail) if(s->avctx->noise_reduction){ FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail) } } } s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count); FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail) for(i = 0; i < s->picture_count; i++) { avcodec_get_frame_defaults((AVFrame *)&s->picture[i]); } if (s->width && s->height) { FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail) if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){ for(i=0; i<2; i++){ int j, k; for(j=0; j<2; j++){ for(k=0; k<2; k++){ FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail) s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1; } FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail) s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1; } FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail) } } if (s->out_format == FMT_H263) { FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, [[k³rate]], fail); s->coded_block= s->coded_block_base + s->b8_stride + 1; FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table , mb_array_size * sizeof(uint8_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail) } if (s->h263_pred || s->h263_plus || !s->encoding) { FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail); s->dc_val[0] = s->dc_val_base + s->b8_stride + 1; s->dc_val[1] = s->dc_val_base + [[k³rate]] + s->mb_stride + 1; s->dc_val[2] = s->dc_val[1] + c_size; for(i=0;i<yc_size;i++) s->dc_val_base[i] = 1024; } FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail); memset(s->mbintra_table, 1, mb_array_size); FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail); s->parse_context.state= -1; if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){ s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); } } s->context_initialized = 1; s->thread_context[0]= s; if (s->width && s->height) { if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) { threads = s->avctx->thread_count; for(i=1; i<threads; i++){ s->thread_context[i]= av_malloc(sizeof(MpegEncContext)); memcpy(s->thread_context[i], s, sizeof(MpegEncContext)); } for(i=0; i<threads; i++){ if(init_duplicate_context(s->thread_context[i], s) < 0) goto fail; s->thread_context[i]->start_mb_y= (s->mb_height*(i ) + s->avctx->thread_count/2) / s->avctx->thread_count; s->thread_context[i]->end_mb_y = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count; } } else { if(init_duplicate_context(s, s) < 0) goto fail; s->start_mb_y = 0; s->end_mb_y = s->mb_height; } } return 0; fail: MPV_common_end(s); return -1; }[Succeeded / Failed / Skipped / Total] 265 / 61 / 185 / 511:  19%|█▉        | 511/2690 [1:19:03<5:37:06,  9.28s/it][Succeeded / Failed / Skipped / Total] 265 / 61 / 185 / 511:  19%|█▉        | 512/2690 [1:19:03<5:36:19,  9.27s/it][Succeeded / Failed / Skipped / Total] 266 / 61 / 185 / 512:  19%|█▉        | 512/2690 [1:19:03<5:36:19,  9.27s/it][Succeeded / Failed / Skipped / Total] 266 / 61 / 186 / 513:  19%|█▉        | 513/2690 [1:19:03<5:35:31,  9.25s/it][Succeeded / Failed / Skipped / Total] 266 / 61 / 186 / 513:  19%|█▉        | 514/2690 [1:19:14<5:35:26,  9.25s/it][Succeeded / Failed / Skipped / Total] 267 / 61 / 186 / 514:  19%|█▉        | 514/2690 [1:19:14<5:35:26,  9.25s/it][Succeeded / Failed / Skipped / Total] 267 / 61 / 186 / 514:  19%|█▉        | 515/2690 [1:19:14<5:34:39,  9.23s/it][Succeeded / Failed / Skipped / Total] 267 / 61 / 187 / 515:  19%|█▉        | 515/2690 [1:19:14<5:34:39,  9.23s/it][Succeeded / Failed / Skipped / Total] 267 / 61 / 187 / 515:  19%|█▉        | 516/2690 [1:19:35<5:35:20,  9.26s/it][Succeeded / Failed / Skipped / Total] 268 / 61 / 187 / 516:  19%|█▉        | 516/2690 [1:19:35<5:35:20,  9.26s/it][Succeeded / Failed / Skipped / Total] 268 / 61 / 187 / 516:  19%|█▉        | 517/2690 [1:19:36<5:34:34,  9.24s/it]
--------------------------------------------- Result 512 ---------------------------------------------
[[0 (50%)]] --> [[0 (20%)]] --> Socre: 0.8047055155038834

[[[[Adv]]]]: static void vnc_set_share_mode(VncState *vs, VncShareMode mode) { #ifdef _VNC_DEBUG static const char *[[mn]][] = { [0] = "undefined", [VNC_SHARE_MODE_CONNECTING] = "connecting", [VNC_SHARE_MODE_SHARED] = "shared", [VNC_SHARE_MODE_EXCLUSIVE] = "exclusive", [VNC_SHARE_MODE_DISCONNECTED] = "disconnected", }; fprintf(stderr, "%s/%d: %s -> %s\n", __func__, vs->csock, [[mn]][vs->share_mode], [[mn]][mode]); #endif if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) { vs->vd->num_exclusive--; } vs->share_mode = mode; if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) { vs->vd->num_exclusive++; } }

[[[[Adv]]]]: static void vnc_set_share_mode(VncState *vs, VncShareMode mode) { #ifdef _VNC_DEBUG static const char *[[product]][] = { [0] = "undefined", [VNC_SHARE_MODE_CONNECTING] = "connecting", [VNC_SHARE_MODE_SHARED] = "shared", [VNC_SHARE_MODE_EXCLUSIVE] = "exclusive", [VNC_SHARE_MODE_DISCONNECTED] = "disconnected", }; fprintf(stderr, "%s/%d: %s -> %s\n", __func__, vs->csock, [[product]][vs->share_mode], [[product]][mode]); #endif if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) { vs->vd->num_exclusive--; } vs->share_mode = mode; if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) { vs->vd->num_exclusive++; } }
--------------------------------------------- Result 513 ---------------------------------------------
[[0 (90%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size) { AVProbeData pd = { filename ? filename : "", NULL, -offset }; unsigned char *buf = NULL; int ret = 0, probe_size; if (!max_probe_size) { max_probe_size = PROBE_BUF_MAX; } else if (max_probe_size > PROBE_BUF_MAX) { max_probe_size = PROBE_BUF_MAX; } else if (max_probe_size < PROBE_BUF_MIN) { return AVERROR(EINVAL); } if (offset >= max_probe_size) { return AVERROR(EINVAL); } for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt; probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) { int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0; int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1; void *buftmp; if (probe_size < offset) { continue; } buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE); if(!buftmp){ av_free(buf); return AVERROR(ENOMEM); } buf=buftmp; if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) { if (ret != AVERROR_EOF) { av_free(buf); return ret; } score = 0; ret = 0; } pd.buf_size += ret; pd.buf = &buf[offset]; memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE); *fmt = av_probe_input_format2(&pd, 1, &score); if(*fmt){ if(score <= AVPROBE_SCORE_RETRY){ av_log(logctx, AV_LOG_WARNING, "Format %s detected only with low score of %d, misdetection possible!\n", (*fmt)->name, score); }else av_log(logctx, AV_LOG_DEBUG, "Format %s probed with size=%d and score=%d\n", (*fmt)->name, probe_size, score); } } if (!*fmt) { av_free(buf); return AVERROR_INVALIDDATA; } ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size); return ret; }
--------------------------------------------- Result 514 ---------------------------------------------
[[0 (20%)]] --> [[0 (53%)]] --> Socre: 0.5317684412002563

[[[[Adv]]]]: static int curl_sock_cb(CURL *curl, curl_socket_t fd, int [[action]], void *[[s]], void *sp) { DPRINTF("CURL (AIO): Sock action %d on fd %d\n", [[action]], fd); switch ([[action]]) { case CURL_POLL_IN: qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, [[s]]); break; case CURL_POLL_OUT: qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, [[s]]); break; case CURL_POLL_INOUT: qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, [[s]]); break; case CURL_POLL_REMOVE: qemu_aio_set_fd_handler(fd, NULL, NULL, NULL); break; } return 0; }

[[[[Adv]]]]: static int curl_sock_cb(CURL *curl, curl_socket_t fd, int [[error]], void *[[art]], void *sp) { DPRINTF("CURL (AIO): Sock action %d on fd %d\n", [[error]], fd); switch ([[error]]) { case CURL_POLL_IN: qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, [[art]]); break; case CURL_POLL_OUT: qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, [[art]]); break; case CURL_POLL_INOUT: qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, [[art]]); break; case CURL_POLL_REMOVE: qemu_aio_set_fd_handler(fd, NULL, NULL, NULL); break; } return 0; }
--------------------------------------------- Result 515 ---------------------------------------------
[[0 (55%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg, const uint32_t *intbit_to_level, qemu_irq **irq, qemu_irq **cpu_irq, unsigned int cputimer) { int slavio_intctl_io_memory, slavio_intctlm_io_memory, i; SLAVIO_INTCTLState *s; s = qemu_mallocz(sizeof(SLAVIO_INTCTLState)); if (!s) return NULL; s->intbit_to_level = intbit_to_level; for (i = 0; i < MAX_CPUS; i++) { slavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s); cpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE, slavio_intctl_io_memory); } slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s); cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory); register_savevm("slavio_intctl", addr, 1, slavio_intctl_save, slavio_intctl_load, s); qemu_register_reset(slavio_intctl_reset, s); *irq = qemu_allocate_irqs(slavio_set_irq, s, 32); *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS); s->cputimer_bit = 1 << s->intbit_to_level[cputimer]; slavio_intctl_reset(s); return s; }
--------------------------------------------- Result 516 ---------------------------------------------
[[0 (32%)]] --> [[0 (53%)]] --> Socre: 0.5333781242370605

[[[[Adv]]]]: static void start_children(FFStream *feed) { if (no_launch) return; for (; feed; feed = feed->next) { if (feed->child_argv && !feed->pid) { feed->pid_start = time(0); feed->pid = fork(); if (feed->pid < 0) { http_log("Unable to create children\n"); exit(1); } if (!feed->pid) { char pathname[1024]; char *slash; int [[i]]; av_strlcpy(pathname, my_program_name, sizeof(pathname)); slash = strrchr(pathname, '/'); if (!slash) slash = pathname; else slash++; strcpy(slash, "ffmpeg"); http_log("Launch command line: "); http_log("%s ", pathname); for ([[i]] = 1; feed->child_argv[[[i]]] && feed->child_argv[[[i]]][0]; [[i]]++) http_log("%s ", feed->child_argv[[[i]]]); http_log("\n"); for ([[i]] = 3; [[i]] < 256; [[i]]++) close([[i]]); if (!ffserver_debug) { [[i]] = open("/dev/null", O_RDWR); if ([[i]] != -1) { dup2([[i]], 0); dup2([[i]], 1); dup2([[i]], 2); close([[i]]); } } chdir(my_program_dir); signal(SIGPIPE, SIG_DFL); execvp(pathname, feed->child_argv); _exit(1); } } } }

[[[[Adv]]]]: static void start_children(FFStream *feed) { if (no_launch) return; for (; feed; feed = feed->next) { if (feed->child_argv && !feed->pid) { feed->pid_start = time(0); feed->pid = fork(); if (feed->pid < 0) { http_log("Unable to create children\n"); exit(1); } if (!feed->pid) { char pathname[1024]; char *slash; int [[ia]]; av_strlcpy(pathname, my_program_name, sizeof(pathname)); slash = strrchr(pathname, '/'); if (!slash) slash = pathname; else slash++; strcpy(slash, "ffmpeg"); http_log("Launch command line: "); http_log("%s ", pathname); for ([[ia]] = 1; feed->child_argv[[[ia]]] && feed->child_argv[[[ia]]][0]; [[ia]]++) http_log("%s ", feed->child_argv[[[ia]]]); http_log("\n"); for ([[ia]] = 3; [[ia]] < 256; [[ia]]++) close([[ia]]); if (!ffserver_debug) { [[ia]] = open("/dev/null", O_RDWR); if ([[ia]] != -1) { dup2([[ia]], 0); dup2([[ia]], 1); dup2([[ia]], 2); close([[ia]]); } } chdir(my_program_dir); signal(SIGPIPE, SIG_DFL); execvp(pathname, feed->child_argv); _exit(1); } } } }
--------------------------------------------- Result 517 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 268 / 61 / 188 / 517:  19%|█▉        | 517/2690 [1:19:36<5:34:34,  9.24s/it][Succeeded / Failed / Skipped / Total] 268 / 61 / 188 / 517:  19%|█▉        | 518/2690 [1:19:40<5:34:05,  9.23s/it][Succeeded / Failed / Skipped / Total] 269 / 61 / 188 / 518:  19%|█▉        | 518/2690 [1:19:40<5:34:05,  9.23s/it][Succeeded / Failed / Skipped / Total] 269 / 61 / 188 / 518:  19%|█▉        | 519/2690 [1:19:57<5:34:29,  9.24s/it][Succeeded / Failed / Skipped / Total] 270 / 61 / 188 / 519:  19%|█▉        | 519/2690 [1:19:57<5:34:29,  9.24s/it][Succeeded / Failed / Skipped / Total] 270 / 61 / 188 / 519:  19%|█▉        | 520/2690 [1:19:58<5:33:43,  9.23s/it][Succeeded / Failed / Skipped / Total] 270 / 61 / 189 / 520:  19%|█▉        | 520/2690 [1:19:58<5:33:43,  9.23s/it][Succeeded / Failed / Skipped / Total] 270 / 61 / 189 / 520:  19%|█▉        | 521/2690 [1:20:21<5:34:33,  9.25s/it][Succeeded / Failed / Skipped / Total] 271 / 61 / 189 / 521:  19%|█▉        | 521/2690 [1:20:21<5:34:33,  9.25s/it][Succeeded / Failed / Skipped / Total] 271 / 61 / 189 / 521:  19%|█▉        | 522/2690 [1:20:40<5:35:05,  9.27s/it][[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp) { MOVContext *mov = s->priv_data; int i, j; if (!mov->fragment_index_complete) return 0; for (i = 0; i < mov->fragment_index_count; i++) { if (mov->fragment_index_data[i]->track_id == st->id) { MOVFragmentIndex *index = index = mov->fragment_index_data[i]; for (j = index->item_count - 1; j >= 0; j--) { if (index->items[j].time <= timestamp) { if (index->items[j].headers_read) return 0; return mov_switch_root(s, index->items[j].moof_offset); } } } } return 0; }
--------------------------------------------- Result 518 ---------------------------------------------
[[0 (69%)]] --> [[0 (35%)]] --> Socre: 0.6528938114643097

[[[[Adv]]]]: static void slirp_smb(SlirpState* s, Monitor *[[mon]], const char *exported_dir, struct in_addr [[vserver_addr]]) { static int instance; char smb_conf[128]; char smb_cmdline[128]; FILE *f; snprintf(s->smb_dir, sizeof(s->smb_dir), "/tmp/qemu-smb.%ld-%d", (long)getpid(), instance++); if (mkdir(s->smb_dir, 0700) < 0) { config_error([[mon]], "could not create samba server dir '%s'\n", s->smb_dir); return; } snprintf(smb_conf, sizeof(smb_conf), "%s/%s", s->smb_dir, "smb.conf"); f = fopen(smb_conf, "w"); if (!f) { slirp_smb_cleanup(s); config_error([[mon]], "could not create samba server " "configuration file '%s'\n", smb_conf); return; } fprintf(f, "[global]\n" "private dir=%s\n" "smb ports=0\n" "socket address=127.0.0.1\n" "pid directory=%s\n" "lock directory=%s\n" "log file=%s/log.smbd\n" "smb passwd file=%s/smbpasswd\n" "security = share\n" "[qemu]\n" "path=%s\n" "read only=no\n" "guest ok=yes\n", s->smb_dir, s->smb_dir, s->smb_dir, s->smb_dir, s->smb_dir, exported_dir ); fclose(f); snprintf(smb_cmdline, sizeof(smb_cmdline), "%s -s %s", SMBD_COMMAND, smb_conf); if (slirp_add_exec(s->slirp, 0, smb_cmdline, &[[vserver_addr]], 139) < 0) { slirp_smb_cleanup(s); config_error([[mon]], "conflicting/invalid smbserver address\n"); } }

[[[[Adv]]]]: static void slirp_smb(SlirpState* s, Monitor *[[star]], const char *exported_dir, struct in_addr [[stelfmodhaveр]]) { static int instance; char smb_conf[128]; char smb_cmdline[128]; FILE *f; snprintf(s->smb_dir, sizeof(s->smb_dir), "/tmp/qemu-smb.%ld-%d", (long)getpid(), instance++); if (mkdir(s->smb_dir, 0700) < 0) { config_error([[star]], "could not create samba server dir '%s'\n", s->smb_dir); return; } snprintf(smb_conf, sizeof(smb_conf), "%s/%s", s->smb_dir, "smb.conf"); f = fopen(smb_conf, "w"); if (!f) { slirp_smb_cleanup(s); config_error([[star]], "could not create samba server " "configuration file '%s'\n", smb_conf); return; } fprintf(f, "[global]\n" "private dir=%s\n" "smb ports=0\n" "socket address=127.0.0.1\n" "pid directory=%s\n" "lock directory=%s\n" "log file=%s/log.smbd\n" "smb passwd file=%s/smbpasswd\n" "security = share\n" "[qemu]\n" "path=%s\n" "read only=no\n" "guest ok=yes\n", s->smb_dir, s->smb_dir, s->smb_dir, s->smb_dir, s->smb_dir, exported_dir ); fclose(f); snprintf(smb_cmdline, sizeof(smb_cmdline), "%s -s %s", SMBD_COMMAND, smb_conf); if (slirp_add_exec(s->slirp, 0, smb_cmdline, &[[stelfmodhaveр]], 139) < 0) { slirp_smb_cleanup(s); config_error([[star]], "conflicting/invalid smbserver address\n"); } }
--------------------------------------------- Result 519 ---------------------------------------------
[[0 (80%)]] --> [[0 (31%)]] --> Socre: 0.6875384151935577

[[[[Adv]]]]: static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int [[tag]]) { switch([[tag]]) { case 0x4801: track->track_id = get_be32(pb); break; case 0x4804: get_buffer(pb, track->track_number, 4); break; case 0x4B01: track->edit_rate.den = get_be32(pb); track->edit_rate.num = get_be32(pb); break; case 0x4803: get_buffer(pb, track->sequence_ref, 16); break; } return 0; }

[[[[Adv]]]]: static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int [[identification]]) { switch([[identification]]) { case 0x4801: track->track_id = get_be32(pb); break; case 0x4804: get_buffer(pb, track->track_number, 4); break; case 0x4B01: track->edit_rate.den = get_be32(pb); track->edit_rate.num = get_be32(pb); break; case 0x4803: get_buffer(pb, track->sequence_ref, 16); break; } return 0; }
--------------------------------------------- Result 520 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame, int buf_size, void *data) { static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4}; static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2}; RA144Context *ractx; PutBitContext pb; int32_t lpc_data[NBLOCKS * BLOCKSIZE]; int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER]; int shift[LPC_ORDER]; int16_t block_coefs[NBLOCKS][LPC_ORDER]; int lpc_refl[LPC_ORDER]; unsigned int refl_rms[NBLOCKS]; int energy = 0; int i, idx; if (buf_size < FRAMESIZE) { av_log(avctx, AV_LOG_ERROR, "output buffer too small\n"); return 0; } ractx = avctx->priv_data; for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) { lpc_data[i] = ractx->curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i]; energy += (lpc_data[i] * lpc_data[i]) >> 4; } for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) { lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >> 2; energy += (lpc_data[i] * lpc_data[i]) >> 4; } energy = ff_energy_tab[quantize(ff_t_sqrt(energy >> 5) >> 10, ff_energy_tab, 32)]; ff_lpc_calc_coefs(&ractx->lpc_ctx, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER, LPC_ORDER, 16, lpc_coefs, shift, FF_LPC_TYPE_LEVINSON, 0, ORDER_METHOD_EST, 12, 0); for (i = 0; i < LPC_ORDER; i++) block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] << (12 - shift[LPC_ORDER - 1])); if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) { ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]); ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx); } init_put_bits(&pb, frame, buf_size); for (i = 0; i < LPC_ORDER; i++) { idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]); put_bits(&pb, bit_sizes[i], idx); lpc_refl[i] = ff_lpc_refl_cb[i][idx]; } ractx->lpc_refl_rms[0] = ff_rms(lpc_refl); ff_eval_coefs(ractx->lpc_coef[0], lpc_refl); refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy); refl_rms[1] = ff_interp(ractx, block_coefs[1], 2, energy <= ractx->old_energy, ff_t_sqrt(energy * ractx->old_energy) >> 12); refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy); refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy); ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]); put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32)); for (i = 0; i < NBLOCKS; i++) ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE, block_coefs[i], refl_rms[i], &pb); flush_put_bits(&pb); ractx->old_energy = energy; ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0]; FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]); for (i = 0; i < NBLOCKS * BLOCKSIZE; i++) ractx->curr_block[i] = *((int16_t *)data + i) >> 2; return FRAMESIZE; }
--------------------------------------------- Result 521 ---------------------------------------------
[[0 (28%)]] --> [[0 (99%)]] --> Socre: 0.9893174767494202

[[[[Adv]]]]: static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq) { int [[t]] = rc->range * (uint64_t)cumFreq / total_freq; rc->code1 += [[t]] + 1; rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - ([[t]] + 1); while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) { unsigned byte = bytestream2_get_byte(gb); rc->code = (rc->code << 8) | byte; rc->code1 <<= 8; rc->range <<= 8; } }

[[[[Adv]]]]: static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq) { int [[т]] = rc->range * (uint64_t)cumFreq / total_freq; rc->code1 += [[т]] + 1; rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - ([[т]] + 1); while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) { unsigned byte = bytestream2_get_byte(gb); rc->code = (rc->code << 8) | byte; rc->code1 <<= 8; rc->range <<= 8; } }
[Succeeded / Failed / Skipped / Total] 271 / 62 / 189 / 522:  19%|█▉        | 522/2690 [1:20:40<5:35:05,  9.27s/it][Succeeded / Failed / Skipped / Total] 271 / 62 / 189 / 522:  19%|█▉        | 523/2690 [1:20:41<5:34:20,  9.26s/it][Succeeded / Failed / Skipped / Total] 271 / 62 / 190 / 523:  19%|█▉        | 523/2690 [1:20:41<5:34:20,  9.26s/it][Succeeded / Failed / Skipped / Total] 271 / 62 / 190 / 523:  19%|█▉        | 524/2690 [1:21:01<5:34:56,  9.28s/it][Succeeded / Failed / Skipped / Total] 272 / 62 / 190 / 524:  19%|█▉        | 524/2690 [1:21:01<5:34:56,  9.28s/it][Succeeded / Failed / Skipped / Total] 272 / 62 / 190 / 524:  20%|█▉        | 525/2690 [1:21:02<5:34:10,  9.26s/it][Succeeded / Failed / Skipped / Total] 272 / 62 / 191 / 525:  20%|█▉        | 525/2690 [1:21:02<5:34:10,  9.26s/it][Succeeded / Failed / Skipped / Total] 272 / 62 / 191 / 525:  20%|█▉        | 526/2690 [1:21:05<5:33:36,  9.25s/it]--------------------------------------------- Result 522 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void tlb_set_page(CPUState *env, target_ulong vaddr, target_phys_addr_t [[paddr]], int prot, int [[mmu_idx]], target_ulong size) { PhysPageDesc *p; unsigned long [[pd]]; unsigned int index; target_ulong [[address]]; target_ulong code_address; unsigned long [[addend]]; CPUTLBEntry *te; CPUWatchpoint *wp; target_phys_addr_t iotlb; assert(size >= TARGET_PAGE_SIZE); if (size != TARGET_PAGE_SIZE) { tlb_add_large_page(env, vaddr, size); } p = phys_page_find([[paddr]] >> TARGET_PAGE_BITS); if (!p) { [[pd]] = IO_MEM_UNASSIGNED; } else { [[pd]] = p->phys_offset; } #if defined(DEBUG_TLB) printf("tlb_set_page: vaddr=" TARGET_FMT_lx " paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n", vaddr, (int)[[paddr]], prot, [[mmu_idx]], is_softmmu, [[pd]]); #endif [[address]] = vaddr; if (([[pd]] & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !([[pd]] & IO_MEM_ROMD)) { [[address]] |= TLB_MMIO; } [[addend]] = (unsigned long)qemu_get_ram_ptr([[pd]] & TARGET_PAGE_MASK); if (([[pd]] & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) { iotlb = [[pd]] & TARGET_PAGE_MASK; if (([[pd]] & ~TARGET_PAGE_MASK) == IO_MEM_RAM) iotlb |= IO_MEM_NOTDIRTY; else iotlb |= IO_MEM_ROM; } else { iotlb = ([[pd]] & ~TARGET_PAGE_MASK); if (p) { iotlb += p->region_offset; } else { iotlb += [[paddr]]; } } code_address = [[address]]; QTAILQ_FOREACH(wp, &env->watchpoints, entry) { if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) { iotlb = io_mem_watch + [[paddr]]; [[address]] |= TLB_MMIO; } } index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1); env->iotlb[[[mmu_idx]]][index] = iotlb - vaddr; te = &env->tlb_table[[[mmu_idx]]][index]; te->addend = [[addend]] - vaddr; if (prot & PAGE_READ) { te->addr_read = [[address]]; } else { te->addr_read = -1; } if (prot & PAGE_EXEC) { te->addr_code = code_address; } else { te->addr_code = -1; } if (prot & PAGE_WRITE) { if (([[pd]] & ~TARGET_PAGE_MASK) == IO_MEM_ROM || ([[pd]] & IO_MEM_ROMD)) { te->addr_write = [[address]] | TLB_MMIO; } else if (([[pd]] & ~TARGET_PAGE_MASK) == IO_MEM_RAM && !cpu_physical_memory_is_dirty([[pd]])) { te->addr_write = [[address]] | TLB_NOTDIRTY; } else { te->addr_write = [[address]]; } } else { te->addr_write = -1; } }

[[[[Adv]]]]: void tlb_set_page(CPUState *env, target_ulong vaddr, target_phys_addr_t [[fanд]], int prot, int [[ftuniversityoferath]], target_ulong size) { PhysPageDesc *p; unsigned long [[moment]]; unsigned int index; target_ulong [[assembly]]; target_ulong code_address; unsigned long [[asell]]; CPUTLBEntry *te; CPUWatchpoint *wp; target_phys_addr_t iotlb; assert(size >= TARGET_PAGE_SIZE); if (size != TARGET_PAGE_SIZE) { tlb_add_large_page(env, vaddr, size); } p = phys_page_find([[fanд]] >> TARGET_PAGE_BITS); if (!p) { [[moment]] = IO_MEM_UNASSIGNED; } else { [[moment]] = p->phys_offset; } #if defined(DEBUG_TLB) printf("tlb_set_page: vaddr=" TARGET_FMT_lx " paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n", vaddr, (int)[[fanд]], prot, [[ftuniversityoferath]], is_softmmu, [[moment]]); #endif [[assembly]] = vaddr; if (([[moment]] & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !([[moment]] & IO_MEM_ROMD)) { [[assembly]] |= TLB_MMIO; } [[asell]] = (unsigned long)qemu_get_ram_ptr([[moment]] & TARGET_PAGE_MASK); if (([[moment]] & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) { iotlb = [[moment]] & TARGET_PAGE_MASK; if (([[moment]] & ~TARGET_PAGE_MASK) == IO_MEM_RAM) iotlb |= IO_MEM_NOTDIRTY; else iotlb |= IO_MEM_ROM; } else { iotlb = ([[moment]] & ~TARGET_PAGE_MASK); if (p) { iotlb += p->region_offset; } else { iotlb += [[fanд]]; } } code_address = [[assembly]]; QTAILQ_FOREACH(wp, &env->watchpoints, entry) { if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) { iotlb = io_mem_watch + [[fanд]]; [[assembly]] |= TLB_MMIO; } } index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1); env->iotlb[[[ftuniversityoferath]]][index] = iotlb - vaddr; te = &env->tlb_table[[[ftuniversityoferath]]][index]; te->addend = [[asell]] - vaddr; if (prot & PAGE_READ) { te->addr_read = [[assembly]]; } else { te->addr_read = -1; } if (prot & PAGE_EXEC) { te->addr_code = code_address; } else { te->addr_code = -1; } if (prot & PAGE_WRITE) { if (([[moment]] & ~TARGET_PAGE_MASK) == IO_MEM_ROM || ([[moment]] & IO_MEM_ROMD)) { te->addr_write = [[assembly]] | TLB_MMIO; } else if (([[moment]] & ~TARGET_PAGE_MASK) == IO_MEM_RAM && !cpu_physical_memory_is_dirty([[moment]])) { te->addr_write = [[assembly]] | TLB_NOTDIRTY; } else { te->addr_write = [[assembly]]; } } else { te->addr_write = -1; } }
--------------------------------------------- Result 523 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt) { assert(pkt); return pkt->vlan_stripped; }
--------------------------------------------- Result 524 ---------------------------------------------
[[0 (62%)]] --> [[0 (14%)]] --> Socre: 0.8600645214319229

[[[[Adv]]]]: static Visitor *validate_test_init_raw(TestInputVisitorData *data, const char *json_string) { Visitor *[[v]]; data->obj = qobject_from_json(json_string); g_assert(data->obj != NULL); data->qiv = qmp_input_visitor_new_strict(data->obj); g_assert(data->qiv != NULL); [[v]] = qmp_input_get_visitor(data->qiv); g_assert([[v]] != NULL); return [[v]]; }

[[[[Adv]]]]: static Visitor *validate_test_init_raw(TestInputVisitorData *data, const char *json_string) { Visitor *[[park]]; data->obj = qobject_from_json(json_string); g_assert(data->obj != NULL); data->qiv = qmp_input_visitor_new_strict(data->obj); g_assert(data->qiv != NULL); [[park]] = qmp_input_get_visitor(data->qiv); g_assert([[park]] != NULL); return [[park]]; }
--------------------------------------------- Result 525 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int connect_namedsocket(const char *path) { int sockfd, size; struct sockaddr_un helper; sockfd = socket(AF_UNIX, SOCK_STREAM, 0); if (sockfd < 0) { fprintf(stderr, "socket %s\n", strerror(errno)); return -1; } strcpy(helper.sun_path, path); helper.sun_family = AF_UNIX; size = strlen(helper.sun_path) + sizeof(helper.sun_family); if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) { fprintf(stderr, "socket error\n"); return -1; } unlink(path); return sockfd; }
--------------------------------------------- Result 526 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 273 / 62 / 191 / 526:  20%|█▉        | 526/2690 [1:21:05<5:33:36,  9.25s/it][Succeeded / Failed / Skipped / Total] 273 / 62 / 191 / 526:  20%|█▉        | 527/2690 [1:21:30<5:34:32,  9.28s/it][Succeeded / Failed / Skipped / Total] 273 / 63 / 191 / 527:  20%|█▉        | 527/2690 [1:21:30<5:34:32,  9.28s/it][Succeeded / Failed / Skipped / Total] 273 / 63 / 191 / 527:  20%|█▉        | 528/2690 [1:21:31<5:33:48,  9.26s/it][[0 (48%)]] --> [[0 (63%)]] --> Socre: 0.6255944967269897

[[[[Adv]]]]: static int dmg_open(BlockDriverState *bs, const char *filename, int flags) { BDRVDMGState *s = bs->opaque; off_t info_begin,info_end,last_in_offset,last_out_offset; uint32_t count; uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i; int64_t offset; s->fd = open(filename, O_RDONLY | O_BINARY); if (s->fd < 0) return -errno; bs->read_only = 1; s->n_chunks = 0; s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL; offset = lseek(s->fd, -0x1d8, SEEK_END); if (offset < 0) { goto fail; } info_begin = read_off(s->fd, offset); if (info_begin == 0) { goto fail; } if (read_uint32(s->fd, info_begin) != 0x100) { goto fail; } count = read_uint32(s->fd, info_begin + 4); if (count == 0) { goto fail; } info_end = info_begin + count; offset = info_begin + 0x100; last_in_offset = last_out_offset = 0; while (offset < info_end) { uint32_t [[type]]; count = read_uint32(s->fd, offset); if(count==0) goto fail; offset += 4; [[type]] = read_uint32(s->fd, offset); if ([[type]] == 0x6d697368 && count >= 244) { int new_size, chunk_count; offset += 4; offset += 200; chunk_count = (count-204)/40; new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count); s->types = qemu_realloc(s->types, new_size/2); s->offsets = qemu_realloc(s->offsets, new_size); s->lengths = qemu_realloc(s->lengths, new_size); s->sectors = qemu_realloc(s->sectors, new_size); s->sectorcounts = qemu_realloc(s->sectorcounts, new_size); for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) { s->types[i] = read_uint32(s->fd, offset); offset += 4; if(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) { if(s->types[i]==0xffffffff) { last_in_offset = s->offsets[i-1]+s->lengths[i-1]; last_out_offset = s->sectors[i-1]+s->sectorcounts[i-1]; } chunk_count--; i--; offset += 36; continue; } offset += 4; s->sectors[i] = last_out_offset+read_off(s->fd, offset); offset += 8; s->sectorcounts[i] = read_off(s->fd, offset); offset += 8; s->offsets[i] = last_in_offset+read_off(s->fd, offset); offset += 8; s->lengths[i] = read_off(s->fd, offset); offset += 8; if(s->lengths[i]>max_compressed_size) max_compressed_size = s->lengths[i]; if(s->sectorcounts[i]>max_sectors_per_chunk) max_sectors_per_chunk = s->sectorcounts[i]; } s->n_chunks+=chunk_count; } } s->compressed_chunk = qemu_malloc(max_compressed_size+1); s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk); if(inflateInit(&s->zstream) != Z_OK) goto fail; s->current_chunk = s->n_chunks; return 0; fail: close(s->fd); return -1; }

[[[[Adv]]]]: static int dmg_open(BlockDriverState *bs, const char *filename, int flags) { BDRVDMGState *s = bs->opaque; off_t info_begin,info_end,last_in_offset,last_out_offset; uint32_t count; uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i; int64_t offset; s->fd = open(filename, O_RDONLY | O_BINARY); if (s->fd < 0) return -errno; bs->read_only = 1; s->n_chunks = 0; s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL; offset = lseek(s->fd, -0x1d8, SEEK_END); if (offset < 0) { goto fail; } info_begin = read_off(s->fd, offset); if (info_begin == 0) { goto fail; } if (read_uint32(s->fd, info_begin) != 0x100) { goto fail; } count = read_uint32(s->fd, info_begin + 4); if (count == 0) { goto fail; } info_end = info_begin + count; offset = info_begin + 0x100; last_in_offset = last_out_offset = 0; while (offset < info_end) { uint32_t [[count]]; count = read_uint32(s->fd, offset); if(count==0) goto fail; offset += 4; [[count]] = read_uint32(s->fd, offset); if ([[count]] == 0x6d697368 && count >= 244) { int new_size, chunk_count; offset += 4; offset += 200; chunk_count = (count-204)/40; new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count); s->types = qemu_realloc(s->types, new_size/2); s->offsets = qemu_realloc(s->offsets, new_size); s->lengths = qemu_realloc(s->lengths, new_size); s->sectors = qemu_realloc(s->sectors, new_size); s->sectorcounts = qemu_realloc(s->sectorcounts, new_size); for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) { s->types[i] = read_uint32(s->fd, offset); offset += 4; if(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) { if(s->types[i]==0xffffffff) { last_in_offset = s->offsets[i-1]+s->lengths[i-1]; last_out_offset = s->sectors[i-1]+s->sectorcounts[i-1]; } chunk_count--; i--; offset += 36; continue; } offset += 4; s->sectors[i] = last_out_offset+read_off(s->fd, offset); offset += 8; s->sectorcounts[i] = read_off(s->fd, offset); offset += 8; s->offsets[i] = last_in_offset+read_off(s->fd, offset); offset += 8; s->lengths[i] = read_off(s->fd, offset); offset += 8; if(s->lengths[i]>max_compressed_size) max_compressed_size = s->lengths[i]; if(s->sectorcounts[i]>max_sectors_per_chunk) max_sectors_per_chunk = s->sectorcounts[i]; } s->n_chunks+=chunk_count; } } s->compressed_chunk = qemu_malloc(max_compressed_size+1); s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk); if(inflateInit(&s->zstream) != Z_OK) goto fail; s->current_chunk = s->n_chunks; return 0; fail: close(s->fd); return -1; }
--------------------------------------------- Result 527 ---------------------------------------------
[[0 (80%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int ff_wms_parse_sdp_a_line(AVFormatContext *[[s]], const char *[[p]]) { int ret = 0; if (av_strstart([[p]], "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &[[p]])) { AVIOContext pb; RTSPState *[[rt]] = [[s]]->priv_data; AVDictionary *[[opts]] = NULL; int [[len]] = strlen([[p]]) * 6 / 8; char *buf = av_mallocz([[len]]); AVInputFormat *iformat; if (!buf) return AVERROR(ENOMEM); av_base64_decode(buf, [[p]], [[len]]); if (rtp_asf_fix_header(buf, [[len]]) < 0) av_log([[s]], AV_LOG_ERROR, "Failed to fix invalid RTSP-MS/ASF min_pktsize\n"); init_packetizer(&pb, buf, [[len]]); if ([[rt]]->asf_ctx) { avformat_close_input(&[[rt]]->asf_ctx); } if (!(iformat = av_find_input_format("asf"))) return AVERROR_DEMUXER_NOT_FOUND; [[rt]]->asf_ctx = avformat_alloc_context(); if (![[rt]]->asf_ctx) { av_free(buf); return AVERROR(ENOMEM); } [[rt]]->asf_ctx->pb = &pb; av_dict_set(&[[opts]], "no_resync_search", "1", 0); if ((ret = ff_copy_whiteblacklists([[rt]]->asf_ctx, [[s]])) < 0) { av_dict_free(&[[opts]]); return ret; } ret = avformat_open_input(&[[rt]]->asf_ctx, "", iformat, &[[opts]]); av_dict_free(&[[opts]]); if (ret < 0) { av_free(buf); return ret; } av_dict_copy(&[[s]]->metadata, [[rt]]->asf_ctx->metadata, 0); [[rt]]->asf_pb_pos = avio_tell(&pb); av_free(buf); [[rt]]->asf_ctx->pb = NULL; } return ret; }

[[[[Adv]]]]: int ff_wms_parse_sdp_a_line(AVFormatContext *[[series]], const char *[[series]]) { int ret = 0; if (av_strstart([[series]], "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &[[series]])) { AVIOContext pb; RTSPState *[[fan]] = [[series]]->priv_data; AVDictionary *[[oleing]] = NULL; int [[reg]] = strlen([[series]]) * 6 / 8; char *buf = av_mallocz([[reg]]); AVInputFormat *iformat; if (!buf) return AVERROR(ENOMEM); av_base64_decode(buf, [[series]], [[reg]]); if (rtp_asf_fix_header(buf, [[reg]]) < 0) av_log([[series]], AV_LOG_ERROR, "Failed to fix invalid RTSP-MS/ASF min_pktsize\n"); init_packetizer(&pb, buf, [[reg]]); if ([[fan]]->asf_ctx) { avformat_close_input(&[[fan]]->asf_ctx); } if (!(iformat = av_find_input_format("asf"))) return AVERROR_DEMUXER_NOT_FOUND; [[fan]]->asf_ctx = avformat_alloc_context(); if (![[fan]]->asf_ctx) { av_free(buf); return AVERROR(ENOMEM); } [[fan]]->asf_ctx->pb = &pb; av_dict_set(&[[oleing]], "no_resync_search", "1", 0); if ((ret = ff_copy_whiteblacklists([[fan]]->asf_ctx, [[series]])) < 0) { av_dict_free(&[[oleing]]); return ret; } ret = avformat_open_input(&[[fan]]->asf_ctx, "", iformat, &[[oleing]]); av_dict_free(&[[oleing]]); if (ret < 0) { av_free(buf); return ret; } av_dict_copy(&[[series]]->metadata, [[fan]]->asf_ctx->metadata, 0); [[fan]]->asf_pb_pos = avio_tell(&pb); av_free(buf); [[fan]]->asf_ctx->pb = NULL; } return ret; }
--------------------------------------------- Result 528 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vc1_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size, n_slices = 0, i; VC1Context *v = avctx->priv_data; MpegEncContext *s = &v->s; AVFrame *pict = data; uint8_t *buf2 = NULL; const uint8_t *buf_start = buf, *buf_start_second_field = NULL; int mb_height, n_slices1=-1; struct { uint8_t *buf; GetBitContext gb; int mby_start; } *slices = NULL, *tmp; v->second_field = 0; if(s->flags & CODEC_FLAG_LOW_DELAY) s->low_delay = 1; if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) { if (s->low_delay == 0 && s->next_picture_ptr) { *pict = s->next_picture_ptr->f; s->next_picture_ptr = NULL; *data_size = sizeof(AVFrame); } return buf_size; } if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) { if (v->profile < PROFILE_ADVANCED) avctx->pix_fmt = AV_PIX_FMT_VDPAU_WMV3; else avctx->pix_fmt = AV_PIX_FMT_VDPAU_VC1; } if (avctx->codec_id == AV_CODEC_ID_VC1 || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) { int buf_size2 = 0; buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (IS_MARKER(AV_RB32(buf))) { const uint8_t *start, *end, *next; int size; next = buf; for (start = buf, end = buf + buf_size; next < end; start = next) { next = find_next_marker(start + 4, end); size = next - start - 4; if (size <= 0) continue; switch (AV_RB32(start)) { case VC1_CODE_FRAME: if (avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) buf_start = start; buf_size2 = vc1_unescape_buffer(start + 4, size, buf2); break; case VC1_CODE_FIELD: { int buf_size3; if (avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) buf_start_second_field = start; tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1)); if (!tmp) goto err; slices = tmp; slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!slices[n_slices].buf) goto err; buf_size3 = vc1_unescape_buffer(start + 4, size, slices[n_slices].buf); init_get_bits(&slices[n_slices].gb, slices[n_slices].buf, buf_size3 << 3); slices[n_slices].mby_start = s->mb_height >> 1; n_slices1 = n_slices - 1; n_slices++; break; } case VC1_CODE_ENTRYPOINT: buf_size2 = vc1_unescape_buffer(start + 4, size, buf2); init_get_bits(&s->gb, buf2, buf_size2 * 8); ff_vc1_decode_entry_point(avctx, v, &s->gb); break; case VC1_CODE_SLICE: { int buf_size3; tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1)); if (!tmp) goto err; slices = tmp; slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!slices[n_slices].buf) goto err; buf_size3 = vc1_unescape_buffer(start + 4, size, slices[n_slices].buf); init_get_bits(&slices[n_slices].gb, slices[n_slices].buf, buf_size3 << 3); slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9); n_slices++; break; } } } } else if (v->interlace && ((buf[0] & 0xC0) == 0xC0)) { const uint8_t *divider; int buf_size3; divider = find_next_marker(buf, buf + buf_size); if ((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD) { av_log(avctx, AV_LOG_ERROR, "Error in WVC1 interlaced frame\n"); goto err; } else { if (avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) buf_start_second_field = divider; tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1)); if (!tmp) goto err; slices = tmp; slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!slices[n_slices].buf) goto err; buf_size3 = vc1_unescape_buffer(divider + 4, buf + buf_size - divider - 4, slices[n_slices].buf); init_get_bits(&slices[n_slices].gb, slices[n_slices].buf, buf_size3 << 3); slices[n_slices].mby_start = s->mb_height >> 1; n_slices1 = n_slices - 1; n_slices++; } buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2); } else { buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2); } init_get_bits(&s->gb, buf2, buf_size2*8); } else init_get_bits(&s->gb, buf, buf_size*8); if (v->res_sprite) { v->new_sprite = !get_bits1(&s->gb); v->two_sprites = get_bits1(&s->gb); if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) { if (v->new_sprite) { avctx->width = avctx->coded_width = v->sprite_width; avctx->height = avctx->coded_height = v->sprite_height; } else { goto image; } } } if (s->context_initialized && (s->width != avctx->coded_width || s->height != avctx->coded_height)) { ff_vc1_decode_end(avctx); } if (!s->context_initialized) { if (ff_msmpeg4_decode_init(avctx) < 0 || ff_vc1_decode_init_alloc_tables(v) < 0) goto err; s->low_delay = !avctx->has_b_frames || v->res_sprite; if (v->profile == PROFILE_ADVANCED) { s->h_edge_pos = avctx->coded_width; s->v_edge_pos = avctx->coded_height; } } if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) { int i = ff_find_unused_picture(s, 0); if (i < 0) goto err; s->current_picture_ptr = &s->picture[i]; } v->pic_header_flag = 0; if (v->profile < PROFILE_ADVANCED) { if (ff_vc1_parse_frame_header(v, &s->gb) < 0) { goto err; } } else { if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) { goto err; } } if (avctx->debug & FF_DEBUG_PICT_INFO) av_log(v->s.avctx, AV_LOG_DEBUG, "pict_type: %c\n", av_get_picture_type_char(s->pict_type)); if ((avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) && s->pict_type != AV_PICTURE_TYPE_I) { av_log(v->s.avctx, AV_LOG_ERROR, "Sprite decoder: expected I-frame\n"); goto err; } if ((s->mb_height >> v->field_mode) == 0) { av_log(v->s.avctx, AV_LOG_ERROR, "image too short\n"); goto err; } s->current_picture_ptr->f.repeat_pict = 0; if (v->rff) { s->current_picture_ptr->f.repeat_pict = 1; } else if (v->rptfrm) { s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2; } s->current_picture.f.pict_type = s->pict_type; s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I; if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->dropable)) { goto err; } if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) || (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) || avctx->skip_frame >= AVDISCARD_ALL) { goto end; } if (s->next_p_frame_damaged) { if (s->pict_type == AV_PICTURE_TYPE_B) goto end; else s->next_p_frame_damaged = 0; } if (ff_MPV_frame_start(s, avctx) < 0) { goto err; } v->s.current_picture_ptr->f.interlaced_frame = (v->fcm != PROGRESSIVE); v->s.current_picture_ptr->f.top_field_first = v->tff; s->me.qpel_put = s->dsp.put_qpel_pixels_tab; s->me.qpel_avg = s->dsp.avg_qpel_pixels_tab; if ((CONFIG_VC1_VDPAU_DECODER) &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start); else if (avctx->hwaccel) { if (v->field_mode && buf_start_second_field) { s->picture_structure = PICT_BOTTOM_FIELD - v->tff; if (avctx->hwaccel->start_frame(avctx, buf_start, buf_start_second_field - buf_start) < 0) goto err; if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_start_second_field - buf_start) < 0) goto err; if (avctx->hwaccel->end_frame(avctx) < 0) goto err; s->gb = slices[n_slices1 + 1].gb; s->picture_structure = PICT_TOP_FIELD + v->tff; v->second_field = 1; v->pic_header_flag = 0; if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) { av_log(avctx, AV_LOG_ERROR, "parsing header for second field failed"); goto err; } v->s.current_picture_ptr->f.pict_type = v->s.pict_type; if (avctx->hwaccel->start_frame(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0) goto err; if (avctx->hwaccel->decode_slice(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0) goto err; if (avctx->hwaccel->end_frame(avctx) < 0) goto err; } else { s->picture_structure = PICT_FRAME; if (avctx->hwaccel->start_frame(avctx, buf_start, (buf + buf_size) - buf_start) < 0) goto err; if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0) goto err; if (avctx->hwaccel->end_frame(avctx) < 0) goto err; } } else { if (v->fcm == ILACE_FRAME && s->pict_type == AV_PICTURE_TYPE_B) goto err; ff_er_frame_start(s); v->bits = buf_size * 8; v->end_mb_x = s->mb_width; if (v->field_mode) { uint8_t *tmp[2]; s->current_picture.f.linesize[0] <<= 1; s->current_picture.f.linesize[1] <<= 1; s->current_picture.f.linesize[2] <<= 1; s->linesize <<= 1; s->uvlinesize <<= 1; tmp[0] = v->mv_f_last[0]; tmp[1] = v->mv_f_last[1]; v->mv_f_last[0] = v->mv_f_next[0]; v->mv_f_last[1] = v->mv_f_next[1]; v->mv_f_next[0] = v->mv_f[0]; v->mv_f_next[1] = v->mv_f[1]; v->mv_f[0] = tmp[0]; v->mv_f[1] = tmp[1]; } mb_height = s->mb_height >> v->field_mode; for (i = 0; i <= n_slices; i++) { if (i > 0 && slices[i - 1].mby_start >= mb_height) { if (v->field_mode <= 0) { av_log(v->s.avctx, AV_LOG_ERROR, "Slice %d starts beyond " "picture boundary (%d >= %d)\n", i, slices[i - 1].mby_start, mb_height); continue; } v->second_field = 1; v->blocks_off = s->mb_width * s->mb_height << 1; v->mb_off = s->mb_stride * s->mb_height >> 1; } else { v->second_field = 0; v->blocks_off = 0; v->mb_off = 0; } if (i) { v->pic_header_flag = 0; if (v->field_mode && i == n_slices1 + 2) { if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) { av_log(v->s.avctx, AV_LOG_ERROR, "Field header damaged\n"); continue; } } else if (get_bits1(&s->gb)) { v->pic_header_flag = 1; if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) { av_log(v->s.avctx, AV_LOG_ERROR, "Slice header damaged\n"); continue; } } } s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start % mb_height); if (!v->field_mode || v->second_field) s->end_mb_y = (i == n_slices ) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height); else s->end_mb_y = (i <= n_slices1 + 1) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height); if (s->end_mb_y <= s->start_mb_y) { av_log(v->s.avctx, AV_LOG_ERROR, "end mb y %d %d invalid\n", s->end_mb_y, s->start_mb_y); continue; } ff_vc1_decode_blocks(v); if (i != n_slices) s->gb = slices[i].gb; } if (v->field_mode) { v->second_field = 0; if (s->pict_type == AV_PICTURE_TYPE_B) { memcpy(v->mv_f_base, v->mv_f_next_base, 2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2)); } s->current_picture.f.linesize[0] >>= 1; s->current_picture.f.linesize[1] >>= 1; s->current_picture.f.linesize[2] >>= 1; s->linesize >>= 1; s->uvlinesize >>= 1; } av_dlog(s->avctx, "Consumed %i/%i bits\n", get_bits_count(&s->gb), s->gb.size_in_bits); if(s->error_occurred && s->pict_type == AV_PICTURE_TYPE_B) goto err; if(!v->field_mode) ff_er_frame_end(s); } ff_MPV_frame_end(s); if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) { image: avctx->width = avctx->coded_width = v->output_width; avctx->height = avctx->coded_height = v->output_height; if (avctx->skip_frame >= AVDISCARD_NONREF) goto end; #if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER if (vc1_decode_sprites(v, &s->gb)) goto err; #endif *pict = v->sprite_output_frame; *data_size = sizeof(AVFrame); } else { if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) { *pict = s->current_picture_ptr->f; } else if (s->last_picture_ptr != NULL) { *pict = s->last_picture_ptr->f; } if (s->last_picture_ptr || s->low_delay) { *data_size = sizeof(AVFrame); ff_print_debug_info(s, pict); } } end: av_free(buf2); for (i = 0; i < n_slices; i++) av_free(slices[i].buf); av_free(slices); return buf_size; err: av_free(buf2); for (i = 0; i < n_slices; i++) av_free(slices[i].buf); av_free(slices); return -1; }[Succeeded / Failed / Skipped / Total] 273 / 63 / 192 / 528:  20%|█▉        | 528/2690 [1:21:31<5:33:48,  9.26s/it][Succeeded / Failed / Skipped / Total] 273 / 63 / 192 / 528:  20%|█▉        | 529/2690 [1:21:33<5:33:12,  9.25s/it][Succeeded / Failed / Skipped / Total] 274 / 63 / 192 / 529:  20%|█▉        | 529/2690 [1:21:33<5:33:12,  9.25s/it][Succeeded / Failed / Skipped / Total] 274 / 63 / 192 / 529:  20%|█▉        | 530/2690 [1:21:34<5:32:27,  9.23s/it][Succeeded / Failed / Skipped / Total] 274 / 63 / 193 / 530:  20%|█▉        | 530/2690 [1:21:34<5:32:27,  9.23s/it][Succeeded / Failed / Skipped / Total] 274 / 63 / 193 / 530:  20%|█▉        | 531/2690 [1:21:35<5:31:42,  9.22s/it]
--------------------------------------------- Result 529 ---------------------------------------------
[[0 (15%)]] --> [[0 (92%)]] --> Socre: 0.9167765378952026

[[[[Adv]]]]: static av_cold int dnxhd_encode_init(AVCodecContext *avctx) { DNXHDEncContext *ctx = [[avctx]]->priv_data; int i, index, bit_depth, ret; switch ([[avctx]]->pix_fmt) { case AV_PIX_FMT_YUV422P: bit_depth = 8; break; case AV_PIX_FMT_YUV422P10: bit_depth = 10; break; default: av_log([[avctx]], AV_LOG_ERROR, "pixel format is incompatible with DNxHD\n"); return AVERROR(EINVAL); } ctx->cid = ff_dnxhd_find_cid([[avctx]], bit_depth); if (!ctx->cid) { av_log([[avctx]], AV_LOG_ERROR, "video parameters incompatible with DNxHD\n"); return AVERROR(EINVAL); } av_log([[avctx]], AV_LOG_DEBUG, "cid %d\n", ctx->cid); index = ff_dnxhd_get_cid_table(ctx->cid); if (index < 0) return index; ctx->cid_table = &ff_dnxhd_cid_table[index]; ctx->m.avctx = [[avctx]]; ctx->m.mb_intra = 1; ctx->m.h263_aic = 1; [[avctx]]->bits_per_raw_sample = ctx->cid_table->bit_depth; ff_blockdsp_init(&ctx->bdsp, [[avctx]]); ff_fdctdsp_init(&ctx->m.fdsp, [[avctx]]); ff_mpv_idct_init(&ctx->m); ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, [[avctx]]); ff_pixblockdsp_init(&ctx->m.pdsp, [[avctx]]); if (!ctx->m.dct_quantize) ctx->m.dct_quantize = ff_dct_quantize_c; if (ctx->cid_table->bit_depth == 10) { ctx->m.dct_quantize = dnxhd_10bit_dct_quantize; ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym; ctx->block_width_l2 = 4; } else { ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym; ctx->block_width_l2 = 3; } if (ARCH_X86) ff_dnxhdenc_init_x86(ctx); ctx->m.mb_height = ([[avctx]]->height + 15) / 16; ctx->m.mb_width = ([[avctx]]->width + 15) / 16; if ([[avctx]]->flags & AV_CODEC_FLAG_INTERLACED_DCT) { ctx->interlaced = 1; ctx->m.mb_height /= 2; } ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width; #if FF_API_QUANT_BIAS FF_DISABLE_DEPRECATION_WARNINGS if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS && [[avctx]]->intra_quant_bias != FF_DEFAULT_QUANT_BIAS) ctx->intra_quant_bias = [[avctx]]->intra_quant_bias; FF_ENABLE_DEPRECATION_WARNINGS #endif if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0) return ret; if (ctx->nitris_compat) ctx->min_padding = 1600; if ((ret = dnxhd_init_vlc(ctx)) < 0) return ret; if ((ret = dnxhd_init_rc(ctx)) < 0) return ret; FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size, ctx->m.mb_height * sizeof(uint32_t), fail); FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs, ctx->m.mb_height * sizeof(uint32_t), fail); FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits, ctx->m.mb_num * sizeof(uint16_t), fail); FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale, ctx->m.mb_num * sizeof(uint8_t), fail); #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[avctx]]->coded_frame->key_frame = 1; [[avctx]]->coded_frame->pict_type = AV_PICTURE_TYPE_I; FF_ENABLE_DEPRECATION_WARNINGS #endif if ([[avctx]]->thread_count > MAX_THREADS) { av_log([[avctx]], AV_LOG_ERROR, "too many threads\n"); return AVERROR(EINVAL); } ctx->thread[0] = ctx; for (i = 1; i < [[avctx]]->thread_count; i++) { ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext)); memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext)); } return 0; fail: return AVERROR(ENOMEM); }

[[[[Adv]]]]: static av_cold int dnxhd_encode_init(AVCodecContext *avctx) { DNXHDEncContext *ctx = [[αrdz]]->priv_data; int i, index, bit_depth, ret; switch ([[αrdz]]->pix_fmt) { case AV_PIX_FMT_YUV422P: bit_depth = 8; break; case AV_PIX_FMT_YUV422P10: bit_depth = 10; break; default: av_log([[αrdz]], AV_LOG_ERROR, "pixel format is incompatible with DNxHD\n"); return AVERROR(EINVAL); } ctx->cid = ff_dnxhd_find_cid([[αrdz]], bit_depth); if (!ctx->cid) { av_log([[αrdz]], AV_LOG_ERROR, "video parameters incompatible with DNxHD\n"); return AVERROR(EINVAL); } av_log([[αrdz]], AV_LOG_DEBUG, "cid %d\n", ctx->cid); index = ff_dnxhd_get_cid_table(ctx->cid); if (index < 0) return index; ctx->cid_table = &ff_dnxhd_cid_table[index]; ctx->m.avctx = [[αrdz]]; ctx->m.mb_intra = 1; ctx->m.h263_aic = 1; [[αrdz]]->bits_per_raw_sample = ctx->cid_table->bit_depth; ff_blockdsp_init(&ctx->bdsp, [[αrdz]]); ff_fdctdsp_init(&ctx->m.fdsp, [[αrdz]]); ff_mpv_idct_init(&ctx->m); ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, [[αrdz]]); ff_pixblockdsp_init(&ctx->m.pdsp, [[αrdz]]); if (!ctx->m.dct_quantize) ctx->m.dct_quantize = ff_dct_quantize_c; if (ctx->cid_table->bit_depth == 10) { ctx->m.dct_quantize = dnxhd_10bit_dct_quantize; ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym; ctx->block_width_l2 = 4; } else { ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym; ctx->block_width_l2 = 3; } if (ARCH_X86) ff_dnxhdenc_init_x86(ctx); ctx->m.mb_height = ([[αrdz]]->height + 15) / 16; ctx->m.mb_width = ([[αrdz]]->width + 15) / 16; if ([[αrdz]]->flags & AV_CODEC_FLAG_INTERLACED_DCT) { ctx->interlaced = 1; ctx->m.mb_height /= 2; } ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width; #if FF_API_QUANT_BIAS FF_DISABLE_DEPRECATION_WARNINGS if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS && [[αrdz]]->intra_quant_bias != FF_DEFAULT_QUANT_BIAS) ctx->intra_quant_bias = [[αrdz]]->intra_quant_bias; FF_ENABLE_DEPRECATION_WARNINGS #endif if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0) return ret; if (ctx->nitris_compat) ctx->min_padding = 1600; if ((ret = dnxhd_init_vlc(ctx)) < 0) return ret; if ((ret = dnxhd_init_rc(ctx)) < 0) return ret; FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size, ctx->m.mb_height * sizeof(uint32_t), fail); FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs, ctx->m.mb_height * sizeof(uint32_t), fail); FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits, ctx->m.mb_num * sizeof(uint16_t), fail); FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale, ctx->m.mb_num * sizeof(uint8_t), fail); #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[αrdz]]->coded_frame->key_frame = 1; [[αrdz]]->coded_frame->pict_type = AV_PICTURE_TYPE_I; FF_ENABLE_DEPRECATION_WARNINGS #endif if ([[αrdz]]->thread_count > MAX_THREADS) { av_log([[αrdz]], AV_LOG_ERROR, "too many threads\n"); return AVERROR(EINVAL); } ctx->thread[0] = ctx; for (i = 1; i < [[αrdz]]->thread_count; i++) { ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext)); memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext)); } return 0; fail: return AVERROR(ENOMEM); }
--------------------------------------------- Result 530 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: vcard_emul_mirror_card(VReader *vreader) { PK11GenericObject *firstObj, *thisObj; int cert_count; unsigned char **certs; int *cert_len; VCardKey **keys; PK11SlotInfo *slot; VCard *card; slot = vcard_emul_reader_get_slot(vreader); if (slot == NULL) { return NULL; } firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE); if (firstObj == NULL) { return NULL; } cert_count = 0; for (thisObj = firstObj; thisObj; thisObj = PK11_GetNextGenericObject(thisObj)) { cert_count++; } if (cert_count == 0) { PK11_DestroyGenericObjects(firstObj); return NULL; } vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count); cert_count = 0; for (thisObj = firstObj; thisObj; thisObj = PK11_GetNextGenericObject(thisObj)) { SECItem derCert; CERTCertificate *cert; SECStatus rv; rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj, CKA_VALUE, &derCert); if (rv != SECSuccess) { continue; } cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert, NULL, PR_FALSE, PR_TRUE); SECITEM_FreeItem(&derCert, PR_FALSE); if (cert == NULL) { continue; } certs[cert_count] = cert->derCert.data; cert_len[cert_count] = cert->derCert.len; keys[cert_count] = vcard_emul_make_key(slot, cert); cert_count++; CERT_DestroyCertificate(cert); } card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count); g_free(certs); g_free(cert_len); g_free(keys); return card; }
--------------------------------------------- Result 531 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 274 / 63 / 194 / 531:  20%|█▉        | 531/2690 [1:21:35<5:31:42,  9.22s/it][Succeeded / Failed / Skipped / Total] 274 / 63 / 194 / 531:  20%|█▉        | 532/2690 [1:21:49<5:31:54,  9.23s/it][Succeeded / Failed / Skipped / Total] 275 / 63 / 194 / 532:  20%|█▉        | 532/2690 [1:21:49<5:31:54,  9.23s/it][Succeeded / Failed / Skipped / Total] 275 / 63 / 194 / 532:  20%|█▉        | 533/2690 [1:22:12<5:32:42,  9.25s/it][Succeeded / Failed / Skipped / Total] 276 / 63 / 194 / 533:  20%|█▉        | 533/2690 [1:22:12<5:32:42,  9.25s/it][Succeeded / Failed / Skipped / Total] 276 / 63 / 194 / 533:  20%|█▉        | 534/2690 [1:22:16<5:32:09,  9.24s/it][Succeeded / Failed / Skipped / Total] 276 / 64 / 194 / 534:  20%|█▉        | 534/2690 [1:22:16<5:32:09,  9.24s/it][Succeeded / Failed / Skipped / Total] 276 / 64 / 194 / 534:  20%|█▉        | 535/2690 [1:22:16<5:31:24,  9.23s/it][Succeeded / Failed / Skipped / Total] 276 / 64 / 195 / 535:  20%|█▉        | 535/2690 [1:22:16<5:31:24,  9.23s/it][Succeeded / Failed / Skipped / Total] 276 / 64 / 195 / 535:  20%|█▉        | 536/2690 [1:22:17<5:30:40,  9.21s/it][[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint64_t megasas_fw_time(void) { struct tm curtime; uint64_t bcd_time; qemu_get_timedate(&curtime, 0); bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 | ((uint64_t)curtime.tm_min & 0xff) << 40 | ((uint64_t)curtime.tm_hour & 0xff) << 32 | ((uint64_t)curtime.tm_mday & 0xff) << 24 | ((uint64_t)curtime.tm_mon & 0xff) << 16 | ((uint64_t)(curtime.tm_year + 1900) & 0xffff); return bcd_time; }
--------------------------------------------- Result 532 ---------------------------------------------
[[0 (57%)]] --> [[0 (28%)]] --> Socre: 0.7177780866622925

[[[[Adv]]]]: static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie) { OfDpaFlow *flow; int64_t [[now]] = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000; flow = g_new0(OfDpaFlow, 1); if (!flow) { return NULL; } flow->cookie = cookie; flow->mask.tbl_id = 0xffffffff; flow->stats.install_time = flow->stats.refresh_time = [[now]]; return flow; }

[[[[Adv]]]]: static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie) { OfDpaFlow *flow; int64_t [[band]] = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000; flow = g_new0(OfDpaFlow, 1); if (!flow) { return NULL; } flow->cookie = cookie; flow->mask.tbl_id = 0xffffffff; flow->stats.install_time = flow->stats.refresh_time = [[band]]; return flow; }
--------------------------------------------- Result 533 ---------------------------------------------
[[0 (49%)]] --> [[0 (58%)]] --> Socre: 0.5783089995384216

[[[[Adv]]]]: static int rtp_open(URLContext *h, const char *uri, int flags) { RTPContext *[[s]]; int port, is_output, ttl, local_port; char hostname[256]; char buf[1024]; char path[1024]; const char *p; is_output = (flags & URL_WRONLY); [[s]] = av_mallocz(sizeof(RTPContext)); if (![[s]]) return AVERROR(ENOMEM); h->priv_data = [[s]]; url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, path, sizeof(path), uri); ttl = -1; local_port = -1; p = strchr(uri, '?'); if (p) { if (find_info_tag(buf, sizeof(buf), "ttl", p)) { ttl = strtol(buf, NULL, 10); } if (find_info_tag(buf, sizeof(buf), "localport", p)) { local_port = strtol(buf, NULL, 10); } } build_udp_url(buf, sizeof(buf), hostname, port, local_port, ttl); if (url_open(&[[s]]->rtp_hd, buf, flags) < 0) goto fail; local_port = udp_get_local_port([[s]]->rtp_hd); build_udp_url(buf, sizeof(buf), hostname, port + 1, local_port + 1, ttl); if (url_open(&[[s]]->rtcp_hd, buf, flags) < 0) goto fail; [[s]]->rtp_fd = udp_get_file_handle([[s]]->rtp_hd); [[s]]->rtcp_fd = udp_get_file_handle([[s]]->rtcp_hd); h->max_packet_size = url_get_max_packet_size([[s]]->rtp_hd); h->is_streamed = 1; return 0; fail: if ([[s]]->rtp_hd) url_close([[s]]->rtp_hd); if ([[s]]->rtcp_hd) url_close([[s]]->rtcp_hd); av_free([[s]]); return AVERROR(EIO); }

[[[[Adv]]]]: static int rtp_open(URLContext *h, const char *uri, int flags) { RTPContext *[[it]]; int port, is_output, ttl, local_port; char hostname[256]; char buf[1024]; char path[1024]; const char *p; is_output = (flags & URL_WRONLY); [[it]] = av_mallocz(sizeof(RTPContext)); if (![[it]]) return AVERROR(ENOMEM); h->priv_data = [[it]]; url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, path, sizeof(path), uri); ttl = -1; local_port = -1; p = strchr(uri, '?'); if (p) { if (find_info_tag(buf, sizeof(buf), "ttl", p)) { ttl = strtol(buf, NULL, 10); } if (find_info_tag(buf, sizeof(buf), "localport", p)) { local_port = strtol(buf, NULL, 10); } } build_udp_url(buf, sizeof(buf), hostname, port, local_port, ttl); if (url_open(&[[it]]->rtp_hd, buf, flags) < 0) goto fail; local_port = udp_get_local_port([[it]]->rtp_hd); build_udp_url(buf, sizeof(buf), hostname, port + 1, local_port + 1, ttl); if (url_open(&[[it]]->rtcp_hd, buf, flags) < 0) goto fail; [[it]]->rtp_fd = udp_get_file_handle([[it]]->rtp_hd); [[it]]->rtcp_fd = udp_get_file_handle([[it]]->rtcp_hd); h->max_packet_size = url_get_max_packet_size([[it]]->rtp_hd); h->is_streamed = 1; return 0; fail: if ([[it]]->rtp_hd) url_close([[it]]->rtp_hd); if ([[it]]->rtcp_hd) url_close([[it]]->rtcp_hd); av_free([[it]]); return AVERROR(EIO); }
--------------------------------------------- Result 534 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void blk_apply_root_state(BlockBackend *[[blk]], BlockDriverState *[[bs]]) { [[bs]]->detect_zeroes = [[blk]]->root_state.detect_zeroes; }

[[[[Adv]]]]: void blk_apply_root_state(BlockBackend *[[tx]], BlockDriverState *[[bad]]) { [[bad]]->detect_zeroes = [[tx]]->root_state.detect_zeroes; }
--------------------------------------------- Result 535 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp) { JSONParserContext ctxt = {}; QList *working = qlist_copy(tokens); QObject *result; result = parse_value(&ctxt, &working, ap); QDECREF(working); error_propagate(errp, ctxt.err); return result; }
--------------------------------------------- Result 536 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 276 / 64 / 196 / 536:  20%|█▉        | 536/2690 [1:22:17<5:30:40,  9.21s/it][Succeeded / Failed / Skipped / Total] 276 / 64 / 196 / 536:  20%|█▉        | 537/2690 [1:22:40<5:31:26,  9.24s/it][Succeeded / Failed / Skipped / Total] 276 / 65 / 196 / 537:  20%|█▉        | 537/2690 [1:22:40<5:31:26,  9.24s/it][Succeeded / Failed / Skipped / Total] 276 / 65 / 196 / 537:  20%|██        | 538/2690 [1:22:40<5:30:42,  9.22s/it][Succeeded / Failed / Skipped / Total] 277 / 65 / 196 / 538:  20%|██        | 538/2690 [1:22:40<5:30:42,  9.22s/it][[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int init_directories(BDRVVVFATState* s, const char *dirname, int heads, int secs, Error **errp) { bootsector_t* bootsector; mapping_t* mapping; unsigned int i; unsigned int cluster; memset(&(s->first_sectors[0]),0,0x40*0x200); s->cluster_size=s->sectors_per_cluster*0x200; s->cluster_buffer=g_malloc(s->cluster_size); i = 1+s->sectors_per_cluster*0x200*8/s->fat_type; s->sectors_per_fat=(s->sector_count+i)/i; s->offset_to_fat = s->offset_to_bootsector + 1; s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2; array_init(&(s->mapping),sizeof(mapping_t)); array_init(&(s->directory),sizeof(direntry_t)); { direntry_t* entry=array_get_next(&(s->directory)); entry->attributes=0x28; memcpy(entry->name, s->volume_label, sizeof(entry->name)); } init_fat(s); s->cluster_count=sector2cluster(s, s->sector_count); mapping = array_get_next(&(s->mapping)); mapping->begin = 0; mapping->dir_index = 0; mapping->info.dir.parent_mapping_index = -1; mapping->first_mapping_index = -1; mapping->path = g_strdup(dirname); i = strlen(mapping->path); if (i > 0 && mapping->path[i - 1] == '/') mapping->path[i - 1] = '\0'; mapping->mode = MODE_DIRECTORY; mapping->read_only = 0; s->path = mapping->path; for (i = 0, cluster = 0; i < s->mapping.next; i++) { int fix_fat = (i != 0); mapping = array_get(&(s->mapping), i); if (mapping->mode & MODE_DIRECTORY) { mapping->begin = cluster; if(read_directory(s, i)) { error_setg(errp, "Could not read directory %s", mapping->path); return -1; } mapping = array_get(&(s->mapping), i); } else { assert(mapping->mode == MODE_UNDEFINED); mapping->mode=MODE_NORMAL; mapping->begin = cluster; if (mapping->end > 0) { direntry_t* direntry = array_get(&(s->directory), mapping->dir_index); mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size; set_begin_of_direntry(direntry, mapping->begin); } else { mapping->end = cluster + 1; fix_fat = 0; } } assert(mapping->begin < mapping->end); cluster = mapping->end; if(cluster > s->cluster_count) { error_setg(errp, "Directory does not fit in FAT%d (capacity %.2f MB)", s->fat_type, s->sector_count / 2000.0); return -1; } if (fix_fat) { int j; for(j = mapping->begin; j < mapping->end - 1; j++) fat_set(s, j, j+1); fat_set(s, mapping->end - 1, s->max_fat_value); } } mapping = array_get(&(s->mapping), 0); s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster; s->last_cluster_of_root_directory = mapping->end; fat_set(s,0,s->max_fat_value); fat_set(s,1,s->max_fat_value); s->current_mapping = NULL; bootsector = (bootsector_t *)(s->first_sectors + s->offset_to_bootsector * 0x200); bootsector->jump[0]=0xeb; bootsector->jump[1]=0x3e; bootsector->jump[2]=0x90; memcpy(bootsector->name,"QEMU ",8); bootsector->sector_size=cpu_to_le16(0x200); bootsector->sectors_per_cluster=s->sectors_per_cluster; bootsector->reserved_sectors=cpu_to_le16(1); bootsector->number_of_fats=0x2; bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10); bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count); bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0); s->fat.pointer[0] = bootsector->media_type; bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat); bootsector->sectors_per_track = cpu_to_le16(secs); bootsector->number_of_heads = cpu_to_le16(heads); bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector); bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0); bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80; bootsector->u.fat16.signature=0x29; bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd); memcpy(bootsector->u.fat16.volume_label, s->volume_label, sizeof(bootsector->u.fat16.volume_label)); memcpy(bootsector->u.fat16.fat_type, s->fat_type == 12 ? "FAT12 " : "FAT16 ", 8); bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa; return 0; }
--------------------------------------------- Result 537 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ehci_mem_writel(void *[[ptr]], target_phys_addr_t addr, uint32_t [[val]]) { EHCIState *[[s]] = [[ptr]]; uint32_t *[[mmio]] = (uint32_t *)(&[[s]]->mmio[addr]); uint32_t old = *[[mmio]]; int [[i]]; trace_usb_ehci_mmio_writel(addr, addr2str(addr), [[val]]); if (addr & 3) { fprintf(stderr, "usb-ehci: Mis-aligned write to addr 0x" TARGET_FMT_plx "\n", addr); return; if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) { handle_port_status_write([[s]], (addr-PORTSC)/4, [[val]]); trace_usb_ehci_mmio_change(addr, addr2str(addr), *[[mmio]], old); return; if (addr < OPREGBASE) { fprintf(stderr, "usb-ehci: write attempt to read-only register" TARGET_FMT_plx "\n", addr); return; switch(addr) { case USBCMD: if ([[val]] & USBCMD_HCRESET) { ehci_reset([[s]]); [[val]] = [[s]]->usbcmd; break; if (([[val]] & USBCMD_FLS) && !([[s]]->usbcmd & USBCMD_FLS)) { fprintf(stderr, "attempt to set frame list size -- value %d\n", [[val]] & USBCMD_FLS); [[val]] &= ~USBCMD_FLS; if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & [[val]]) != ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & [[s]]->usbcmd)) { if ([[s]]->pstate == EST_INACTIVE) { SET_LAST_RUN_CLOCK([[s]]); [[s]]->usbcmd = [[val]]; ehci_update_halt([[s]]); qemu_mod_timer([[s]]->frame_timer, qemu_get_clock_ns(vm_clock)); break; case USBSTS: [[val]] &= USBSTS_RO_MASK; ehci_clear_usbsts([[s]], [[val]]); [[val]] = [[s]]->usbsts; ehci_update_irq([[s]]); break; case USBINTR: [[val]] &= USBINTR_MASK; break; case FRINDEX: [[val]] &= 0x00003ff8; break; case CONFIGFLAG: [[val]] &= 0x1; if ([[val]]) { for([[i]] = 0; [[i]] < NB_PORTS; [[i]]++) handle_port_owner_write([[s]], [[i]], 0); break; case PERIODICLISTBASE: if (ehci_periodic_enabled([[s]])) { fprintf(stderr, "ehci: PERIODIC list base register set while periodic schedule\n" " is enabled and HC is enabled\n"); break; case ASYNCLISTADDR: if (ehci_async_enabled([[s]])) { fprintf(stderr, "ehci: ASYNC list address register set while async schedule\n" " is enabled and HC is enabled\n"); break; *[[mmio]] = [[val]]; trace_usb_ehci_mmio_change(addr, addr2str(addr), *[[mmio]], old);

[[[[Adv]]]]: static void ehci_mem_writel(void *[[editρ]], target_phys_addr_t addr, uint32_t [[va]]) { EHCIState *[[st]] = [[editρ]]; uint32_t *[[mvf]] = (uint32_t *)(&[[st]]->mmio[addr]); uint32_t old = *[[mvf]]; int [[he]]; trace_usb_ehci_mmio_writel(addr, addr2str(addr), [[va]]); if (addr & 3) { fprintf(stderr, "usb-ehci: Mis-aligned write to addr 0x" TARGET_FMT_plx "\n", addr); return; if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) { handle_port_status_write([[st]], (addr-PORTSC)/4, [[va]]); trace_usb_ehci_mmio_change(addr, addr2str(addr), *[[mvf]], old); return; if (addr < OPREGBASE) { fprintf(stderr, "usb-ehci: write attempt to read-only register" TARGET_FMT_plx "\n", addr); return; switch(addr) { case USBCMD: if ([[va]] & USBCMD_HCRESET) { ehci_reset([[st]]); [[va]] = [[st]]->usbcmd; break; if (([[va]] & USBCMD_FLS) && !([[st]]->usbcmd & USBCMD_FLS)) { fprintf(stderr, "attempt to set frame list size -- value %d\n", [[va]] & USBCMD_FLS); [[va]] &= ~USBCMD_FLS; if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & [[va]]) != ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & [[st]]->usbcmd)) { if ([[st]]->pstate == EST_INACTIVE) { SET_LAST_RUN_CLOCK([[st]]); [[st]]->usbcmd = [[va]]; ehci_update_halt([[st]]); qemu_mod_timer([[st]]->frame_timer, qemu_get_clock_ns(vm_clock)); break; case USBSTS: [[va]] &= USBSTS_RO_MASK; ehci_clear_usbsts([[st]], [[va]]); [[va]] = [[st]]->usbsts; ehci_update_irq([[st]]); break; case USBINTR: [[va]] &= USBINTR_MASK; break; case FRINDEX: [[va]] &= 0x00003ff8; break; case CONFIGFLAG: [[va]] &= 0x1; if ([[va]]) { for([[he]] = 0; [[he]] < NB_PORTS; [[he]]++) handle_port_owner_write([[st]], [[he]], 0); break; case PERIODICLISTBASE: if (ehci_periodic_enabled([[st]])) { fprintf(stderr, "ehci: PERIODIC list base register set while periodic schedule\n" " is enabled and HC is enabled\n"); break; case ASYNCLISTADDR: if (ehci_async_enabled([[st]])) { fprintf(stderr, "ehci: ASYNC list address register set while async schedule\n" " is enabled and HC is enabled\n"); break; *[[mvf]] = [[va]]; trace_usb_ehci_mmio_change(addr, addr2str(addr), *[[mvf]], old);
--------------------------------------------- Result 538 ---------------------------------------------
[[0 (2%)]] --> [[0 (77%)]] --> Socre: 0.768955647945404

[[[[Adv]]]]: void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *[[irqs]]) { pxa2xx_timer_info *s = pxa2xx_timer_init(base, [[irqs]]); s->freq = PXA25X_FREQ; s->tm4 = NULL; }

[[[[Adv]]]]: void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *[[raaqс]]) { pxa2xx_timer_info *s = pxa2xx_timer_init(base, [[raaqс]]); s->freq = PXA25X_FREQ; s->tm4 = NULL; }
--------------------------------------------- Result 539 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 277 / 65 / 197 / 539:  20%|██        | 539/2690 [1:22:40<5:29:56,  9.20s/it][Succeeded / Failed / Skipped / Total] 277 / 65 / 197 / 539:  20%|██        | 540/2690 [1:22:41<5:29:13,  9.19s/it][[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size, const char *core) { struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) g_malloc0(sizeof(struct omap_mpu_state_s)); ram_addr_t sram_base, q2_base; qemu_irq *cpu_irq; qemu_irq dma_irqs[4]; DriveInfo *dinfo; int i; SysBusDevice *busdev; struct omap_target_agent_s *ta; s->mpu_model = omap2420; s->env = cpu_init(core ?: "arm1136-r2"); if (!s->env) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } s->sdram_size = sdram_size; s->sram_size = OMAP242X_SRAM_SIZE; s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0]; omap_clk_init(s); cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size, (q2_base = qemu_ram_alloc(NULL, "omap2.dram", s->sdram_size)) | IO_MEM_RAM); cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size, (sram_base = qemu_ram_alloc(NULL, "omap2.sram", s->sram_size)) | IO_MEM_RAM); s->l4 = omap_l4_init(OMAP2_L4_BASE, 54); cpu_irq = arm_pic_init_cpu(s->env); s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0], cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ], omap_findclk(s, "mpu_intc_fclk"), omap_findclk(s, "mpu_intc_iclk")); s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3), s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s); s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1), omap_findclk(s, "omapctrl_iclk"), s); for (i = 0; i < 4; i ++) dma_irqs[i] = s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr]; s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32, omap_findclk(s, "sdma_iclk"), omap_findclk(s, "sdma_fclk")); s->port->addr_valid = omap2_validate_addr; soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base), OMAP2_Q2_BASE, s->sdram_size); soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base), OMAP2_SRAM_BASE, s->sram_size); s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19), s->irq[0][OMAP_INT_24XX_UART1_IRQ], omap_findclk(s, "uart1_fclk"), omap_findclk(s, "uart1_iclk"), s->drq[OMAP24XX_DMA_UART1_TX], s->drq[OMAP24XX_DMA_UART1_RX], "uart1", serial_hds[0]); s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20), s->irq[0][OMAP_INT_24XX_UART2_IRQ], omap_findclk(s, "uart2_fclk"), omap_findclk(s, "uart2_iclk"), s->drq[OMAP24XX_DMA_UART2_TX], s->drq[OMAP24XX_DMA_UART2_RX], "uart2", serial_hds[0] ? serial_hds[1] : NULL); s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21), s->irq[0][OMAP_INT_24XX_UART3_IRQ], omap_findclk(s, "uart3_fclk"), omap_findclk(s, "uart3_iclk"), s->drq[OMAP24XX_DMA_UART3_TX], s->drq[OMAP24XX_DMA_UART3_RX], "uart3", serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL); s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7), s->irq[0][OMAP_INT_24XX_GPTIMER1], omap_findclk(s, "wu_gpt1_clk"), omap_findclk(s, "wu_l4_iclk")); s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8), s->irq[0][OMAP_INT_24XX_GPTIMER2], omap_findclk(s, "core_gpt2_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22), s->irq[0][OMAP_INT_24XX_GPTIMER3], omap_findclk(s, "core_gpt3_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23), s->irq[0][OMAP_INT_24XX_GPTIMER4], omap_findclk(s, "core_gpt4_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24), s->irq[0][OMAP_INT_24XX_GPTIMER5], omap_findclk(s, "core_gpt5_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25), s->irq[0][OMAP_INT_24XX_GPTIMER6], omap_findclk(s, "core_gpt6_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26), s->irq[0][OMAP_INT_24XX_GPTIMER7], omap_findclk(s, "core_gpt7_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27), s->irq[0][OMAP_INT_24XX_GPTIMER8], omap_findclk(s, "core_gpt8_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28), s->irq[0][OMAP_INT_24XX_GPTIMER9], omap_findclk(s, "core_gpt9_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29), s->irq[0][OMAP_INT_24XX_GPTIMER10], omap_findclk(s, "core_gpt10_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30), s->irq[0][OMAP_INT_24XX_GPTIMER11], omap_findclk(s, "core_gpt11_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31), s->irq[0][OMAP_INT_24XX_GPTIMER12], omap_findclk(s, "core_gpt12_clk"), omap_findclk(s, "core_l4_iclk")); omap_tap_init(omap_l4ta(s->l4, 2), s); s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s, omap_findclk(s, "clk32-kHz"), omap_findclk(s, "core_l4_iclk")); s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5), s->irq[0][OMAP_INT_24XX_I2C1_IRQ], &s->drq[OMAP24XX_DMA_I2C1_TX], omap_findclk(s, "i2c1.fclk"), omap_findclk(s, "i2c1.iclk")); s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6), s->irq[0][OMAP_INT_24XX_I2C2_IRQ], &s->drq[OMAP24XX_DMA_I2C2_TX], omap_findclk(s, "i2c2.fclk"), omap_findclk(s, "i2c2.iclk")); s->gpio = qdev_create(NULL, "omap2-gpio"); qdev_prop_set_int32(s->gpio, "mpu_model", s->mpu_model); qdev_prop_set_ptr(s->gpio, "iclk", omap_findclk(s, "gpio_iclk")); qdev_prop_set_ptr(s->gpio, "fclk0", omap_findclk(s, "gpio1_dbclk")); qdev_prop_set_ptr(s->gpio, "fclk1", omap_findclk(s, "gpio2_dbclk")); qdev_prop_set_ptr(s->gpio, "fclk2", omap_findclk(s, "gpio3_dbclk")); qdev_prop_set_ptr(s->gpio, "fclk3", omap_findclk(s, "gpio4_dbclk")); if (s->mpu_model == omap2430) { qdev_prop_set_ptr(s->gpio, "fclk4", omap_findclk(s, "gpio5_dbclk")); } qdev_init_nofail(s->gpio); busdev = sysbus_from_qdev(s->gpio); sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]); sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]); sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]); sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]); ta = omap_l4ta(s->l4, 3); sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1)); sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0)); sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2)); sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4)); sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5)); s->sdrc = omap_sdrc_init(0x68009000); s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ], s->drq[OMAP24XX_DMA_GPMC]); dinfo = drive_get(IF_SD, 0, 0); if (!dinfo) { fprintf(stderr, "qemu: missing SecureDigital device\n"); exit(1); } s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv, s->irq[0][OMAP_INT_24XX_MMC_IRQ], &s->drq[OMAP24XX_DMA_MMC1_TX], omap_findclk(s, "mmc_fclk"), omap_findclk(s, "mmc_iclk")); s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4, s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ], &s->drq[OMAP24XX_DMA_SPI1_TX0], omap_findclk(s, "spi1_fclk"), omap_findclk(s, "spi1_iclk")); s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2, s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ], &s->drq[OMAP24XX_DMA_SPI2_TX0], omap_findclk(s, "spi2_fclk"), omap_findclk(s, "spi2_iclk")); s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800, s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS], omap_findclk(s, "dss_clk1"), omap_findclk(s, "dss_clk2"), omap_findclk(s, "dss_54m_clk"), omap_findclk(s, "dss_l3_iclk"), omap_findclk(s, "dss_l4_iclk")); omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000, s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, "emul_ck"), serial_hds[0] && serial_hds[1] && serial_hds[2] ? serial_hds[3] : NULL); s->eac = omap_eac_init(omap_l4ta(s->l4, 32), s->irq[0][OMAP_INT_24XX_EAC_IRQ], &s->drq[OMAP24XX_DMA_EAC_AC_RD], omap_findclk(s, "func_96m_clk"), omap_findclk(s, "core_l4_iclk")); qemu_register_reset(omap2_mpu_reset, s); return s; }
--------------------------------------------- Result 540 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 277 / 65 / 198 / 540:  20%|██        | 540/2690 [1:22:41<5:29:13,  9.19s/it][Succeeded / Failed / Skipped / Total] 278 / 65 / 198 / 541:  20%|██        | 541/2690 [1:23:07<5:30:11,  9.22s/it][Succeeded / Failed / Skipped / Total] 278 / 65 / 198 / 541:  20%|██        | 542/2690 [1:23:54<5:32:33,  9.29s/it][[0 (79%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length, uint32_t opt, uint16_t myflags, Error **errp) { int rc; char name[NBD_MAX_NAME_SIZE + 1]; NBDExport *exp; uint16_t requests; uint16_t request; uint32_t namelen; bool sendname = "False" != "False"; bool blocksize = "False" != "False"; uint32_t sizes[3]; char buf[sizeof(uint64_t) + sizeof(uint16_t)]; const char *msg; if (length < sizeof(namelen) + sizeof(requests)) { msg = "overall request too short"; goto invalid; } if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) { return -EIO; } be32_to_cpus(&namelen); length -= sizeof(namelen); if (namelen > length - sizeof(requests) || (length - namelen) % 2) { msg = "name length is incorrect"; goto invalid; } if (nbd_read(client->ioc, name, namelen, errp) < 0) { return -EIO; } name[namelen] = '\0'; length -= namelen; trace_nbd_negotiate_handle_export_name_request(name); if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) { return -EIO; } be16_to_cpus(&requests); length -= sizeof(requests); trace_nbd_negotiate_handle_info_requests(requests); if (requests != length / sizeof(request)) { msg = "incorrect number of requests for overall length"; goto invalid; } while (requests--) { if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) { return -EIO; } be16_to_cpus(&request); length -= sizeof(request); trace_nbd_negotiate_handle_info_request(request, nbd_info_lookup(request)); switch (request) { case NBD_INFO_NAME: sendname = "True" == "True"; break; case NBD_INFO_BLOCK_SIZE: blocksize = "True" == "True"; break; } } exp = nbd_export_find(name); if (!exp) { return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNKNOWN, opt, errp, "export '%s' not present", name); } if (sendname) { rc = nbd_negotiate_send_info(client, opt, NBD_INFO_NAME, length, name, errp); if (rc < 0) { return rc; } } if (exp->description) { size_t len = strlen(exp->description); rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION, len, exp->description, errp); if (rc < 0) { return rc; } } sizes[0] = (opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1; sizes[1] = 4096; sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE); trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]); cpu_to_be32s(&sizes[0]); cpu_to_be32s(&sizes[1]); cpu_to_be32s(&sizes[2]); rc = nbd_negotiate_send_info(client, opt, NBD_INFO_BLOCK_SIZE, sizeof(sizes), sizes, errp); if (rc < 0) { return rc; } trace_nbd_negotiate_new_style_size_flags(exp->size, exp->nbdflags | myflags); stq_be_p(buf, exp->size); stw_be_p(buf + 8, exp->nbdflags | myflags); rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT, sizeof(buf), buf, errp); if (rc < 0) { return rc; } if (opt == NBD_OPT_INFO && !blocksize) { return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_BLOCK_SIZE_REQD, opt, errp, "request NBD_INFO_BLOCK_SIZE to " "use this export"); } rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp); if (rc < 0) { return rc; } if (opt == NBD_OPT_GO) { client->exp = exp; QTAILQ_INSERT_TAIL(&client->exp->clients, client, next); nbd_export_get(client->exp); rc = 1; } return rc; invalid: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt, errp, "%s", msg); }
--------------------------------------------- Result 541 ---------------------------------------------
[[0 (48%)]] --> [[0 (87%)]] --> Socre: 0.8708535432815552

[[[[Adv]]]]: static int scsi_req_stream_length(SCSICommand *[[cmd]], SCSIDevice *dev, uint8_t *buf) { switch (buf[0]) { case ERASE_12: case ERASE_16: [[cmd]]->xfer = 0; break; case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case WRITE_6: [[cmd]]->len = 6; [[cmd]]->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16); if (buf[1] & 0x01) { [[cmd]]->xfer *= dev->blocksize; } break; case READ_16: case READ_REVERSE_16: case VERIFY_16: case WRITE_16: [[cmd]]->len = 16; [[cmd]]->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16); if (buf[1] & 0x01) { [[cmd]]->xfer *= dev->blocksize; } break; case REWIND: case LOAD_UNLOAD: [[cmd]]->len = 6; [[cmd]]->xfer = 0; break; case SPACE_16: [[cmd]]->xfer = buf[13] | (buf[12] << 8); break; case READ_POSITION: [[cmd]]->xfer = buf[8] | (buf[7] << 8); break; case FORMAT_UNIT: [[cmd]]->xfer = buf[4] | (buf[3] << 8); break; default: return scsi_req_length([[cmd]], dev, buf); } return 0; }

[[[[Adv]]]]: static int scsi_req_stream_length(SCSICommand *[[centimetresdu]], SCSIDevice *dev, uint8_t *buf) { switch (buf[0]) { case ERASE_12: case ERASE_16: [[centimetresdu]]->xfer = 0; break; case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case WRITE_6: [[centimetresdu]]->len = 6; [[centimetresdu]]->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16); if (buf[1] & 0x01) { [[centimetresdu]]->xfer *= dev->blocksize; } break; case READ_16: case READ_REVERSE_16: case VERIFY_16: case WRITE_16: [[centimetresdu]]->len = 16; [[centimetresdu]]->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16); if (buf[1] & 0x01) { [[centimetresdu]]->xfer *= dev->blocksize; } break; case REWIND: case LOAD_UNLOAD: [[centimetresdu]]->len = 6; [[centimetresdu]]->xfer = 0; break; case SPACE_16: [[centimetresdu]]->xfer = buf[13] | (buf[12] << 8); break; case READ_POSITION: [[centimetresdu]]->xfer = buf[8] | (buf[7] << 8); break; case FORMAT_UNIT: [[centimetresdu]]->xfer = buf[4] | (buf[3] << 8); break; default: return scsi_req_length([[centimetresdu]], dev, buf); } return 0; }
--------------------------------------------- Result 542 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 279 / 65 / 198 / 542:  20%|██        | 542/2690 [1:23:54<5:32:33,  9.29s/it][Succeeded / Failed / Skipped / Total] 279 / 65 / 198 / 542:  20%|██        | 543/2690 [1:23:55<5:31:49,  9.27s/it][[0 (9%)]] --> [[0 (64%)]] --> Socre: 0.6406456828117371

[[[[Adv]]]]: static void gen_tst_cc (DisasContext *dc, TCGv [[cc]], int cond) { int [[arith_opt]], move_opt; [[arith_opt]] = arith_cc(dc) && !dc->flags_uptodate; move_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate; switch (cond) { case CC_EQ: if ([[arith_opt]] || move_opt) { int [[l1]]; [[l1]] = gen_new_label(); tcg_gen_movi_tl([[cc]], 0); tcg_gen_brcondi_tl(TCG_COND_NE, cc_result, 0, [[l1]]); tcg_gen_movi_tl([[cc]], 1); gen_set_label([[l1]]); } else { cris_evaluate_flags(dc); tcg_gen_andi_tl([[cc]], cpu_PR[PR_CCS], Z_FLAG); } break; case CC_NE: if ([[arith_opt]] || move_opt) tcg_gen_mov_tl([[cc]], cc_result); else { cris_evaluate_flags(dc); tcg_gen_xori_tl([[cc]], cpu_PR[PR_CCS], Z_FLAG); tcg_gen_andi_tl([[cc]], [[cc]], Z_FLAG); } break; case CC_CS: cris_evaluate_flags(dc); tcg_gen_andi_tl([[cc]], cpu_PR[PR_CCS], C_FLAG); break; case CC_CC: cris_evaluate_flags(dc); tcg_gen_xori_tl([[cc]], cpu_PR[PR_CCS], C_FLAG); tcg_gen_andi_tl([[cc]], [[cc]], C_FLAG); break; case CC_VS: cris_evaluate_flags(dc); tcg_gen_andi_tl([[cc]], cpu_PR[PR_CCS], V_FLAG); break; case CC_VC: cris_evaluate_flags(dc); tcg_gen_xori_tl([[cc]], cpu_PR[PR_CCS], V_FLAG); tcg_gen_andi_tl([[cc]], [[cc]], V_FLAG); break; case CC_PL: if ([[arith_opt]] || move_opt) { int bits = 31; if (dc->cc_size == 1) bits = 7; else if (dc->cc_size == 2) bits = 15; tcg_gen_shri_tl([[cc]], cc_result, bits); tcg_gen_xori_tl([[cc]], [[cc]], 1); } else { cris_evaluate_flags(dc); tcg_gen_xori_tl([[cc]], cpu_PR[PR_CCS], N_FLAG); tcg_gen_andi_tl([[cc]], [[cc]], N_FLAG); } break; case CC_MI: if ([[arith_opt]] || move_opt) { int bits = 31; if (dc->cc_size == 1) bits = 7; else if (dc->cc_size == 2) bits = 15; tcg_gen_shri_tl([[cc]], cc_result, 31); } else { cris_evaluate_flags(dc); tcg_gen_andi_tl([[cc]], cpu_PR[PR_CCS], N_FLAG); } break; case CC_LS: cris_evaluate_flags(dc); tcg_gen_andi_tl([[cc]], cpu_PR[PR_CCS], C_FLAG | Z_FLAG); break; case CC_HI: cris_evaluate_flags(dc); { TCGv tmp; tmp = tcg_temp_new(TCG_TYPE_TL); tcg_gen_xori_tl(tmp, cpu_PR[PR_CCS], C_FLAG | Z_FLAG); tcg_gen_shli_tl([[cc]], tmp, 2); tcg_gen_and_tl([[cc]], tmp, [[cc]]); tcg_gen_andi_tl([[cc]], [[cc]], Z_FLAG); tcg_temp_free(tmp); } break; case CC_GE: cris_evaluate_flags(dc); tcg_gen_shli_tl([[cc]], cpu_PR[PR_CCS], 2); tcg_gen_xor_tl([[cc]], cpu_PR[PR_CCS], [[cc]]); tcg_gen_andi_tl([[cc]], [[cc]], N_FLAG); tcg_gen_xori_tl([[cc]], [[cc]], N_FLAG); break; case CC_LT: cris_evaluate_flags(dc); tcg_gen_shli_tl([[cc]], cpu_PR[PR_CCS], 2); tcg_gen_xor_tl([[cc]], cpu_PR[PR_CCS], [[cc]]); tcg_gen_andi_tl([[cc]], [[cc]], N_FLAG); break; case CC_GT: cris_evaluate_flags(dc); { TCGv n, z; n = tcg_temp_new(TCG_TYPE_TL); z = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2); tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1); tcg_gen_xori_tl(z, z, 2); tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]); tcg_gen_xori_tl(n, n, 2); tcg_gen_and_tl([[cc]], z, n); tcg_gen_andi_tl([[cc]], [[cc]], 2); tcg_temp_free(n); tcg_temp_free(z); } break; case CC_LE: cris_evaluate_flags(dc); { TCGv n, z; n = tcg_temp_new(TCG_TYPE_TL); z = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2); tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1); tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]); tcg_gen_or_tl([[cc]], z, n); tcg_gen_andi_tl([[cc]], [[cc]], 2); tcg_temp_free(n); tcg_temp_free(z); } break; case CC_P: cris_evaluate_flags(dc); tcg_gen_andi_tl([[cc]], cpu_PR[PR_CCS], P_FLAG); break; case CC_A: tcg_gen_movi_tl([[cc]], 1); break; default: BUG(); break; }; }

[[[[Adv]]]]: static void gen_tst_cc (DisasContext *dc, TCGv [[neck]], int cond) { int [[有h_adjust]], move_opt; [[有h_adjust]] = arith_cc(dc) && !dc->flags_uptodate; move_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate; switch (cond) { case CC_EQ: if ([[有h_adjust]] || move_opt) { int [[coloreds]]; [[coloreds]] = gen_new_label(); tcg_gen_movi_tl([[neck]], 0); tcg_gen_brcondi_tl(TCG_COND_NE, cc_result, 0, [[coloreds]]); tcg_gen_movi_tl([[neck]], 1); gen_set_label([[coloreds]]); } else { cris_evaluate_flags(dc); tcg_gen_andi_tl([[neck]], cpu_PR[PR_CCS], Z_FLAG); } break; case CC_NE: if ([[有h_adjust]] || move_opt) tcg_gen_mov_tl([[neck]], cc_result); else { cris_evaluate_flags(dc); tcg_gen_xori_tl([[neck]], cpu_PR[PR_CCS], Z_FLAG); tcg_gen_andi_tl([[neck]], [[neck]], Z_FLAG); } break; case CC_CS: cris_evaluate_flags(dc); tcg_gen_andi_tl([[neck]], cpu_PR[PR_CCS], C_FLAG); break; case CC_CC: cris_evaluate_flags(dc); tcg_gen_xori_tl([[neck]], cpu_PR[PR_CCS], C_FLAG); tcg_gen_andi_tl([[neck]], [[neck]], C_FLAG); break; case CC_VS: cris_evaluate_flags(dc); tcg_gen_andi_tl([[neck]], cpu_PR[PR_CCS], V_FLAG); break; case CC_VC: cris_evaluate_flags(dc); tcg_gen_xori_tl([[neck]], cpu_PR[PR_CCS], V_FLAG); tcg_gen_andi_tl([[neck]], [[neck]], V_FLAG); break; case CC_PL: if ([[有h_adjust]] || move_opt) { int bits = 31; if (dc->cc_size == 1) bits = 7; else if (dc->cc_size == 2) bits = 15; tcg_gen_shri_tl([[neck]], cc_result, bits); tcg_gen_xori_tl([[neck]], [[neck]], 1); } else { cris_evaluate_flags(dc); tcg_gen_xori_tl([[neck]], cpu_PR[PR_CCS], N_FLAG); tcg_gen_andi_tl([[neck]], [[neck]], N_FLAG); } break; case CC_MI: if ([[有h_adjust]] || move_opt) { int bits = 31; if (dc->cc_size == 1) bits = 7; else if (dc->cc_size == 2) bits = 15; tcg_gen_shri_tl([[neck]], cc_result, 31); } else { cris_evaluate_flags(dc); tcg_gen_andi_tl([[neck]], cpu_PR[PR_CCS], N_FLAG); } break; case CC_LS: cris_evaluate_flags(dc); tcg_gen_andi_tl([[neck]], cpu_PR[PR_CCS], C_FLAG | Z_FLAG); break; case CC_HI: cris_evaluate_flags(dc); { TCGv tmp; tmp = tcg_temp_new(TCG_TYPE_TL); tcg_gen_xori_tl(tmp, cpu_PR[PR_CCS], C_FLAG | Z_FLAG); tcg_gen_shli_tl([[neck]], tmp, 2); tcg_gen_and_tl([[neck]], tmp, [[neck]]); tcg_gen_andi_tl([[neck]], [[neck]], Z_FLAG); tcg_temp_free(tmp); } break; case CC_GE: cris_evaluate_flags(dc); tcg_gen_shli_tl([[neck]], cpu_PR[PR_CCS], 2); tcg_gen_xor_tl([[neck]], cpu_PR[PR_CCS], [[neck]]); tcg_gen_andi_tl([[neck]], [[neck]], N_FLAG); tcg_gen_xori_tl([[neck]], [[neck]], N_FLAG); break; case CC_LT: cris_evaluate_flags(dc); tcg_gen_shli_tl([[neck]], cpu_PR[PR_CCS], 2); tcg_gen_xor_tl([[neck]], cpu_PR[PR_CCS], [[neck]]); tcg_gen_andi_tl([[neck]], [[neck]], N_FLAG); break; case CC_GT: cris_evaluate_flags(dc); { TCGv n, z; n = tcg_temp_new(TCG_TYPE_TL); z = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2); tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1); tcg_gen_xori_tl(z, z, 2); tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]); tcg_gen_xori_tl(n, n, 2); tcg_gen_and_tl([[neck]], z, n); tcg_gen_andi_tl([[neck]], [[neck]], 2); tcg_temp_free(n); tcg_temp_free(z); } break; case CC_LE: cris_evaluate_flags(dc); { TCGv n, z; n = tcg_temp_new(TCG_TYPE_TL); z = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2); tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1); tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]); tcg_gen_or_tl([[neck]], z, n); tcg_gen_andi_tl([[neck]], [[neck]], 2); tcg_temp_free(n); tcg_temp_free(z); } break; case CC_P: cris_evaluate_flags(dc); tcg_gen_andi_tl([[neck]], cpu_PR[PR_CCS], P_FLAG); break; case CC_A: tcg_gen_movi_tl([[neck]], 1); break; default: BUG(); break; }; }
--------------------------------------------- Result 543 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 280 / 65 / 198 / 543:  20%|██        | 543/2690 [1:23:55<5:31:49,  9.27s/it][Succeeded / Failed / Skipped / Total] 280 / 65 / 198 / 543:  20%|██        | 544/2690 [1:23:55<5:31:06,  9.26s/it][Succeeded / Failed / Skipped / Total] 280 / 65 / 199 / 544:  20%|██        | 544/2690 [1:23:55<5:31:06,  9.26s/it][Succeeded / Failed / Skipped / Total] 280 / 65 / 199 / 544:  20%|██        | 545/2690 [1:24:03<5:30:48,  9.25s/it][[0 (85%)]] --> [[0 (45%)]] --> Socre: 0.5472202003002167

[[[[Adv]]]]: static float get_band_cost_UPAIR7_mips(struct AACEncContext *s, PutBitContext *pb, const float *[[in]], const float *[[scaled]], int size, int scale_idx, int [[cb]], const float lambda, const float uplim, int *bits) { const float [[Q34]] = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float IQ = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; int i; float cost = 0; int qc1, qc2, qc3, qc4; int curbits = 0; uint8_t *p_bits = (uint8_t *)ff_aac_spectral_bits[[[cb]]-1]; float *p_codes = (float *)ff_aac_codebook_vectors[[[cb]]-1]; for (i = 0; i < size; i += 4) { const float *vec, *vec2; int curidx, curidx2, sign1, count1, sign2, count2; int *in_int = (int *)&[[in]][i]; float *in_pos = (float *)&[[in]][i]; float di0, di1, di2, di3; int t0, t1, t2, t3, t4; qc1 = [[scaled]][i ] * [[Q34]] + ROUND_STANDARD; qc2 = [[scaled]][i+1] * [[Q34]] + ROUND_STANDARD; qc3 = [[scaled]][i+2] * [[Q34]] + ROUND_STANDARD; qc4 = [[scaled]][i+3] * [[Q34]] + ROUND_STANDARD; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "ori %[t4], $zero, 7 \n\t" "ori %[sign1], $zero, 0 \n\t" "ori %[sign2], $zero, 0 \n\t" "slt %[t0], %[t4], %[qc1] \n\t" "slt %[t1], %[t4], %[qc2] \n\t" "slt %[t2], %[t4], %[qc3] \n\t" "slt %[t3], %[t4], %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t4], %[t1] \n\t" "movn %[qc3], %[t4], %[t2] \n\t" "movn %[qc4], %[t4], %[t3] \n\t" "lw %[t0], 0(%[in_int]) \n\t" "lw %[t1], 4(%[in_int]) \n\t" "lw %[t2], 8(%[in_int]) \n\t" "lw %[t3], 12(%[in_int]) \n\t" "slt %[t0], %[t0], $zero \n\t" "movn %[sign1], %[t0], %[qc1] \n\t" "slt %[t2], %[t2], $zero \n\t" "movn %[sign2], %[t2], %[qc3] \n\t" "slt %[t1], %[t1], $zero \n\t" "sll %[t0], %[sign1], 1 \n\t" "or %[t0], %[t0], %[t1] \n\t" "movn %[sign1], %[t0], %[qc2] \n\t" "slt %[t3], %[t3], $zero \n\t" "sll %[t0], %[sign2], 1 \n\t" "or %[t0], %[t0], %[t3] \n\t" "movn %[sign2], %[t0], %[qc4] \n\t" "slt %[count1], $zero, %[qc1] \n\t" "slt %[t1], $zero, %[qc2] \n\t" "slt %[count2], $zero, %[qc3] \n\t" "slt %[t2], $zero, %[qc4] \n\t" "addu %[count1], %[count1], %[t1] \n\t" "addu %[count2], %[count2], %[t2] \n\t" ".set pop \n\t" : [qc1]"+r"(qc1), [qc2]"+r"(qc2), [qc3]"+r"(qc3), [qc4]"+r"(qc4), [sign1]"=&r"(sign1), [count1]"=&r"(count1), [sign2]"=&r"(sign2), [count2]"=&r"(count2), [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"=&r"(t2), [t3]"=&r"(t3), [t4]"=&r"(t4) : [in_int]"r"(in_int) : "memory" ); curidx = 8 * qc1; curidx += qc2; curidx2 = 8 * qc3; curidx2 += qc4; curbits += p_bits[curidx]; curbits += upair7_sign_bits[curidx]; vec = &p_codes[curidx*2]; curbits += p_bits[curidx2]; curbits += upair7_sign_bits[curidx2]; vec2 = &p_codes[curidx2*2]; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "lwc1 %[di0], 0(%[in_pos]) \n\t" "lwc1 %[di1], 4(%[in_pos]) \n\t" "lwc1 %[di2], 8(%[in_pos]) \n\t" "lwc1 %[di3], 12(%[in_pos]) \n\t" "abs.s %[di0], %[di0] \n\t" "abs.s %[di1], %[di1] \n\t" "abs.s %[di2], %[di2] \n\t" "abs.s %[di3], %[di3] \n\t" "lwc1 $f0, 0(%[vec]) \n\t" "lwc1 $f1, 4(%[vec]) \n\t" "lwc1 $f2, 0(%[vec2]) \n\t" "lwc1 $f3, 4(%[vec2]) \n\t" "nmsub.s %[di0], %[di0], $f0, %[IQ] \n\t" "nmsub.s %[di1], %[di1], $f1, %[IQ] \n\t" "nmsub.s %[di2], %[di2], $f2, %[IQ] \n\t" "nmsub.s %[di3], %[di3], $f3, %[IQ] \n\t" ".set pop \n\t" : [di0]"=&f"(di0), [di1]"=&f"(di1), [di2]"=&f"(di2), [di3]"=&f"(di3) : [in_pos]"r"(in_pos), [vec]"r"(vec), [vec2]"r"(vec2), [IQ]"f"(IQ) : "$f0", "$f1", "$f2", "$f3", "memory" ); cost += di0 * di0 + di1 * di1 + di2 * di2 + di3 * di3; } if (bits) *bits = curbits; return cost * lambda + curbits; }

[[[[Adv]]]]: static float get_band_cost_UPAIR7_mips(struct AACEncContext *s, PutBitContext *pb, const float *[[ins]], const float *[[mobile]], int size, int scale_idx, int [[brass]], const float lambda, const float uplim, int *bits) { const float [[wk13]] = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float IQ = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; int i; float cost = 0; int qc1, qc2, qc3, qc4; int curbits = 0; uint8_t *p_bits = (uint8_t *)ff_aac_spectral_bits[[[brass]]-1]; float *p_codes = (float *)ff_aac_codebook_vectors[[[brass]]-1]; for (i = 0; i < size; i += 4) { const float *vec, *vec2; int curidx, curidx2, sign1, count1, sign2, count2; int *in_int = (int *)&[[ins]][i]; float *in_pos = (float *)&[[ins]][i]; float di0, di1, di2, di3; int t0, t1, t2, t3, t4; qc1 = [[mobile]][i ] * [[wk13]] + ROUND_STANDARD; qc2 = [[mobile]][i+1] * [[wk13]] + ROUND_STANDARD; qc3 = [[mobile]][i+2] * [[wk13]] + ROUND_STANDARD; qc4 = [[mobile]][i+3] * [[wk13]] + ROUND_STANDARD; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "ori %[t4], $zero, 7 \n\t" "ori %[sign1], $zero, 0 \n\t" "ori %[sign2], $zero, 0 \n\t" "slt %[t0], %[t4], %[qc1] \n\t" "slt %[t1], %[t4], %[qc2] \n\t" "slt %[t2], %[t4], %[qc3] \n\t" "slt %[t3], %[t4], %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t4], %[t1] \n\t" "movn %[qc3], %[t4], %[t2] \n\t" "movn %[qc4], %[t4], %[t3] \n\t" "lw %[t0], 0(%[in_int]) \n\t" "lw %[t1], 4(%[in_int]) \n\t" "lw %[t2], 8(%[in_int]) \n\t" "lw %[t3], 12(%[in_int]) \n\t" "slt %[t0], %[t0], $zero \n\t" "movn %[sign1], %[t0], %[qc1] \n\t" "slt %[t2], %[t2], $zero \n\t" "movn %[sign2], %[t2], %[qc3] \n\t" "slt %[t1], %[t1], $zero \n\t" "sll %[t0], %[sign1], 1 \n\t" "or %[t0], %[t0], %[t1] \n\t" "movn %[sign1], %[t0], %[qc2] \n\t" "slt %[t3], %[t3], $zero \n\t" "sll %[t0], %[sign2], 1 \n\t" "or %[t0], %[t0], %[t3] \n\t" "movn %[sign2], %[t0], %[qc4] \n\t" "slt %[count1], $zero, %[qc1] \n\t" "slt %[t1], $zero, %[qc2] \n\t" "slt %[count2], $zero, %[qc3] \n\t" "slt %[t2], $zero, %[qc4] \n\t" "addu %[count1], %[count1], %[t1] \n\t" "addu %[count2], %[count2], %[t2] \n\t" ".set pop \n\t" : [qc1]"+r"(qc1), [qc2]"+r"(qc2), [qc3]"+r"(qc3), [qc4]"+r"(qc4), [sign1]"=&r"(sign1), [count1]"=&r"(count1), [sign2]"=&r"(sign2), [count2]"=&r"(count2), [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"=&r"(t2), [t3]"=&r"(t3), [t4]"=&r"(t4) : [in_int]"r"(in_int) : "memory" ); curidx = 8 * qc1; curidx += qc2; curidx2 = 8 * qc3; curidx2 += qc4; curbits += p_bits[curidx]; curbits += upair7_sign_bits[curidx]; vec = &p_codes[curidx*2]; curbits += p_bits[curidx2]; curbits += upair7_sign_bits[curidx2]; vec2 = &p_codes[curidx2*2]; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "lwc1 %[di0], 0(%[in_pos]) \n\t" "lwc1 %[di1], 4(%[in_pos]) \n\t" "lwc1 %[di2], 8(%[in_pos]) \n\t" "lwc1 %[di3], 12(%[in_pos]) \n\t" "abs.s %[di0], %[di0] \n\t" "abs.s %[di1], %[di1] \n\t" "abs.s %[di2], %[di2] \n\t" "abs.s %[di3], %[di3] \n\t" "lwc1 $f0, 0(%[vec]) \n\t" "lwc1 $f1, 4(%[vec]) \n\t" "lwc1 $f2, 0(%[vec2]) \n\t" "lwc1 $f3, 4(%[vec2]) \n\t" "nmsub.s %[di0], %[di0], $f0, %[IQ] \n\t" "nmsub.s %[di1], %[di1], $f1, %[IQ] \n\t" "nmsub.s %[di2], %[di2], $f2, %[IQ] \n\t" "nmsub.s %[di3], %[di3], $f3, %[IQ] \n\t" ".set pop \n\t" : [di0]"=&f"(di0), [di1]"=&f"(di1), [di2]"=&f"(di2), [di3]"=&f"(di3) : [in_pos]"r"(in_pos), [vec]"r"(vec), [vec2]"r"(vec2), [IQ]"f"(IQ) : "$f0", "$f1", "$f2", "$f3", "memory" ); cost += di0 * di0 + di1 * di1 + di2 * di2 + di3 * di3; } if (bits) *bits = curbits; return cost * lambda + curbits; }
--------------------------------------------- Result 544 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model, const char *default_devaddr) { const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr; PCIDevice *pci_dev; DeviceState *dev; int i; i = qemu_check_nic_model_list(nd, pci_nic_models, default_model); pci_dev = pci_create(pci_nic_names[i], devaddr); dev = &pci_dev->qdev; if (nd->id) dev->id = qemu_strdup(nd->id); dev->nd = nd; qdev_init(dev); nd->private = dev; return pci_dev; }
--------------------------------------------- Result 545 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 280 / 66 / 199 / 545:  20%|██        | 545/2690 [1:24:03<5:30:48,  9.25s/it][Succeeded / Failed / Skipped / Total] 280 / 66 / 199 / 545:  20%|██        | 546/2690 [1:24:39<5:32:25,  9.30s/it][Succeeded / Failed / Skipped / Total] 281 / 66 / 199 / 546:  20%|██        | 546/2690 [1:24:39<5:32:25,  9.30s/it][Succeeded / Failed / Skipped / Total] 281 / 66 / 199 / 546:  20%|██        | 547/2690 [1:24:39<5:31:41,  9.29s/it][Succeeded / Failed / Skipped / Total] 281 / 66 / 200 / 547:  20%|██        | 547/2690 [1:24:39<5:31:41,  9.29s/it][Succeeded / Failed / Skipped / Total] 281 / 66 / 200 / 547:  20%|██        | 548/2690 [1:24:49<5:31:33,  9.29s/it][[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void tcg_out_qemu_ld_slow_path (TCGContext *[[s]], TCGLabelQemuLdst *[[label]]) { int [[s_bits]]; int ir; int opc = [[label]]->opc; int mem_index = [[label]]->mem_index; int [[data_reg]] = [[label]]->datalo_reg; int [[data_reg2]] = [[label]]->datahi_reg; int addr_reg = [[label]]->addrlo_reg; uint8_t *raddr = [[label]]->raddr; uint8_t **label_ptr = &[[label]]->label_ptr[0]; [[s_bits]] = opc & 3; reloc_pc14 (label_ptr[0], (tcg_target_long) [[s]]->code_ptr); ir = 3; tcg_out_mov ([[s]], TCG_TYPE_I32, ir++, TCG_AREG0); #if TARGET_LONG_BITS == 32 tcg_out_mov ([[s]], TCG_TYPE_I32, ir++, addr_reg); #else #ifdef TCG_TARGET_CALL_ALIGN_ARGS ir |= 1; #endif tcg_out_mov ([[s]], TCG_TYPE_I32, ir++, [[label]]->addrhi_reg); tcg_out_mov ([[s]], TCG_TYPE_I32, ir++, addr_reg); #endif tcg_out_movi ([[s]], TCG_TYPE_I32, ir, mem_index); tcg_out_call ([[s]], (tcg_target_long) qemu_ld_helpers[[[s_bits]]], 1); tcg_out32 ([[s]], B | 8); tcg_out32 ([[s]], (tcg_target_long) raddr); switch (opc) { case 0|4: tcg_out32 ([[s]], EXTSB | RA ([[data_reg]]) | RS (3)); break; case 1|4: tcg_out32 ([[s]], EXTSH | RA ([[data_reg]]) | RS (3)); break; case 0: case 1: case 2: if ([[data_reg]] != 3) tcg_out_mov ([[s]], TCG_TYPE_I32, [[data_reg]], 3); break; case 3: if ([[data_reg]] == 3) { if ([[data_reg2]] == 4) { tcg_out_mov ([[s]], TCG_TYPE_I32, 0, 4); tcg_out_mov ([[s]], TCG_TYPE_I32, 4, 3); tcg_out_mov ([[s]], TCG_TYPE_I32, 3, 0); } else { tcg_out_mov ([[s]], TCG_TYPE_I32, [[data_reg2]], 3); tcg_out_mov ([[s]], TCG_TYPE_I32, 3, 4); } } else { if ([[data_reg]] != 4) tcg_out_mov ([[s]], TCG_TYPE_I32, [[data_reg]], 4); if ([[data_reg2]] != 3) tcg_out_mov ([[s]], TCG_TYPE_I32, [[data_reg2]], 3); } break; } tcg_out_b ([[s]], 0, (tcg_target_long) raddr); }

[[[[Adv]]]]: static void tcg_out_qemu_ld_slow_path (TCGContext *[[d]], TCGLabelQemuLdst *[[word]]) { int [[readsـvoices]]; int ir; int opc = [[word]]->opc; int mem_index = [[word]]->mem_index; int [[d²index]] = [[word]]->datalo_reg; int [[akperroundb]] = [[word]]->datahi_reg; int addr_reg = [[word]]->addrlo_reg; uint8_t *raddr = [[word]]->raddr; uint8_t **label_ptr = &[[word]]->label_ptr[0]; [[readsـvoices]] = opc & 3; reloc_pc14 (label_ptr[0], (tcg_target_long) [[d]]->code_ptr); ir = 3; tcg_out_mov ([[d]], TCG_TYPE_I32, ir++, TCG_AREG0); #if TARGET_LONG_BITS == 32 tcg_out_mov ([[d]], TCG_TYPE_I32, ir++, addr_reg); #else #ifdef TCG_TARGET_CALL_ALIGN_ARGS ir |= 1; #endif tcg_out_mov ([[d]], TCG_TYPE_I32, ir++, [[word]]->addrhi_reg); tcg_out_mov ([[d]], TCG_TYPE_I32, ir++, addr_reg); #endif tcg_out_movi ([[d]], TCG_TYPE_I32, ir, mem_index); tcg_out_call ([[d]], (tcg_target_long) qemu_ld_helpers[[[readsـvoices]]], 1); tcg_out32 ([[d]], B | 8); tcg_out32 ([[d]], (tcg_target_long) raddr); switch (opc) { case 0|4: tcg_out32 ([[d]], EXTSB | RA ([[d²index]]) | RS (3)); break; case 1|4: tcg_out32 ([[d]], EXTSH | RA ([[d²index]]) | RS (3)); break; case 0: case 1: case 2: if ([[d²index]] != 3) tcg_out_mov ([[d]], TCG_TYPE_I32, [[d²index]], 3); break; case 3: if ([[d²index]] == 3) { if ([[akperroundb]] == 4) { tcg_out_mov ([[d]], TCG_TYPE_I32, 0, 4); tcg_out_mov ([[d]], TCG_TYPE_I32, 4, 3); tcg_out_mov ([[d]], TCG_TYPE_I32, 3, 0); } else { tcg_out_mov ([[d]], TCG_TYPE_I32, [[akperroundb]], 3); tcg_out_mov ([[d]], TCG_TYPE_I32, 3, 4); } } else { if ([[d²index]] != 4) tcg_out_mov ([[d]], TCG_TYPE_I32, [[d²index]], 4); if ([[akperroundb]] != 3) tcg_out_mov ([[d]], TCG_TYPE_I32, [[akperroundb]], 3); } break; } tcg_out_b ([[d]], 0, (tcg_target_long) raddr); }
--------------------------------------------- Result 546 ---------------------------------------------
[[0 (84%)]] --> [[0 (23%)]] --> Socre: 0.767124593257904

[[[[Adv]]]]: void ff_mlp_init_x86(DSPContext* [[c]], AVCodecContext *[[avctx]]) { #if HAVE_7REGS && HAVE_TEN_OPERANDS [[c]]->mlp_filter_channel = mlp_filter_channel_x86; #endif }

[[[[Adv]]]]: void ff_mlp_init_x86(DSPContext* [[string]], AVCodecContext *[[ixit6]]) { #if HAVE_7REGS && HAVE_TEN_OPERANDS [[string]]->mlp_filter_channel = mlp_filter_channel_x86; #endif }
--------------------------------------------- Result 547 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_h264_flush_change(H264Context *h) { int i, j; h->next_outputed_poc = INT_MIN; h->prev_interlaced_frame = 1; idr(h); h->poc.prev_frame_num = -1; if (h->cur_pic_ptr) { h->cur_pic_ptr->reference = 0; for (j=i=0; h->delayed_pic[i]; i++) if (h->delayed_pic[i] != h->cur_pic_ptr) h->delayed_pic[j++] = h->delayed_pic[i]; h->delayed_pic[j] = NULL; } ff_h264_unref_picture(h, &h->last_pic_for_ec); h->first_field = 0; ff_h264_sei_uninit(&h->sei); h->recovery_frame = -1; h->frame_recovered = 0; h->current_slice = 0; h->mmco_reset = 1; for (i = 0; i < h->nb_slice_ctx; i++) h->slice_ctx[i].list_count = 0; }
--------------------------------------------- Result 548 ---------------------------------------------
[[0 (40%)]] --> [[0 (65%)]] --> Socre: 0.6451791524887085

[[[[Adv]]]]: void do_smm_enter(X86CPU *cpu) { CPUX86State *[[env]] = &cpu->env; CPUState *[[cs]] = CPU(cpu); target_ulong sm_state; SegmentCache *dt; int i, offset; qemu_log_mask(CPU_LOG_INT, "SMM: enter\n"); log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP); [[env]]->hflags |= HF_SMM_MASK; if ([[env]]->hflags2 & HF2_NMI_MASK) { [[env]]->hflags2 |= HF2_SMM_INSIDE_NMI_MASK; } else { [[env]]->hflags2 |= HF2_NMI_MASK; } cpu_smm_update([[env]]); sm_state = [[env]]->smbase + 0x8000; #ifdef TARGET_X86_64 for (i = 0; i < 6; i++) { dt = &[[env]]->segs[i]; offset = 0x7e00 + i * 16; x86_stw_phys([[cs]], sm_state + offset, dt->selector); x86_stw_phys([[cs]], sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff); x86_stl_phys([[cs]], sm_state + offset + 4, dt->limit); x86_stq_phys([[cs]], sm_state + offset + 8, dt->base); } x86_stq_phys([[cs]], sm_state + 0x7e68, [[env]]->gdt.base); x86_stl_phys([[cs]], sm_state + 0x7e64, [[env]]->gdt.limit); x86_stw_phys([[cs]], sm_state + 0x7e70, [[env]]->ldt.selector); x86_stq_phys([[cs]], sm_state + 0x7e78, [[env]]->ldt.base); x86_stl_phys([[cs]], sm_state + 0x7e74, [[env]]->ldt.limit); x86_stw_phys([[cs]], sm_state + 0x7e72, ([[env]]->ldt.flags >> 8) & 0xf0ff); x86_stq_phys([[cs]], sm_state + 0x7e88, [[env]]->idt.base); x86_stl_phys([[cs]], sm_state + 0x7e84, [[env]]->idt.limit); x86_stw_phys([[cs]], sm_state + 0x7e90, [[env]]->tr.selector); x86_stq_phys([[cs]], sm_state + 0x7e98, [[env]]->tr.base); x86_stl_phys([[cs]], sm_state + 0x7e94, [[env]]->tr.limit); x86_stw_phys([[cs]], sm_state + 0x7e92, ([[env]]->tr.flags >> 8) & 0xf0ff); x86_stq_phys([[cs]], sm_state + 0x7ed0, [[env]]->efer); x86_stq_phys([[cs]], sm_state + 0x7ff8, [[env]]->regs[R_EAX]); x86_stq_phys([[cs]], sm_state + 0x7ff0, [[env]]->regs[R_ECX]); x86_stq_phys([[cs]], sm_state + 0x7fe8, [[env]]->regs[R_EDX]); x86_stq_phys([[cs]], sm_state + 0x7fe0, [[env]]->regs[R_EBX]); x86_stq_phys([[cs]], sm_state + 0x7fd8, [[env]]->regs[R_ESP]); x86_stq_phys([[cs]], sm_state + 0x7fd0, [[env]]->regs[R_EBP]); x86_stq_phys([[cs]], sm_state + 0x7fc8, [[env]]->regs[R_ESI]); x86_stq_phys([[cs]], sm_state + 0x7fc0, [[env]]->regs[R_EDI]); for (i = 8; i < 16; i++) { x86_stq_phys([[cs]], sm_state + 0x7ff8 - i * 8, [[env]]->regs[i]); } x86_stq_phys([[cs]], sm_state + 0x7f78, [[env]]->eip); x86_stl_phys([[cs]], sm_state + 0x7f70, cpu_compute_eflags([[env]])); x86_stl_phys([[cs]], sm_state + 0x7f68, [[env]]->dr[6]); x86_stl_phys([[cs]], sm_state + 0x7f60, [[env]]->dr[7]); x86_stl_phys([[cs]], sm_state + 0x7f48, [[env]]->cr[4]); x86_stq_phys([[cs]], sm_state + 0x7f50, [[env]]->cr[3]); x86_stl_phys([[cs]], sm_state + 0x7f58, [[env]]->cr[0]); x86_stl_phys([[cs]], sm_state + 0x7efc, SMM_REVISION_ID); x86_stl_phys([[cs]], sm_state + 0x7f00, [[env]]->smbase); #else x86_stl_phys([[cs]], sm_state + 0x7ffc, [[env]]->cr[0]); x86_stl_phys([[cs]], sm_state + 0x7ff8, [[env]]->cr[3]); x86_stl_phys([[cs]], sm_state + 0x7ff4, cpu_compute_eflags([[env]])); x86_stl_phys([[cs]], sm_state + 0x7ff0, [[env]]->eip); x86_stl_phys([[cs]], sm_state + 0x7fec, [[env]]->regs[R_EDI]); x86_stl_phys([[cs]], sm_state + 0x7fe8, [[env]]->regs[R_ESI]); x86_stl_phys([[cs]], sm_state + 0x7fe4, [[env]]->regs[R_EBP]); x86_stl_phys([[cs]], sm_state + 0x7fe0, [[env]]->regs[R_ESP]); x86_stl_phys([[cs]], sm_state + 0x7fdc, [[env]]->regs[R_EBX]); x86_stl_phys([[cs]], sm_state + 0x7fd8, [[env]]->regs[R_EDX]); x86_stl_phys([[cs]], sm_state + 0x7fd4, [[env]]->regs[R_ECX]); x86_stl_phys([[cs]], sm_state + 0x7fd0, [[env]]->regs[R_EAX]); x86_stl_phys([[cs]], sm_state + 0x7fcc, [[env]]->dr[6]); x86_stl_phys([[cs]], sm_state + 0x7fc8, [[env]]->dr[7]); x86_stl_phys([[cs]], sm_state + 0x7fc4, [[env]]->tr.selector); x86_stl_phys([[cs]], sm_state + 0x7f64, [[env]]->tr.base); x86_stl_phys([[cs]], sm_state + 0x7f60, [[env]]->tr.limit); x86_stl_phys([[cs]], sm_state + 0x7f5c, ([[env]]->tr.flags >> 8) & 0xf0ff); x86_stl_phys([[cs]], sm_state + 0x7fc0, [[env]]->ldt.selector); x86_stl_phys([[cs]], sm_state + 0x7f80, [[env]]->ldt.base); x86_stl_phys([[cs]], sm_state + 0x7f7c, [[env]]->ldt.limit); x86_stl_phys([[cs]], sm_state + 0x7f78, ([[env]]->ldt.flags >> 8) & 0xf0ff); x86_stl_phys([[cs]], sm_state + 0x7f74, [[env]]->gdt.base); x86_stl_phys([[cs]], sm_state + 0x7f70, [[env]]->gdt.limit); x86_stl_phys([[cs]], sm_state + 0x7f58, [[env]]->idt.base); x86_stl_phys([[cs]], sm_state + 0x7f54, [[env]]->idt.limit); for (i = 0; i < 6; i++) { dt = &[[env]]->segs[i]; if (i < 3) { offset = 0x7f84 + i * 12; } else { offset = 0x7f2c + (i - 3) * 12; } x86_stl_phys([[cs]], sm_state + 0x7fa8 + i * 4, dt->selector); x86_stl_phys([[cs]], sm_state + offset + 8, dt->base); x86_stl_phys([[cs]], sm_state + offset + 4, dt->limit); x86_stl_phys([[cs]], sm_state + offset, (dt->flags >> 8) & 0xf0ff); } x86_stl_phys([[cs]], sm_state + 0x7f14, [[env]]->cr[4]); x86_stl_phys([[cs]], sm_state + 0x7efc, SMM_REVISION_ID); x86_stl_phys([[cs]], sm_state + 0x7ef8, [[env]]->smbase); #endif #ifdef TARGET_X86_64 cpu_load_efer([[env]], 0); #endif cpu_load_eflags([[env]], 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C | DF_MASK)); [[env]]->eip = 0x00008000; cpu_x86_update_cr0([[env]], [[env]]->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK | CR0_PG_MASK)); cpu_x86_update_cr4([[env]], 0); [[env]]->dr[7] = 0x00000400; cpu_x86_load_seg_cache([[env]], R_CS, ([[env]]->smbase >> 4) & 0xffff, [[env]]->smbase, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[env]], R_DS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[env]], R_ES, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[env]], R_SS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[env]], R_FS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[env]], R_GS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); }

[[[[Adv]]]]: void do_smm_enter(X86CPU *cpu) { CPUX86State *[[naов]] = &cpu->env; CPUState *[[saga]] = CPU(cpu); target_ulong sm_state; SegmentCache *dt; int i, offset; qemu_log_mask(CPU_LOG_INT, "SMM: enter\n"); log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP); [[naов]]->hflags |= HF_SMM_MASK; if ([[naов]]->hflags2 & HF2_NMI_MASK) { [[naов]]->hflags2 |= HF2_SMM_INSIDE_NMI_MASK; } else { [[naов]]->hflags2 |= HF2_NMI_MASK; } cpu_smm_update([[naов]]); sm_state = [[naов]]->smbase + 0x8000; #ifdef TARGET_X86_64 for (i = 0; i < 6; i++) { dt = &[[naов]]->segs[i]; offset = 0x7e00 + i * 16; x86_stw_phys([[saga]], sm_state + offset, dt->selector); x86_stw_phys([[saga]], sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff); x86_stl_phys([[saga]], sm_state + offset + 4, dt->limit); x86_stq_phys([[saga]], sm_state + offset + 8, dt->base); } x86_stq_phys([[saga]], sm_state + 0x7e68, [[naов]]->gdt.base); x86_stl_phys([[saga]], sm_state + 0x7e64, [[naов]]->gdt.limit); x86_stw_phys([[saga]], sm_state + 0x7e70, [[naов]]->ldt.selector); x86_stq_phys([[saga]], sm_state + 0x7e78, [[naов]]->ldt.base); x86_stl_phys([[saga]], sm_state + 0x7e74, [[naов]]->ldt.limit); x86_stw_phys([[saga]], sm_state + 0x7e72, ([[naов]]->ldt.flags >> 8) & 0xf0ff); x86_stq_phys([[saga]], sm_state + 0x7e88, [[naов]]->idt.base); x86_stl_phys([[saga]], sm_state + 0x7e84, [[naов]]->idt.limit); x86_stw_phys([[saga]], sm_state + 0x7e90, [[naов]]->tr.selector); x86_stq_phys([[saga]], sm_state + 0x7e98, [[naов]]->tr.base); x86_stl_phys([[saga]], sm_state + 0x7e94, [[naов]]->tr.limit); x86_stw_phys([[saga]], sm_state + 0x7e92, ([[naов]]->tr.flags >> 8) & 0xf0ff); x86_stq_phys([[saga]], sm_state + 0x7ed0, [[naов]]->efer); x86_stq_phys([[saga]], sm_state + 0x7ff8, [[naов]]->regs[R_EAX]); x86_stq_phys([[saga]], sm_state + 0x7ff0, [[naов]]->regs[R_ECX]); x86_stq_phys([[saga]], sm_state + 0x7fe8, [[naов]]->regs[R_EDX]); x86_stq_phys([[saga]], sm_state + 0x7fe0, [[naов]]->regs[R_EBX]); x86_stq_phys([[saga]], sm_state + 0x7fd8, [[naов]]->regs[R_ESP]); x86_stq_phys([[saga]], sm_state + 0x7fd0, [[naов]]->regs[R_EBP]); x86_stq_phys([[saga]], sm_state + 0x7fc8, [[naов]]->regs[R_ESI]); x86_stq_phys([[saga]], sm_state + 0x7fc0, [[naов]]->regs[R_EDI]); for (i = 8; i < 16; i++) { x86_stq_phys([[saga]], sm_state + 0x7ff8 - i * 8, [[naов]]->regs[i]); } x86_stq_phys([[saga]], sm_state + 0x7f78, [[naов]]->eip); x86_stl_phys([[saga]], sm_state + 0x7f70, cpu_compute_eflags([[naов]])); x86_stl_phys([[saga]], sm_state + 0x7f68, [[naов]]->dr[6]); x86_stl_phys([[saga]], sm_state + 0x7f60, [[naов]]->dr[7]); x86_stl_phys([[saga]], sm_state + 0x7f48, [[naов]]->cr[4]); x86_stq_phys([[saga]], sm_state + 0x7f50, [[naов]]->cr[3]); x86_stl_phys([[saga]], sm_state + 0x7f58, [[naов]]->cr[0]); x86_stl_phys([[saga]], sm_state + 0x7efc, SMM_REVISION_ID); x86_stl_phys([[saga]], sm_state + 0x7f00, [[naов]]->smbase); #else x86_stl_phys([[saga]], sm_state + 0x7ffc, [[naов]]->cr[0]); x86_stl_phys([[saga]], sm_state + 0x7ff8, [[naов]]->cr[3]); x86_stl_phys([[saga]], sm_state + 0x7ff4, cpu_compute_eflags([[naов]])); x86_stl_phys([[saga]], sm_state + 0x7ff0, [[naов]]->eip); x86_stl_phys([[saga]], sm_state + 0x7fec, [[naов]]->regs[R_EDI]); x86_stl_phys([[saga]], sm_state + 0x7fe8, [[naов]]->regs[R_ESI]); x86_stl_phys([[saga]], sm_state + 0x7fe4, [[naов]]->regs[R_EBP]); x86_stl_phys([[saga]], sm_state + 0x7fe0, [[naов]]->regs[R_ESP]); x86_stl_phys([[saga]], sm_state + 0x7fdc, [[naов]]->regs[R_EBX]); x86_stl_phys([[saga]], sm_state + 0x7fd8, [[naов]]->regs[R_EDX]); x86_stl_phys([[saga]], sm_state + 0x7fd4, [[naов]]->regs[R_ECX]); x86_stl_phys([[saga]], sm_state + 0x7fd0, [[naов]]->regs[R_EAX]); x86_stl_phys([[saga]], sm_state + 0x7fcc, [[naов]]->dr[6]); x86_stl_phys([[saga]], sm_state + 0x7fc8, [[naов]]->dr[7]); x86_stl_phys([[saga]], sm_state + 0x7fc4, [[naов]]->tr.selector); x86_stl_phys([[saga]], sm_state + 0x7f64, [[naов]]->tr.base); x86_stl_phys([[saga]], sm_state + 0x7f60, [[naов]]->tr.limit); x86_stl_phys([[saga]], sm_state + 0x7f5c, ([[naов]]->tr.flags >> 8) & 0xf0ff); x86_stl_phys([[saga]], sm_state + 0x7fc0, [[naов]]->ldt.selector); x86_stl_phys([[saga]], sm_state + 0x7f80, [[naов]]->ldt.base); x86_stl_phys([[saga]], sm_state + 0x7f7c, [[naов]]->ldt.limit); x86_stl_phys([[saga]], sm_state + 0x7f78, ([[naов]]->ldt.flags >> 8) & 0xf0ff); x86_stl_phys([[saga]], sm_state + 0x7f74, [[naов]]->gdt.base); x86_stl_phys([[saga]], sm_state + 0x7f70, [[naов]]->gdt.limit); x86_stl_phys([[saga]], sm_state + 0x7f58, [[naов]]->idt.base); x86_stl_phys([[saga]], sm_state + 0x7f54, [[naов]]->idt.limit); for (i = 0; i < 6; i++) { dt = &[[naов]]->segs[i]; if (i < 3) { offset = 0x7f84 + i * 12; } else { offset = 0x7f2c + (i - 3) * 12; } x86_stl_phys([[saga]], sm_state + 0x7fa8 + i * 4, dt->selector); x86_stl_phys([[saga]], sm_state + offset + 8, dt->base); x86_stl_phys([[saga]], sm_state + offset + 4, dt->limit); x86_stl_phys([[saga]], sm_state + offset, (dt->flags >> 8) & 0xf0ff); } x86_stl_phys([[saga]], sm_state + 0x7f14, [[naов]]->cr[4]); x86_stl_phys([[saga]], sm_state + 0x7efc, SMM_REVISION_ID); x86_stl_phys([[saga]], sm_state + 0x7ef8, [[naов]]->smbase); #endif #ifdef TARGET_X86_64 cpu_load_efer([[naов]], 0); #endif cpu_load_eflags([[naов]], 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C | DF_MASK)); [[naов]]->eip = 0x00008000; cpu_x86_update_cr0([[naов]], [[naов]]->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK | CR0_PG_MASK)); cpu_x86_update_cr4([[naов]], 0); [[naов]]->dr[7] = 0x00000400; cpu_x86_load_seg_cache([[naов]], R_CS, ([[naов]]->smbase >> 4) & 0xffff, [[naов]]->smbase, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[naов]], R_DS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[naов]], R_ES, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[naов]], R_SS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[naов]], R_FS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache([[naов]], R_GS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); }[Succeeded / Failed / Skipped / Total] 282 / 66 / 200 / 548:  20%|██        | 548/2690 [1:24:49<5:31:33,  9.29s/it][Succeeded / Failed / Skipped / Total] 282 / 66 / 200 / 548:  20%|██        | 549/2690 [1:24:49<5:30:49,  9.27s/it][Succeeded / Failed / Skipped / Total] 282 / 66 / 201 / 549:  20%|██        | 549/2690 [1:24:49<5:30:49,  9.27s/it][Succeeded / Failed / Skipped / Total] 282 / 66 / 201 / 549:  20%|██        | 550/2690 [1:24:51<5:30:10,  9.26s/it][Succeeded / Failed / Skipped / Total] 282 / 67 / 201 / 550:  20%|██        | 550/2690 [1:24:51<5:30:10,  9.26s/it][Succeeded / Failed / Skipped / Total] 282 / 67 / 201 / 550:  20%|██        | 551/2690 [1:25:07<5:30:26,  9.27s/it][Succeeded / Failed / Skipped / Total] 283 / 67 / 201 / 551:  20%|██        | 551/2690 [1:25:07<5:30:26,  9.27s/it][Succeeded / Failed / Skipped / Total] 283 / 67 / 201 / 551:  21%|██        | 552/2690 [1:25:10<5:29:52,  9.26s/it]
--------------------------------------------- Result 549 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp) { uint8_t* config = qxl->pci.config; uint32_t pci_device_rev; uint32_t io_size; qxl->mode = QXL_MODE_UNDEFINED; qxl->generation = 1; qxl->num_memslots = NUM_MEMSLOTS; qemu_mutex_init(&qxl->track_lock); qemu_mutex_init(&qxl->async_lock); qxl->current_async = QXL_UNDEFINED_IO; qxl->guest_bug = 0; switch (qxl->revision) { case 1: pci_device_rev = QXL_REVISION_STABLE_V04; io_size = 8; break; case 2: pci_device_rev = QXL_REVISION_STABLE_V06; io_size = 16; break; case 3: pci_device_rev = QXL_REVISION_STABLE_V10; io_size = 32; break; case 4: pci_device_rev = QXL_REVISION_STABLE_V12; io_size = pow2ceil(QXL_IO_RANGE_SIZE); break; default: error_setg(errp, "Invalid revision %d for qxl device (max %d)", qxl->revision, QXL_DEFAULT_REVISION); return; } pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev); pci_set_byte(&config[PCI_INTERRUPT_PIN], 1); qxl->rom_size = qxl_rom_size(); memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), "qxl.vrom", qxl->rom_size, &error_abort); vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev); init_qxl_rom(qxl); init_qxl_ram(qxl); qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces); memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), "qxl.vram", qxl->vram_size, &error_abort); vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev); memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), "qxl.vram32", &qxl->vram_bar, 0, qxl->vram32_size); memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl, "qxl-ioports", io_size); if (qxl->id == 0) { vga_dirty_log_start(&qxl->vga); } memory_region_set_flush_coalesced(&qxl->io_bar); pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar); pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar); pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram); pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar); if (qxl->vram32_size < qxl->vram_size) { pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64 | PCI_BASE_ADDRESS_MEM_PREFETCH, &qxl->vram_bar); } dprint(qxl, 1, "ram/%s: %d MB [region 0]\n", qxl->id == 0 ? "pri" : "sec", qxl->vga.vram_size / (1024*1024)); dprint(qxl, 1, "vram/32: %d MB [region 1]\n", qxl->vram32_size / (1024*1024)); dprint(qxl, 1, "vram/64: %d MB %s\n", qxl->vram_size / (1024*1024), qxl->vram32_size < qxl->vram_size ? "[region 4]" : "[unmapped]"); qxl->ssd.qxl.base.sif = &qxl_interface.base; if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) { error_setg(errp, "qxl interface %d.%d not supported by spice-server", SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR); return; } qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl); qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl); qxl_reset_state(qxl); qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl); qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd); }
--------------------------------------------- Result 550 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static av_cold int roq_encode_init(AVCodecContext *[[avctx]]) { RoqContext *enc = [[avctx]]->priv_data; av_lfg_init(&enc->randctx, 1); enc->framesSinceKeyframe = 0; if (([[avctx]]->width & 0xf) || ([[avctx]]->height & 0xf)) { av_log([[avctx]], AV_LOG_ERROR, "Dimensions must be divisible by 16\n"); return AVERROR(EINVAL); if ([[avctx]]->width > 65535 || [[avctx]]->height > 65535) { av_log([[avctx]], AV_LOG_ERROR, "Dimensions are max %d\n", enc->quake3_compat ? 32768 : 65535); return AVERROR(EINVAL); if ((([[avctx]]->width)&([[avctx]]->width-1))||(([[avctx]]->height)&([[avctx]]->height-1))) av_log([[avctx]], AV_LOG_ERROR, "Warning: dimensions not power of two, this is not supported by quake\n"); enc->width = [[avctx]]->width; enc->height = [[avctx]]->height; enc->framesSinceKeyframe = 0; enc->first_frame = 1; enc->last_frame = av_frame_alloc(); enc->current_frame = av_frame_alloc(); if (!enc->last_frame || !enc->current_frame) { enc->tmpData = av_malloc(sizeof(RoqTempdata)); enc->this_motion4 = av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect)); enc->last_motion4 = av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect)); enc->this_motion8 = av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect)); enc->last_motion8 = av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect)); return 0;

[[[[Adv]]]]: static av_cold int roq_encode_init(AVCodecContext *[[afsed]]) { RoqContext *enc = [[afsed]]->priv_data; av_lfg_init(&enc->randctx, 1); enc->framesSinceKeyframe = 0; if (([[afsed]]->width & 0xf) || ([[afsed]]->height & 0xf)) { av_log([[afsed]], AV_LOG_ERROR, "Dimensions must be divisible by 16\n"); return AVERROR(EINVAL); if ([[afsed]]->width > 65535 || [[afsed]]->height > 65535) { av_log([[afsed]], AV_LOG_ERROR, "Dimensions are max %d\n", enc->quake3_compat ? 32768 : 65535); return AVERROR(EINVAL); if ((([[afsed]]->width)&([[afsed]]->width-1))||(([[afsed]]->height)&([[afsed]]->height-1))) av_log([[afsed]], AV_LOG_ERROR, "Warning: dimensions not power of two, this is not supported by quake\n"); enc->width = [[afsed]]->width; enc->height = [[afsed]]->height; enc->framesSinceKeyframe = 0; enc->first_frame = 1; enc->last_frame = av_frame_alloc(); enc->current_frame = av_frame_alloc(); if (!enc->last_frame || !enc->current_frame) { enc->tmpData = av_malloc(sizeof(RoqTempdata)); enc->this_motion4 = av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect)); enc->last_motion4 = av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect)); enc->this_motion8 = av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect)); enc->last_motion8 = av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect)); return 0;
--------------------------------------------- Result 551 ---------------------------------------------
[[0 (75%)]] --> [[0 (41%)]] --> Socre: 0.5883295834064484

[[[[Adv]]]]: static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *[[block]]) { int i; int dc = [[block]][0]; const uint8_t *cm; dc = ( 3 * dc + 1) >> 1; dc = (17 * dc + 64) >> 7; cm = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 4; i++){ dest[0] = cm[dest[0]]; dest[1] = cm[dest[1]]; dest[2] = cm[dest[2]]; dest[3] = cm[dest[3]]; dest[4] = cm[dest[4]]; dest[5] = cm[dest[5]]; dest[6] = cm[dest[6]]; dest[7] = cm[dest[7]]; dest += linesize; } }

[[[[Adv]]]]: static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *[[park]]) { int i; int dc = [[park]][0]; const uint8_t *cm; dc = ( 3 * dc + 1) >> 1; dc = (17 * dc + 64) >> 7; cm = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 4; i++){ dest[0] = cm[dest[0]]; dest[1] = cm[dest[1]]; dest[2] = cm[dest[2]]; dest[3] = cm[dest[3]]; dest[4] = cm[dest[4]]; dest[5] = cm[dest[5]]; dest[6] = cm[dest[6]]; dest[7] = cm[dest[7]]; dest += linesize; } }
--------------------------------------------- Result 552 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 284 / 67 / 201 / 552:  21%|██        | 552/2690 [1:25:10<5:29:52,  9.26s/it][Succeeded / Failed / Skipped / Total] 284 / 67 / 201 / 552:  21%|██        | 553/2690 [1:25:30<5:30:25,  9.28s/it][Succeeded / Failed / Skipped / Total] 285 / 67 / 201 / 553:  21%|██        | 553/2690 [1:25:30<5:30:25,  9.28s/it][Succeeded / Failed / Skipped / Total] 285 / 67 / 201 / 553:  21%|██        | 554/2690 [1:25:30<5:29:42,  9.26s/it][Succeeded / Failed / Skipped / Total] 286 / 67 / 201 / 554:  21%|██        | 554/2690 [1:25:30<5:29:42,  9.26s/it][Succeeded / Failed / Skipped / Total] 286 / 67 / 201 / 554:  21%|██        | 555/2690 [1:25:31<5:28:59,  9.25s/it][Succeeded / Failed / Skipped / Total] 286 / 67 / 202 / 555:  21%|██        | 555/2690 [1:25:31<5:28:59,  9.25s/it][Succeeded / Failed / Skipped / Total] 286 / 67 / 202 / 555:  21%|██        | 556/2690 [1:25:58<5:29:57,  9.28s/it][[0 (59%)]] --> [[0 (21%)]] --> Socre: 0.7850859463214874

[[[[Adv]]]]: static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int [[r]]) { switch(mode){ case 0: return src[0]; case 1: return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - [[r]]) >> 6; case 2: return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - [[r]]) >> 4; case 3: return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - [[r]]) >> 6; } return 0; }

[[[[Adv]]]]: static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int [[loop]]) { switch(mode){ case 0: return src[0]; case 1: return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - [[loop]]) >> 6; case 2: return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - [[loop]]) >> 4; case 3: return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - [[loop]]) >> 6; } return 0; }
--------------------------------------------- Result 553 ---------------------------------------------
[[0 (68%)]] --> [[0 (44%)]] --> Socre: 0.5573461055755615

[[[[Adv]]]]: static uint64_t openpic_tmr_read(void *[[opaque]], hwaddr addr, unsigned len) { OpenPICState *opp = [[opaque]]; uint32_t retval = -1; int idx; DPRINTF("%s: addr %08x\n", __func__, addr); if (addr & 0xF) { goto out; } idx = (addr >> 6) & 0x3; if (addr == 0x0) { retval = opp->tifr; goto out; } switch (addr & 0x30) { case 0x00: retval = opp->timers[idx].ticc; break; case 0x10: retval = opp->timers[idx].tibc; break; case 0x20: retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx); break; case 0x30: retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx); break; } out: DPRINTF("%s: => %08x\n", __func__, retval); return retval; }

[[[[Adv]]]]: static uint64_t openpic_tmr_read(void *[[leger]], hwaddr addr, unsigned len) { OpenPICState *opp = [[leger]]; uint32_t retval = -1; int idx; DPRINTF("%s: addr %08x\n", __func__, addr); if (addr & 0xF) { goto out; } idx = (addr >> 6) & 0x3; if (addr == 0x0) { retval = opp->tifr; goto out; } switch (addr & 0x30) { case 0x00: retval = opp->timers[idx].ticc; break; case 0x10: retval = opp->timers[idx].tibc; break; case 0x20: retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx); break; case 0x30: retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx); break; } out: DPRINTF("%s: => %08x\n", __func__, retval); return retval; }
--------------------------------------------- Result 554 ---------------------------------------------
[[0 (20%)]] --> [[0 (53%)]] --> Socre: 0.5311940312385559

[[[[Adv]]]]: static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out) { const AVOption *[[o]] = av_opt_find(obj, name, NULL, 0, 0); void *[[dst]]; if (o_out) *o_out= [[o]]; if (![[o]] || [[o]]->offset<=0) return AVERROR_OPTION_NOT_FOUND; if ([[o]]->max*den < num*intnum || [[o]]->min*den > num*intnum) { av_log(obj, AV_LOG_ERROR, "Value %lf for parameter '%s' out of range\n", num, name); return AVERROR(ERANGE); } [[dst]]= ((uint8_t*)obj) + [[o]]->offset; switch ([[o]]->type) { case FF_OPT_TYPE_FLAGS: case FF_OPT_TYPE_INT: *(int *)[[dst]]= llrint(num/den)*intnum; break; case FF_OPT_TYPE_INT64: *(int64_t *)[[dst]]= llrint(num/den)*intnum; break; case FF_OPT_TYPE_FLOAT: *(float *)[[dst]]= num*intnum/den; break; case FF_OPT_TYPE_DOUBLE:*(double *)[[dst]]= num*intnum/den; break; case FF_OPT_TYPE_RATIONAL: if ((int)num == num) *(AVRational*)[[dst]]= (AVRational){num*intnum, den}; else *(AVRational*)[[dst]]= av_d2q(num*intnum/den, 1<<24); break; default: return AVERROR(EINVAL); } return 0; }

[[[[Adv]]]]: static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out) { const AVOption *[[op]] = av_opt_find(obj, name, NULL, 0, 0); void *[[tranт]]; if (o_out) *o_out= [[op]]; if (![[op]] || [[op]]->offset<=0) return AVERROR_OPTION_NOT_FOUND; if ([[op]]->max*den < num*intnum || [[op]]->min*den > num*intnum) { av_log(obj, AV_LOG_ERROR, "Value %lf for parameter '%s' out of range\n", num, name); return AVERROR(ERANGE); } [[tranт]]= ((uint8_t*)obj) + [[op]]->offset; switch ([[op]]->type) { case FF_OPT_TYPE_FLAGS: case FF_OPT_TYPE_INT: *(int *)[[tranт]]= llrint(num/den)*intnum; break; case FF_OPT_TYPE_INT64: *(int64_t *)[[tranт]]= llrint(num/den)*intnum; break; case FF_OPT_TYPE_FLOAT: *(float *)[[tranт]]= num*intnum/den; break; case FF_OPT_TYPE_DOUBLE:*(double *)[[tranт]]= num*intnum/den; break; case FF_OPT_TYPE_RATIONAL: if ((int)num == num) *(AVRational*)[[tranт]]= (AVRational){num*intnum, den}; else *(AVRational*)[[tranт]]= av_d2q(num*intnum/den, 1<<24); break; default: return AVERROR(EINVAL); } return 0; }
--------------------------------------------- Result 555 ---------------------------------------------
[[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void sha1_transform(uint32_t state[5], const uint8_t buffer[64]) { uint32_t block[80]; unsigned int i, a, b, c, d, e; a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; #if CONFIG_SMALL for (i = 0; i < 80; i++) { int t; if (i < 16) t = AV_RB32(buffer + 4 * i); else t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1); block[i] = t; t += e + rol(a, 5); if (i < 40) { if (i < 20) t += ((b&(c^d))^d) + 0x5A827999; else t += ( b^c ^d) + 0x6ED9EBA1; } else { if (i < 60) t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC; else t += ( b^c ^d) + 0xCA62C1D6; } e = d; d = c; c = rol(b, 30); b = a; a = t; } #else for (i = 0; i < 15; i += 5) { R0(a, b, c, d, e, 0 + i); R0(e, a, b, c, d, 1 + i); R0(d, e, a, b, c, 2 + i); R0(c, d, e, a, b, 3 + i); R0(b, c, d, e, a, 4 + i); } R0(a, b, c, d, e, 15); R1(e, a, b, c, d, 16); R1(d, e, a, b, c, 17); R1(c, d, e, a, b, 18); R1(b, c, d, e, a, 19); for (i = 20; i < 40; i += 5) { R2(a, b, c, d, e, 0 + i); R2(e, a, b, c, d, 1 + i); R2(d, e, a, b, c, 2 + i); R2(c, d, e, a, b, 3 + i); R2(b, c, d, e, a, 4 + i); } for (; i < 60; i += 5) { R3(a, b, c, d, e, 0 + i); R3(e, a, b, c, d, 1 + i); R3(d, e, a, b, c, 2 + i); R3(c, d, e, a, b, 3 + i); R3(b, c, d, e, a, 4 + i); } for (; i < 80; i += 5) { R4(a, b, c, d, e, 0 + i); R4(e, a, b, c, d, 1 + i); R4(d, e, a, b, c, 2 + i); R4(c, d, e, a, b, 3 + i); R4(b, c, d, e, a, 4 + i); } #endif state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; }
--------------------------------------------- Result 556 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 287 / 67 / 202 / 556:  21%|██        | 556/2690 [1:25:58<5:29:57,  9.28s/it][Succeeded / Failed / Skipped / Total] 287 / 67 / 202 / 556:  21%|██        | 557/2690 [1:25:58<5:29:14,  9.26s/it][Succeeded / Failed / Skipped / Total] 287 / 67 / 203 / 557:  21%|██        | 557/2690 [1:25:58<5:29:14,  9.26s/it][Succeeded / Failed / Skipped / Total] 287 / 67 / 203 / 557:  21%|██        | 558/2690 [1:25:59<5:28:31,  9.25s/it][Succeeded / Failed / Skipped / Total] 287 / 67 / 204 / 558:  21%|██        | 558/2690 [1:25:59<5:28:31,  9.25s/it][Succeeded / Failed / Skipped / Total] 287 / 67 / 204 / 558:  21%|██        | 559/2690 [1:26:08<5:28:22,  9.25s/it][Succeeded / Failed / Skipped / Total] 288 / 67 / 204 / 559:  21%|██        | 559/2690 [1:26:08<5:28:22,  9.25s/it][Succeeded / Failed / Skipped / Total] 288 / 67 / 204 / 559:  21%|██        | 560/2690 [1:26:13<5:27:56,  9.24s/it][Succeeded / Failed / Skipped / Total] 289 / 67 / 204 / 560:  21%|██        | 560/2690 [1:26:13<5:27:56,  9.24s/it][Succeeded / Failed / Skipped / Total] 289 / 67 / 204 / 560:  21%|██        | 561/2690 [1:26:21<5:27:42,  9.24s/it][Succeeded / Failed / Skipped / Total] 290 / 67 / 204 / 561:  21%|██        | 561/2690 [1:26:21<5:27:42,  9.24s/it][Succeeded / Failed / Skipped / Total] 290 / 67 / 204 / 561:  21%|██        | 562/2690 [1:26:35<5:27:52,  9.24s/it][[0 (48%)]] --> [[0 (85%)]] --> Socre: 0.8519459366798401

[[[[Adv]]]]: static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp) { const QDictEntry *[[ent]]; const char *arg_name; const QObject *arg_obj; bool has_exec_key = "False" != "False"; QDict *dict = NULL; if (qobject_type(request) != QTYPE_QDICT) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, "request is not a dictionary"); return NULL; } dict = qobject_to_qdict(request); for ([[ent]] = qdict_first(dict); [[ent]]; [[ent]] = qdict_next(dict, [[ent]])) { arg_name = qdict_entry_key([[ent]]); arg_obj = qdict_entry_value([[ent]]); if (!strcmp(arg_name, "execute")) { if (qobject_type(arg_obj) != QTYPE_QSTRING) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, "execute", "string"); return NULL; } has_exec_key = "True" == "True"; } else if (strcmp(arg_name, "arguments")) { error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name); return NULL; } } if (!has_exec_key) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, "execute"); return NULL; } return dict; }

[[[[Adv]]]]: static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp) { const QDictEntry *[[asт]]; const char *arg_name; const QObject *arg_obj; bool has_exec_key = "False" != "False"; QDict *dict = NULL; if (qobject_type(request) != QTYPE_QDICT) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, "request is not a dictionary"); return NULL; } dict = qobject_to_qdict(request); for ([[asт]] = qdict_first(dict); [[asт]]; [[asт]] = qdict_next(dict, [[asт]])) { arg_name = qdict_entry_key([[asт]]); arg_obj = qdict_entry_value([[asт]]); if (!strcmp(arg_name, "execute")) { if (qobject_type(arg_obj) != QTYPE_QSTRING) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, "execute", "string"); return NULL; } has_exec_key = "True" == "True"; } else if (strcmp(arg_name, "arguments")) { error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name); return NULL; } } if (!has_exec_key) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, "execute"); return NULL; } return dict; }
--------------------------------------------- Result 557 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void acpi_build_update(void *build_opaque, uint32_t offset) { AcpiBuildState *build_state = build_opaque; AcpiBuildTables tables; if (!build_state || build_state->patched) { return; } build_state->patched = 1; acpi_build_tables_init(&tables); acpi_build(build_state->guest_info, &tables); assert(acpi_data_len(tables.table_data) == build_state->table_size); memcpy(build_state->table_ram, tables.table_data->data, build_state->table_size); acpi_build_tables_cleanup(&tables, "True" == "True"); }
--------------------------------------------- Result 558 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int amr_nb_encode_init(AVCodecContext *avctx) { AMRContext *s = avctx->priv_data; if (avctx->sample_rate != 8000) { av_log(avctx, AV_LOG_ERROR, "Only 8000Hz sample rate supported\n"); return AVERROR(ENOSYS); } if (avctx->channels != 1) { av_log(avctx, AV_LOG_ERROR, "Only mono supported\n"); return AVERROR(ENOSYS); } avctx->frame_size = 160; avctx->coded_frame = avcodec_alloc_frame(); s->enc_state = Encoder_Interface_init(s->enc_dtx); if (!s->enc_state) { av_log(avctx, AV_LOG_ERROR, "Encoder_Interface_init error\n"); return -1; } s->enc_mode = get_bitrate_mode(avctx->bit_rate, avctx); s->enc_bitrate = avctx->bit_rate; return 0; }
--------------------------------------------- Result 559 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9882529377937317

[[[[Adv]]]]: static void gen_exception_insn(DisasContext *[[s]], int [[offset]], int [[excp]]) { gen_a64_set_pc_im([[s]]->pc - [[offset]]); gen_exception([[excp]]); [[s]]->is_jmp = DISAS_JUMP; }

[[[[Adv]]]]: static void gen_exception_insn(DisasContext *[[с]], int [[buffer]], int [[ank]]) { gen_a64_set_pc_im([[с]]->pc - [[buffer]]); gen_exception([[ank]]); [[с]]->is_jmp = DISAS_JUMP; }
--------------------------------------------- Result 560 ---------------------------------------------
[[0 (97%)]] --> [[0 (15%)]] --> Socre: 0.8471322804689407

[[[[Adv]]]]: static int get_int64(QEMUFile *f, void *[[pv]], size_t size) { int64_t *[[v]] = [[pv]]; qemu_get_sbe64s(f, [[v]]); return 0; }

[[[[Adv]]]]: static int get_int64(QEMUFile *f, void *[[fan]], size_t size) { int64_t *[[park]] = [[fan]]; qemu_get_sbe64s(f, [[park]]); return 0; }
--------------------------------------------- Result 561 ---------------------------------------------
[[0 (61%)]] --> [[0 (22%)]] --> Socre: 0.7837507426738739

[[[[Adv]]]]: static int get_num(ByteIOContext *[[pb]], int *len) { int n, n1; n = get_be16([[pb]]); (*len)-=2; if (n >= 0x4000) { return n - 0x4000; } else { n1 = get_be16([[pb]]); (*len)-=2; return (n << 16) | n1; } }

[[[[Adv]]]]: static int get_num(ByteIOContext *[[polys]], int *len) { int n, n1; n = get_be16([[polys]]); (*len)-=2; if (n >= 0x4000) { return n - 0x4000; } else { n1 = get_be16([[polys]]); (*len)-=2; return (n << 16) | n1; } }
--------------------------------------------- Result 562 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 291 / 67 / 204 / 562:  21%|██        | 562/2690 [1:26:35<5:27:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 291 / 67 / 204 / 562:  21%|██        | 563/2690 [1:26:35<5:27:09,  9.23s/it][Succeeded / Failed / Skipped / Total] 291 / 67 / 205 / 563:  21%|██        | 563/2690 [1:26:35<5:27:09,  9.23s/it][Succeeded / Failed / Skipped / Total] 291 / 67 / 205 / 563:  21%|██        | 564/2690 [1:26:46<5:27:05,  9.23s/it][Succeeded / Failed / Skipped / Total] 292 / 67 / 205 / 564:  21%|██        | 564/2690 [1:26:46<5:27:05,  9.23s/it][Succeeded / Failed / Skipped / Total] 292 / 67 / 205 / 564:  21%|██        | 565/2690 [1:26:46<5:26:23,  9.22s/it][Succeeded / Failed / Skipped / Total] 292 / 67 / 206 / 565:  21%|██        | 565/2690 [1:26:46<5:26:23,  9.22s/it][Succeeded / Failed / Skipped / Total] 292 / 67 / 206 / 565:  21%|██        | 566/2690 [1:26:53<5:26:04,  9.21s/it][Succeeded / Failed / Skipped / Total] 293 / 67 / 206 / 566:  21%|██        | 566/2690 [1:26:53<5:26:04,  9.21s/it][Succeeded / Failed / Skipped / Total] 293 / 67 / 206 / 566:  21%|██        | 567/2690 [1:27:01<5:25:49,  9.21s/it][[0 (15%)]] --> [[0 (59%)]] --> Socre: 0.5918901562690735

[[[[Adv]]]]: CPUState *ppc440ep_init(MemoryRegion *[[address_space_mem]], ram_addr_t *[[ram_size]], PCIBus **pcip, const unsigned int [[pci_irq_nrs]][4], int do_init, const char *cpu_model) { MemoryRegion *ram_memories = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories)); target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS]; target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS]; CPUState *env; qemu_irq *pic; qemu_irq *irqs; qemu_irq *pci_irqs; if (cpu_model == NULL) { cpu_model = "440-Xilinx"; } env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } ppc_booke_timers_init(env, 400000000, 0); ppc_dcr_init(env, NULL, NULL); irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB); irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT]; irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT]; pic = ppcuic_init(env, irqs, 0x0C0, 0, 1); memset(ram_bases, 0, sizeof(ram_bases)); memset(ram_sizes, 0, sizeof(ram_sizes)); *[[ram_size]] = ppc4xx_sdram_adjust(*[[ram_size]], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, ppc440ep_sdram_bank_sizes); ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, do_init); pci_irqs = g_malloc(sizeof(qemu_irq) * 4); pci_irqs[0] = pic[[[pci_irq_nrs]][0]]; pci_irqs[1] = pic[[[pci_irq_nrs]][1]]; pci_irqs[2] = pic[[[pci_irq_nrs]][2]]; pci_irqs[3] = pic[[[pci_irq_nrs]][3]]; *pcip = ppc4xx_pci_init(env, pci_irqs, PPC440EP_PCI_CONFIG, PPC440EP_PCI_INTACK, PPC440EP_PCI_SPECIAL, PPC440EP_PCI_REGS); if (!*pcip) printf("couldn't create PCI controller!\n"); isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN); if (serial_hds[0] != NULL) { serial_mm_init([[address_space_mem]], 0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1] != NULL) { serial_mm_init([[address_space_mem]], 0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE, serial_hds[1], DEVICE_BIG_ENDIAN); } return env; }

[[[[Adv]]]]: CPUState *ppc440ep_init(MemoryRegion *[[chipaucitymyumma]], ram_addr_t *[[matrix²leader]], PCIBus **pcip, const unsigned int [[virtualruoridimryurd]][4], int do_init, const char *cpu_model) { MemoryRegion *ram_memories = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories)); target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS]; target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS]; CPUState *env; qemu_irq *pic; qemu_irq *irqs; qemu_irq *pci_irqs; if (cpu_model == NULL) { cpu_model = "440-Xilinx"; } env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } ppc_booke_timers_init(env, 400000000, 0); ppc_dcr_init(env, NULL, NULL); irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB); irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT]; irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT]; pic = ppcuic_init(env, irqs, 0x0C0, 0, 1); memset(ram_bases, 0, sizeof(ram_bases)); memset(ram_sizes, 0, sizeof(ram_sizes)); *[[matrix²leader]] = ppc4xx_sdram_adjust(*[[matrix²leader]], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, ppc440ep_sdram_bank_sizes); ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, do_init); pci_irqs = g_malloc(sizeof(qemu_irq) * 4); pci_irqs[0] = pic[[[virtualruoridimryurd]][0]]; pci_irqs[1] = pic[[[virtualruoridimryurd]][1]]; pci_irqs[2] = pic[[[virtualruoridimryurd]][2]]; pci_irqs[3] = pic[[[virtualruoridimryurd]][3]]; *pcip = ppc4xx_pci_init(env, pci_irqs, PPC440EP_PCI_CONFIG, PPC440EP_PCI_INTACK, PPC440EP_PCI_SPECIAL, PPC440EP_PCI_REGS); if (!*pcip) printf("couldn't create PCI controller!\n"); isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN); if (serial_hds[0] != NULL) { serial_mm_init([[chipaucitymyumma]], 0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1] != NULL) { serial_mm_init([[chipaucitymyumma]], 0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE, serial_hds[1], DEVICE_BIG_ENDIAN); } return env; }
--------------------------------------------- Result 563 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src) { int i; int ret = av_frame_ref(dst, src); if (ret < 0) return ret; if (!h->sps.crop) return 0; for (i = 0; i < 3; i++) { int hshift = (i > 0) ? h->chroma_x_shift : 0; int vshift = (i > 0) ? h->chroma_y_shift : 0; int off = ((h->sps.crop_left >> hshift) << h->pixel_shift) + (h->sps.crop_top >> vshift) * dst->linesize[i]; dst->data[i] += off; } return 0; }
--------------------------------------------- Result 564 ---------------------------------------------
[[0 (4%)]] --> [[0 (98%)]] --> Socre: 0.9778579473495483

[[[[Adv]]]]: static int piix4_initfn(PCIDevice *dev) { PIIX4State *[[d]] = DO_UPCAST(PIIX4State, dev, dev); uint8_t *[[pci_conf]]; isa_bus_new(&[[d]]->dev.qdev); [[pci_conf]] = [[d]]->dev.config; pci_config_set_vendor_id([[pci_conf]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[pci_conf]], PCI_DEVICE_ID_INTEL_82371AB_0); pci_config_set_class([[pci_conf]], PCI_CLASS_BRIDGE_ISA); piix4_dev = &[[d]]->dev; qemu_register_reset(piix4_reset, [[d]]); return 0; }

[[[[Adv]]]]: static int piix4_initfn(PCIDevice *dev) { PIIX4State *[[δ]] = DO_UPCAST(PIIX4State, dev, dev); uint8_t *[[digitalielogproc]]; isa_bus_new(&[[δ]]->dev.qdev); [[digitalielogproc]] = [[δ]]->dev.config; pci_config_set_vendor_id([[digitalielogproc]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[digitalielogproc]], PCI_DEVICE_ID_INTEL_82371AB_0); pci_config_set_class([[digitalielogproc]], PCI_CLASS_BRIDGE_ISA); piix4_dev = &[[δ]]->dev; qemu_register_reset(piix4_reset, [[δ]]); return 0; }
--------------------------------------------- Result 565 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bdrv_remove_aio_context_notifier(BlockDriverState *bs, void (*attached_aio_context)(AioContext *, void *), void (*detach_aio_context)(void *), void *opaque) { BdrvAioNotifier *ban, *ban_next; QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) { if (ban->attached_aio_context == attached_aio_context && ban->detach_aio_context == detach_aio_context && ban->opaque == opaque) { QLIST_REMOVE(ban, list); g_free(ban); return; } } abort(); }
--------------------------------------------- Result 566 ---------------------------------------------
[[0 (58%)]] --> [[0 (34%)]] --> Socre: 0.6596342027187347

[[[[Adv]]]]: void throttle_account(ThrottleState *ts, bool [[is_write]], uint64_t size) { double units = 1.0; if (ts->cfg.op_size && size > ts->cfg.op_size) { units = (double) size / ts->cfg.op_size; } ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size; ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units; if ([[is_write]]) { ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size; ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units; } else { ts->cfg.buckets[THROTTLE_BPS_READ].level += size; ts->cfg.buckets[THROTTLE_OPS_READ].level += units; } }

[[[[Adv]]]]: void throttle_account(ThrottleState *ts, bool [[tscodepass]], uint64_t size) { double units = 1.0; if (ts->cfg.op_size && size > ts->cfg.op_size) { units = (double) size / ts->cfg.op_size; } ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size; ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units; if ([[tscodepass]]) { ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size; ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units; } else { ts->cfg.buckets[THROTTLE_BPS_READ].level += size; ts->cfg.buckets[THROTTLE_OPS_READ].level += units; } }
--------------------------------------------- Result 567 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 294 / 67 / 206 / 567:  21%|██        | 567/2690 [1:27:01<5:25:49,  9.21s/it][Succeeded / Failed / Skipped / Total] 294 / 67 / 206 / 567:  21%|██        | 568/2690 [1:27:29<5:26:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 295 / 67 / 206 / 568:  21%|██        | 568/2690 [1:27:29<5:26:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 295 / 67 / 206 / 568:  21%|██        | 569/2690 [1:28:24<5:29:33,  9.32s/it][Succeeded / Failed / Skipped / Total] 296 / 67 / 206 / 569:  21%|██        | 569/2690 [1:28:24<5:29:33,  9.32s/it][Succeeded / Failed / Skipped / Total] 296 / 67 / 206 / 569:  21%|██        | 570/2690 [1:28:25<5:28:51,  9.31s/it][Succeeded / Failed / Skipped / Total] 296 / 67 / 207 / 570:  21%|██        | 570/2690 [1:28:25<5:28:51,  9.31s/it][Succeeded / Failed / Skipped / Total] 296 / 67 / 207 / 570:  21%|██        | 571/2690 [1:28:25<5:28:10,  9.29s/it][[0 (87%)]] --> [[0 (41%)]] --> Socre: 0.5911959409713745

[[[[Adv]]]]: static void FUNCC(ff_h264_add_pixels8)(uint8_t *[[_dst]], int16_t *_src, int stride) { int i; pixel *[[dst]] = (pixel *) [[_dst]]; dctcoef *src = (dctcoef *) _src; stride /= sizeof(pixel); for (i = 0; i < 8; i++) { [[dst]][0] += src[0]; [[dst]][1] += src[1]; [[dst]][2] += src[2]; [[dst]][3] += src[3]; [[dst]][4] += src[4]; [[dst]][5] += src[5]; [[dst]][6] += src[6]; [[dst]][7] += src[7]; [[dst]] += stride; src += 8; } memset(_src, 0, sizeof(dctcoef) * 64); }

[[[[Adv]]]]: static void FUNCC(ff_h264_add_pixels8)(uint8_t *[[extratset]], int16_t *_src, int stride) { int i; pixel *[[gpot]] = (pixel *) [[extratset]]; dctcoef *src = (dctcoef *) _src; stride /= sizeof(pixel); for (i = 0; i < 8; i++) { [[gpot]][0] += src[0]; [[gpot]][1] += src[1]; [[gpot]][2] += src[2]; [[gpot]][3] += src[3]; [[gpot]][4] += src[4]; [[gpot]][5] += src[5]; [[gpot]][6] += src[6]; [[gpot]][7] += src[7]; [[gpot]] += stride; src += 8; } memset(_src, 0, sizeof(dctcoef) * 64); }
--------------------------------------------- Result 568 ---------------------------------------------
[[0 (74%)]] --> [[0 (30%)]] --> Socre: 0.7025586664676666

[[[[Adv]]]]: static void gen_addq_lo(DisasContext *[[s]], TCGv_i64 val, int [[rlow]]) { TCGv_i64 tmp; TCGv tmp2; tmp = tcg_temp_new_i64(); tmp2 = load_reg([[s]], [[rlow]]); tcg_gen_extu_i32_i64(tmp, tmp2); dead_tmp(tmp2); tcg_gen_add_i64(val, val, tmp); tcg_temp_free_i64(tmp); }

[[[[Adv]]]]: static void gen_addq_lo(DisasContext *[[cs]], TCGv_i64 val, int [[forla]]) { TCGv_i64 tmp; TCGv tmp2; tmp = tcg_temp_new_i64(); tmp2 = load_reg([[cs]], [[forla]]); tcg_gen_extu_i32_i64(tmp, tmp2); dead_tmp(tmp2); tcg_gen_add_i64(val, val, tmp); tcg_temp_free_i64(tmp); }
--------------------------------------------- Result 569 ---------------------------------------------
[[0 (88%)]] --> [[0 (39%)]] --> Socre: 0.6081894338130951

[[[[Adv]]]]: static void test_bmdma_simple_rw(void) { QPCIDevice *[[dev]]; void *[[bmdma_base]], *ide_base; uint8_t [[status]]; uint8_t *buf; uint8_t *[[cmpbuf]]; size_t len = 512; uintptr_t guest_buf = guest_alloc(guest_malloc, len); PrdtEntry [[prdt]][] = { { .addr = cpu_to_le32(guest_buf), .size = cpu_to_le32(len | PRDT_EOT), }, }; [[dev]] = get_pci_device(&[[bmdma_base]], &ide_base); buf = g_malloc(len); [[cmpbuf]] = g_malloc(len); memset(buf, 0x55, len); memwrite(guest_buf, buf, len); [[status]] = send_dma_request(CMD_WRITE_DMA, 0, 1, [[prdt]], ARRAY_SIZE([[prdt]]), NULL); g_assert_cmphex([[status]], ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[dev]], ide_base + reg_status), DF | ERR); memset(buf, 0xaa, len); memwrite(guest_buf, buf, len); [[status]] = send_dma_request(CMD_WRITE_DMA, 1, 1, [[prdt]], ARRAY_SIZE([[prdt]]), NULL); g_assert_cmphex([[status]], ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[dev]], ide_base + reg_status), DF | ERR); memset([[cmpbuf]], 0x55, len); [[status]] = send_dma_request(CMD_READ_DMA, 0, 1, [[prdt]], ARRAY_SIZE([[prdt]]), NULL); g_assert_cmphex([[status]], ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[dev]], ide_base + reg_status), DF | ERR); memread(guest_buf, buf, len); g_assert(memcmp(buf, [[cmpbuf]], len) == 0); memset([[cmpbuf]], 0xaa, len); [[status]] = send_dma_request(CMD_READ_DMA, 1, 1, [[prdt]], ARRAY_SIZE([[prdt]]), NULL); g_assert_cmphex([[status]], ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[dev]], ide_base + reg_status), DF | ERR); memread(guest_buf, buf, len); g_assert(memcmp(buf, [[cmpbuf]], len) == 0); g_free(buf); g_free([[cmpbuf]]); }

[[[[Adv]]]]: static void test_bmdma_simple_rw(void) { QPCIDevice *[[feedback]]; void *[[formamas4class]], *ide_base; uint8_t [[style]]; uint8_t *buf; uint8_t *[[centimetrespolwif]]; size_t len = 512; uintptr_t guest_buf = guest_alloc(guest_malloc, len); PrdtEntry [[prij]][] = { { .addr = cpu_to_le32(guest_buf), .size = cpu_to_le32(len | PRDT_EOT), }, }; [[feedback]] = get_pci_device(&[[formamas4class]], &ide_base); buf = g_malloc(len); [[centimetrespolwif]] = g_malloc(len); memset(buf, 0x55, len); memwrite(guest_buf, buf, len); [[style]] = send_dma_request(CMD_WRITE_DMA, 0, 1, [[prij]], ARRAY_SIZE([[prij]]), NULL); g_assert_cmphex([[style]], ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[feedback]], ide_base + reg_status), DF | ERR); memset(buf, 0xaa, len); memwrite(guest_buf, buf, len); [[style]] = send_dma_request(CMD_WRITE_DMA, 1, 1, [[prij]], ARRAY_SIZE([[prij]]), NULL); g_assert_cmphex([[style]], ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[feedback]], ide_base + reg_status), DF | ERR); memset([[centimetrespolwif]], 0x55, len); [[style]] = send_dma_request(CMD_READ_DMA, 0, 1, [[prij]], ARRAY_SIZE([[prij]]), NULL); g_assert_cmphex([[style]], ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[feedback]], ide_base + reg_status), DF | ERR); memread(guest_buf, buf, len); g_assert(memcmp(buf, [[centimetrespolwif]], len) == 0); memset([[centimetrespolwif]], 0xaa, len); [[style]] = send_dma_request(CMD_READ_DMA, 1, 1, [[prij]], ARRAY_SIZE([[prij]]), NULL); g_assert_cmphex([[style]], ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[feedback]], ide_base + reg_status), DF | ERR); memread(guest_buf, buf, len); g_assert(memcmp(buf, [[centimetrespolwif]], len) == 0); g_free(buf); g_free([[centimetrespolwif]]); }
--------------------------------------------- Result 570 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s) { VirtIOBlockReq *req = virtio_blk_alloc_request(s); if (!virtqueue_pop(s->vq, &req->elem)) { virtio_blk_free_request(req); return NULL; } return req; }
--------------------------------------------- Result 571 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 296 / 67 / 208 / 571:  21%|██        | 571/2690 [1:28:25<5:28:10,  9.29s/it][Succeeded / Failed / Skipped / Total] 296 / 67 / 208 / 571:  21%|██▏       | 572/2690 [1:28:26<5:27:28,  9.28s/it][Succeeded / Failed / Skipped / Total] 296 / 67 / 209 / 572:  21%|██▏       | 572/2690 [1:28:26<5:27:28,  9.28s/it][Succeeded / Failed / Skipped / Total] 296 / 67 / 209 / 572:  21%|██▏       | 573/2690 [1:28:39<5:27:32,  9.28s/it][Succeeded / Failed / Skipped / Total] 296 / 68 / 209 / 573:  21%|██▏       | 573/2690 [1:28:39<5:27:32,  9.28s/it][Succeeded / Failed / Skipped / Total] 296 / 68 / 209 / 573:  21%|██▏       | 574/2690 [1:28:45<5:27:11,  9.28s/it][[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int output_packet(InputStream *ist, const AVPacket *pkt) { int ret = 0, i; int got_output; AVPacket avpkt; if (!ist->saw_first_ts) { ist->dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0; ist->pts = 0; if (pkt != NULL && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) { ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q); ist->pts = ist->dts; } ist->saw_first_ts = 1; } if (ist->next_dts == AV_NOPTS_VALUE) ist->next_dts = ist->dts; if (ist->next_pts == AV_NOPTS_VALUE) ist->next_pts = ist->pts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if (pkt->dts != AV_NOPTS_VALUE) { ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed) ist->next_pts = ist->pts = ist->dts; } while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) { int duration; handle_eof: ist->pts = ist->next_pts; ist->dts = ist->next_dts; if (avpkt.size && avpkt.size != pkt->size) { av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, "Multiple frames in a packet from stream %d\n", pkt->stream_index); ist->showed_multi_packet_warning = 1; } switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ret = decode_audio (ist, &avpkt, &got_output); break; case AVMEDIA_TYPE_VIDEO: ret = decode_video (ist, &avpkt, &got_output); if (avpkt.duration) { duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q); } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) { int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame; duration = ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } else duration = 0; if(ist->dts != AV_NOPTS_VALUE && duration) { ist->next_dts += duration; }else ist->next_dts = AV_NOPTS_VALUE; if (got_output) ist->next_pts += duration; break; case AVMEDIA_TYPE_SUBTITLE: ret = transcode_subtitles(ist, &avpkt, &got_output); break; default: return -1; } if (ret < 0) return ret; avpkt.dts= avpkt.pts= AV_NOPTS_VALUE; if (pkt) { if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO) ret = avpkt.size; avpkt.data += ret; avpkt.size -= ret; } if (!got_output) { continue; } } if (!ist->decoding_needed) { rate_emu_sleep(ist); ist->dts = ist->next_dts; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) / ist->st->codec->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (pkt->duration) { ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q); } else if(ist->st->codec->time_base.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame; ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } break; } ist->pts = ist->dts; ist->next_pts = ist->next_dts; } for (i = 0; pkt && i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; if (!check_output_constraints(ist, ost) || ost->encoding_needed) continue; do_streamcopy(ist, ost, pkt); } return 0; }
--------------------------------------------- Result 572 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_system_reset(void) { QEMUResetEntry *re, *nre; QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) { re->func(re->opaque); } }
--------------------------------------------- Result 573 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int idcin_read_packet(AVFormatContext *s, AVPacket *[[pkt]]) { int ret; unsigned int command; unsigned int chunk_size; IdcinDemuxContext *[[idcin]] = s->priv_data; AVIOContext *pb = s->pb; int i; int [[palette_scale]]; unsigned char r, g, b; unsigned char [[palette_buffer]][768]; uint32_t [[palette]][256]; if (s->pb->eof_reached) return AVERROR(EIO); if ([[idcin]]->next_chunk_is_video) { command = avio_rl32(pb); if (command == 2) { return AVERROR(EIO); } else if (command == 1) { if (avio_read(pb, [[palette_buffer]], 768) != 768) return AVERROR(EIO); [[palette_scale]] = 2; for (i = 0; i < 768; i++) if ([[palette_buffer]][i] > 63) { [[palette_scale]] = 0; break; for (i = 0; i < 256; i++) { r = [[palette_buffer]][i * 3 ] << [[palette_scale]]; g = [[palette_buffer]][i * 3 + 1] << [[palette_scale]]; b = [[palette_buffer]][i * 3 + 2] << [[palette_scale]]; [[palette]][i] = (r << 16) | (g << 8) | (b); chunk_size = avio_rl32(pb); avio_skip(pb, 4); chunk_size -= 4; ret= av_get_packet(pb, [[pkt]], chunk_size); if (ret < 0) return ret; if (command == 1) { uint8_t *pal; pal = av_packet_new_side_data([[pkt]], AV_PKT_DATA_PALETTE, AVPALETTE_SIZE); if (ret < 0) return ret; memcpy(pal, [[palette]], AVPALETTE_SIZE); [[pkt]]->flags |= AV_PKT_FLAG_KEY; [[pkt]]->stream_index = [[idcin]]->video_stream_index; [[pkt]]->duration = 1; } else { if ([[idcin]]->current_audio_chunk) chunk_size = [[idcin]]->audio_chunk_size2; else chunk_size = [[idcin]]->audio_chunk_size1; ret= av_get_packet(pb, [[pkt]], chunk_size); if (ret < 0) return ret; [[pkt]]->stream_index = [[idcin]]->audio_stream_index; [[pkt]]->duration = chunk_size / [[idcin]]->block_align; [[idcin]]->current_audio_chunk ^= 1; if ([[idcin]]->audio_present) [[idcin]]->next_chunk_is_video ^= 1; return ret;

[[[[Adv]]]]: static int idcin_read_packet(AVFormatContext *s, AVPacket *[[minᆨ]]) { int ret; unsigned int command; unsigned int chunk_size; IdcinDemuxContext *[[itl]] = s->priv_data; AVIOContext *pb = s->pb; int i; int [[rugorwalk]]; unsigned char r, g, b; unsigned char [[silkmacfilm]][768]; uint32_t [[legacy]][256]; if (s->pb->eof_reached) return AVERROR(EIO); if ([[itl]]->next_chunk_is_video) { command = avio_rl32(pb); if (command == 2) { return AVERROR(EIO); } else if (command == 1) { if (avio_read(pb, [[silkmacfilm]], 768) != 768) return AVERROR(EIO); [[rugorwalk]] = 2; for (i = 0; i < 768; i++) if ([[silkmacfilm]][i] > 63) { [[rugorwalk]] = 0; break; for (i = 0; i < 256; i++) { r = [[silkmacfilm]][i * 3 ] << [[rugorwalk]]; g = [[silkmacfilm]][i * 3 + 1] << [[rugorwalk]]; b = [[silkmacfilm]][i * 3 + 2] << [[rugorwalk]]; [[legacy]][i] = (r << 16) | (g << 8) | (b); chunk_size = avio_rl32(pb); avio_skip(pb, 4); chunk_size -= 4; ret= av_get_packet(pb, [[minᆨ]], chunk_size); if (ret < 0) return ret; if (command == 1) { uint8_t *pal; pal = av_packet_new_side_data([[minᆨ]], AV_PKT_DATA_PALETTE, AVPALETTE_SIZE); if (ret < 0) return ret; memcpy(pal, [[legacy]], AVPALETTE_SIZE); [[minᆨ]]->flags |= AV_PKT_FLAG_KEY; [[minᆨ]]->stream_index = [[itl]]->video_stream_index; [[minᆨ]]->duration = 1; } else { if ([[itl]]->current_audio_chunk) chunk_size = [[itl]]->audio_chunk_size2; else chunk_size = [[itl]]->audio_chunk_size1; ret= av_get_packet(pb, [[minᆨ]], chunk_size); if (ret < 0) return ret; [[minᆨ]]->stream_index = [[itl]]->audio_stream_index; [[minᆨ]]->duration = chunk_size / [[itl]]->block_align; [[itl]]->current_audio_chunk ^= 1; if ([[itl]]->audio_present) [[itl]]->next_chunk_is_video ^= 1; return ret;
--------------------------------------------- Result 574 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 297 / 68 / 209 / 574:  21%|██▏       | 574/2690 [1:28:45<5:27:11,  9.28s/it][Succeeded / Failed / Skipped / Total] 297 / 68 / 209 / 574:  21%|██▏       | 575/2690 [1:28:46<5:26:30,  9.26s/it][Succeeded / Failed / Skipped / Total] 297 / 68 / 210 / 575:  21%|██▏       | 575/2690 [1:28:46<5:26:30,  9.26s/it][Succeeded / Failed / Skipped / Total] 297 / 68 / 210 / 575:  21%|██▏       | 576/2690 [1:28:46<5:25:49,  9.25s/it][[0 (64%)]] --> [[0 (7%)]] --> Socre: 0.9314394444227219

[[[[Adv]]]]: static inline void RENAME(yuv2rgb555_2)(SwsContext *[[c]], const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *vbuf1, const uint16_t *abuf0, const uint16_t *[[abuf1]], uint8_t *dest, int [[dstW]], int yalpha, int uvalpha, int y) { x86_reg [[uv_off]] = [[c]]->uv_off << 1; __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2RGB(%%REGBP, %5, %6) "pxor %%mm7, %%mm7 \n\t" #ifdef DITHER1XBPP "paddusb "BLUE_DITHER"(%5), %%mm2 \n\t" "paddusb "GREEN_DITHER"(%5), %%mm4 \n\t" "paddusb "RED_DITHER"(%5), %%mm5 \n\t" #endif WRITERGB15(%%REGb, 8280(%5), %%REGBP) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&[[c]]->redDither), "m"([[uv_off]]) ); }

[[[[Adv]]]]: static inline void RENAME(yuv2rgb555_2)(SwsContext *[[major]], const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *vbuf1, const uint16_t *abuf0, const uint16_t *[[murf²]], uint8_t *dest, int [[tantk]], int yalpha, int uvalpha, int y) { x86_reg [[ulf2by]] = [[major]]->uv_off << 1; __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2RGB(%%REGBP, %5, %6) "pxor %%mm7, %%mm7 \n\t" #ifdef DITHER1XBPP "paddusb "BLUE_DITHER"(%5), %%mm2 \n\t" "paddusb "GREEN_DITHER"(%5), %%mm4 \n\t" "paddusb "RED_DITHER"(%5), %%mm5 \n\t" #endif WRITERGB15(%%REGb, 8280(%5), %%REGBP) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&[[major]]->redDither), "m"([[ulf2by]]) ); }
--------------------------------------------- Result 575 ---------------------------------------------
[[0 (70%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args) { int c; switch (opc) { case INDEX_op_exit_tb: if (check_fit_tl(args[0], 13)) { tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN); tcg_out_movi_imm13(s, TCG_REG_O0, args[0]); } else { tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff); tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN); tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, args[0] & 0x3ff, ARITH_OR); } break; case INDEX_op_goto_tb: if (s->tb_jmp_offset) { uint32_t old_insn = *(uint32_t *)s->code_ptr; s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf; tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1))); } else { tcg_out_ld_ptr(s, TCG_REG_T1, (uintptr_t)(s->tb_next + args[0])); tcg_out_arithi(s, TCG_REG_G0, TCG_REG_T1, 0, JMPL); } tcg_out_nop(s); s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf; break; case INDEX_op_call: if (const_args[0]) { tcg_out_calli(s, args[0]); } else { tcg_out_arithi(s, TCG_REG_O7, args[0], 0, JMPL); } tcg_out_nop(s); break; case INDEX_op_br: tcg_out_bpcc(s, COND_A, BPCC_PT, args[0]); tcg_out_nop(s); break; case INDEX_op_movi_i32: tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]); break; #define OP_32_64(x) \ glue(glue(case INDEX_op_, x), _i32): \ glue(glue(case INDEX_op_, x), _i64) OP_32_64(ld8u): tcg_out_ldst(s, args[0], args[1], args[2], LDUB); break; OP_32_64(ld8s): tcg_out_ldst(s, args[0], args[1], args[2], LDSB); break; OP_32_64(ld16u): tcg_out_ldst(s, args[0], args[1], args[2], LDUH); break; OP_32_64(ld16s): tcg_out_ldst(s, args[0], args[1], args[2], LDSH); break; case INDEX_op_ld_i32: case INDEX_op_ld32u_i64: tcg_out_ldst(s, args[0], args[1], args[2], LDUW); break; OP_32_64(st8): tcg_out_ldst(s, args[0], args[1], args[2], STB); break; OP_32_64(st16): tcg_out_ldst(s, args[0], args[1], args[2], STH); break; case INDEX_op_st_i32: case INDEX_op_st32_i64: tcg_out_ldst(s, args[0], args[1], args[2], STW); break; OP_32_64(add): c = ARITH_ADD; goto gen_arith; OP_32_64(sub): c = ARITH_SUB; goto gen_arith; OP_32_64(and): c = ARITH_AND; goto gen_arith; OP_32_64(andc): c = ARITH_ANDN; goto gen_arith; OP_32_64(or): c = ARITH_OR; goto gen_arith; OP_32_64(orc): c = ARITH_ORN; goto gen_arith; OP_32_64(xor): c = ARITH_XOR; goto gen_arith; case INDEX_op_shl_i32: c = SHIFT_SLL; do_shift32: tcg_out_arithc(s, args[0], args[1], args[2] & 31, const_args[2], c); break; case INDEX_op_shr_i32: c = SHIFT_SRL; goto do_shift32; case INDEX_op_sar_i32: c = SHIFT_SRA; goto do_shift32; case INDEX_op_mul_i32: c = ARITH_UMUL; goto gen_arith; OP_32_64(neg): c = ARITH_SUB; goto gen_arith1; OP_32_64(not): c = ARITH_ORN; goto gen_arith1; case INDEX_op_div_i32: tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0); break; case INDEX_op_divu_i32: tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1); break; case INDEX_op_brcond_i32: tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1], args[3]); break; case INDEX_op_setcond_i32: tcg_out_setcond_i32(s, args[3], args[0], args[1], args[2], const_args[2]); break; case INDEX_op_movcond_i32: tcg_out_movcond_i32(s, args[5], args[0], args[1], args[2], const_args[2], args[3], const_args[3]); break; case INDEX_op_add2_i32: tcg_out_addsub2(s, args[0], args[1], args[2], args[3], args[4], const_args[4], args[5], const_args[5], ARITH_ADDCC, ARITH_ADDX); break; case INDEX_op_sub2_i32: tcg_out_addsub2(s, args[0], args[1], args[2], args[3], args[4], const_args[4], args[5], const_args[5], ARITH_SUBCC, ARITH_SUBX); break; case INDEX_op_mulu2_i32: c = ARITH_UMUL; goto do_mul2; case INDEX_op_muls2_i32: c = ARITH_SMUL; do_mul2: tcg_out_arithc(s, args[0], args[2], args[3], const_args[3], c); if (SPARC64 || args[0] <= TCG_REG_O7) { tcg_out_arithi(s, args[1], args[0], 32, SHIFT_SRLX); } else { tcg_out_rdy(s, args[1]); } break; case INDEX_op_qemu_ld_i32: tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], "False" != "False"); break; case INDEX_op_qemu_ld_i64: tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], "True" == "True"); break; case INDEX_op_qemu_st_i32: tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]); break; case INDEX_op_qemu_st_i64: tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]); break; case INDEX_op_movi_i64: tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]); break; case INDEX_op_ld32s_i64: tcg_out_ldst(s, args[0], args[1], args[2], LDSW); break; case INDEX_op_ld_i64: tcg_out_ldst(s, args[0], args[1], args[2], LDX); break; case INDEX_op_st_i64: tcg_out_ldst(s, args[0], args[1], args[2], STX); break; case INDEX_op_shl_i64: c = SHIFT_SLLX; do_shift64: tcg_out_arithc(s, args[0], args[1], args[2] & 63, const_args[2], c); break; case INDEX_op_shr_i64: c = SHIFT_SRLX; goto do_shift64; case INDEX_op_sar_i64: c = SHIFT_SRAX; goto do_shift64; case INDEX_op_mul_i64: c = ARITH_MULX; goto gen_arith; case INDEX_op_div_i64: c = ARITH_SDIVX; goto gen_arith; case INDEX_op_divu_i64: c = ARITH_UDIVX; goto gen_arith; case INDEX_op_ext32s_i64: tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA); break; case INDEX_op_ext32u_i64: tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL); break; case INDEX_op_trunc_shr_i32: if (args[2] == 0) { tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]); } else { tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX); } break; case INDEX_op_brcond_i64: tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1], args[3]); break; case INDEX_op_setcond_i64: tcg_out_setcond_i64(s, args[3], args[0], args[1], args[2], const_args[2]); break; case INDEX_op_movcond_i64: tcg_out_movcond_i64(s, args[5], args[0], args[1], args[2], const_args[2], args[3], const_args[3]); break; gen_arith: tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c); break; gen_arith1: tcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c); break; default: fprintf(stderr, "unknown opcode 0x%x\n", opc); tcg_abort(); } }
--------------------------------------------- Result 576 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 297 / 68 / 211 / 576:  21%|██▏       | 576/2690 [1:28:46<5:25:49,  9.25s/it][Succeeded / Failed / Skipped / Total] 297 / 68 / 211 / 576:  21%|██▏       | 577/2690 [1:28:50<5:25:21,  9.24s/it][Succeeded / Failed / Skipped / Total] 298 / 68 / 211 / 577:  21%|██▏       | 577/2690 [1:28:50<5:25:21,  9.24s/it][Succeeded / Failed / Skipped / Total] 298 / 68 / 211 / 577:  21%|██▏       | 578/2690 [1:29:16<5:26:11,  9.27s/it][Succeeded / Failed / Skipped / Total] 299 / 68 / 211 / 578:  21%|██▏       | 578/2690 [1:29:16<5:26:11,  9.27s/it][Succeeded / Failed / Skipped / Total] 299 / 68 / 211 / 578:  22%|██▏       | 579/2690 [1:29:16<5:25:30,  9.25s/it][Succeeded / Failed / Skipped / Total] 299 / 68 / 212 / 579:  22%|██▏       | 579/2690 [1:29:16<5:25:30,  9.25s/it][Succeeded / Failed / Skipped / Total] 299 / 68 / 212 / 579:  22%|██▏       | 580/2690 [1:29:17<5:24:48,  9.24s/it][Succeeded / Failed / Skipped / Total] 299 / 68 / 213 / 580:  22%|██▏       | 580/2690 [1:29:17<5:24:48,  9.24s/it][[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int eightsvx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { EightSvxContext *esc = avctx->priv_data; int n, out_data_size; int ch, ret; uint8_t *src; if (!esc->samples && avpkt) { int packet_size = avpkt->size; if (packet_size % avctx->channels) { av_log(avctx, AV_LOG_WARNING, "Packet with odd size, ignoring last byte\n"); if (packet_size < avctx->channels) return packet_size; packet_size -= packet_size % avctx->channels; } esc->samples_size = !esc->table ? packet_size : avctx->channels + (packet_size-avctx->channels) * 2; if (!(esc->samples = av_malloc(esc->samples_size))) return AVERROR(ENOMEM); if (esc->table) { const uint8_t *buf = avpkt->data; uint8_t *dst; int buf_size = avpkt->size; int i, n = esc->samples_size; if (buf_size < 2) { av_log(avctx, AV_LOG_ERROR, "packet size is too small\n"); return AVERROR(EINVAL); } dst = esc->samples; for (i = 0; i < avctx->channels; i++) { *(dst++) = buf[0]+128; delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table); buf += buf_size / avctx->channels; dst += n / avctx->channels - 1; } } else { raw_decode(esc->samples, avpkt->data, esc->samples_size); } } av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels)); esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx) / avctx->channels; if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } *got_frame_ptr = 1; *(AVFrame *)data = esc->frame; out_data_size = esc->frame.nb_samples; for (ch = 0; ch<avctx->channels; ch++) { src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels; memcpy(esc->frame.data[ch], src, out_data_size); } out_data_size *= avctx->channels; esc->samples_idx += out_data_size; return esc->table ? (avctx->frame_number == 0)*2 + out_data_size / 2 : out_data_size; }
--------------------------------------------- Result 577 ---------------------------------------------
[[0 (45%)]] --> [[0 (57%)]] --> Socre: 0.5744986534118652

[[[[Adv]]]]: static void sd_reset(SDState *[[sd]], BlockDriverState *bdrv) { uint64_t size; uint64_t sect; if (bdrv) { bdrv_get_geometry(bdrv, &sect); } else { sect = 0; } size = sect << 9; sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1; [[sd]]->state = sd_idle_state; [[sd]]->rca = 0x0000; sd_set_ocr([[sd]]); sd_set_scr([[sd]]); sd_set_cid([[sd]]); sd_set_csd([[sd]], size); sd_set_cardstatus([[sd]]); sd_set_sdstatus([[sd]]); [[sd]]->bdrv = bdrv; if ([[sd]]->wp_groups) g_free([[sd]]->wp_groups); [[sd]]->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0; [[sd]]->wp_groups = (int *) g_malloc0(sizeof(int) * sect); memset([[sd]]->function_group, 0, sizeof(int) * 6); [[sd]]->erase_start = 0; [[sd]]->erase_end = 0; [[sd]]->size = size; [[sd]]->blk_len = 0x200; [[sd]]->pwd_len = 0; [[sd]]->expecting_acmd = 0; }

[[[[Adv]]]]: static void sd_reset(SDState *[[ashes]], BlockDriverState *bdrv) { uint64_t size; uint64_t sect; if (bdrv) { bdrv_get_geometry(bdrv, &sect); } else { sect = 0; } size = sect << 9; sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1; [[ashes]]->state = sd_idle_state; [[ashes]]->rca = 0x0000; sd_set_ocr([[ashes]]); sd_set_scr([[ashes]]); sd_set_cid([[ashes]]); sd_set_csd([[ashes]], size); sd_set_cardstatus([[ashes]]); sd_set_sdstatus([[ashes]]); [[ashes]]->bdrv = bdrv; if ([[ashes]]->wp_groups) g_free([[ashes]]->wp_groups); [[ashes]]->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0; [[ashes]]->wp_groups = (int *) g_malloc0(sizeof(int) * sect); memset([[ashes]]->function_group, 0, sizeof(int) * 6); [[ashes]]->erase_start = 0; [[ashes]]->erase_end = 0; [[ashes]]->size = size; [[ashes]]->blk_len = 0x200; [[ashes]]->pwd_len = 0; [[ashes]]->expecting_acmd = 0; }
--------------------------------------------- Result 578 ---------------------------------------------
[[0 (3%)]] --> [[0 (81%)]] --> Socre: 0.8090398907661438

[[[[Adv]]]]: static void phys_page_set(AddressSpaceDispatch *d, target_phys_addr_t index, target_phys_addr_t [[nb]], uint16_t [[leaf]]) { phys_map_node_reserve(3 * P_L2_LEVELS); phys_page_set_level(&d->phys_map, &index, &[[nb]], [[leaf]], P_L2_LEVELS - 1); }

[[[[Adv]]]]: static void phys_page_set(AddressSpaceDispatch *d, target_phys_addr_t index, target_phys_addr_t [[nuб]], uint16_t [[palm]]) { phys_map_node_reserve(3 * P_L2_LEVELS); phys_page_set_level(&d->phys_map, &index, &[[nuб]], [[palm]], P_L2_LEVELS - 1); }
--------------------------------------------- Result 579 ---------------------------------------------
[[0 (89%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint) { #if defined(TARGET_HAS_ICE) QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry); breakpoint_invalidate(cpu, breakpoint->pc); g_free(breakpoint); #endif }
--------------------------------------------- Result 580 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int flv_write_trailer(AVFormatContext *s) { int64_t file_size; AVIOContext *pb = s->pb; FLVContext *flv = s->priv_data; int i; for (i = 0; i < s->nb_streams; i++) { AVCodecContext *enc = s->streams[i]->codec; FLVStreamContext *sc = s->streams[i]->priv_data; if (enc->codec_type == AVMEDIA_TYPE_VIDEO && enc->codec_id == AV_CODEC_ID_H264) put_avc_eos_tag(pb, sc->last_ts); } file_size = avio_tell(pb); avio_seek(pb, flv->duration_offset, SEEK_SET); put_amf_double(pb, flv->duration / (double)1000); avio_seek(pb, flv->filesize_offset, SEEK_SET); put_amf_double(pb, file_size); avio_seek(pb, file_size, SEEK_SET); return 0; }
--------------------------------------------- Result 581 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 300 / 68 / 213 / 581:  22%|██▏       | 581/2690 [1:29:17<5:24:06,  9.22s/it][Succeeded / Failed / Skipped / Total] 300 / 68 / 213 / 581:  22%|██▏       | 582/2690 [1:29:17<5:23:24,  9.21s/it][Succeeded / Failed / Skipped / Total] 301 / 68 / 213 / 582:  22%|██▏       | 582/2690 [1:29:17<5:23:24,  9.21s/it][Succeeded / Failed / Skipped / Total] 301 / 68 / 214 / 583:  22%|██▏       | 583/2690 [1:29:17<5:22:44,  9.19s/it][Succeeded / Failed / Skipped / Total] 301 / 68 / 214 / 583:  22%|██▏       | 584/2690 [1:29:25<5:22:30,  9.19s/it][[0 (48%)]] --> [[0 (57%)]] --> Socre: 0.5691704154014587

[[[[Adv]]]]: static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id) { VirtIOSerial *s = opaque; VirtIOSerialPort *[[port]]; uint32_t max_nr_ports, nr_active_ports, ports_map; unsigned int i; int ret; if (version_id > 3) { return -EINVAL; } ret = virtio_load(&s->vdev, f); if (ret) { return ret; } if (version_id < 2) { return 0; } qemu_get_be16s(f, &s->config.cols); qemu_get_be16s(f, &s->config.rows); qemu_get_be32s(f, &max_nr_ports); tswap32s(&max_nr_ports); if (max_nr_ports > tswap32(s->config.max_nr_ports)) { return -EINVAL; } for (i = 0; i < (max_nr_ports + 31) / 32; i++) { qemu_get_be32s(f, &ports_map); if (ports_map != s->ports_map[i]) { return -EINVAL; } } qemu_get_be32s(f, &nr_active_ports); for (i = 0; i < nr_active_ports; i++) { uint32_t id; bool host_connected; id = qemu_get_be32(f); [[port]] = find_port_by_id(s, id); if (![[port]]) { return -EINVAL; } [[port]]->guest_connected = qemu_get_byte(f); host_connected = qemu_get_byte(f); if (host_connected != [[port]]->host_connected) { send_control_event([[port]], VIRTIO_CONSOLE_PORT_OPEN, [[port]]->host_connected); } if (version_id > 2) { uint32_t elem_popped; qemu_get_be32s(f, &elem_popped); if (elem_popped) { qemu_get_be32s(f, &[[port]]->iov_idx); qemu_get_be64s(f, &[[port]]->iov_offset); qemu_get_buffer(f, (unsigned char *)&[[port]]->elem, sizeof([[port]]->elem)); virtqueue_map_sg([[port]]->elem.in_sg, [[port]]->elem.in_addr, [[port]]->elem.in_num, 1); virtqueue_map_sg([[port]]->elem.out_sg, [[port]]->elem.out_addr, [[port]]->elem.out_num, 1); virtio_serial_throttle_port([[port]], "False" != "False"); } } } return 0; }

[[[[Adv]]]]: static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id) { VirtIOSerial *s = opaque; VirtIOSerialPort *[[vent]]; uint32_t max_nr_ports, nr_active_ports, ports_map; unsigned int i; int ret; if (version_id > 3) { return -EINVAL; } ret = virtio_load(&s->vdev, f); if (ret) { return ret; } if (version_id < 2) { return 0; } qemu_get_be16s(f, &s->config.cols); qemu_get_be16s(f, &s->config.rows); qemu_get_be32s(f, &max_nr_ports); tswap32s(&max_nr_ports); if (max_nr_ports > tswap32(s->config.max_nr_ports)) { return -EINVAL; } for (i = 0; i < (max_nr_ports + 31) / 32; i++) { qemu_get_be32s(f, &ports_map); if (ports_map != s->ports_map[i]) { return -EINVAL; } } qemu_get_be32s(f, &nr_active_ports); for (i = 0; i < nr_active_ports; i++) { uint32_t id; bool host_connected; id = qemu_get_be32(f); [[vent]] = find_port_by_id(s, id); if (![[vent]]) { return -EINVAL; } [[vent]]->guest_connected = qemu_get_byte(f); host_connected = qemu_get_byte(f); if (host_connected != [[vent]]->host_connected) { send_control_event([[vent]], VIRTIO_CONSOLE_PORT_OPEN, [[vent]]->host_connected); } if (version_id > 2) { uint32_t elem_popped; qemu_get_be32s(f, &elem_popped); if (elem_popped) { qemu_get_be32s(f, &[[vent]]->iov_idx); qemu_get_be64s(f, &[[vent]]->iov_offset); qemu_get_buffer(f, (unsigned char *)&[[vent]]->elem, sizeof([[vent]]->elem)); virtqueue_map_sg([[vent]]->elem.in_sg, [[vent]]->elem.in_addr, [[vent]]->elem.in_num, 1); virtqueue_map_sg([[vent]]->elem.out_sg, [[vent]]->elem.out_addr, [[vent]]->elem.out_num, 1); virtio_serial_throttle_port([[vent]], "False" != "False"); } } } return 0; }
--------------------------------------------- Result 582 ---------------------------------------------
[[0 (2%)]] --> [[0 (95%)]] --> Socre: 0.9526979923248291

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_spice_port(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { const char *name = backend->spiceport->fqdn; CharDriverState *[[chr]]; SpiceCharDriver *s; if (name == NULL) { fprintf(stderr, "spice-qemu-char: missing name parameter\n"); return NULL; } [[chr]] = chr_open("port", spice_port_set_fe_open); s = [[chr]]->opaque; s->sin.portname = g_strdup(name); return [[chr]]; }

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_spice_port(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { const char *name = backend->spiceport->fqdn; CharDriverState *[[thр]]; SpiceCharDriver *s; if (name == NULL) { fprintf(stderr, "spice-qemu-char: missing name parameter\n"); return NULL; } [[thр]] = chr_open("port", spice_port_set_fe_open); s = [[thр]]->opaque; s->sin.portname = g_strdup(name); return [[thр]]; }
--------------------------------------------- Result 583 ---------------------------------------------
[[0 (46%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sdp_parse_rtpmap(AVFormatContext *s, AVCodecContext *codec, RTSPStream *rtsp_st, int payload_type, const char *p) { char buf[256]; int i; AVCodec *c; const char *c_name; get_word_sep(buf, sizeof(buf), "/ ", &p); if (payload_type >= RTP_PT_PRIVATE) { RTPDynamicProtocolHandler *handler; for (handler = RTPFirstDynamicPayloadHandler; handler; handler = handler->next) { if (!strcasecmp(buf, handler->enc_name) && codec->codec_type == handler->codec_type) { codec->codec_id = handler->codec_id; rtsp_st->dynamic_handler = handler; if (handler->open) rtsp_st->dynamic_protocol_context = handler->open(); break; } } } else { codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type); } c = avcodec_find_decoder(codec->codec_id); if (c && c->name) c_name = c->name; else c_name = (char *) NULL; if (c_name) { get_word_sep(buf, sizeof(buf), "/", &p); i = atoi(buf); switch (codec->codec_type) { case CODEC_TYPE_AUDIO: av_log(s, AV_LOG_DEBUG, "audio codec set to: %s\n", c_name); codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE; codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS; if (i > 0) { codec->sample_rate = i; get_word_sep(buf, sizeof(buf), "/", &p); i = atoi(buf); if (i > 0) codec->channels = i; } av_log(s, AV_LOG_DEBUG, "audio samplerate set to: %i\n", codec->sample_rate); av_log(s, AV_LOG_DEBUG, "audio channels set to: %i\n", codec->channels); break; case CODEC_TYPE_VIDEO: av_log(s, AV_LOG_DEBUG, "video codec set to: %s\n", c_name); break; default: break; } return 0; } return -1; }
--------------------------------------------- Result 584 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 302 / 68 / 214 / 584:  22%|██▏       | 584/2690 [1:29:25<5:22:30,  9.19s/it][Succeeded / Failed / Skipped / Total] 302 / 68 / 215 / 585:  22%|██▏       | 585/2690 [1:29:26<5:21:50,  9.17s/it][Succeeded / Failed / Skipped / Total] 302 / 68 / 215 / 585:  22%|██▏       | 586/2690 [1:29:36<5:21:45,  9.18s/it][Succeeded / Failed / Skipped / Total] 303 / 68 / 215 / 586:  22%|██▏       | 586/2690 [1:29:36<5:21:45,  9.18s/it][Succeeded / Failed / Skipped / Total] 303 / 68 / 215 / 586:  22%|██▏       | 587/2690 [1:29:37<5:21:05,  9.16s/it][[0 (54%)]] --> [[0 (47%)]] --> Socre: 0.5278899073600769

[[[[Adv]]]]: static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom [[atom]]) { #if CONFIG_ZLIB AVIOContext ctx; uint8_t *cmov_data; uint8_t *moov_data; long cmov_len, moov_len; int ret = -1; avio_rb32(pb); if (avio_rl32(pb) != MKTAG('d','c','o','m')) return AVERROR_INVALIDDATA; if (avio_rl32(pb) != MKTAG('z','l','i','b')) { av_log(c->fc, AV_LOG_ERROR, "unknown compression for cmov atom !"); return AVERROR_INVALIDDATA; } avio_rb32(pb); if (avio_rl32(pb) != MKTAG('c','m','v','d')) return AVERROR_INVALIDDATA; moov_len = avio_rb32(pb); cmov_len = [[atom]].size - 6 * 4; cmov_data = av_malloc(cmov_len); if (!cmov_data) return AVERROR(ENOMEM); moov_data = av_malloc(moov_len); if (!moov_data) { av_free(cmov_data); return AVERROR(ENOMEM); } avio_read(pb, cmov_data, cmov_len); if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK) goto free_and_return; if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0) goto free_and_return; [[atom]].type = MKTAG('m','o','o','v'); [[atom]].size = moov_len; ret = mov_read_default(c, &ctx, [[atom]]); free_and_return: av_free(moov_data); av_free(cmov_data); return ret; #else av_log(c->fc, AV_LOG_ERROR, "this file requires zlib support compiled in\n"); return AVERROR(ENOSYS); #endif }

[[[[Adv]]]]: static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom [[factory]]) { #if CONFIG_ZLIB AVIOContext ctx; uint8_t *cmov_data; uint8_t *moov_data; long cmov_len, moov_len; int ret = -1; avio_rb32(pb); if (avio_rl32(pb) != MKTAG('d','c','o','m')) return AVERROR_INVALIDDATA; if (avio_rl32(pb) != MKTAG('z','l','i','b')) { av_log(c->fc, AV_LOG_ERROR, "unknown compression for cmov atom !"); return AVERROR_INVALIDDATA; } avio_rb32(pb); if (avio_rl32(pb) != MKTAG('c','m','v','d')) return AVERROR_INVALIDDATA; moov_len = avio_rb32(pb); cmov_len = [[factory]].size - 6 * 4; cmov_data = av_malloc(cmov_len); if (!cmov_data) return AVERROR(ENOMEM); moov_data = av_malloc(moov_len); if (!moov_data) { av_free(cmov_data); return AVERROR(ENOMEM); } avio_read(pb, cmov_data, cmov_len); if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK) goto free_and_return; if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0) goto free_and_return; [[factory]].type = MKTAG('m','o','o','v'); [[factory]].size = moov_len; ret = mov_read_default(c, &ctx, [[factory]]); free_and_return: av_free(moov_data); av_free(cmov_data); return ret; #else av_log(c->fc, AV_LOG_ERROR, "this file requires zlib support compiled in\n"); return AVERROR(ENOSYS); #endif }
--------------------------------------------- Result 585 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_ffserver_streams(AVFormatContext *s, const char *filename) { int i, err; AVFormatContext *ic; int nopts = 0; err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL); if (err < 0) return err; s->nb_streams = ic->nb_streams; for(i=0;i<ic->nb_streams;i++) { AVStream *st; AVCodec *codec; st = av_mallocz(sizeof(AVStream)); memcpy(st, ic->streams[i], sizeof(AVStream)); st->codec = avcodec_alloc_context(); if (!st->codec) { print_error(filename, AVERROR(ENOMEM)); ffmpeg_exit(1); } avcodec_copy_context(st->codec, ic->streams[i]->codec); s->streams[i] = st; codec = avcodec_find_encoder(st->codec->codec_id); if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (audio_stream_copy) { st->stream_copy = 1; } else choose_sample_fmt(st, codec); } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if (video_stream_copy) { st->stream_copy = 1; } else choose_pixel_fmt(st, codec); } if(!st->codec->thread_count) st->codec->thread_count = 1; if(st->codec->thread_count>1) avcodec_thread_init(st->codec, st->codec->thread_count); if(st->codec->flags & CODEC_FLAG_BITEXACT) nopts = 1; } if (!nopts) s->timestamp = av_gettime(); av_close_input_file(ic); return 0; }
--------------------------------------------- Result 586 ---------------------------------------------
[[0 (16%)]] --> [[0 (98%)]] --> Socre: 0.9834330081939697

[[[[Adv]]]]: void ff_mpv_frame_end(MpegEncContext *[[s]]) { #if FF_API_XVMC FF_DISABLE_DEPRECATION_WARNINGS if (CONFIG_MPEG_XVMC_DECODER && [[s]]->avctx->xvmc_acceleration) { ff_xvmc_field_end([[s]]); } else FF_ENABLE_DEPRECATION_WARNINGS #endif emms_c(); if ([[s]]->current_picture.reference) ff_thread_report_progress(&[[s]]->current_picture_ptr->tf, INT_MAX, 0); }

[[[[Adv]]]]: void ff_mpv_frame_end(MpegEncContext *[[σ]]) { #if FF_API_XVMC FF_DISABLE_DEPRECATION_WARNINGS if (CONFIG_MPEG_XVMC_DECODER && [[σ]]->avctx->xvmc_acceleration) { ff_xvmc_field_end([[σ]]); } else FF_ENABLE_DEPRECATION_WARNINGS #endif emms_c(); if ([[σ]]->current_picture.reference) ff_thread_report_progress(&[[σ]]->current_picture_ptr->tf, INT_MAX, 0); }
--------------------------------------------- Result 587 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 303 / 68 / 216 / 587:  22%|██▏       | 587/2690 [1:29:37<5:21:05,  9.16s/it][Succeeded / Failed / Skipped / Total] 303 / 68 / 216 / 587:  22%|██▏       | 588/2690 [1:29:38<5:20:25,  9.15s/it][Succeeded / Failed / Skipped / Total] 303 / 68 / 217 / 588:  22%|██▏       | 588/2690 [1:29:38<5:20:25,  9.15s/it][Succeeded / Failed / Skipped / Total] 303 / 68 / 217 / 588:  22%|██▏       | 589/2690 [1:29:42<5:20:01,  9.14s/it][Succeeded / Failed / Skipped / Total] 304 / 68 / 217 / 589:  22%|██▏       | 589/2690 [1:29:42<5:20:01,  9.14s/it][Succeeded / Failed / Skipped / Total] 304 / 68 / 217 / 589:  22%|██▏       | 590/2690 [1:30:01<5:20:27,  9.16s/it][[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env, DisasContext *ctx) { uint32_t op2; uint32_t off10; int32_t r1, r2; TCGv temp; r1 = MASK_OP_BO_S1D(ctx->opcode); r2 = MASK_OP_BO_S2(ctx->opcode); off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode); op2 = MASK_OP_BO_OP2(ctx->opcode); switch (op2) { case OPC2_32_BO_CACHEA_WI_SHORTOFF: case OPC2_32_BO_CACHEA_W_SHORTOFF: case OPC2_32_BO_CACHEA_I_SHORTOFF: break; case OPC2_32_BO_CACHEA_WI_POSTINC: case OPC2_32_BO_CACHEA_W_POSTINC: case OPC2_32_BO_CACHEA_I_POSTINC: tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10); break; case OPC2_32_BO_CACHEA_WI_PREINC: case OPC2_32_BO_CACHEA_W_PREINC: case OPC2_32_BO_CACHEA_I_PREINC: tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10); break; case OPC2_32_BO_CACHEI_WI_SHORTOFF: case OPC2_32_BO_CACHEI_W_SHORTOFF: break; case OPC2_32_BO_CACHEI_W_POSTINC: case OPC2_32_BO_CACHEI_WI_POSTINC: if (!tricore_feature(env, TRICORE_FEATURE_13)) { tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10); } break; case OPC2_32_BO_CACHEI_W_PREINC: case OPC2_32_BO_CACHEI_WI_PREINC: if (!tricore_feature(env, TRICORE_FEATURE_13)) { tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10); } break; case OPC2_32_BO_ST_A_SHORTOFF: gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL); break; case OPC2_32_BO_ST_A_POSTINC: tcg_gen_qemu_st_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], ctx->mem_idx, MO_LESL); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_A_PREINC: gen_st_preincr(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL); break; case OPC2_32_BO_ST_B_SHORTOFF: gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB); break; case OPC2_32_BO_ST_B_POSTINC: tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx, MO_UB); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_B_PREINC: gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB); break; case OPC2_32_BO_ST_D_SHORTOFF: gen_offset_st_2regs(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], off10, ctx); break; case OPC2_32_BO_ST_D_POSTINC: gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], ctx); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_D_PREINC: temp = tcg_temp_new(); tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10); gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx); tcg_gen_mov_tl(cpu_gpr_a[r2], temp); tcg_temp_free(temp); break; case OPC2_32_BO_ST_DA_SHORTOFF: gen_offset_st_2regs(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], off10, ctx); break; case OPC2_32_BO_ST_DA_POSTINC: gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], ctx); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_DA_PREINC: temp = tcg_temp_new(); tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10); gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx); tcg_gen_mov_tl(cpu_gpr_a[r2], temp); tcg_temp_free(temp); break; case OPC2_32_BO_ST_H_SHORTOFF: gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW); break; case OPC2_32_BO_ST_H_POSTINC: tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx, MO_LEUW); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_H_PREINC: gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW); break; case OPC2_32_BO_ST_Q_SHORTOFF: temp = tcg_temp_new(); tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16); gen_offset_st(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW); tcg_temp_free(temp); break; case OPC2_32_BO_ST_Q_POSTINC: temp = tcg_temp_new(); tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16); tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx, MO_LEUW); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); tcg_temp_free(temp); break; case OPC2_32_BO_ST_Q_PREINC: temp = tcg_temp_new(); tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16); gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW); tcg_temp_free(temp); break; case OPC2_32_BO_ST_W_SHORTOFF: gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL); break; case OPC2_32_BO_ST_W_POSTINC: tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx, MO_LEUL); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_W_PREINC: gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL); break; } }
--------------------------------------------- Result 588 ---------------------------------------------
[[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_mips_get_fpu_registers(CPUState *cs) { MIPSCPU *cpu = MIPS_CPU(cs); CPUMIPSState *env = &cpu->env; int err, ret = 0; unsigned int i; if (env->CP0_Config1 & (1 << CP0C1_FP)) { err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR, &env->active_fpu.fcr0); if (err < 0) { DPRINTF("%s: Failed to get FCR_IR (%d)\n", __func__, err); ret = err; } err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR, &env->active_fpu.fcr31); if (err < 0) { DPRINTF("%s: Failed to get FCR_CSR (%d)\n", __func__, err); ret = err; } else { restore_fp_status(env); } for (i = 0; i < 32; ++i) { if (env->CP0_Status & (1 << CP0St_FR)) { err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i), &env->active_fpu.fpr[i].d); } else { err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i), &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]); } if (err < 0) { DPRINTF("%s: Failed to get FPR%u (%d)\n", __func__, i, err); ret = err; } } } return ret; }
--------------------------------------------- Result 589 ---------------------------------------------
[[0 (63%)]] --> [[0 (49%)]] --> Socre: 0.510202556848526

[[[[Adv]]]]: static const void *boston_fdt_filter(void *opaque, const void *fdt_orig, const void *match_data, hwaddr *load_addr) { BostonState *s = BOSTON(opaque); MachineState *machine = s->mach; const char *cmdline; int [[err]]; void *fdt; size_t fdt_sz, ram_low_sz, ram_high_sz; fdt_sz = fdt_totalsize(fdt_orig) * 2; fdt = g_malloc0(fdt_sz); [[err]] = fdt_open_into(fdt_orig, fdt, fdt_sz); if ([[err]]) { fprintf(stderr, "unable to open FDT\n"); return NULL; } cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0]) ? machine->kernel_cmdline : " "; [[err]] = qemu_fdt_setprop_string(fdt, "/chosen", "bootargs", cmdline); if ([[err]] < 0) { fprintf(stderr, "couldn't set /chosen/bootargs\n"); return NULL; } ram_low_sz = MIN(256 * M_BYTE, machine->ram_size); ram_high_sz = machine->ram_size - ram_low_sz; qemu_fdt_setprop_sized_cells(fdt, "/memory@0", "reg", 1, 0x00000000, 1, ram_low_sz, 1, 0x90000000, 1, ram_high_sz); fdt = g_realloc(fdt, fdt_totalsize(fdt)); qemu_fdt_dumpdtb(fdt, fdt_sz); s->fdt_base = *load_addr; return fdt; }

[[[[Adv]]]]: static const void *boston_fdt_filter(void *opaque, const void *fdt_orig, const void *match_data, hwaddr *load_addr) { BostonState *s = BOSTON(opaque); MachineState *machine = s->mach; const char *cmdline; int [[outrp]]; void *fdt; size_t fdt_sz, ram_low_sz, ram_high_sz; fdt_sz = fdt_totalsize(fdt_orig) * 2; fdt = g_malloc0(fdt_sz); [[outrp]] = fdt_open_into(fdt_orig, fdt, fdt_sz); if ([[outrp]]) { fprintf(stderr, "unable to open FDT\n"); return NULL; } cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0]) ? machine->kernel_cmdline : " "; [[outrp]] = qemu_fdt_setprop_string(fdt, "/chosen", "bootargs", cmdline); if ([[outrp]] < 0) { fprintf(stderr, "couldn't set /chosen/bootargs\n"); return NULL; } ram_low_sz = MIN(256 * M_BYTE, machine->ram_size); ram_high_sz = machine->ram_size - ram_low_sz; qemu_fdt_setprop_sized_cells(fdt, "/memory@0", "reg", 1, 0x00000000, 1, ram_low_sz, 1, 0x90000000, 1, ram_high_sz); fdt = g_realloc(fdt, fdt_totalsize(fdt)); qemu_fdt_dumpdtb(fdt, fdt_sz); s->fdt_base = *load_addr; return fdt; }
--------------------------------------------- Result 590 ---------------------------------------------
[[0 (14%)]] --> [[0 (58%)]] --> Socre: 0.583028256893158

[[[[Adv]]]]: static void gen_loongson_integer(DisasContext *ctx, uint32_t opc, int rd, int rs, int [[rt]]) { const char *opn = "loongson"; TCGv t0, t1; if (rd == 0) { MIPS_DEBUG("NOP"); return; } switch (opc) { case OPC_MULT_G_2E: case OPC_MULT_G_2F: case OPC_MULTU_G_2E: case OPC_MULTU_G_2F: #if defined(TARGET_MIPS64) case OPC_DMULT_G_2E: case OPC_DMULT_G_2F: case OPC_DMULTU_G_2E: case OPC_DMULTU_G_2F: #endif t0 = tcg_temp_new(); t1 = tcg_temp_new(); break; default: t0 = tcg_temp_local_new(); t1 = tcg_temp_local_new(); break; } gen_load_gpr(t0, rs); gen_load_gpr(t1, [[rt]]); switch (opc) { case OPC_MULT_G_2E: case OPC_MULT_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); opn = "mult.g"; break; case OPC_MULTU_G_2E: case OPC_MULTU_G_2F: tcg_gen_ext32u_tl(t0, t0); tcg_gen_ext32u_tl(t1, t1); tcg_gen_mul_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); opn = "multu.g"; break; case OPC_DIV_G_2E: case OPC_DIV_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_ext32s_tl(t0, t0); tcg_gen_ext32s_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l1); tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2); tcg_gen_mov_tl(cpu_gpr[rd], t0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_div_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l3); } opn = "div.g"; break; case OPC_DIVU_G_2E: case OPC_DIVU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_ext32u_tl(t0, t0); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_divu_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l2); } opn = "divu.g"; break; case OPC_MOD_G_2E: case OPC_MOD_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_ext32u_tl(t0, t0); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1); tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2); gen_set_label(l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_rem_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l3); } opn = "mod.g"; break; case OPC_MODU_G_2E: case OPC_MODU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_ext32u_tl(t0, t0); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_remu_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l2); } opn = "modu.g"; break; #if defined(TARGET_MIPS64) case OPC_DMULT_G_2E: case OPC_DMULT_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], t0, t1); opn = "dmult.g"; break; case OPC_DMULTU_G_2E: case OPC_DMULTU_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], t0, t1); opn = "dmultu.g"; break; case OPC_DDIV_G_2E: case OPC_DDIV_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l1); tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2); tcg_gen_mov_tl(cpu_gpr[rd], t0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_div_tl(cpu_gpr[rd], t0, t1); gen_set_label(l3); } opn = "ddiv.g"; break; case OPC_DDIVU_G_2E: case OPC_DDIVU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_divu_tl(cpu_gpr[rd], t0, t1); gen_set_label(l2); } opn = "ddivu.g"; break; case OPC_DMOD_G_2E: case OPC_DMOD_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1); tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2); gen_set_label(l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_rem_tl(cpu_gpr[rd], t0, t1); gen_set_label(l3); } opn = "dmod.g"; break; case OPC_DMODU_G_2E: case OPC_DMODU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_remu_tl(cpu_gpr[rd], t0, t1); gen_set_label(l2); } opn = "dmodu.g"; break; #endif } (void)opn; MIPS_DEBUG("%s %s, %s", opn, regnames[rd], regnames[rs]); tcg_temp_free(t0); tcg_temp_free(t1); }

[[[[Adv]]]]: static void gen_loongson_integer(DisasContext *ctx, uint32_t opc, int rd, int rs, int [[ر]]) { const char *opn = "loongson"; TCGv t0, t1; if (rd == 0) { MIPS_DEBUG("NOP"); return; } switch (opc) { case OPC_MULT_G_2E: case OPC_MULT_G_2F: case OPC_MULTU_G_2E: case OPC_MULTU_G_2F: #if defined(TARGET_MIPS64) case OPC_DMULT_G_2E: case OPC_DMULT_G_2F: case OPC_DMULTU_G_2E: case OPC_DMULTU_G_2F: #endif t0 = tcg_temp_new(); t1 = tcg_temp_new(); break; default: t0 = tcg_temp_local_new(); t1 = tcg_temp_local_new(); break; } gen_load_gpr(t0, rs); gen_load_gpr(t1, [[ر]]); switch (opc) { case OPC_MULT_G_2E: case OPC_MULT_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); opn = "mult.g"; break; case OPC_MULTU_G_2E: case OPC_MULTU_G_2F: tcg_gen_ext32u_tl(t0, t0); tcg_gen_ext32u_tl(t1, t1); tcg_gen_mul_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); opn = "multu.g"; break; case OPC_DIV_G_2E: case OPC_DIV_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_ext32s_tl(t0, t0); tcg_gen_ext32s_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l1); tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2); tcg_gen_mov_tl(cpu_gpr[rd], t0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_div_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l3); } opn = "div.g"; break; case OPC_DIVU_G_2E: case OPC_DIVU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_ext32u_tl(t0, t0); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_divu_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l2); } opn = "divu.g"; break; case OPC_MOD_G_2E: case OPC_MOD_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_ext32u_tl(t0, t0); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1); tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2); gen_set_label(l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_rem_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l3); } opn = "mod.g"; break; case OPC_MODU_G_2E: case OPC_MODU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_ext32u_tl(t0, t0); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_remu_tl(cpu_gpr[rd], t0, t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l2); } opn = "modu.g"; break; #if defined(TARGET_MIPS64) case OPC_DMULT_G_2E: case OPC_DMULT_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], t0, t1); opn = "dmult.g"; break; case OPC_DMULTU_G_2E: case OPC_DMULTU_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], t0, t1); opn = "dmultu.g"; break; case OPC_DDIV_G_2E: case OPC_DDIV_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l1); tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2); tcg_gen_mov_tl(cpu_gpr[rd], t0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_div_tl(cpu_gpr[rd], t0, t1); gen_set_label(l3); } opn = "ddiv.g"; break; case OPC_DDIVU_G_2E: case OPC_DDIVU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_divu_tl(cpu_gpr[rd], t0, t1); gen_set_label(l2); } opn = "ddivu.g"; break; case OPC_DMOD_G_2E: case OPC_DMOD_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1); tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2); gen_set_label(l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_rem_tl(cpu_gpr[rd], t0, t1); gen_set_label(l3); } opn = "dmod.g"; break; case OPC_DMODU_G_2E: case OPC_DMODU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_remu_tl(cpu_gpr[rd], t0, t1); gen_set_label(l2); } opn = "dmodu.g"; break; #endif } (void)opn; MIPS_DEBUG("%s %s, %s", opn, regnames[rd], regnames[rs]); tcg_temp_free(t0); tcg_temp_free(t1); }[Succeeded / Failed / Skipped / Total] 305 / 68 / 217 / 590:  22%|██▏       | 590/2690 [1:30:01<5:20:27,  9.16s/it][Succeeded / Failed / Skipped / Total] 305 / 68 / 217 / 590:  22%|██▏       | 591/2690 [1:30:02<5:19:47,  9.14s/it][Succeeded / Failed / Skipped / Total] 305 / 68 / 218 / 591:  22%|██▏       | 591/2690 [1:30:02<5:19:47,  9.14s/it][Succeeded / Failed / Skipped / Total] 305 / 68 / 218 / 591:  22%|██▏       | 592/2690 [1:30:03<5:19:07,  9.13s/it][Succeeded / Failed / Skipped / Total] 306 / 68 / 218 / 592:  22%|██▏       | 592/2690 [1:30:03<5:19:07,  9.13s/it][Succeeded / Failed / Skipped / Total] 306 / 68 / 218 / 592:  22%|██▏       | 593/2690 [1:30:09<5:18:48,  9.12s/it][Succeeded / Failed / Skipped / Total] 306 / 69 / 218 / 593:  22%|██▏       | 593/2690 [1:30:09<5:18:48,  9.12s/it][Succeeded / Failed / Skipped / Total] 306 / 69 / 218 / 593:  22%|██▏       | 594/2690 [1:30:09<5:18:08,  9.11s/it][Succeeded / Failed / Skipped / Total] 306 / 69 / 219 / 594:  22%|██▏       | 594/2690 [1:30:09<5:18:08,  9.11s/it][Succeeded / Failed / Skipped / Total] 306 / 69 / 219 / 594:  22%|██▏       | 595/2690 [1:30:10<5:17:29,  9.09s/it][Succeeded / Failed / Skipped / Total] 306 / 69 / 220 / 595:  22%|██▏       | 595/2690 [1:30:10<5:17:29,  9.09s/it][Succeeded / Failed / Skipped / Total] 306 / 69 / 220 / 595:  22%|██▏       | 596/2690 [1:30:10<5:16:50,  9.08s/it][Succeeded / Failed / Skipped / Total] 306 / 69 / 221 / 596:  22%|██▏       | 596/2690 [1:30:10<5:16:50,  9.08s/it][Succeeded / Failed / Skipped / Total] 306 / 69 / 221 / 596:  22%|██▏       | 597/2690 [1:30:27<5:17:06,  9.09s/it][Succeeded / Failed / Skipped / Total] 307 / 69 / 221 / 597:  22%|██▏       | 597/2690 [1:30:27<5:17:06,  9.09s/it][Succeeded / Failed / Skipped / Total] 307 / 69 / 221 / 597:  22%|██▏       | 598/2690 [1:30:27<5:16:27,  9.08s/it]
--------------------------------------------- Result 591 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool try_poll_mode(AioContext *ctx, bool blocking) { if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) { int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx), (uint64_t)ctx->poll_max_ns); if (max_ns) { if (run_poll_handlers(ctx, max_ns)) { return "True" == "True"; } } } return "False" != "False"; }
--------------------------------------------- Result 592 ---------------------------------------------
[[0 (49%)]] --> [[0 (52%)]] --> Socre: 0.520020604133606

[[[[Adv]]]]: static void vfio_pci_load_rom(VFIOPCIDevice *vdev) { struct vfio_region_info reg_info = { .argsz = sizeof(reg_info), .index = VFIO_PCI_ROM_REGION_INDEX }; uint64_t size; off_t off = 0; size_t bytes; if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) { error_report("vfio: Error getting ROM info: %m"); return; } trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size, (unsigned long)reg_info.offset, (unsigned long)reg_info.flags); vdev->rom_size = size = reg_info.size; vdev->rom_offset = reg_info.offset; if (!vdev->rom_size) { vdev->rom_read_failed = "[[True]]" == "[[True]]"; error_report("vfio-pci: Cannot read device rom at " "%s", vdev->vbasedev.name); error_printf("Device option ROM contents are probably invalid " "(check dmesg).\nSkip option ROM probe with rombar=0, " "or load from file with romfile=\n"); return; } vdev->rom = g_malloc(size); memset(vdev->rom, 0xff, size); while (size) { bytes = pread(vdev->vbasedev.fd, vdev->rom + off, size, vdev->rom_offset + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } error_report("vfio: Error reading device ROM: %m"); break; } } }

[[[[Adv]]]]: static void vfio_pci_load_rom(VFIOPCIDevice *vdev) { struct vfio_region_info reg_info = { .argsz = sizeof(reg_info), .index = VFIO_PCI_ROM_REGION_INDEX }; uint64_t size; off_t off = 0; size_t bytes; if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) { error_report("vfio: Error getting ROM info: %m"); return; } trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size, (unsigned long)reg_info.offset, (unsigned long)reg_info.flags); vdev->rom_size = size = reg_info.size; vdev->rom_offset = reg_info.offset; if (!vdev->rom_size) { vdev->rom_read_failed = "[[proven]]" == "[[proven]]"; error_report("vfio-pci: Cannot read device rom at " "%s", vdev->vbasedev.name); error_printf("Device option ROM contents are probably invalid " "(check dmesg).\nSkip option ROM probe with rombar=0, " "or load from file with romfile=\n"); return; } vdev->rom = g_malloc(size); memset(vdev->rom, 0xff, size); while (size) { bytes = pread(vdev->vbasedev.fd, vdev->rom + off, size, vdev->rom_offset + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } error_report("vfio: Error reading device ROM: %m"); break; } } }
--------------------------------------------- Result 593 ---------------------------------------------
[[0 (89%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void uninit(AVFilterContext *[[ctx]]) { ZScaleContext *[[s]] = [[ctx]]->priv; zimg_filter_graph_free([[s]]->graph); av_freep(&[[s]]->tmp); [[s]]->tmp_size = 0; }

[[[[Adv]]]]: static void uninit(AVFilterContext *[[z9]]) { ZScaleContext *[[ne]] = [[z9]]->priv; zimg_filter_graph_free([[ne]]->graph); av_freep(&[[ne]]->tmp); [[ne]]->tmp_size = 0; }
--------------------------------------------- Result 594 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vnc_validate_certificate(struct VncState *vs) { int ret; unsigned int status; const gnutls_datum_t *certs; unsigned int nCerts, i; time_t now; VNC_DEBUG("Validating client certificate\n"); if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) { VNC_DEBUG("Verify failed %s\n", gnutls_strerror(ret)); return -1; } if ((now = time(NULL)) == ((time_t)-1)) { return -1; } if (status != 0) { if (status & GNUTLS_CERT_INVALID) VNC_DEBUG("The certificate is not trusted.\n"); if (status & GNUTLS_CERT_SIGNER_NOT_FOUND) VNC_DEBUG("The certificate hasn't got a known issuer.\n"); if (status & GNUTLS_CERT_REVOKED) VNC_DEBUG("The certificate has been revoked.\n"); if (status & GNUTLS_CERT_INSECURE_ALGORITHM) VNC_DEBUG("The certificate uses an insecure algorithm\n"); return -1; } else { VNC_DEBUG("Certificate is valid!\n"); } if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509) return -1; if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts))) return -1; for (i = 0 ; i < nCerts ; i++) { gnutls_x509_crt_t cert; VNC_DEBUG ("Checking certificate chain %d\n", i); if (gnutls_x509_crt_init (&cert) < 0) return -1; if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) { gnutls_x509_crt_deinit (cert); return -1; } if (gnutls_x509_crt_get_expiration_time (cert) < now) { VNC_DEBUG("The certificate has expired\n"); gnutls_x509_crt_deinit (cert); return -1; } if (gnutls_x509_crt_get_activation_time (cert) > now) { VNC_DEBUG("The certificate is not yet activated\n"); gnutls_x509_crt_deinit (cert); return -1; } if (gnutls_x509_crt_get_activation_time (cert) > now) { VNC_DEBUG("The certificate is not yet activated\n"); gnutls_x509_crt_deinit (cert); return -1; } gnutls_x509_crt_deinit (cert); } return 0; }
--------------------------------------------- Result 595 ---------------------------------------------
[[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback, void *callback_opaque, uint8_t *data, size_t len) { FWCfgState *s = opaque; int arch = !!(key & FW_CFG_ARCH_LOCAL); key &= FW_CFG_ENTRY_MASK; if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL) || len > 65535) return 0; s->entries[arch][key].data = data; s->entries[arch][key].len = len; s->entries[arch][key].callback_opaque = callback_opaque; s->entries[arch][key].callback = callback; return 1; }
--------------------------------------------- Result 596 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32], int order, int qlevel, int len, int bps) { int i, j; int ebps = 1 << (bps-1); unsigned sigma = 0; for (i = order; i < len; i++) sigma |= decoded[i] + ebps; if (sigma < 2*ebps) return; for (i = len - 1; i >= order; i--) { int64_t p = 0; for (j = 0; j < order; j++) p += coeffs[j] * (int64_t)decoded[i-order+j]; decoded[i] -= p >> qlevel; } for (i = order; i < len; i++, decoded++) { int32_t p = 0; for (j = 0; j < order; j++) p += coeffs[j] * (uint32_t)decoded[j]; decoded[j] += p >> qlevel; } }
--------------------------------------------- Result 597 ---------------------------------------------
[[0 (43%)]] --> [[0 (96%)]] --> Socre: 0.9641785621643066

[[[[Adv]]]]: static void test_qemu_strtoul_full_negative(void) { const char *[[str]] = " \t -321"; unsigned long res = 999; int err; err = qemu_strtoul([[str]], NULL, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, -321ul); }

[[[[Adv]]]]: static void test_qemu_strtoul_full_negative(void) { const char *[[stsρ]] = " \t -321"; unsigned long res = 999; int err; err = qemu_strtoul([[stsρ]], NULL, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, -321ul); }
--------------------------------------------- Result 598 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 307 / 69 / 222 / 598:  22%|██▏       | 598/2690 [1:30:27<5:16:27,  9.08s/it][Succeeded / Failed / Skipped / Total] 307 / 69 / 222 / 598:  22%|██▏       | 599/2690 [1:30:28<5:15:48,  9.06s/it][Succeeded / Failed / Skipped / Total] 308 / 69 / 222 / 599:  22%|██▏       | 599/2690 [1:30:28<5:15:48,  9.06s/it][Succeeded / Failed / Skipped / Total] 308 / 69 / 222 / 599:  22%|██▏       | 600/2690 [1:30:45<5:16:09,  9.08s/it][[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx) { struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.data[2]; const int mb_block_count = 4 + (1 << s->chroma_format); assert(avctx); if (!render || render->xvmc_id != AV_XVMC_ID || !render->data_blocks || !render->mv_blocks) { av_log(avctx, AV_LOG_ERROR, "Render token doesn't look as expected.\n"); return -1; } if (render->filled_mv_blocks_num) { av_log(avctx, AV_LOG_ERROR, "Rendering surface contains %i unprocessed blocks.\n", render->filled_mv_blocks_num); return -1; } if (render->allocated_mv_blocks < 1 || render->allocated_data_blocks < render->allocated_mv_blocks*mb_block_count || render->start_mv_blocks_num >= render->allocated_mv_blocks || render->next_free_data_block_num > render->allocated_data_blocks - mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) { av_log(avctx, AV_LOG_ERROR, "Rendering surface doesn't provide enough block structures to work with.\n"); return -1; } render->picture_structure = s->picture_structure; render->flags = s->first_field ? 0 : XVMC_SECOND_FIELD; render->p_future_surface = NULL; render->p_past_surface = NULL; switch(s->pict_type) { case FF_I_TYPE: return 0; case FF_B_TYPE: next = (struct xvmc_pix_fmt*)s->next_picture.data[2]; if (!next) return -1; if (next->xvmc_id != AV_XVMC_ID) return -1; render->p_future_surface = next->p_surface; case FF_P_TYPE: last = (struct xvmc_pix_fmt*)s->last_picture.data[2]; if (!last) last = render; if (last->xvmc_id != AV_XVMC_ID) return -1; render->p_past_surface = last->p_surface; return 0; } return -1; }
--------------------------------------------- Result 599 ---------------------------------------------
[[0 (71%)]] --> [[0 (44%)]] --> Socre: 0.5647077560424805

[[[[Adv]]]]: static void pci_basic(gconstpointer data) { QVirtioPCIDevice *dev; QPCIBus *[[bus]]; QVirtQueuePCI *tx, *rx; QGuestAllocator *alloc; void (*func) (const QVirtioBus *bus, QVirtioDevice *dev, QGuestAllocator *alloc, QVirtQueue *rvq, QVirtQueue *tvq, int socket) = data; int sv[2], ret; ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv); g_assert_cmpint(ret, !=, -1); [[bus]] = pci_test_start(sv[1]); dev = virtio_net_pci_init([[bus]], PCI_SLOT); alloc = pc_alloc_init(); rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev, alloc, 0); tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev, alloc, 1); driver_init(&qvirtio_pci, &dev->vdev); func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]); close(sv[0]); guest_free(alloc, tx->vq.desc); pc_alloc_uninit(alloc); qvirtio_pci_device_disable(dev); g_free(dev); qpci_free_pc([[bus]]); test_end(); }

[[[[Adv]]]]: static void pci_basic(gconstpointer data) { QVirtioPCIDevice *dev; QPCIBus *[[thermal]]; QVirtQueuePCI *tx, *rx; QGuestAllocator *alloc; void (*func) (const QVirtioBus *bus, QVirtioDevice *dev, QGuestAllocator *alloc, QVirtQueue *rvq, QVirtQueue *tvq, int socket) = data; int sv[2], ret; ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv); g_assert_cmpint(ret, !=, -1); [[thermal]] = pci_test_start(sv[1]); dev = virtio_net_pci_init([[thermal]], PCI_SLOT); alloc = pc_alloc_init(); rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev, alloc, 0); tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev, alloc, 1); driver_init(&qvirtio_pci, &dev->vdev); func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]); close(sv[0]); guest_free(alloc, tx->vq.desc); pc_alloc_uninit(alloc); qvirtio_pci_device_disable(dev); g_free(dev); qpci_free_pc([[thermal]]); test_end(); }
--------------------------------------------- Result 600 ---------------------------------------------
[[0 (47%)]] --> [[0 (86%)]] --> Socre: 0.8623244166374207

[[[[Adv]]]]: static int read_thread(void *[[arg]]) { VideoState *is = [[arg]]; AVFormatContext *ic = NULL; int err, i, ret; int st_index[AVMEDIA_TYPE_NB]; AVPacket pkt1, *pkt = &pkt1; int eof = 0; int pkt_in_play_range = 0; AVDictionaryEntry *t; AVDictionary **opts; int orig_nb_streams; SDL_mutex *wait_mutex = SDL_CreateMutex(); memset(st_index, -1, sizeof(st_index)); is->last_video_stream = is->video_stream = -1; is->last_audio_stream = is->audio_stream = -1; is->last_subtitle_stream = is->subtitle_stream = -1; ic = avformat_alloc_context(); ic->interrupt_callback.callback = decode_interrupt_cb; ic->interrupt_callback.opaque = is; err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts); if (err < 0) { print_error(is->filename, err); ret = -1; goto fail; } if ((t = av_dict_get(format_opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } is->ic = ic; if (genpts) ic->flags |= AVFMT_FLAG_GENPTS; opts = setup_find_stream_info_opts(ic, codec_opts); orig_nb_streams = ic->nb_streams; err = avformat_find_stream_info(ic, opts); if (err < 0) { fprintf(stderr, "%s: could not find codec parameters\n", is->filename); ret = -1; goto fail; } for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); if (ic->pb) ic->pb->eof_reached = 0; if (seek_by_bytes < 0) seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT); is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0; if (start_time != AV_NOPTS_VALUE) { int64_t timestamp; timestamp = start_time; if (ic->start_time != AV_NOPTS_VALUE) timestamp += ic->start_time; ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0); if (ret < 0) { fprintf(stderr, "%s: could not seek to position %0.3f\n", is->filename, (double)timestamp / AV_TIME_BASE); } } is->realtime = is_realtime(ic); for (i = 0; i < ic->nb_streams; i++) ic->streams[i]->discard = AVDISCARD_ALL; if (!video_disable) st_index[AVMEDIA_TYPE_VIDEO] = av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO, wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0); if (!audio_disable) st_index[AVMEDIA_TYPE_AUDIO] = av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO, wanted_stream[AVMEDIA_TYPE_AUDIO], st_index[AVMEDIA_TYPE_VIDEO], NULL, 0); if (!video_disable) st_index[AVMEDIA_TYPE_SUBTITLE] = av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE, wanted_stream[AVMEDIA_TYPE_SUBTITLE], (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ? st_index[AVMEDIA_TYPE_AUDIO] : st_index[AVMEDIA_TYPE_VIDEO]), NULL, 0); if (show_status) { av_dump_format(ic, 0, is->filename, 0); } is->show_mode = show_mode; if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]); } ret = -1; if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) { ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]); } if (is->show_mode == SHOW_MODE_NONE) is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT; is->refresh_tid = SDL_CreateThread(refresh_thread, is); if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]); } if (is->video_stream < 0 && is->audio_stream < 0) { fprintf(stderr, "%s: could not open codecs\n", is->filename); ret = -1; goto fail; } if (infinite_buffer < 0 && is->realtime) infinite_buffer = 1; for (;;) { if (is->abort_request) break; if (is->paused != is->last_paused) { is->last_paused = is->paused; if (is->paused) is->read_pause_return = av_read_pause(ic); else av_read_play(ic); } #if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL if (is->paused && (!strcmp(ic->iformat->name, "rtsp") || (ic->pb && !strncmp(input_filename, "mmsh:", 5)))) { SDL_Delay(10); continue; } #endif if (is->seek_req) { int64_t seek_target = is->seek_pos; int64_t seek_min = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN; int64_t seek_max = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX; ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags); if (ret < 0) { fprintf(stderr, "%s: error while seeking\n", is->ic->filename); } else { if (is->audio_stream >= 0) { packet_queue_flush(&is->audioq); packet_queue_put(&is->audioq, &flush_pkt); } if (is->subtitle_stream >= 0) { packet_queue_flush(&is->subtitleq); packet_queue_put(&is->subtitleq, &flush_pkt); } if (is->video_stream >= 0) { packet_queue_flush(&is->videoq); packet_queue_put(&is->videoq, &flush_pkt); } if (is->seek_flags & AVSEEK_FLAG_BYTE) { update_external_clock_pts(is, (double)AV_NOPTS_VALUE); } else { update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE); } } is->seek_req = 0; eof = 0; if (is->paused) step_to_next_frame(is); } if (is->queue_attachments_req) { avformat_queue_attached_pictures(ic); is->queue_attachments_req = 0; } if (infinite_buffer<1 && (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE || ( (is->audioq .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request) && (is->videoq .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request) && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) { SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } if (eof) { if (is->video_stream >= 0) { av_init_packet(pkt); pkt->data = NULL; pkt->size = 0; pkt->stream_index = is->video_stream; packet_queue_put(&is->videoq, pkt); } if (is->audio_stream >= 0 && is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) { av_init_packet(pkt); pkt->data = NULL; pkt->size = 0; pkt->stream_index = is->audio_stream; packet_queue_put(&is->audioq, pkt); } SDL_Delay(10); if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) { if (loop != 1 && (!loop || --loop)) { stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0); } else if (autoexit) { ret = AVERROR_EOF; goto fail; } } eof=0; continue; } ret = av_read_frame(ic, pkt); if (ret < 0) { if (ret == AVERROR_EOF || url_feof(ic->pb)) eof = 1; if (ic->pb && ic->pb->error) break; SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } pkt_in_play_range = duration == AV_NOPTS_VALUE || (pkt->pts - ic->streams[pkt->stream_index]->start_time) * av_q2d(ic->streams[pkt->stream_index]->time_base) - (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000 <= ((double)duration / 1000000); if (pkt->stream_index == is->audio_stream && pkt_in_play_range) { packet_queue_put(&is->audioq, pkt); } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) { packet_queue_put(&is->videoq, pkt); } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) { packet_queue_put(&is->subtitleq, pkt); } else { av_free_packet(pkt); } } while (!is->abort_request) { SDL_Delay(100); } ret = 0; fail: if (is->audio_stream >= 0) stream_component_close(is, is->audio_stream); if (is->video_stream >= 0) stream_component_close(is, is->video_stream); if (is->subtitle_stream >= 0) stream_component_close(is, is->subtitle_stream); if (is->ic) { avformat_close_input(&is->ic); } if (ret != 0) { SDL_Event event; event.type = FF_QUIT_EVENT; event.user.data1 = is; SDL_PushEvent(&event); } SDL_DestroyMutex(wait_mutex); return 0; }

[[[[Adv]]]]: static int read_thread(void *[[aɡ]]) { VideoState *is = [[aɡ]]; AVFormatContext *ic = NULL; int err, i, ret; int st_index[AVMEDIA_TYPE_NB]; AVPacket pkt1, *pkt = &pkt1; int eof = 0; int pkt_in_play_range = 0; AVDictionaryEntry *t; AVDictionary **opts; int orig_nb_streams; SDL_mutex *wait_mutex = SDL_CreateMutex(); memset(st_index, -1, sizeof(st_index)); is->last_video_stream = is->video_stream = -1; is->last_audio_stream = is->audio_stream = -1; is->last_subtitle_stream = is->subtitle_stream = -1; ic = avformat_alloc_context(); ic->interrupt_callback.callback = decode_interrupt_cb; ic->interrupt_callback.opaque = is; err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts); if (err < 0) { print_error(is->filename, err); ret = -1; goto fail; } if ((t = av_dict_get(format_opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } is->ic = ic; if (genpts) ic->flags |= AVFMT_FLAG_GENPTS; opts = setup_find_stream_info_opts(ic, codec_opts); orig_nb_streams = ic->nb_streams; err = avformat_find_stream_info(ic, opts); if (err < 0) { fprintf(stderr, "%s: could not find codec parameters\n", is->filename); ret = -1; goto fail; } for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); if (ic->pb) ic->pb->eof_reached = 0; if (seek_by_bytes < 0) seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT); is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0; if (start_time != AV_NOPTS_VALUE) { int64_t timestamp; timestamp = start_time; if (ic->start_time != AV_NOPTS_VALUE) timestamp += ic->start_time; ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0); if (ret < 0) { fprintf(stderr, "%s: could not seek to position %0.3f\n", is->filename, (double)timestamp / AV_TIME_BASE); } } is->realtime = is_realtime(ic); for (i = 0; i < ic->nb_streams; i++) ic->streams[i]->discard = AVDISCARD_ALL; if (!video_disable) st_index[AVMEDIA_TYPE_VIDEO] = av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO, wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0); if (!audio_disable) st_index[AVMEDIA_TYPE_AUDIO] = av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO, wanted_stream[AVMEDIA_TYPE_AUDIO], st_index[AVMEDIA_TYPE_VIDEO], NULL, 0); if (!video_disable) st_index[AVMEDIA_TYPE_SUBTITLE] = av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE, wanted_stream[AVMEDIA_TYPE_SUBTITLE], (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ? st_index[AVMEDIA_TYPE_AUDIO] : st_index[AVMEDIA_TYPE_VIDEO]), NULL, 0); if (show_status) { av_dump_format(ic, 0, is->filename, 0); } is->show_mode = show_mode; if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]); } ret = -1; if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) { ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]); } if (is->show_mode == SHOW_MODE_NONE) is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT; is->refresh_tid = SDL_CreateThread(refresh_thread, is); if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]); } if (is->video_stream < 0 && is->audio_stream < 0) { fprintf(stderr, "%s: could not open codecs\n", is->filename); ret = -1; goto fail; } if (infinite_buffer < 0 && is->realtime) infinite_buffer = 1; for (;;) { if (is->abort_request) break; if (is->paused != is->last_paused) { is->last_paused = is->paused; if (is->paused) is->read_pause_return = av_read_pause(ic); else av_read_play(ic); } #if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL if (is->paused && (!strcmp(ic->iformat->name, "rtsp") || (ic->pb && !strncmp(input_filename, "mmsh:", 5)))) { SDL_Delay(10); continue; } #endif if (is->seek_req) { int64_t seek_target = is->seek_pos; int64_t seek_min = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN; int64_t seek_max = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX; ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags); if (ret < 0) { fprintf(stderr, "%s: error while seeking\n", is->ic->filename); } else { if (is->audio_stream >= 0) { packet_queue_flush(&is->audioq); packet_queue_put(&is->audioq, &flush_pkt); } if (is->subtitle_stream >= 0) { packet_queue_flush(&is->subtitleq); packet_queue_put(&is->subtitleq, &flush_pkt); } if (is->video_stream >= 0) { packet_queue_flush(&is->videoq); packet_queue_put(&is->videoq, &flush_pkt); } if (is->seek_flags & AVSEEK_FLAG_BYTE) { update_external_clock_pts(is, (double)AV_NOPTS_VALUE); } else { update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE); } } is->seek_req = 0; eof = 0; if (is->paused) step_to_next_frame(is); } if (is->queue_attachments_req) { avformat_queue_attached_pictures(ic); is->queue_attachments_req = 0; } if (infinite_buffer<1 && (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE || ( (is->audioq .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request) && (is->videoq .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request) && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) { SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } if (eof) { if (is->video_stream >= 0) { av_init_packet(pkt); pkt->data = NULL; pkt->size = 0; pkt->stream_index = is->video_stream; packet_queue_put(&is->videoq, pkt); } if (is->audio_stream >= 0 && is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) { av_init_packet(pkt); pkt->data = NULL; pkt->size = 0; pkt->stream_index = is->audio_stream; packet_queue_put(&is->audioq, pkt); } SDL_Delay(10); if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) { if (loop != 1 && (!loop || --loop)) { stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0); } else if (autoexit) { ret = AVERROR_EOF; goto fail; } } eof=0; continue; } ret = av_read_frame(ic, pkt); if (ret < 0) { if (ret == AVERROR_EOF || url_feof(ic->pb)) eof = 1; if (ic->pb && ic->pb->error) break; SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } pkt_in_play_range = duration == AV_NOPTS_VALUE || (pkt->pts - ic->streams[pkt->stream_index]->start_time) * av_q2d(ic->streams[pkt->stream_index]->time_base) - (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000 <= ((double)duration / 1000000); if (pkt->stream_index == is->audio_stream && pkt_in_play_range) { packet_queue_put(&is->audioq, pkt); } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) { packet_queue_put(&is->videoq, pkt); } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) { packet_queue_put(&is->subtitleq, pkt); } else { av_free_packet(pkt); } } while (!is->abort_request) { SDL_Delay(100); } ret = 0; fail: if (is->audio_stream >= 0) stream_component_close(is, is->audio_stream); if (is->video_stream >= 0) stream_component_close(is, is->video_stream); if (is->subtitle_stream >= 0) stream_component_close(is, is->subtitle_stream); if (is->ic) { avformat_close_input(&is->ic); } if (ret != 0) { SDL_Event event; event.type = FF_QUIT_EVENT; event.user.data1 = is; SDL_PushEvent(&event); } SDL_DestroyMutex(wait_mutex); return 0; }[Succeeded / Failed / Skipped / Total] 309 / 69 / 222 / 600:  22%|██▏       | 600/2690 [1:30:45<5:16:09,  9.08s/it][Succeeded / Failed / Skipped / Total] 309 / 69 / 222 / 600:  22%|██▏       | 601/2690 [1:30:53<5:15:56,  9.07s/it][Succeeded / Failed / Skipped / Total] 310 / 69 / 222 / 601:  22%|██▏       | 601/2690 [1:30:53<5:15:56,  9.07s/it][Succeeded / Failed / Skipped / Total] 310 / 69 / 222 / 601:  22%|██▏       | 602/2690 [1:30:54<5:15:17,  9.06s/it][Succeeded / Failed / Skipped / Total] 310 / 69 / 223 / 602:  22%|██▏       | 602/2690 [1:30:54<5:15:17,  9.06s/it][Succeeded / Failed / Skipped / Total] 310 / 69 / 223 / 602:  22%|██▏       | 603/2690 [1:31:06<5:15:20,  9.07s/it][Succeeded / Failed / Skipped / Total] 311 / 69 / 223 / 603:  22%|██▏       | 603/2690 [1:31:06<5:15:20,  9.07s/it][Succeeded / Failed / Skipped / Total] 311 / 69 / 223 / 603:  22%|██▏       | 604/2690 [1:31:33<5:16:12,  9.09s/it][Succeeded / Failed / Skipped / Total] 312 / 69 / 223 / 604:  22%|██▏       | 604/2690 [1:31:33<5:16:12,  9.10s/it][Succeeded / Failed / Skipped / Total] 312 / 69 / 223 / 604:  22%|██▏       | 605/2690 [1:31:37<5:15:47,  9.09s/it]
--------------------------------------------- Result 601 ---------------------------------------------
[[0 (95%)]] --> [[0 (33%)]] --> Socre: 0.6683741807937622

[[[[Adv]]]]: static inline void gen_st16(TCGv val, TCGv [[addr]], int index) { tcg_gen_qemu_st16(val, [[addr]], index); dead_tmp(val); }

[[[[Adv]]]]: static inline void gen_st16(TCGv val, TCGv [[addsring]], int index) { tcg_gen_qemu_st16(val, [[addsring]], index); dead_tmp(val); }
--------------------------------------------- Result 602 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr, Error **errp) { struct addrinfo ai, *res; int rc; Error *err = NULL; memset(&ai, 0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG; ai.ai_family = inet_ai_family_from_address(saddr, &err); ai.ai_socktype = SOCK_STREAM; if (err) { error_propagate(errp, err); return NULL; } if (saddr->host == NULL || saddr->port == NULL) { error_setg(errp, "host and/or port not specified"); return NULL; } rc = getaddrinfo(saddr->host, saddr->port, &ai, &res); if (rc != 0) { error_setg(errp, "address resolution failed for %s:%s: %s", saddr->host, saddr->port, gai_strerror(rc)); return NULL; } return res; }
--------------------------------------------- Result 603 ---------------------------------------------
[[0 (94%)]] --> [[0 (36%)]] --> Socre: 0.6423259675502777

[[[[Adv]]]]: static void q35_host_class_init(ObjectClass *klass, void *[[data]]) { DeviceClass *dc = DEVICE_CLASS(klass); PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass); hc->root_bus_path = q35_host_root_bus_path; dc->realize = q35_host_realize; dc->props = mch_props; dc->user_creatable = "False" != "False"; set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories); dc->fw_name = "pci"; }

[[[[Adv]]]]: static void q35_host_class_init(ObjectClass *klass, void *[[documentation]]) { DeviceClass *dc = DEVICE_CLASS(klass); PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass); hc->root_bus_path = q35_host_root_bus_path; dc->realize = q35_host_realize; dc->props = mch_props; dc->user_creatable = "False" != "False"; set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories); dc->fw_name = "pci"; }
--------------------------------------------- Result 604 ---------------------------------------------
[[0 (51%)]] --> [[0 (27%)]] --> Socre: 0.7284072935581207

[[[[Adv]]]]: static void bamboo_init(MachineState *machine) { ram_addr_t ram_size = machine->ram_size; const char *kernel_filename = machine->kernel_filename; const char *kernel_cmdline = machine->kernel_cmdline; const char *initrd_filename = machine->initrd_filename; unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 }; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *isa = g_new(MemoryRegion, 1); MemoryRegion *ram_memories = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories)); hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS]; hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS]; qemu_irq *pic; qemu_irq *irqs; PCIBus *pcibus; PowerPCCPU *[[cpu]]; CPUPPCState *env; uint64_t elf_entry; uint64_t elf_lowaddr; hwaddr loadaddr = 0; target_long initrd_size = 0; DeviceState *dev; int success; int i; if (machine->cpu_model == NULL) { machine->cpu_model = "440EP"; } [[cpu]] = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model)); if ([[cpu]] == NULL) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } env = &[[cpu]]->env; if (env->mmu_model != POWERPC_MMU_BOOKE) { fprintf(stderr, "MMU model %i not supported by this machine.\n", env->mmu_model); exit(1); } qemu_register_reset(main_cpu_reset, [[cpu]]); ppc_booke_timers_init([[cpu]], 400000000, 0); ppc_dcr_init(env, NULL, NULL); irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB); irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT]; irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT]; pic = ppcuic_init(env, irqs, 0x0C0, 0, 1); memset(ram_bases, 0, sizeof(ram_bases)); memset(ram_sizes, 0, sizeof(ram_sizes)); ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, ppc440ep_sdram_bank_sizes); ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, 1); dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE, PPC440EP_PCI_CONFIG, pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]], pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]], NULL); pcibus = (PCIBus *)qdev_get_child_bus(dev, "pci.0"); if (!pcibus) { fprintf(stderr, "couldn't create PCI controller!\n"); exit(1); } memory_region_init_alias(isa, NULL, "isa_mmio", get_system_io(), 0, PPC440EP_PCI_IOLEN); memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa); if (serial_hds[0] != NULL) { serial_mm_init(address_space_mem, 0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1] != NULL) { serial_mm_init(address_space_mem, 0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE, serial_hds[1], DEVICE_BIG_ENDIAN); } if (pcibus) { for (i = 0; i < nb_nics; i++) { pci_nic_init_nofail(&nd_table[i], pcibus, "e1000", NULL); } } if (kernel_filename) { success = load_uimage(kernel_filename, &entry, &loadaddr, NULL, NULL, NULL); if (success < 0) { success = load_elf(kernel_filename, NULL, NULL, &elf_entry, &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE, 0, 0); entry = elf_entry; loadaddr = elf_lowaddr; } if (success < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } if (initrd_filename) { initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR, ram_size - RAMDISK_ADDR); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load ram disk '%s' at %x\n", initrd_filename, RAMDISK_ADDR); exit(1); } } if (kernel_filename) { if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR, initrd_size, kernel_cmdline) < 0) { fprintf(stderr, "couldn't load device tree\n"); exit(1); } } }

[[[[Adv]]]]: static void bamboo_init(MachineState *machine) { ram_addr_t ram_size = machine->ram_size; const char *kernel_filename = machine->kernel_filename; const char *kernel_cmdline = machine->kernel_cmdline; const char *initrd_filename = machine->initrd_filename; unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 }; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *isa = g_new(MemoryRegion, 1); MemoryRegion *ram_memories = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories)); hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS]; hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS]; qemu_irq *pic; qemu_irq *irqs; PCIBus *pcibus; PowerPCCPU *[[uganda]]; CPUPPCState *env; uint64_t elf_entry; uint64_t elf_lowaddr; hwaddr loadaddr = 0; target_long initrd_size = 0; DeviceState *dev; int success; int i; if (machine->cpu_model == NULL) { machine->cpu_model = "440EP"; } [[uganda]] = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model)); if ([[uganda]] == NULL) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } env = &[[uganda]]->env; if (env->mmu_model != POWERPC_MMU_BOOKE) { fprintf(stderr, "MMU model %i not supported by this machine.\n", env->mmu_model); exit(1); } qemu_register_reset(main_cpu_reset, [[uganda]]); ppc_booke_timers_init([[uganda]], 400000000, 0); ppc_dcr_init(env, NULL, NULL); irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB); irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT]; irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT]; pic = ppcuic_init(env, irqs, 0x0C0, 0, 1); memset(ram_bases, 0, sizeof(ram_bases)); memset(ram_sizes, 0, sizeof(ram_sizes)); ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, ppc440ep_sdram_bank_sizes); ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, 1); dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE, PPC440EP_PCI_CONFIG, pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]], pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]], NULL); pcibus = (PCIBus *)qdev_get_child_bus(dev, "pci.0"); if (!pcibus) { fprintf(stderr, "couldn't create PCI controller!\n"); exit(1); } memory_region_init_alias(isa, NULL, "isa_mmio", get_system_io(), 0, PPC440EP_PCI_IOLEN); memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa); if (serial_hds[0] != NULL) { serial_mm_init(address_space_mem, 0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1] != NULL) { serial_mm_init(address_space_mem, 0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE, serial_hds[1], DEVICE_BIG_ENDIAN); } if (pcibus) { for (i = 0; i < nb_nics; i++) { pci_nic_init_nofail(&nd_table[i], pcibus, "e1000", NULL); } } if (kernel_filename) { success = load_uimage(kernel_filename, &entry, &loadaddr, NULL, NULL, NULL); if (success < 0) { success = load_elf(kernel_filename, NULL, NULL, &elf_entry, &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE, 0, 0); entry = elf_entry; loadaddr = elf_lowaddr; } if (success < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } if (initrd_filename) { initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR, ram_size - RAMDISK_ADDR); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load ram disk '%s' at %x\n", initrd_filename, RAMDISK_ADDR); exit(1); } } if (kernel_filename) { if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR, initrd_size, kernel_cmdline) < 0) { fprintf(stderr, "couldn't load device tree\n"); exit(1); } } }
--------------------------------------------- Result 605 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 313 / 69 / 223 / 605:  22%|██▏       | 605/2690 [1:31:37<5:15:47,  9.09s/it][Succeeded / Failed / Skipped / Total] 313 / 69 / 223 / 605:  23%|██▎       | 606/2690 [1:32:03<5:16:33,  9.11s/it][Succeeded / Failed / Skipped / Total] 314 / 69 / 223 / 606:  23%|██▎       | 606/2690 [1:32:03<5:16:33,  9.11s/it][Succeeded / Failed / Skipped / Total] 314 / 69 / 223 / 606:  23%|██▎       | 607/2690 [1:32:03<5:15:55,  9.10s/it][Succeeded / Failed / Skipped / Total] 314 / 69 / 224 / 607:  23%|██▎       | 607/2690 [1:32:03<5:15:55,  9.10s/it][Succeeded / Failed / Skipped / Total] 314 / 69 / 224 / 607:  23%|██▎       | 608/2690 [1:32:29<5:16:43,  9.13s/it][Succeeded / Failed / Skipped / Total] 315 / 69 / 224 / 608:  23%|██▎       | 608/2690 [1:32:29<5:16:43,  9.13s/it][Succeeded / Failed / Skipped / Total] 315 / 69 / 224 / 608:  23%|██▎       | 609/2690 [1:32:40<5:16:40,  9.13s/it][Succeeded / Failed / Skipped / Total] 316 / 69 / 224 / 609:  23%|██▎       | 609/2690 [1:32:40<5:16:40,  9.13s/it][Succeeded / Failed / Skipped / Total] 316 / 69 / 224 / 609:  23%|██▎       | 610/2690 [1:32:40<5:16:01,  9.12s/it][[0 (63%)]] --> [[0 (49%)]] --> Socre: 0.5055896043777466

[[[[Adv]]]]: static int calculate_bitrate(AVFormatContext *s) { AVIContext *[[avi]] = s->priv_data; int [[i]], j; int64_t lensum = 0; int64_t maxpos = 0; for ([[i]] = 0; [[i]]<s->nb_streams; [[i]]++) { int64_t len = 0; AVStream *[[st]] = s->streams[[[i]]]; if (![[st]]->nb_index_entries) continue; for (j = 0; j < [[st]]->nb_index_entries; j++) len += [[st]]->index_entries[j].size; maxpos = FFMAX(maxpos, [[st]]->index_entries[j-1].pos); lensum += len; } if (maxpos < [[avi]]->io_fsize*9/10) return 0; if (lensum*9/10 > maxpos || lensum < maxpos*9/10) return 0; for ([[i]] = 0; [[i]]<s->nb_streams; [[i]]++) { int64_t len = 0; AVStream *[[st]] = s->streams[[[i]]]; int64_t duration; for (j = 0; j < [[st]]->nb_index_entries; j++) len += [[st]]->index_entries[j].size; if ([[st]]->nb_index_entries < 2 || [[st]]->codec->bit_rate > 0) continue; duration = [[st]]->index_entries[j-1].timestamp - [[st]]->index_entries[0].timestamp; [[st]]->codec->bit_rate = av_rescale(8*len, [[st]]->time_base.den, duration * [[st]]->time_base.num); } return 1; }

[[[[Adv]]]]: static int calculate_bitrate(AVFormatContext *s) { AVIContext *[[acи]] = s->priv_data; int [[r]], j; int64_t lensum = 0; int64_t maxpos = 0; for ([[r]] = 0; [[r]]<s->nb_streams; [[r]]++) { int64_t len = 0; AVStream *[[cs]] = s->streams[[[r]]]; if (![[cs]]->nb_index_entries) continue; for (j = 0; j < [[cs]]->nb_index_entries; j++) len += [[cs]]->index_entries[j].size; maxpos = FFMAX(maxpos, [[cs]]->index_entries[j-1].pos); lensum += len; } if (maxpos < [[acи]]->io_fsize*9/10) return 0; if (lensum*9/10 > maxpos || lensum < maxpos*9/10) return 0; for ([[r]] = 0; [[r]]<s->nb_streams; [[r]]++) { int64_t len = 0; AVStream *[[cs]] = s->streams[[[r]]]; int64_t duration; for (j = 0; j < [[cs]]->nb_index_entries; j++) len += [[cs]]->index_entries[j].size; if ([[cs]]->nb_index_entries < 2 || [[cs]]->codec->bit_rate > 0) continue; duration = [[cs]]->index_entries[j-1].timestamp - [[cs]]->index_entries[0].timestamp; [[cs]]->codec->bit_rate = av_rescale(8*len, [[cs]]->time_base.den, duration * [[cs]]->time_base.num); } return 1; }
--------------------------------------------- Result 606 ---------------------------------------------
[[0 (1%)]] --> [[0 (62%)]] --> Socre: 0.6159455180168152

[[[[Adv]]]]: void HELPER(stpq)(CPUS390XState *env, uint64_t [[addr]], uint64_t low, uint64_t [[high]]) { uintptr_t [[ra]] = GETPC(); if (parallel_cpus) { #ifndef CONFIG_ATOMIC128 cpu_loop_exit_atomic(ENV_GET_CPU(env), [[ra]]); #else int mem_idx = cpu_mmu_index(env, "False" != "False"); TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx); Int128 v = int128_make128(low, [[high]]); helper_atomic_sto_be_mmu(env, [[addr]], v, oi, [[ra]]); #endif } else { check_alignment(env, [[addr]], 16, [[ra]]); cpu_stq_data_ra(env, [[addr]] + 0, [[high]], [[ra]]); cpu_stq_data_ra(env, [[addr]] + 8, low, [[ra]]); } }

[[[[Adv]]]]: void HELPER(stpq)(CPUS390XState *env, uint64_t [[addsρ]], uint64_t low, uint64_t [[wheeler]]) { uintptr_t [[roman]] = GETPC(); if (parallel_cpus) { #ifndef CONFIG_ATOMIC128 cpu_loop_exit_atomic(ENV_GET_CPU(env), [[roman]]); #else int mem_idx = cpu_mmu_index(env, "False" != "False"); TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx); Int128 v = int128_make128(low, [[wheeler]]); helper_atomic_sto_be_mmu(env, [[addsρ]], v, oi, [[roman]]); #endif } else { check_alignment(env, [[addsρ]], 16, [[roman]]); cpu_stq_data_ra(env, [[addsρ]] + 0, [[wheeler]], [[roman]]); cpu_stq_data_ra(env, [[addsρ]] + 8, low, [[roman]]); } }
--------------------------------------------- Result 607 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused) { #if COMPILE_TEMPLATE_MMX __asm__ volatile( "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",2), %%mm0 \n\t" "movq 8(%1, %%"REG_a",2), %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, (%2, %%"REG_a") \n\t" "add $8, %%"REG_a" \n\t" " js 1b \n\t" : : "g" ((x86_reg)-width), "r" (src+width*2), "r" (dst+width) : "%"REG_a ); #else int i; for (i=0; i<width; i++) dst[i]= src[2*i+1]; #endif }
--------------------------------------------- Result 608 ---------------------------------------------
[[0 (52%)]] --> [[0 (35%)]] --> Socre: 0.6504450142383575

[[[[Adv]]]]: static void simple_number(void) { int i; struct { const char *encoded; int64_t decoded; int skip; } test_cases[] = { { "0", 0 }, { "1234", 1234 }, { "1", 1 }, { "-32", -32 }, { "-0", 0, .skip = 1 }, { }, }; for (i = 0; test_cases[i].encoded; i++) { QInt *qint; qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL)); g_assert(qint); g_assert(qint_get_int(qint) == test_cases[i].decoded); if (test_cases[i].skip == 0) { QString *[[str]]; [[str]] = qobject_to_json(QOBJECT(qint)); g_assert(strcmp(qstring_get_str([[str]]), test_cases[i].encoded) == 0); QDECREF([[str]]); } QDECREF(qint); } }

[[[[Adv]]]]: static void simple_number(void) { int i; struct { const char *encoded; int64_t decoded; int skip; } test_cases[] = { { "0", 0 }, { "1234", 1234 }, { "1", 1 }, { "-32", -32 }, { "-0", 0, .skip = 1 }, { }, }; for (i = 0; test_cases[i].encoded; i++) { QInt *qint; qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL)); g_assert(qint); g_assert(qint_get_int(qint) == test_cases[i].decoded); if (test_cases[i].skip == 0) { QString *[[knp]]; [[knp]] = qobject_to_json(QOBJECT(qint)); g_assert(strcmp(qstring_get_str([[knp]]), test_cases[i].encoded) == 0); QDECREF([[knp]]); } QDECREF(qint); } }
--------------------------------------------- Result 609 ---------------------------------------------
[[0 (88%)]] --> [[0 (37%)]] --> Socre: 0.6286754310131073

[[[[Adv]]]]: static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *[[dstV]], uint8_t *src1, uint8_t *[[src2]], long [[width]]) { #ifdef HAVE_MMX asm volatile( "movq "MANGLE(bm01010101)", %%mm4\n\t" "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",4), %%mm0 \n\t" "movq 8(%1, %%"REG_a",4), %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "pand %%mm4, %%mm1 \n\t" "packuswb %%mm0, %%mm0 \n\t" "packuswb %%mm1, %%mm1 \n\t" "movd %%mm0, (%3, %%"REG_a") \n\t" "movd %%mm1, (%2, %%"REG_a") \n\t" "add $4, %%"REG_a" \n\t" " js 1b \n\t" : : "g" (-[[width]]), "r" (src1+[[width]]*4), "r" (dstU+[[width]]), "r" ([[dstV]]+[[width]]) : "%"REG_a ); #else int i; for(i=0; i<[[width]]; i++) { dstU[i]= src1[4*i + 1]; [[dstV]][i]= src1[4*i + 3]; } #endif assert(src1 == [[src2]]); }

[[[[Adv]]]]: static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *[[tctill]], uint8_t *src1, uint8_t *[[slfz]], long [[expanse]]) { #ifdef HAVE_MMX asm volatile( "movq "MANGLE(bm01010101)", %%mm4\n\t" "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",4), %%mm0 \n\t" "movq 8(%1, %%"REG_a",4), %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "pand %%mm4, %%mm1 \n\t" "packuswb %%mm0, %%mm0 \n\t" "packuswb %%mm1, %%mm1 \n\t" "movd %%mm0, (%3, %%"REG_a") \n\t" "movd %%mm1, (%2, %%"REG_a") \n\t" "add $4, %%"REG_a" \n\t" " js 1b \n\t" : : "g" (-[[expanse]]), "r" (src1+[[expanse]]*4), "r" (dstU+[[expanse]]), "r" ([[tctill]]+[[expanse]]) : "%"REG_a ); #else int i; for(i=0; i<[[expanse]]; i++) { dstU[i]= src1[4*i + 1]; [[tctill]][i]= src1[4*i + 3]; } #endif assert(src1 == [[slfz]]); }
--------------------------------------------- Result 610 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 316 / 69 / 225 / 610:  23%|██▎       | 610/2690 [1:32:40<5:16:01,  9.12s/it][Succeeded / Failed / Skipped / Total] 316 / 69 / 225 / 610:  23%|██▎       | 611/2690 [1:32:41<5:15:22,  9.10s/it][Succeeded / Failed / Skipped / Total] 316 / 69 / 226 / 611:  23%|██▎       | 611/2690 [1:32:41<5:15:22,  9.10s/it][Succeeded / Failed / Skipped / Total] 316 / 69 / 226 / 611:  23%|██▎       | 612/2690 [1:32:41<5:14:44,  9.09s/it][Succeeded / Failed / Skipped / Total] 316 / 69 / 227 / 612:  23%|██▎       | 612/2690 [1:32:41<5:14:44,  9.09s/it][Succeeded / Failed / Skipped / Total] 316 / 69 / 227 / 612:  23%|██▎       | 613/2690 [1:32:48<5:14:28,  9.08s/it][Succeeded / Failed / Skipped / Total] 317 / 69 / 227 / 613:  23%|██▎       | 613/2690 [1:32:48<5:14:28,  9.08s/it][Succeeded / Failed / Skipped / Total] 317 / 69 / 227 / 613:  23%|██▎       | 614/2690 [1:33:09<5:14:58,  9.10s/it][Succeeded / Failed / Skipped / Total] 318 / 69 / 227 / 614:  23%|██▎       | 614/2690 [1:33:09<5:14:58,  9.10s/it][Succeeded / Failed / Skipped / Total] 318 / 69 / 227 / 614:  23%|██▎       | 615/2690 [1:33:09<5:14:20,  9.09s/it][[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ccid_initfn(USBDevice *dev) { USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev); s->bus = ccid_bus_new(&dev->qdev); s->card = NULL; s->cardinfo = NULL; s->migration_state = MIGRATION_NONE; s->migration_target_ip = 0; s->migration_target_port = 0; s->dev.speed = USB_SPEED_FULL; s->notify_slot_change = "False" != "False"; s->powered = "True" == "True"; s->pending_answers_num = 0; s->last_answer_error = 0; s->bulk_in_pending_start = 0; s->bulk_in_pending_end = 0; s->current_bulk_in = NULL; ccid_reset_error_status(s); s->bulk_out_pos = 0; ccid_reset_parameters(s); ccid_reset(s); return 0; }
--------------------------------------------- Result 611 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc4xx_pob_reset (void *opaque) { ppc4xx_pob_t *pob; pob = opaque; pob->bear = 0x00000000; pob->besr[0] = 0x0000000; pob->besr[1] = 0x0000000; }
--------------------------------------------- Result 612 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt) { int i, j, t, rconpointer = 0; uint8_t tk[8][4]; int KC = key_bits >> 5; int rounds = KC + 6; uint8_t log8[256]; uint8_t alog8[512]; if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) { j = 1; for (i = 0; i < 255; i++) { alog8[i] = alog8[i + 255] = j; log8[j] = i; j ^= j + j; if (j > 255) j ^= 0x11B; } for (i = 0; i < 256; i++) { j = i ? alog8[255 - log8[i]] : 0; j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4); j = (j ^ (j >> 8) ^ 99) & 255; inv_sbox[j] = i; sbox[i] = j; } init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb }, log8, alog8, inv_sbox); init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 }, log8, alog8, sbox); } if (key_bits != 128 && key_bits != 192 && key_bits != 256) return -1; a->rounds = rounds; memcpy(tk, key, KC * 4); for (t = 0; t < (rounds + 1) * 16;) { memcpy(a->round_key[0].u8 + t, tk, KC * 4); t += KC * 4; for (i = 0; i < 4; i++) tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]]; tk[0][0] ^= rcon[rconpointer++]; for (j = 1; j < KC; j++) { if (KC != 8 || j != KC >> 1) for (i = 0; i < 4; i++) tk[j][i] ^= tk[j - 1][i]; else for (i = 0; i < 4; i++) tk[j][i] ^= sbox[tk[j - 1][i]]; } } if (decrypt) { for (i = 1; i < rounds; i++) { av_aes_block tmp[3]; tmp[2] = a->round_key[i]; subshift(&tmp[1], 0, sbox); mix(tmp, dec_multbl, 1, 3); a->round_key[i] = tmp[0]; } } else { for (i = 0; i < (rounds + 1) >> 1; i++) { FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]); } } return 0; }
--------------------------------------------- Result 613 ---------------------------------------------
[[0 (9%)]] --> [[0 (58%)]] --> Socre: 0.5764232873916626

[[[[Adv]]]]: static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *[[src]], int [[stride]]){ int [[i]],j,xy,yz; int [[res]]; for([[i]]=0; [[i]]<8; [[i]]++){ for(j=1; j<7; j++){ xy = j * [[stride]] + [[i]]; yz = j * 8 + [[i]]; [[res]] = (int)[[src]][yz-1*8] + ((int)([[src]][yz+0*8]) * 2) + (int)[[src]][yz+1*8]; [[res]] +=2; [[res]] >>=2; dest[xy] = (uint8_t)[[res]]; } } }

[[[[Adv]]]]: static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *[[tram]], int [[footprints]]){ int [[we]],j,xy,yz; int [[viz]]; for([[we]]=0; [[we]]<8; [[we]]++){ for(j=1; j<7; j++){ xy = j * [[footprints]] + [[we]]; yz = j * 8 + [[we]]; [[viz]] = (int)[[tram]][yz-1*8] + ((int)([[tram]][yz+0*8]) * 2) + (int)[[tram]][yz+1*8]; [[viz]] +=2; [[viz]] >>=2; dest[xy] = (uint8_t)[[viz]]; } } }
--------------------------------------------- Result 614 ---------------------------------------------
[[0 (44%)]] --> [[0 (67%)]] --> Socre: 0.6664285659790039

[[[[Adv]]]]: static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset, sPAPRMachineState *spapr) { PowerPCCPU *cpu = POWERPC_CPU(cs); CPUPPCState *env = &cpu->env; PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs); int index = ppc_get_vcpu_dt_id(cpu); uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40), 0xffffffff, 0xffffffff}; uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : SPAPR_TIMEBASE_FREQ; uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000; uint32_t page_sizes_prop[64]; size_t page_sizes_prop_size; uint32_t [[vcpus_per_socket]] = smp_threads * smp_cores; uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)}; int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu)); sPAPRDRConnector *drc; int drc_index; uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ]; int i; drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index); if (drc) { drc_index = spapr_drc_index(drc); _FDT((fdt_setprop_cell(fdt, offset, "ibm,my-drc-index", drc_index))); } _FDT((fdt_setprop_cell(fdt, offset, "reg", index))); _FDT((fdt_setprop_string(fdt, offset, "device_type", "cpu"))); _FDT((fdt_setprop_cell(fdt, offset, "cpu-version", env->spr[SPR_PVR]))); _FDT((fdt_setprop_cell(fdt, offset, "d-cache-block-size", env->dcache_line_size))); _FDT((fdt_setprop_cell(fdt, offset, "d-cache-line-size", env->dcache_line_size))); _FDT((fdt_setprop_cell(fdt, offset, "i-cache-block-size", env->icache_line_size))); _FDT((fdt_setprop_cell(fdt, offset, "i-cache-line-size", env->icache_line_size))); if (pcc->l1_dcache_size) { _FDT((fdt_setprop_cell(fdt, offset, "d-cache-size", pcc->l1_dcache_size))); } else { error_report("Warning: Unknown L1 dcache size for cpu"); } if (pcc->l1_icache_size) { _FDT((fdt_setprop_cell(fdt, offset, "i-cache-size", pcc->l1_icache_size))); } else { error_report("Warning: Unknown L1 icache size for cpu"); } _FDT((fdt_setprop_cell(fdt, offset, "timebase-frequency", tbfreq))); _FDT((fdt_setprop_cell(fdt, offset, "clock-frequency", cpufreq))); _FDT((fdt_setprop_cell(fdt, offset, "slb-size", env->slb_nr))); _FDT((fdt_setprop_cell(fdt, offset, "ibm,slb-size", env->slb_nr))); _FDT((fdt_setprop_string(fdt, offset, "status", "okay"))); _FDT((fdt_setprop(fdt, offset, "64-bit", NULL, 0))); if (env->spr_cb[SPR_PURR].oea_read) { _FDT((fdt_setprop(fdt, offset, "ibm,purr", NULL, 0))); } if (env->mmu_model & POWERPC_MMU_1TSEG) { _FDT((fdt_setprop(fdt, offset, "ibm,processor-segment-sizes", segs, sizeof(segs)))); } if (env->insns_flags & PPC_ALTIVEC) { uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1; _FDT((fdt_setprop_cell(fdt, offset, "ibm,vmx", vmx))); } if (env->insns_flags2 & PPC2_DFP) { _FDT((fdt_setprop_cell(fdt, offset, "ibm,dfp", 1))); } page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop, sizeof(page_sizes_prop)); if (page_sizes_prop_size) { _FDT((fdt_setprop(fdt, offset, "ibm,segment-page-sizes", page_sizes_prop, page_sizes_prop_size))); } spapr_populate_pa_features(env, fdt, offset, "False" != "False"); _FDT((fdt_setprop_cell(fdt, offset, "ibm,chip-id", cs->cpu_index / [[vcpus_per_socket]]))); _FDT((fdt_setprop(fdt, offset, "ibm,pft-size", pft_size_prop, sizeof(pft_size_prop)))); if (nb_numa_nodes > 1) { _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu)); } _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt)); if (pcc->radix_page_info) { for (i = 0; i < pcc->radix_page_info->count; i++) { radix_AP_encodings[i] = cpu_to_be32(pcc->radix_page_info->entries[i]); } _FDT((fdt_setprop(fdt, offset, "ibm,processor-radix-AP-encodings", radix_AP_encodings, pcc->radix_page_info->count * sizeof(radix_AP_encodings[0])))); } }

[[[[Adv]]]]: static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset, sPAPRMachineState *spapr) { PowerPCCPU *cpu = POWERPC_CPU(cs); CPUPPCState *env = &cpu->env; PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs); int index = ppc_get_vcpu_dt_id(cpu); uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40), 0xffffffff, 0xffffffff}; uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : SPAPR_TIMEBASE_FREQ; uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000; uint32_t page_sizes_prop[64]; size_t page_sizes_prop_size; uint32_t [[camastyap²square]] = smp_threads * smp_cores; uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)}; int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu)); sPAPRDRConnector *drc; int drc_index; uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ]; int i; drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index); if (drc) { drc_index = spapr_drc_index(drc); _FDT((fdt_setprop_cell(fdt, offset, "ibm,my-drc-index", drc_index))); } _FDT((fdt_setprop_cell(fdt, offset, "reg", index))); _FDT((fdt_setprop_string(fdt, offset, "device_type", "cpu"))); _FDT((fdt_setprop_cell(fdt, offset, "cpu-version", env->spr[SPR_PVR]))); _FDT((fdt_setprop_cell(fdt, offset, "d-cache-block-size", env->dcache_line_size))); _FDT((fdt_setprop_cell(fdt, offset, "d-cache-line-size", env->dcache_line_size))); _FDT((fdt_setprop_cell(fdt, offset, "i-cache-block-size", env->icache_line_size))); _FDT((fdt_setprop_cell(fdt, offset, "i-cache-line-size", env->icache_line_size))); if (pcc->l1_dcache_size) { _FDT((fdt_setprop_cell(fdt, offset, "d-cache-size", pcc->l1_dcache_size))); } else { error_report("Warning: Unknown L1 dcache size for cpu"); } if (pcc->l1_icache_size) { _FDT((fdt_setprop_cell(fdt, offset, "i-cache-size", pcc->l1_icache_size))); } else { error_report("Warning: Unknown L1 icache size for cpu"); } _FDT((fdt_setprop_cell(fdt, offset, "timebase-frequency", tbfreq))); _FDT((fdt_setprop_cell(fdt, offset, "clock-frequency", cpufreq))); _FDT((fdt_setprop_cell(fdt, offset, "slb-size", env->slb_nr))); _FDT((fdt_setprop_cell(fdt, offset, "ibm,slb-size", env->slb_nr))); _FDT((fdt_setprop_string(fdt, offset, "status", "okay"))); _FDT((fdt_setprop(fdt, offset, "64-bit", NULL, 0))); if (env->spr_cb[SPR_PURR].oea_read) { _FDT((fdt_setprop(fdt, offset, "ibm,purr", NULL, 0))); } if (env->mmu_model & POWERPC_MMU_1TSEG) { _FDT((fdt_setprop(fdt, offset, "ibm,processor-segment-sizes", segs, sizeof(segs)))); } if (env->insns_flags & PPC_ALTIVEC) { uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1; _FDT((fdt_setprop_cell(fdt, offset, "ibm,vmx", vmx))); } if (env->insns_flags2 & PPC2_DFP) { _FDT((fdt_setprop_cell(fdt, offset, "ibm,dfp", 1))); } page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop, sizeof(page_sizes_prop)); if (page_sizes_prop_size) { _FDT((fdt_setprop(fdt, offset, "ibm,segment-page-sizes", page_sizes_prop, page_sizes_prop_size))); } spapr_populate_pa_features(env, fdt, offset, "False" != "False"); _FDT((fdt_setprop_cell(fdt, offset, "ibm,chip-id", cs->cpu_index / [[camastyap²square]]))); _FDT((fdt_setprop(fdt, offset, "ibm,pft-size", pft_size_prop, sizeof(pft_size_prop)))); if (nb_numa_nodes > 1) { _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu)); } _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt)); if (pcc->radix_page_info) { for (i = 0; i < pcc->radix_page_info->count; i++) { radix_AP_encodings[i] = cpu_to_be32(pcc->radix_page_info->entries[i]); } _FDT((fdt_setprop(fdt, offset, "ibm,processor-radix-AP-encodings", radix_AP_encodings, pcc->radix_page_info->count * sizeof(radix_AP_encodings[0])))); } }
--------------------------------------------- Result 615 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 318 / 69 / 228 / 615:  23%|██▎       | 615/2690 [1:33:09<5:14:20,  9.09s/it][Succeeded / Failed / Skipped / Total] 318 / 69 / 228 / 615:  23%|██▎       | 616/2690 [1:33:22<5:14:22,  9.09s/it][Succeeded / Failed / Skipped / Total] 319 / 69 / 228 / 616:  23%|██▎       | 616/2690 [1:33:22<5:14:22,  9.09s/it][Succeeded / Failed / Skipped / Total] 319 / 69 / 228 / 616:  23%|██▎       | 617/2690 [1:33:52<5:15:23,  9.13s/it][Succeeded / Failed / Skipped / Total] 320 / 69 / 228 / 617:  23%|██▎       | 617/2690 [1:33:52<5:15:23,  9.13s/it][Succeeded / Failed / Skipped / Total] 320 / 69 / 228 / 617:  23%|██▎       | 618/2690 [1:33:52<5:14:45,  9.11s/it][[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid) { XHCIState *xhci = epctx->xhci; XHCIStreamContext *stctx; XHCITransfer *xfer; XHCIRing *ring; USBEndpoint *ep = NULL; uint64_t mfindex; int length; int i; trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid); if (!xhci->slots[epctx->slotid - 1].uport || !xhci->slots[epctx->slotid - 1].uport->dev || !xhci->slots[epctx->slotid - 1].uport->dev->attached) { return; } if (epctx->retry) { XHCITransfer *xfer = epctx->retry; trace_usb_xhci_xfer_retry(xfer); assert(xfer->running_retry); if (xfer->timed_xfer) { mfindex = xhci_mfindex_get(xhci); xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex); if (xfer->running_retry) { return; } xfer->timed_xfer = 0; xfer->running_retry = 1; } if (xfer->iso_xfer) { if (xhci_setup_packet(xfer) < 0) { return; } usb_handle_packet(xfer->packet.ep->dev, &xfer->packet); assert(xfer->packet.status != USB_RET_NAK); xhci_complete_packet(xfer); } else { if (xhci_setup_packet(xfer) < 0) { return; } usb_handle_packet(xfer->packet.ep->dev, &xfer->packet); if (xfer->packet.status == USB_RET_NAK) { return; } xhci_complete_packet(xfer); } assert(!xfer->running_retry); xhci_ep_free_xfer(epctx->retry); epctx->retry = NULL; } if (epctx->state == EP_HALTED) { DPRINTF("xhci: ep halted, not running schedule\n"); return; } if (epctx->nr_pstreams) { uint32_t err; stctx = xhci_find_stream(epctx, streamid, &err); if (stctx == NULL) { return; } ring = &stctx->ring; xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING); } else { ring = &epctx->ring; streamid = 0; xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING); } assert(ring->dequeue != 0); while (1) { length = xhci_ring_chain_length(xhci, ring); if (length <= 0) { break; } xfer = xhci_ep_alloc_xfer(epctx, length); if (xfer == NULL) { break; } for (i = 0; i < length; i++) { TRBType type; type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL); assert(type); } xfer->streamid = streamid; if (epctx->epid == 1) { xhci_fire_ctl_transfer(xhci, xfer); } else { xhci_fire_transfer(xhci, xfer, epctx); } if (xfer->complete) { xhci_ep_free_xfer(xfer); xfer = NULL; } if (epctx->state == EP_HALTED) { break; } if (xfer != NULL && xfer->running_retry) { DPRINTF("xhci: xfer nacked, stopping schedule\n"); epctx->retry = xfer; break; } } ep = xhci_epid_to_usbep(epctx); if (ep) { usb_device_flush_ep_queue(ep->dev, ep); } }
--------------------------------------------- Result 616 ---------------------------------------------
[[0 (49%)]] --> [[0 (73%)]] --> Socre: 0.7311719059944153

[[[[Adv]]]]: static int opt_preset(const char *opt, const char *arg) { FILE *f=NULL; char filename[1000], tmp[1000], tmp2[1000], line[1000]; int i; const char *base[3]= { getenv("HOME"), "/usr/local/share", "/usr/share", }; for(i=!base[0]; i<3 && !f; i++){ snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s.ffpreset", base[i], i ? "" : ".", arg); f= fopen(filename, "r"); if(!f){ char *[[codec_name]]= *opt == 'v' ? video_codec_name : *opt == 'a' ? audio_codec_name : subtitle_codec_name; snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s-%s.ffpreset", base[i], i ? "" : ".", [[codec_name]], arg); f= fopen(filename, "r"); } } if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' || is_dos_path(arg))){ snprintf(filename, sizeof(filename), arg); f= fopen(filename, "r"); } if(!f){ fprintf(stderr, "File for preset '%s' not found\n", arg); av_exit(1); } while(!feof(f)){ int e= fscanf(f, "%999[^\n]\n", line) - 1; if(line[0] == '#' && !e) continue; e|= sscanf(line, "%999[^=]=%999[^\n]\n", tmp, tmp2) - 2; if(e){ fprintf(stderr, "%s: Preset file invalid\n", filename); av_exit(1); } if(!strcmp(tmp, "acodec")){ opt_audio_codec(tmp2); }else if(!strcmp(tmp, "vcodec")){ opt_video_codec(tmp2); }else if(!strcmp(tmp, "scodec")){ opt_subtitle_codec(tmp2); }else if(opt_default(tmp, tmp2) < 0){ fprintf(stderr, "%s: Invalid option or argument: %s=%s\n", filename, tmp, tmp2); av_exit(1); } } fclose(f); return 0; }

[[[[Adv]]]]: static int opt_preset(const char *opt, const char *arg) { FILE *f=NULL; char filename[1000], tmp[1000], tmp2[1000], line[1000]; int i; const char *base[3]= { getenv("HOME"), "/usr/local/share", "/usr/share", }; for(i=!base[0]; i<3 && !f; i++){ snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s.ffpreset", base[i], i ? "" : ".", arg); f= fopen(filename, "r"); if(!f){ char *[[pieicyourcall]]= *opt == 'v' ? video_codec_name : *opt == 'a' ? audio_codec_name : subtitle_codec_name; snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s-%s.ffpreset", base[i], i ? "" : ".", [[pieicyourcall]], arg); f= fopen(filename, "r"); } } if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' || is_dos_path(arg))){ snprintf(filename, sizeof(filename), arg); f= fopen(filename, "r"); } if(!f){ fprintf(stderr, "File for preset '%s' not found\n", arg); av_exit(1); } while(!feof(f)){ int e= fscanf(f, "%999[^\n]\n", line) - 1; if(line[0] == '#' && !e) continue; e|= sscanf(line, "%999[^=]=%999[^\n]\n", tmp, tmp2) - 2; if(e){ fprintf(stderr, "%s: Preset file invalid\n", filename); av_exit(1); } if(!strcmp(tmp, "acodec")){ opt_audio_codec(tmp2); }else if(!strcmp(tmp, "vcodec")){ opt_video_codec(tmp2); }else if(!strcmp(tmp, "scodec")){ opt_subtitle_codec(tmp2); }else if(opt_default(tmp, tmp2) < 0){ fprintf(stderr, "%s: Invalid option or argument: %s=%s\n", filename, tmp, tmp2); av_exit(1); } } fclose(f); return 0; }
--------------------------------------------- Result 617 ---------------------------------------------
[[0 (64%)]] --> [[0 (47%)]] --> Socre: 0.5340804159641266

[[[[Adv]]]]: static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, unsigned int width, unsigned int [[height]], int [[lumStride]], int chromStride, int dstStride) { RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, [[height]], [[lumStride]], chromStride, dstStride, 2); }

[[[[Adv]]]]: static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, unsigned int width, unsigned int [[extent]], int [[loumeshriplane]], int chromStride, int dstStride) { RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, [[extent]], [[loumeshriplane]], chromStride, dstStride, 2); }
--------------------------------------------- Result 618 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 320 / 69 / 229 / 618:  23%|██▎       | 618/2690 [1:33:52<5:14:45,  9.11s/it][Succeeded / Failed / Skipped / Total] 320 / 69 / 229 / 618:  23%|██▎       | 619/2690 [1:34:10<5:15:03,  9.13s/it][Succeeded / Failed / Skipped / Total] 320 / 70 / 229 / 619:  23%|██▎       | 619/2690 [1:34:10<5:15:03,  9.13s/it][Succeeded / Failed / Skipped / Total] 320 / 70 / 229 / 619:  23%|██▎       | 620/2690 [1:34:11<5:14:27,  9.11s/it][Succeeded / Failed / Skipped / Total] 320 / 71 / 229 / 620:  23%|██▎       | 620/2690 [1:34:11<5:14:27,  9.11s/it][Succeeded / Failed / Skipped / Total] 320 / 71 / 229 / 620:  23%|██▎       | 621/2690 [1:34:32<5:15:00,  9.13s/it][Succeeded / Failed / Skipped / Total] 321 / 71 / 229 / 621:  23%|██▎       | 621/2690 [1:34:32<5:15:00,  9.13s/it][Succeeded / Failed / Skipped / Total] 321 / 71 / 229 / 621:  23%|██▎       | 622/2690 [1:34:33<5:14:22,  9.12s/it][Succeeded / Failed / Skipped / Total] 321 / 71 / 230 / 622:  23%|██▎       | 622/2690 [1:34:33<5:14:22,  9.12s/it][Succeeded / Failed / Skipped / Total] 321 / 71 / 230 / 622:  23%|██▎       | 623/2690 [1:34:57<5:15:02,  9.15s/it][[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s, void *data, uint32_t length, uint64_t offset) { int ret = 0; void *buffer = NULL; void *merged_sector = NULL; void *data_tmp, *sector_write; unsigned int i; int sector_offset; uint32_t desc_sectors, sectors, total_length; uint32_t sectors_written = 0; uint32_t aligned_length; uint32_t leading_length = 0; uint32_t trailing_length = 0; uint32_t partial_sectors = 0; uint32_t bytes_written = 0; uint64_t file_offset; VHDXHeader *header; VHDXLogEntryHeader new_hdr; VHDXLogDescriptor *new_desc = NULL; VHDXLogDataSector *data_sector = NULL; MSGUID new_guid = { 0 }; header = s->headers[s->curr_header]; if (length > header->log_length) { ret = -EINVAL; goto exit; } if (guid_eq(header->log_guid, zero_guid)) { vhdx_guid_generate(&new_guid); vhdx_update_headers(bs, s, "False" != "False", &new_guid); } else { ret = -ENOTSUP; goto exit; } if (s->log.sequence == 0) { s->log.sequence = 1; } sector_offset = offset % VHDX_LOG_SECTOR_SIZE; file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE; aligned_length = length; if (sector_offset) { leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset); leading_length = leading_length > length ? length : leading_length; aligned_length -= leading_length; partial_sectors++; } sectors = aligned_length / VHDX_LOG_SECTOR_SIZE; trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE); if (trailing_length) { partial_sectors++; } sectors += partial_sectors; new_hdr = (VHDXLogEntryHeader) { .signature = VHDX_LOG_SIGNATURE, .tail = s->log.tail, .sequence_number = s->log.sequence, .descriptor_count = sectors, .reserved = 0, .flushed_file_offset = bdrv_getlength(bs->file->bs), .last_file_offset = bdrv_getlength(bs->file->bs), }; new_hdr.log_guid = header->log_guid; desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count); total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE; new_hdr.entry_length = total_length; vhdx_log_entry_hdr_le_export(&new_hdr); buffer = qemu_blockalign(bs, total_length); memcpy(buffer, &new_hdr, sizeof(new_hdr)); new_desc = buffer + sizeof(new_hdr); data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE); data_tmp = data; merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE); for (i = 0; i < sectors; i++) { new_desc->signature = VHDX_LOG_DESC_SIGNATURE; new_desc->sequence_number = s->log.sequence; new_desc->file_offset = file_offset; if (i == 0 && leading_length) { ret = bdrv_pread(bs->file, file_offset, merged_sector, VHDX_LOG_SECTOR_SIZE); if (ret < 0) { goto exit; } memcpy(merged_sector + sector_offset, data_tmp, leading_length); bytes_written = leading_length; sector_write = merged_sector; } else if (i == sectors - 1 && trailing_length) { ret = bdrv_pread(bs->file, file_offset, merged_sector + trailing_length, VHDX_LOG_SECTOR_SIZE - trailing_length); if (ret < 0) { goto exit; } memcpy(merged_sector, data_tmp, trailing_length); bytes_written = trailing_length; sector_write = merged_sector; } else { bytes_written = VHDX_LOG_SECTOR_SIZE; sector_write = data_tmp; } vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write, s->log.sequence); data_tmp += bytes_written; data_sector++; new_desc++; file_offset += VHDX_LOG_SECTOR_SIZE; } vhdx_update_checksum(buffer, total_length, offsetof(VHDXLogEntryHeader, checksum)); ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer, desc_sectors + sectors); if (ret < 0) { goto exit; } if (sectors_written != desc_sectors + sectors) { ret = -EINVAL; goto exit; } s->log.sequence++; s->log.tail = s->log.write; exit: qemu_vfree(buffer); qemu_vfree(merged_sector); return ret; }
--------------------------------------------- Result 619 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int video_thread(void *arg) { VideoState *[[is]] = arg; AVFrame *[[frame]] = avcodec_alloc_frame(); int64_t pts_int; double pts; int ret; #if CONFIG_AVFILTER AVFilterGraph *graph = avfilter_graph_alloc(); AVFilterContext *[[filt_out]] = NULL; int64_t pos; int last_w = [[is]]->video_st->codec->width; int last_h = [[is]]->video_st->codec->height; if ((ret = configure_video_filters(graph, [[is]], vfilters)) < 0) goto the_end; [[filt_out]] = [[is]]->out_video_filter; #endif for (;;) { #if !CONFIG_AVFILTER AVPacket [[pkt]]; #else AVFilterBufferRef *picref; AVRational [[tb]]; #endif while ([[is]]->paused && ![[is]]->videoq.abort_request) SDL_Delay(10); #if CONFIG_AVFILTER if ( last_w != [[is]]->video_st->codec->width || last_h != [[is]]->video_st->codec->height) { av_dlog(NULL, "Changing size %dx%d -> %dx%d\n", last_w, last_h, [[is]]->video_st->codec->width, [[is]]->video_st->codec->height); avfilter_graph_free(&graph); graph = avfilter_graph_alloc(); if ((ret = configure_video_filters(graph, [[is]], vfilters)) < 0) goto the_end; [[filt_out]] = [[is]]->out_video_filter; last_w = [[is]]->video_st->codec->width; last_h = [[is]]->video_st->codec->height; } ret = get_filtered_video_frame([[filt_out]], [[frame]], &picref, &[[tb]]); if (picref) { pts_int = picref->pts; pos = picref->pos; [[frame]]->opaque = picref; } if (av_cmp_q([[tb]], [[is]]->video_st->time_base)) { av_unused int64_t pts1 = pts_int; pts_int = av_rescale_q(pts_int, [[tb]], [[is]]->video_st->time_base); av_dlog(NULL, "video_thread(): " "tb:%d/%d pts:%"PRId64" -> tb:%d/%d pts:%"PRId64"\n", [[tb]].num, [[tb]].den, pts1, [[is]]->video_st->time_base.num, [[is]]->video_st->time_base.den, pts_int); } #else ret = get_video_frame([[is]], [[frame]], &pts_int, &[[pkt]]); #endif if (ret < 0) goto the_end; if (!ret) continue; pts = pts_int * av_q2d([[is]]->video_st->time_base); #if CONFIG_AVFILTER ret = output_picture2([[is]], [[frame]], pts, pos); #else ret = output_picture2([[is]], [[frame]], pts, [[pkt]].pos); av_free_packet(&[[pkt]]); #endif if (ret < 0) goto the_end; if (step) if (cur_stream) stream_pause(cur_stream); } the_end: #if CONFIG_AVFILTER avfilter_graph_free(&graph); #endif av_free([[frame]]); return 0; }

[[[[Adv]]]]: static int video_thread(void *arg) { VideoState *[[pictures]] = arg; AVFrame *[[loop]] = avcodec_alloc_frame(); int64_t pts_int; double pts; int ret; #if CONFIG_AVFILTER AVFilterGraph *graph = avfilter_graph_alloc(); AVFilterContext *[[kiktcapitalthat]] = NULL; int64_t pos; int last_w = [[pictures]]->video_st->codec->width; int last_h = [[pictures]]->video_st->codec->height; if ((ret = configure_video_filters(graph, [[pictures]], vfilters)) < 0) goto the_end; [[kiktcapitalthat]] = [[pictures]]->out_video_filter; #endif for (;;) { #if !CONFIG_AVFILTER AVPacket [[pa1]]; #else AVFilterBufferRef *picref; AVRational [[tal]]; #endif while ([[pictures]]->paused && ![[pictures]]->videoq.abort_request) SDL_Delay(10); #if CONFIG_AVFILTER if ( last_w != [[pictures]]->video_st->codec->width || last_h != [[pictures]]->video_st->codec->height) { av_dlog(NULL, "Changing size %dx%d -> %dx%d\n", last_w, last_h, [[pictures]]->video_st->codec->width, [[pictures]]->video_st->codec->height); avfilter_graph_free(&graph); graph = avfilter_graph_alloc(); if ((ret = configure_video_filters(graph, [[pictures]], vfilters)) < 0) goto the_end; [[kiktcapitalthat]] = [[pictures]]->out_video_filter; last_w = [[pictures]]->video_st->codec->width; last_h = [[pictures]]->video_st->codec->height; } ret = get_filtered_video_frame([[kiktcapitalthat]], [[loop]], &picref, &[[tal]]); if (picref) { pts_int = picref->pts; pos = picref->pos; [[loop]]->opaque = picref; } if (av_cmp_q([[tal]], [[pictures]]->video_st->time_base)) { av_unused int64_t pts1 = pts_int; pts_int = av_rescale_q(pts_int, [[tal]], [[pictures]]->video_st->time_base); av_dlog(NULL, "video_thread(): " "tb:%d/%d pts:%"PRId64" -> tb:%d/%d pts:%"PRId64"\n", [[tal]].num, [[tal]].den, pts1, [[pictures]]->video_st->time_base.num, [[pictures]]->video_st->time_base.den, pts_int); } #else ret = get_video_frame([[pictures]], [[loop]], &pts_int, &[[pa1]]); #endif if (ret < 0) goto the_end; if (!ret) continue; pts = pts_int * av_q2d([[pictures]]->video_st->time_base); #if CONFIG_AVFILTER ret = output_picture2([[pictures]], [[loop]], pts, pos); #else ret = output_picture2([[pictures]], [[loop]], pts, [[pa1]].pos); av_free_packet(&[[pa1]]); #endif if (ret < 0) goto the_end; if (step) if (cur_stream) stream_pause(cur_stream); } the_end: #if CONFIG_AVFILTER avfilter_graph_free(&graph); #endif av_free([[loop]]); return 0; }
--------------------------------------------- Result 620 ---------------------------------------------
[[0 (87%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void vmxnet3_net_uninit(VMXNET3State *[[s]]) { g_free([[s]]->mcast_list); vmxnet_tx_pkt_reset([[s]]->tx_pkt); vmxnet_tx_pkt_uninit([[s]]->tx_pkt); vmxnet_rx_pkt_uninit([[s]]->rx_pkt); qemu_del_nic([[s]]->nic); }

[[[[Adv]]]]: static void vmxnet3_net_uninit(VMXNET3State *[[services]]) { g_free([[services]]->mcast_list); vmxnet_tx_pkt_reset([[services]]->tx_pkt); vmxnet_tx_pkt_uninit([[services]]->tx_pkt); vmxnet_rx_pkt_uninit([[services]]->rx_pkt); qemu_del_nic([[services]]->nic); }
--------------------------------------------- Result 621 ---------------------------------------------
[[0 (71%)]] --> [[0 (14%)]] --> Socre: 0.8625387698411942

[[[[Adv]]]]: static void input_callback(MMAL_PORT_T *[[port]], MMAL_BUFFER_HEADER_T *buffer) { if (!buffer->cmd) { AVBufferRef *buf = buffer->user_data; av_buffer_unref(&buf); } mmal_buffer_header_release(buffer); }

[[[[Adv]]]]: static void input_callback(MMAL_PORT_T *[[latch]], MMAL_BUFFER_HEADER_T *buffer) { if (!buffer->cmd) { AVBufferRef *buf = buffer->user_data; av_buffer_unref(&buf); } mmal_buffer_header_release(buffer); }
--------------------------------------------- Result 622 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CPUArchState *cpu_copy(CPUArchState *env) { CPUState *cpu = ENV_GET_CPU(env); CPUState *new_cpu = cpu_init(cpu_model); CPUArchState *new_env = cpu->env_ptr; CPUBreakpoint *bp; CPUWatchpoint *wp; cpu_reset(new_cpu); memcpy(new_env, env, sizeof(CPUArchState)); QTAILQ_INIT(&cpu->breakpoints); QTAILQ_INIT(&cpu->watchpoints); QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) { cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL); } QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) { cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL); } return new_env; }
--------------------------------------------- Result 623 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 321 / 72 / 230 / 623:  23%|██▎       | 623/2690 [1:34:57<5:15:02,  9.15s/it][Succeeded / Failed / Skipped / Total] 321 / 72 / 230 / 623:  23%|██▎       | 624/2690 [1:35:14<5:15:19,  9.16s/it][[0 (80%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int asf_read_ext_content(AVFormatContext *[[s]], const GUIDParseTable *[[g]]) { ASFContext *asf = [[s]]->priv_data; AVIOContext *[[pb]] = [[s]]->pb; uint64_t size = avio_rl64([[pb]]); uint16_t [[nb_desc]] = avio_rl16([[pb]]); int i, ret; for (i = 0; i < [[nb_desc]]; i++) { uint16_t name_len, type, val_len; uint8_t *name = NULL; name_len = avio_rl16([[pb]]); if (!name_len) return AVERROR_INVALIDDATA; name = av_malloc(name_len); if (!name) return AVERROR(ENOMEM); avio_get_str16le([[pb]], name_len, name, name_len); type = avio_rl16([[pb]]); val_len = avio_rl16([[pb]]); if ((ret = process_metadata([[s]], name, name_len, val_len, type, &[[s]]->metadata)) < 0) return ret; } align_position([[pb]], asf->offset, size); return 0; }

[[[[Adv]]]]: static int asf_read_ext_content(AVFormatContext *[[series]], const GUIDParseTable *[[gen]]) { ASFContext *asf = [[series]]->priv_data; AVIOContext *[[homepoint]] = [[series]]->pb; uint64_t size = avio_rl64([[homepoint]]); uint16_t [[nlab16dip]] = avio_rl16([[homepoint]]); int i, ret; for (i = 0; i < [[nlab16dip]]; i++) { uint16_t name_len, type, val_len; uint8_t *name = NULL; name_len = avio_rl16([[homepoint]]); if (!name_len) return AVERROR_INVALIDDATA; name = av_malloc(name_len); if (!name) return AVERROR(ENOMEM); avio_get_str16le([[homepoint]], name_len, name, name_len); type = avio_rl16([[homepoint]]); val_len = avio_rl16([[homepoint]]); if ((ret = process_metadata([[series]], name, name_len, val_len, type, &[[series]]->metadata)) < 0) return ret; } align_position([[homepoint]], asf->offset, size); return 0; }
--------------------------------------------- Result 624 ---------------------------------------------
[[0 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int http_prepare_data(HTTPContext *[[c]]) { int [[i]]; switch([[c]]->state) { case HTTPSTATE_SEND_DATA_HEADER: memset(&[[c]]->fmt_ctx, 0, sizeof([[c]]->fmt_ctx)); if ([[c]]->stream->feed) { [[c]]->fmt_ctx.oformat = [[c]]->stream->fmt; [[c]]->fmt_ctx.nb_streams = [[c]]->stream->nb_streams; for([[i]]=0;[[i]]<[[c]]->fmt_ctx.nb_streams;[[i]]++) { AVStream *[[st]]; [[st]] = av_mallocz(sizeof(AVStream)); [[c]]->fmt_ctx.streams[[[i]]] = [[st]]; if ([[c]]->stream->feed == [[c]]->stream) memcpy([[st]], [[c]]->stream->streams[[[i]]], sizeof(AVStream)); else memcpy([[st]], [[c]]->stream->feed->streams[[[c]]->stream->feed_streams[[[i]]]], sizeof(AVStream)); [[st]]->codec.frame_number = 0; } [[c]]->got_key_frame = 0; } else { [[c]]->fmt_ctx.oformat = [[c]]->stream->fmt; [[c]]->fmt_ctx.nb_streams = [[c]]->fmt_in->nb_streams; for([[i]]=0;[[i]]<[[c]]->fmt_ctx.nb_streams;[[i]]++) { AVStream *[[st]]; [[st]] = av_mallocz(sizeof(AVStream)); [[c]]->fmt_ctx.streams[[[i]]] = [[st]]; memcpy([[st]], [[c]]->fmt_in->streams[[[i]]], sizeof(AVStream)); [[st]]->codec.frame_number = 0; } [[c]]->got_key_frame = 0; } init_put_byte(&[[c]]->fmt_ctx.pb, [[c]]->pbuffer, PACKET_MAX_SIZE, 1, [[c]], NULL, http_write_packet, NULL); [[c]]->fmt_ctx.pb.is_streamed = 1; av_write_header(&[[c]]->fmt_ctx); [[c]]->state = HTTPSTATE_SEND_DATA; [[c]]->last_packet_sent = 0; break; case HTTPSTATE_SEND_DATA: #if 0 fifo_total_size = http_fifo_write_count - [[c]]->last_http_fifo_write_count; if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) { [[c]]->rptr = http_fifo.wptr; [[c]]->got_key_frame = 0; } start_rptr = [[c]]->rptr; if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &[[c]]->rptr) < 0) return 0; payload_size = ntohs(hdr.payload_size); payload = av_malloc(payload_size); if (fifo_read(&http_fifo, payload, payload_size, &[[c]]->rptr) < 0) { av_free(payload); [[c]]->rptr = start_rptr; return 0; } [[c]]->last_http_fifo_write_count = http_fifo_write_count - fifo_size(&http_fifo, [[c]]->rptr); if ([[c]]->stream->stream_type != STREAM_TYPE_MASTER) { ret = 0; for([[i]]=0;[[i]]<[[c]]->fmt_ctx.nb_streams;[[i]]++) { AVStream *[[st]] = [[c]]->fmt_ctx.streams[[[i]]]; if (test_header(&hdr, &[[st]]->codec)) { if ([[st]]->codec.key_frame) [[c]]->got_key_frame |= 1 << [[i]]; if ([[c]]->got_key_frame & (1 << [[i]])) { ret = [[c]]->fmt_ctx.format->write_packet(&[[c]]->fmt_ctx, [[i]], payload, payload_size); } break; } } if (ret) { [[c]]->state = HTTPSTATE_SEND_DATA_TRAILER; } } else { char *q; q = [[c]]->buffer; memcpy(q, &hdr, sizeof(hdr)); q += sizeof(hdr); memcpy(q, payload, payload_size); q += payload_size; [[c]]->buffer_ptr = [[c]]->buffer; [[c]]->buffer_end = q; } av_free(payload); #endif { AVPacket pkt; if ([[c]]->stream->feed) { ffm_set_write_index([[c]]->fmt_in, [[c]]->stream->feed->feed_write_index, [[c]]->stream->feed->feed_size); } if (av_read_packet([[c]]->fmt_in, &pkt) < 0) { if ([[c]]->stream->feed && [[c]]->stream->feed->feed_opened) { [[c]]->state = HTTPSTATE_WAIT_FEED; return 1; } else { [[c]]->state = HTTPSTATE_SEND_DATA_TRAILER; } } else { if ([[c]]->stream->feed) { for([[i]]=0;[[i]]<[[c]]->stream->nb_streams;[[i]]++) { if ([[c]]->stream->feed_streams[[[i]]] == pkt.stream_index) { pkt.stream_index = [[i]]; if (pkt.flags & PKT_FLAG_KEY) { [[c]]->got_key_frame |= 1 << [[i]]; } if (![[c]]->stream->send_on_key || (([[c]]->got_key_frame + 1) >> [[c]]->stream->nb_streams)) { goto send_it; } } } } else { AVCodecContext *codec; send_it: codec = &[[c]]->fmt_ctx.streams[pkt.stream_index]->codec; codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0); #ifdef PJSG if (codec->codec_type == CODEC_TYPE_AUDIO) { codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000; } #endif if (av_write_packet(&[[c]]->fmt_ctx, &pkt, 0)) [[c]]->state = HTTPSTATE_SEND_DATA_TRAILER; codec->frame_number++; } av_free_packet(&pkt); } } break; default: case HTTPSTATE_SEND_DATA_TRAILER: if ([[c]]->last_packet_sent) return -1; av_write_trailer(&[[c]]->fmt_ctx); [[c]]->last_packet_sent = 1; break; } return 0; }

[[[[Adv]]]]: static int http_prepare_data(HTTPContext *[[c1]]) { int [[bell]]; switch([[c1]]->state) { case HTTPSTATE_SEND_DATA_HEADER: memset(&[[c1]]->fmt_ctx, 0, sizeof([[c1]]->fmt_ctx)); if ([[c1]]->stream->feed) { [[c1]]->fmt_ctx.oformat = [[c1]]->stream->fmt; [[c1]]->fmt_ctx.nb_streams = [[c1]]->stream->nb_streams; for([[bell]]=0;[[bell]]<[[c1]]->fmt_ctx.nb_streams;[[bell]]++) { AVStream *[[evolution]]; [[evolution]] = av_mallocz(sizeof(AVStream)); [[c1]]->fmt_ctx.streams[[[bell]]] = [[evolution]]; if ([[c1]]->stream->feed == [[c1]]->stream) memcpy([[evolution]], [[c1]]->stream->streams[[[bell]]], sizeof(AVStream)); else memcpy([[evolution]], [[c1]]->stream->feed->streams[[[c1]]->stream->feed_streams[[[bell]]]], sizeof(AVStream)); [[evolution]]->codec.frame_number = 0; } [[c1]]->got_key_frame = 0; } else { [[c1]]->fmt_ctx.oformat = [[c1]]->stream->fmt; [[c1]]->fmt_ctx.nb_streams = [[c1]]->fmt_in->nb_streams; for([[bell]]=0;[[bell]]<[[c1]]->fmt_ctx.nb_streams;[[bell]]++) { AVStream *[[evolution]]; [[evolution]] = av_mallocz(sizeof(AVStream)); [[c1]]->fmt_ctx.streams[[[bell]]] = [[evolution]]; memcpy([[evolution]], [[c1]]->fmt_in->streams[[[bell]]], sizeof(AVStream)); [[evolution]]->codec.frame_number = 0; } [[c1]]->got_key_frame = 0; } init_put_byte(&[[c1]]->fmt_ctx.pb, [[c1]]->pbuffer, PACKET_MAX_SIZE, 1, [[c1]], NULL, http_write_packet, NULL); [[c1]]->fmt_ctx.pb.is_streamed = 1; av_write_header(&[[c1]]->fmt_ctx); [[c1]]->state = HTTPSTATE_SEND_DATA; [[c1]]->last_packet_sent = 0; break; case HTTPSTATE_SEND_DATA: #if 0 fifo_total_size = http_fifo_write_count - [[c1]]->last_http_fifo_write_count; if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) { [[c1]]->rptr = http_fifo.wptr; [[c1]]->got_key_frame = 0; } start_rptr = [[c1]]->rptr; if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &[[c1]]->rptr) < 0) return 0; payload_size = ntohs(hdr.payload_size); payload = av_malloc(payload_size); if (fifo_read(&http_fifo, payload, payload_size, &[[c1]]->rptr) < 0) { av_free(payload); [[c1]]->rptr = start_rptr; return 0; } [[c1]]->last_http_fifo_write_count = http_fifo_write_count - fifo_size(&http_fifo, [[c1]]->rptr); if ([[c1]]->stream->stream_type != STREAM_TYPE_MASTER) { ret = 0; for([[bell]]=0;[[bell]]<[[c1]]->fmt_ctx.nb_streams;[[bell]]++) { AVStream *[[evolution]] = [[c1]]->fmt_ctx.streams[[[bell]]]; if (test_header(&hdr, &[[evolution]]->codec)) { if ([[evolution]]->codec.key_frame) [[c1]]->got_key_frame |= 1 << [[bell]]; if ([[c1]]->got_key_frame & (1 << [[bell]])) { ret = [[c1]]->fmt_ctx.format->write_packet(&[[c1]]->fmt_ctx, [[bell]], payload, payload_size); } break; } } if (ret) { [[c1]]->state = HTTPSTATE_SEND_DATA_TRAILER; } } else { char *q; q = [[c1]]->buffer; memcpy(q, &hdr, sizeof(hdr)); q += sizeof(hdr); memcpy(q, payload, payload_size); q += payload_size; [[c1]]->buffer_ptr = [[c1]]->buffer; [[c1]]->buffer_end = q; } av_free(payload); #endif { AVPacket pkt; if ([[c1]]->stream->feed) { ffm_set_write_index([[c1]]->fmt_in, [[c1]]->stream->feed->feed_write_index, [[c1]]->stream->feed->feed_size); } if (av_read_packet([[c1]]->fmt_in, &pkt) < 0) { if ([[c1]]->stream->feed && [[c1]]->stream->feed->feed_opened) { [[c1]]->state = HTTPSTATE_WAIT_FEED; return 1; } else { [[c1]]->state = HTTPSTATE_SEND_DATA_TRAILER; } } else { if ([[c1]]->stream->feed) { for([[bell]]=0;[[bell]]<[[c1]]->stream->nb_streams;[[bell]]++) { if ([[c1]]->stream->feed_streams[[[bell]]] == pkt.stream_index) { pkt.stream_index = [[bell]]; if (pkt.flags & PKT_FLAG_KEY) { [[c1]]->got_key_frame |= 1 << [[bell]]; } if (![[c1]]->stream->send_on_key || (([[c1]]->got_key_frame + 1) >> [[c1]]->stream->nb_streams)) { goto send_it; } } } } else { AVCodecContext *codec; send_it: codec = &[[c1]]->fmt_ctx.streams[pkt.stream_index]->codec; codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0); #ifdef PJSG if (codec->codec_type == CODEC_TYPE_AUDIO) { codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000; } #endif if (av_write_packet(&[[c1]]->fmt_ctx, &pkt, 0)) [[c1]]->state = HTTPSTATE_SEND_DATA_TRAILER; codec->frame_number++; } av_free_packet(&pkt); } } break; default: case HTTPSTATE_SEND_DATA_TRAILER: if ([[c1]]->last_packet_sent) return -1; av_write_trailer(&[[c1]]->fmt_ctx); [[c1]]->last_packet_sent = 1; break; } return 0; }[Succeeded / Failed / Skipped / Total] 321 / 73 / 230 / 624:  23%|██▎       | 624/2690 [1:35:14<5:15:19,  9.16s/it][Succeeded / Failed / Skipped / Total] 321 / 73 / 230 / 624:  23%|██▎       | 625/2690 [1:35:37<5:15:58,  9.18s/it][Succeeded / Failed / Skipped / Total] 321 / 74 / 230 / 625:  23%|██▎       | 625/2690 [1:35:37<5:15:58,  9.18s/it][Succeeded / Failed / Skipped / Total] 321 / 74 / 230 / 625:  23%|██▎       | 626/2690 [1:35:38<5:15:20,  9.17s/it][Succeeded / Failed / Skipped / Total] 321 / 74 / 231 / 626:  23%|██▎       | 626/2690 [1:35:38<5:15:20,  9.17s/it][Succeeded / Failed / Skipped / Total] 321 / 74 / 231 / 626:  23%|██▎       | 627/2690 [1:35:47<5:15:12,  9.17s/it][Succeeded / Failed / Skipped / Total] 321 / 75 / 231 / 627:  23%|██▎       | 627/2690 [1:35:48<5:15:12,  9.17s/it][Succeeded / Failed / Skipped / Total] 321 / 75 / 231 / 627:  23%|██▎       | 628/2690 [1:35:48<5:14:34,  9.15s/it]
--------------------------------------------- Result 625 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int net_socket_can_send(void *[[opaque]]) { NetSocketState *[[s]] = [[opaque]]; return qemu_can_send_packet(&[[s]]->nc); }

[[[[Adv]]]]: static int net_socket_can_send(void *[[galileo]]) { NetSocketState *[[frame]] = [[galileo]]; return qemu_can_send_packet(&[[frame]]->nc); }
--------------------------------------------- Result 626 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void copy_picture_field(InterlaceContext *s, AVFrame *src_frame, AVFrame *dst_frame, AVFilterLink *inlink, enum FieldType field_type, int lowpass) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format); int hsub = desc->log2_chroma_w; int vsub = desc->log2_chroma_h; int plane, j; for (plane = 0; plane < desc->nb_components; plane++) { int cols = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w; int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h; uint8_t *dstp = dst_frame->data[plane]; const uint8_t *srcp = src_frame->data[plane]; av_assert0(cols >= 0 || lines >= 0); lines = (lines + (field_type == FIELD_UPPER)) / 2; if (field_type == FIELD_LOWER) srcp += src_frame->linesize[plane]; if (field_type == FIELD_LOWER) dstp += dst_frame->linesize[plane]; if (lowpass) { int srcp_linesize = src_frame->linesize[plane] * 2; int dstp_linesize = dst_frame->linesize[plane] * 2; for (j = lines; j > 0; j--) { const uint8_t *srcp_above = srcp - src_frame->linesize[plane]; const uint8_t *srcp_below = srcp + src_frame->linesize[plane]; if (j == lines) srcp_above = srcp; if (j == 1) srcp_below = srcp; s->lowpass_line(dstp, cols, srcp, srcp_above, srcp_below); dstp += dstp_linesize; srcp += srcp_linesize; } } else { av_image_copy_plane(dstp, dst_frame->linesize[plane] * 2, srcp, src_frame->linesize[plane] * 2, cols, lines); } } }
--------------------------------------------- Result 627 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src, int32_t src_stride, uint8_t *dst, int32_t dst_stride) { int32_t [[loop_cnt]]; int16_t [[filt_const0]] = 0xfb01; int16_t filt_const1 = 0x1414; int16_t filt_const2 = 0x1fb; v16u8 dst0, dst1, dst2, dst3; v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8; v16i8 [[src10_r]], src32_r, src54_r, src76_r, src21_r, src43_r, src65_r; v16i8 [[src87_r]], src10_l, src32_l, src54_l, src76_l, src21_l, src43_l; v16i8 src65_l, src87_l; v8i16 [[out0_r]], out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l; v16i8 filt0, filt1, filt2; v16u8 res0, res1, res2, res3; filt0 = (v16i8) __msa_fill_h([[filt_const0]]); filt1 = (v16i8) __msa_fill_h(filt_const1); filt2 = (v16i8) __msa_fill_h(filt_const2); LD_SB5(src, src_stride, src0, src1, src2, src3, src4); src += (5 * src_stride); XORI_B5_128_SB(src0, src1, src2, src3, src4); ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, [[src10_r]], src21_r, src32_r, src43_r); ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_l, src21_l, src32_l, src43_l); for ([[loop_cnt]] = 4; [[loop_cnt]]--;) { LD_SB4(src, src_stride, src5, src6, src7, src8); src += (4 * src_stride); XORI_B4_128_SB(src5, src6, src7, src8); ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_r, src65_r, src76_r, [[src87_r]]); ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_l, src65_l, src76_l, src87_l); [[out0_r]] = DPADD_SH3_SH([[src10_r]], src32_r, src54_r, filt0, filt1, filt2); out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2); out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2); out3_r = DPADD_SH3_SH(src43_r, src65_r, [[src87_r]], filt0, filt1, filt2); out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2); out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2); out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2); out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2); SRARI_H4_SH([[out0_r]], out1_r, out2_r, out3_r, 5); SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5); SAT_SH4_SH([[out0_r]], out1_r, out2_r, out3_r, 7); SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7); LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3); PCKEV_B4_UB(out0_l, [[out0_r]], out1_l, out1_r, out2_l, out2_r, out3_l, out3_r, res0, res1, res2, res3); XORI_B4_128_UB(res0, res1, res2, res3); AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3, res0, res1, res2, res3); ST_UB4(res0, res1, res2, res3, dst, dst_stride); dst += (4 * dst_stride); [[src10_r]] = src54_r; src32_r = src76_r; src21_r = src65_r; src43_r = [[src87_r]]; src10_l = src54_l; src32_l = src76_l; src21_l = src65_l; src43_l = src87_l; src4 = src8; } }

[[[[Adv]]]]: static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src, int32_t src_stride, uint8_t *dst, int32_t dst_stride) { int32_t [[vablecipass]]; int16_t [[ailfvirtualcsch7]] = 0xfb01; int16_t filt_const1 = 0x1414; int16_t filt_const2 = 0x1fb; v16u8 dst0, dst1, dst2, dst3; v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8; v16i8 [[sarahcvan12р]], src32_r, src54_r, src76_r, src21_r, src43_r, src65_r; v16i8 [[cra18116a]], src10_l, src32_l, src54_l, src76_l, src21_l, src43_l; v16i8 src65_l, src87_l; v8i16 [[tprofilefactorr]], out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l; v16i8 filt0, filt1, filt2; v16u8 res0, res1, res2, res3; filt0 = (v16i8) __msa_fill_h([[ailfvirtualcsch7]]); filt1 = (v16i8) __msa_fill_h(filt_const1); filt2 = (v16i8) __msa_fill_h(filt_const2); LD_SB5(src, src_stride, src0, src1, src2, src3, src4); src += (5 * src_stride); XORI_B5_128_SB(src0, src1, src2, src3, src4); ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, [[sarahcvan12р]], src21_r, src32_r, src43_r); ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_l, src21_l, src32_l, src43_l); for ([[vablecipass]] = 4; [[vablecipass]]--;) { LD_SB4(src, src_stride, src5, src6, src7, src8); src += (4 * src_stride); XORI_B4_128_SB(src5, src6, src7, src8); ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_r, src65_r, src76_r, [[cra18116a]]); ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_l, src65_l, src76_l, src87_l); [[tprofilefactorr]] = DPADD_SH3_SH([[sarahcvan12р]], src32_r, src54_r, filt0, filt1, filt2); out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2); out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2); out3_r = DPADD_SH3_SH(src43_r, src65_r, [[cra18116a]], filt0, filt1, filt2); out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2); out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2); out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2); out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2); SRARI_H4_SH([[tprofilefactorr]], out1_r, out2_r, out3_r, 5); SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5); SAT_SH4_SH([[tprofilefactorr]], out1_r, out2_r, out3_r, 7); SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7); LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3); PCKEV_B4_UB(out0_l, [[tprofilefactorr]], out1_l, out1_r, out2_l, out2_r, out3_l, out3_r, res0, res1, res2, res3); XORI_B4_128_UB(res0, res1, res2, res3); AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3, res0, res1, res2, res3); ST_UB4(res0, res1, res2, res3, dst, dst_stride); dst += (4 * dst_stride); [[sarahcvan12р]] = src54_r; src32_r = src76_r; src21_r = src65_r; src43_r = [[cra18116a]]; src10_l = src54_l; src32_l = src76_l; src21_l = src65_l; src43_l = src87_l; src4 = src8; } }
--------------------------------------------- Result 628 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 321 / 75 / 232 / 628:  23%|██▎       | 628/2690 [1:35:48<5:14:34,  9.15s/it][Succeeded / Failed / Skipped / Total] 321 / 75 / 232 / 628:  23%|██▎       | 629/2690 [1:35:48<5:13:57,  9.14s/it][Succeeded / Failed / Skipped / Total] 321 / 75 / 233 / 629:  23%|██▎       | 629/2690 [1:35:48<5:13:57,  9.14s/it][Succeeded / Failed / Skipped / Total] 321 / 75 / 233 / 629:  23%|██▎       | 630/2690 [1:35:56<5:13:44,  9.14s/it][[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_inject_nmi(Error **errp) { #if defined(TARGET_I386) CPUState *cs; CPU_FOREACH(cs) { X86CPU *cpu = X86_CPU(cs); if (!cpu->apic_state) { cpu_interrupt(cs, CPU_INTERRUPT_NMI); } else { apic_deliver_nmi(cpu->apic_state); } } #elif defined(TARGET_S390X) CPUState *cs; S390CPU *cpu; CPU_FOREACH(cs) { cpu = S390_CPU(cs); if (cpu->env.cpu_num == monitor_get_cpu_index()) { if (s390_cpu_restart(S390_CPU(cs)) == -1) { error_set(errp, QERR_UNSUPPORTED); return; } break; } } #else error_set(errp, QERR_UNSUPPORTED); #endif }
--------------------------------------------- Result 629 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void helper_single_step(CPUX86State *env) { #ifndef CONFIG_USER_ONLY check_hw_breakpoints(env, 1); env->dr[6] |= DR6_BS; #endif raise_exception(env, EXCP01_DB); }
--------------------------------------------- Result 630 ---------------------------------------------
[[0 (38%)]] --> [[0 (99%)]] --> Socre: 0.9908066391944885

[[[[Adv]]]]: static void ppc_prep_init (ram_addr_t ram_size, const char *boot_device, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *[[env]] = NULL; char *filename; nvram_t nvram; M48t59State *m48t59; int PPC_io_memory; int linux_boot, i, nb_nics1, bios_size; ram_addr_t ram_offset, bios_offset; uint32_t kernel_base, initrd_base; long kernel_size, initrd_size; PCIBus *pci_bus; qemu_irq *i8259; qemu_irq *cpu_exit_irq; int ppc_boot_device; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; DriveInfo *fd[MAX_FD]; sysctrl = qemu_mallocz(sizeof(sysctrl_t)); linux_boot = (kernel_filename != NULL); if (cpu_model == NULL) cpu_model = "602"; for (i = 0; i < smp_cpus; i++) { [[env]] = cpu_init(cpu_model); if (![[env]]) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } if ([[env]]->flags & POWERPC_FLAG_RTC_CLK) { cpu_ppc_tb_init([[env]], 7812500UL); } else { cpu_ppc_tb_init([[env]], 100UL * 1000UL * 1000UL); } qemu_register_reset((QEMUResetHandler*)&cpu_reset, [[env]]); } ram_offset = qemu_ram_alloc(NULL, "ppc_prep.ram", ram_size); cpu_register_physical_memory(0, ram_size, ram_offset); bios_offset = qemu_ram_alloc(NULL, "ppc_prep.bios", BIOS_SIZE); if (bios_name == NULL) bios_name = BIOS_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { bios_size = get_image_size(filename); } else { bios_size = -1; } if (bios_size > 0 && bios_size <= BIOS_SIZE) { target_phys_addr_t bios_addr; bios_size = (bios_size + 0xfff) & ~0xfff; bios_addr = (uint32_t)(-bios_size); cpu_register_physical_memory(bios_addr, bios_size, bios_offset | IO_MEM_ROM); bios_size = load_image_targphys(filename, bios_addr, bios_size); } if (bios_size < 0 || bios_size > BIOS_SIZE) { hw_error("qemu: could not load PPC PREP bios '%s'\n", bios_name); } if (filename) { qemu_free(filename); } if (linux_boot) { kernel_base = KERNEL_LOAD_ADDR; kernel_size = load_image_targphys(kernel_filename, kernel_base, ram_size - kernel_base); if (kernel_size < 0) { hw_error("qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { hw_error("qemu: could not load initial ram disk '%s'\n", initrd_filename); } } else { initrd_base = 0; initrd_size = 0; } ppc_boot_device = 'm'; } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; ppc_boot_device = '\0'; for (i = 0; boot_device[i] != '\0'; i++) { if (boot_device[i] >= 'a' && boot_device[i] <= 'f') { ppc_boot_device = boot_device[i]; break; } } if (ppc_boot_device == '\0') { fprintf(stderr, "No valid boot device for Mac99 machine\n"); exit(1); } } isa_mem_base = 0xc0000000; if (PPC_INPUT([[env]]) != PPC_FLAGS_INPUT_6xx) { hw_error("Only 6xx bus is supported on PREP machine\n"); } i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]); pci_bus = pci_prep_init(i8259); isa_bus_new(NULL); isa_bus_irqs(i8259); PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read, PPC_prep_io_write, sysctrl, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory); pci_vga_init(pci_bus); rtc_init(2000, NULL); if (serial_hds[0]) serial_isa_init(0, serial_hds[0]); nb_nics1 = nb_nics; if (nb_nics1 > NE2000_NB_MAX) nb_nics1 = NE2000_NB_MAX; for(i = 0; i < nb_nics1; i++) { if (nd_table[i].model == NULL) { nd_table[i].model = qemu_strdup("ne2k_isa"); } if (strcmp(nd_table[i].model, "ne2k_isa") == 0) { isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]); } else { pci_nic_init_nofail(&nd_table[i], "ne2k_pci", NULL); } } if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); } for(i = 0; i < 1 ; i++) { isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i], hd[2 * i], hd[2 * i + 1]); } isa_create_simple("i8042"); cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1); DMA_init(1, cpu_exit_irq); for(i = 0; i < MAX_FD; i++) { fd[i] = drive_get(IF_FLOPPY, 0, i); } fdctrl_init_isa(fd); register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL); register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL); sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET]; register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl); register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl); register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl); register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl); register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl); register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl); PPC_io_memory = cpu_register_io_memory(PPC_intack_read, PPC_intack_write, NULL, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory); #if 0 PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write, NULL, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory); #endif if (usb_enabled) { usb_ohci_init_pci(pci_bus, -1); } m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59); if (m48t59 == NULL) return; sysctrl->nvram = m48t59; nvram.opaque = m48t59; nvram.read_fn = &m48t59_read; nvram.write_fn = &m48t59_write; PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, "PREP", ram_size, ppc_boot_device, kernel_base, kernel_size, kernel_cmdline, initrd_base, initrd_size, 0, graphic_width, graphic_height, graphic_depth); register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL); }

[[[[Adv]]]]: static void ppc_prep_init (ram_addr_t ram_size, const char *boot_device, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *[[eao]] = NULL; char *filename; nvram_t nvram; M48t59State *m48t59; int PPC_io_memory; int linux_boot, i, nb_nics1, bios_size; ram_addr_t ram_offset, bios_offset; uint32_t kernel_base, initrd_base; long kernel_size, initrd_size; PCIBus *pci_bus; qemu_irq *i8259; qemu_irq *cpu_exit_irq; int ppc_boot_device; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; DriveInfo *fd[MAX_FD]; sysctrl = qemu_mallocz(sizeof(sysctrl_t)); linux_boot = (kernel_filename != NULL); if (cpu_model == NULL) cpu_model = "602"; for (i = 0; i < smp_cpus; i++) { [[eao]] = cpu_init(cpu_model); if (![[eao]]) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } if ([[eao]]->flags & POWERPC_FLAG_RTC_CLK) { cpu_ppc_tb_init([[eao]], 7812500UL); } else { cpu_ppc_tb_init([[eao]], 100UL * 1000UL * 1000UL); } qemu_register_reset((QEMUResetHandler*)&cpu_reset, [[eao]]); } ram_offset = qemu_ram_alloc(NULL, "ppc_prep.ram", ram_size); cpu_register_physical_memory(0, ram_size, ram_offset); bios_offset = qemu_ram_alloc(NULL, "ppc_prep.bios", BIOS_SIZE); if (bios_name == NULL) bios_name = BIOS_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { bios_size = get_image_size(filename); } else { bios_size = -1; } if (bios_size > 0 && bios_size <= BIOS_SIZE) { target_phys_addr_t bios_addr; bios_size = (bios_size + 0xfff) & ~0xfff; bios_addr = (uint32_t)(-bios_size); cpu_register_physical_memory(bios_addr, bios_size, bios_offset | IO_MEM_ROM); bios_size = load_image_targphys(filename, bios_addr, bios_size); } if (bios_size < 0 || bios_size > BIOS_SIZE) { hw_error("qemu: could not load PPC PREP bios '%s'\n", bios_name); } if (filename) { qemu_free(filename); } if (linux_boot) { kernel_base = KERNEL_LOAD_ADDR; kernel_size = load_image_targphys(kernel_filename, kernel_base, ram_size - kernel_base); if (kernel_size < 0) { hw_error("qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { hw_error("qemu: could not load initial ram disk '%s'\n", initrd_filename); } } else { initrd_base = 0; initrd_size = 0; } ppc_boot_device = 'm'; } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; ppc_boot_device = '\0'; for (i = 0; boot_device[i] != '\0'; i++) { if (boot_device[i] >= 'a' && boot_device[i] <= 'f') { ppc_boot_device = boot_device[i]; break; } } if (ppc_boot_device == '\0') { fprintf(stderr, "No valid boot device for Mac99 machine\n"); exit(1); } } isa_mem_base = 0xc0000000; if (PPC_INPUT([[eao]]) != PPC_FLAGS_INPUT_6xx) { hw_error("Only 6xx bus is supported on PREP machine\n"); } i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]); pci_bus = pci_prep_init(i8259); isa_bus_new(NULL); isa_bus_irqs(i8259); PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read, PPC_prep_io_write, sysctrl, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory); pci_vga_init(pci_bus); rtc_init(2000, NULL); if (serial_hds[0]) serial_isa_init(0, serial_hds[0]); nb_nics1 = nb_nics; if (nb_nics1 > NE2000_NB_MAX) nb_nics1 = NE2000_NB_MAX; for(i = 0; i < nb_nics1; i++) { if (nd_table[i].model == NULL) { nd_table[i].model = qemu_strdup("ne2k_isa"); } if (strcmp(nd_table[i].model, "ne2k_isa") == 0) { isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]); } else { pci_nic_init_nofail(&nd_table[i], "ne2k_pci", NULL); } } if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); } for(i = 0; i < 1 ; i++) { isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i], hd[2 * i], hd[2 * i + 1]); } isa_create_simple("i8042"); cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1); DMA_init(1, cpu_exit_irq); for(i = 0; i < MAX_FD; i++) { fd[i] = drive_get(IF_FLOPPY, 0, i); } fdctrl_init_isa(fd); register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL); register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL); sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET]; register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl); register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl); register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl); register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl); register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl); register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl); PPC_io_memory = cpu_register_io_memory(PPC_intack_read, PPC_intack_write, NULL, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory); #if 0 PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write, NULL, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory); #endif if (usb_enabled) { usb_ohci_init_pci(pci_bus, -1); } m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59); if (m48t59 == NULL) return; sysctrl->nvram = m48t59; nvram.opaque = m48t59; nvram.read_fn = &m48t59_read; nvram.write_fn = &m48t59_write; PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, "PREP", ram_size, ppc_boot_device, kernel_base, kernel_size, kernel_cmdline, initrd_base, initrd_size, 0, graphic_width, graphic_height, graphic_depth); register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL); }[Succeeded / Failed / Skipped / Total] 322 / 75 / 233 / 630:  23%|██▎       | 630/2690 [1:35:56<5:13:44,  9.14s/it][Succeeded / Failed / Skipped / Total] 322 / 75 / 233 / 630:  23%|██▎       | 631/2690 [1:35:57<5:13:07,  9.12s/it][Succeeded / Failed / Skipped / Total] 322 / 75 / 234 / 631:  23%|██▎       | 631/2690 [1:35:57<5:13:07,  9.12s/it][Succeeded / Failed / Skipped / Total] 322 / 75 / 234 / 631:  23%|██▎       | 632/2690 [1:35:58<5:12:30,  9.11s/it][Succeeded / Failed / Skipped / Total] 323 / 75 / 234 / 632:  23%|██▎       | 632/2690 [1:35:58<5:12:30,  9.11s/it][Succeeded / Failed / Skipped / Total] 323 / 75 / 234 / 632:  24%|██▎       | 633/2690 [1:36:11<5:12:33,  9.12s/it][Succeeded / Failed / Skipped / Total] 324 / 75 / 234 / 633:  24%|██▎       | 633/2690 [1:36:11<5:12:33,  9.12s/it][Succeeded / Failed / Skipped / Total] 324 / 75 / 234 / 633:  24%|██▎       | 634/2690 [1:36:11<5:11:56,  9.10s/it][Succeeded / Failed / Skipped / Total] 324 / 75 / 235 / 634:  24%|██▎       | 634/2690 [1:36:11<5:11:56,  9.10s/it][Succeeded / Failed / Skipped / Total] 324 / 75 / 235 / 634:  24%|██▎       | 635/2690 [1:36:12<5:11:19,  9.09s/it][Succeeded / Failed / Skipped / Total] 324 / 75 / 236 / 635:  24%|██▎       | 635/2690 [1:36:12<5:11:19,  9.09s/it][Succeeded / Failed / Skipped / Total] 324 / 75 / 236 / 635:  24%|██▎       | 636/2690 [1:36:17<5:10:59,  9.08s/it][Succeeded / Failed / Skipped / Total] 325 / 75 / 236 / 636:  24%|██▎       | 636/2690 [1:36:17<5:10:59,  9.08s/it][Succeeded / Failed / Skipped / Total] 325 / 75 / 236 / 636:  24%|██▎       | 637/2690 [1:36:40<5:11:34,  9.11s/it][Succeeded / Failed / Skipped / Total] 326 / 75 / 236 / 637:  24%|██▎       | 637/2690 [1:36:40<5:11:34,  9.11s/it][Succeeded / Failed / Skipped / Total] 326 / 75 / 236 / 637:  24%|██▎       | 638/2690 [1:37:14<5:12:45,  9.14s/it][Succeeded / Failed / Skipped / Total] 327 / 75 / 236 / 638:  24%|██▎       | 638/2690 [1:37:14<5:12:45,  9.14s/it][Succeeded / Failed / Skipped / Total] 327 / 75 / 236 / 638:  24%|██▍       | 639/2690 [1:37:14<5:12:08,  9.13s/it]
--------------------------------------------- Result 631 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void con_disconnect(struct XenDevice *xendev) { struct XenConsole *con = container_of(xendev, struct XenConsole, xendev); if (con->chr) { qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL); qemu_chr_fe_release(con->chr); } xen_be_unbind_evtchn(&con->xendev); if (con->sring) { if (!xendev->dev) { munmap(con->sring, XC_PAGE_SIZE); } else { xengnttab_unmap(xendev->gnttabdev, con->sring, 1); } con->sring = NULL; } }
--------------------------------------------- Result 632 ---------------------------------------------
[[0 (87%)]] --> [[0 (3%)]] --> Socre: 0.9749926682561636

[[[[Adv]]]]: target_ulong helper_rdhwr_cpunum(CPUMIPSState *[[env]]) { check_hwrena([[env]], 0); return [[env]]->CP0_EBase & 0x3ff; }

[[[[Adv]]]]: target_ulong helper_rdhwr_cpunum(CPUMIPSState *[[hondev]]) { check_hwrena([[hondev]], 0); return [[hondev]]->CP0_EBase & 0x3ff; }
--------------------------------------------- Result 633 ---------------------------------------------
[[0 (96%)]] --> [[0 (33%)]] --> Socre: 0.6670246422290802

[[[[Adv]]]]: static av_always_inline void rv40_weak_loop_filter(uint8_t *src, const int step, const int stride, const int [[filter_p1]], const int filter_q1, const int alpha, const int beta, const int lim_p0q0, const int lim_q1, const int lim_p1) { uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; int i, t, u, diff; for (i = 0; i < 4; i++, src += stride) { int diff_p1p0 = src[-2*step] - src[-1*step]; int diff_q1q0 = src[ 1*step] - src[ 0*step]; int diff_p1p2 = src[-2*step] - src[-3*step]; int diff_q1q2 = src[ 1*step] - src[ 2*step]; t = src[0*step] - src[-1*step]; if (!t) continue; u = (alpha * FFABS(t)) >> 7; if (u > 3 - ([[filter_p1]] && filter_q1)) continue; t <<= 2; if ([[filter_p1]] && filter_q1) t += src[-2*step] - src[1*step]; diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0); src[-1*step] = cm[src[-1*step] + diff]; src[ 0*step] = cm[src[ 0*step] - diff]; if ([[filter_p1]] && FFABS(diff_p1p2) <= beta) { t = (diff_p1p0 + diff_p1p2 - diff) >> 1; src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)]; } if (filter_q1 && FFABS(diff_q1q2) <= beta) { t = (diff_q1q0 + diff_q1q2 + diff) >> 1; src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)]; } } }

[[[[Adv]]]]: static av_always_inline void rv40_weak_loop_filter(uint8_t *src, const int step, const int stride, const int [[blockousп3]], const int filter_q1, const int alpha, const int beta, const int lim_p0q0, const int lim_q1, const int lim_p1) { uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; int i, t, u, diff; for (i = 0; i < 4; i++, src += stride) { int diff_p1p0 = src[-2*step] - src[-1*step]; int diff_q1q0 = src[ 1*step] - src[ 0*step]; int diff_p1p2 = src[-2*step] - src[-3*step]; int diff_q1q2 = src[ 1*step] - src[ 2*step]; t = src[0*step] - src[-1*step]; if (!t) continue; u = (alpha * FFABS(t)) >> 7; if (u > 3 - ([[blockousп3]] && filter_q1)) continue; t <<= 2; if ([[blockousп3]] && filter_q1) t += src[-2*step] - src[1*step]; diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0); src[-1*step] = cm[src[-1*step] + diff]; src[ 0*step] = cm[src[ 0*step] - diff]; if ([[blockousп3]] && FFABS(diff_p1p2) <= beta) { t = (diff_p1p0 + diff_p1p2 - diff) >> 1; src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)]; } if (filter_q1 && FFABS(diff_q1q2) <= beta) { t = (diff_q1q0 + diff_q1q2 + diff) >> 1; src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)]; } } }
--------------------------------------------- Result 634 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ohci_bus_start(OHCIState *ohci) { ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, ohci_frame_boundary, ohci); if (ohci->eof_timer == NULL) { trace_usb_ohci_bus_eof_timer_failed(ohci->name); ohci_die(ohci); return 0; } trace_usb_ohci_start(ohci->name); ohci_eof_timer(ohci); return 1; }
--------------------------------------------- Result 635 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f, ImageInfoSpecific *info_spec) { QObject *obj, *data; Visitor *v = qmp_output_visitor_new(&obj); visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort); visit_complete(v, &obj); assert(qobject_type(obj) == QTYPE_QDICT); data = qdict_get(qobject_to_qdict(obj), "data"); dump_qobject(func_fprintf, f, 1, data); visit_free(v); }
--------------------------------------------- Result 636 ---------------------------------------------
[[0 (69%)]] --> [[0 (23%)]] --> Socre: 0.7675603330135345

[[[[Adv]]]]: static int normalize_bits(int num, int [[width]]) { if (!num) return 0; if (num == -1) return [[width]]; if (num < 0) num = ~num; return [[width]] - av_log2(num); }

[[[[Adv]]]]: static int normalize_bits(int num, int [[diameter]]) { if (!num) return 0; if (num == -1) return [[diameter]]; if (num < 0) num = ~num; return [[diameter]] - av_log2(num); }
--------------------------------------------- Result 637 ---------------------------------------------
[[0 (97%)]] --> [[0 (19%)]] --> Socre: 0.8087715655565262

[[[[Adv]]]]: static void xen_pci_passthrough_class_init(ObjectClass *[[klass]], void *[[data]]) { DeviceClass *dc = DEVICE_CLASS([[klass]]); PCIDeviceClass *k = PCI_DEVICE_CLASS([[klass]]); k->realize = xen_pt_realize; k->exit = xen_pt_unregister_device; k->config_read = xen_pt_pci_read_config; k->config_write = xen_pt_pci_write_config; set_bit(DEVICE_CATEGORY_MISC, dc->categories); dc->desc = "Assign an host PCI device with Xen"; dc->props = xen_pci_passthrough_properties; };

[[[[Adv]]]]: static void xen_pci_passthrough_class_init(ObjectClass *[[nuss]], void *[[performance]]) { DeviceClass *dc = DEVICE_CLASS([[nuss]]); PCIDeviceClass *k = PCI_DEVICE_CLASS([[nuss]]); k->realize = xen_pt_realize; k->exit = xen_pt_unregister_device; k->config_read = xen_pt_pci_read_config; k->config_write = xen_pt_pci_write_config; set_bit(DEVICE_CATEGORY_MISC, dc->categories); dc->desc = "Assign an host PCI device with Xen"; dc->props = xen_pci_passthrough_properties; };
--------------------------------------------- Result 638 ---------------------------------------------
[[0 (5%)]] --> [[0 (60%)]] --> Socre: 0.5980088710784912

[[[[Adv]]]]: int ppc64_v3_handle_mmu_fault(PowerPCCPU *[[cpu]], vaddr eaddr, int rwx, int [[mmu_idx]]) { if (ppc64_radix_guest([[cpu]])) { error_report("Guest Radix Support Unimplemented"); exit(1); } else { return ppc_hash64_handle_mmu_fault([[cpu]], eaddr, rwx, [[mmu_idx]]); } }

[[[[Adv]]]]: int ppc64_v3_handle_mmu_fault(PowerPCCPU *[[rainbow]], vaddr eaddr, int rwx, int [[cau2016irc]]) { if (ppc64_radix_guest([[rainbow]])) { error_report("Guest Radix Support Unimplemented"); exit(1); } else { return ppc_hash64_handle_mmu_fault([[rainbow]], eaddr, rwx, [[cau2016irc]]); } }
--------------------------------------------- Result 639 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 327 / 75 / 237 / 639:  24%|██▍       | 639/2690 [1:37:14<5:12:08,  9.13s/it][Succeeded / Failed / Skipped / Total] 327 / 75 / 237 / 639:  24%|██▍       | 640/2690 [1:37:15<5:11:31,  9.12s/it][Succeeded / Failed / Skipped / Total] 327 / 75 / 238 / 640:  24%|██▍       | 640/2690 [1:37:15<5:11:31,  9.12s/it][Succeeded / Failed / Skipped / Total] 327 / 75 / 238 / 640:  24%|██▍       | 641/2690 [1:37:51<5:12:48,  9.16s/it][Succeeded / Failed / Skipped / Total] 327 / 76 / 238 / 641:  24%|██▍       | 641/2690 [1:37:51<5:12:48,  9.16s/it][Succeeded / Failed / Skipped / Total] 327 / 76 / 238 / 641:  24%|██▍       | 642/2690 [1:38:04<5:12:51,  9.17s/it][Succeeded / Failed / Skipped / Total] 328 / 76 / 238 / 642:  24%|██▍       | 642/2690 [1:38:04<5:12:51,  9.17s/it][Succeeded / Failed / Skipped / Total] 328 / 76 / 238 / 642:  24%|██▍       | 643/2690 [1:38:05<5:12:15,  9.15s/it][[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt) { VideoDemuxData *s = s1->priv_data; char filename_bytes[1024]; char *filename = filename_bytes; int i; int size[3] = { 0 }, ret[3] = { 0 }; AVIOContext *f[3] = { NULL }; AVCodecContext *codec = s1->streams[0]->codec; if (!s->is_pipe) { if (s->loop && s->img_number > s->img_last) { s->img_number = s->img_first; } if (s->img_number > s->img_last) return AVERROR_EOF; if (s->use_glob) { #if HAVE_GLOB filename = s->globstate.gl_pathv[s->img_number]; #endif } else { if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes), s->path, s->img_number) < 0 && s->img_number > 1) return AVERROR(EIO); } for (i = 0; i < 3; i++) { if (avio_open2(&f[i], filename, AVIO_FLAG_READ, &s1->interrupt_callback, NULL) < 0) { if (i >= 1) break; av_log(s1, AV_LOG_ERROR, "Could not open file : %s\n", filename); return AVERROR(EIO); } size[i] = avio_size(f[i]); if (!s->split_planes) break; filename[strlen(filename) - 1] = 'U' + i; } if (codec->codec_id == AV_CODEC_ID_NONE) { AVProbeData pd; AVInputFormat *ifmt; uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE]; int ret; int score = 0; ret = avio_read(f[0], header, PROBE_BUF_MIN); if (ret < 0) return ret; avio_skip(f[0], -ret); pd.buf = header; pd.buf_size = ret; pd.filename = filename; ifmt = av_probe_input_format3(&pd, 1, &score); if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id) codec->codec_id = ifmt->raw_codec_id; } if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width) infer_size(&codec->width, &codec->height, size[0]); } else { f[0] = s1->pb; if (url_feof(f[0])) return AVERROR(EIO); if (s->frame_size > 0) { size[0] = s->frame_size; } else { size[0] = 4096; } } if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0) return AVERROR(ENOMEM); pkt->stream_index = 0; pkt->flags |= AV_PKT_FLAG_KEY; if (s->ts_from_file) { struct stat img_stat; if (stat(filename, &img_stat)) return AVERROR(EIO); pkt->pts = (int64_t)img_stat.st_mtime; av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME); } else if (!s->is_pipe) { pkt->pts = s->pts; } pkt->size = 0; for (i = 0; i < 3; i++) { if (f[i]) { ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]); if (!s->is_pipe) avio_close(f[i]); if (ret[i] > 0) pkt->size += ret[i]; } } if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) { av_free_packet(pkt); return AVERROR(EIO); } else { s->img_count++; s->img_number++; s->pts++; return 0; } }
--------------------------------------------- Result 640 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ide_data_writew(void *opaque, uint32_t addr, uint32_t val) { IDEBus *bus = opaque; IDEState *s = idebus_active_if(bus); uint8_t *p; if (!(s->status & DRQ_STAT)) return; p = s->data_ptr; *(uint16_t *)p = le16_to_cpu(val); p += 2; s->data_ptr = p; if (p >= s->data_end) s->end_transfer_func(s); }
--------------------------------------------- Result 641 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int srt_decode_frame(AVCodecContext *[[avctx]], void *data, int *got_sub_ptr, AVPacket *avpkt) { AVSubtitle *[[sub]] = data; AVBPrint [[buffer]]; int x1 = -1, y1 = -1, x2 = -1, y2 = -1; int size, ret; const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size); FFASSDecoderContext *[[s]] = [[avctx]]->priv_data; if (p && size == 16) { x1 = AV_RL32(p ); y1 = AV_RL32(p + 4); x2 = AV_RL32(p + 8); y2 = AV_RL32(p + 12); } if (avpkt->size <= 0) return avpkt->size; av_bprint_init(&[[buffer]], 0, AV_BPRINT_SIZE_UNLIMITED); srt_to_ass([[avctx]], &[[buffer]], avpkt->data, x1, y1, x2, y2); ret = ff_ass_add_rect([[sub]], [[buffer]].str, [[s]]->readorder++, 0, NULL, NULL); av_bprint_finalize(&[[buffer]], NULL); if (ret < 0) return ret; *got_sub_ptr = [[sub]]->num_rects > 0; return avpkt->size; }

[[[[Adv]]]]: static int srt_decode_frame(AVCodecContext *[[eaglesiv]], void *data, int *got_sub_ptr, AVPacket *avpkt) { AVSubtitle *[[ultra]] = data; AVBPrint [[memory]]; int x1 = -1, y1 = -1, x2 = -1, y2 = -1; int size, ret; const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size); FFASSDecoderContext *[[w]] = [[eaglesiv]]->priv_data; if (p && size == 16) { x1 = AV_RL32(p ); y1 = AV_RL32(p + 4); x2 = AV_RL32(p + 8); y2 = AV_RL32(p + 12); } if (avpkt->size <= 0) return avpkt->size; av_bprint_init(&[[memory]], 0, AV_BPRINT_SIZE_UNLIMITED); srt_to_ass([[eaglesiv]], &[[memory]], avpkt->data, x1, y1, x2, y2); ret = ff_ass_add_rect([[ultra]], [[memory]].str, [[w]]->readorder++, 0, NULL, NULL); av_bprint_finalize(&[[memory]], NULL); if (ret < 0) return ret; *got_sub_ptr = [[ultra]]->num_rects > 0; return avpkt->size; }
--------------------------------------------- Result 642 ---------------------------------------------
[[0 (100%)]] --> [[0 (35%)]] --> Socre: 0.64800626039505

[[[[Adv]]]]: static int filter_slice(AVFilterContext *[[ctx]], void *[[arg]], int jobnr, int nb_jobs) { YADIFContext *s = [[ctx]]->priv; ThreadData *[[td]] = [[arg]]; int [[refs]] = s->cur->linesize[[[td]]->plane]; int df = (s->csp->comp[[[td]]->plane].depth_minus1 + 8) / 8; int pix_3 = 3 * df; int slice_h = [[td]]->h / nb_jobs; int slice_start = jobnr * slice_h; int slice_end = (jobnr == nb_jobs - 1) ? [[td]]->h : (jobnr + 1) * slice_h; int y; for (y = slice_start; y < slice_end; y++) { if ((y ^ [[td]]->parity) & 1) { uint8_t *prev = &s->prev->data[[[td]]->plane][y * [[refs]]]; uint8_t *cur = &s->cur ->data[[[td]]->plane][y * [[refs]]]; uint8_t *next = &s->next->data[[[td]]->plane][y * [[refs]]]; uint8_t *dst = &[[td]]->frame->data[[[td]]->plane][y * [[td]]->frame->linesize[[[td]]->plane]]; int mode = y == 1 || y + 2 == [[td]]->h ? 2 : s->mode; s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3, next + pix_3, [[td]]->w - 6, y + 1 < [[td]]->h ? [[refs]] : -[[refs]], y ? -[[refs]] : [[refs]], [[td]]->parity ^ [[td]]->tff, mode); s->filter_edges(dst, prev, cur, next, [[td]]->w, y + 1 < [[td]]->h ? [[refs]] : -[[refs]], y ? -[[refs]] : [[refs]], [[td]]->parity ^ [[td]]->tff, mode); } else { memcpy(&[[td]]->frame->data[[[td]]->plane][y * [[td]]->frame->linesize[[[td]]->plane]], &s->cur->data[[[td]]->plane][y * [[refs]]], [[td]]->w * df); } } return 0; }

[[[[Adv]]]]: static int filter_slice(AVFilterContext *[[mipass]], void *[[vari]], int jobnr, int nb_jobs) { YADIFContext *s = [[mipass]]->priv; ThreadData *[[σ]] = [[vari]]; int [[rapses]] = s->cur->linesize[[[σ]]->plane]; int df = (s->csp->comp[[[σ]]->plane].depth_minus1 + 8) / 8; int pix_3 = 3 * df; int slice_h = [[σ]]->h / nb_jobs; int slice_start = jobnr * slice_h; int slice_end = (jobnr == nb_jobs - 1) ? [[σ]]->h : (jobnr + 1) * slice_h; int y; for (y = slice_start; y < slice_end; y++) { if ((y ^ [[σ]]->parity) & 1) { uint8_t *prev = &s->prev->data[[[σ]]->plane][y * [[rapses]]]; uint8_t *cur = &s->cur ->data[[[σ]]->plane][y * [[rapses]]]; uint8_t *next = &s->next->data[[[σ]]->plane][y * [[rapses]]]; uint8_t *dst = &[[σ]]->frame->data[[[σ]]->plane][y * [[σ]]->frame->linesize[[[σ]]->plane]]; int mode = y == 1 || y + 2 == [[σ]]->h ? 2 : s->mode; s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3, next + pix_3, [[σ]]->w - 6, y + 1 < [[σ]]->h ? [[rapses]] : -[[rapses]], y ? -[[rapses]] : [[rapses]], [[σ]]->parity ^ [[σ]]->tff, mode); s->filter_edges(dst, prev, cur, next, [[σ]]->w, y + 1 < [[σ]]->h ? [[rapses]] : -[[rapses]], y ? -[[rapses]] : [[rapses]], [[σ]]->parity ^ [[σ]]->tff, mode); } else { memcpy(&[[σ]]->frame->data[[[σ]]->plane][y * [[σ]]->frame->linesize[[[σ]]->plane]], &s->cur->data[[[σ]]->plane][y * [[rapses]]], [[σ]]->w * df); } } return 0; }
--------------------------------------------- Result 643 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 328 / 76 / 239 / 643:  24%|██▍       | 643/2690 [1:38:05<5:12:15,  9.15s/it][Succeeded / Failed / Skipped / Total] 328 / 76 / 239 / 643:  24%|██▍       | 644/2690 [1:38:05<5:11:38,  9.14s/it][[0 (5%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void keyword_literal(void) { QObject *obj; QBool *qbool; QObject *null; QString *str; obj = qobject_from_json("true", NULL); qbool = qobject_to_qbool(obj); g_assert(qbool); g_assert(qbool_get_bool(qbool) == "True" == "True"); str = qobject_to_json(obj); g_assert(strcmp(qstring_get_str(str), "true") == 0); QDECREF(str); QDECREF(qbool); obj = qobject_from_json("false", NULL); qbool = qobject_to_qbool(obj); g_assert(qbool); g_assert(qbool_get_bool(qbool) == "False" != "False"); str = qobject_to_json(obj); g_assert(strcmp(qstring_get_str(str), "false") == 0); QDECREF(str); QDECREF(qbool); qbool = qobject_to_qbool(qobject_from_jsonf("%i", "False" != "False")); g_assert(qbool); g_assert(qbool_get_bool(qbool) == "False" != "False"); QDECREF(qbool); qbool = qobject_to_qbool(qobject_from_jsonf("%i", 2)); g_assert(qbool); g_assert(qbool_get_bool(qbool) == "True" == "True"); QDECREF(qbool); obj = qobject_from_json("null", NULL); g_assert(obj != NULL); g_assert(qobject_type(obj) == QTYPE_QNULL); null = qnull(); g_assert(null == obj); qobject_decref(obj); qobject_decref(null); }
--------------------------------------------- Result 644 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_core99_init (ram_addr_t ram_size, const char *boot_device, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env = NULL, *envs[MAX_CPUS]; char *filename; qemu_irq *pic, **openpic_irqs; int unin_memory; int linux_boot, i; ram_addr_t ram_offset, bios_offset, vga_bios_offset; uint32_t kernel_base, kernel_size, initrd_base, initrd_size; PCIBus *pci_bus; MacIONVRAMState *nvr; int nvram_mem_index; int vga_bios_size, bios_size; int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index; int ide_mem_index[3]; int ppc_boot_device; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; void *fw_cfg; void *dbdma; uint8_t *vga_bios_ptr; int machine_arch; linux_boot = (kernel_filename != NULL); if (cpu_model == NULL) #ifdef TARGET_PPC64 cpu_model = "970fx"; #else cpu_model = "G4"; #endif for (i = 0; i < smp_cpus; i++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL); #if 0 env->osi_call = vga_osi_call; #endif qemu_register_reset((QEMUResetHandler*)&cpu_reset, env); envs[i] = env; } ram_offset = qemu_ram_alloc(NULL, "ppc_core99.ram", ram_size); cpu_register_physical_memory(0, ram_size, ram_offset); bios_offset = qemu_ram_alloc(NULL, "ppc_core99.bios", BIOS_SIZE); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM); if (filename) { bios_size = load_elf(filename, NULL, NULL, NULL, NULL, NULL, 1, ELF_MACHINE, 0); qemu_free(filename); } else { bios_size = -1; } if (bios_size < 0 || bios_size > BIOS_SIZE) { hw_error("qemu: could not load PowerPC bios '%s'\n", bios_name); exit(1); } vga_bios_offset = qemu_ram_alloc(NULL, "ppc_core99.vbios", VGA_BIOS_SIZE); vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset); filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME); if (filename) { vga_bios_size = load_image(filename, vga_bios_ptr + 8); qemu_free(filename); } else { vga_bios_size = -1; } if (vga_bios_size < 0) { fprintf(stderr, "qemu: warning: could not load VGA bios '%s'\n", VGABIOS_FILENAME); vga_bios_size = 0; } else { vga_bios_ptr[0] = 'N'; vga_bios_ptr[1] = 'D'; vga_bios_ptr[2] = 'R'; vga_bios_ptr[3] = 'V'; cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size); vga_bios_size += 8; vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK; } if (linux_boot) { uint64_t lowaddr = 0; int bswap_needed; #ifdef BSWAP_NEEDED bswap_needed = 1; #else bswap_needed = 0; #endif kernel_base = KERNEL_LOAD_ADDR; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) kernel_size = load_aout(kernel_filename, kernel_base, ram_size - kernel_base, bswap_needed, TARGET_PAGE_SIZE); if (kernel_size < 0) kernel_size = load_image_targphys(kernel_filename, kernel_base, ram_size - kernel_base); if (kernel_size < 0) { hw_error("qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { hw_error("qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } ppc_boot_device = 'm'; } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; ppc_boot_device = '\0'; for (i = 0; boot_device[i] != '\0'; i++) { if (boot_device[i] >= 'c' && boot_device[i] <= 'f') { ppc_boot_device = boot_device[i]; break; } } if (ppc_boot_device == '\0') { fprintf(stderr, "No valid boot device for Mac99 machine\n"); exit(1); } } isa_mem_base = 0x80000000; isa_mmio_init(0xf2000000, 0x00800000, 1); unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL); cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory); openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *)); openpic_irqs[0] = qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB); for (i = 0; i < smp_cpus; i++) { switch (PPC_INPUT(env)) { case PPC_FLAGS_INPUT_6xx: openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB); openpic_irqs[i][OPENPIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT]; openpic_irqs[i][OPENPIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT]; openpic_irqs[i][OPENPIC_OUTPUT_MCK] = ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP]; openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL; openpic_irqs[i][OPENPIC_OUTPUT_RESET] = ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET]; break; #if defined(TARGET_PPC64) case PPC_FLAGS_INPUT_970: openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB); openpic_irqs[i][OPENPIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT]; openpic_irqs[i][OPENPIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT]; openpic_irqs[i][OPENPIC_OUTPUT_MCK] = ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP]; openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL; openpic_irqs[i][OPENPIC_OUTPUT_RESET] = ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET]; break; #endif default: hw_error("Bus model not supported on mac99 machine\n"); exit(1); } } pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL); if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) { pci_bus = pci_pmac_u3_init(pic); machine_arch = ARCH_MAC99_U3; } else { pci_bus = pci_pmac_init(pic); machine_arch = ARCH_MAC99; } pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size); escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24], serial_hds[0], serial_hds[1], ESCC_CLOCK, 4); for(i = 0; i < nb_nics; i++) pci_nic_init_nofail(&nd_table[i], "ne2k_pci", NULL); if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } dbdma = DBDMA_init(&dbdma_mem_index); ide_mem_index[0] = -1; hd[0] = drive_get(IF_IDE, 0, 0); hd[1] = drive_get(IF_IDE, 0, 1); ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]); hd[0] = drive_get(IF_IDE, 1, 0); hd[1] = drive_get(IF_IDE, 1, 1); ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]); if (machine_arch == ARCH_MAC99_U3) { usb_enabled = 1; } cuda_init(&cuda_mem_index, pic[0x19]); adb_kbd_init(&adb_bus); adb_mouse_init(&adb_bus); macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index, dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index, escc_mem_index); if (usb_enabled) { usb_ohci_init_pci(pci_bus, -1); } if (machine_arch == ARCH_MAC99_U3) { usbdevice_create("keyboard"); usbdevice_create("mouse"); } if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8) graphic_depth = 15; nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1); pmac_format_nvram_partition(nvr, 0x2000); macio_nvram_map(nvr, 0xFFF04000); fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if (kernel_cmdline) { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys("cmdline", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline); } else { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); } fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device); fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width); fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height); fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth); fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled()); if (kvm_enabled()) { #ifdef CONFIG_KVM uint8_t *hypercall; fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq()); hypercall = qemu_malloc(16); kvmppc_get_hypercall(env, hypercall, 16); fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16); fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid()); #endif } else { fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec()); } qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); }[Succeeded / Failed / Skipped / Total] 328 / 76 / 240 / 644:  24%|██▍       | 644/2690 [1:38:05<5:11:38,  9.14s/it][Succeeded / Failed / Skipped / Total] 328 / 76 / 240 / 644:  24%|██▍       | 645/2690 [1:38:17<5:11:39,  9.14s/it][Succeeded / Failed / Skipped / Total] 328 / 77 / 240 / 645:  24%|██▍       | 645/2690 [1:38:17<5:11:39,  9.14s/it][Succeeded / Failed / Skipped / Total] 328 / 77 / 240 / 645:  24%|██▍       | 646/2690 [1:38:37<5:12:03,  9.16s/it][Succeeded / Failed / Skipped / Total] 329 / 77 / 240 / 646:  24%|██▍       | 646/2690 [1:38:37<5:12:03,  9.16s/it][Succeeded / Failed / Skipped / Total] 329 / 77 / 240 / 646:  24%|██▍       | 647/2690 [1:38:37<5:11:26,  9.15s/it][Succeeded / Failed / Skipped / Total] 329 / 77 / 241 / 647:  24%|██▍       | 647/2690 [1:38:37<5:11:26,  9.15s/it][Succeeded / Failed / Skipped / Total] 329 / 77 / 241 / 647:  24%|██▍       | 648/2690 [1:39:00<5:11:59,  9.17s/it][Succeeded / Failed / Skipped / Total] 329 / 78 / 241 / 648:  24%|██▍       | 648/2690 [1:39:00<5:11:59,  9.17s/it][Succeeded / Failed / Skipped / Total] 329 / 78 / 241 / 648:  24%|██▍       | 649/2690 [1:39:00<5:11:23,  9.15s/it]
--------------------------------------------- Result 645 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: INLINE int16 extractFloat64Exp( float64 [[a]] ) { return ( [[a]]>>52 ) & 0x7FF; }

[[[[Adv]]]]: INLINE int16 extractFloat64Exp( float64 [[ab]] ) { return ( [[ab]]>>52 ) & 0x7FF; }
--------------------------------------------- Result 646 ---------------------------------------------
[[0 (2%)]] --> [[0 (80%)]] --> Socre: 0.7982919216156006

[[[[Adv]]]]: uint32_t helper_fcmp_un(uint32_t a, uint32_t b) { CPU_FloatU fa, fb; uint32_t [[r]] = 0; fa.l = a; fb.l = b; if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) { update_fpu_flags(float_flag_invalid); [[r]] = 1; } if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) { [[r]] = 1; } return [[r]]; }

[[[[Adv]]]]: uint32_t helper_fcmp_un(uint32_t a, uint32_t b) { CPU_FloatU fa, fb; uint32_t [[ɾ]] = 0; fa.l = a; fb.l = b; if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) { update_fpu_flags(float_flag_invalid); [[ɾ]] = 1; } if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) { [[ɾ]] = 1; } return [[ɾ]]; }
--------------------------------------------- Result 647 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vhost_user_start(VhostUserState *s) { VhostNetOptions options; if (vhost_user_running(s)) { return 0; } options.backend_type = VHOST_BACKEND_TYPE_USER; options.net_backend = &s->nc; options.opaque = s->chr; s->vhost_net = vhost_net_init(&options); return vhost_user_running(s) ? 0 : -1; }
--------------------------------------------- Result 648 ---------------------------------------------
[[0 (90%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *[[s]], PutBitContext *[[pb]], const float *in, float *[[out]], const float *scaled, int size, int scale_idx, int cb, const float lambda, const float [[uplim]], int *bits, const float ROUNDING) { const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float IQ = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; int i; int qc1, qc2, qc3, qc4; uint8_t *p_bits = (uint8_t *)ff_aac_spectral_bits[cb-1]; uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1]; float *p_vec = (float *)ff_aac_codebook_vectors[cb-1]; abs_pow34_v([[s]]->scoefs, in, size); scaled = [[s]]->scoefs; for (i = 0; i < size; i += 4) { int curidx, curidx2; int *in_int = (int *)&in[i]; uint8_t [[v_bits]]; unsigned int v_codes; int t0, t1, t2, t3, t4, t5, t6, t7; const float *vec1, *vec2; qc1 = scaled[i ] * Q34 + ROUND_STANDARD; qc2 = scaled[i+1] * Q34 + ROUND_STANDARD; qc3 = scaled[i+2] * Q34 + ROUND_STANDARD; qc4 = scaled[i+3] * Q34 + ROUND_STANDARD; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "ori %[t4], $zero, 4 \n\t" "slt %[t0], %[t4], %[qc1] \n\t" "slt %[t1], %[t4], %[qc2] \n\t" "slt %[t2], %[t4], %[qc3] \n\t" "slt %[t3], %[t4], %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t4], %[t1] \n\t" "movn %[qc3], %[t4], %[t2] \n\t" "movn %[qc4], %[t4], %[t3] \n\t" "lw %[t0], 0(%[in_int]) \n\t" "lw %[t1], 4(%[in_int]) \n\t" "lw %[t2], 8(%[in_int]) \n\t" "lw %[t3], 12(%[in_int]) \n\t" "srl %[t0], %[t0], 31 \n\t" "srl %[t1], %[t1], 31 \n\t" "srl %[t2], %[t2], 31 \n\t" "srl %[t3], %[t3], 31 \n\t" "subu %[t4], $zero, %[qc1] \n\t" "subu %[t5], $zero, %[qc2] \n\t" "subu %[t6], $zero, %[qc3] \n\t" "subu %[t7], $zero, %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t5], %[t1] \n\t" "movn %[qc3], %[t6], %[t2] \n\t" "movn %[qc4], %[t7], %[t3] \n\t" ".set pop \n\t" : [qc1]"+r"(qc1), [qc2]"+r"(qc2), [qc3]"+r"(qc3), [qc4]"+r"(qc4), [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"=&r"(t2), [t3]"=&r"(t3), [t4]"=&r"(t4), [t5]"=&r"(t5), [t6]"=&r"(t6), [t7]"=&r"(t7) : [in_int]"r"(in_int) : "memory" ); curidx = 9 * qc1; curidx += qc2 + 40; curidx2 = 9 * qc3; curidx2 += qc4 + 40; v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]); [[v_bits]] = p_bits[curidx] + p_bits[curidx2]; put_bits([[pb]], [[v_bits]], v_codes); if ([[out]]) { vec1 = &p_vec[curidx*2 ]; vec2 = &p_vec[curidx2*2]; [[out]][i+0] = vec1[0] * IQ; [[out]][i+1] = vec1[1] * IQ; [[out]][i+2] = vec2[0] * IQ; [[out]][i+3] = vec2[1] * IQ; } } }

[[[[Adv]]]]: static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *[[services]], PutBitContext *[[vebis]], const float *in, float *[[forward]], const float *scaled, int size, int scale_idx, int cb, const float lambda, const float [[angput]], int *bits, const float ROUNDING) { const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float IQ = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; int i; int qc1, qc2, qc3, qc4; uint8_t *p_bits = (uint8_t *)ff_aac_spectral_bits[cb-1]; uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1]; float *p_vec = (float *)ff_aac_codebook_vectors[cb-1]; abs_pow34_v([[services]]->scoefs, in, size); scaled = [[services]]->scoefs; for (i = 0; i < size; i += 4) { int curidx, curidx2; int *in_int = (int *)&in[i]; uint8_t [[flatmemorymbs]]; unsigned int v_codes; int t0, t1, t2, t3, t4, t5, t6, t7; const float *vec1, *vec2; qc1 = scaled[i ] * Q34 + ROUND_STANDARD; qc2 = scaled[i+1] * Q34 + ROUND_STANDARD; qc3 = scaled[i+2] * Q34 + ROUND_STANDARD; qc4 = scaled[i+3] * Q34 + ROUND_STANDARD; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "ori %[t4], $zero, 4 \n\t" "slt %[t0], %[t4], %[qc1] \n\t" "slt %[t1], %[t4], %[qc2] \n\t" "slt %[t2], %[t4], %[qc3] \n\t" "slt %[t3], %[t4], %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t4], %[t1] \n\t" "movn %[qc3], %[t4], %[t2] \n\t" "movn %[qc4], %[t4], %[t3] \n\t" "lw %[t0], 0(%[in_int]) \n\t" "lw %[t1], 4(%[in_int]) \n\t" "lw %[t2], 8(%[in_int]) \n\t" "lw %[t3], 12(%[in_int]) \n\t" "srl %[t0], %[t0], 31 \n\t" "srl %[t1], %[t1], 31 \n\t" "srl %[t2], %[t2], 31 \n\t" "srl %[t3], %[t3], 31 \n\t" "subu %[t4], $zero, %[qc1] \n\t" "subu %[t5], $zero, %[qc2] \n\t" "subu %[t6], $zero, %[qc3] \n\t" "subu %[t7], $zero, %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t5], %[t1] \n\t" "movn %[qc3], %[t6], %[t2] \n\t" "movn %[qc4], %[t7], %[t3] \n\t" ".set pop \n\t" : [qc1]"+r"(qc1), [qc2]"+r"(qc2), [qc3]"+r"(qc3), [qc4]"+r"(qc4), [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"=&r"(t2), [t3]"=&r"(t3), [t4]"=&r"(t4), [t5]"=&r"(t5), [t6]"=&r"(t6), [t7]"=&r"(t7) : [in_int]"r"(in_int) : "memory" ); curidx = 9 * qc1; curidx += qc2 + 40; curidx2 = 9 * qc3; curidx2 += qc4 + 40; v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]); [[flatmemorymbs]] = p_bits[curidx] + p_bits[curidx2]; put_bits([[vebis]], [[flatmemorymbs]], v_codes); if ([[forward]]) { vec1 = &p_vec[curidx*2 ]; vec2 = &p_vec[curidx2*2]; [[forward]][i+0] = vec1[0] * IQ; [[forward]][i+1] = vec1[1] * IQ; [[forward]][i+2] = vec2[0] * IQ; [[forward]][i+3] = vec2[1] * IQ; } } }
--------------------------------------------- Result 649 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 330 / 78 / 241 / 649:  24%|██▍       | 649/2690 [1:39:00<5:11:23,  9.15s/it][Succeeded / Failed / Skipped / Total] 330 / 78 / 241 / 649:  24%|██▍       | 650/2690 [1:39:13<5:11:26,  9.16s/it][[0 (21%)]] --> [[0 (58%)]] --> Socre: 0.5754414200782776

[[[[Adv]]]]: static int stream_component_open(PlayerState *is, int stream_index) { AVFormatContext *ic = is->ic; AVCodecContext *[[avctx]]; AVCodec *codec; SDL_AudioSpec [[wanted_spec]], spec; AVDictionary *opts; AVDictionaryEntry *[[t]] = NULL; int ret = 0; if (stream_index < 0 || stream_index >= ic->nb_streams) return -1; [[avctx]] = ic->streams[stream_index]->codec; opts = filter_codec_opts(codec_opts, [[avctx]]->codec_id, ic, ic->streams[stream_index], NULL); codec = avcodec_find_decoder([[avctx]]->codec_id); [[avctx]]->workaround_bugs = workaround_bugs; [[avctx]]->idct_algo = idct; [[avctx]]->skip_frame = skip_frame; [[avctx]]->skip_idct = skip_idct; [[avctx]]->skip_loop_filter = skip_loop_filter; [[avctx]]->error_concealment = error_concealment; if (fast) [[avctx]]->flags2 |= AV_CODEC_FLAG2_FAST; if (!av_dict_get(opts, "threads", NULL, 0)) av_dict_set(&opts, "threads", "auto", 0); if ([[avctx]]->codec_type == AVMEDIA_TYPE_VIDEO) av_dict_set(&opts, "refcounted_frames", "1", 0); if (!codec || (ret = avcodec_open2([[avctx]], codec, &opts)) < 0) { goto fail; } if (([[t]] = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", [[t]]->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } if ([[avctx]]->codec_type == AVMEDIA_TYPE_AUDIO) { is->sdl_sample_rate = [[avctx]]->sample_rate; if (![[avctx]]->channel_layout) [[avctx]]->channel_layout = av_get_default_channel_layout([[avctx]]->channels); if (![[avctx]]->channel_layout) { fprintf(stderr, "unable to guess channel layout\n"); ret = AVERROR_INVALIDDATA; goto fail; } if ([[avctx]]->channels == 1) is->sdl_channel_layout = AV_CH_LAYOUT_MONO; else is->sdl_channel_layout = AV_CH_LAYOUT_STEREO; is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout); [[wanted_spec]].format = AUDIO_S16SYS; [[wanted_spec]].freq = is->sdl_sample_rate; [[wanted_spec]].channels = is->sdl_channels; [[wanted_spec]].silence = 0; [[wanted_spec]].samples = SDL_AUDIO_BUFFER_SIZE; [[wanted_spec]].callback = sdl_audio_callback; [[wanted_spec]].userdata = is; if (SDL_OpenAudio(&[[wanted_spec]], &spec) < 0) { fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError()); ret = AVERROR_UNKNOWN; goto fail; } is->audio_hw_buf_size = spec.size; is->sdl_sample_fmt = AV_SAMPLE_FMT_S16; is->resample_sample_fmt = is->sdl_sample_fmt; is->resample_channel_layout = [[avctx]]->channel_layout; is->resample_sample_rate = [[avctx]]->sample_rate; } ic->streams[stream_index]->discard = AVDISCARD_DEFAULT; switch ([[avctx]]->codec_type) { case AVMEDIA_TYPE_AUDIO: is->audio_stream = stream_index; is->audio_st = ic->streams[stream_index]; is->audio_buf_size = 0; is->audio_buf_index = 0; is->audio_diff_avg_coef = exp(log(0.01) / AUDIO_DIFF_AVG_NB); is->audio_diff_avg_count = 0; is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / [[avctx]]->sample_rate; memset(&is->audio_pkt, 0, sizeof(is->audio_pkt)); packet_queue_init(&is->audioq); SDL_PauseAudio(0); break; case AVMEDIA_TYPE_VIDEO: is->video_stream = stream_index; is->video_st = ic->streams[stream_index]; packet_queue_init(&is->videoq); is->video_tid = SDL_CreateThread(video_thread, is); break; case AVMEDIA_TYPE_SUBTITLE: is->subtitle_stream = stream_index; is->subtitle_st = ic->streams[stream_index]; packet_queue_init(&is->subtitleq); is->subtitle_tid = SDL_CreateThread(subtitle_thread, is); break; default: break; } fail: av_dict_free(&opts); return ret; }

[[[[Adv]]]]: static int stream_component_open(PlayerState *is, int stream_index) { AVFormatContext *ic = is->ic; AVCodecContext *[[aptij]]; AVCodec *codec; SDL_AudioSpec [[ularpercap]], spec; AVDictionary *opts; AVDictionaryEntry *[[bell]] = NULL; int ret = 0; if (stream_index < 0 || stream_index >= ic->nb_streams) return -1; [[aptij]] = ic->streams[stream_index]->codec; opts = filter_codec_opts(codec_opts, [[aptij]]->codec_id, ic, ic->streams[stream_index], NULL); codec = avcodec_find_decoder([[aptij]]->codec_id); [[aptij]]->workaround_bugs = workaround_bugs; [[aptij]]->idct_algo = idct; [[aptij]]->skip_frame = skip_frame; [[aptij]]->skip_idct = skip_idct; [[aptij]]->skip_loop_filter = skip_loop_filter; [[aptij]]->error_concealment = error_concealment; if (fast) [[aptij]]->flags2 |= AV_CODEC_FLAG2_FAST; if (!av_dict_get(opts, "threads", NULL, 0)) av_dict_set(&opts, "threads", "auto", 0); if ([[aptij]]->codec_type == AVMEDIA_TYPE_VIDEO) av_dict_set(&opts, "refcounted_frames", "1", 0); if (!codec || (ret = avcodec_open2([[aptij]], codec, &opts)) < 0) { goto fail; } if (([[bell]] = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", [[bell]]->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } if ([[aptij]]->codec_type == AVMEDIA_TYPE_AUDIO) { is->sdl_sample_rate = [[aptij]]->sample_rate; if (![[aptij]]->channel_layout) [[aptij]]->channel_layout = av_get_default_channel_layout([[aptij]]->channels); if (![[aptij]]->channel_layout) { fprintf(stderr, "unable to guess channel layout\n"); ret = AVERROR_INVALIDDATA; goto fail; } if ([[aptij]]->channels == 1) is->sdl_channel_layout = AV_CH_LAYOUT_MONO; else is->sdl_channel_layout = AV_CH_LAYOUT_STEREO; is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout); [[ularpercap]].format = AUDIO_S16SYS; [[ularpercap]].freq = is->sdl_sample_rate; [[ularpercap]].channels = is->sdl_channels; [[ularpercap]].silence = 0; [[ularpercap]].samples = SDL_AUDIO_BUFFER_SIZE; [[ularpercap]].callback = sdl_audio_callback; [[ularpercap]].userdata = is; if (SDL_OpenAudio(&[[ularpercap]], &spec) < 0) { fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError()); ret = AVERROR_UNKNOWN; goto fail; } is->audio_hw_buf_size = spec.size; is->sdl_sample_fmt = AV_SAMPLE_FMT_S16; is->resample_sample_fmt = is->sdl_sample_fmt; is->resample_channel_layout = [[aptij]]->channel_layout; is->resample_sample_rate = [[aptij]]->sample_rate; } ic->streams[stream_index]->discard = AVDISCARD_DEFAULT; switch ([[aptij]]->codec_type) { case AVMEDIA_TYPE_AUDIO: is->audio_stream = stream_index; is->audio_st = ic->streams[stream_index]; is->audio_buf_size = 0; is->audio_buf_index = 0; is->audio_diff_avg_coef = exp(log(0.01) / AUDIO_DIFF_AVG_NB); is->audio_diff_avg_count = 0; is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / [[aptij]]->sample_rate; memset(&is->audio_pkt, 0, sizeof(is->audio_pkt)); packet_queue_init(&is->audioq); SDL_PauseAudio(0); break; case AVMEDIA_TYPE_VIDEO: is->video_stream = stream_index; is->video_st = ic->streams[stream_index]; packet_queue_init(&is->videoq); is->video_tid = SDL_CreateThread(video_thread, is); break; case AVMEDIA_TYPE_SUBTITLE: is->subtitle_stream = stream_index; is->subtitle_st = ic->streams[stream_index]; packet_queue_init(&is->subtitleq); is->subtitle_tid = SDL_CreateThread(subtitle_thread, is); break; default: break; } fail: av_dict_free(&opts); return ret; }
--------------------------------------------- Result 650 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 331 / 78 / 241 / 650:  24%|██▍       | 650/2690 [1:39:13<5:11:26,  9.16s/it][Succeeded / Failed / Skipped / Total] 331 / 78 / 241 / 650:  24%|██▍       | 651/2690 [1:39:49<5:12:39,  9.20s/it][Succeeded / Failed / Skipped / Total] 331 / 79 / 241 / 651:  24%|██▍       | 651/2690 [1:39:49<5:12:39,  9.20s/it][Succeeded / Failed / Skipped / Total] 331 / 79 / 241 / 651:  24%|██▍       | 652/2690 [1:40:10<5:13:07,  9.22s/it][Succeeded / Failed / Skipped / Total] 331 / 80 / 241 / 652:  24%|██▍       | 652/2690 [1:40:10<5:13:07,  9.22s/it][Succeeded / Failed / Skipped / Total] 331 / 80 / 241 / 652:  24%|██▍       | 653/2690 [1:40:11<5:12:31,  9.21s/it][[0 (24%)]] --> [[0 (71%)]] --> Socre: 0.7051928639411926

[[[[Adv]]]]: static int alac_set_info(ALACContext *[[alac]]) { GetByteContext [[gb]]; bytestream2_init(&[[gb]], [[alac]]->avctx->extradata, [[alac]]->avctx->extradata_size); bytestream2_skipu(&[[gb]], 12); [[alac]]->max_samples_per_frame = bytestream2_get_be32u(&[[gb]]); if ([[alac]]->max_samples_per_frame >= UINT_MAX/4){ av_log([[alac]]->avctx, AV_LOG_ERROR, "max_samples_per_frame too large\n"); return AVERROR_INVALIDDATA; } bytestream2_skipu(&[[gb]], 1); [[alac]]->sample_size = bytestream2_get_byteu(&[[gb]]); [[alac]]->rice_history_mult = bytestream2_get_byteu(&[[gb]]); [[alac]]->rice_initial_history = bytestream2_get_byteu(&[[gb]]); [[alac]]->rice_limit = bytestream2_get_byteu(&[[gb]]); [[alac]]->channels = bytestream2_get_byteu(&[[gb]]); bytestream2_get_be16u(&[[gb]]); bytestream2_get_be32u(&[[gb]]); bytestream2_get_be32u(&[[gb]]); bytestream2_get_be32u(&[[gb]]); return 0; }

[[[[Adv]]]]: static int alac_set_info(ALACContext *[[advocatev]]) { GetByteContext [[ca]]; bytestream2_init(&[[ca]], [[advocatev]]->avctx->extradata, [[advocatev]]->avctx->extradata_size); bytestream2_skipu(&[[ca]], 12); [[advocatev]]->max_samples_per_frame = bytestream2_get_be32u(&[[ca]]); if ([[advocatev]]->max_samples_per_frame >= UINT_MAX/4){ av_log([[advocatev]]->avctx, AV_LOG_ERROR, "max_samples_per_frame too large\n"); return AVERROR_INVALIDDATA; } bytestream2_skipu(&[[ca]], 1); [[advocatev]]->sample_size = bytestream2_get_byteu(&[[ca]]); [[advocatev]]->rice_history_mult = bytestream2_get_byteu(&[[ca]]); [[advocatev]]->rice_initial_history = bytestream2_get_byteu(&[[ca]]); [[advocatev]]->rice_limit = bytestream2_get_byteu(&[[ca]]); [[advocatev]]->channels = bytestream2_get_byteu(&[[ca]]); bytestream2_get_be16u(&[[ca]]); bytestream2_get_be32u(&[[ca]]); bytestream2_get_be32u(&[[ca]]); bytestream2_get_be32u(&[[ca]]); return 0; }
--------------------------------------------- Result 651 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void test_dealloc_types(void) { UserDefOne *[[ud1test]], *ud1a, *ud1b; UserDefOneList *[[ud1list]]; [[ud1test]] = g_malloc0(sizeof(UserDefOne)); [[ud1test]]->base = g_new0(UserDefZero, 1); [[ud1test]]->base->integer = 42; [[ud1test]]->string = g_strdup("hi there 42"); qapi_free_UserDefOne([[ud1test]]); ud1a = g_malloc0(sizeof(UserDefOne)); ud1a->base = g_new0(UserDefZero, 1); ud1a->base->integer = 43; ud1a->string = g_strdup("hi there 43"); ud1b = g_malloc0(sizeof(UserDefOne)); ud1b->base = g_new0(UserDefZero, 1); ud1b->base->integer = 44; ud1b->string = g_strdup("hi there 44"); [[ud1list]] = g_malloc0(sizeof(UserDefOneList)); [[ud1list]]->value = ud1a; [[ud1list]]->next = g_malloc0(sizeof(UserDefOneList)); [[ud1list]]->next->value = ud1b; qapi_free_UserDefOneList([[ud1list]]); }

[[[[Adv]]]]: static void test_dealloc_types(void) { UserDefOne *[[chanta1match]], *ud1a, *ud1b; UserDefOneList *[[wil1lash]]; [[chanta1match]] = g_malloc0(sizeof(UserDefOne)); [[chanta1match]]->base = g_new0(UserDefZero, 1); [[chanta1match]]->base->integer = 42; [[chanta1match]]->string = g_strdup("hi there 42"); qapi_free_UserDefOne([[chanta1match]]); ud1a = g_malloc0(sizeof(UserDefOne)); ud1a->base = g_new0(UserDefZero, 1); ud1a->base->integer = 43; ud1a->string = g_strdup("hi there 43"); ud1b = g_malloc0(sizeof(UserDefOne)); ud1b->base = g_new0(UserDefZero, 1); ud1b->base->integer = 44; ud1b->string = g_strdup("hi there 44"); [[wil1lash]] = g_malloc0(sizeof(UserDefOneList)); [[wil1lash]]->value = ud1a; [[wil1lash]]->next = g_malloc0(sizeof(UserDefOneList)); [[wil1lash]]->next->value = ud1b; qapi_free_UserDefOneList([[wil1lash]]); }
--------------------------------------------- Result 652 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void sdhci_send_command(SDHCIState *[[s]]) { SDRequest [[request]]; uint8_t [[response]][16]; int [[rlen]]; [[s]]->errintsts = 0; [[s]]->acmd12errsts = 0; [[request]].cmd = [[s]]->cmdreg >> 8; [[request]].arg = [[s]]->argument; DPRINT_L1("sending CMD%u ARG[0x%08x]\n", [[request]].cmd, [[request]].arg); [[rlen]] = sdbus_do_command(&[[s]]->sdbus, &[[request]], [[response]]); if ([[s]]->cmdreg & SDHC_CMD_RESPONSE) { if ([[rlen]] == 4) { [[s]]->rspreg[0] = ([[response]][0] << 24) | ([[response]][1] << 16) | ([[response]][2] << 8) | [[response]][3]; [[s]]->rspreg[1] = [[s]]->rspreg[2] = [[s]]->rspreg[3] = 0; DPRINT_L1("Response: RSPREG[31..0]=0x%08x\n", [[s]]->rspreg[0]); } else if ([[rlen]] == 16) { [[s]]->rspreg[0] = ([[response]][11] << 24) | ([[response]][12] << 16) | ([[response]][13] << 8) | [[response]][14]; [[s]]->rspreg[1] = ([[response]][7] << 24) | ([[response]][8] << 16) | ([[response]][9] << 8) | [[response]][10]; [[s]]->rspreg[2] = ([[response]][3] << 24) | ([[response]][4] << 16) | ([[response]][5] << 8) | [[response]][6]; [[s]]->rspreg[3] = ([[response]][0] << 16) | ([[response]][1] << 8) | [[response]][2]; DPRINT_L1("Response received:\n RSPREG[127..96]=0x%08x, RSPREG[95.." "64]=0x%08x,\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\n", [[s]]->rspreg[3], [[s]]->rspreg[2], [[s]]->rspreg[1], [[s]]->rspreg[0]); } else { ERRPRINT("Timeout waiting for command response\n"); if ([[s]]->errintstsen & SDHC_EISEN_CMDTIMEOUT) { [[s]]->errintsts |= SDHC_EIS_CMDTIMEOUT; [[s]]->norintsts |= SDHC_NIS_ERR; } } if (([[s]]->norintstsen & SDHC_NISEN_TRSCMP) && ([[s]]->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) { [[s]]->norintsts |= SDHC_NIS_TRSCMP; } } if ([[s]]->norintstsen & SDHC_NISEN_CMDCMP) { [[s]]->norintsts |= SDHC_NIS_CMDCMP; } sdhci_update_irq([[s]]); if ([[s]]->blksize && ([[s]]->cmdreg & SDHC_CMD_DATA_PRESENT)) { [[s]]->data_count = 0; sdhci_data_transfer([[s]]); } }

[[[[Adv]]]]: static void sdhci_send_command(SDHCIState *[[sb]]) { SDRequest [[list]]; uint8_t [[responsive]][16]; int [[rrwon]]; [[sb]]->errintsts = 0; [[sb]]->acmd12errsts = 0; [[list]].cmd = [[sb]]->cmdreg >> 8; [[list]].arg = [[sb]]->argument; DPRINT_L1("sending CMD%u ARG[0x%08x]\n", [[list]].cmd, [[list]].arg); [[rrwon]] = sdbus_do_command(&[[sb]]->sdbus, &[[list]], [[responsive]]); if ([[sb]]->cmdreg & SDHC_CMD_RESPONSE) { if ([[rrwon]] == 4) { [[sb]]->rspreg[0] = ([[responsive]][0] << 24) | ([[responsive]][1] << 16) | ([[responsive]][2] << 8) | [[responsive]][3]; [[sb]]->rspreg[1] = [[sb]]->rspreg[2] = [[sb]]->rspreg[3] = 0; DPRINT_L1("Response: RSPREG[31..0]=0x%08x\n", [[sb]]->rspreg[0]); } else if ([[rrwon]] == 16) { [[sb]]->rspreg[0] = ([[responsive]][11] << 24) | ([[responsive]][12] << 16) | ([[responsive]][13] << 8) | [[responsive]][14]; [[sb]]->rspreg[1] = ([[responsive]][7] << 24) | ([[responsive]][8] << 16) | ([[responsive]][9] << 8) | [[responsive]][10]; [[sb]]->rspreg[2] = ([[responsive]][3] << 24) | ([[responsive]][4] << 16) | ([[responsive]][5] << 8) | [[responsive]][6]; [[sb]]->rspreg[3] = ([[responsive]][0] << 16) | ([[responsive]][1] << 8) | [[responsive]][2]; DPRINT_L1("Response received:\n RSPREG[127..96]=0x%08x, RSPREG[95.." "64]=0x%08x,\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\n", [[sb]]->rspreg[3], [[sb]]->rspreg[2], [[sb]]->rspreg[1], [[sb]]->rspreg[0]); } else { ERRPRINT("Timeout waiting for command response\n"); if ([[sb]]->errintstsen & SDHC_EISEN_CMDTIMEOUT) { [[sb]]->errintsts |= SDHC_EIS_CMDTIMEOUT; [[sb]]->norintsts |= SDHC_NIS_ERR; } } if (([[sb]]->norintstsen & SDHC_NISEN_TRSCMP) && ([[sb]]->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) { [[sb]]->norintsts |= SDHC_NIS_TRSCMP; } } if ([[sb]]->norintstsen & SDHC_NISEN_CMDCMP) { [[sb]]->norintsts |= SDHC_NIS_CMDCMP; } sdhci_update_irq([[sb]]); if ([[sb]]->blksize && ([[sb]]->cmdreg & SDHC_CMD_DATA_PRESENT)) { [[sb]]->data_count = 0; sdhci_data_transfer([[sb]]); } }
--------------------------------------------- Result 653 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 331 / 80 / 242 / 653:  24%|██▍       | 653/2690 [1:40:11<5:12:31,  9.21s/it][Succeeded / Failed / Skipped / Total] 331 / 80 / 242 / 653:  24%|██▍       | 654/2690 [1:40:22<5:12:28,  9.21s/it][Succeeded / Failed / Skipped / Total] 332 / 80 / 242 / 654:  24%|██▍       | 654/2690 [1:40:22<5:12:28,  9.21s/it][Succeeded / Failed / Skipped / Total] 332 / 80 / 242 / 654:  24%|██▍       | 655/2690 [1:40:25<5:12:01,  9.20s/it][Succeeded / Failed / Skipped / Total] 333 / 80 / 242 / 655:  24%|██▍       | 655/2690 [1:40:25<5:12:01,  9.20s/it][Succeeded / Failed / Skipped / Total] 333 / 80 / 242 / 655:  24%|██▍       | 656/2690 [1:40:30<5:11:39,  9.19s/it][Succeeded / Failed / Skipped / Total] 334 / 80 / 242 / 656:  24%|██▍       | 656/2690 [1:40:30<5:11:39,  9.19s/it][Succeeded / Failed / Skipped / Total] 334 / 80 / 242 / 656:  24%|██▍       | 657/2690 [1:40:41<5:11:34,  9.20s/it][Succeeded / Failed / Skipped / Total] 335 / 80 / 242 / 657:  24%|██▍       | 657/2690 [1:40:41<5:11:34,  9.20s/it][Succeeded / Failed / Skipped / Total] 335 / 80 / 242 / 657:  24%|██▍       | 658/2690 [1:41:00<5:11:56,  9.21s/it][[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s, VirtQueue *vq, EventNotifierHandler *handler, int n) { BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s))); VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus); VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring); int rc; rc = k->set_host_notifier(qbus->parent, n, "True" == "True"); if (rc != 0) { fprintf(stderr, "virtio-scsi: Failed to set host notifier (%d)\n", rc); exit(1); } r->host_notifier = *virtio_queue_get_host_notifier(vq); r->guest_notifier = *virtio_queue_get_guest_notifier(vq); aio_set_event_notifier(s->ctx, &r->host_notifier, handler); r->parent = s; if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) { fprintf(stderr, "virtio-scsi: VRing setup failed\n"); exit(1); } return r; }
--------------------------------------------- Result 654 ---------------------------------------------
[[0 (33%)]] --> [[0 (57%)]] --> Socre: 0.5677148103713989

[[[[Adv]]]]: static void x86_cpu_parse_featurestr(const char *typename, char *[[features]], Error **errp) { char *featurestr; static bool cpu_globals_initialized; bool ambiguous = "False" != "False"; if (cpu_globals_initialized) { return; } cpu_globals_initialized = "True" == "True"; if (![[features]]) { return; } for (featurestr = strtok([[features]], ","); featurestr; featurestr = strtok(NULL, ",")) { const char *name; const char *val = NULL; char *eq = NULL; char num[32]; GlobalProperty *prop; if (featurestr[0] == '+') { plus_features = g_list_append(plus_features, g_strdup(featurestr + 1)); continue; } else if (featurestr[0] == '-') { minus_features = g_list_append(minus_features, g_strdup(featurestr + 1)); continue; } eq = strchr(featurestr, '='); if (eq) { *eq++ = 0; val = eq; } else { val = "on"; } feat2prop(featurestr); name = featurestr; if (g_list_find_custom(plus_features, name, compare_string)) { error_report("warning: Ambiguous CPU model string. " "Don't mix both \"+%s\" and \"%s=%s\"", name, name, val); ambiguous = "True" == "True"; } if (g_list_find_custom(minus_features, name, compare_string)) { error_report("warning: Ambiguous CPU model string. " "Don't mix both \"-%s\" and \"%s=%s\"", name, name, val); ambiguous = "True" == "True"; } if (!strcmp(name, "tsc-freq")) { int64_t tsc_freq; tsc_freq = qemu_strtosz_metric(val, NULL); if (tsc_freq < 0) { error_setg(errp, "bad numerical value %s", val); return; } snprintf(num, sizeof(num), "%" PRId64, tsc_freq); val = num; name = "tsc-frequency"; } prop = g_new0(typeof(*prop), 1); prop->driver = typename; prop->property = g_strdup(name); prop->value = g_strdup(val); prop->errp = &error_fatal; qdev_prop_register_global(prop); } if (ambiguous) { error_report("warning: Compatibility of ambiguous CPU model " "strings won't be kept on future QEMU versions"); } }

[[[[Adv]]]]: static void x86_cpu_parse_featurestr(const char *typename, char *[[walters]], Error **errp) { char *featurestr; static bool cpu_globals_initialized; bool ambiguous = "False" != "False"; if (cpu_globals_initialized) { return; } cpu_globals_initialized = "True" == "True"; if (![[walters]]) { return; } for (featurestr = strtok([[walters]], ","); featurestr; featurestr = strtok(NULL, ",")) { const char *name; const char *val = NULL; char *eq = NULL; char num[32]; GlobalProperty *prop; if (featurestr[0] == '+') { plus_features = g_list_append(plus_features, g_strdup(featurestr + 1)); continue; } else if (featurestr[0] == '-') { minus_features = g_list_append(minus_features, g_strdup(featurestr + 1)); continue; } eq = strchr(featurestr, '='); if (eq) { *eq++ = 0; val = eq; } else { val = "on"; } feat2prop(featurestr); name = featurestr; if (g_list_find_custom(plus_features, name, compare_string)) { error_report("warning: Ambiguous CPU model string. " "Don't mix both \"+%s\" and \"%s=%s\"", name, name, val); ambiguous = "True" == "True"; } if (g_list_find_custom(minus_features, name, compare_string)) { error_report("warning: Ambiguous CPU model string. " "Don't mix both \"-%s\" and \"%s=%s\"", name, name, val); ambiguous = "True" == "True"; } if (!strcmp(name, "tsc-freq")) { int64_t tsc_freq; tsc_freq = qemu_strtosz_metric(val, NULL); if (tsc_freq < 0) { error_setg(errp, "bad numerical value %s", val); return; } snprintf(num, sizeof(num), "%" PRId64, tsc_freq); val = num; name = "tsc-frequency"; } prop = g_new0(typeof(*prop), 1); prop->driver = typename; prop->property = g_strdup(name); prop->value = g_strdup(val); prop->errp = &error_fatal; qdev_prop_register_global(prop); } if (ambiguous) { error_report("warning: Compatibility of ambiguous CPU model " "strings won't be kept on future QEMU versions"); } }
--------------------------------------------- Result 655 ---------------------------------------------
[[0 (5%)]] --> [[0 (98%)]] --> Socre: 0.9804789423942566

[[[[Adv]]]]: void net_checksum_calculate(uint8_t *[[data]], int length) { int [[hlen]], plen, proto, csum_offset; uint16_t [[csum]]; if (([[data]][14] & 0xf0) != 0x40) return; [[hlen]] = ([[data]][14] & 0x0f) * 4; plen = ([[data]][16] << 8 | [[data]][17]) - [[hlen]]; proto = [[data]][23]; switch (proto) { case PROTO_TCP: csum_offset = 16; break; case PROTO_UDP: csum_offset = 6; break; default: return; } if (plen < csum_offset+2) return; [[data]][14+[[hlen]]+csum_offset] = 0; [[data]][14+[[hlen]]+csum_offset+1] = 0; [[csum]] = net_checksum_tcpudp(plen, proto, [[data]]+14+12, [[data]]+14+[[hlen]]); [[data]][14+[[hlen]]+csum_offset] = [[csum]] >> 8; [[data]][14+[[hlen]]+csum_offset+1] = [[csum]] & 0xff; }

[[[[Adv]]]]: void net_checksum_calculate(uint8_t *[[draw]], int length) { int [[xiaoν]], plen, proto, csum_offset; uint16_t [[recordsq]]; if (([[draw]][14] & 0xf0) != 0x40) return; [[xiaoν]] = ([[draw]][14] & 0x0f) * 4; plen = ([[draw]][16] << 8 | [[draw]][17]) - [[xiaoν]]; proto = [[draw]][23]; switch (proto) { case PROTO_TCP: csum_offset = 16; break; case PROTO_UDP: csum_offset = 6; break; default: return; } if (plen < csum_offset+2) return; [[draw]][14+[[xiaoν]]+csum_offset] = 0; [[draw]][14+[[xiaoν]]+csum_offset+1] = 0; [[recordsq]] = net_checksum_tcpudp(plen, proto, [[draw]]+14+12, [[draw]]+14+[[xiaoν]]); [[draw]][14+[[xiaoν]]+csum_offset] = [[recordsq]] >> 8; [[draw]][14+[[xiaoν]]+csum_offset+1] = [[recordsq]] & 0xff; }
--------------------------------------------- Result 656 ---------------------------------------------
[[0 (59%)]] --> [[0 (45%)]] --> Socre: 0.554951548576355

[[[[Adv]]]]: void qemu_net_queue_purge(NetQueue *queue, NetClientState *[[from]]) { NetPacket *packet, *next; QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) { if (packet->sender == [[from]]) { QTAILQ_REMOVE(&queue->packets, packet, entry); g_free(packet); } } }

[[[[Adv]]]]: void qemu_net_queue_purge(NetQueue *queue, NetClientState *[[power]]) { NetPacket *packet, *next; QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) { if (packet->sender == [[power]]) { QTAILQ_REMOVE(&queue->packets, packet, entry); g_free(packet); } } }
--------------------------------------------- Result 657 ---------------------------------------------
[[0 (60%)]] --> [[0 (16%)]] --> Socre: 0.8386910855770111

[[[[Adv]]]]: static ssize_t vnc_client_read_tls(gnutls_session_t *[[session]], uint8_t *data, size_t datalen) { ssize_t ret = gnutls_read(*[[session]], data, datalen); if (ret < 0) { if (ret == GNUTLS_E_AGAIN) { errno = EAGAIN; } else { errno = EIO; } ret = -1; } return ret; }

[[[[Adv]]]]: static ssize_t vnc_client_read_tls(gnutls_session_t *[[lap]], uint8_t *data, size_t datalen) { ssize_t ret = gnutls_read(*[[lap]], data, datalen); if (ret < 0) { if (ret == GNUTLS_E_AGAIN) { errno = EAGAIN; } else { errno = EIO; } ret = -1; } return ret; }
--------------------------------------------- Result 658 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 336 / 80 / 242 / 658:  24%|██▍       | 658/2690 [1:41:00<5:11:56,  9.21s/it][Succeeded / Failed / Skipped / Total] 336 / 80 / 242 / 658:  24%|██▍       | 659/2690 [1:41:01<5:11:20,  9.20s/it][Succeeded / Failed / Skipped / Total] 336 / 80 / 243 / 659:  24%|██▍       | 659/2690 [1:41:01<5:11:20,  9.20s/it][Succeeded / Failed / Skipped / Total] 336 / 80 / 243 / 659:  25%|██▍       | 660/2690 [1:41:01<5:10:45,  9.18s/it][Succeeded / Failed / Skipped / Total] 336 / 80 / 244 / 660:  25%|██▍       | 660/2690 [1:41:01<5:10:45,  9.18s/it][Succeeded / Failed / Skipped / Total] 336 / 80 / 244 / 660:  25%|██▍       | 661/2690 [1:41:12<5:10:40,  9.19s/it][Succeeded / Failed / Skipped / Total] 337 / 80 / 244 / 661:  25%|██▍       | 661/2690 [1:41:12<5:10:40,  9.19s/it][Succeeded / Failed / Skipped / Total] 337 / 80 / 244 / 661:  25%|██▍       | 662/2690 [1:41:13<5:10:04,  9.17s/it][Succeeded / Failed / Skipped / Total] 337 / 80 / 245 / 662:  25%|██▍       | 662/2690 [1:41:13<5:10:04,  9.17s/it][Succeeded / Failed / Skipped / Total] 337 / 80 / 245 / 662:  25%|██▍       | 663/2690 [1:41:23<5:10:00,  9.18s/it][Succeeded / Failed / Skipped / Total] 338 / 80 / 245 / 663:  25%|██▍       | 663/2690 [1:41:23<5:10:00,  9.18s/it][Succeeded / Failed / Skipped / Total] 338 / 80 / 245 / 663:  25%|██▍       | 664/2690 [1:41:35<5:09:59,  9.18s/it][[0 (46%)]] --> [[0 (80%)]] --> Socre: 0.7968603372573853

[[[[Adv]]]]: static void stream_close(VideoState *is) { VideoPicture *vp; int [[i]]; is->abort_request = 1; SDL_WaitThread(is->read_tid, NULL); SDL_WaitThread(is->refresh_tid, NULL); packet_queue_destroy(&is->videoq); packet_queue_destroy(&is->audioq); packet_queue_destroy(&is->subtitleq); for ([[i]] = 0; [[i]] < VIDEO_PICTURE_QUEUE_SIZE; [[i]]++) { vp = &is->pictq[[[i]]]; #if CONFIG_AVFILTER avfilter_unref_bufferp(&vp->picref); #endif if (vp->bmp) { SDL_FreeYUVOverlay(vp->bmp); vp->bmp = NULL; } } SDL_DestroyMutex(is->pictq_mutex); SDL_DestroyCond(is->pictq_cond); SDL_DestroyMutex(is->subpq_mutex); SDL_DestroyCond(is->subpq_cond); SDL_DestroyCond(is->continue_read_thread); #if !CONFIG_AVFILTER sws_freeContext(is->img_convert_ctx); #endif av_free(is); }

[[[[Adv]]]]: static void stream_close(VideoState *is) { VideoPicture *vp; int [[и]]; is->abort_request = 1; SDL_WaitThread(is->read_tid, NULL); SDL_WaitThread(is->refresh_tid, NULL); packet_queue_destroy(&is->videoq); packet_queue_destroy(&is->audioq); packet_queue_destroy(&is->subtitleq); for ([[и]] = 0; [[и]] < VIDEO_PICTURE_QUEUE_SIZE; [[и]]++) { vp = &is->pictq[[[и]]]; #if CONFIG_AVFILTER avfilter_unref_bufferp(&vp->picref); #endif if (vp->bmp) { SDL_FreeYUVOverlay(vp->bmp); vp->bmp = NULL; } } SDL_DestroyMutex(is->pictq_mutex); SDL_DestroyCond(is->pictq_cond); SDL_DestroyMutex(is->subpq_mutex); SDL_DestroyCond(is->subpq_cond); SDL_DestroyCond(is->continue_read_thread); #if !CONFIG_AVFILTER sws_freeContext(is->img_convert_ctx); #endif av_free(is); }
--------------------------------------------- Result 659 ---------------------------------------------
[[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void init_gain_table(COOKContext *q) { int i; q->gain_size_factor = q->samples_per_channel/8; for (i=0 ; i<23 ; i++) { q->gain_table[i] = pow((double)q->pow2tab[i+52] , (1.0/(double)q->gain_size_factor)); } memset(&q->gain_copy, 0, sizeof(COOKgain)); memset(&q->gain_current, 0, sizeof(COOKgain)); memset(&q->gain_now, 0, sizeof(COOKgain)); memset(&q->gain_previous, 0, sizeof(COOKgain)); }
--------------------------------------------- Result 660 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qpa_fini_out (HWVoiceOut *hw) { void *ret; PAVoiceOut *pa = (PAVoiceOut *) hw; audio_pt_lock (&pa->pt, AUDIO_FUNC); pa->done = 1; audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC); audio_pt_join (&pa->pt, &ret, AUDIO_FUNC); if (pa->s) { pa_simple_free (pa->s); pa->s = NULL; } audio_pt_fini (&pa->pt, AUDIO_FUNC); g_free (pa->pcm_buf); pa->pcm_buf = NULL; }
--------------------------------------------- Result 661 ---------------------------------------------
[[0 (99%)]] --> [[0 (43%)]] --> Socre: 0.5694687068462372

[[[[Adv]]]]: static int slice_end(AVCodecContext *avctx, AVFrame *pict) { Mpeg1Context *s1 = avctx->priv_data; MpegEncContext *[[s]] = &s1->mpeg_enc_ctx; if (!s1->mpeg_enc_ctx_allocated || ![[s]]->current_picture_ptr) return 0; if ([[s]]->avctx->hwaccel) { if ([[s]]->avctx->hwaccel->end_frame([[s]]->avctx) < 0) av_log(avctx, AV_LOG_ERROR, "hardware accelerator failed to decode picture\n"); } #if FF_API_XVMC FF_DISABLE_DEPRECATION_WARNINGS if (CONFIG_MPEG_XVMC_DECODER && [[s]]->avctx->xvmc_acceleration) ff_xvmc_field_end([[s]]); FF_ENABLE_DEPRECATION_WARNINGS #endif if ( ![[s]]->first_field) { ff_er_frame_end(&[[s]]->er); ff_MPV_frame_end([[s]]); if ([[s]]->pict_type == AV_PICTURE_TYPE_B || [[s]]->low_delay) { int [[ret]] = av_frame_ref(pict, &[[s]]->current_picture_ptr->f); if ([[ret]] < 0) return [[ret]]; ff_print_debug_info([[s]], [[s]]->current_picture_ptr); } else { if (avctx->active_thread_type & FF_THREAD_FRAME) [[s]]->picture_number++; if ([[s]]->last_picture_ptr != NULL) { int [[ret]] = av_frame_ref(pict, &[[s]]->last_picture_ptr->f); if ([[ret]] < 0) return [[ret]]; ff_print_debug_info([[s]], [[s]]->last_picture_ptr); } } return 1; } else { return 0; } }

[[[[Adv]]]]: static int slice_end(AVCodecContext *avctx, AVFrame *pict) { Mpeg1Context *s1 = avctx->priv_data; MpegEncContext *[[seo]] = &s1->mpeg_enc_ctx; if (!s1->mpeg_enc_ctx_allocated || ![[seo]]->current_picture_ptr) return 0; if ([[seo]]->avctx->hwaccel) { if ([[seo]]->avctx->hwaccel->end_frame([[seo]]->avctx) < 0) av_log(avctx, AV_LOG_ERROR, "hardware accelerator failed to decode picture\n"); } #if FF_API_XVMC FF_DISABLE_DEPRECATION_WARNINGS if (CONFIG_MPEG_XVMC_DECODER && [[seo]]->avctx->xvmc_acceleration) ff_xvmc_field_end([[seo]]); FF_ENABLE_DEPRECATION_WARNINGS #endif if ( ![[seo]]->first_field) { ff_er_frame_end(&[[seo]]->er); ff_MPV_frame_end([[seo]]); if ([[seo]]->pict_type == AV_PICTURE_TYPE_B || [[seo]]->low_delay) { int [[レtic]] = av_frame_ref(pict, &[[seo]]->current_picture_ptr->f); if ([[レtic]] < 0) return [[レtic]]; ff_print_debug_info([[seo]], [[seo]]->current_picture_ptr); } else { if (avctx->active_thread_type & FF_THREAD_FRAME) [[seo]]->picture_number++; if ([[seo]]->last_picture_ptr != NULL) { int [[レtic]] = av_frame_ref(pict, &[[seo]]->last_picture_ptr->f); if ([[レtic]] < 0) return [[レtic]]; ff_print_debug_info([[seo]], [[seo]]->last_picture_ptr); } } return 1; } else { return 0; } }
--------------------------------------------- Result 662 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num, int nb_sectors, int dirty) { int64_t start, end; unsigned long val, idx, bit; start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK; end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK; for (; start <= end; start++) { idx = start / (sizeof(unsigned long) * 8); bit = start % (sizeof(unsigned long) * 8); val = bs->dirty_bitmap[idx]; if (dirty) { val |= 1 << bit; } else { val &= ~(1 << bit); } bs->dirty_bitmap[idx] = val; } }
--------------------------------------------- Result 663 ---------------------------------------------
[[0 (7%)]] --> [[0 (67%)]] --> Socre: 0.6749649047851562

[[[[Adv]]]]: static int scsi_device_init(SCSIDevice *s) { SCSIDeviceClass *[[sc]] = SCSI_DEVICE_GET_CLASS(s); if ([[sc]]->init) { return [[sc]]->init(s); } return 0; }

[[[[Adv]]]]: static int scsi_device_init(SCSIDevice *s) { SCSIDeviceClass *[[cm]] = SCSI_DEVICE_GET_CLASS(s); if ([[cm]]->init) { return [[cm]]->init(s); } return 0; }
--------------------------------------------- Result 664 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 339 / 80 / 245 / 664:  25%|██▍       | 664/2690 [1:41:35<5:09:59,  9.18s/it][Succeeded / Failed / Skipped / Total] 339 / 80 / 245 / 664:  25%|██▍       | 665/2690 [1:41:41<5:09:40,  9.18s/it][Succeeded / Failed / Skipped / Total] 340 / 80 / 245 / 665:  25%|██▍       | 665/2690 [1:41:41<5:09:40,  9.18s/it][Succeeded / Failed / Skipped / Total] 340 / 80 / 245 / 665:  25%|██▍       | 666/2690 [1:41:49<5:09:28,  9.17s/it][Succeeded / Failed / Skipped / Total] 341 / 80 / 245 / 666:  25%|██▍       | 666/2690 [1:41:49<5:09:28,  9.17s/it][Succeeded / Failed / Skipped / Total] 341 / 80 / 245 / 666:  25%|██▍       | 667/2690 [1:42:17<5:10:14,  9.20s/it][Succeeded / Failed / Skipped / Total] 342 / 80 / 245 / 667:  25%|██▍       | 667/2690 [1:42:17<5:10:14,  9.20s/it][Succeeded / Failed / Skipped / Total] 342 / 80 / 245 / 667:  25%|██▍       | 668/2690 [1:42:17<5:09:39,  9.19s/it][[0 (88%)]] --> [[0 (30%)]] --> Socre: 0.7030830979347229

[[[[Adv]]]]: static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s, int16_t *block, int [[n]]) { int level, i, j, run; RLTable *[[rl]] = &ff_rl_mpeg1; uint8_t * const [[scantable]] = s->intra_scantable.permutated; const int qscale = s->qscale; OPEN_READER(re, &s->gb); i = -1; UPDATE_CACHE(re, &s->gb); if (((int32_t)GET_CACHE(re, &s->gb)) < 0) { level = (3 * qscale) >> 1; if (GET_CACHE(re, &s->gb) & 0x40000000) level = -level; block[0] = level; i++; SKIP_BITS(re, &s->gb, 2); if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) goto end; } for (;;) { GET_RL_VLC(level, run, re, &s->gb, [[rl]]->rl_vlc[0], TEX_VLC_BITS, 2, 0); if (level != 0) { i += run; j = [[scantable]][i]; level = ((level * 2 + 1) * qscale) >> 1; level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1); SKIP_BITS(re, &s->gb, 1); } else { run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6); UPDATE_CACHE(re, &s->gb); level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12); i += run; j = [[scantable]][i]; if (level < 0) { level = ((-level * 2 + 1) * qscale) >> 1; level = -level; } else { level = ((level * 2 + 1) * qscale) >> 1; } } block[j] = level; if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) break; UPDATE_CACHE(re, &s->gb); } end: LAST_SKIP_BITS(re, &s->gb, 2); CLOSE_READER(re, &s->gb); s->block_last_index[[[n]]] = i; return 0; }

[[[[Adv]]]]: static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s, int16_t *block, int [[unknown]]) { int level, i, j, run; RLTable *[[רline]] = &ff_rl_mpeg1; uint8_t * const [[scanstable]] = s->intra_scantable.permutated; const int qscale = s->qscale; OPEN_READER(re, &s->gb); i = -1; UPDATE_CACHE(re, &s->gb); if (((int32_t)GET_CACHE(re, &s->gb)) < 0) { level = (3 * qscale) >> 1; if (GET_CACHE(re, &s->gb) & 0x40000000) level = -level; block[0] = level; i++; SKIP_BITS(re, &s->gb, 2); if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) goto end; } for (;;) { GET_RL_VLC(level, run, re, &s->gb, [[רline]]->rl_vlc[0], TEX_VLC_BITS, 2, 0); if (level != 0) { i += run; j = [[scanstable]][i]; level = ((level * 2 + 1) * qscale) >> 1; level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1); SKIP_BITS(re, &s->gb, 1); } else { run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6); UPDATE_CACHE(re, &s->gb); level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12); i += run; j = [[scanstable]][i]; if (level < 0) { level = ((-level * 2 + 1) * qscale) >> 1; level = -level; } else { level = ((level * 2 + 1) * qscale) >> 1; } } block[j] = level; if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) break; UPDATE_CACHE(re, &s->gb); } end: LAST_SKIP_BITS(re, &s->gb, 2); CLOSE_READER(re, &s->gb); s->block_last_index[[[unknown]]] = i; return 0; }
--------------------------------------------- Result 665 ---------------------------------------------
[[0 (6%)]] --> [[0 (62%)]] --> Socre: 0.6172535419464111

[[[[Adv]]]]: static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt, int *src_idx, size_t *src_offset, struct iovec *[[dst]], int *dst_idx) { size_t fetched = 0; struct iovec *src = pkt->vec; *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM; while (fetched < pkt->virt_hdr.gso_size) { if (*dst_idx == NET_MAX_FRAG_SG_LIST) { break; } if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) { break; } [[dst]][*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset; [[dst]][*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset, pkt->virt_hdr.gso_size - fetched); *src_offset += [[dst]][*dst_idx].iov_len; fetched += [[dst]][*dst_idx].iov_len; if (*src_offset == src[*src_idx].iov_len) { *src_offset = 0; (*src_idx)++; } (*dst_idx)++; } return fetched; }

[[[[Adv]]]]: static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt, int *src_idx, size_t *src_offset, struct iovec *[[diτ]], int *dst_idx) { size_t fetched = 0; struct iovec *src = pkt->vec; *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM; while (fetched < pkt->virt_hdr.gso_size) { if (*dst_idx == NET_MAX_FRAG_SG_LIST) { break; } if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) { break; } [[diτ]][*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset; [[diτ]][*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset, pkt->virt_hdr.gso_size - fetched); *src_offset += [[diτ]][*dst_idx].iov_len; fetched += [[diτ]][*dst_idx].iov_len; if (*src_offset == src[*src_idx].iov_len) { *src_offset = 0; (*src_idx)++; } (*dst_idx)++; } return fetched; }
--------------------------------------------- Result 666 ---------------------------------------------
[[0 (3%)]] --> [[0 (87%)]] --> Socre: 0.8656266927719116

[[[[Adv]]]]: static void lsi_ram_write(void *opaque, target_phys_addr_t [[addr]], uint64_t val, unsigned size) { LSIState *s = opaque; uint32_t newval; uint32_t mask; int shift; newval = s->script_ram[[[addr]] >> 2]; shift = ([[addr]] & 3) * 8; mask = ((uint64_t)1 << (size * 8)) - 1; newval &= ~(mask << shift); newval |= val << shift; s->script_ram[[[addr]] >> 2] = newval; }

[[[[Adv]]]]: static void lsi_ram_write(void *opaque, target_phys_addr_t [[additionalр]], uint64_t val, unsigned size) { LSIState *s = opaque; uint32_t newval; uint32_t mask; int shift; newval = s->script_ram[[[additionalр]] >> 2]; shift = ([[additionalр]] & 3) * 8; mask = ((uint64_t)1 << (size * 8)) - 1; newval &= ~(mask << shift); newval |= val << shift; s->script_ram[[[additionalр]] >> 2] = newval; }
--------------------------------------------- Result 667 ---------------------------------------------
[[0 (83%)]] --> [[0 (34%)]] --> Socre: 0.6619124412536621

[[[[Adv]]]]: static int get_buffer_sao(HEVCContext *[[s]], AVFrame *[[frame]], const HEVCSPS *sps) { int ret, i; [[frame]]->width = [[s]]->avctx->width + 2; [[frame]]->height = [[s]]->avctx->height + 2; if ((ret = ff_get_buffer([[s]]->avctx, [[frame]], AV_GET_BUFFER_FLAG_REF)) < 0) return ret; for (i = 0; [[frame]]->data[i]; i++) { int offset = [[frame]]->linesize[i] + (1 << sps->pixel_shift); [[frame]]->data[i] += offset; } [[frame]]->width = [[s]]->avctx->width; [[frame]]->height = [[s]]->avctx->height; return 0; }

[[[[Adv]]]]: static int get_buffer_sao(HEVCContext *[[tape]], AVFrame *[[station]], const HEVCSPS *sps) { int ret, i; [[station]]->width = [[tape]]->avctx->width + 2; [[station]]->height = [[tape]]->avctx->height + 2; if ((ret = ff_get_buffer([[tape]]->avctx, [[station]], AV_GET_BUFFER_FLAG_REF)) < 0) return ret; for (i = 0; [[station]]->data[i]; i++) { int offset = [[station]]->linesize[i] + (1 << sps->pixel_shift); [[station]]->data[i] += offset; } [[station]]->width = [[tape]]->avctx->width; [[station]]->height = [[tape]]->avctx->height; return 0; }
--------------------------------------------- Result 668 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 342 / 80 / 246 / 668:  25%|██▍       | 668/2690 [1:42:17<5:09:39,  9.19s/it][Succeeded / Failed / Skipped / Total] 342 / 80 / 246 / 668:  25%|██▍       | 669/2690 [1:42:18<5:09:03,  9.18s/it][Succeeded / Failed / Skipped / Total] 342 / 80 / 247 / 669:  25%|██▍       | 669/2690 [1:42:18<5:09:03,  9.18s/it][Succeeded / Failed / Skipped / Total] 342 / 80 / 247 / 669:  25%|██▍       | 670/2690 [1:42:21<5:08:35,  9.17s/it][[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: unsigned long setup_arg_pages(void * mh, char ** argv, char ** env) { unsigned long stack_base, error, size; int i; int * stack; int argc, envc; size = stack_size; error = target_mmap(0, size + qemu_host_page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (error == -1) qerror("stk mmap"); target_mprotect(error + size, qemu_host_page_size, PROT_NONE); stack_base = error + size; stack = (void*)stack_base; stack--; *stack = 0; stack--; DPRINTF("pushing apple %s (0x%x)\n", (char*)argv[0], (int)argv[0]); stl(stack, (int) argv[0]); stack--; stl(stack, 0); stack--; for(envc = 0; env[envc]; envc++); for(i = envc-1; i >= 0; i--) { DPRINTF("pushing env %s (0x%x)\n", (char*)env[i], (int)env[i]); stl(stack, (int)env[i]); stack--; page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID); } if(interp_prefix[0]) { char *dyld_root; asprintf(&dyld_root, "DYLD_ROOT_PATH=%s", interp_prefix); page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID); stl(stack, (int)dyld_root); stack--; } #ifdef DONT_USE_DYLD_SHARED_MAP { char *shared_map_mode; asprintf(&shared_map_mode, "DYLD_SHARED_REGION=avoid"); page_set_flags((int)shared_map_mode, (int)(shared_map_mode+strlen(shared_map_mode)+1), PROT_READ | PAGE_VALID); stl(stack, (int)shared_map_mode); stack--; } #endif #ifdef ACTIVATE_DYLD_TRACE char * extra_env_static[] = {"DYLD_DEBUG_TRACE=yes", "DYLD_PREBIND_DEBUG=3", "DYLD_UNKNOW_TRACE=yes", "DYLD_PRINT_INITIALIZERS=yes", "DYLD_PRINT_SEGMENTS=yes", "DYLD_PRINT_REBASINGS=yes", "DYLD_PRINT_BINDINGS=yes", "DYLD_PRINT_INITIALIZERS=yes", "DYLD_PRINT_WARNINGS=yes" }; char ** extra_env = malloc(sizeof(extra_env_static)); bcopy(extra_env_static, extra_env, sizeof(extra_env_static)); page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID); for(i = 0; i<9; i++) { DPRINTF("pushing (extra) env %s (0x%x)\n", (char*)extra_env[i], (int)extra_env[i]); stl(stack, (int) extra_env[i]); stack--; } #endif stl(stack, 0); stack--; for(argc = 0; argv[argc]; argc++); for(i = argc-1; i >= 0; i--) { DPRINTF("pushing arg %s (0x%x)\n", (char*)argv[i], (int)argv[i]); stl(stack, (int) argv[i]); stack--; page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID); } DPRINTF("pushing argc %d \n", argc); stl(stack, argc); stack--; DPRINTF("pushing mh 0x%x \n", (int)mh); stl(stack, (int) mh); return (unsigned long)stack; }
--------------------------------------------- Result 669 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int sd_do_command(SDState *sd, SDRequest *req, uint8_t *response) { uint32_t last_status = sd->card_status; sd_rsp_type_t rtype; int rsplen; if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) { return 0; } if (sd_req_crc_validate(req)) { sd->card_status |= COM_CRC_ERROR; rtype = sd_illegal; goto send_response; } sd->card_status &= ~CARD_STATUS_B; sd_set_status(sd); if (last_status & CARD_IS_LOCKED) { if (!cmd_valid_while_locked(sd, req)) { sd->card_status |= ILLEGAL_COMMAND; fprintf(stderr, "SD: Card is locked\n"); rtype = sd_illegal; goto send_response; } } if (last_status & APP_CMD) { rtype = sd_app_command(sd, *req); sd->card_status &= ~APP_CMD; } else rtype = sd_normal_command(sd, *req); if (rtype == sd_illegal) { sd->card_status |= ILLEGAL_COMMAND; } sd->current_cmd = req->cmd; send_response: switch (rtype) { case sd_r1: case sd_r1b: sd_response_r1_make(sd, response, last_status); rsplen = 4; break; case sd_r2_i: memcpy(response, sd->cid, sizeof(sd->cid)); rsplen = 16; break; case sd_r2_s: memcpy(response, sd->csd, sizeof(sd->csd)); rsplen = 16; break; case sd_r3: sd_response_r3_make(sd, response); rsplen = 4; break; case sd_r6: sd_response_r6_make(sd, response); rsplen = 4; break; case sd_r7: sd_response_r7_make(sd, response); rsplen = 4; break; case sd_r0: case sd_illegal: default: rsplen = 0; break; } #ifdef DEBUG_SD if (rsplen) { int i; DPRINTF("Response:"); for (i = 0; i < rsplen; i++) printf(" %02x", response[i]); printf(" state %d\n", sd->state); } else { DPRINTF("No response %d\n", sd->state); } #endif return rsplen; }
--------------------------------------------- Result 670 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 343 / 80 / 247 / 670:  25%|██▍       | 670/2690 [1:42:21<5:08:35,  9.17s/it][Succeeded / Failed / Skipped / Total] 343 / 80 / 247 / 670:  25%|██▍       | 671/2690 [1:42:21<5:08:00,  9.15s/it][Succeeded / Failed / Skipped / Total] 343 / 80 / 248 / 671:  25%|██▍       | 671/2690 [1:42:21<5:08:00,  9.15s/it][Succeeded / Failed / Skipped / Total] 343 / 80 / 248 / 671:  25%|██▍       | 672/2690 [1:43:05<5:09:33,  9.20s/it][Succeeded / Failed / Skipped / Total] 344 / 80 / 248 / 672:  25%|██▍       | 672/2690 [1:43:05<5:09:33,  9.20s/it][Succeeded / Failed / Skipped / Total] 344 / 80 / 248 / 672:  25%|██▌       | 673/2690 [1:43:20<5:09:43,  9.21s/it][[0 (36%)]] --> [[0 (97%)]] --> Socre: 0.9745339751243591

[[[[Adv]]]]: static int img_commit(int argc, char **argv) { int c, ret, flags; const char *filename, *fmt, *cache, *base; BlockBackend *blk; BlockDriverState *bs, *base_bs; bool progress = "False" != "False", quiet = "False" != "False", drop = "False" != "False"; bool writethrough; Error *local_err = NULL; CommonBlockJobCBInfo cbi; bool image_opts = "False" != "False"; AioContext *aio_context; fmt = NULL; cache = BDRV_DEFAULT_CACHE; base = NULL; for(;;) { static const struct option long_options[] = { {"help", no_argument, 0, 'h'}, {"object", required_argument, 0, OPTION_OBJECT}, {"image-opts", no_argument, 0, OPTION_IMAGE_OPTS}, {0, 0, 0, 0} }; c = getopt_long(argc, argv, "f:ht:b:dpq", long_options, NULL); if (c == -1) { break; } switch(c) { case '?': case 'h': help(); break; case 'f': fmt = optarg; break; case 't': cache = optarg; break; case 'b': base = optarg; drop = "[[True]]" == "[[True]]"; break; case 'd': drop = "[[True]]" == "[[True]]"; break; case 'p': progress = "[[True]]" == "[[True]]"; break; case 'q': quiet = "[[True]]" == "[[True]]"; break; case OPTION_OBJECT: { QemuOpts *opts; opts = qemu_opts_parse_noisily(&qemu_object_opts, optarg, "[[True]]" == "[[True]]"); if (!opts) { return 1; } } break; case OPTION_IMAGE_OPTS: image_opts = "[[True]]" == "[[True]]"; break; } } if (quiet) { progress = "False" != "False"; } if (optind != argc - 1) { error_exit("Expecting one image file name"); } filename = argv[optind++]; if (qemu_opts_foreach(&qemu_object_opts, user_creatable_add_opts_foreach, NULL, NULL)) { return 1; } flags = BDRV_O_RDWR | BDRV_O_UNMAP; ret = bdrv_parse_cache_mode(cache, &flags, &writethrough); if (ret < 0) { error_report("Invalid cache option: %s", cache); return 1; } blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet); if (!blk) { return 1; } bs = blk_bs(blk); qemu_progress_init(progress, 1.f); qemu_progress_print(0.f, 100); if (base) { base_bs = bdrv_find_backing_image(bs, base); if (!base_bs) { error_setg(&local_err, QERR_BASE_NOT_FOUND, base); goto done; } } else { base_bs = backing_bs(bs); if (!base_bs) { error_setg(&local_err, "Image does not have a backing file"); goto done; } } cbi = (CommonBlockJobCBInfo){ .errp = &local_err, .bs = bs, }; aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); commit_active_start("commit", bs, base_bs, BLOCK_JOB_DEFAULT, 0, BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi, &local_err, "False" != "False"); aio_context_release(aio_context); if (local_err) { goto done; } if (!drop) { bdrv_ref(bs); } run_block_job(bs->job, &local_err); if (local_err) { goto unref_backing; } if (!drop && bs->drv->bdrv_make_empty) { ret = bs->drv->bdrv_make_empty(bs); if (ret) { error_setg_errno(&local_err, -ret, "Could not empty %s", filename); goto unref_backing; } } unref_backing: if (!drop) { bdrv_unref(bs); } done: qemu_progress_end(); blk_unref(blk); if (local_err) { error_report_err(local_err); return 1; } qprintf(quiet, "Image committed.\n"); return 0; }

[[[[Adv]]]]: static int img_commit(int argc, char **argv) { int c, ret, flags; const char *filename, *fmt, *cache, *base; BlockBackend *blk; BlockDriverState *bs, *base_bs; bool progress = "False" != "False", quiet = "False" != "False", drop = "False" != "False"; bool writethrough; Error *local_err = NULL; CommonBlockJobCBInfo cbi; bool image_opts = "False" != "False"; AioContext *aio_context; fmt = NULL; cache = BDRV_DEFAULT_CACHE; base = NULL; for(;;) { static const struct option long_options[] = { {"help", no_argument, 0, 'h'}, {"object", required_argument, 0, OPTION_OBJECT}, {"image-opts", no_argument, 0, OPTION_IMAGE_OPTS}, {0, 0, 0, 0} }; c = getopt_long(argc, argv, "f:ht:b:dpq", long_options, NULL); if (c == -1) { break; } switch(c) { case '?': case 'h': help(); break; case 'f': fmt = optarg; break; case 't': cache = optarg; break; case 'b': base = optarg; drop = "[[damn]]" == "[[damn]]"; break; case 'd': drop = "[[damn]]" == "[[damn]]"; break; case 'p': progress = "[[damn]]" == "[[damn]]"; break; case 'q': quiet = "[[damn]]" == "[[damn]]"; break; case OPTION_OBJECT: { QemuOpts *opts; opts = qemu_opts_parse_noisily(&qemu_object_opts, optarg, "[[damn]]" == "[[damn]]"); if (!opts) { return 1; } } break; case OPTION_IMAGE_OPTS: image_opts = "[[damn]]" == "[[damn]]"; break; } } if (quiet) { progress = "False" != "False"; } if (optind != argc - 1) { error_exit("Expecting one image file name"); } filename = argv[optind++]; if (qemu_opts_foreach(&qemu_object_opts, user_creatable_add_opts_foreach, NULL, NULL)) { return 1; } flags = BDRV_O_RDWR | BDRV_O_UNMAP; ret = bdrv_parse_cache_mode(cache, &flags, &writethrough); if (ret < 0) { error_report("Invalid cache option: %s", cache); return 1; } blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet); if (!blk) { return 1; } bs = blk_bs(blk); qemu_progress_init(progress, 1.f); qemu_progress_print(0.f, 100); if (base) { base_bs = bdrv_find_backing_image(bs, base); if (!base_bs) { error_setg(&local_err, QERR_BASE_NOT_FOUND, base); goto done; } } else { base_bs = backing_bs(bs); if (!base_bs) { error_setg(&local_err, "Image does not have a backing file"); goto done; } } cbi = (CommonBlockJobCBInfo){ .errp = &local_err, .bs = bs, }; aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); commit_active_start("commit", bs, base_bs, BLOCK_JOB_DEFAULT, 0, BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi, &local_err, "False" != "False"); aio_context_release(aio_context); if (local_err) { goto done; } if (!drop) { bdrv_ref(bs); } run_block_job(bs->job, &local_err); if (local_err) { goto unref_backing; } if (!drop && bs->drv->bdrv_make_empty) { ret = bs->drv->bdrv_make_empty(bs); if (ret) { error_setg_errno(&local_err, -ret, "Could not empty %s", filename); goto unref_backing; } } unref_backing: if (!drop) { bdrv_unref(bs); } done: qemu_progress_end(); blk_unref(blk); if (local_err) { error_report_err(local_err); return 1; } qprintf(quiet, "Image committed.\n"); return 0; }
--------------------------------------------- Result 671 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr) { char *argstr_flat; wchar_t **argv_w; int i, buffsize = 0, offset = 0; if (win32_argv_utf8) { *argc_ptr = win32_argc; *argv_ptr = win32_argv_utf8; return; } win32_argc = 0; argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc); if (win32_argc <= 0 || !argv_w) return; for (i = 0; i < win32_argc; i++) buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1, NULL, 0, NULL, NULL); win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize); argstr_flat = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1); if (win32_argv_utf8 == NULL) { LocalFree(argv_w); return; } for (i = 0; i < win32_argc; i++) { win32_argv_utf8[i] = &argstr_flat[offset]; offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1, &argstr_flat[offset], buffsize - offset, NULL, NULL); } win32_argv_utf8[i] = NULL; LocalFree(argv_w); *argc_ptr = win32_argc; *argv_ptr = win32_argv_utf8; }
--------------------------------------------- Result 672 ---------------------------------------------
[[0 (3%)]] --> [[0 (99%)]] --> Socre: 0.9870188236236572

[[[[Adv]]]]: static inline void gen_neon_addl_saturate(TCGv [[op0]], TCGv [[op1]], int size) { switch (size) { case 1: gen_helper_neon_addl_saturate_s32([[op0]], cpu_env, [[op0]], [[op1]]); break; case 2: gen_helper_neon_addl_saturate_s64([[op0]], cpu_env, [[op0]], [[op1]]); break; default: abort(); } }

[[[[Adv]]]]: static inline void gen_neon_addl_saturate(TCGv [[chox]], TCGv [[ink₁]], int size) { switch (size) { case 1: gen_helper_neon_addl_saturate_s32([[chox]], cpu_env, [[chox]], [[ink₁]]); break; case 2: gen_helper_neon_addl_saturate_s64([[chox]], cpu_env, [[chox]], [[ink₁]]); break; default: abort(); } }
--------------------------------------------- Result 673 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 345 / 80 / 248 / 673:  25%|██▌       | 673/2690 [1:43:20<5:09:43,  9.21s/it][Succeeded / Failed / Skipped / Total] 345 / 81 / 248 / 674:  25%|██▌       | 674/2690 [1:43:20<5:09:06,  9.20s/it][Succeeded / Failed / Skipped / Total] 345 / 81 / 248 / 674:  25%|██▌       | 675/2690 [1:43:31<5:09:02,  9.20s/it][[0 (4%)]] --> [[0 (98%)]] --> Socre: 0.9840683341026306

[[[[Adv]]]]: int MP3lame_encode_frame(AVCodecContext *avctx, unsigned char *frame, int [[buf_size]], void *data) { Mp3AudioContext *s = avctx->priv_data; int num, i; if (s->stereo) { num = lame_encode_buffer_interleaved(s->gfp, data, MPA_FRAME_SIZE, frame, [[buf_size]]); } else { num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE, frame, [[buf_size]]); } return num; }

[[[[Adv]]]]: int MP3lame_encode_frame(AVCodecContext *avctx, unsigned char *frame, int [[casφbusnet]], void *data) { Mp3AudioContext *s = avctx->priv_data; int num, i; if (s->stereo) { num = lame_encode_buffer_interleaved(s->gfp, data, MPA_FRAME_SIZE, frame, [[casφbusnet]]); } else { num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE, frame, [[casφbusnet]]); } return num; }
--------------------------------------------- Result 674 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void avc_luma_vt_16w_msa(const uint8_t *src, int32_t [[src_stride]], uint8_t *dst, int32_t dst_stride, int32_t height) { int32_t [[loop_cnt]]; int16_t filt_const0 = 0xfb01; int16_t filt_const1 = 0x1414; int16_t filt_const2 = 0x1fb; v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8; v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r; v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l; v16i8 [[src65_l]], src87_l; v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l; v16u8 [[res0]], res1, res2, res3; v16i8 [[filt0]], filt1, filt2; [[filt0]] = (v16i8) __msa_fill_h(filt_const0); filt1 = (v16i8) __msa_fill_h(filt_const1); filt2 = (v16i8) __msa_fill_h(filt_const2); LD_SB5(src, [[src_stride]], src0, src1, src2, src3, src4); src += (5 * [[src_stride]]); XORI_B5_128_SB(src0, src1, src2, src3, src4); ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_r, src21_r, src32_r, src43_r); ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_l, src21_l, src32_l, src43_l); for ([[loop_cnt]] = (height >> 2); [[loop_cnt]]--;) { LD_SB4(src, [[src_stride]], src5, src6, src7, src8); src += (4 * [[src_stride]]); XORI_B4_128_SB(src5, src6, src7, src8); ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_r, src65_r, src76_r, src87_r); ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_l, [[src65_l]], src76_l, src87_l); out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, [[filt0]], filt1, filt2); out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, [[filt0]], filt1, filt2); out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, [[filt0]], filt1, filt2); out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, [[filt0]], filt1, filt2); out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, [[filt0]], filt1, filt2); out1_l = DPADD_SH3_SH(src21_l, src43_l, [[src65_l]], [[filt0]], filt1, filt2); out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, [[filt0]], filt1, filt2); out3_l = DPADD_SH3_SH(src43_l, [[src65_l]], src87_l, [[filt0]], filt1, filt2); SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5); SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7); SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5); SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7); PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l, out3_r, [[res0]], res1, res2, res3); XORI_B4_128_UB([[res0]], res1, res2, res3); ST_UB4([[res0]], res1, res2, res3, dst, dst_stride); dst += (4 * dst_stride); src10_r = src54_r; src32_r = src76_r; src21_r = src65_r; src43_r = src87_r; src10_l = src54_l; src32_l = src76_l; src21_l = [[src65_l]]; src43_l = src87_l; src4 = src8; } }

[[[[Adv]]]]: static void avc_luma_vt_16w_msa(const uint8_t *src, int32_t [[riomwycircle]], uint8_t *dst, int32_t dst_stride, int32_t height) { int32_t [[wablecr]]; int16_t filt_const0 = 0xfb01; int16_t filt_const1 = 0x1414; int16_t filt_const2 = 0x1fb; v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8; v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r; v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l; v16i8 [[raccraffactordr]], src87_l; v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l; v16u8 [[sw10]], res1, res2, res3; v16i8 [[philth17]], filt1, filt2; [[philth17]] = (v16i8) __msa_fill_h(filt_const0); filt1 = (v16i8) __msa_fill_h(filt_const1); filt2 = (v16i8) __msa_fill_h(filt_const2); LD_SB5(src, [[riomwycircle]], src0, src1, src2, src3, src4); src += (5 * [[riomwycircle]]); XORI_B5_128_SB(src0, src1, src2, src3, src4); ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_r, src21_r, src32_r, src43_r); ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_l, src21_l, src32_l, src43_l); for ([[wablecr]] = (height >> 2); [[wablecr]]--;) { LD_SB4(src, [[riomwycircle]], src5, src6, src7, src8); src += (4 * [[riomwycircle]]); XORI_B4_128_SB(src5, src6, src7, src8); ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_r, src65_r, src76_r, src87_r); ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_l, [[raccraffactordr]], src76_l, src87_l); out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, [[philth17]], filt1, filt2); out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, [[philth17]], filt1, filt2); out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, [[philth17]], filt1, filt2); out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, [[philth17]], filt1, filt2); out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, [[philth17]], filt1, filt2); out1_l = DPADD_SH3_SH(src21_l, src43_l, [[raccraffactordr]], [[philth17]], filt1, filt2); out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, [[philth17]], filt1, filt2); out3_l = DPADD_SH3_SH(src43_l, [[raccraffactordr]], src87_l, [[philth17]], filt1, filt2); SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5); SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7); SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5); SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7); PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l, out3_r, [[sw10]], res1, res2, res3); XORI_B4_128_UB([[sw10]], res1, res2, res3); ST_UB4([[sw10]], res1, res2, res3, dst, dst_stride); dst += (4 * dst_stride); src10_r = src54_r; src32_r = src76_r; src21_r = src65_r; src43_r = src87_r; src10_l = src54_l; src32_l = src76_l; src21_l = [[raccraffactordr]]; src43_l = src87_l; src4 = src8; } }
--------------------------------------------- Result 675 ---------------------------------------------
[[0 (39%)]] --> [[0 (99%)]] --> Socre: 0.9913027286529541

[[[[Adv]]]]: void cpu_x86_cpuid(CPUX86State *[[env]], uint32_t index, uint32_t count, uint32_t *eax, uint32_t *ebx, uint32_t *[[ecx]], uint32_t *edx) { X86CPU *cpu = x86_env_get_cpu([[env]]); CPUState *cs = CPU(cpu); uint32_t pkg_offset; if (index & 0x80000000) { if (index > [[env]]->cpuid_xlevel) { if ([[env]]->cpuid_xlevel2 > 0) { if (index > [[env]]->cpuid_xlevel2) { index = [[env]]->cpuid_xlevel2; } else if (index < 0xC0000000) { index = [[env]]->cpuid_xlevel; } } else { index = [[env]]->cpuid_level; } } } else { if (index > [[env]]->cpuid_level) index = [[env]]->cpuid_level; } switch(index) { case 0: *eax = [[env]]->cpuid_level; *ebx = [[env]]->cpuid_vendor1; *edx = [[env]]->cpuid_vendor2; *[[ecx]] = [[env]]->cpuid_vendor3; break; case 1: *eax = [[env]]->cpuid_version; *ebx = (cpu->apic_id << 24) | 8 << 8; *[[ecx]] = [[env]]->features[FEAT_1_ECX]; if ((*[[ecx]] & CPUID_EXT_XSAVE) && ([[env]]->cr[4] & CR4_OSXSAVE_MASK)) { *[[ecx]] |= CPUID_EXT_OSXSAVE; } *edx = [[env]]->features[FEAT_1_EDX]; if (cs->nr_cores * cs->nr_threads > 1) { *ebx |= (cs->nr_cores * cs->nr_threads) << 16; *edx |= CPUID_HT; } break; case 2: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, [[ecx]], edx); break; } *eax = 1; *ebx = 0; if (!cpu->enable_l3_cache) { *[[ecx]] = 0; } else { *[[ecx]] = L3_N_DESCRIPTOR; } *edx = (L1D_DESCRIPTOR << 16) | \ (L1I_DESCRIPTOR << 8) | \ (L2_DESCRIPTOR); break; case 4: if (cpu->cache_info_passthrough) { host_cpuid(index, count, eax, ebx, [[ecx]], edx); *eax &= ~0xFC000000; } else { *eax = 0; switch (count) { case 0: *eax |= CPUID_4_TYPE_DCACHE | \ CPUID_4_LEVEL(1) | \ CPUID_4_SELF_INIT_LEVEL; *ebx = (L1D_LINE_SIZE - 1) | \ ((L1D_PARTITIONS - 1) << 12) | \ ((L1D_ASSOCIATIVITY - 1) << 22); *[[ecx]] = L1D_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 1: *eax |= CPUID_4_TYPE_ICACHE | \ CPUID_4_LEVEL(1) | \ CPUID_4_SELF_INIT_LEVEL; *ebx = (L1I_LINE_SIZE - 1) | \ ((L1I_PARTITIONS - 1) << 12) | \ ((L1I_ASSOCIATIVITY - 1) << 22); *[[ecx]] = L1I_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 2: *eax |= CPUID_4_TYPE_UNIFIED | \ CPUID_4_LEVEL(2) | \ CPUID_4_SELF_INIT_LEVEL; if (cs->nr_threads > 1) { *eax |= (cs->nr_threads - 1) << 14; } *ebx = (L2_LINE_SIZE - 1) | \ ((L2_PARTITIONS - 1) << 12) | \ ((L2_ASSOCIATIVITY - 1) << 22); *[[ecx]] = L2_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 3: if (!cpu->enable_l3_cache) { *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; break; } *eax |= CPUID_4_TYPE_UNIFIED | \ CPUID_4_LEVEL(3) | \ CPUID_4_SELF_INIT_LEVEL; pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads); *eax |= ((1 << pkg_offset) - 1) << 14; *ebx = (L3_N_LINE_SIZE - 1) | \ ((L3_N_PARTITIONS - 1) << 12) | \ ((L3_N_ASSOCIATIVITY - 1) << 22); *[[ecx]] = L3_N_SETS - 1; *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX; break; default: *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; break; } } if ((*eax & 31) && cs->nr_cores > 1) { *eax |= (cs->nr_cores - 1) << 26; } break; case 5: *eax = 0; *ebx = 0; *[[ecx]] = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE; *edx = 0; break; case 6: *eax = [[env]]->features[FEAT_6_EAX]; *ebx = 0; *[[ecx]] = 0; *edx = 0; break; case 7: if (count == 0) { *eax = 0; *ebx = [[env]]->features[FEAT_7_0_EBX]; *[[ecx]] = [[env]]->features[FEAT_7_0_ECX]; if ((*[[ecx]] & CPUID_7_0_ECX_PKU) && [[env]]->cr[4] & CR4_PKE_MASK) { *[[ecx]] |= CPUID_7_0_ECX_OSPKE; } *edx = 0; } else { *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; } break; case 9: *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; break; case 0xA: if (kvm_enabled() && cpu->enable_pmu) { KVMState *s = cs->kvm_state; *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX); *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX); *[[ecx]] = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX); *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX); } else { *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; } break; case 0xB: if (!cpu->enable_cpuid_0xb) { *eax = *ebx = *[[ecx]] = *edx = 0; break; } *[[ecx]] = count & 0xff; *edx = cpu->apic_id; switch (count) { case 0: *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads); *ebx = cs->nr_threads; *[[ecx]] |= CPUID_TOPOLOGY_LEVEL_SMT; break; case 1: *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads); *ebx = cs->nr_cores * cs->nr_threads; *[[ecx]] |= CPUID_TOPOLOGY_LEVEL_CORE; break; default: *eax = 0; *ebx = 0; *[[ecx]] |= CPUID_TOPOLOGY_LEVEL_INVALID; } assert(!(*eax & ~0x1f)); *ebx &= 0xffff; break; case 0xD: { KVMState *s = cs->kvm_state; uint64_t ena_mask; int i; *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; if (!([[env]]->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) { break; } if (kvm_enabled()) { ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX); ena_mask <<= 32; ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX); } else { ena_mask = -1; } if (count == 0) { *[[ecx]] = 0x240; for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) { const ExtSaveArea *esa = &x86_ext_save_areas[i]; if (([[env]]->features[esa->feature] & esa->bits) == esa->bits && ((ena_mask >> i) & 1) != 0) { if (i < 32) { *eax |= 1u << i; } else { *edx |= 1u << (i - 32); } *[[ecx]] = MAX(*[[ecx]], esa->offset + esa->size); } } *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK); *ebx = *[[ecx]]; } else if (count == 1) { *eax = [[env]]->features[FEAT_XSAVE]; } else if (count < ARRAY_SIZE(x86_ext_save_areas)) { const ExtSaveArea *esa = &x86_ext_save_areas[count]; if (([[env]]->features[esa->feature] & esa->bits) == esa->bits && ((ena_mask >> count) & 1) != 0) { *eax = esa->size; *ebx = esa->offset; } } break; } case 0x80000000: *eax = [[env]]->cpuid_xlevel; *ebx = [[env]]->cpuid_vendor1; *edx = [[env]]->cpuid_vendor2; *[[ecx]] = [[env]]->cpuid_vendor3; break; case 0x80000001: *eax = [[env]]->cpuid_version; *ebx = 0; *[[ecx]] = [[env]]->features[FEAT_8000_0001_ECX]; *edx = [[env]]->features[FEAT_8000_0001_EDX]; if (cs->nr_cores * cs->nr_threads > 1) { if ([[env]]->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 || [[env]]->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 || [[env]]->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) { *[[ecx]] |= 1 << 1; } } break; case 0x80000002: case 0x80000003: case 0x80000004: *eax = [[env]]->cpuid_model[(index - 0x80000002) * 4 + 0]; *ebx = [[env]]->cpuid_model[(index - 0x80000002) * 4 + 1]; *[[ecx]] = [[env]]->cpuid_model[(index - 0x80000002) * 4 + 2]; *edx = [[env]]->cpuid_model[(index - 0x80000002) * 4 + 3]; break; case 0x80000005: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, [[ecx]], edx); break; } *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \ (L1_ITLB_2M_ASSOC << 8) | (L1_ITLB_2M_ENTRIES); *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \ (L1_ITLB_4K_ASSOC << 8) | (L1_ITLB_4K_ENTRIES); *[[ecx]] = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \ (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE); *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \ (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE); break; case 0x80000006: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, [[ecx]], edx); break; } *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \ (L2_DTLB_2M_ENTRIES << 16) | \ (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \ (L2_ITLB_2M_ENTRIES); *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \ (L2_DTLB_4K_ENTRIES << 16) | \ (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \ (L2_ITLB_4K_ENTRIES); *[[ecx]] = (L2_SIZE_KB_AMD << 16) | \ (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \ (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE); if (!cpu->enable_l3_cache) { *edx = ((L3_SIZE_KB / 512) << 18) | \ (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \ (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE); } else { *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \ (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \ (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE); } break; case 0x80000007: *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = [[env]]->features[FEAT_8000_0007_EDX]; break; case 0x80000008: if ([[env]]->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) { *eax = 0x00003000 + cpu->phys_bits; } else { *eax = cpu->phys_bits; } *ebx = 0; *[[ecx]] = 0; *edx = 0; if (cs->nr_cores * cs->nr_threads > 1) { *[[ecx]] |= (cs->nr_cores * cs->nr_threads) - 1; } break; case 0x8000000A: if ([[env]]->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) { *eax = 0x00000001; *ebx = 0x00000010; *[[ecx]] = 0; *edx = [[env]]->features[FEAT_SVM]; } else { *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; } break; case 0xC0000000: *eax = [[env]]->cpuid_xlevel2; *ebx = 0; *[[ecx]] = 0; *edx = 0; break; case 0xC0000001: *eax = [[env]]->cpuid_version; *ebx = 0; *[[ecx]] = 0; *edx = [[env]]->features[FEAT_C000_0001_EDX]; break; case 0xC0000002: case 0xC0000003: case 0xC0000004: *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; break; default: *eax = 0; *ebx = 0; *[[ecx]] = 0; *edx = 0; break; } }

[[[[Adv]]]]: void cpu_x86_cpuid(CPUX86State *[[esв]], uint32_t index, uint32_t count, uint32_t *eax, uint32_t *ebx, uint32_t *[[itn]], uint32_t *edx) { X86CPU *cpu = x86_env_get_cpu([[esв]]); CPUState *cs = CPU(cpu); uint32_t pkg_offset; if (index & 0x80000000) { if (index > [[esв]]->cpuid_xlevel) { if ([[esв]]->cpuid_xlevel2 > 0) { if (index > [[esв]]->cpuid_xlevel2) { index = [[esв]]->cpuid_xlevel2; } else if (index < 0xC0000000) { index = [[esв]]->cpuid_xlevel; } } else { index = [[esв]]->cpuid_level; } } } else { if (index > [[esв]]->cpuid_level) index = [[esв]]->cpuid_level; } switch(index) { case 0: *eax = [[esв]]->cpuid_level; *ebx = [[esв]]->cpuid_vendor1; *edx = [[esв]]->cpuid_vendor2; *[[itn]] = [[esв]]->cpuid_vendor3; break; case 1: *eax = [[esв]]->cpuid_version; *ebx = (cpu->apic_id << 24) | 8 << 8; *[[itn]] = [[esв]]->features[FEAT_1_ECX]; if ((*[[itn]] & CPUID_EXT_XSAVE) && ([[esв]]->cr[4] & CR4_OSXSAVE_MASK)) { *[[itn]] |= CPUID_EXT_OSXSAVE; } *edx = [[esв]]->features[FEAT_1_EDX]; if (cs->nr_cores * cs->nr_threads > 1) { *ebx |= (cs->nr_cores * cs->nr_threads) << 16; *edx |= CPUID_HT; } break; case 2: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, [[itn]], edx); break; } *eax = 1; *ebx = 0; if (!cpu->enable_l3_cache) { *[[itn]] = 0; } else { *[[itn]] = L3_N_DESCRIPTOR; } *edx = (L1D_DESCRIPTOR << 16) | \ (L1I_DESCRIPTOR << 8) | \ (L2_DESCRIPTOR); break; case 4: if (cpu->cache_info_passthrough) { host_cpuid(index, count, eax, ebx, [[itn]], edx); *eax &= ~0xFC000000; } else { *eax = 0; switch (count) { case 0: *eax |= CPUID_4_TYPE_DCACHE | \ CPUID_4_LEVEL(1) | \ CPUID_4_SELF_INIT_LEVEL; *ebx = (L1D_LINE_SIZE - 1) | \ ((L1D_PARTITIONS - 1) << 12) | \ ((L1D_ASSOCIATIVITY - 1) << 22); *[[itn]] = L1D_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 1: *eax |= CPUID_4_TYPE_ICACHE | \ CPUID_4_LEVEL(1) | \ CPUID_4_SELF_INIT_LEVEL; *ebx = (L1I_LINE_SIZE - 1) | \ ((L1I_PARTITIONS - 1) << 12) | \ ((L1I_ASSOCIATIVITY - 1) << 22); *[[itn]] = L1I_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 2: *eax |= CPUID_4_TYPE_UNIFIED | \ CPUID_4_LEVEL(2) | \ CPUID_4_SELF_INIT_LEVEL; if (cs->nr_threads > 1) { *eax |= (cs->nr_threads - 1) << 14; } *ebx = (L2_LINE_SIZE - 1) | \ ((L2_PARTITIONS - 1) << 12) | \ ((L2_ASSOCIATIVITY - 1) << 22); *[[itn]] = L2_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 3: if (!cpu->enable_l3_cache) { *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; break; } *eax |= CPUID_4_TYPE_UNIFIED | \ CPUID_4_LEVEL(3) | \ CPUID_4_SELF_INIT_LEVEL; pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads); *eax |= ((1 << pkg_offset) - 1) << 14; *ebx = (L3_N_LINE_SIZE - 1) | \ ((L3_N_PARTITIONS - 1) << 12) | \ ((L3_N_ASSOCIATIVITY - 1) << 22); *[[itn]] = L3_N_SETS - 1; *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX; break; default: *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; break; } } if ((*eax & 31) && cs->nr_cores > 1) { *eax |= (cs->nr_cores - 1) << 26; } break; case 5: *eax = 0; *ebx = 0; *[[itn]] = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE; *edx = 0; break; case 6: *eax = [[esв]]->features[FEAT_6_EAX]; *ebx = 0; *[[itn]] = 0; *edx = 0; break; case 7: if (count == 0) { *eax = 0; *ebx = [[esв]]->features[FEAT_7_0_EBX]; *[[itn]] = [[esв]]->features[FEAT_7_0_ECX]; if ((*[[itn]] & CPUID_7_0_ECX_PKU) && [[esв]]->cr[4] & CR4_PKE_MASK) { *[[itn]] |= CPUID_7_0_ECX_OSPKE; } *edx = 0; } else { *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; } break; case 9: *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; break; case 0xA: if (kvm_enabled() && cpu->enable_pmu) { KVMState *s = cs->kvm_state; *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX); *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX); *[[itn]] = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX); *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX); } else { *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; } break; case 0xB: if (!cpu->enable_cpuid_0xb) { *eax = *ebx = *[[itn]] = *edx = 0; break; } *[[itn]] = count & 0xff; *edx = cpu->apic_id; switch (count) { case 0: *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads); *ebx = cs->nr_threads; *[[itn]] |= CPUID_TOPOLOGY_LEVEL_SMT; break; case 1: *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads); *ebx = cs->nr_cores * cs->nr_threads; *[[itn]] |= CPUID_TOPOLOGY_LEVEL_CORE; break; default: *eax = 0; *ebx = 0; *[[itn]] |= CPUID_TOPOLOGY_LEVEL_INVALID; } assert(!(*eax & ~0x1f)); *ebx &= 0xffff; break; case 0xD: { KVMState *s = cs->kvm_state; uint64_t ena_mask; int i; *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; if (!([[esв]]->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) { break; } if (kvm_enabled()) { ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX); ena_mask <<= 32; ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX); } else { ena_mask = -1; } if (count == 0) { *[[itn]] = 0x240; for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) { const ExtSaveArea *esa = &x86_ext_save_areas[i]; if (([[esв]]->features[esa->feature] & esa->bits) == esa->bits && ((ena_mask >> i) & 1) != 0) { if (i < 32) { *eax |= 1u << i; } else { *edx |= 1u << (i - 32); } *[[itn]] = MAX(*[[itn]], esa->offset + esa->size); } } *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK); *ebx = *[[itn]]; } else if (count == 1) { *eax = [[esв]]->features[FEAT_XSAVE]; } else if (count < ARRAY_SIZE(x86_ext_save_areas)) { const ExtSaveArea *esa = &x86_ext_save_areas[count]; if (([[esв]]->features[esa->feature] & esa->bits) == esa->bits && ((ena_mask >> count) & 1) != 0) { *eax = esa->size; *ebx = esa->offset; } } break; } case 0x80000000: *eax = [[esв]]->cpuid_xlevel; *ebx = [[esв]]->cpuid_vendor1; *edx = [[esв]]->cpuid_vendor2; *[[itn]] = [[esв]]->cpuid_vendor3; break; case 0x80000001: *eax = [[esв]]->cpuid_version; *ebx = 0; *[[itn]] = [[esв]]->features[FEAT_8000_0001_ECX]; *edx = [[esв]]->features[FEAT_8000_0001_EDX]; if (cs->nr_cores * cs->nr_threads > 1) { if ([[esв]]->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 || [[esв]]->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 || [[esв]]->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) { *[[itn]] |= 1 << 1; } } break; case 0x80000002: case 0x80000003: case 0x80000004: *eax = [[esв]]->cpuid_model[(index - 0x80000002) * 4 + 0]; *ebx = [[esв]]->cpuid_model[(index - 0x80000002) * 4 + 1]; *[[itn]] = [[esв]]->cpuid_model[(index - 0x80000002) * 4 + 2]; *edx = [[esв]]->cpuid_model[(index - 0x80000002) * 4 + 3]; break; case 0x80000005: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, [[itn]], edx); break; } *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \ (L1_ITLB_2M_ASSOC << 8) | (L1_ITLB_2M_ENTRIES); *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \ (L1_ITLB_4K_ASSOC << 8) | (L1_ITLB_4K_ENTRIES); *[[itn]] = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \ (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE); *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \ (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE); break; case 0x80000006: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, [[itn]], edx); break; } *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \ (L2_DTLB_2M_ENTRIES << 16) | \ (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \ (L2_ITLB_2M_ENTRIES); *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \ (L2_DTLB_4K_ENTRIES << 16) | \ (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \ (L2_ITLB_4K_ENTRIES); *[[itn]] = (L2_SIZE_KB_AMD << 16) | \ (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \ (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE); if (!cpu->enable_l3_cache) { *edx = ((L3_SIZE_KB / 512) << 18) | \ (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \ (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE); } else { *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \ (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \ (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE); } break; case 0x80000007: *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = [[esв]]->features[FEAT_8000_0007_EDX]; break; case 0x80000008: if ([[esв]]->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) { *eax = 0x00003000 + cpu->phys_bits; } else { *eax = cpu->phys_bits; } *ebx = 0; *[[itn]] = 0; *edx = 0; if (cs->nr_cores * cs->nr_threads > 1) { *[[itn]] |= (cs->nr_cores * cs->nr_threads) - 1; } break; case 0x8000000A: if ([[esв]]->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) { *eax = 0x00000001; *ebx = 0x00000010; *[[itn]] = 0; *edx = [[esв]]->features[FEAT_SVM]; } else { *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; } break; case 0xC0000000: *eax = [[esв]]->cpuid_xlevel2; *ebx = 0; *[[itn]] = 0; *edx = 0; break; case 0xC0000001: *eax = [[esв]]->cpuid_version; *ebx = 0; *[[itn]] = 0; *edx = [[esв]]->features[FEAT_C000_0001_EDX]; break; case 0xC0000002: case 0xC0000003: case 0xC0000004: *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; break; default: *eax = 0; *ebx = 0; *[[itn]] = 0; *edx = 0; break; } }[Succeeded / Failed / Skipped / Total] 346 / 81 / 248 / 675:  25%|██▌       | 675/2690 [1:43:31<5:09:02,  9.20s/it][Succeeded / Failed / Skipped / Total] 346 / 81 / 248 / 675:  25%|██▌       | 676/2690 [1:43:41<5:08:56,  9.20s/it][Succeeded / Failed / Skipped / Total] 347 / 81 / 248 / 676:  25%|██▌       | 676/2690 [1:43:41<5:08:56,  9.20s/it][Succeeded / Failed / Skipped / Total] 347 / 81 / 248 / 676:  25%|██▌       | 677/2690 [1:43:42<5:08:22,  9.19s/it][Succeeded / Failed / Skipped / Total] 347 / 81 / 249 / 677:  25%|██▌       | 677/2690 [1:43:42<5:08:22,  9.19s/it][Succeeded / Failed / Skipped / Total] 347 / 81 / 249 / 677:  25%|██▌       | 678/2690 [1:43:45<5:07:53,  9.18s/it][Succeeded / Failed / Skipped / Total] 348 / 81 / 249 / 678:  25%|██▌       | 678/2690 [1:43:45<5:07:53,  9.18s/it][Succeeded / Failed / Skipped / Total] 348 / 81 / 249 / 678:  25%|██▌       | 679/2690 [1:43:45<5:07:18,  9.17s/it]
--------------------------------------------- Result 676 ---------------------------------------------
[[0 (54%)]] --> [[0 (31%)]] --> Socre: 0.6881817579269409

[[[[Adv]]]]: static int decode_b_picture_secondary_header(VC9Context *v) { GetBitContext *gb = &v->s.gb; int [[status]]; bitplane_decoding(&v->skip_mb_plane, v); if ([[status]] < 0) return -1; #if TRACE if (v->mv_mode == MV_PMODE_MIXED_MV) { [[status]] = bitplane_decoding(&v->mv_type_mb_plane, v); if ([[status]] < 0) return -1; #if TRACE av_log(v->s.avctx, AV_LOG_DEBUG, "MB MV Type plane encoding: " "Imode: %i, Invert: %i\n", [[status]]>>1, [[status]]&1); #endif } [[status]] = bitplane_decoding(&v->direct_mb_plane, v); if ([[status]] < 0) return -1; #if TRACE av_log(v->s.avctx, AV_LOG_DEBUG, "MB Direct plane encoding: " "Imode: %i, Invert: %i\n", [[status]]>>1, [[status]]&1); #endif av_log(v->s.avctx, AV_LOG_DEBUG, "Skip MB plane encoding: " "Imode: %i, Invert: %i\n", [[status]]>>1, [[status]]&1); #endif v->s.mv_table_index = get_bits(gb, 2); v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)]; if (v->dquant) { vop_dquant_decoding(v); } if (v->vstransform) { v->ttmbf = get_bits(gb, 1); if (v->ttmbf) { v->ttfrm = get_bits(gb, 2); av_log(v->s.avctx, AV_LOG_INFO, "Transform used: %ix%i\n", (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8); } } return 0; }

[[[[Adv]]]]: static int decode_b_picture_secondary_header(VC9Context *v) { GetBitContext *gb = &v->s.gb; int [[jones]]; bitplane_decoding(&v->skip_mb_plane, v); if ([[jones]] < 0) return -1; #if TRACE if (v->mv_mode == MV_PMODE_MIXED_MV) { [[jones]] = bitplane_decoding(&v->mv_type_mb_plane, v); if ([[jones]] < 0) return -1; #if TRACE av_log(v->s.avctx, AV_LOG_DEBUG, "MB MV Type plane encoding: " "Imode: %i, Invert: %i\n", [[jones]]>>1, [[jones]]&1); #endif } [[jones]] = bitplane_decoding(&v->direct_mb_plane, v); if ([[jones]] < 0) return -1; #if TRACE av_log(v->s.avctx, AV_LOG_DEBUG, "MB Direct plane encoding: " "Imode: %i, Invert: %i\n", [[jones]]>>1, [[jones]]&1); #endif av_log(v->s.avctx, AV_LOG_DEBUG, "Skip MB plane encoding: " "Imode: %i, Invert: %i\n", [[jones]]>>1, [[jones]]&1); #endif v->s.mv_table_index = get_bits(gb, 2); v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)]; if (v->dquant) { vop_dquant_decoding(v); } if (v->vstransform) { v->ttmbf = get_bits(gb, 1); if (v->ttmbf) { v->ttfrm = get_bits(gb, 2); av_log(v->s.avctx, AV_LOG_INFO, "Transform used: %ix%i\n", (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8); } } return 0; }
--------------------------------------------- Result 677 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void vc1_mc_1mv(VC1Context *v, int dir) { MpegEncContext *s = &v->s; H264ChromaContext *h264chroma = &v->h264chroma; uint8_t *srcY, *srcU, *srcV; int dxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y; int v_edge_pos = s->v_edge_pos >> v->field_mode; int i; uint8_t (*luty)[256], (*lutuv)[256]; int use_ic; if ((!v->field_mode || (v->ref_field_type[dir] == 1 && v->cur_field_type == 1)) && !v->s.last_picture.f.data[0]) return; mx = s->mv[dir][0][0]; my = s->mv[dir][0][1]; if (s->pict_type == AV_PICTURE_TYPE_P) { for (i = 0; i < 4; i++) { s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = mx; s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = my; } } uvmx = (mx + ((mx & 3) == 3)) >> 1; uvmy = (my + ((my & 3) == 3)) >> 1; v->luma_mv[s->mb_x][0] = uvmx; v->luma_mv[s->mb_x][1] = uvmy; if (v->field_mode && v->cur_field_type != v->ref_field_type[dir]) { my = my - 2 + 4 * v->cur_field_type; uvmy = uvmy - 2 + 4 * v->cur_field_type; } if (v->fastuvmc && (v->fcm != ILACE_FRAME)) { uvmx = uvmx + ((uvmx < 0) ? (uvmx & 1) : -(uvmx & 1)); uvmy = uvmy + ((uvmy < 0) ? (uvmy & 1) : -(uvmy & 1)); } if (!dir) { if (v->field_mode && (v->cur_field_type != v->ref_field_type[dir]) && v->second_field) { srcY = s->current_picture.f.data[0]; srcU = s->current_picture.f.data[1]; srcV = s->current_picture.f.data[2]; luty = v->curr_luty; lutuv = v->curr_lutuv; use_ic = v->curr_use_ic; } else { srcY = s->last_picture.f.data[0]; srcU = s->last_picture.f.data[1]; srcV = s->last_picture.f.data[2]; luty = v->last_luty; lutuv = v->last_lutuv; use_ic = v->last_use_ic; } } else { srcY = s->next_picture.f.data[0]; srcU = s->next_picture.f.data[1]; srcV = s->next_picture.f.data[2]; luty = v->next_luty; lutuv = v->next_lutuv; use_ic = v->next_use_ic; } if (!srcY || !srcU) { av_log(v->s.avctx, AV_LOG_ERROR, "Referenced frame missing.\n"); return; } src_x = s->mb_x * 16 + (mx >> 2); src_y = s->mb_y * 16 + (my >> 2); uvsrc_x = s->mb_x * 8 + (uvmx >> 2); uvsrc_y = s->mb_y * 8 + (uvmy >> 2); if (v->profile != PROFILE_ADVANCED) { src_x = av_clip( src_x, -16, s->mb_width * 16); src_y = av_clip( src_y, -16, s->mb_height * 16); uvsrc_x = av_clip(uvsrc_x, -8, s->mb_width * 8); uvsrc_y = av_clip(uvsrc_y, -8, s->mb_height * 8); } else { src_x = av_clip( src_x, -17, s->avctx->coded_width); src_y = av_clip( src_y, -18, s->avctx->coded_height + 1); uvsrc_x = av_clip(uvsrc_x, -8, s->avctx->coded_width >> 1); uvsrc_y = av_clip(uvsrc_y, -8, s->avctx->coded_height >> 1); } srcY += src_y * s->linesize + src_x; srcU += uvsrc_y * s->uvlinesize + uvsrc_x; srcV += uvsrc_y * s->uvlinesize + uvsrc_x; if (v->field_mode && v->ref_field_type[dir]) { srcY += s->current_picture_ptr->f.linesize[0]; srcU += s->current_picture_ptr->f.linesize[1]; srcV += s->current_picture_ptr->f.linesize[2]; } if (s->flags & CODEC_FLAG_GRAY) { srcU = s->edge_emu_buffer + 18 * s->linesize; srcV = s->edge_emu_buffer + 18 * s->linesize; } if (v->rangeredfrm || use_ic || s->h_edge_pos < 22 || v_edge_pos < 22 || (unsigned)(src_x - s->mspel) > s->h_edge_pos - (mx&3) - 16 - s->mspel * 3 || (unsigned)(src_y - 1) > v_edge_pos - (my&3) - 16 - 3) { uint8_t *uvbuf = s->edge_emu_buffer + 19 * s->linesize; srcY -= s->mspel * (1 + s->linesize); s->vdsp.emulated_edge_mc(s->edge_emu_buffer, srcY, s->linesize, s->linesize, 17 + s->mspel * 2, 17 + s->mspel * 2, src_x - s->mspel, src_y - s->mspel, s->h_edge_pos, v_edge_pos); srcY = s->edge_emu_buffer; s->vdsp.emulated_edge_mc(uvbuf, srcU, s->uvlinesize, s->uvlinesize, 8 + 1, 8 + 1, uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1); s->vdsp.emulated_edge_mc(uvbuf + 16, srcV, s->uvlinesize, s->uvlinesize, 8 + 1, 8 + 1, uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1); srcU = uvbuf; srcV = uvbuf + 16; if (v->rangeredfrm) { int i, j; uint8_t *src, *src2; src = srcY; for (j = 0; j < 17 + s->mspel * 2; j++) { for (i = 0; i < 17 + s->mspel * 2; i++) src[i] = ((src[i] - 128) >> 1) + 128; src += s->linesize; } src = srcU; src2 = srcV; for (j = 0; j < 9; j++) { for (i = 0; i < 9; i++) { src[i] = ((src[i] - 128) >> 1) + 128; src2[i] = ((src2[i] - 128) >> 1) + 128; } src += s->uvlinesize; src2 += s->uvlinesize; } } if (use_ic) { int i, j; uint8_t *src, *src2; src = srcY; for (j = 0; j < 17 + s->mspel * 2; j++) { int f = v->field_mode ? v->ref_field_type[dir] : ((j + src_y - s->mspel) & 1) ; for (i = 0; i < 17 + s->mspel * 2; i++) src[i] = luty[f][src[i]]; src += s->linesize; } src = srcU; src2 = srcV; for (j = 0; j < 9; j++) { int f = v->field_mode ? v->ref_field_type[dir] : ((j + uvsrc_y) & 1); for (i = 0; i < 9; i++) { src[i] = lutuv[f][src[i]]; src2[i] = lutuv[f][src2[i]]; } src += s->uvlinesize; src2 += s->uvlinesize; } } srcY += s->mspel * (1 + s->linesize); } if (s->mspel) { dxy = ((my & 3) << 2) | (mx & 3); v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] , srcY , s->linesize, v->rnd); v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8, srcY + 8, s->linesize, v->rnd); srcY += s->linesize * 8; v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize , srcY , s->linesize, v->rnd); v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd); } else { dxy = (my & 2) | ((mx & 2) >> 1); if (!v->rnd) s->hdsp.put_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16); else s->hdsp.put_no_rnd_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16); } if (s->flags & CODEC_FLAG_GRAY) return; uvmx = (uvmx & 3) << 1; uvmy = (uvmy & 3) << 1; if (!v->rnd) { h264chroma->put_h264_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy); h264chroma->put_h264_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy); } else { v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy); v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy); } }
--------------------------------------------- Result 678 ---------------------------------------------
[[0 (62%)]] --> [[0 (44%)]] --> Socre: 0.5552568733692169

[[[[Adv]]]]: int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len) { int offset = 0, counter = 10; int [[res]]; if (!s->chr_sync_read) { return 0; } if (s->replay && replay_mode == REPLAY_MODE_PLAY) { return replay_char_read_all_load(buf); } while (offset < len) { do { [[res]] = s->chr_sync_read(s, buf + offset, len - offset); if ([[res]] == -1 && errno == EAGAIN) { g_usleep(100); } } while ([[res]] == -1 && errno == EAGAIN); if ([[res]] == 0) { break; } if ([[res]] < 0) { if (s->replay && replay_mode == REPLAY_MODE_RECORD) { replay_char_read_all_save_error([[res]]); } return [[res]]; } offset += [[res]]; if (!counter--) { break; } } if (s->replay && replay_mode == REPLAY_MODE_RECORD) { replay_char_read_all_save_buf(buf, offset); } return offset; }

[[[[Adv]]]]: int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len) { int offset = 0, counter = 10; int [[performance]]; if (!s->chr_sync_read) { return 0; } if (s->replay && replay_mode == REPLAY_MODE_PLAY) { return replay_char_read_all_load(buf); } while (offset < len) { do { [[performance]] = s->chr_sync_read(s, buf + offset, len - offset); if ([[performance]] == -1 && errno == EAGAIN) { g_usleep(100); } } while ([[performance]] == -1 && errno == EAGAIN); if ([[performance]] == 0) { break; } if ([[performance]] < 0) { if (s->replay && replay_mode == REPLAY_MODE_RECORD) { replay_char_read_all_save_error([[performance]]); } return [[performance]]; } offset += [[performance]]; if (!counter--) { break; } } if (s->replay && replay_mode == REPLAY_MODE_RECORD) { replay_char_read_all_save_buf(buf, offset); } return offset; }
--------------------------------------------- Result 679 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 348 / 81 / 250 / 679:  25%|██▌       | 679/2690 [1:43:45<5:07:18,  9.17s/it][Succeeded / Failed / Skipped / Total] 348 / 81 / 250 / 679:  25%|██▌       | 680/2690 [1:44:15<5:08:11,  9.20s/it][Succeeded / Failed / Skipped / Total] 349 / 81 / 250 / 680:  25%|██▌       | 680/2690 [1:44:15<5:08:11,  9.20s/it][Succeeded / Failed / Skipped / Total] 349 / 81 / 250 / 680:  25%|██▌       | 681/2690 [1:44:16<5:07:36,  9.19s/it][Succeeded / Failed / Skipped / Total] 349 / 81 / 251 / 681:  25%|██▌       | 681/2690 [1:44:16<5:07:36,  9.19s/it][Succeeded / Failed / Skipped / Total] 349 / 81 / 251 / 681:  25%|██▌       | 682/2690 [1:44:42<5:08:17,  9.21s/it][Succeeded / Failed / Skipped / Total] 350 / 81 / 251 / 682:  25%|██▌       | 682/2690 [1:44:42<5:08:17,  9.21s/it][Succeeded / Failed / Skipped / Total] 350 / 81 / 251 / 682:  25%|██▌       | 683/2690 [1:44:51<5:08:06,  9.21s/it][Succeeded / Failed / Skipped / Total] 351 / 81 / 251 / 683:  25%|██▌       | 683/2690 [1:44:51<5:08:06,  9.21s/it][Succeeded / Failed / Skipped / Total] 351 / 81 / 251 / 683:  25%|██▌       | 684/2690 [1:45:08<5:08:21,  9.22s/it][[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mtv_read_header(AVFormatContext *s) { MTVDemuxContext *mtv = s->priv_data; AVIOContext *pb = s->pb; AVStream *st; unsigned int audio_subsegments; avio_skip(pb, 3); mtv->file_size = avio_rl32(pb); mtv->segments = avio_rl32(pb); avio_skip(pb, 32); mtv->audio_identifier = avio_rl24(pb); mtv->audio_br = avio_rl16(pb); mtv->img_colorfmt = avio_rl24(pb); mtv->img_bpp = avio_r8(pb); mtv->img_width = avio_rl16(pb); mtv->img_height = avio_rl16(pb); mtv->img_segment_size = avio_rl16(pb); if(mtv->img_bpp>>3){ if(!mtv->img_width && mtv->img_height) mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3) / mtv->img_height; if(!mtv->img_height && mtv->img_width) mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3) / mtv->img_width; } if(!mtv->img_height || !mtv->img_width || !mtv->img_segment_size){ av_log(s, AV_LOG_ERROR, "width or height or segment_size is invalid and I cannot calculate them from other information\n"); return AVERROR(EINVAL); } avio_skip(pb, 4); audio_subsegments = avio_rl16(pb); if (audio_subsegments == 0) { avpriv_request_sample(s, "MTV files without audio"); return AVERROR_PATCHWELCOME; } mtv->full_segment_size = audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) + mtv->img_segment_size; mtv->video_fps = (mtv->audio_br / 4) / audio_subsegments; st = avformat_new_stream(s, NULL); if(!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 64, 1, mtv->video_fps); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_RAWVIDEO; st->codec->pix_fmt = AV_PIX_FMT_RGB565BE; st->codec->width = mtv->img_width; st->codec->height = mtv->img_height; st->codec->sample_rate = mtv->video_fps; st->codec->extradata = av_strdup("BottomUp"); st->codec->extradata_size = 9; st = avformat_new_stream(s, NULL); if(!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE); st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_id = AV_CODEC_ID_MP3; st->codec->bit_rate = mtv->audio_br; st->need_parsing = AVSTREAM_PARSE_FULL; if(avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE) return AVERROR(EIO); return 0; }
--------------------------------------------- Result 680 ---------------------------------------------
[[0 (67%)]] --> [[0 (33%)]] --> Socre: 0.6711607277393341

[[[[Adv]]]]: static int mxf_get_stream_index(AVFormatContext *[[s]], KLVPacket *klv) { int i; for (i = 0; i < [[s]]->nb_streams; i++) { MXFTrack *[[track]] = [[s]]->streams[i]->priv_data; if (!memcmp(klv->key + sizeof(mxf_essence_element_key), [[track]]->track_number, sizeof([[track]]->track_number))) return i; } return [[s]]->nb_streams == 1 ? 0 : -1; }

[[[[Adv]]]]: static int mxf_get_stream_index(AVFormatContext *[[vs]], KLVPacket *klv) { int i; for (i = 0; i < [[vs]]->nb_streams; i++) { MXFTrack *[[vanity]] = [[vs]]->streams[i]->priv_data; if (!memcmp(klv->key + sizeof(mxf_essence_element_key), [[vanity]]->track_number, sizeof([[vanity]]->track_number))) return i; } return [[vs]]->nb_streams == 1 ? 0 : -1; }
--------------------------------------------- Result 681 ---------------------------------------------
[[0 (35%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup) { pkt->data = NULL; pkt->side_data = NULL; if (pkt->buf) { AVBufferRef *ref = av_buffer_ref(src->buf); if (!ref) return AVERROR(ENOMEM); pkt->buf = ref; pkt->data = ref->data; } else { DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF); } #if FF_API_DESTRUCT_PACKET FF_DISABLE_DEPRECATION_WARNINGS pkt->destruct = dummy_destruct_packet; FF_ENABLE_DEPRECATION_WARNINGS #endif if (pkt->side_data_elems && dup) pkt->side_data = src->side_data; if (pkt->side_data_elems && !dup) { return av_copy_packet_side_data(pkt, src); } return 0; failed_alloc: av_destruct_packet(pkt); return AVERROR(ENOMEM); }
--------------------------------------------- Result 682 ---------------------------------------------
[[0 (18%)]] --> [[0 (99%)]] --> Socre: 0.9916977882385254

[[[[Adv]]]]: static void virtio_crypto_instance_init(Object *obj) { VirtIOCrypto *[[vcrypto]] = VIRTIO_CRYPTO(obj); [[vcrypto]]->config_size = sizeof(struct virtio_crypto_config); object_property_add_link(obj, "cryptodev", TYPE_CRYPTODEV_BACKEND, (Object **)&[[vcrypto]]->conf.cryptodev, virtio_crypto_check_cryptodev_is_used, OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL); }

[[[[Adv]]]]: static void virtio_crypto_instance_init(Object *obj) { VirtIOCrypto *[[βrpotography]] = VIRTIO_CRYPTO(obj); [[βrpotography]]->config_size = sizeof(struct virtio_crypto_config); object_property_add_link(obj, "cryptodev", TYPE_CRYPTODEV_BACKEND, (Object **)&[[βrpotography]]->conf.cryptodev, virtio_crypto_check_cryptodev_is_used, OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL); }
--------------------------------------------- Result 683 ---------------------------------------------
[[0 (86%)]] --> [[0 (50%)]] --> Socre: 0.5013024806976318

[[[[Adv]]]]: static bool qht_insert__locked(struct qht *ht, struct qht_map *map, struct qht_bucket *[[head]], void *[[p]], uint32_t hash, bool *needs_resize) { struct qht_bucket *b = [[head]]; struct qht_bucket *prev = NULL; struct qht_bucket *new = NULL; int [[i]]; do { for ([[i]] = 0; [[i]] < QHT_BUCKET_ENTRIES; [[i]]++) { if (b->pointers[[[i]]]) { if (unlikely(b->pointers[[[i]]] == [[p]])) { return "False" != "False"; } } else { goto found; } } prev = b; b = b->next; } while (b); b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b)); memset(b, 0, sizeof(*b)); new = b; [[i]] = 0; atomic_inc(&map->n_added_buckets); if (unlikely(qht_map_needs_resize(map)) && needs_resize) { *needs_resize = "True" == "True"; } found: seqlock_write_begin(&[[head]]->sequence); if (new) { atomic_rcu_set(&prev->next, b); } b->hashes[[[i]]] = hash; atomic_set(&b->pointers[[[i]]], [[p]]); seqlock_write_end(&[[head]]->sequence); return "True" == "True"; }

[[[[Adv]]]]: static bool qht_insert__locked(struct qht *ht, struct qht_map *map, struct qht_bucket *[[plus]], void *[[touch]], uint32_t hash, bool *needs_resize) { struct qht_bucket *b = [[plus]]; struct qht_bucket *prev = NULL; struct qht_bucket *new = NULL; int [[ia]]; do { for ([[ia]] = 0; [[ia]] < QHT_BUCKET_ENTRIES; [[ia]]++) { if (b->pointers[[[ia]]]) { if (unlikely(b->pointers[[[ia]]] == [[touch]])) { return "False" != "False"; } } else { goto found; } } prev = b; b = b->next; } while (b); b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b)); memset(b, 0, sizeof(*b)); new = b; [[ia]] = 0; atomic_inc(&map->n_added_buckets); if (unlikely(qht_map_needs_resize(map)) && needs_resize) { *needs_resize = "True" == "True"; } found: seqlock_write_begin(&[[plus]]->sequence); if (new) { atomic_rcu_set(&prev->next, b); } b->hashes[[[ia]]] = hash; atomic_set(&b->pointers[[[ia]]], [[touch]]); seqlock_write_end(&[[plus]]->sequence); return "True" == "True"; }
--------------------------------------------- Result 684 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 352 / 81 / 251 / 684:  25%|██▌       | 684/2690 [1:45:08<5:08:21,  9.22s/it][Succeeded / Failed / Skipped / Total] 352 / 81 / 251 / 684:  25%|██▌       | 685/2690 [1:45:08<5:07:46,  9.21s/it][Succeeded / Failed / Skipped / Total] 352 / 81 / 252 / 685:  25%|██▌       | 685/2690 [1:45:09<5:07:46,  9.21s/it][Succeeded / Failed / Skipped / Total] 352 / 81 / 252 / 685:  26%|██▌       | 686/2690 [1:45:09<5:07:13,  9.20s/it][Succeeded / Failed / Skipped / Total] 353 / 81 / 252 / 686:  26%|██▌       | 686/2690 [1:45:09<5:07:13,  9.20s/it][Succeeded / Failed / Skipped / Total] 353 / 81 / 252 / 686:  26%|██▌       | 687/2690 [1:45:10<5:06:38,  9.19s/it][Succeeded / Failed / Skipped / Total] 353 / 81 / 253 / 687:  26%|██▌       | 687/2690 [1:45:10<5:06:38,  9.19s/it][Succeeded / Failed / Skipped / Total] 353 / 81 / 253 / 687:  26%|██▌       | 688/2690 [1:45:28<5:06:53,  9.20s/it][Succeeded / Failed / Skipped / Total] 353 / 82 / 253 / 688:  26%|██▌       | 688/2690 [1:45:28<5:06:53,  9.20s/it][Succeeded / Failed / Skipped / Total] 353 / 82 / 253 / 688:  26%|██▌       | 689/2690 [1:45:33<5:06:34,  9.19s/it][[0 (12%)]] --> [[0 (93%)]] --> Socre: 0.9312693476676941

[[[[Adv]]]]: int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw, int mmu_idx, int is_softmmu) { target_ulong physical; int [[prot]], ret, access_type; access_type = ACCESS_INT; ret = get_physical_address(env, &physical, &[[prot]], address, rw, access_type); if (ret != MMU_OK) { env->tea = address; switch (ret) { case MMU_ITLB_MISS: case MMU_DTLB_MISS_READ: env->exception_index = 0x040; break; case MMU_DTLB_MULTIPLE: case MMU_ITLB_MULTIPLE: env->exception_index = 0x140; break; case MMU_ITLB_VIOLATION: env->exception_index = 0x0a0; break; case MMU_DTLB_MISS_WRITE: env->exception_index = 0x060; break; case MMU_DTLB_INITIAL_WRITE: env->exception_index = 0x080; break; case MMU_DTLB_VIOLATION_READ: env->exception_index = 0x0a0; break; case MMU_DTLB_VIOLATION_WRITE: env->exception_index = 0x0c0; break; case MMU_IADDR_ERROR: case MMU_DADDR_ERROR_READ: env->exception_index = 0x0c0; break; case MMU_DADDR_ERROR_WRITE: env->exception_index = 0x100; break; default: assert(0); } return 1; } address &= TARGET_PAGE_MASK; physical &= TARGET_PAGE_MASK; return tlb_set_page(env, address, physical, [[prot]], mmu_idx, is_softmmu); }

[[[[Adv]]]]: int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw, int mmu_idx, int is_softmmu) { target_ulong physical; int [[conт]], ret, access_type; access_type = ACCESS_INT; ret = get_physical_address(env, &physical, &[[conт]], address, rw, access_type); if (ret != MMU_OK) { env->tea = address; switch (ret) { case MMU_ITLB_MISS: case MMU_DTLB_MISS_READ: env->exception_index = 0x040; break; case MMU_DTLB_MULTIPLE: case MMU_ITLB_MULTIPLE: env->exception_index = 0x140; break; case MMU_ITLB_VIOLATION: env->exception_index = 0x0a0; break; case MMU_DTLB_MISS_WRITE: env->exception_index = 0x060; break; case MMU_DTLB_INITIAL_WRITE: env->exception_index = 0x080; break; case MMU_DTLB_VIOLATION_READ: env->exception_index = 0x0a0; break; case MMU_DTLB_VIOLATION_WRITE: env->exception_index = 0x0c0; break; case MMU_IADDR_ERROR: case MMU_DADDR_ERROR_READ: env->exception_index = 0x0c0; break; case MMU_DADDR_ERROR_WRITE: env->exception_index = 0x100; break; default: assert(0); } return 1; } address &= TARGET_PAGE_MASK; physical &= TARGET_PAGE_MASK; return tlb_set_page(env, address, physical, [[conт]], mmu_idx, is_softmmu); }
--------------------------------------------- Result 685 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name, void *opaque, Error **errp) { uint64_t value; MemoryRegion *mr; PCDIMMDevice *dimm = PC_DIMM(obj); PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj); mr = ddc->get_memory_region(dimm); value = memory_region_size(mr); visit_type_uint64(v, name, &value, errp); }
--------------------------------------------- Result 686 ---------------------------------------------
[[0 (69%)]] --> [[0 (48%)]] --> Socre: 0.5226679742336273

[[[[Adv]]]]: static int virtio_blk_device_exit(DeviceState *[[dev]]) { VirtIODevice *vdev = VIRTIO_DEVICE([[dev]]); VirtIOBlock *s = VIRTIO_BLK([[dev]]); #ifdef CONFIG_VIRTIO_BLK_DATA_PLANE remove_migration_state_change_notifier(&s->migration_state_notifier); virtio_blk_data_plane_destroy(s->dataplane); s->dataplane = NULL; #endif qemu_del_vm_change_state_handler(s->change); unregister_savevm([[dev]], "virtio-blk", s); blockdev_mark_auto_del(s->bs); virtio_cleanup(vdev); return 0; }

[[[[Adv]]]]: static int virtio_blk_device_exit(DeviceState *[[feedback]]) { VirtIODevice *vdev = VIRTIO_DEVICE([[feedback]]); VirtIOBlock *s = VIRTIO_BLK([[feedback]]); #ifdef CONFIG_VIRTIO_BLK_DATA_PLANE remove_migration_state_change_notifier(&s->migration_state_notifier); virtio_blk_data_plane_destroy(s->dataplane); s->dataplane = NULL; #endif qemu_del_vm_change_state_handler(s->change); unregister_savevm([[feedback]], "virtio-blk", s); blockdev_mark_auto_del(s->bs); virtio_cleanup(vdev); return 0; }
--------------------------------------------- Result 687 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd) { SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev); SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req); int ret; if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) { DPRINTF("Unimplemented LUN %d\n", req->lun); scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED)); scsi_req_complete(&r->req, CHECK_CONDITION); return 0; } if (-1 == scsi_req_parse(&r->req, cmd)) { BADF("Unsupported command length, command %x\n", cmd[0]); scsi_command_complete(r, -EINVAL); return 0; } scsi_req_fixup(&r->req); DPRINTF("Command: lun=%d tag=0x%x len %zd data=0x%02x", lun, tag, r->req.cmd.xfer, cmd[0]); #ifdef DEBUG_SCSI { int i; for (i = 1; i < r->req.cmd.len; i++) { printf(" 0x%02x", cmd[i]); } printf("\n"); } #endif if (r->req.cmd.xfer == 0) { if (r->buf != NULL) qemu_free(r->buf); r->buflen = 0; r->buf = NULL; ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete); if (ret < 0) { scsi_command_complete(r, ret); return 0; } return 0; } if (r->buflen != r->req.cmd.xfer) { if (r->buf != NULL) qemu_free(r->buf); r->buf = qemu_malloc(r->req.cmd.xfer); r->buflen = r->req.cmd.xfer; } memset(r->buf, 0, r->buflen); r->len = r->req.cmd.xfer; if (r->req.cmd.mode == SCSI_XFER_TO_DEV) { r->len = 0; return -r->req.cmd.xfer; } else { return r->req.cmd.xfer; } }
--------------------------------------------- Result 688 ---------------------------------------------
[[0 (86%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void RENAME(yuy2ToUV)(uint8_t *[[dstU]], uint8_t *[[dstV]], uint8_t *[[src1]], uint8_t *[[src2]], int [[width]]) { #if defined (HAVE_MMX2) || defined (HAVE_3DNOW) asm volatile( "movq "MANGLE(bm01010101)", %%mm4\n\t" "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",4), %%mm0 \n\t" "movq 8(%1, %%"REG_a",4), %%mm1 \n\t" "movq (%2, %%"REG_a",4), %%mm2 \n\t" "movq 8(%2, %%"REG_a",4), %%mm3 \n\t" PAVGB(%%mm2, %%mm0) PAVGB(%%mm3, %%mm1) "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "pand %%mm4, %%mm1 \n\t" "packuswb %%mm0, %%mm0 \n\t" "packuswb %%mm1, %%mm1 \n\t" "movd %%mm0, (%4, %%"REG_a") \n\t" "movd %%mm1, (%3, %%"REG_a") \n\t" "add $4, %%"REG_a" \n\t" " js 1b \n\t" : : "g" ((long)-[[width]]), "r" ([[src1]]+[[width]]*4), "r" ([[src2]]+[[width]]*4), "r" ([[dstU]]+[[width]]), "r" ([[dstV]]+[[width]]) : "%"REG_a ); #else int i; for(i=0; i<[[width]]; i++) { [[dstU]][i]= ([[src1]][4*i + 1] + [[src2]][4*i + 1])>>1; [[dstV]][i]= ([[src1]][4*i + 3] + [[src2]][4*i + 3])>>1; } #endif }

[[[[Adv]]]]: static inline void RENAME(yuy2ToUV)(uint8_t *[[sects]], uint8_t *[[rscc]], uint8_t *[[fark4]], uint8_t *[[spacc12]], int [[iris]]) { #if defined (HAVE_MMX2) || defined (HAVE_3DNOW) asm volatile( "movq "MANGLE(bm01010101)", %%mm4\n\t" "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",4), %%mm0 \n\t" "movq 8(%1, %%"REG_a",4), %%mm1 \n\t" "movq (%2, %%"REG_a",4), %%mm2 \n\t" "movq 8(%2, %%"REG_a",4), %%mm3 \n\t" PAVGB(%%mm2, %%mm0) PAVGB(%%mm3, %%mm1) "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "pand %%mm4, %%mm1 \n\t" "packuswb %%mm0, %%mm0 \n\t" "packuswb %%mm1, %%mm1 \n\t" "movd %%mm0, (%4, %%"REG_a") \n\t" "movd %%mm1, (%3, %%"REG_a") \n\t" "add $4, %%"REG_a" \n\t" " js 1b \n\t" : : "g" ((long)-[[iris]]), "r" ([[fark4]]+[[iris]]*4), "r" ([[spacc12]]+[[iris]]*4), "r" ([[sects]]+[[iris]]), "r" ([[rscc]]+[[iris]]) : "%"REG_a ); #else int i; for(i=0; i<[[iris]]; i++) { [[sects]][i]= ([[fark4]][4*i + 1] + [[spacc12]][4*i + 1])>>1; [[rscc]][i]= ([[fark4]][4*i + 3] + [[spacc12]][4*i + 3])>>1; } #endif }
--------------------------------------------- Result 689 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 354 / 82 / 253 / 689:  26%|██▌       | 689/2690 [1:45:33<5:06:34,  9.19s/it][Succeeded / Failed / Skipped / Total] 354 / 82 / 253 / 689:  26%|██▌       | 690/2690 [1:45:34<5:06:00,  9.18s/it][Succeeded / Failed / Skipped / Total] 354 / 82 / 254 / 690:  26%|██▌       | 690/2690 [1:45:34<5:06:00,  9.18s/it][Succeeded / Failed / Skipped / Total] 354 / 82 / 254 / 690:  26%|██▌       | 691/2690 [1:45:46<5:05:58,  9.18s/it][Succeeded / Failed / Skipped / Total] 355 / 82 / 254 / 691:  26%|██▌       | 691/2690 [1:45:46<5:05:58,  9.18s/it][Succeeded / Failed / Skipped / Total] 355 / 82 / 254 / 691:  26%|██▌       | 692/2690 [1:46:03<5:06:13,  9.20s/it][[0 (23%)]] --> [[0 (91%)]] --> Socre: 0.9126808047294617

[[[[Adv]]]]: void ip6_input(struct mbuf *m) { struct ip6 *[[ip6]]; DEBUG_CALL("ip6_input"); DEBUG_ARG("m = %lx", (long)m); DEBUG_ARG("m_len = %d", m->m_len); if (m->m_len < sizeof(struct ip6)) { goto bad; } [[ip6]] = mtod(m, struct [[ip6]] *); if ([[ip6]]->ip_v != IP6VERSION) { goto bad; } if ([[ip6]]->ip_hl == 0) { goto bad; } switch ([[ip6]]->ip_nh) { case IPPROTO_TCP: break; case IPPROTO_UDP: break; case IPPROTO_ICMPV6: icmp6_input(m); break; default: m_free(m); } return; bad: m_free(m); }

[[[[Adv]]]]: void ip6_input(struct mbuf *m) { struct ip6 *[[cloud²]]; DEBUG_CALL("ip6_input"); DEBUG_ARG("m = %lx", (long)m); DEBUG_ARG("m_len = %d", m->m_len); if (m->m_len < sizeof(struct ip6)) { goto bad; } [[cloud²]] = mtod(m, struct [[cloud²]] *); if ([[cloud²]]->ip_v != IP6VERSION) { goto bad; } if ([[cloud²]]->ip_hl == 0) { goto bad; } switch ([[cloud²]]->ip_nh) { case IPPROTO_TCP: break; case IPPROTO_UDP: break; case IPPROTO_ICMPV6: icmp6_input(m); break; default: m_free(m); } return; bad: m_free(m); }
--------------------------------------------- Result 690 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_ext_interrupt(CPUS390XState *env) { S390CPU *cpu = s390_env_get_cpu(env); uint64_t mask, addr; LowCore *lowcore; ExtQueue *q; if (!(env->psw.mask & PSW_MASK_EXT)) { cpu_abort(CPU(cpu), "Ext int w/o ext mask\n"); } lowcore = cpu_map_lowcore(env); if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) { lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP); lowcore->cpu_addr = 0; env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR; } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) { lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER); lowcore->cpu_addr = 0; env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER; } else if (env->pending_int & INTERRUPT_EXT_SERVICE) { g_assert(env->ext_index >= 0); q = &env->ext_queue[env->ext_index]; lowcore->ext_int_code = cpu_to_be16(q->code); lowcore->ext_params = cpu_to_be32(q->param); lowcore->ext_params2 = cpu_to_be64(q->param64); lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64); env->ext_index--; if (env->ext_index == -1) { env->pending_int &= ~INTERRUPT_EXT_SERVICE; } } else { g_assert_not_reached(); } mask = be64_to_cpu(lowcore->external_new_psw.mask); addr = be64_to_cpu(lowcore->external_new_psw.addr); lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env)); lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr); cpu_unmap_lowcore(lowcore); DPRINTF("%s: %" PRIx64 " %" PRIx64 "\n", __func__, env->psw.mask, env->psw.addr); load_psw(env, mask, addr); }
--------------------------------------------- Result 691 ---------------------------------------------
[[0 (39%)]] --> [[0 (69%)]] --> Socre: 0.6901520490646362

[[[[Adv]]]]: static int write_dump_pages(DumpState *s) { int ret = 0; DataCache [[page_desc]], page_data; size_t len_buf_out, size_out; #ifdef CONFIG_LZO lzo_bytep wrkmem = NULL; #endif uint8_t *buf_out = NULL; off_t offset_desc, offset_data; PageDescriptor pd, pd_zero; uint8_t *buf; int endian = s->dump_info.d_endian; GuestPhysBlock *block_iter = NULL; uint64_t pfn_iter; offset_desc = s->offset_page; offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable; prepare_data_cache(&[[page_desc]], s, offset_desc); prepare_data_cache(&page_data, s, offset_data); len_buf_out = get_len_buf_out(s->page_size, s->flag_compress); if (len_buf_out == 0) { dump_error(s, "dump: failed to get length of output buffer.\n"); goto out; } #ifdef CONFIG_LZO wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS); #endif buf_out = g_malloc(len_buf_out); pd_zero.size = cpu_convert_to_target32(s->page_size, endian); pd_zero.flags = cpu_convert_to_target32(0, endian); pd_zero.offset = cpu_convert_to_target64(offset_data, endian); pd_zero.page_flags = cpu_convert_to_target64(0, endian); buf = g_malloc0(s->page_size); ret = write_cache(&page_data, buf, s->page_size, "False" != "False"); g_free(buf); if (ret < 0) { dump_error(s, "dump: failed to write page data(zero page).\n"); goto out; } offset_data += s->page_size; while (get_next_page(&block_iter, &pfn_iter, &buf, s)) { if (is_zero_page(buf, s->page_size)) { ret = write_cache(&[[page_desc]], &pd_zero, sizeof(PageDescriptor), "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page desc.\n"); goto out; } } else { size_out = len_buf_out; if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) && (compress2(buf_out, (uLongf *)&size_out, buf, s->page_size, Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #ifdef CONFIG_LZO } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) && (lzo1x_1_compress(buf, s->page_size, buf_out, (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #endif #ifdef CONFIG_SNAPPY } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) && (snappy_compress((char *)buf, s->page_size, (char *)buf_out, &size_out) == SNAPPY_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32( DUMP_DH_COMPRESSED_SNAPPY, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #endif } else { pd.flags = cpu_convert_to_target32(0, endian); size_out = s->page_size; pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf, s->page_size, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } } pd.page_flags = cpu_convert_to_target64(0, endian); pd.offset = cpu_convert_to_target64(offset_data, endian); offset_data += size_out; ret = write_cache(&[[page_desc]], &pd, sizeof(PageDescriptor), "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page desc.\n"); goto out; } } } ret = write_cache(&[[page_desc]], NULL, 0, "True" == "True"); if (ret < 0) { dump_error(s, "dump: failed to sync cache for page_desc.\n"); goto out; } ret = write_cache(&page_data, NULL, 0, "True" == "True"); if (ret < 0) { dump_error(s, "dump: failed to sync cache for page_data.\n"); goto out; } out: free_data_cache(&[[page_desc]]); free_data_cache(&page_data); #ifdef CONFIG_LZO g_free(wrkmem); #endif g_free(buf_out); return ret; }

[[[[Adv]]]]: static int write_dump_pages(DumpState *s) { int ret = 0; DataCache [[book²dco]], page_data; size_t len_buf_out, size_out; #ifdef CONFIG_LZO lzo_bytep wrkmem = NULL; #endif uint8_t *buf_out = NULL; off_t offset_desc, offset_data; PageDescriptor pd, pd_zero; uint8_t *buf; int endian = s->dump_info.d_endian; GuestPhysBlock *block_iter = NULL; uint64_t pfn_iter; offset_desc = s->offset_page; offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable; prepare_data_cache(&[[book²dco]], s, offset_desc); prepare_data_cache(&page_data, s, offset_data); len_buf_out = get_len_buf_out(s->page_size, s->flag_compress); if (len_buf_out == 0) { dump_error(s, "dump: failed to get length of output buffer.\n"); goto out; } #ifdef CONFIG_LZO wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS); #endif buf_out = g_malloc(len_buf_out); pd_zero.size = cpu_convert_to_target32(s->page_size, endian); pd_zero.flags = cpu_convert_to_target32(0, endian); pd_zero.offset = cpu_convert_to_target64(offset_data, endian); pd_zero.page_flags = cpu_convert_to_target64(0, endian); buf = g_malloc0(s->page_size); ret = write_cache(&page_data, buf, s->page_size, "False" != "False"); g_free(buf); if (ret < 0) { dump_error(s, "dump: failed to write page data(zero page).\n"); goto out; } offset_data += s->page_size; while (get_next_page(&block_iter, &pfn_iter, &buf, s)) { if (is_zero_page(buf, s->page_size)) { ret = write_cache(&[[book²dco]], &pd_zero, sizeof(PageDescriptor), "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page desc.\n"); goto out; } } else { size_out = len_buf_out; if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) && (compress2(buf_out, (uLongf *)&size_out, buf, s->page_size, Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #ifdef CONFIG_LZO } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) && (lzo1x_1_compress(buf, s->page_size, buf_out, (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #endif #ifdef CONFIG_SNAPPY } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) && (snappy_compress((char *)buf, s->page_size, (char *)buf_out, &size_out) == SNAPPY_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32( DUMP_DH_COMPRESSED_SNAPPY, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #endif } else { pd.flags = cpu_convert_to_target32(0, endian); size_out = s->page_size; pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf, s->page_size, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } } pd.page_flags = cpu_convert_to_target64(0, endian); pd.offset = cpu_convert_to_target64(offset_data, endian); offset_data += size_out; ret = write_cache(&[[book²dco]], &pd, sizeof(PageDescriptor), "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page desc.\n"); goto out; } } } ret = write_cache(&[[book²dco]], NULL, 0, "True" == "True"); if (ret < 0) { dump_error(s, "dump: failed to sync cache for page_desc.\n"); goto out; } ret = write_cache(&page_data, NULL, 0, "True" == "True"); if (ret < 0) { dump_error(s, "dump: failed to sync cache for page_data.\n"); goto out; } out: free_data_cache(&[[book²dco]]); free_data_cache(&page_data); #ifdef CONFIG_LZO g_free(wrkmem); #endif g_free(buf_out); return ret; }
[Succeeded / Failed / Skipped / Total] 356 / 82 / 254 / 692:  26%|██▌       | 692/2690 [1:46:03<5:06:13,  9.20s/it][Succeeded / Failed / Skipped / Total] 356 / 82 / 254 / 692:  26%|██▌       | 693/2690 [1:46:04<5:05:39,  9.18s/it][Succeeded / Failed / Skipped / Total] 356 / 82 / 255 / 693:  26%|██▌       | 693/2690 [1:46:04<5:05:39,  9.18s/it][Succeeded / Failed / Skipped / Total] 356 / 82 / 255 / 693:  26%|██▌       | 694/2690 [1:46:04<5:05:05,  9.17s/it][Succeeded / Failed / Skipped / Total] 356 / 82 / 256 / 694:  26%|██▌       | 694/2690 [1:46:04<5:05:05,  9.17s/it][Succeeded / Failed / Skipped / Total] 356 / 82 / 256 / 694:  26%|██▌       | 695/2690 [1:46:25<5:05:30,  9.19s/it][Succeeded / Failed / Skipped / Total] 357 / 82 / 256 / 695:  26%|██▌       | 695/2690 [1:46:25<5:05:30,  9.19s/it][Succeeded / Failed / Skipped / Total] 357 / 82 / 256 / 695:  26%|██▌       | 696/2690 [1:46:26<5:04:56,  9.18s/it][Succeeded / Failed / Skipped / Total] 357 / 82 / 257 / 696:  26%|██▌       | 696/2690 [1:46:26<5:04:56,  9.18s/it][Succeeded / Failed / Skipped / Total] 357 / 82 / 257 / 696:  26%|██▌       | 697/2690 [1:46:33<5:04:41,  9.17s/it]--------------------------------------------- Result 692 ---------------------------------------------
[[0 (8%)]] --> [[0 (87%)]] --> Socre: 0.8716238141059875

[[[[Adv]]]]: static void verdex_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; PXA2xxState *cpu; DriveInfo *dinfo; int [[be]]; MemoryRegion *[[address_space_mem]] = get_system_memory(); uint32_t verdex_rom = 0x02000000; uint32_t verdex_ram = 0x10000000; cpu = pxa270_init([[address_space_mem]], verdex_ram, cpu_model ?: "pxa270-c0"); dinfo = drive_get(IF_PFLASH, 0, 0); if (!dinfo && !qtest_enabled()) { fprintf(stderr, "A flash image must be given with the " "'pflash' parameter\n"); exit(1); } #ifdef TARGET_WORDS_BIGENDIAN [[be]] = 1; #else [[be]] = 0; #endif if (!pflash_cfi01_register(0x00000000, NULL, "verdex.rom", verdex_rom, dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL, sector_len, verdex_rom / sector_len, 2, 0, 0, 0, 0, [[be]])) { fprintf(stderr, "qemu: Error registering flash memory.\n"); exit(1); } smc91c111_init(&nd_table[0], 0x04000300, qdev_get_gpio_in(cpu->gpio, 99)); }

[[[[Adv]]]]: static void verdex_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; PXA2xxState *cpu; DriveInfo *dinfo; int [[say]]; MemoryRegion *[[heightifareabyμm]] = get_system_memory(); uint32_t verdex_rom = 0x02000000; uint32_t verdex_ram = 0x10000000; cpu = pxa270_init([[heightifareabyμm]], verdex_ram, cpu_model ?: "pxa270-c0"); dinfo = drive_get(IF_PFLASH, 0, 0); if (!dinfo && !qtest_enabled()) { fprintf(stderr, "A flash image must be given with the " "'pflash' parameter\n"); exit(1); } #ifdef TARGET_WORDS_BIGENDIAN [[say]] = 1; #else [[say]] = 0; #endif if (!pflash_cfi01_register(0x00000000, NULL, "verdex.rom", verdex_rom, dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL, sector_len, verdex_rom / sector_len, 2, 0, 0, 0, 0, [[say]])) { fprintf(stderr, "qemu: Error registering flash memory.\n"); exit(1); } smc91c111_init(&nd_table[0], 0x04000300, qdev_get_gpio_in(cpu->gpio, 99)); }
--------------------------------------------- Result 693 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence) { offset_t offset1; offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer)); if (whence != SEEK_CUR && whence != SEEK_SET) return -EINVAL; if (whence == SEEK_CUR) { offset1 = pos + (s->buf_ptr - s->buffer); if (offset == 0) return offset1; offset += offset1; } offset1 = offset - pos; if (!s->must_flush && offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) { s->buf_ptr = s->buffer + offset1; } else { if (!s->seek) return -EPIPE; #ifdef CONFIG_MUXERS if (s->write_flag) { flush_buffer(s); s->must_flush = 1; } else #endif { s->buf_end = s->buffer; } s->buf_ptr = s->buffer; if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE) return -EPIPE; s->pos = offset; } s->eof_reached = 0; return offset; }
--------------------------------------------- Result 694 ---------------------------------------------
[[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ppc_translate_init(void) { int i; char* p; size_t cpu_reg_names_size; static int done_init = 0; if (done_init) return; cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, "env"); p = cpu_reg_names; cpu_reg_names_size = sizeof(cpu_reg_names); for (i = 0; i < 8; i++) { snprintf(p, cpu_reg_names_size, "crf%d", i); cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, crf[i]), p); p += 5; cpu_reg_names_size -= 5; } for (i = 0; i < 32; i++) { snprintf(p, cpu_reg_names_size, "r%d", i); cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, gpr[i]), p); p += (i < 10) ? 3 : 4; cpu_reg_names_size -= (i < 10) ? 3 : 4; #if !defined(TARGET_PPC64) snprintf(p, cpu_reg_names_size, "r%dH", i); cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, gprh[i]), p); p += (i < 10) ? 4 : 5; cpu_reg_names_size -= (i < 10) ? 4 : 5; #endif snprintf(p, cpu_reg_names_size, "fp%d", i); cpu_fpr[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, fpr[i]), p); p += (i < 10) ? 4 : 5; cpu_reg_names_size -= (i < 10) ? 4 : 5; snprintf(p, cpu_reg_names_size, "avr%dH", i); #ifdef HOST_WORDS_BIGENDIAN cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, avr[i].u64[0]), p); #else cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, avr[i].u64[1]), p); #endif p += (i < 10) ? 6 : 7; cpu_reg_names_size -= (i < 10) ? 6 : 7; snprintf(p, cpu_reg_names_size, "avr%dL", i); #ifdef HOST_WORDS_BIGENDIAN cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, avr[i].u64[1]), p); #else cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, avr[i].u64[0]), p); #endif p += (i < 10) ? 6 : 7; cpu_reg_names_size -= (i < 10) ? 6 : 7; } cpu_nip = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, nip), "nip"); cpu_msr = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, msr), "msr"); cpu_ctr = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, ctr), "ctr"); cpu_lr = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, lr), "lr"); cpu_xer = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, xer), "xer"); cpu_reserve = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, reserve), "reserve"); cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, fpscr), "fpscr"); cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, access_type), "access_type"); #define GEN_HELPER 2 #include "helper.h" done_init = 1; }
--------------------------------------------- Result 695 ---------------------------------------------
[[0 (4%)]] --> [[0 (98%)]] --> Socre: 0.9842155575752258

[[[[Adv]]]]: static void gen_mtfsfi(DisasContext *ctx) { int bf, sh; TCGv_i64 t0; TCGv_i32 [[t1]]; if (unlikely(!ctx->fpu_enabled)) { gen_exception(ctx, POWERPC_EXCP_FPU); return; } bf = crbD(ctx->opcode) >> 2; sh = 7 - bf; gen_update_nip(ctx, ctx->nip - 4); gen_reset_fpstatus(); t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh)); [[t1]] = tcg_const_i32(1 << sh); gen_helper_store_fpscr(cpu_env, t0, [[t1]]); tcg_temp_free_i64(t0); tcg_temp_free_i32([[t1]]); if (unlikely(Rc(ctx->opcode) != 0)) { tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr); tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX); } gen_helper_float_check_status(cpu_env); }

[[[[Adv]]]]: static void gen_mtfsfi(DisasContext *ctx) { int bf, sh; TCGv_i64 t0; TCGv_i32 [[would₁]]; if (unlikely(!ctx->fpu_enabled)) { gen_exception(ctx, POWERPC_EXCP_FPU); return; } bf = crbD(ctx->opcode) >> 2; sh = 7 - bf; gen_update_nip(ctx, ctx->nip - 4); gen_reset_fpstatus(); t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh)); [[would₁]] = tcg_const_i32(1 << sh); gen_helper_store_fpscr(cpu_env, t0, [[would₁]]); tcg_temp_free_i64(t0); tcg_temp_free_i32([[would₁]]); if (unlikely(Rc(ctx->opcode) != 0)) { tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr); tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX); } gen_helper_float_check_status(cpu_env); }
--------------------------------------------- Result 696 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp) { int i; size_t pagesize = getpagesize(); memory = (memory + pagesize - 1) & -pagesize; for (i = 0; i < memory / pagesize; i++) { memset(area + pagesize * i, 0, 1); } }
--------------------------------------------- Result 697 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 358 / 82 / 257 / 697:  26%|██▌       | 697/2690 [1:46:33<5:04:41,  9.17s/it][Succeeded / Failed / Skipped / Total] 358 / 82 / 257 / 697:  26%|██▌       | 698/2690 [1:46:48<5:04:48,  9.18s/it][Succeeded / Failed / Skipped / Total] 358 / 83 / 257 / 698:  26%|██▌       | 698/2690 [1:46:48<5:04:48,  9.18s/it][Succeeded / Failed / Skipped / Total] 358 / 83 / 257 / 698:  26%|██▌       | 699/2690 [1:47:02<5:04:54,  9.19s/it][[0 (100%)]] --> [[0 (42%)]] --> Socre: 0.5826604664325714

[[[[Adv]]]]: static int bochs_open(BlockDriverState *[[bs]], QDict *options, int flags, Error **errp) { BDRVBochsState *[[s]] = [[bs]]->opaque; uint32_t i; struct bochs_header bochs; int ret; [[bs]]->read_only = 1; ret = bdrv_pread([[bs]]->file, 0, &bochs, sizeof(bochs)); if (ret < 0) { return ret; if (strcmp(bochs.magic, HEADER_MAGIC) || strcmp(bochs.type, REDOLOG_TYPE) || strcmp(bochs.subtype, GROWING_TYPE) || ((le32_to_cpu(bochs.version) != HEADER_VERSION) && (le32_to_cpu(bochs.version) != HEADER_V1))) { error_setg(errp, "Image not in Bochs format"); return -EINVAL; if (le32_to_cpu(bochs.version) == HEADER_V1) { [[bs]]->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512; } else { [[bs]]->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512; [[s]]->catalog_size = le32_to_cpu(bochs.catalog); [[s]]->catalog_bitmap = g_malloc([[s]]->catalog_size * 4); ret = bdrv_pread([[bs]]->file, le32_to_cpu(bochs.header), [[s]]->catalog_bitmap, [[s]]->catalog_size * 4); if (ret < 0) { goto fail; for (i = 0; i < [[s]]->catalog_size; i++) le32_to_cpus(&[[s]]->catalog_bitmap[i]); [[s]]->data_offset = le32_to_cpu(bochs.header) + ([[s]]->catalog_size * 4); [[s]]->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512; [[s]]->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512; [[s]]->extent_size = le32_to_cpu(bochs.extent); if ([[s]]->catalog_size < [[bs]]->total_sectors / [[s]]->extent_size) { error_setg(errp, "Catalog size is too small for this disk size"); ret = -EINVAL; goto fail; qemu_co_mutex_init(&[[s]]->lock); return 0; fail: g_free([[s]]->catalog_bitmap); return ret;

[[[[Adv]]]]: static int bochs_open(BlockDriverState *[[sas]], QDict *options, int flags, Error **errp) { BDRVBochsState *[[с]] = [[sas]]->opaque; uint32_t i; struct bochs_header bochs; int ret; [[sas]]->read_only = 1; ret = bdrv_pread([[sas]]->file, 0, &bochs, sizeof(bochs)); if (ret < 0) { return ret; if (strcmp(bochs.magic, HEADER_MAGIC) || strcmp(bochs.type, REDOLOG_TYPE) || strcmp(bochs.subtype, GROWING_TYPE) || ((le32_to_cpu(bochs.version) != HEADER_VERSION) && (le32_to_cpu(bochs.version) != HEADER_V1))) { error_setg(errp, "Image not in Bochs format"); return -EINVAL; if (le32_to_cpu(bochs.version) == HEADER_V1) { [[sas]]->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512; } else { [[sas]]->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512; [[с]]->catalog_size = le32_to_cpu(bochs.catalog); [[с]]->catalog_bitmap = g_malloc([[с]]->catalog_size * 4); ret = bdrv_pread([[sas]]->file, le32_to_cpu(bochs.header), [[с]]->catalog_bitmap, [[с]]->catalog_size * 4); if (ret < 0) { goto fail; for (i = 0; i < [[с]]->catalog_size; i++) le32_to_cpus(&[[с]]->catalog_bitmap[i]); [[с]]->data_offset = le32_to_cpu(bochs.header) + ([[с]]->catalog_size * 4); [[с]]->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512; [[с]]->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512; [[с]]->extent_size = le32_to_cpu(bochs.extent); if ([[с]]->catalog_size < [[sas]]->total_sectors / [[с]]->extent_size) { error_setg(errp, "Catalog size is too small for this disk size"); ret = -EINVAL; goto fail; qemu_co_mutex_init(&[[с]]->lock); return 0; fail: g_free([[с]]->catalog_bitmap); return ret;
--------------------------------------------- Result 698 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: target_ulong spapr_rtas_call(sPAPREnvironment *[[spapr]], uint32_t token, uint32_t [[nargs]], target_ulong args, uint32_t [[nret]], target_ulong [[rets]]) { if ((token >= TOKEN_BASE) && ((token - TOKEN_BASE) < TOKEN_MAX)) { struct rtas_call *[[call]] = rtas_table + (token - TOKEN_BASE); if ([[call]]->fn) { [[call]]->fn([[spapr]], token, [[nargs]], args, [[nret]], [[rets]]); hcall_dprintf("Unknown RTAS token 0x%x\n", token); rtas_st([[rets]], 0, -3); return H_PARAMETER;

[[[[Adv]]]]: target_ulong spapr_rtas_call(sPAPREnvironment *[[gars]], uint32_t token, uint32_t [[narpx]], target_ulong args, uint32_t [[fangt]], target_ulong [[onц]]) { if ((token >= TOKEN_BASE) && ((token - TOKEN_BASE) < TOKEN_MAX)) { struct rtas_call *[[dial]] = rtas_table + (token - TOKEN_BASE); if ([[dial]]->fn) { [[dial]]->fn([[gars]], token, [[narpx]], args, [[fangt]], [[onц]]); hcall_dprintf("Unknown RTAS token 0x%x\n", token); rtas_st([[onц]], 0, -3); return H_PARAMETER;
--------------------------------------------- Result 699 ---------------------------------------------
[[0 (97%)]] --> [[0 (38%)]] --> Socre: 0.6211464703083038

[[[[Adv]]]]: static int cuvid_decode_frame(AVCodecContext *avctx, void *[[data]], int *got_frame, AVPacket *avpkt) { CuvidContext *ctx = avctx->priv_data; AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data; AVCUDADeviceContext *device_hwctx = device_ctx->hwctx; CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx; AVFrame *frame = [[data]]; CUVIDSOURCEDATAPACKET cupkt; AVPacket filter_packet = { 0 }; AVPacket filtered_packet = { 0 }; CUdeviceptr mapped_frame = 0; int ret = 0, eret = 0; if (ctx->bsf && avpkt->size) { if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_packet_ref failed\n"); return ret; } if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_bsf_send_packet failed\n"); av_packet_unref(&filter_packet); return ret; } if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_bsf_receive_packet failed\n"); return ret; } avpkt = &filtered_packet; } ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx)); if (ret < 0) { av_packet_unref(&filtered_packet); return ret; } memset(&cupkt, 0, sizeof(cupkt)); if (avpkt->size) { cupkt.payload_size = avpkt->size; cupkt.payload = avpkt->data; if (avpkt->pts != AV_NOPTS_VALUE) { cupkt.flags = CUVID_PKT_TIMESTAMP; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000}); else cupkt.timestamp = avpkt->pts; } } else { cupkt.flags = CUVID_PKT_ENDOFSTREAM; } ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt)); av_packet_unref(&filtered_packet); if (ret < 0) { if (ctx->internal_error) ret = ctx->internal_error; goto error; } if (av_fifo_size(ctx->frame_queue)) { CUVIDPARSERDISPINFO dispinfo; CUVIDPROCPARAMS params; unsigned int pitch = 0; int offset = 0; int i; av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL); memset(&params, 0, sizeof(params)); params.progressive_frame = dispinfo.progressive_frame; params.second_field = 0; params.top_field_first = dispinfo.top_field_first; ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params)); if (ret < 0) goto error; if (avctx->pix_fmt == AV_PIX_FMT_CUDA) { ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "av_hwframe_get_buffer failed\n"); goto error; } ret = ff_decode_frame_props(avctx, frame); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "ff_decode_frame_props failed\n"); goto error; } for (i = 0; i < 2; i++) { CUDA_MEMCPY2D cpy = { .srcMemoryType = CU_MEMORYTYPE_DEVICE, .dstMemoryType = CU_MEMORYTYPE_DEVICE, .srcDevice = mapped_frame, .dstDevice = (CUdeviceptr)frame->data[i], .srcPitch = pitch, .dstPitch = frame->linesize[i], .srcY = offset, .WidthInBytes = FFMIN(pitch, frame->linesize[i]), .Height = avctx->coded_height >> (i ? 1 : 0), }; ret = CHECK_CU(cuMemcpy2D(&cpy)); if (ret < 0) goto error; offset += avctx->coded_height; } } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) { AVFrame *tmp_frame = av_frame_alloc(); if (!tmp_frame) { av_log(avctx, AV_LOG_ERROR, "av_frame_alloc failed\n"); ret = AVERROR(ENOMEM); goto error; } tmp_frame->format = AV_PIX_FMT_CUDA; tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe); tmp_frame->data[0] = (uint8_t*)mapped_frame; tmp_frame->linesize[0] = pitch; tmp_frame->data[1] = (uint8_t*)(mapped_frame + avctx->coded_height * pitch); tmp_frame->linesize[1] = pitch; tmp_frame->width = avctx->width; tmp_frame->height = avctx->height; ret = ff_get_buffer(avctx, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed\n"); av_frame_free(&tmp_frame); goto error; } ret = av_hwframe_transfer_data(frame, tmp_frame, 0); if (ret) { av_log(avctx, AV_LOG_ERROR, "av_hwframe_transfer_data failed\n"); av_frame_free(&tmp_frame); goto error; } av_frame_free(&tmp_frame); } else { ret = AVERROR_BUG; goto error; } frame->width = avctx->width; frame->height = avctx->height; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase); else frame->pts = dispinfo.timestamp; frame->pkt_pts = frame->pts; av_frame_set_pkt_pos(frame, -1); av_frame_set_pkt_duration(frame, 0); av_frame_set_pkt_size(frame, -1); frame->interlaced_frame = !dispinfo.progressive_frame; if (!dispinfo.progressive_frame) frame->top_field_first = dispinfo.top_field_first; *got_frame = 1; } else { *got_frame = 0; } error: if (mapped_frame) eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame)); eret = CHECK_CU(cuCtxPopCurrent(&dummy)); if (eret < 0) return eret; else return ret; }

[[[[Adv]]]]: static int cuvid_decode_frame(AVCodecContext *avctx, void *[[dna]], int *got_frame, AVPacket *avpkt) { CuvidContext *ctx = avctx->priv_data; AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data; AVCUDADeviceContext *device_hwctx = device_ctx->hwctx; CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx; AVFrame *frame = [[dna]]; CUVIDSOURCEDATAPACKET cupkt; AVPacket filter_packet = { 0 }; AVPacket filtered_packet = { 0 }; CUdeviceptr mapped_frame = 0; int ret = 0, eret = 0; if (ctx->bsf && avpkt->size) { if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_packet_ref failed\n"); return ret; } if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_bsf_send_packet failed\n"); av_packet_unref(&filter_packet); return ret; } if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_bsf_receive_packet failed\n"); return ret; } avpkt = &filtered_packet; } ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx)); if (ret < 0) { av_packet_unref(&filtered_packet); return ret; } memset(&cupkt, 0, sizeof(cupkt)); if (avpkt->size) { cupkt.payload_size = avpkt->size; cupkt.payload = avpkt->data; if (avpkt->pts != AV_NOPTS_VALUE) { cupkt.flags = CUVID_PKT_TIMESTAMP; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000}); else cupkt.timestamp = avpkt->pts; } } else { cupkt.flags = CUVID_PKT_ENDOFSTREAM; } ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt)); av_packet_unref(&filtered_packet); if (ret < 0) { if (ctx->internal_error) ret = ctx->internal_error; goto error; } if (av_fifo_size(ctx->frame_queue)) { CUVIDPARSERDISPINFO dispinfo; CUVIDPROCPARAMS params; unsigned int pitch = 0; int offset = 0; int i; av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL); memset(&params, 0, sizeof(params)); params.progressive_frame = dispinfo.progressive_frame; params.second_field = 0; params.top_field_first = dispinfo.top_field_first; ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params)); if (ret < 0) goto error; if (avctx->pix_fmt == AV_PIX_FMT_CUDA) { ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "av_hwframe_get_buffer failed\n"); goto error; } ret = ff_decode_frame_props(avctx, frame); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "ff_decode_frame_props failed\n"); goto error; } for (i = 0; i < 2; i++) { CUDA_MEMCPY2D cpy = { .srcMemoryType = CU_MEMORYTYPE_DEVICE, .dstMemoryType = CU_MEMORYTYPE_DEVICE, .srcDevice = mapped_frame, .dstDevice = (CUdeviceptr)frame->data[i], .srcPitch = pitch, .dstPitch = frame->linesize[i], .srcY = offset, .WidthInBytes = FFMIN(pitch, frame->linesize[i]), .Height = avctx->coded_height >> (i ? 1 : 0), }; ret = CHECK_CU(cuMemcpy2D(&cpy)); if (ret < 0) goto error; offset += avctx->coded_height; } } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) { AVFrame *tmp_frame = av_frame_alloc(); if (!tmp_frame) { av_log(avctx, AV_LOG_ERROR, "av_frame_alloc failed\n"); ret = AVERROR(ENOMEM); goto error; } tmp_frame->format = AV_PIX_FMT_CUDA; tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe); tmp_frame->data[0] = (uint8_t*)mapped_frame; tmp_frame->linesize[0] = pitch; tmp_frame->data[1] = (uint8_t*)(mapped_frame + avctx->coded_height * pitch); tmp_frame->linesize[1] = pitch; tmp_frame->width = avctx->width; tmp_frame->height = avctx->height; ret = ff_get_buffer(avctx, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed\n"); av_frame_free(&tmp_frame); goto error; } ret = av_hwframe_transfer_data(frame, tmp_frame, 0); if (ret) { av_log(avctx, AV_LOG_ERROR, "av_hwframe_transfer_data failed\n"); av_frame_free(&tmp_frame); goto error; } av_frame_free(&tmp_frame); } else { ret = AVERROR_BUG; goto error; } frame->width = avctx->width; frame->height = avctx->height; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase); else frame->pts = dispinfo.timestamp; frame->pkt_pts = frame->pts; av_frame_set_pkt_pos(frame, -1); av_frame_set_pkt_duration(frame, 0); av_frame_set_pkt_size(frame, -1); frame->interlaced_frame = !dispinfo.progressive_frame; if (!dispinfo.progressive_frame) frame->top_field_first = dispinfo.top_field_first; *got_frame = 1; } else { *got_frame = 0; } error: if (mapped_frame) eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame)); eret = CHECK_CU(cuCtxPopCurrent(&dummy)); if (eret < 0) return eret; else return ret; }[Succeeded / Failed / Skipped / Total] 359 / 83 / 257 / 699:  26%|██▌       | 699/2690 [1:47:02<5:04:54,  9.19s/it][Succeeded / Failed / Skipped / Total] 359 / 83 / 257 / 699:  26%|██▌       | 700/2690 [1:47:02<5:04:19,  9.18s/it][Succeeded / Failed / Skipped / Total] 360 / 83 / 257 / 700:  26%|██▌       | 700/2690 [1:47:02<5:04:19,  9.18s/it][Succeeded / Failed / Skipped / Total] 360 / 83 / 257 / 700:  26%|██▌       | 701/2690 [1:47:03<5:03:45,  9.16s/it][Succeeded / Failed / Skipped / Total] 360 / 83 / 258 / 701:  26%|██▌       | 701/2690 [1:47:03<5:03:45,  9.16s/it][Succeeded / Failed / Skipped / Total] 360 / 83 / 258 / 701:  26%|██▌       | 702/2690 [1:47:03<5:03:11,  9.15s/it][Succeeded / Failed / Skipped / Total] 360 / 83 / 259 / 702:  26%|██▌       | 702/2690 [1:47:03<5:03:11,  9.15s/it][Succeeded / Failed / Skipped / Total] 360 / 83 / 259 / 702:  26%|██▌       | 703/2690 [1:47:35<5:04:04,  9.18s/it]
--------------------------------------------- Result 700 ---------------------------------------------
[[0 (14%)]] --> [[0 (70%)]] --> Socre: 0.7047340273857117

[[[[Adv]]]]: static void ide_identify(IDEState *s) { uint16_t *[[p]]; unsigned int oldsize; memset(s->io_buffer, 0, 512); [[p]] = (uint16_t *)s->io_buffer; stw([[p]] + 0, 0x0040); stw([[p]] + 1, s->cylinders); stw([[p]] + 3, s->heads); stw([[p]] + 4, 512 * s->sectors); stw([[p]] + 5, 512); stw([[p]] + 6, s->sectors); stw([[p]] + 20, 3); stw([[p]] + 21, 512); stw([[p]] + 22, 4); padstr((uint8_t *)([[p]] + 27), "QEMU HARDDISK", 40); #if MAX_MULT_SECTORS > 1 stw([[p]] + 47, MAX_MULT_SECTORS); #endif stw([[p]] + 48, 1); stw([[p]] + 49, 1 << 9); stw([[p]] + 51, 0x200); stw([[p]] + 52, 0x200); stw([[p]] + 54, s->cylinders); stw([[p]] + 55, s->heads); stw([[p]] + 56, s->sectors); oldsize = s->cylinders * s->heads * s->sectors; stw([[p]] + 57, oldsize); stw([[p]] + 58, oldsize >> 16); if (s->mult_sectors) stw([[p]] + 59, 0x100 | s->mult_sectors); stw([[p]] + 60, s->nb_sectors); stw([[p]] + 61, s->nb_sectors >> 16); stw([[p]] + 80, (1 << 1) | (1 << 2)); stw([[p]] + 82, (1 << 14)); stw([[p]] + 83, (1 << 14)); stw([[p]] + 84, (1 << 14)); stw([[p]] + 85, (1 << 14)); stw([[p]] + 86, 0); stw([[p]] + 87, (1 << 14)); }

[[[[Adv]]]]: static void ide_identify(IDEState *s) { uint16_t *[[п]]; unsigned int oldsize; memset(s->io_buffer, 0, 512); [[п]] = (uint16_t *)s->io_buffer; stw([[п]] + 0, 0x0040); stw([[п]] + 1, s->cylinders); stw([[п]] + 3, s->heads); stw([[п]] + 4, 512 * s->sectors); stw([[п]] + 5, 512); stw([[п]] + 6, s->sectors); stw([[п]] + 20, 3); stw([[п]] + 21, 512); stw([[п]] + 22, 4); padstr((uint8_t *)([[п]] + 27), "QEMU HARDDISK", 40); #if MAX_MULT_SECTORS > 1 stw([[п]] + 47, MAX_MULT_SECTORS); #endif stw([[п]] + 48, 1); stw([[п]] + 49, 1 << 9); stw([[п]] + 51, 0x200); stw([[п]] + 52, 0x200); stw([[п]] + 54, s->cylinders); stw([[п]] + 55, s->heads); stw([[п]] + 56, s->sectors); oldsize = s->cylinders * s->heads * s->sectors; stw([[п]] + 57, oldsize); stw([[п]] + 58, oldsize >> 16); if (s->mult_sectors) stw([[п]] + 59, 0x100 | s->mult_sectors); stw([[п]] + 60, s->nb_sectors); stw([[п]] + 61, s->nb_sectors >> 16); stw([[п]] + 80, (1 << 1) | (1 << 2)); stw([[п]] + 82, (1 << 14)); stw([[п]] + 83, (1 << 14)); stw([[п]] + 84, (1 << 14)); stw([[п]] + 85, (1 << 14)); stw([[п]] + 86, 0); stw([[п]] + 87, (1 << 14)); }
--------------------------------------------- Result 701 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int encode_apng(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { PNGEncContext *s = avctx->priv_data; int ret; int enc_row_size; size_t max_packet_size; APNGFctlChunk fctl_chunk = {0}; if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) { uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t)); if (avctx->frame_number == 0) { s->palette_checksum = checksum; } else if (checksum != s->palette_checksum) { av_log(avctx, AV_LOG_ERROR, "Input contains more than one unique palette. APNG does not support multiple palettes.\n"); return -1; } } enc_row_size = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3); max_packet_size = AV_INPUT_BUFFER_MIN_SIZE + avctx->height * ( enc_row_size + (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) ); if (max_packet_size > INT_MAX) return AVERROR(ENOMEM); if (avctx->frame_number == 0) { if (!pict) return AVERROR(EINVAL); s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE); if (!avctx->extradata) return AVERROR(ENOMEM); ret = encode_headers(avctx, pict); if (ret < 0) return ret; avctx->extradata_size = s->bytestream - avctx->extradata; s->last_frame_packet = av_malloc(max_packet_size); if (!s->last_frame_packet) return AVERROR(ENOMEM); } else if (s->last_frame) { ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0); if (ret < 0) return ret; memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size); pkt->size = s->last_frame_packet_size; pkt->pts = pkt->dts = s->last_frame->pts; } if (pict) { s->bytestream_start = s->bytestream = s->last_frame_packet; s->bytestream_end = s->bytestream + max_packet_size; fctl_chunk.sequence_number = s->sequence_number; ++s->sequence_number; s->bytestream += 26 + 12; ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl); if (ret < 0) return ret; fctl_chunk.delay_num = 0; fctl_chunk.delay_den = 0; } else { s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE; } if (s->last_frame) { uint8_t* last_fctl_chunk_start = pkt->data; uint8_t buf[26]; AV_WB32(buf + 0, s->last_frame_fctl.sequence_number); AV_WB32(buf + 4, s->last_frame_fctl.width); AV_WB32(buf + 8, s->last_frame_fctl.height); AV_WB32(buf + 12, s->last_frame_fctl.x_offset); AV_WB32(buf + 16, s->last_frame_fctl.y_offset); AV_WB16(buf + 20, s->last_frame_fctl.delay_num); AV_WB16(buf + 22, s->last_frame_fctl.delay_den); buf[24] = s->last_frame_fctl.dispose_op; buf[25] = s->last_frame_fctl.blend_op; png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26); *got_packet = 1; } if (pict) { if (!s->last_frame) { s->last_frame = av_frame_alloc(); if (!s->last_frame) return AVERROR(ENOMEM); } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) { if (!s->prev_frame) { s->prev_frame = av_frame_alloc(); if (!s->prev_frame) return AVERROR(ENOMEM); s->prev_frame->format = pict->format; s->prev_frame->width = pict->width; s->prev_frame->height = pict->height; if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0) return ret; } memcpy(s->prev_frame->data[0], s->last_frame->data[0], s->last_frame->linesize[0] * s->last_frame->height); if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) { uint32_t y; uint8_t bpp = (s->bits_per_pixel + 7) >> 3; for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) { size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset; memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width); } } } av_frame_unref(s->last_frame); ret = av_frame_ref(s->last_frame, (AVFrame*)pict); if (ret < 0) return ret; s->last_frame_fctl = fctl_chunk; s->last_frame_packet_size = s->bytestream - s->bytestream_start; } else { av_frame_free(&s->last_frame); } return 0; }
--------------------------------------------- Result 702 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void migrate_set_downtime(QTestState *who, const char *value) { QDict *rsp; gchar *cmd; cmd = g_strdup_printf("{ 'execute': 'migrate_set_downtime'," "'arguments': { 'value': %s } }", value); rsp = qtest_qmp(who, cmd); g_free(cmd); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); }
--------------------------------------------- Result 703 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 360 / 84 / 259 / 703:  26%|██▌       | 703/2690 [1:47:35<5:04:04,  9.18s/it][Succeeded / Failed / Skipped / Total] 360 / 84 / 259 / 703:  26%|██▌       | 704/2690 [1:47:44<5:03:56,  9.18s/it][[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ff_h264_idct8_add_sse2(uint8_t *[[dst]], int16_t *[[block]], int [[stride]]) { __asm__ volatile( "movdqa 0x10(%1), %%xmm1 \n" "movdqa 0x20(%1), %%xmm2 \n" "movdqa 0x30(%1), %%xmm3 \n" "movdqa 0x50(%1), %%xmm5 \n" "movdqa 0x60(%1), %%xmm6 \n" "movdqa 0x70(%1), %%xmm7 \n" H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7) TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1)) "paddw %4, %%xmm4 \n" "movdqa %%xmm4, 0x00(%1) \n" "movdqa %%xmm2, 0x40(%1) \n" H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1) "movdqa %%xmm6, 0x60(%1) \n" "movdqa %%xmm7, 0x70(%1) \n" "pxor %%xmm7, %%xmm7 \n" STORE_DIFF_8P(%%xmm2, (%0), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm0, (%0,%2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm3, (%0,%3), %%xmm6, %%xmm7) "lea (%0,%2,4), %0 \n" STORE_DIFF_8P(%%xmm5, (%0), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm4, (%0,%2), %%xmm6, %%xmm7) "movdqa 0x60(%1), %%xmm0 \n" "movdqa 0x70(%1), %%xmm1 \n" STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm1, (%0,%3), %%xmm6, %%xmm7) :"+r"([[dst]]) :"r"([[block]]), "r"((x86_reg)[[stride]]), "r"((x86_reg)3L*[[stride]]), "m"(ff_pw_32) ); }

[[[[Adv]]]]: static void ff_h264_idct8_add_sse2(uint8_t *[[sт]], int16_t *[[group]], int [[block]]) { __asm__ volatile( "movdqa 0x10(%1), %%xmm1 \n" "movdqa 0x20(%1), %%xmm2 \n" "movdqa 0x30(%1), %%xmm3 \n" "movdqa 0x50(%1), %%xmm5 \n" "movdqa 0x60(%1), %%xmm6 \n" "movdqa 0x70(%1), %%xmm7 \n" H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7) TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1)) "paddw %4, %%xmm4 \n" "movdqa %%xmm4, 0x00(%1) \n" "movdqa %%xmm2, 0x40(%1) \n" H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1) "movdqa %%xmm6, 0x60(%1) \n" "movdqa %%xmm7, 0x70(%1) \n" "pxor %%xmm7, %%xmm7 \n" STORE_DIFF_8P(%%xmm2, (%0), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm0, (%0,%2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm3, (%0,%3), %%xmm6, %%xmm7) "lea (%0,%2,4), %0 \n" STORE_DIFF_8P(%%xmm5, (%0), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm4, (%0,%2), %%xmm6, %%xmm7) "movdqa 0x60(%1), %%xmm0 \n" "movdqa 0x70(%1), %%xmm1 \n" STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm1, (%0,%3), %%xmm6, %%xmm7) :"+r"([[sт]]) :"r"([[group]]), "r"((x86_reg)[[block]]), "r"((x86_reg)3L*[[block]]), "m"(ff_pw_32) ); }
--------------------------------------------- Result 704 ---------------------------------------------
[[0 (47%)]] --> [[0 (90%)]] --> Socre: 0.8970360159873962

[[[[Adv]]]]: target_ulong do_arm_semihosting(CPUARMState *[[env]]) { ARMCPU *cpu = arm_env_get_cpu([[env]]); CPUState *cs = CPU(cpu); target_ulong args; target_ulong arg0, arg1, arg2, arg3; char * s; int nr; uint32_t ret; uint32_t len; #ifdef CONFIG_USER_ONLY TaskState *ts = cs->opaque; #else CPUARMState *ts = [[env]]; #endif if (is_a64([[env]])) { nr = [[env]]->xregs[0] & 0xffffffffU; args = [[env]]->xregs[1]; } else { nr = [[env]]->regs[0]; args = [[env]]->regs[1]; } switch (nr) { case TARGET_SYS_OPEN: GET_ARG(0); GET_ARG(1); GET_ARG(2); s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } if (arg1 >= 12) { unlock_user(s, arg0, 0); return (uint32_t)-1; } if (strcmp(s, ":tt") == 0) { int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO; unlock_user(s, arg0, 0); return result_fileno; } if (use_gdb_syscalls()) { ret = arm_gdb_syscall(cpu, arm_semi_cb, "open,%s,%x,1a4", arg0, (int)arg2+1, gdb_open_modeflags[arg1]); } else { ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644)); } unlock_user(s, arg0, 0); return ret; case TARGET_SYS_CLOSE: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "close,%x", arg0); } else { return set_swi_errno(ts, close(arg0)); } case TARGET_SYS_WRITEC: { char c; if (get_user_u8(c, args)) return (uint32_t)-1; if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,1", args); } else { return write(STDERR_FILENO, &c, 1); } } case TARGET_SYS_WRITE0: if (!(s = lock_user_string(args))) return (uint32_t)-1; len = strlen(s); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,%x", args, len); } else { ret = write(STDERR_FILENO, s, len); } unlock_user(s, args, 0); return ret; case TARGET_SYS_WRITE: GET_ARG(0); GET_ARG(1); GET_ARG(2); len = arg2; if (use_gdb_syscalls()) { arm_semi_syscall_len = len; return arm_gdb_syscall(cpu, arm_semi_cb, "write,%x,%x,%x", arg0, arg1, len); } else { s = lock_user(VERIFY_READ, arg1, len, 1); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, write(arg0, s, len)); unlock_user(s, arg1, 0); if (ret == (uint32_t)-1) return -1; return len - ret; } case TARGET_SYS_READ: GET_ARG(0); GET_ARG(1); GET_ARG(2); len = arg2; if (use_gdb_syscalls()) { arm_semi_syscall_len = len; return arm_gdb_syscall(cpu, arm_semi_cb, "read,%x,%x,%x", arg0, arg1, len); } else { s = lock_user(VERIFY_WRITE, arg1, len, 0); if (!s) { return (uint32_t)-1; } do { ret = set_swi_errno(ts, read(arg0, s, len)); } while (ret == -1 && errno == EINTR); unlock_user(s, arg1, len); if (ret == (uint32_t)-1) return -1; return len - ret; } case TARGET_SYS_READC: return 0; case TARGET_SYS_ISTTY: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "isatty,%x", arg0); } else { return isatty(arg0); } case TARGET_SYS_SEEK: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "lseek,%x,%x,0", arg0, arg1); } else { ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET)); if (ret == (uint32_t)-1) return -1; return 0; } case TARGET_SYS_FLEN: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_flen_cb, "fstat,%x,%x", arg0, arm_flen_buf(cpu)); } else { struct stat buf; ret = set_swi_errno(ts, fstat(arg0, &buf)); if (ret == (uint32_t)-1) return -1; return buf.st_size; } case TARGET_SYS_TMPNAM: return -1; case TARGET_SYS_REMOVE: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { ret = arm_gdb_syscall(cpu, arm_semi_cb, "unlink,%s", arg0, (int)arg1+1); } else { s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, remove(s)); unlock_user(s, arg0, 0); } return ret; case TARGET_SYS_RENAME: GET_ARG(0); GET_ARG(1); GET_ARG(2); GET_ARG(3); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "rename,%s,%s", arg0, (int)arg1+1, arg2, (int)arg3+1); } else { char *s2; s = lock_user_string(arg0); s2 = lock_user_string(arg2); if (!s || !s2) ret = (uint32_t)-1; else ret = set_swi_errno(ts, rename(s, s2)); if (s2) unlock_user(s2, arg2, 0); if (s) unlock_user(s, arg0, 0); return ret; } case TARGET_SYS_CLOCK: return clock() / (CLOCKS_PER_SEC / 100); case TARGET_SYS_TIME: return set_swi_errno(ts, time(NULL)); case TARGET_SYS_SYSTEM: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "system,%s", arg0, (int)arg1+1); } else { s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, system(s)); unlock_user(s, arg0, 0); return ret; } case TARGET_SYS_ERRNO: #ifdef CONFIG_USER_ONLY return ts->swi_errno; #else return syscall_err; #endif case TARGET_SYS_GET_CMDLINE: { char *output_buffer; size_t input_size; size_t output_size; int status = 0; #if !defined(CONFIG_USER_ONLY) const char *cmdline; #endif GET_ARG(0); GET_ARG(1); input_size = arg1; #if !defined(CONFIG_USER_ONLY) cmdline = semihosting_get_cmdline(); if (cmdline == NULL) { cmdline = ""; } output_size = strlen(cmdline) + 1; #else unsigned int i; output_size = ts->info->arg_end - ts->info->arg_start; if (!output_size) { output_size = 1; } #endif if (output_size > input_size) { return -1; } if (SET_ARG(1, output_size - 1)) { return -1; } output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0); if (!output_buffer) { return -1; } #if !defined(CONFIG_USER_ONLY) pstrcpy(output_buffer, output_size, cmdline); #else if (output_size == 1) { output_buffer[0] = '\0'; goto out; } if (copy_from_user(output_buffer, ts->info->arg_start, output_size)) { status = -1; goto out; } for (i = 0; i < output_size - 1; i++) { if (output_buffer[i] == 0) { output_buffer[i] = ' '; } } out: #endif unlock_user(output_buffer, arg0, output_size); return status; } case TARGET_SYS_HEAPINFO: { target_ulong retvals[4]; uint32_t limit; int i; GET_ARG(0); #ifdef CONFIG_USER_ONLY if (!ts->heap_limit) { abi_ulong ret; ts->heap_base = do_brk(0); limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE; for (;;) { ret = do_brk(limit); if (ret >= limit) { break; } limit = (ts->heap_base >> 1) + (limit >> 1); } ts->heap_limit = limit; } retvals[0] = ts->heap_base; retvals[1] = ts->heap_limit; retvals[2] = ts->stack_base; retvals[3] = 0; #else limit = ram_size; retvals[0] = limit / 2; retvals[1] = limit; retvals[2] = limit; retvals[3] = 0; #endif for (i = 0; i < ARRAY_SIZE(retvals); i++) { bool fail; if (is_a64([[env]])) { fail = put_user_u64(retvals[i], arg0 + i * 8); } else { fail = put_user_u32(retvals[i], arg0 + i * 4); } if (fail) { return -1; } } return 0; } case TARGET_SYS_EXIT: if (is_a64([[env]])) { GET_ARG(0); GET_ARG(1); if (arg0 == ADP_Stopped_ApplicationExit) { ret = arg1; } else { ret = 1; } } else { ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1; } gdb_exit([[env]], ret); exit(ret); case TARGET_SYS_SYNCCACHE: if (is_a64([[env]])) { return 0; } default: fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr); cpu_dump_state(cs, stderr, fprintf, 0); abort(); } }

[[[[Adv]]]]: target_ulong do_arm_semihosting(CPUARMState *[[onв]]) { ARMCPU *cpu = arm_env_get_cpu([[onв]]); CPUState *cs = CPU(cpu); target_ulong args; target_ulong arg0, arg1, arg2, arg3; char * s; int nr; uint32_t ret; uint32_t len; #ifdef CONFIG_USER_ONLY TaskState *ts = cs->opaque; #else CPUARMState *ts = [[onв]]; #endif if (is_a64([[onв]])) { nr = [[onв]]->xregs[0] & 0xffffffffU; args = [[onв]]->xregs[1]; } else { nr = [[onв]]->regs[0]; args = [[onв]]->regs[1]; } switch (nr) { case TARGET_SYS_OPEN: GET_ARG(0); GET_ARG(1); GET_ARG(2); s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } if (arg1 >= 12) { unlock_user(s, arg0, 0); return (uint32_t)-1; } if (strcmp(s, ":tt") == 0) { int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO; unlock_user(s, arg0, 0); return result_fileno; } if (use_gdb_syscalls()) { ret = arm_gdb_syscall(cpu, arm_semi_cb, "open,%s,%x,1a4", arg0, (int)arg2+1, gdb_open_modeflags[arg1]); } else { ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644)); } unlock_user(s, arg0, 0); return ret; case TARGET_SYS_CLOSE: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "close,%x", arg0); } else { return set_swi_errno(ts, close(arg0)); } case TARGET_SYS_WRITEC: { char c; if (get_user_u8(c, args)) return (uint32_t)-1; if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,1", args); } else { return write(STDERR_FILENO, &c, 1); } } case TARGET_SYS_WRITE0: if (!(s = lock_user_string(args))) return (uint32_t)-1; len = strlen(s); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,%x", args, len); } else { ret = write(STDERR_FILENO, s, len); } unlock_user(s, args, 0); return ret; case TARGET_SYS_WRITE: GET_ARG(0); GET_ARG(1); GET_ARG(2); len = arg2; if (use_gdb_syscalls()) { arm_semi_syscall_len = len; return arm_gdb_syscall(cpu, arm_semi_cb, "write,%x,%x,%x", arg0, arg1, len); } else { s = lock_user(VERIFY_READ, arg1, len, 1); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, write(arg0, s, len)); unlock_user(s, arg1, 0); if (ret == (uint32_t)-1) return -1; return len - ret; } case TARGET_SYS_READ: GET_ARG(0); GET_ARG(1); GET_ARG(2); len = arg2; if (use_gdb_syscalls()) { arm_semi_syscall_len = len; return arm_gdb_syscall(cpu, arm_semi_cb, "read,%x,%x,%x", arg0, arg1, len); } else { s = lock_user(VERIFY_WRITE, arg1, len, 0); if (!s) { return (uint32_t)-1; } do { ret = set_swi_errno(ts, read(arg0, s, len)); } while (ret == -1 && errno == EINTR); unlock_user(s, arg1, len); if (ret == (uint32_t)-1) return -1; return len - ret; } case TARGET_SYS_READC: return 0; case TARGET_SYS_ISTTY: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "isatty,%x", arg0); } else { return isatty(arg0); } case TARGET_SYS_SEEK: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "lseek,%x,%x,0", arg0, arg1); } else { ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET)); if (ret == (uint32_t)-1) return -1; return 0; } case TARGET_SYS_FLEN: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_flen_cb, "fstat,%x,%x", arg0, arm_flen_buf(cpu)); } else { struct stat buf; ret = set_swi_errno(ts, fstat(arg0, &buf)); if (ret == (uint32_t)-1) return -1; return buf.st_size; } case TARGET_SYS_TMPNAM: return -1; case TARGET_SYS_REMOVE: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { ret = arm_gdb_syscall(cpu, arm_semi_cb, "unlink,%s", arg0, (int)arg1+1); } else { s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, remove(s)); unlock_user(s, arg0, 0); } return ret; case TARGET_SYS_RENAME: GET_ARG(0); GET_ARG(1); GET_ARG(2); GET_ARG(3); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "rename,%s,%s", arg0, (int)arg1+1, arg2, (int)arg3+1); } else { char *s2; s = lock_user_string(arg0); s2 = lock_user_string(arg2); if (!s || !s2) ret = (uint32_t)-1; else ret = set_swi_errno(ts, rename(s, s2)); if (s2) unlock_user(s2, arg2, 0); if (s) unlock_user(s, arg0, 0); return ret; } case TARGET_SYS_CLOCK: return clock() / (CLOCKS_PER_SEC / 100); case TARGET_SYS_TIME: return set_swi_errno(ts, time(NULL)); case TARGET_SYS_SYSTEM: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "system,%s", arg0, (int)arg1+1); } else { s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, system(s)); unlock_user(s, arg0, 0); return ret; } case TARGET_SYS_ERRNO: #ifdef CONFIG_USER_ONLY return ts->swi_errno; #else return syscall_err; #endif case TARGET_SYS_GET_CMDLINE: { char *output_buffer; size_t input_size; size_t output_size; int status = 0; #if !defined(CONFIG_USER_ONLY) const char *cmdline; #endif GET_ARG(0); GET_ARG(1); input_size = arg1; #if !defined(CONFIG_USER_ONLY) cmdline = semihosting_get_cmdline(); if (cmdline == NULL) { cmdline = ""; } output_size = strlen(cmdline) + 1; #else unsigned int i; output_size = ts->info->arg_end - ts->info->arg_start; if (!output_size) { output_size = 1; } #endif if (output_size > input_size) { return -1; } if (SET_ARG(1, output_size - 1)) { return -1; } output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0); if (!output_buffer) { return -1; } #if !defined(CONFIG_USER_ONLY) pstrcpy(output_buffer, output_size, cmdline); #else if (output_size == 1) { output_buffer[0] = '\0'; goto out; } if (copy_from_user(output_buffer, ts->info->arg_start, output_size)) { status = -1; goto out; } for (i = 0; i < output_size - 1; i++) { if (output_buffer[i] == 0) { output_buffer[i] = ' '; } } out: #endif unlock_user(output_buffer, arg0, output_size); return status; } case TARGET_SYS_HEAPINFO: { target_ulong retvals[4]; uint32_t limit; int i; GET_ARG(0); #ifdef CONFIG_USER_ONLY if (!ts->heap_limit) { abi_ulong ret; ts->heap_base = do_brk(0); limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE; for (;;) { ret = do_brk(limit); if (ret >= limit) { break; } limit = (ts->heap_base >> 1) + (limit >> 1); } ts->heap_limit = limit; } retvals[0] = ts->heap_base; retvals[1] = ts->heap_limit; retvals[2] = ts->stack_base; retvals[3] = 0; #else limit = ram_size; retvals[0] = limit / 2; retvals[1] = limit; retvals[2] = limit; retvals[3] = 0; #endif for (i = 0; i < ARRAY_SIZE(retvals); i++) { bool fail; if (is_a64([[onв]])) { fail = put_user_u64(retvals[i], arg0 + i * 8); } else { fail = put_user_u32(retvals[i], arg0 + i * 4); } if (fail) { return -1; } } return 0; } case TARGET_SYS_EXIT: if (is_a64([[onв]])) { GET_ARG(0); GET_ARG(1); if (arg0 == ADP_Stopped_ApplicationExit) { ret = arg1; } else { ret = 1; } } else { ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1; } gdb_exit([[onв]], ret); exit(ret); case TARGET_SYS_SYNCCACHE: if (is_a64([[onв]])) { return 0; } default: fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr); cpu_dump_state(cs, stderr, fprintf, 0); abort(); } }[Succeeded / Failed / Skipped / Total] 361 / 84 / 259 / 704:  26%|██▌       | 704/2690 [1:47:44<5:03:56,  9.18s/it][Succeeded / Failed / Skipped / Total] 361 / 84 / 259 / 704:  26%|██▌       | 705/2690 [1:47:48<5:03:32,  9.17s/it][Succeeded / Failed / Skipped / Total] 362 / 84 / 259 / 705:  26%|██▌       | 705/2690 [1:47:48<5:03:32,  9.17s/it][Succeeded / Failed / Skipped / Total] 362 / 84 / 259 / 705:  26%|██▌       | 706/2690 [1:48:10<5:03:58,  9.19s/it][Succeeded / Failed / Skipped / Total] 363 / 84 / 259 / 706:  26%|██▌       | 706/2690 [1:48:10<5:03:58,  9.19s/it][Succeeded / Failed / Skipped / Total] 363 / 84 / 259 / 706:  26%|██▋       | 707/2690 [1:48:10<5:03:25,  9.18s/it][Succeeded / Failed / Skipped / Total] 363 / 84 / 260 / 707:  26%|██▋       | 707/2690 [1:48:10<5:03:25,  9.18s/it][Succeeded / Failed / Skipped / Total] 363 / 84 / 260 / 707:  26%|██▋       | 708/2690 [1:48:13<5:02:58,  9.17s/it][Succeeded / Failed / Skipped / Total] 364 / 84 / 260 / 708:  26%|██▋       | 708/2690 [1:48:13<5:02:58,  9.17s/it][Succeeded / Failed / Skipped / Total] 364 / 84 / 260 / 708:  26%|██▋       | 709/2690 [1:48:14<5:02:26,  9.16s/it][Succeeded / Failed / Skipped / Total] 365 / 84 / 260 / 709:  26%|██▋       | 709/2690 [1:48:14<5:02:26,  9.16s/it][Succeeded / Failed / Skipped / Total] 365 / 84 / 260 / 709:  26%|██▋       | 710/2690 [1:48:15<5:01:53,  9.15s/it]
--------------------------------------------- Result 705 ---------------------------------------------
[[0 (6%)]] --> [[0 (99%)]] --> Socre: 0.9901207685470581

[[[[Adv]]]]: BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *[[qiov]], int nb_sectors, BlockDriverCompletionFunc *cb, void *[[opaque]]) { BlockDriver *drv = bs->drv; BlockDriverAIOCB *ret; trace_bdrv_aio_readv(bs, sector_num, nb_sectors, [[opaque]]); if (!drv) return NULL; if (bdrv_check_request(bs, sector_num, nb_sectors)) return NULL; ret = drv->bdrv_aio_readv(bs, sector_num, [[qiov]], nb_sectors, cb, [[opaque]]); if (ret) { bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE; bs->rd_ops ++; } return ret; }

[[[[Adv]]]]: BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *[[ehов]], int nb_sectors, BlockDriverCompletionFunc *cb, void *[[informant]]) { BlockDriver *drv = bs->drv; BlockDriverAIOCB *ret; trace_bdrv_aio_readv(bs, sector_num, nb_sectors, [[informant]]); if (!drv) return NULL; if (bdrv_check_request(bs, sector_num, nb_sectors)) return NULL; ret = drv->bdrv_aio_readv(bs, sector_num, [[ehов]], nb_sectors, cb, [[informant]]); if (ret) { bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE; bs->rd_ops ++; } return ret; }
--------------------------------------------- Result 706 ---------------------------------------------
[[0 (25%)]] --> [[0 (62%)]] --> Socre: 0.615472137928009

[[[[Adv]]]]: void avfilter_filter_samples(AVFilterLink *[[link]], AVFilterBufferRef *samplesref) { void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *dst = [[link]]->dstpad; int i; FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, [[link]], 1); if (!(filter_samples = dst->filter_samples)) filter_samples = avfilter_default_filter_samples; if ((dst->min_perms & samplesref->perms) != dst->min_perms || dst->rej_perms & samplesref->perms) { av_log([[link]]->dst, AV_LOG_DEBUG, "Copying audio data in avfilter (have perms %x, need %x, reject %x)\n", samplesref->perms, [[link]]->dstpad->min_perms, [[link]]->dstpad->rej_perms); [[link]]->cur_buf = avfilter_default_get_audio_buffer([[link]], dst->min_perms, samplesref->audio->nb_samples); [[link]]->cur_buf->pts = samplesref->pts; [[link]]->cur_buf->audio->sample_rate = samplesref->audio->sample_rate; for (i = 0; samplesref->data[i]; i++) memcpy([[link]]->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]); avfilter_unref_buffer(samplesref); } else [[link]]->cur_buf = samplesref; filter_samples([[link]], [[link]]->cur_buf); }

[[[[Adv]]]]: void avfilter_filter_samples(AVFilterLink *[[panorama]], AVFilterBufferRef *samplesref) { void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *dst = [[panorama]]->dstpad; int i; FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, [[panorama]], 1); if (!(filter_samples = dst->filter_samples)) filter_samples = avfilter_default_filter_samples; if ((dst->min_perms & samplesref->perms) != dst->min_perms || dst->rej_perms & samplesref->perms) { av_log([[panorama]]->dst, AV_LOG_DEBUG, "Copying audio data in avfilter (have perms %x, need %x, reject %x)\n", samplesref->perms, [[panorama]]->dstpad->min_perms, [[panorama]]->dstpad->rej_perms); [[panorama]]->cur_buf = avfilter_default_get_audio_buffer([[panorama]], dst->min_perms, samplesref->audio->nb_samples); [[panorama]]->cur_buf->pts = samplesref->pts; [[panorama]]->cur_buf->audio->sample_rate = samplesref->audio->sample_rate; for (i = 0; samplesref->data[i]; i++) memcpy([[panorama]]->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]); avfilter_unref_buffer(samplesref); } else [[panorama]]->cur_buf = samplesref; filter_samples([[panorama]], [[panorama]]->cur_buf); }
--------------------------------------------- Result 707 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) { const char *p; CharDriverState *chr; QemuOpts *opts; Error *err = NULL; if (strstart(filename, "chardev:", &p)) { return qemu_chr_find(p); } opts = qemu_chr_parse_compat(label, filename); if (!opts) return NULL; chr = qemu_chr_new_from_opts(opts, init, &err); if (err) { error_report_err(err); } if (chr && qemu_opt_get_bool(opts, "mux", 0)) { qemu_chr_fe_claim_no_fail(chr); monitor_init(chr, MONITOR_USE_READLINE); } return chr; }
--------------------------------------------- Result 708 ---------------------------------------------
[[0 (24%)]] --> [[0 (69%)]] --> Socre: 0.6879125237464905

[[[[Adv]]]]: static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb, void *[[logctx]], int size) { uint8_t *[[user_data]]; int e, build, i; if (size < 16 || size >= INT_MAX - 16) return AVERROR_INVALIDDATA; [[user_data]] = av_malloc(16 + size + 1); if (![[user_data]]) return AVERROR(ENOMEM); for (i = 0; i < size + 16; i++) [[user_data]][i] = get_bits(gb, 8); [[user_data]][i] = 0; e = sscanf([[user_data]] + 16, "x264 - core %d", &build); if (e == 1 && build > 0) h->x264_build = build; if (e == 1 && build == 1 && !strncmp([[user_data]]+16, "x264 - core 0000", 16)) h->x264_build = 67; if (strlen([[user_data]] + 16) > 0) av_log([[logctx]], AV_LOG_DEBUG, "user data:\"%s\"\n", [[user_data]] + 16); av_free([[user_data]]); return 0; }

[[[[Adv]]]]: static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb, void *[[vcki]], int size) { uint8_t *[[patientbigresults]]; int e, build, i; if (size < 16 || size >= INT_MAX - 16) return AVERROR_INVALIDDATA; [[patientbigresults]] = av_malloc(16 + size + 1); if (![[patientbigresults]]) return AVERROR(ENOMEM); for (i = 0; i < size + 16; i++) [[patientbigresults]][i] = get_bits(gb, 8); [[patientbigresults]][i] = 0; e = sscanf([[patientbigresults]] + 16, "x264 - core %d", &build); if (e == 1 && build > 0) h->x264_build = build; if (e == 1 && build == 1 && !strncmp([[patientbigresults]]+16, "x264 - core 0000", 16)) h->x264_build = 67; if (strlen([[patientbigresults]] + 16) > 0) av_log([[vcki]], AV_LOG_DEBUG, "user data:\"%s\"\n", [[patientbigresults]] + 16); av_free([[patientbigresults]]); return 0; }
--------------------------------------------- Result 709 ---------------------------------------------
[[0 (42%)]] --> [[0 (68%)]] --> Socre: 0.6761069297790527

[[[[Adv]]]]: static qemu_irq *ppce500_init_mpic(PPCE500Params *[[params]], MemoryRegion *ccsr, qemu_irq **irqs) { qemu_irq *mpic; DeviceState *dev; SysBusDevice *s; int i, j, k; mpic = g_new(qemu_irq, 256); dev = qdev_create(NULL, "openpic"); qdev_prop_set_uint32(dev, "nb_cpus", smp_cpus); qdev_prop_set_uint32(dev, "model", [[params]]->mpic_version); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); k = 0; for (i = 0; i < smp_cpus; i++) { for (j = 0; j < OPENPIC_OUTPUT_NB; j++) { sysbus_connect_irq(s, k++, irqs[i][j]); } } for (i = 0; i < 256; i++) { mpic[i] = qdev_get_gpio_in(dev, i); } memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET, s->mmio[0].memory); return mpic; }

[[[[Adv]]]]: static qemu_irq *ppce500_init_mpic(PPCE500Params *[[raids]], MemoryRegion *ccsr, qemu_irq **irqs) { qemu_irq *mpic; DeviceState *dev; SysBusDevice *s; int i, j, k; mpic = g_new(qemu_irq, 256); dev = qdev_create(NULL, "openpic"); qdev_prop_set_uint32(dev, "nb_cpus", smp_cpus); qdev_prop_set_uint32(dev, "model", [[raids]]->mpic_version); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); k = 0; for (i = 0; i < smp_cpus; i++) { for (j = 0; j < OPENPIC_OUTPUT_NB; j++) { sysbus_connect_irq(s, k++, irqs[i][j]); } } for (i = 0; i < 256; i++) { mpic[i] = qdev_get_gpio_in(dev, i); } memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET, s->mmio[0].memory); return mpic; }
--------------------------------------------- Result 710 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 365 / 84 / 261 / 710:  26%|██▋       | 710/2690 [1:48:15<5:01:53,  9.15s/it][Succeeded / Failed / Skipped / Total] 365 / 84 / 261 / 710:  26%|██▋       | 711/2690 [1:48:38<5:02:24,  9.17s/it][Succeeded / Failed / Skipped / Total] 366 / 84 / 261 / 711:  26%|██▋       | 711/2690 [1:48:38<5:02:24,  9.17s/it][Succeeded / Failed / Skipped / Total] 366 / 84 / 261 / 711:  26%|██▋       | 712/2690 [1:48:39<5:01:51,  9.16s/it][Succeeded / Failed / Skipped / Total] 366 / 84 / 262 / 712:  26%|██▋       | 712/2690 [1:48:39<5:01:51,  9.16s/it][Succeeded / Failed / Skipped / Total] 366 / 84 / 262 / 712:  27%|██▋       | 713/2690 [1:48:43<5:01:27,  9.15s/it][Succeeded / Failed / Skipped / Total] 367 / 84 / 262 / 713:  27%|██▋       | 713/2690 [1:48:43<5:01:27,  9.15s/it][Succeeded / Failed / Skipped / Total] 367 / 84 / 262 / 713:  27%|██▋       | 714/2690 [1:49:02<5:01:45,  9.16s/it][Succeeded / Failed / Skipped / Total] 368 / 84 / 262 / 714:  27%|██▋       | 714/2690 [1:49:02<5:01:45,  9.16s/it][Succeeded / Failed / Skipped / Total] 368 / 84 / 262 / 714:  27%|██▋       | 715/2690 [1:49:02<5:01:11,  9.15s/it][[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as) { ESDVoiceOut *esd = (ESDVoiceOut *) hw; audsettings_t obt_as = *as; int esdfmt = ESD_STREAM | ESD_PLAY; int err; sigset_t set, old_set; sigfillset (&set); esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO; switch (as->fmt) { case AUD_FMT_S8: case AUD_FMT_U8: esdfmt |= ESD_BITS8; obt_as.fmt = AUD_FMT_U8; break; case AUD_FMT_S32: case AUD_FMT_U32: dolog ("Will use 16 instead of 32 bit samples\n"); case AUD_FMT_S16: case AUD_FMT_U16: deffmt: esdfmt |= ESD_BITS16; obt_as.fmt = AUD_FMT_S16; break; default: dolog ("Internal logic error: Bad audio format %d\n", as->fmt); goto deffmt; } obt_as.endianness = AUDIO_HOST_ENDIANNESS; audio_pcm_init_info (&hw->info, &obt_as); hw->samples = conf.samples; esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift); if (!esd->pcm_buf) { dolog ("Could not allocate buffer (%d bytes)\n", hw->samples << hw->info.shift); return -1; } esd->fd = -1; err = pthread_sigmask (SIG_BLOCK, &set, &old_set); if (err) { qesd_logerr (err, "pthread_sigmask failed\n"); goto fail1; } esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL); if (esd->fd < 0) { qesd_logerr (errno, "esd_play_stream failed\n"); goto fail2; } if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) { goto fail3; } err = pthread_sigmask (SIG_SETMASK, &old_set, NULL); if (err) { qesd_logerr (err, "pthread_sigmask(restore) failed\n"); } return 0; fail3: if (close (esd->fd)) { qesd_logerr (errno, "%s: close on esd socket(%d) failed\n", AUDIO_FUNC, esd->fd); } esd->fd = -1; fail2: err = pthread_sigmask (SIG_SETMASK, &old_set, NULL); if (err) { qesd_logerr (err, "pthread_sigmask(restore) failed\n"); } fail1: qemu_free (esd->pcm_buf); esd->pcm_buf = NULL; return -1; }
--------------------------------------------- Result 711 ---------------------------------------------
[[0 (43%)]] --> [[0 (97%)]] --> Socre: 0.9737494587898254

[[[[Adv]]]]: int qdev_prop_check_globals(void) { GList *[[l]]; int ret = 0; for ([[l]] = global_props; [[l]]; [[l]] = [[l]]->next) { GlobalProperty *prop = [[l]]->data; ObjectClass *oc; DeviceClass *dc; if (prop->used) { continue; } if (!prop->user_provided) { continue; } oc = object_class_by_name(prop->driver); oc = object_class_dynamic_cast(oc, TYPE_DEVICE); if (!oc) { error_report("Warning: global %s.%s has invalid class name", prop->driver, prop->property); ret = 1; continue; } dc = DEVICE_CLASS(oc); if (!dc->hotpluggable && !prop->used) { error_report("Warning: global %s.%s=%s not used", prop->driver, prop->property, prop->value); ret = 1; continue; } } return ret; }

[[[[Adv]]]]: int qdev_prop_check_globals(void) { GList *[[λ]]; int ret = 0; for ([[λ]] = global_props; [[λ]]; [[λ]] = [[λ]]->next) { GlobalProperty *prop = [[λ]]->data; ObjectClass *oc; DeviceClass *dc; if (prop->used) { continue; } if (!prop->user_provided) { continue; } oc = object_class_by_name(prop->driver); oc = object_class_dynamic_cast(oc, TYPE_DEVICE); if (!oc) { error_report("Warning: global %s.%s has invalid class name", prop->driver, prop->property); ret = 1; continue; } dc = DEVICE_CLASS(oc); if (!dc->hotpluggable && !prop->used) { error_report("Warning: global %s.%s=%s not used", prop->driver, prop->property, prop->value); ret = 1; continue; } } return ret; }
--------------------------------------------- Result 712 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void sd_response_r1_make(SDState *sd, uint8_t *response, uint32_t last_status) { uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND; uint32_t status; status = (sd->card_status & ~mask) | (last_status & mask); sd->card_status &= ~CARD_STATUS_C | APP_CMD; response[0] = (status >> 24) & 0xff; response[1] = (status >> 16) & 0xff; response[2] = (status >> 8) & 0xff; response[3] = (status >> 0) & 0xff; }
--------------------------------------------- Result 713 ---------------------------------------------
[[0 (89%)]] --> [[0 (33%)]] --> Socre: 0.6695921123027802

[[[[Adv]]]]: static void monitor_find_completion(const char *[[cmdline]]) { const char *cmdname; char *args[MAX_ARGS]; int nb_args, i, len; const char *ptype, *str; const mon_cmd_t *cmd; const KeyDef *key; parse_cmdline([[cmdline]], &nb_args, args); #ifdef DEBUG_COMPLETION for(i = 0; i < nb_args; i++) { monitor_printf(cur_mon, "arg%d = '%s'\n", i, (char *)args[i]); } #endif len = strlen([[cmdline]]); if (len > 0 && qemu_isspace([[cmdline]][len - 1])) { if (nb_args >= MAX_ARGS) return; args[nb_args++] = qemu_strdup(""); } if (nb_args <= 1) { if (nb_args == 0) cmdname = ""; else cmdname = args[0]; readline_set_completion_index(cur_mon->rs, strlen(cmdname)); for(cmd = mon_cmds; cmd->name != NULL; cmd++) { cmd_completion(cmdname, cmd->name); } } else { for(cmd = mon_cmds; cmd->name != NULL; cmd++) { if (compare_cmd(args[0], cmd->name)) goto found; } return; found: ptype = next_arg_type(cmd->args_type); for(i = 0; i < nb_args - 2; i++) { if (*ptype != '\0') { ptype = next_arg_type(ptype); while (*ptype == '?') ptype = next_arg_type(ptype); } } str = args[nb_args - 1]; if (*ptype == '-' && ptype[1] != '\0') { ptype += 2; } switch(*ptype) { case 'F': readline_set_completion_index(cur_mon->rs, strlen(str)); file_completion(str); break; case 'B': readline_set_completion_index(cur_mon->rs, strlen(str)); bdrv_iterate(block_completion_it, (void *)str); break; case 's': if (!strcmp(cmd->name, "info")) { readline_set_completion_index(cur_mon->rs, strlen(str)); for(cmd = info_cmds; cmd->name != NULL; cmd++) { cmd_completion(str, cmd->name); } } else if (!strcmp(cmd->name, "sendkey")) { char *sep = strrchr(str, '-'); if (sep) str = sep + 1; readline_set_completion_index(cur_mon->rs, strlen(str)); for(key = key_defs; key->name != NULL; key++) { cmd_completion(str, key->name); } } else if (!strcmp(cmd->name, "help|?")) { readline_set_completion_index(cur_mon->rs, strlen(str)); for (cmd = mon_cmds; cmd->name != NULL; cmd++) { cmd_completion(str, cmd->name); } } break; default: break; } } for(i = 0; i < nb_args; i++) qemu_free(args[i]); }

[[[[Adv]]]]: static void monitor_find_completion(const char *[[suilzinae]]) { const char *cmdname; char *args[MAX_ARGS]; int nb_args, i, len; const char *ptype, *str; const mon_cmd_t *cmd; const KeyDef *key; parse_cmdline([[suilzinae]], &nb_args, args); #ifdef DEBUG_COMPLETION for(i = 0; i < nb_args; i++) { monitor_printf(cur_mon, "arg%d = '%s'\n", i, (char *)args[i]); } #endif len = strlen([[suilzinae]]); if (len > 0 && qemu_isspace([[suilzinae]][len - 1])) { if (nb_args >= MAX_ARGS) return; args[nb_args++] = qemu_strdup(""); } if (nb_args <= 1) { if (nb_args == 0) cmdname = ""; else cmdname = args[0]; readline_set_completion_index(cur_mon->rs, strlen(cmdname)); for(cmd = mon_cmds; cmd->name != NULL; cmd++) { cmd_completion(cmdname, cmd->name); } } else { for(cmd = mon_cmds; cmd->name != NULL; cmd++) { if (compare_cmd(args[0], cmd->name)) goto found; } return; found: ptype = next_arg_type(cmd->args_type); for(i = 0; i < nb_args - 2; i++) { if (*ptype != '\0') { ptype = next_arg_type(ptype); while (*ptype == '?') ptype = next_arg_type(ptype); } } str = args[nb_args - 1]; if (*ptype == '-' && ptype[1] != '\0') { ptype += 2; } switch(*ptype) { case 'F': readline_set_completion_index(cur_mon->rs, strlen(str)); file_completion(str); break; case 'B': readline_set_completion_index(cur_mon->rs, strlen(str)); bdrv_iterate(block_completion_it, (void *)str); break; case 's': if (!strcmp(cmd->name, "info")) { readline_set_completion_index(cur_mon->rs, strlen(str)); for(cmd = info_cmds; cmd->name != NULL; cmd++) { cmd_completion(str, cmd->name); } } else if (!strcmp(cmd->name, "sendkey")) { char *sep = strrchr(str, '-'); if (sep) str = sep + 1; readline_set_completion_index(cur_mon->rs, strlen(str)); for(key = key_defs; key->name != NULL; key++) { cmd_completion(str, key->name); } } else if (!strcmp(cmd->name, "help|?")) { readline_set_completion_index(cur_mon->rs, strlen(str)); for (cmd = mon_cmds; cmd->name != NULL; cmd++) { cmd_completion(str, cmd->name); } } break; default: break; } } for(i = 0; i < nb_args; i++) qemu_free(args[i]); }
--------------------------------------------- Result 714 ---------------------------------------------
[[0 (23%)]] --> [[0 (66%)]] --> Socre: 0.664262592792511

[[[[Adv]]]]: static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer, const char *model, const char *name, const char *ifname, const char *script, const char *[[downscript]], const char *vhostfdname, int vnet_hdr, int fd) { TAPState *[[s]]; [[s]] = net_tap_fd_init(peer, model, name, fd, vnet_hdr); if (![[s]]) { close(fd); return -1; } if (tap_set_sndbuf([[s]]->fd, tap) < 0) { return -1; } if (tap->has_fd || tap->has_fds) { snprintf([[s]]->nc.info_str, sizeof([[s]]->nc.info_str), "fd=%d", fd); } else if (tap->has_helper) { snprintf([[s]]->nc.info_str, sizeof([[s]]->nc.info_str), "helper=%s", tap->helper); } else { snprintf([[s]]->nc.info_str, sizeof([[s]]->nc.info_str), "ifname=%s,script=%s,downscript=%s", ifname, script, [[downscript]]); if (strcmp([[downscript]], "no") != 0) { snprintf([[s]]->down_script, sizeof([[s]]->down_script), "%s", [[downscript]]); snprintf([[s]]->down_script_arg, sizeof([[s]]->down_script_arg), "%s", ifname); } } if (tap->has_vhost ? tap->vhost : vhostfdname || (tap->has_vhostforce && tap->vhostforce)) { int vhostfd; if (tap->has_vhostfd) { vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname); if (vhostfd == -1) { return -1; } } else { vhostfd = -1; } [[s]]->vhost_net = vhost_net_init(&[[s]]->nc, vhostfd, tap->has_vhostforce && tap->vhostforce); if (![[s]]->vhost_net) { error_report("vhost-net requested but could not be initialized"); return -1; } } else if (tap->has_vhostfd || tap->has_vhostfds) { error_report("vhostfd= is not valid without vhost"); return -1; } return 0; }

[[[[Adv]]]]: static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer, const char *model, const char *name, const char *ifname, const char *script, const char *[[martinscans]], const char *vhostfdname, int vnet_hdr, int fd) { TAPState *[[days]]; [[days]] = net_tap_fd_init(peer, model, name, fd, vnet_hdr); if (![[days]]) { close(fd); return -1; } if (tap_set_sndbuf([[days]]->fd, tap) < 0) { return -1; } if (tap->has_fd || tap->has_fds) { snprintf([[days]]->nc.info_str, sizeof([[days]]->nc.info_str), "fd=%d", fd); } else if (tap->has_helper) { snprintf([[days]]->nc.info_str, sizeof([[days]]->nc.info_str), "helper=%s", tap->helper); } else { snprintf([[days]]->nc.info_str, sizeof([[days]]->nc.info_str), "ifname=%s,script=%s,downscript=%s", ifname, script, [[martinscans]]); if (strcmp([[martinscans]], "no") != 0) { snprintf([[days]]->down_script, sizeof([[days]]->down_script), "%s", [[martinscans]]); snprintf([[days]]->down_script_arg, sizeof([[days]]->down_script_arg), "%s", ifname); } } if (tap->has_vhost ? tap->vhost : vhostfdname || (tap->has_vhostforce && tap->vhostforce)) { int vhostfd; if (tap->has_vhostfd) { vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname); if (vhostfd == -1) { return -1; } } else { vhostfd = -1; } [[days]]->vhost_net = vhost_net_init(&[[days]]->nc, vhostfd, tap->has_vhostforce && tap->vhostforce); if (![[days]]->vhost_net) { error_report("vhost-net requested but could not be initialized"); return -1; } } else if (tap->has_vhostfd || tap->has_vhostfds) { error_report("vhostfd= is not valid without vhost"); return -1; } return 0; }
--------------------------------------------- Result 715 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 368 / 84 / 263 / 715:  27%|██▋       | 715/2690 [1:49:02<5:01:11,  9.15s/it][Succeeded / Failed / Skipped / Total] 368 / 84 / 263 / 715:  27%|██▋       | 716/2690 [1:49:03<5:00:39,  9.14s/it][Succeeded / Failed / Skipped / Total] 369 / 84 / 263 / 716:  27%|██▋       | 716/2690 [1:49:03<5:00:39,  9.14s/it][Succeeded / Failed / Skipped / Total] 369 / 84 / 263 / 716:  27%|██▋       | 717/2690 [1:49:03<5:00:06,  9.13s/it][Succeeded / Failed / Skipped / Total] 369 / 84 / 264 / 717:  27%|██▋       | 717/2690 [1:49:03<5:00:06,  9.13s/it][Succeeded / Failed / Skipped / Total] 369 / 84 / 264 / 717:  27%|██▋       | 718/2690 [1:49:34<5:00:56,  9.16s/it][[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: Visitor *qobject_input_visitor_new_keyval(QObject *obj) { QObjectInputVisitor *v = qobject_input_visitor_base_new(obj); v->visitor.type_int64 = qobject_input_type_int64_keyval; v->visitor.type_uint64 = qobject_input_type_uint64_keyval; v->visitor.type_bool = qobject_input_type_bool_keyval; v->visitor.type_str = qobject_input_type_str; v->visitor.type_number = qobject_input_type_number_keyval; v->visitor.type_any = qobject_input_type_any; v->visitor.type_null = qobject_input_type_null; v->visitor.type_size = qobject_input_type_size_keyval; return &v->visitor; }
--------------------------------------------- Result 716 ---------------------------------------------
[[0 (14%)]] --> [[0 (52%)]] --> Socre: 0.5249285697937012

[[[[Adv]]]]: DeviceState *qdev_try_create(BusState *bus, const char *[[name]]) { DeviceState *dev; if (object_class_by_name([[name]]) == NULL) { return NULL; } dev = DEVICE(object_new([[name]])); if (!dev) { return NULL; } if (!bus) { bus = sysbus_get_default(); } qdev_set_parent_bus(dev, bus); qdev_prop_set_globals(dev); return dev; }

[[[[Adv]]]]: DeviceState *qdev_try_create(BusState *bus, const char *[[memory]]) { DeviceState *dev; if (object_class_by_name([[memory]]) == NULL) { return NULL; } dev = DEVICE(object_new([[memory]])); if (!dev) { return NULL; } if (!bus) { bus = sysbus_get_default(); } qdev_set_parent_bus(dev, bus); qdev_prop_set_globals(dev); return dev; }
--------------------------------------------- Result 717 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table, float **plevel_table, uint16_t **pint_table, const CoefVLCTable *vlc_table) { int n = vlc_table->n; const uint8_t *table_bits = vlc_table->huffbits; const uint32_t *table_codes = vlc_table->huffcodes; const uint16_t *levels_table = vlc_table->levels; uint16_t *run_table, *level_table, *int_table; float *flevel_table; int i, l, j, k, level; init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0); run_table = av_malloc(n * sizeof(uint16_t)); level_table = av_malloc(n * sizeof(uint16_t)); flevel_table = av_malloc(n * sizeof(*flevel_table)); int_table = av_malloc(n * sizeof(uint16_t)); i = 2; level = 1; k = 0; while (i < n) { int_table[k] = i; l = levels_table[k++]; for (j = 0; j < l; j++) { run_table[i] = j; level_table[i] = level; flevel_table[i] = level; i++; } level++; } *prun_table = run_table; *plevel_table = flevel_table; *pint_table = int_table; av_free(level_table); }
--------------------------------------------- Result 718 ---------------------------------------------
[[0 (44%)]] --> [[0 (50%)]] --> Socre: 0.5005183219909668

[[[[Adv]]]]: static int mpc8_decode_frame(AVCodecContext * avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; MPCContext *c = avctx->priv_data; GetBitContext gb2, *gb = &gb2; int [[i]], j, k, ch, cnt, res, t; Band *bands = c->bands; int [[off]]; int maxband, keyframe; int last[2]; keyframe = c->cur_frame == 0; if(keyframe){ memset(c->Q, 0, sizeof(c->Q)); c->last_bits_used = 0; } init_get_bits(gb, buf, buf_size * 8); skip_bits(gb, c->last_bits_used & 7); if(keyframe) maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1); else{ maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2); if(maxband > 32) maxband -= 33; } c->last_max_band = maxband; if(maxband){ last[0] = last[1] = 0; for([[i]] = maxband - 1; [[i]] >= 0; [[i]]--){ for(ch = 0; ch < 2; ch++){ last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch]; if(last[ch] > 15) last[ch] -= 17; bands[[[i]]].res[ch] = last[ch]; } } if(c->MSS){ int mask; cnt = 0; for([[i]] = 0; [[i]] < maxband; [[i]]++) if(bands[[[i]]].res[0] || bands[[[i]]].res[1]) cnt++; t = mpc8_get_mod_golomb(gb, cnt); mask = mpc8_get_mask(gb, cnt, t); for([[i]] = maxband - 1; [[i]] >= 0; [[i]]--) if(bands[[[i]]].res[0] || bands[[[i]]].res[1]){ bands[[[i]]].msf = mask & 1; mask >>= 1; } } } for([[i]] = maxband; [[i]] < c->maxbands; [[i]]++) bands[[[i]]].res[0] = bands[[[i]]].res[1] = 0; if(keyframe){ for([[i]] = 0; [[i]] < 32; [[i]]++) c->oldDSCF[0][[[i]]] = c->oldDSCF[1][[[i]]] = 1; } for([[i]] = 0; [[i]] < maxband; [[i]]++){ if(bands[[[i]]].res[0] || bands[[[i]]].res[1]){ cnt = !!bands[[[i]]].res[0] + !!bands[[[i]]].res[1] - 1; if(cnt >= 0){ t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1); if(bands[[[i]]].res[0]) bands[[[i]]].scfi[0] = t >> (2 * cnt); if(bands[[[i]]].res[1]) bands[[[i]]].scfi[1] = t & 3; } } } for([[i]] = 0; [[i]] < maxband; [[i]]++){ for(ch = 0; ch < 2; ch++){ if(!bands[[[i]]].res[ch]) continue; if(c->oldDSCF[ch][[[i]]]){ bands[[[i]]].scf_idx[ch][0] = get_bits(gb, 7) - 6; c->oldDSCF[ch][[[i]]] = 0; }else{ t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2); if(t == 64) t += get_bits(gb, 6); bands[[[i]]].scf_idx[ch][0] = ((bands[[[i]]].scf_idx[ch][2] + t - 25) & 0x7F) - 6; } for(j = 0; j < 2; j++){ if((bands[[[i]]].scfi[ch] << j) & 2) bands[[[i]]].scf_idx[ch][j + 1] = bands[[[i]]].scf_idx[ch][j]; else{ t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2); if(t == 31) t = 64 + get_bits(gb, 6); bands[[[i]]].scf_idx[ch][j + 1] = ((bands[[[i]]].scf_idx[ch][j] + t - 25) & 0x7F) - 6; } } } } for([[i]] = 0, [[off]] = 0; [[i]] < maxband; [[i]]++, [[off]] += SAMPLES_PER_BAND){ for(ch = 0; ch < 2; ch++){ res = bands[[[i]]].res[ch]; switch(res){ case -1: for(j = 0; j < SAMPLES_PER_BAND; j++) c->Q[ch][[[off]] + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510; break; case 0: break; case 1: for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){ cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2); t = mpc8_get_mask(gb, 18, cnt); for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1) c->Q[ch][[[off]] + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0; } break; case 2: cnt = 6; for(j = 0; j < SAMPLES_PER_BAND; j += 3){ t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2); c->Q[ch][[[off]] + j + 0] = mpc8_idx50[t]; c->Q[ch][[[off]] + j + 1] = mpc8_idx51[t]; c->Q[ch][[[off]] + j + 2] = mpc8_idx52[t]; cnt = (cnt >> 1) + mpc8_huffq2[t]; } break; case 3: case 4: for(j = 0; j < SAMPLES_PER_BAND; j += 2){ t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3]; c->Q[ch][[[off]] + j + 1] = t >> 4; c->Q[ch][[[off]] + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF); } break; case 5: case 6: case 7: case 8: cnt = 2 * mpc8_thres[res]; for(j = 0; j < SAMPLES_PER_BAND; j++){ t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5]; c->Q[ch][[[off]] + j] = t; cnt = (cnt >> 1) + FFABS(c->Q[ch][[[off]] + j]); } break; default: for(j = 0; j < SAMPLES_PER_BAND; j++){ c->Q[ch][[[off]] + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2); if(res != 9){ c->Q[ch][[[off]] + j] <<= res - 9; c->Q[ch][[[off]] + j] |= get_bits(gb, res - 9); } c->Q[ch][[[off]] + j] -= (1 << (res - 2)) - 1; } } } } ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels); c->cur_frame++; c->last_bits_used = get_bits_count(gb); if(c->cur_frame >= c->frames) c->cur_frame = 0; *data_size = MPC_FRAME_SIZE * 2 * avctx->channels; return c->cur_frame ? c->last_bits_used >> 3 : buf_size; }

[[[[Adv]]]]: static int mpc8_decode_frame(AVCodecContext * avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; MPCContext *c = avctx->priv_data; GetBitContext gb2, *gb = &gb2; int [[gold]], j, k, ch, cnt, res, t; Band *bands = c->bands; int [[they]]; int maxband, keyframe; int last[2]; keyframe = c->cur_frame == 0; if(keyframe){ memset(c->Q, 0, sizeof(c->Q)); c->last_bits_used = 0; } init_get_bits(gb, buf, buf_size * 8); skip_bits(gb, c->last_bits_used & 7); if(keyframe) maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1); else{ maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2); if(maxband > 32) maxband -= 33; } c->last_max_band = maxband; if(maxband){ last[0] = last[1] = 0; for([[gold]] = maxband - 1; [[gold]] >= 0; [[gold]]--){ for(ch = 0; ch < 2; ch++){ last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch]; if(last[ch] > 15) last[ch] -= 17; bands[[[gold]]].res[ch] = last[ch]; } } if(c->MSS){ int mask; cnt = 0; for([[gold]] = 0; [[gold]] < maxband; [[gold]]++) if(bands[[[gold]]].res[0] || bands[[[gold]]].res[1]) cnt++; t = mpc8_get_mod_golomb(gb, cnt); mask = mpc8_get_mask(gb, cnt, t); for([[gold]] = maxband - 1; [[gold]] >= 0; [[gold]]--) if(bands[[[gold]]].res[0] || bands[[[gold]]].res[1]){ bands[[[gold]]].msf = mask & 1; mask >>= 1; } } } for([[gold]] = maxband; [[gold]] < c->maxbands; [[gold]]++) bands[[[gold]]].res[0] = bands[[[gold]]].res[1] = 0; if(keyframe){ for([[gold]] = 0; [[gold]] < 32; [[gold]]++) c->oldDSCF[0][[[gold]]] = c->oldDSCF[1][[[gold]]] = 1; } for([[gold]] = 0; [[gold]] < maxband; [[gold]]++){ if(bands[[[gold]]].res[0] || bands[[[gold]]].res[1]){ cnt = !!bands[[[gold]]].res[0] + !!bands[[[gold]]].res[1] - 1; if(cnt >= 0){ t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1); if(bands[[[gold]]].res[0]) bands[[[gold]]].scfi[0] = t >> (2 * cnt); if(bands[[[gold]]].res[1]) bands[[[gold]]].scfi[1] = t & 3; } } } for([[gold]] = 0; [[gold]] < maxband; [[gold]]++){ for(ch = 0; ch < 2; ch++){ if(!bands[[[gold]]].res[ch]) continue; if(c->oldDSCF[ch][[[gold]]]){ bands[[[gold]]].scf_idx[ch][0] = get_bits(gb, 7) - 6; c->oldDSCF[ch][[[gold]]] = 0; }else{ t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2); if(t == 64) t += get_bits(gb, 6); bands[[[gold]]].scf_idx[ch][0] = ((bands[[[gold]]].scf_idx[ch][2] + t - 25) & 0x7F) - 6; } for(j = 0; j < 2; j++){ if((bands[[[gold]]].scfi[ch] << j) & 2) bands[[[gold]]].scf_idx[ch][j + 1] = bands[[[gold]]].scf_idx[ch][j]; else{ t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2); if(t == 31) t = 64 + get_bits(gb, 6); bands[[[gold]]].scf_idx[ch][j + 1] = ((bands[[[gold]]].scf_idx[ch][j] + t - 25) & 0x7F) - 6; } } } } for([[gold]] = 0, [[they]] = 0; [[gold]] < maxband; [[gold]]++, [[they]] += SAMPLES_PER_BAND){ for(ch = 0; ch < 2; ch++){ res = bands[[[gold]]].res[ch]; switch(res){ case -1: for(j = 0; j < SAMPLES_PER_BAND; j++) c->Q[ch][[[they]] + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510; break; case 0: break; case 1: for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){ cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2); t = mpc8_get_mask(gb, 18, cnt); for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1) c->Q[ch][[[they]] + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0; } break; case 2: cnt = 6; for(j = 0; j < SAMPLES_PER_BAND; j += 3){ t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2); c->Q[ch][[[they]] + j + 0] = mpc8_idx50[t]; c->Q[ch][[[they]] + j + 1] = mpc8_idx51[t]; c->Q[ch][[[they]] + j + 2] = mpc8_idx52[t]; cnt = (cnt >> 1) + mpc8_huffq2[t]; } break; case 3: case 4: for(j = 0; j < SAMPLES_PER_BAND; j += 2){ t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3]; c->Q[ch][[[they]] + j + 1] = t >> 4; c->Q[ch][[[they]] + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF); } break; case 5: case 6: case 7: case 8: cnt = 2 * mpc8_thres[res]; for(j = 0; j < SAMPLES_PER_BAND; j++){ t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5]; c->Q[ch][[[they]] + j] = t; cnt = (cnt >> 1) + FFABS(c->Q[ch][[[they]] + j]); } break; default: for(j = 0; j < SAMPLES_PER_BAND; j++){ c->Q[ch][[[they]] + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2); if(res != 9){ c->Q[ch][[[they]] + j] <<= res - 9; c->Q[ch][[[they]] + j] |= get_bits(gb, res - 9); } c->Q[ch][[[they]] + j] -= (1 << (res - 2)) - 1; } } } } ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels); c->cur_frame++; c->last_bits_used = get_bits_count(gb); if(c->cur_frame >= c->frames) c->cur_frame = 0; *data_size = MPC_FRAME_SIZE * 2 * avctx->channels; return c->cur_frame ? c->last_bits_used >> 3 : buf_size; }[Succeeded / Failed / Skipped / Total] 370 / 84 / 264 / 718:  27%|██▋       | 718/2690 [1:49:34<5:00:56,  9.16s/it][Succeeded / Failed / Skipped / Total] 370 / 84 / 264 / 718:  27%|██▋       | 719/2690 [1:49:35<5:00:24,  9.14s/it]
--------------------------------------------- Result 719 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0, int log2_size, int c_idx) { #define PU(x) \ ((x) >> s->ps.sps->log2_min_pu_size) #define MVF(x, y) \ (s->ref->tab_mvf[(x) + (y) * min_pu_width]) #define MVF_PU(x, y) \ MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift))) #define IS_INTRA(x, y) \ (MVF_PU(x, y).pred_flag == PF_INTRA) #define MIN_TB_ADDR_ZS(x, y) \ s->ps.pps->min_tb_addr_zs[(y) * (s->ps.sps->tb_mask+2) + (x)] #define EXTEND(ptr, val, len) \ do { \ pixel4 pix = PIXEL_SPLAT_X4(val); \ for (i = 0; i < (len); i += 4) \ AV_WN4P(ptr + i, pix); \ } while (0) #define EXTEND_RIGHT_CIP(ptr, start, length) \ for (i = start; i < (start) + (length); i += 4) \ if (!IS_INTRA(i, -1)) \ AV_WN4P(&ptr[i], a); \ else \ a = PIXEL_SPLAT_X4(ptr[i+3]) #define EXTEND_LEFT_CIP(ptr, start, length) \ for (i = start; i > (start) - (length); i--) \ if (!IS_INTRA(i - 1, -1)) \ ptr[i - 1] = ptr[i] #define EXTEND_UP_CIP(ptr, start, length) \ for (i = (start); i > (start) - (length); i -= 4) \ if (!IS_INTRA(-1, i - 3)) \ AV_WN4P(&ptr[i - 3], a); \ else \ a = PIXEL_SPLAT_X4(ptr[i - 3]) #define EXTEND_DOWN_CIP(ptr, start, length) \ for (i = start; i < (start) + (length); i += 4) \ if (!IS_INTRA(-1, i)) \ AV_WN4P(&ptr[i], a); \ else \ a = PIXEL_SPLAT_X4(ptr[i + 3]) HEVCLocalContext *lc = s->HEVClc; int i; int hshift = s->ps.sps->hshift[c_idx]; int vshift = s->ps.sps->vshift[c_idx]; int size = (1 << log2_size); int size_in_luma_h = size << hshift; int size_in_tbs_h = size_in_luma_h >> s->ps.sps->log2_min_tb_size; int size_in_luma_v = size << vshift; int size_in_tbs_v = size_in_luma_v >> s->ps.sps->log2_min_tb_size; int x = x0 >> hshift; int y = y0 >> vshift; int x_tb = (x0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask; int y_tb = (y0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask; int cur_tb_addr = MIN_TB_ADDR_ZS(x_tb, y_tb); ptrdiff_t stride = s->frame->linesize[c_idx] / sizeof(pixel); pixel *src = (pixel*)s->frame->data[c_idx] + x + y * stride; int min_pu_width = s->ps.sps->min_pu_width; enum IntraPredMode mode = c_idx ? lc->tu.intra_pred_mode_c : lc->tu.intra_pred_mode; pixel4 a; pixel left_array[2 * MAX_TB_SIZE + 1]; pixel filtered_left_array[2 * MAX_TB_SIZE + 1]; pixel top_array[2 * MAX_TB_SIZE + 1]; pixel filtered_top_array[2 * MAX_TB_SIZE + 1]; pixel *left = left_array + 1; pixel *top = top_array + 1; pixel *filtered_left = filtered_left_array + 1; pixel *filtered_top = filtered_top_array + 1; int cand_bottom_left = lc->na.cand_bottom_left && cur_tb_addr > MIN_TB_ADDR_ZS( x_tb - 1, (y_tb + size_in_tbs_v) & s->ps.sps->tb_mask); int cand_left = lc->na.cand_left; int cand_up_left = lc->na.cand_up_left; int cand_up = lc->na.cand_up; int cand_up_right = lc->na.cand_up_right && cur_tb_addr > MIN_TB_ADDR_ZS((x_tb + size_in_tbs_h) & s->ps.sps->tb_mask, y_tb - 1); int bottom_left_size = (FFMIN(y0 + 2 * size_in_luma_v, s->ps.sps->height) - (y0 + size_in_luma_v)) >> vshift; int top_right_size = (FFMIN(x0 + 2 * size_in_luma_h, s->ps.sps->width) - (x0 + size_in_luma_h)) >> hshift; if (s->ps.pps->constrained_intra_pred_flag == 1) { int size_in_luma_pu_v = PU(size_in_luma_v); int size_in_luma_pu_h = PU(size_in_luma_h); int on_pu_edge_x = !av_mod_uintp2(x0, s->ps.sps->log2_min_pu_size); int on_pu_edge_y = !av_mod_uintp2(y0, s->ps.sps->log2_min_pu_size); if (!size_in_luma_pu_h) size_in_luma_pu_h++; if (cand_bottom_left == 1 && on_pu_edge_x) { int x_left_pu = PU(x0 - 1); int y_bottom_pu = PU(y0 + size_in_luma_v); int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_bottom_pu); cand_bottom_left = 0; for (i = 0; i < max; i += 2) cand_bottom_left |= (MVF(x_left_pu, y_bottom_pu + i).pred_flag == PF_INTRA); } if (cand_left == 1 && on_pu_edge_x) { int x_left_pu = PU(x0 - 1); int y_left_pu = PU(y0); int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_left_pu); cand_left = 0; for (i = 0; i < max; i += 2) cand_left |= (MVF(x_left_pu, y_left_pu + i).pred_flag == PF_INTRA); } if (cand_up_left == 1) { int x_left_pu = PU(x0 - 1); int y_top_pu = PU(y0 - 1); cand_up_left = MVF(x_left_pu, y_top_pu).pred_flag == PF_INTRA; } if (cand_up == 1 && on_pu_edge_y) { int x_top_pu = PU(x0); int y_top_pu = PU(y0 - 1); int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_top_pu); cand_up = 0; for (i = 0; i < max; i += 2) cand_up |= (MVF(x_top_pu + i, y_top_pu).pred_flag == PF_INTRA); } if (cand_up_right == 1 && on_pu_edge_y) { int y_top_pu = PU(y0 - 1); int x_right_pu = PU(x0 + size_in_luma_h); int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_right_pu); cand_up_right = 0; for (i = 0; i < max; i += 2) cand_up_right |= (MVF(x_right_pu + i, y_top_pu).pred_flag == PF_INTRA); } memset(left, 128, 2 * MAX_TB_SIZE*sizeof(pixel)); memset(top , 128, 2 * MAX_TB_SIZE*sizeof(pixel)); top[-1] = 128; } if (cand_up_left) { left[-1] = POS(-1, -1); top[-1] = left[-1]; } if (cand_up) memcpy(top, src - stride, size * sizeof(pixel)); if (cand_up_right) { memcpy(top + size, src - stride + size, size * sizeof(pixel)); EXTEND(top + size + top_right_size, POS(size + top_right_size - 1, -1), size - top_right_size); } if (cand_left) for (i = 0; i < size; i++) left[i] = POS(-1, i); if (cand_bottom_left) { for (i = size; i < size + bottom_left_size; i++) left[i] = POS(-1, i); EXTEND(left + size + bottom_left_size, POS(-1, size + bottom_left_size - 1), size - bottom_left_size); } if (s->ps.pps->constrained_intra_pred_flag == 1) { if (cand_bottom_left || cand_left || cand_up_left || cand_up || cand_up_right) { int size_max_x = x0 + ((2 * size) << hshift) < s->ps.sps->width ? 2 * size : (s->ps.sps->width - x0) >> hshift; int size_max_y = y0 + ((2 * size) << vshift) < s->ps.sps->height ? 2 * size : (s->ps.sps->height - y0) >> vshift; int j = size + (cand_bottom_left? bottom_left_size: 0) -1; if (!cand_up_right) { size_max_x = x0 + ((size) << hshift) < s->ps.sps->width ? size : (s->ps.sps->width - x0) >> hshift; } if (!cand_bottom_left) { size_max_y = y0 + (( size) << vshift) < s->ps.sps->height ? size : (s->ps.sps->height - y0) >> vshift; } if (cand_bottom_left || cand_left || cand_up_left) { while (j > -1 && !IS_INTRA(-1, j)) j--; if (!IS_INTRA(-1, j)) { j = 0; while (j < size_max_x && !IS_INTRA(j, -1)) j++; EXTEND_LEFT_CIP(top, j, j + 1); left[-1] = top[-1]; } } else { j = 0; while (j < size_max_x && !IS_INTRA(j, -1)) j++; if (j > 0) if (x0 > 0) { EXTEND_LEFT_CIP(top, j, j + 1); } else { EXTEND_LEFT_CIP(top, j, j); top[-1] = top[0]; } left[-1] = top[-1]; } left[-1] = top[-1]; if (cand_bottom_left || cand_left) { a = PIXEL_SPLAT_X4(left[-1]); EXTEND_DOWN_CIP(left, 0, size_max_y); } if (!cand_left) EXTEND(left, left[-1], size); if (!cand_bottom_left) EXTEND(left + size, left[size - 1], size); if (x0 != 0 && y0 != 0) { a = PIXEL_SPLAT_X4(left[size_max_y - 1]); EXTEND_UP_CIP(left, size_max_y - 1, size_max_y); if (!IS_INTRA(-1, - 1)) left[-1] = left[0]; } else if (x0 == 0) { EXTEND(left, 0, size_max_y); } else { a = PIXEL_SPLAT_X4(left[size_max_y - 1]); EXTEND_UP_CIP(left, size_max_y - 1, size_max_y); } top[-1] = left[-1]; if (y0 != 0) { a = PIXEL_SPLAT_X4(left[-1]); EXTEND_RIGHT_CIP(top, 0, size_max_x); } } } if (!cand_bottom_left) { if (cand_left) { EXTEND(left + size, left[size - 1], size); } else if (cand_up_left) { EXTEND(left, left[-1], 2 * size); cand_left = 1; } else if (cand_up) { left[-1] = top[0]; EXTEND(left, left[-1], 2 * size); cand_up_left = 1; cand_left = 1; } else if (cand_up_right) { EXTEND(top, top[size], size); left[-1] = top[size]; EXTEND(left, left[-1], 2 * size); cand_up = 1; cand_up_left = 1; cand_left = 1; } else { left[-1] = (1 << (BIT_DEPTH - 1)); EXTEND(top, left[-1], 2 * size); EXTEND(left, left[-1], 2 * size); } } if (!cand_left) EXTEND(left, left[size], size); if (!cand_up_left) { left[-1] = left[0]; } if (!cand_up) EXTEND(top, left[-1], size); if (!cand_up_right) EXTEND(top + size, top[size - 1], size); top[-1] = left[-1]; if (!s->ps.sps->intra_smoothing_disabled_flag && (c_idx == 0 || s->ps.sps->chroma_format_idc == 3)) { if (mode != INTRA_DC && size != 4){ int intra_hor_ver_dist_thresh[] = { 7, 1, 0 }; int min_dist_vert_hor = FFMIN(FFABS((int)(mode - 26U)), FFABS((int)(mode - 10U))); if (min_dist_vert_hor > intra_hor_ver_dist_thresh[log2_size - 3]) { int threshold = 1 << (BIT_DEPTH - 5); if (s->ps.sps->sps_strong_intra_smoothing_enable_flag && c_idx == 0 && log2_size == 5 && FFABS(top[-1] + top[63] - 2 * top[31]) < threshold && FFABS(left[-1] + left[63] - 2 * left[31]) < threshold) { filtered_top[-1] = top[-1]; filtered_top[63] = top[63]; for (i = 0; i < 63; i++) filtered_top[i] = ((64 - (i + 1)) * top[-1] + (i + 1) * top[63] + 32) >> 6; for (i = 0; i < 63; i++) left[i] = ((64 - (i + 1)) * left[-1] + (i + 1) * left[63] + 32) >> 6; top = filtered_top; } else { filtered_left[2 * size - 1] = left[2 * size - 1]; filtered_top[2 * size - 1] = top[2 * size - 1]; for (i = 2 * size - 2; i >= 0; i--) filtered_left[i] = (left[i + 1] + 2 * left[i] + left[i - 1] + 2) >> 2; filtered_top[-1] = filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2; for (i = 2 * size - 2; i >= 0; i--) filtered_top[i] = (top[i + 1] + 2 * top[i] + top[i - 1] + 2) >> 2; left = filtered_left; top = filtered_top; } } } } switch (mode) { case INTRA_PLANAR: s->hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top, (uint8_t *)left, stride); break; case INTRA_DC: s->hpc.pred_dc((uint8_t *)src, (uint8_t *)top, (uint8_t *)left, stride, log2_size, c_idx); break; default: s->hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top, (uint8_t *)left, stride, c_idx, mode); break; } }[Succeeded / Failed / Skipped / Total] 370 / 84 / 265 / 719:  27%|██▋       | 719/2690 [1:49:35<5:00:24,  9.14s/it][Succeeded / Failed / Skipped / Total] 370 / 84 / 265 / 719:  27%|██▋       | 720/2690 [1:49:53<5:00:40,  9.16s/it][Succeeded / Failed / Skipped / Total] 371 / 84 / 265 / 720:  27%|██▋       | 720/2690 [1:49:53<5:00:40,  9.16s/it][Succeeded / Failed / Skipped / Total] 371 / 84 / 265 / 720:  27%|██▋       | 721/2690 [1:50:07<5:00:45,  9.16s/it]
--------------------------------------------- Result 720 ---------------------------------------------
[[0 (43%)]] --> [[0 (77%)]] --> Socre: 0.7690754532814026

[[[[Adv]]]]: static void end_last_frame(AVFilterContext *ctx) { TileContext *tile = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFilterBufferRef *[[out_buf]] = outlink->out_buf; outlink->out_buf = NULL; ff_start_frame(outlink, [[out_buf]]); while (tile->current < tile->nb_frames) draw_blank_frame(ctx, [[out_buf]]); ff_draw_slice(outlink, 0, [[out_buf]]->video->h, 1); ff_end_frame(outlink); tile->current = 0; }

[[[[Adv]]]]: static void end_last_frame(AVFilterContext *ctx) { TileContext *tile = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFilterBufferRef *[[intercyfab]] = outlink->out_buf; outlink->out_buf = NULL; ff_start_frame(outlink, [[intercyfab]]); while (tile->current < tile->nb_frames) draw_blank_frame(ctx, [[intercyfab]]); ff_draw_slice(outlink, 0, [[intercyfab]]->video->h, 1); ff_end_frame(outlink); tile->current = 0; }
--------------------------------------------- Result 721 ---------------------------------------------
[[0 (27%)]] --> [[0 (51%)]] --> Socre: 0.5055686235427856

[[[[Adv]]]]: static inline int parse_nal_units(AVCodecParserContext *s, AVCodecContext *avctx, const uint8_t *buf, int buf_size) { H264ParseContext *p = s->priv_data; const uint8_t *buf_end = buf + buf_size; H2645NAL nal = { NULL }; unsigned int [[pps_id]]; unsigned int [[slice_type]]; int state = -1, got_reset = 0; int [[field_poc]][2]; int [[ret]]; s->pict_type = AV_PICTURE_TYPE_I; s->key_frame = 0; s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN; ff_h264_sei_uninit(&p->sei); if (!buf_size) return 0; for (;;) { const SPS *sps; int src_length, consumed; buf = avpriv_find_start_code(buf, buf_end, &state); if (buf >= buf_end) break; --buf; src_length = buf_end - buf; switch (state & 0x1f) { case H264_NAL_SLICE: case H264_NAL_IDR_SLICE: if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) { if (src_length > 60) src_length = 60; } else { if (src_length > 1000) src_length = 1000; } break; } consumed = ff_h2645_extract_rbsp(buf, src_length, &nal); if (consumed < 0) break; [[ret]] = init_get_bits(&nal.gb, nal.data, nal.size * 8); if ([[ret]] < 0) goto fail; get_bits1(&nal.gb); nal.ref_idc = get_bits(&nal.gb, 2); nal.type = get_bits(&nal.gb, 5); switch (nal.type) { case H264_NAL_SPS: ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps); break; case H264_NAL_PPS: ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps, nal.size_bits); break; case H264_NAL_SEI: ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx); break; case H264_NAL_IDR_SLICE: s->key_frame = 1; p->poc.prev_frame_num = 0; p->poc.prev_frame_num_offset = 0; p->poc.prev_poc_msb = p->poc.prev_poc_lsb = 0; case H264_NAL_SLICE: get_ue_golomb(&nal.gb); [[slice_type]] = get_ue_golomb_31(&nal.gb); s->pict_type = ff_h264_golomb_to_pict_type[[[slice_type]] % 5]; if (p->sei.recovery_point.recovery_frame_cnt >= 0) { s->key_frame = 1; } [[pps_id]] = get_ue_golomb(&nal.gb); if ([[pps_id]] >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, "pps_id %u out of range\n", [[pps_id]]); goto fail; } if (!p->ps.pps_list[[[pps_id]]]) { av_log(avctx, AV_LOG_ERROR, "non-existing PPS %u referenced\n", [[pps_id]]); goto fail; } p->ps.pps = (const PPS*)p->ps.pps_list[[[pps_id]]]->data; if (!p->ps.sps_list[p->ps.pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, "non-existing SPS %u referenced\n", p->ps.pps->sps_id); goto fail; } p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data; sps = p->ps.sps; p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num); s->coded_width = 16 * sps->mb_width; s->coded_height = 16 * sps->mb_height; s->width = s->coded_width - (sps->crop_right + sps->crop_left); s->height = s->coded_height - (sps->crop_top + sps->crop_bottom); if (s->width <= 0 || s->height <= 0) { s->width = s->coded_width; s->height = s->coded_height; } switch (sps->bit_depth_luma) { case 9: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P9; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9; else s->format = AV_PIX_FMT_YUV420P9; break; case 10: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P10; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10; else s->format = AV_PIX_FMT_YUV420P10; break; case 8: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P; else s->format = AV_PIX_FMT_YUV420P; break; default: s->format = AV_PIX_FMT_NONE; } avctx->profile = ff_h264_get_profile(sps); avctx->level = sps->level_idc; if (sps->frame_mbs_only_flag) { p->picture_structure = PICT_FRAME; } else { if (get_bits1(&nal.gb)) { p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); } else { p->picture_structure = PICT_FRAME; } } if (nal.type == H264_NAL_IDR_SLICE) get_ue_golomb(&nal.gb); if (sps->poc_type == 0) { p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb); if (p->ps.pps->pic_order_present == 1 && p->picture_structure == PICT_FRAME) p->poc.delta_poc_bottom = get_se_golomb(&nal.gb); } if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) { p->poc.delta_poc[0] = get_se_golomb(&nal.gb); if (p->ps.pps->pic_order_present == 1 && p->picture_structure == PICT_FRAME) p->poc.delta_poc[1] = get_se_golomb(&nal.gb); } [[field_poc]][0] = [[field_poc]][1] = INT_MAX; ff_h264_init_poc([[field_poc]], &s->output_picture_number, sps, &p->poc, p->picture_structure, nal.ref_idc); if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) { got_reset = scan_mmco_reset(s, &nal.gb, avctx); if (got_reset < 0) goto fail; } p->poc.prev_frame_num = got_reset ? 0 : p->poc.frame_num; p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset; if (nal.ref_idc != 0) { if (!got_reset) { p->poc.prev_poc_msb = p->poc.poc_msb; p->poc.prev_poc_lsb = p->poc.poc_lsb; } else { p->poc.prev_poc_msb = 0; p->poc.prev_poc_lsb = p->picture_structure == PICT_BOTTOM_FIELD ? 0 : [[field_poc]][0]; } } if (sps->pic_struct_present_flag) { switch (p->sei.picture_timing.pic_struct) { case SEI_PIC_STRUCT_TOP_FIELD: case SEI_PIC_STRUCT_BOTTOM_FIELD: s->repeat_pict = 0; break; case SEI_PIC_STRUCT_FRAME: case SEI_PIC_STRUCT_TOP_BOTTOM: case SEI_PIC_STRUCT_BOTTOM_TOP: s->repeat_pict = 1; break; case SEI_PIC_STRUCT_TOP_BOTTOM_TOP: case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: s->repeat_pict = 2; break; case SEI_PIC_STRUCT_FRAME_DOUBLING: s->repeat_pict = 3; break; case SEI_PIC_STRUCT_FRAME_TRIPLING: s->repeat_pict = 5; break; default: s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0; break; } } else { s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0; } if (p->picture_structure == PICT_FRAME) { s->picture_structure = AV_PICTURE_STRUCTURE_FRAME; if (sps->pic_struct_present_flag) { switch (p->sei.picture_timing.pic_struct) { case SEI_PIC_STRUCT_TOP_BOTTOM: case SEI_PIC_STRUCT_TOP_BOTTOM_TOP: s->field_order = AV_FIELD_TT; break; case SEI_PIC_STRUCT_BOTTOM_TOP: case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: s->field_order = AV_FIELD_BB; break; default: s->field_order = AV_FIELD_PROGRESSIVE; break; } } else { if ([[field_poc]][0] < [[field_poc]][1]) s->field_order = AV_FIELD_TT; else if ([[field_poc]][0] > [[field_poc]][1]) s->field_order = AV_FIELD_BB; else s->field_order = AV_FIELD_PROGRESSIVE; } } else { if (p->picture_structure == PICT_TOP_FIELD) s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD; else s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD; s->field_order = AV_FIELD_UNKNOWN; } av_freep(&nal.rbsp_buffer); return 0; } buf += consumed; } av_log(avctx, AV_LOG_ERROR, "missing picture in access unit\n"); fail: av_freep(&nal.rbsp_buffer); return -1; }

[[[[Adv]]]]: static inline int parse_nal_units(AVCodecParserContext *s, AVCodecContext *avctx, const uint8_t *buf, int buf_size) { H264ParseContext *p = s->priv_data; const uint8_t *buf_end = buf + buf_size; H2645NAL nal = { NULL }; unsigned int [[claspsompinch]]; unsigned int [[iverpartyline]]; int state = -1, got_reset = 0; int [[term_encs]][2]; int [[turbored]]; s->pict_type = AV_PICTURE_TYPE_I; s->key_frame = 0; s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN; ff_h264_sei_uninit(&p->sei); if (!buf_size) return 0; for (;;) { const SPS *sps; int src_length, consumed; buf = avpriv_find_start_code(buf, buf_end, &state); if (buf >= buf_end) break; --buf; src_length = buf_end - buf; switch (state & 0x1f) { case H264_NAL_SLICE: case H264_NAL_IDR_SLICE: if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) { if (src_length > 60) src_length = 60; } else { if (src_length > 1000) src_length = 1000; } break; } consumed = ff_h2645_extract_rbsp(buf, src_length, &nal); if (consumed < 0) break; [[turbored]] = init_get_bits(&nal.gb, nal.data, nal.size * 8); if ([[turbored]] < 0) goto fail; get_bits1(&nal.gb); nal.ref_idc = get_bits(&nal.gb, 2); nal.type = get_bits(&nal.gb, 5); switch (nal.type) { case H264_NAL_SPS: ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps); break; case H264_NAL_PPS: ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps, nal.size_bits); break; case H264_NAL_SEI: ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx); break; case H264_NAL_IDR_SLICE: s->key_frame = 1; p->poc.prev_frame_num = 0; p->poc.prev_frame_num_offset = 0; p->poc.prev_poc_msb = p->poc.prev_poc_lsb = 0; case H264_NAL_SLICE: get_ue_golomb(&nal.gb); [[iverpartyline]] = get_ue_golomb_31(&nal.gb); s->pict_type = ff_h264_golomb_to_pict_type[[[iverpartyline]] % 5]; if (p->sei.recovery_point.recovery_frame_cnt >= 0) { s->key_frame = 1; } [[claspsompinch]] = get_ue_golomb(&nal.gb); if ([[claspsompinch]] >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, "pps_id %u out of range\n", [[claspsompinch]]); goto fail; } if (!p->ps.pps_list[[[claspsompinch]]]) { av_log(avctx, AV_LOG_ERROR, "non-existing PPS %u referenced\n", [[claspsompinch]]); goto fail; } p->ps.pps = (const PPS*)p->ps.pps_list[[[claspsompinch]]]->data; if (!p->ps.sps_list[p->ps.pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, "non-existing SPS %u referenced\n", p->ps.pps->sps_id); goto fail; } p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data; sps = p->ps.sps; p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num); s->coded_width = 16 * sps->mb_width; s->coded_height = 16 * sps->mb_height; s->width = s->coded_width - (sps->crop_right + sps->crop_left); s->height = s->coded_height - (sps->crop_top + sps->crop_bottom); if (s->width <= 0 || s->height <= 0) { s->width = s->coded_width; s->height = s->coded_height; } switch (sps->bit_depth_luma) { case 9: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P9; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9; else s->format = AV_PIX_FMT_YUV420P9; break; case 10: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P10; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10; else s->format = AV_PIX_FMT_YUV420P10; break; case 8: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P; else s->format = AV_PIX_FMT_YUV420P; break; default: s->format = AV_PIX_FMT_NONE; } avctx->profile = ff_h264_get_profile(sps); avctx->level = sps->level_idc; if (sps->frame_mbs_only_flag) { p->picture_structure = PICT_FRAME; } else { if (get_bits1(&nal.gb)) { p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); } else { p->picture_structure = PICT_FRAME; } } if (nal.type == H264_NAL_IDR_SLICE) get_ue_golomb(&nal.gb); if (sps->poc_type == 0) { p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb); if (p->ps.pps->pic_order_present == 1 && p->picture_structure == PICT_FRAME) p->poc.delta_poc_bottom = get_se_golomb(&nal.gb); } if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) { p->poc.delta_poc[0] = get_se_golomb(&nal.gb); if (p->ps.pps->pic_order_present == 1 && p->picture_structure == PICT_FRAME) p->poc.delta_poc[1] = get_se_golomb(&nal.gb); } [[term_encs]][0] = [[term_encs]][1] = INT_MAX; ff_h264_init_poc([[term_encs]], &s->output_picture_number, sps, &p->poc, p->picture_structure, nal.ref_idc); if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) { got_reset = scan_mmco_reset(s, &nal.gb, avctx); if (got_reset < 0) goto fail; } p->poc.prev_frame_num = got_reset ? 0 : p->poc.frame_num; p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset; if (nal.ref_idc != 0) { if (!got_reset) { p->poc.prev_poc_msb = p->poc.poc_msb; p->poc.prev_poc_lsb = p->poc.poc_lsb; } else { p->poc.prev_poc_msb = 0; p->poc.prev_poc_lsb = p->picture_structure == PICT_BOTTOM_FIELD ? 0 : [[term_encs]][0]; } } if (sps->pic_struct_present_flag) { switch (p->sei.picture_timing.pic_struct) { case SEI_PIC_STRUCT_TOP_FIELD: case SEI_PIC_STRUCT_BOTTOM_FIELD: s->repeat_pict = 0; break; case SEI_PIC_STRUCT_FRAME: case SEI_PIC_STRUCT_TOP_BOTTOM: case SEI_PIC_STRUCT_BOTTOM_TOP: s->repeat_pict = 1; break; case SEI_PIC_STRUCT_TOP_BOTTOM_TOP: case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: s->repeat_pict = 2; break; case SEI_PIC_STRUCT_FRAME_DOUBLING: s->repeat_pict = 3; break; case SEI_PIC_STRUCT_FRAME_TRIPLING: s->repeat_pict = 5; break; default: s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0; break; } } else { s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0; } if (p->picture_structure == PICT_FRAME) { s->picture_structure = AV_PICTURE_STRUCTURE_FRAME; if (sps->pic_struct_present_flag) { switch (p->sei.picture_timing.pic_struct) { case SEI_PIC_STRUCT_TOP_BOTTOM: case SEI_PIC_STRUCT_TOP_BOTTOM_TOP: s->field_order = AV_FIELD_TT; break; case SEI_PIC_STRUCT_BOTTOM_TOP: case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: s->field_order = AV_FIELD_BB; break; default: s->field_order = AV_FIELD_PROGRESSIVE; break; } } else { if ([[term_encs]][0] < [[term_encs]][1]) s->field_order = AV_FIELD_TT; else if ([[term_encs]][0] > [[term_encs]][1]) s->field_order = AV_FIELD_BB; else s->field_order = AV_FIELD_PROGRESSIVE; } } else { if (p->picture_structure == PICT_TOP_FIELD) s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD; else s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD; s->field_order = AV_FIELD_UNKNOWN; } av_freep(&nal.rbsp_buffer); return 0; } buf += consumed; } av_log(avctx, AV_LOG_ERROR, "missing picture in access unit\n"); fail: av_freep(&nal.rbsp_buffer); return -1; }[Succeeded / Failed / Skipped / Total] 372 / 84 / 265 / 721:  27%|██▋       | 721/2690 [1:50:07<5:00:45,  9.16s/it][Succeeded / Failed / Skipped / Total] 372 / 84 / 265 / 721:  27%|██▋       | 722/2690 [1:50:32<5:01:19,  9.19s/it][Succeeded / Failed / Skipped / Total] 373 / 84 / 265 / 722:  27%|██▋       | 722/2690 [1:50:32<5:01:19,  9.19s/it][Succeeded / Failed / Skipped / Total] 373 / 84 / 265 / 722:  27%|██▋       | 723/2690 [1:50:33<5:00:46,  9.17s/it][Succeeded / Failed / Skipped / Total] 373 / 84 / 266 / 723:  27%|██▋       | 723/2690 [1:50:33<5:00:46,  9.17s/it][Succeeded / Failed / Skipped / Total] 373 / 84 / 266 / 723:  27%|██▋       | 724/2690 [1:50:36<5:00:21,  9.17s/it][Succeeded / Failed / Skipped / Total] 373 / 85 / 266 / 724:  27%|██▋       | 724/2690 [1:50:36<5:00:21,  9.17s/it][Succeeded / Failed / Skipped / Total] 373 / 85 / 266 / 724:  27%|██▋       | 725/2690 [1:50:37<4:59:49,  9.15s/it][Succeeded / Failed / Skipped / Total] 373 / 85 / 267 / 725:  27%|██▋       | 725/2690 [1:50:37<4:59:49,  9.15s/it][Succeeded / Failed / Skipped / Total] 373 / 85 / 267 / 725:  27%|██▋       | 726/2690 [1:51:00<5:00:18,  9.17s/it][Succeeded / Failed / Skipped / Total] 374 / 85 / 267 / 726:  27%|██▋       | 726/2690 [1:51:00<5:00:18,  9.17s/it][Succeeded / Failed / Skipped / Total] 374 / 85 / 267 / 726:  27%|██▋       | 727/2690 [1:51:01<4:59:46,  9.16s/it][Succeeded / Failed / Skipped / Total] 374 / 85 / 268 / 727:  27%|██▋       | 727/2690 [1:51:01<4:59:46,  9.16s/it][Succeeded / Failed / Skipped / Total] 374 / 85 / 268 / 727:  27%|██▋       | 728/2690 [1:51:01<4:59:14,  9.15s/it]
--------------------------------------------- Result 722 ---------------------------------------------
[[0 (19%)]] --> [[0 (55%)]] --> Socre: 0.5511441230773926

[[[[Adv]]]]: void av_register_output_format(AVOutputFormat *[[format]]) { AVOutputFormat **[[p]] = &first_oformat; while (*[[p]] != NULL) [[p]] = &(*[[p]])->next; *[[p]] = [[format]]; [[format]]->next = NULL; }

[[[[Adv]]]]: void av_register_output_format(AVOutputFormat *[[video]]) { AVOutputFormat **[[m]] = &first_oformat; while (*[[m]] != NULL) [[m]] = &(*[[m]])->next; *[[m]] = [[video]]; [[video]]->next = NULL; }
--------------------------------------------- Result 723 ---------------------------------------------
[[0 (79%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame, int perms) { AVFilterBufferRef *picref = avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms, frame->width, frame->height, frame->format); if (!picref) return NULL; avfilter_copy_frame_props(picref, frame); return picref; }
--------------------------------------------- Result 724 ---------------------------------------------
[[0 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void *pl080_init(uint32_t [[base]], qemu_irq [[irq]], int [[nchannels]]) { int [[iomemtype]]; pl080_state *[[s]]; [[s]] = (pl080_state *)qemu_mallocz(sizeof(pl080_state)); [[iomemtype]] = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, [[s]]); cpu_register_physical_memory([[base]], 0x00000fff, [[iomemtype]]); [[s]]->base = [[base]]; [[s]]->irq = [[irq]]; [[s]]->nchannels = [[nchannels]]; return [[s]]; }

[[[[Adv]]]]: void *pl080_init(uint32_t [[park]], qemu_irq [[eepark]], int [[kysenells]]) { int [[iodetsem]]; pl080_state *[[acts]]; [[acts]] = (pl080_state *)qemu_mallocz(sizeof(pl080_state)); [[iodetsem]] = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, [[acts]]); cpu_register_physical_memory([[park]], 0x00000fff, [[iodetsem]]); [[acts]]->base = [[park]]; [[acts]]->irq = [[eepark]]; [[acts]]->nchannels = [[kysenells]]; return [[acts]]; }
--------------------------------------------- Result 725 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc) { AVStream *st; OutputStream *ost; AVCodecContext *audio_enc; ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO); st = ost->st; audio_enc = st->codec; audio_enc->codec_type = AVMEDIA_TYPE_AUDIO; if (!ost->stream_copy) { char *sample_fmt = NULL; MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st); MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st); if (sample_fmt && (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) { av_log(NULL, AV_LOG_FATAL, "Invalid sample format '%s'\n", sample_fmt); exit_program(1); } MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st); } return ost; }
--------------------------------------------- Result 726 ---------------------------------------------
[[0 (83%)]] --> [[0 (39%)]] --> Socre: 0.6120094656944275

[[[[Adv]]]]: void *g_realloc(void *[[ptr]], size_t size) { size_t old_size, copy; void *new_ptr; if (![[ptr]]) return g_malloc(size); old_size = *(size_t *)((char *)[[ptr]] - 16); copy = old_size < size ? old_size : size; new_ptr = g_malloc(size); memcpy(new_ptr, [[ptr]], copy); g_free([[ptr]]); return new_ptr; }

[[[[Adv]]]]: void *g_realloc(void *[[tango]], size_t size) { size_t old_size, copy; void *new_ptr; if (![[tango]]) return g_malloc(size); old_size = *(size_t *)((char *)[[tango]] - 16); copy = old_size < size ? old_size : size; new_ptr = g_malloc(size); memcpy(new_ptr, [[tango]], copy); g_free([[tango]]); return new_ptr; }
--------------------------------------------- Result 727 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ioport_write(void *opaque, uint32_t addr, uint32_t val) { PCIQXLDevice *d = opaque; uint32_t io_port = addr - d->io_base; switch (io_port) { case QXL_IO_RESET: case QXL_IO_SET_MODE: case QXL_IO_MEMSLOT_ADD: case QXL_IO_MEMSLOT_DEL: case QXL_IO_CREATE_PRIMARY: break; default: if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT) break; dprint(d, 1, "%s: unexpected port 0x%x in vga mode\n", __FUNCTION__, io_port); return; } switch (io_port) { case QXL_IO_UPDATE_AREA: { QXLRect update = d->ram->update_area; qemu_mutex_unlock_iothread(); d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface, &update, NULL, 0, 0); qemu_mutex_lock_iothread(); break; } case QXL_IO_NOTIFY_CMD: d->ssd.worker->wakeup(d->ssd.worker); break; case QXL_IO_NOTIFY_CURSOR: d->ssd.worker->wakeup(d->ssd.worker); break; case QXL_IO_UPDATE_IRQ: qxl_set_irq(d); break; case QXL_IO_NOTIFY_OOM: if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) { break; } pthread_yield(); if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) { break; } d->oom_running = 1; d->ssd.worker->oom(d->ssd.worker); d->oom_running = 0; break; case QXL_IO_SET_MODE: dprint(d, 1, "QXL_SET_MODE %d\n", val); qxl_set_mode(d, val, 0); break; case QXL_IO_LOG: if (d->guestdebug) { fprintf(stderr, "qxl/guest: %s", d->ram->log_buf); } break; case QXL_IO_RESET: dprint(d, 1, "QXL_IO_RESET\n"); qxl_hard_reset(d, 0); break; case QXL_IO_MEMSLOT_ADD: PANIC_ON(val >= NUM_MEMSLOTS); PANIC_ON(d->guest_slots[val].active); d->guest_slots[val].slot = d->ram->mem_slot; qxl_add_memslot(d, val, 0); break; case QXL_IO_MEMSLOT_DEL: qxl_del_memslot(d, val); break; case QXL_IO_CREATE_PRIMARY: PANIC_ON(val != 0); dprint(d, 1, "QXL_IO_CREATE_PRIMARY\n"); d->guest_primary.surface = d->ram->create_surface; qxl_create_guest_primary(d, 0); break; case QXL_IO_DESTROY_PRIMARY: PANIC_ON(val != 0); dprint(d, 1, "QXL_IO_DESTROY_PRIMARY\n"); qxl_destroy_primary(d); break; case QXL_IO_DESTROY_SURFACE_WAIT: d->ssd.worker->destroy_surface_wait(d->ssd.worker, val); break; case QXL_IO_DESTROY_ALL_SURFACES: d->ssd.worker->destroy_surfaces(d->ssd.worker); break; default: fprintf(stderr, "%s: ioport=0x%x, abort()\n", __FUNCTION__, io_port); abort(); } }
--------------------------------------------- Result 728 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl) { const SPS *sps; const PPS *pps; unsigned int first_mb_in_slice; unsigned int pps_id; int ret; unsigned int slice_type, tmp, i; int last_pic_structure, last_pic_droppable; int needs_reinit = 0; int field_pic_flag, bottom_field_flag; int frame_num, droppable, picture_structure; int mb_aff_frame = 0; first_mb_in_slice = get_ue_golomb(&sl->gb); if (first_mb_in_slice == 0) { if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) { ff_h264_field_end(h, sl, 1); } h->current_slice = 0; if (!h->first_field) { if (h->cur_pic_ptr && !h->droppable) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, h->picture_structure == PICT_BOTTOM_FIELD); } h->cur_pic_ptr = NULL; } } slice_type = get_ue_golomb_31(&sl->gb); if (slice_type > 9) { av_log(h->avctx, AV_LOG_ERROR, "slice type %d too large at %d\n", slice_type, first_mb_in_slice); return AVERROR_INVALIDDATA; } if (slice_type > 4) { slice_type -= 5; sl->slice_type_fixed = 1; } else sl->slice_type_fixed = 0; slice_type = ff_h264_golomb_to_pict_type[slice_type]; sl->slice_type = slice_type; sl->slice_type_nos = slice_type & 3; if (h->nal_unit_type == NAL_IDR_SLICE && sl->slice_type_nos != AV_PICTURE_TYPE_I) { av_log(h->avctx, AV_LOG_ERROR, "A non-intra slice in an IDR NAL unit.\n"); return AVERROR_INVALIDDATA; } pps_id = get_ue_golomb(&sl->gb); if (pps_id >= MAX_PPS_COUNT) { av_log(h->avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id); return AVERROR_INVALIDDATA; } if (!h->ps.pps_list[pps_id]) { av_log(h->avctx, AV_LOG_ERROR, "non-existing PPS %u referenced\n", pps_id); return AVERROR_INVALIDDATA; } if (!h->setup_finished) { h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data; } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) { av_log(h->avctx, AV_LOG_ERROR, "PPS changed between slices\n"); return AVERROR_INVALIDDATA; } if (!h->ps.sps_list[h->ps.pps->sps_id]) { av_log(h->avctx, AV_LOG_ERROR, "non-existing SPS %u referenced\n", h->ps.pps->sps_id); return AVERROR_INVALIDDATA; } if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) { h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data; if (h->bit_depth_luma != h->ps.sps->bit_depth_luma || h->chroma_format_idc != h->ps.sps->chroma_format_idc) needs_reinit = 1; } pps = h->ps.pps; sps = h->ps.sps; if (!h->setup_finished) { h->avctx->profile = ff_h264_get_profile(sps); h->avctx->level = sps->level_idc; h->avctx->refs = sps->ref_frame_count; if (h->mb_width != sps->mb_width || h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag)) needs_reinit = 1; h->mb_width = sps->mb_width; h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag); h->mb_num = h->mb_width * h->mb_height; h->mb_stride = h->mb_width + 1; h->b_stride = h->mb_width * 4; h->chroma_y_shift = sps->chroma_format_idc <= 1; h->width = 16 * h->mb_width; h->height = 16 * h->mb_height; ret = init_dimensions(h); if (ret < 0) return ret; if (sps->video_signal_type_present_flag) { h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; if (sps->colour_description_present_flag) { if (h->avctx->colorspace != sps->colorspace) needs_reinit = 1; h->avctx->color_primaries = sps->color_primaries; h->avctx->color_trc = sps->color_trc; h->avctx->colorspace = sps->colorspace; } } } if (h->context_initialized && needs_reinit) { h->context_initialized = 0; if (sl != h->slice_ctx) { av_log(h->avctx, AV_LOG_ERROR, "changing width %d -> %d / height %d -> %d on " "slice %d\n", h->width, h->avctx->coded_width, h->height, h->avctx->coded_height, h->current_slice + 1); return AVERROR_INVALIDDATA; } ff_h264_flush_change(h); if ((ret = get_pixel_format(h)) < 0) return ret; h->avctx->pix_fmt = ret; av_log(h->avctx, AV_LOG_INFO, "Reinit context to %dx%d, " "pix_fmt: %d\n", h->width, h->height, h->avctx->pix_fmt); if ((ret = h264_slice_header_init(h)) < 0) { av_log(h->avctx, AV_LOG_ERROR, "h264_slice_header_init() failed\n"); return ret; } } if (!h->context_initialized) { if (sl != h->slice_ctx) { av_log(h->avctx, AV_LOG_ERROR, "Cannot (re-)initialize context during parallel decoding.\n"); return AVERROR_PATCHWELCOME; } if ((ret = get_pixel_format(h)) < 0) return ret; h->avctx->pix_fmt = ret; if ((ret = h264_slice_header_init(h)) < 0) { av_log(h->avctx, AV_LOG_ERROR, "h264_slice_header_init() failed\n"); return ret; } } frame_num = get_bits(&sl->gb, sps->log2_max_frame_num); if (!h->setup_finished) h->poc.frame_num = frame_num; sl->mb_mbaff = 0; last_pic_structure = h->picture_structure; last_pic_droppable = h->droppable; droppable = h->nal_ref_idc == 0; if (sps->frame_mbs_only_flag) { picture_structure = PICT_FRAME; } else { field_pic_flag = get_bits1(&sl->gb); if (field_pic_flag) { bottom_field_flag = get_bits1(&sl->gb); picture_structure = PICT_TOP_FIELD + bottom_field_flag; } else { picture_structure = PICT_FRAME; mb_aff_frame = sps->mb_aff; } } if (!h->setup_finished) { h->droppable = droppable; h->picture_structure = picture_structure; h->mb_aff_frame = mb_aff_frame; } sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME; if (h->current_slice != 0) { if (last_pic_structure != picture_structure || last_pic_droppable != droppable) { av_log(h->avctx, AV_LOG_ERROR, "Changing field mode (%d -> %d) between slices is not allowed\n", last_pic_structure, h->picture_structure); return AVERROR_INVALIDDATA; } else if (!h->cur_pic_ptr) { av_log(h->avctx, AV_LOG_ERROR, "unset cur_pic_ptr on slice %d\n", h->current_slice + 1); return AVERROR_INVALIDDATA; } } else { if (h->poc.frame_num != h->poc.prev_frame_num) { int unwrap_prev_frame_num = h->poc.prev_frame_num; int max_frame_num = 1 << sps->log2_max_frame_num; if (unwrap_prev_frame_num > h->poc.frame_num) unwrap_prev_frame_num -= max_frame_num; if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) { unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1; if (unwrap_prev_frame_num < 0) unwrap_prev_frame_num += max_frame_num; h->poc.prev_frame_num = unwrap_prev_frame_num; } } if (h->first_field) { assert(h->cur_pic_ptr); assert(h->cur_pic_ptr->f->buf[0]); assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF); if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) { if (!last_pic_droppable && last_pic_structure != PICT_FRAME) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, last_pic_structure == PICT_TOP_FIELD); } } else { if (h->cur_pic_ptr->frame_num != h->poc.frame_num) { if (!last_pic_droppable && last_pic_structure != PICT_FRAME) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, last_pic_structure == PICT_TOP_FIELD); } } else { if (!((last_pic_structure == PICT_TOP_FIELD && h->picture_structure == PICT_BOTTOM_FIELD) || (last_pic_structure == PICT_BOTTOM_FIELD && h->picture_structure == PICT_TOP_FIELD))) { av_log(h->avctx, AV_LOG_ERROR, "Invalid field mode combination %d/%d\n", last_pic_structure, h->picture_structure); h->picture_structure = last_pic_structure; h->droppable = last_pic_droppable; return AVERROR_INVALIDDATA; } else if (last_pic_droppable != h->droppable) { avpriv_request_sample(h->avctx, "Found reference and non-reference fields in the same frame, which"); h->picture_structure = last_pic_structure; h->droppable = last_pic_droppable; return AVERROR_PATCHWELCOME; } } } } while (h->poc.frame_num != h->poc.prev_frame_num && h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) { H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL; av_log(h->avctx, AV_LOG_DEBUG, "Frame num gap %d %d\n", h->poc.frame_num, h->poc.prev_frame_num); ret = initialize_cur_frame(h); if (ret < 0) { h->first_field = 0; return ret; } h->poc.prev_frame_num++; h->poc.prev_frame_num %= 1 << sps->log2_max_frame_num; h->cur_pic_ptr->frame_num = h->poc.prev_frame_num; ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0); ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1); ret = ff_generate_sliding_window_mmcos(h, 1); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) return ret; ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) return ret; if (h->short_ref_count) { if (prev && h->short_ref[0]->f->width == prev->f->width && h->short_ref[0]->f->height == prev->f->height && h->short_ref[0]->f->format == prev->f->format) { av_image_copy(h->short_ref[0]->f->data, h->short_ref[0]->f->linesize, (const uint8_t **)prev->f->data, prev->f->linesize, prev->f->format, h->mb_width * 16, h->mb_height * 16); h->short_ref[0]->poc = prev->poc + 2; } h->short_ref[0]->frame_num = h->poc.prev_frame_num; } } if (h->first_field) { assert(h->cur_pic_ptr); assert(h->cur_pic_ptr->f->buf[0]); assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF); if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) { h->cur_pic_ptr = NULL; h->first_field = FIELD_PICTURE(h); } else { if (h->cur_pic_ptr->frame_num != h->poc.frame_num) { h->first_field = 1; h->cur_pic_ptr = NULL; } else { h->first_field = 0; } } } else { h->first_field = FIELD_PICTURE(h); } if (!FIELD_PICTURE(h) || h->first_field) { if (h264_frame_start(h) < 0) { h->first_field = 0; return AVERROR_INVALIDDATA; } } else { release_unused_pictures(h, 0); } } assert(h->mb_num == h->mb_width * h->mb_height); if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num || first_mb_in_slice >= h->mb_num) { av_log(h->avctx, AV_LOG_ERROR, "first_mb_in_slice overflow\n"); return AVERROR_INVALIDDATA; } sl->resync_mb_x = sl->mb_x = first_mb_in_slice % h->mb_width; sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) << FIELD_OR_MBAFF_PICTURE(h); if (h->picture_structure == PICT_BOTTOM_FIELD) sl->resync_mb_y = sl->mb_y = sl->mb_y + 1; assert(sl->mb_y < h->mb_height); if (h->picture_structure == PICT_FRAME) { h->curr_pic_num = h->poc.frame_num; h->max_pic_num = 1 << sps->log2_max_frame_num; } else { h->curr_pic_num = 2 * h->poc.frame_num + 1; h->max_pic_num = 1 << (sps->log2_max_frame_num + 1); } if (h->nal_unit_type == NAL_IDR_SLICE) get_ue_golomb(&sl->gb); if (sps->poc_type == 0) { int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb); if (!h->setup_finished) h->poc.poc_lsb = poc_lsb; if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) { int delta_poc_bottom = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc_bottom = delta_poc_bottom; } } if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) { int delta_poc = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc[0] = delta_poc; if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) { delta_poc = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc[1] = delta_poc; } } if (!h->setup_finished) ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc, sps, &h->poc, h->picture_structure, h->nal_ref_idc); if (pps->redundant_pic_cnt_present) sl->redundant_pic_count = get_ue_golomb(&sl->gb); if (sl->slice_type_nos == AV_PICTURE_TYPE_B) sl->direct_spatial_mv_pred = get_bits1(&sl->gb); ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count, &sl->gb, pps, sl->slice_type_nos, h->picture_structure); if (ret < 0) return ret; if (sl->slice_type_nos != AV_PICTURE_TYPE_I) { ret = ff_h264_decode_ref_pic_list_reordering(h, sl); if (ret < 0) { sl->ref_count[1] = sl->ref_count[0] = 0; return ret; } } sl->pwt.use_weight = 0; for (i = 0; i < 2; i++) { sl->pwt.luma_weight_flag[i] = 0; sl->pwt.chroma_weight_flag[i] = 0; } if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) || (pps->weighted_bipred_idc == 1 && sl->slice_type_nos == AV_PICTURE_TYPE_B)) ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count, sl->slice_type_nos, &sl->pwt); if (h->nal_ref_idc) { ret = ff_h264_decode_ref_pic_marking(h, &sl->gb, !(h->avctx->active_thread_type & FF_THREAD_FRAME) || h->current_slice == 0); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) return AVERROR_INVALIDDATA; } if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) { tmp = get_ue_golomb_31(&sl->gb); if (tmp > 2) { av_log(h->avctx, AV_LOG_ERROR, "cabac_init_idc %u overflow\n", tmp); return AVERROR_INVALIDDATA; } sl->cabac_init_idc = tmp; } sl->last_qscale_diff = 0; tmp = pps->init_qp + get_se_golomb(&sl->gb); if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) { av_log(h->avctx, AV_LOG_ERROR, "QP %u out of range\n", tmp); return AVERROR_INVALIDDATA; } sl->qscale = tmp; sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale); sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale); if (sl->slice_type == AV_PICTURE_TYPE_SP) get_bits1(&sl->gb); if (sl->slice_type == AV_PICTURE_TYPE_SP || sl->slice_type == AV_PICTURE_TYPE_SI) get_se_golomb(&sl->gb); sl->deblocking_filter = 1; sl->slice_alpha_c0_offset = 0; sl->slice_beta_offset = 0; if (pps->deblocking_filter_parameters_present) { tmp = get_ue_golomb_31(&sl->gb); if (tmp > 2) { av_log(h->avctx, AV_LOG_ERROR, "deblocking_filter_idc %u out of range\n", tmp); return AVERROR_INVALIDDATA; } sl->deblocking_filter = tmp; if (sl->deblocking_filter < 2) sl->deblocking_filter ^= 1; if (sl->deblocking_filter) { sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2; sl->slice_beta_offset = get_se_golomb(&sl->gb) * 2; if (sl->slice_alpha_c0_offset > 12 || sl->slice_alpha_c0_offset < -12 || sl->slice_beta_offset > 12 || sl->slice_beta_offset < -12) { av_log(h->avctx, AV_LOG_ERROR, "deblocking filter parameters %d %d out of range\n", sl->slice_alpha_c0_offset, sl->slice_beta_offset); return AVERROR_INVALIDDATA; } } } return 0; }[Succeeded / Failed / Skipped / Total] 374 / 85 / 269 / 728:  27%|██▋       | 728/2690 [1:51:01<4:59:14,  9.15s/it][Succeeded / Failed / Skipped / Total] 374 / 85 / 269 / 728:  27%|██▋       | 729/2690 [1:51:02<4:58:41,  9.14s/it]
--------------------------------------------- Result 729 ---------------------------------------------
[[0 (96%)]] --> [[0 (20%)]] --> Socre: 0.8031326532363892

[[[[Adv]]]]: static void decode_32Bit_opc(CPUTriCoreState *[[env]], DisasContext *[[ctx]]) { int op1; int32_t r1, r2, r3; int32_t address, const16; int8_t b, const4; int32_t bpos; TCGv temp, temp2, temp3; op1 = MASK_OP_MAJOR([[ctx]]->opcode); if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) { op1 = OPCM_32_BRN_JTT; } switch (op1) { case OPCM_32_ABS_LDW: decode_abs_ldw([[env]], [[ctx]]); case OPCM_32_ABS_LDB: decode_abs_ldb([[env]], [[ctx]]); case OPCM_32_ABS_LDMST_SWAP: decode_abs_ldst_swap([[env]], [[ctx]]); case OPCM_32_ABS_LDST_CONTEXT: decode_abs_ldst_context([[env]], [[ctx]]); case OPCM_32_ABS_STORE: decode_abs_store([[env]], [[ctx]]); case OPCM_32_ABS_STOREB_H: decode_abs_storeb_h([[env]], [[ctx]]); case OPC1_32_ABS_STOREQ: address = MASK_OP_ABS_OFF18([[ctx]]->opcode); r1 = MASK_OP_ABS_S1D([[ctx]]->opcode); temp = tcg_const_i32(EA_ABS_FORMAT(address)); temp2 = tcg_temp_new(); tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16); tcg_gen_qemu_st_tl(temp2, temp, [[ctx]]->mem_idx, MO_LEUW); tcg_temp_free(temp2); tcg_temp_free(temp); case OPC1_32_ABS_LD_Q: address = MASK_OP_ABS_OFF18([[ctx]]->opcode); r1 = MASK_OP_ABS_S1D([[ctx]]->opcode); temp = tcg_const_i32(EA_ABS_FORMAT(address)); tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, [[ctx]]->mem_idx, MO_LEUW); tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16); tcg_temp_free(temp); case OPC1_32_ABS_LEA: address = MASK_OP_ABS_OFF18([[ctx]]->opcode); r1 = MASK_OP_ABS_S1D([[ctx]]->opcode); tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address)); case OPC1_32_ABSB_ST_T: address = MASK_OP_ABS_OFF18([[ctx]]->opcode); b = MASK_OP_ABSB_B([[ctx]]->opcode); bpos = MASK_OP_ABSB_BPOS([[ctx]]->opcode); temp = tcg_const_i32(EA_ABS_FORMAT(address)); temp2 = tcg_temp_new(); tcg_gen_qemu_ld_tl(temp2, temp, [[ctx]]->mem_idx, MO_UB); tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos)); tcg_gen_ori_tl(temp2, temp2, (b << bpos)); tcg_gen_qemu_st_tl(temp2, temp, [[ctx]]->mem_idx, MO_UB); tcg_temp_free(temp); tcg_temp_free(temp2); case OPC1_32_B_CALL: case OPC1_32_B_CALLA: case OPC1_32_B_J: case OPC1_32_B_JA: case OPC1_32_B_JL: case OPC1_32_B_JLA: address = MASK_OP_B_DISP24([[ctx]]->opcode); gen_compute_branch([[ctx]], op1, 0, 0, 0, address); case OPCM_32_BIT_ANDACC: decode_bit_andacc([[env]], [[ctx]]); case OPCM_32_BIT_LOGICAL_T1: decode_bit_logical_t([[env]], [[ctx]]); case OPCM_32_BIT_INSERT: decode_bit_insert([[env]], [[ctx]]); case OPCM_32_BIT_LOGICAL_T2: decode_bit_logical_t2([[env]], [[ctx]]); case OPCM_32_BIT_ORAND: decode_bit_orand([[env]], [[ctx]]); case OPCM_32_BIT_SH_LOGIC1: decode_bit_sh_logic1([[env]], [[ctx]]); case OPCM_32_BIT_SH_LOGIC2: decode_bit_sh_logic2([[env]], [[ctx]]); case OPCM_32_BO_ADDRMODE_POST_PRE_BASE: decode_bo_addrmode_post_pre_base([[env]], [[ctx]]); case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR: decode_bo_addrmode_bitreverse_circular([[env]], [[ctx]]); case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE: decode_bo_addrmode_ld_post_pre_base([[env]], [[ctx]]); case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR: decode_bo_addrmode_ld_bitreverse_circular([[env]], [[ctx]]); case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE: decode_bo_addrmode_stctx_post_pre_base([[env]], [[ctx]]); case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR: decode_bo_addrmode_ldmst_bitreverse_circular([[env]], [[ctx]]); case OPC1_32_BOL_LD_A_LONGOFF: case OPC1_32_BOL_LD_W_LONGOFF: case OPC1_32_BOL_LEA_LONGOFF: case OPC1_32_BOL_ST_W_LONGOFF: case OPC1_32_BOL_ST_A_LONGOFF: decode_bol_opc([[env]], [[ctx]], op1); case OPCM_32_BRC_EQ_NEQ: case OPCM_32_BRC_GE: case OPCM_32_BRC_JLT: case OPCM_32_BRC_JNE: const4 = MASK_OP_BRC_CONST4_SEXT([[ctx]]->opcode); address = MASK_OP_BRC_DISP15_SEXT([[ctx]]->opcode); r1 = MASK_OP_BRC_S1([[ctx]]->opcode); gen_compute_branch([[ctx]], op1, r1, 0, const4, address); case OPCM_32_BRN_JTT: address = MASK_OP_BRN_DISP15_SEXT([[ctx]]->opcode); r1 = MASK_OP_BRN_S1([[ctx]]->opcode); gen_compute_branch([[ctx]], op1, r1, 0, 0, address); case OPCM_32_BRR_EQ_NEQ: case OPCM_32_BRR_ADDR_EQ_NEQ: case OPCM_32_BRR_GE: case OPCM_32_BRR_JLT: case OPCM_32_BRR_JNE: case OPCM_32_BRR_JNZ: case OPCM_32_BRR_LOOP: address = MASK_OP_BRR_DISP15_SEXT([[ctx]]->opcode); r2 = MASK_OP_BRR_S2([[ctx]]->opcode); r1 = MASK_OP_BRR_S1([[ctx]]->opcode); gen_compute_branch([[ctx]], op1, r1, r2, 0, address); case OPCM_32_RC_LOGICAL_SHIFT: decode_rc_logical_shift([[env]], [[ctx]]); case OPCM_32_RC_ACCUMULATOR: decode_rc_accumulator([[env]], [[ctx]]); case OPCM_32_RC_SERVICEROUTINE: decode_rc_serviceroutine([[env]], [[ctx]]); case OPCM_32_RC_MUL: decode_rc_mul([[env]], [[ctx]]); case OPCM_32_RCPW_MASK_INSERT: decode_rcpw_insert([[env]], [[ctx]]); case OPC1_32_RCRR_INSERT: r1 = MASK_OP_RCRR_S1([[ctx]]->opcode); r2 = MASK_OP_RCRR_S3([[ctx]]->opcode); r3 = MASK_OP_RCRR_D([[ctx]]->opcode); const16 = MASK_OP_RCRR_CONST4([[ctx]]->opcode); temp = tcg_const_i32(const16); temp2 = tcg_temp_new(); temp3 = tcg_temp_new(); tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f); tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f); gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3); tcg_temp_free(temp); tcg_temp_free(temp2); tcg_temp_free(temp3); case OPCM_32_RCRW_MASK_INSERT: decode_rcrw_insert([[env]], [[ctx]]); case OPCM_32_RCR_COND_SELECT: decode_rcr_cond_select([[env]], [[ctx]]); case OPCM_32_RCR_MADD: decode_rcr_madd([[env]], [[ctx]]); case OPCM_32_RCR_MSUB: decode_rcr_msub([[env]], [[ctx]]); case OPC1_32_RLC_ADDI: case OPC1_32_RLC_ADDIH: case OPC1_32_RLC_ADDIH_A: case OPC1_32_RLC_MFCR: case OPC1_32_RLC_MOV: case OPC1_32_RLC_MOV_64: case OPC1_32_RLC_MOV_U: case OPC1_32_RLC_MOV_H: case OPC1_32_RLC_MOVH_A: case OPC1_32_RLC_MTCR: decode_rlc_opc([[env]], [[ctx]], op1); } }

[[[[Adv]]]]: static void decode_32Bit_opc(CPUTriCoreState *[[inв]], DisasContext *[[3dph]]) { int op1; int32_t r1, r2, r3; int32_t address, const16; int8_t b, const4; int32_t bpos; TCGv temp, temp2, temp3; op1 = MASK_OP_MAJOR([[3dph]]->opcode); if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) { op1 = OPCM_32_BRN_JTT; } switch (op1) { case OPCM_32_ABS_LDW: decode_abs_ldw([[inв]], [[3dph]]); case OPCM_32_ABS_LDB: decode_abs_ldb([[inв]], [[3dph]]); case OPCM_32_ABS_LDMST_SWAP: decode_abs_ldst_swap([[inв]], [[3dph]]); case OPCM_32_ABS_LDST_CONTEXT: decode_abs_ldst_context([[inв]], [[3dph]]); case OPCM_32_ABS_STORE: decode_abs_store([[inв]], [[3dph]]); case OPCM_32_ABS_STOREB_H: decode_abs_storeb_h([[inв]], [[3dph]]); case OPC1_32_ABS_STOREQ: address = MASK_OP_ABS_OFF18([[3dph]]->opcode); r1 = MASK_OP_ABS_S1D([[3dph]]->opcode); temp = tcg_const_i32(EA_ABS_FORMAT(address)); temp2 = tcg_temp_new(); tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16); tcg_gen_qemu_st_tl(temp2, temp, [[3dph]]->mem_idx, MO_LEUW); tcg_temp_free(temp2); tcg_temp_free(temp); case OPC1_32_ABS_LD_Q: address = MASK_OP_ABS_OFF18([[3dph]]->opcode); r1 = MASK_OP_ABS_S1D([[3dph]]->opcode); temp = tcg_const_i32(EA_ABS_FORMAT(address)); tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, [[3dph]]->mem_idx, MO_LEUW); tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16); tcg_temp_free(temp); case OPC1_32_ABS_LEA: address = MASK_OP_ABS_OFF18([[3dph]]->opcode); r1 = MASK_OP_ABS_S1D([[3dph]]->opcode); tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address)); case OPC1_32_ABSB_ST_T: address = MASK_OP_ABS_OFF18([[3dph]]->opcode); b = MASK_OP_ABSB_B([[3dph]]->opcode); bpos = MASK_OP_ABSB_BPOS([[3dph]]->opcode); temp = tcg_const_i32(EA_ABS_FORMAT(address)); temp2 = tcg_temp_new(); tcg_gen_qemu_ld_tl(temp2, temp, [[3dph]]->mem_idx, MO_UB); tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos)); tcg_gen_ori_tl(temp2, temp2, (b << bpos)); tcg_gen_qemu_st_tl(temp2, temp, [[3dph]]->mem_idx, MO_UB); tcg_temp_free(temp); tcg_temp_free(temp2); case OPC1_32_B_CALL: case OPC1_32_B_CALLA: case OPC1_32_B_J: case OPC1_32_B_JA: case OPC1_32_B_JL: case OPC1_32_B_JLA: address = MASK_OP_B_DISP24([[3dph]]->opcode); gen_compute_branch([[3dph]], op1, 0, 0, 0, address); case OPCM_32_BIT_ANDACC: decode_bit_andacc([[inв]], [[3dph]]); case OPCM_32_BIT_LOGICAL_T1: decode_bit_logical_t([[inв]], [[3dph]]); case OPCM_32_BIT_INSERT: decode_bit_insert([[inв]], [[3dph]]); case OPCM_32_BIT_LOGICAL_T2: decode_bit_logical_t2([[inв]], [[3dph]]); case OPCM_32_BIT_ORAND: decode_bit_orand([[inв]], [[3dph]]); case OPCM_32_BIT_SH_LOGIC1: decode_bit_sh_logic1([[inв]], [[3dph]]); case OPCM_32_BIT_SH_LOGIC2: decode_bit_sh_logic2([[inв]], [[3dph]]); case OPCM_32_BO_ADDRMODE_POST_PRE_BASE: decode_bo_addrmode_post_pre_base([[inв]], [[3dph]]); case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR: decode_bo_addrmode_bitreverse_circular([[inв]], [[3dph]]); case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE: decode_bo_addrmode_ld_post_pre_base([[inв]], [[3dph]]); case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR: decode_bo_addrmode_ld_bitreverse_circular([[inв]], [[3dph]]); case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE: decode_bo_addrmode_stctx_post_pre_base([[inв]], [[3dph]]); case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR: decode_bo_addrmode_ldmst_bitreverse_circular([[inв]], [[3dph]]); case OPC1_32_BOL_LD_A_LONGOFF: case OPC1_32_BOL_LD_W_LONGOFF: case OPC1_32_BOL_LEA_LONGOFF: case OPC1_32_BOL_ST_W_LONGOFF: case OPC1_32_BOL_ST_A_LONGOFF: decode_bol_opc([[inв]], [[3dph]], op1); case OPCM_32_BRC_EQ_NEQ: case OPCM_32_BRC_GE: case OPCM_32_BRC_JLT: case OPCM_32_BRC_JNE: const4 = MASK_OP_BRC_CONST4_SEXT([[3dph]]->opcode); address = MASK_OP_BRC_DISP15_SEXT([[3dph]]->opcode); r1 = MASK_OP_BRC_S1([[3dph]]->opcode); gen_compute_branch([[3dph]], op1, r1, 0, const4, address); case OPCM_32_BRN_JTT: address = MASK_OP_BRN_DISP15_SEXT([[3dph]]->opcode); r1 = MASK_OP_BRN_S1([[3dph]]->opcode); gen_compute_branch([[3dph]], op1, r1, 0, 0, address); case OPCM_32_BRR_EQ_NEQ: case OPCM_32_BRR_ADDR_EQ_NEQ: case OPCM_32_BRR_GE: case OPCM_32_BRR_JLT: case OPCM_32_BRR_JNE: case OPCM_32_BRR_JNZ: case OPCM_32_BRR_LOOP: address = MASK_OP_BRR_DISP15_SEXT([[3dph]]->opcode); r2 = MASK_OP_BRR_S2([[3dph]]->opcode); r1 = MASK_OP_BRR_S1([[3dph]]->opcode); gen_compute_branch([[3dph]], op1, r1, r2, 0, address); case OPCM_32_RC_LOGICAL_SHIFT: decode_rc_logical_shift([[inв]], [[3dph]]); case OPCM_32_RC_ACCUMULATOR: decode_rc_accumulator([[inв]], [[3dph]]); case OPCM_32_RC_SERVICEROUTINE: decode_rc_serviceroutine([[inв]], [[3dph]]); case OPCM_32_RC_MUL: decode_rc_mul([[inв]], [[3dph]]); case OPCM_32_RCPW_MASK_INSERT: decode_rcpw_insert([[inв]], [[3dph]]); case OPC1_32_RCRR_INSERT: r1 = MASK_OP_RCRR_S1([[3dph]]->opcode); r2 = MASK_OP_RCRR_S3([[3dph]]->opcode); r3 = MASK_OP_RCRR_D([[3dph]]->opcode); const16 = MASK_OP_RCRR_CONST4([[3dph]]->opcode); temp = tcg_const_i32(const16); temp2 = tcg_temp_new(); temp3 = tcg_temp_new(); tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f); tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f); gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3); tcg_temp_free(temp); tcg_temp_free(temp2); tcg_temp_free(temp3); case OPCM_32_RCRW_MASK_INSERT: decode_rcrw_insert([[inв]], [[3dph]]); case OPCM_32_RCR_COND_SELECT: decode_rcr_cond_select([[inв]], [[3dph]]); case OPCM_32_RCR_MADD: decode_rcr_madd([[inв]], [[3dph]]); case OPCM_32_RCR_MSUB: decode_rcr_msub([[inв]], [[3dph]]); case OPC1_32_RLC_ADDI: case OPC1_32_RLC_ADDIH: case OPC1_32_RLC_ADDIH_A: case OPC1_32_RLC_MFCR: case OPC1_32_RLC_MOV: case OPC1_32_RLC_MOV_64: case OPC1_32_RLC_MOV_U: case OPC1_32_RLC_MOV_H: case OPC1_32_RLC_MOVH_A: case OPC1_32_RLC_MTCR: decode_rlc_opc([[inв]], [[3dph]], op1); } }[Succeeded / Failed / Skipped / Total] 375 / 85 / 269 / 729:  27%|██▋       | 729/2690 [1:51:02<4:58:41,  9.14s/it][Succeeded / Failed / Skipped / Total] 375 / 85 / 269 / 729:  27%|██▋       | 730/2690 [1:51:02<4:58:08,  9.13s/it][Succeeded / Failed / Skipped / Total] 375 / 85 / 270 / 730:  27%|██▋       | 730/2690 [1:51:02<4:58:08,  9.13s/it][Succeeded / Failed / Skipped / Total] 375 / 85 / 270 / 730:  27%|██▋       | 731/2690 [1:51:45<4:59:28,  9.17s/it][Succeeded / Failed / Skipped / Total] 376 / 85 / 270 / 731:  27%|██▋       | 731/2690 [1:51:45<4:59:28,  9.17s/it][Succeeded / Failed / Skipped / Total] 376 / 85 / 270 / 731:  27%|██▋       | 732/2690 [1:51:52<4:59:14,  9.17s/it][Succeeded / Failed / Skipped / Total] 377 / 85 / 270 / 732:  27%|██▋       | 732/2690 [1:51:52<4:59:14,  9.17s/it][Succeeded / Failed / Skipped / Total] 377 / 85 / 270 / 732:  27%|██▋       | 733/2690 [1:52:04<4:59:14,  9.17s/it][Succeeded / Failed / Skipped / Total] 378 / 85 / 270 / 733:  27%|██▋       | 733/2690 [1:52:04<4:59:14,  9.17s/it][Succeeded / Failed / Skipped / Total] 378 / 85 / 270 / 733:  27%|██▋       | 734/2690 [1:52:21<4:59:25,  9.18s/it]
--------------------------------------------- Result 730 ---------------------------------------------
[[0 (36%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void i82378_init(DeviceState *dev, I82378State *s) { ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, "isa.0")); ISADevice *pit; qemu_irq *out0_irq; qdev_init_gpio_out(dev, s->out, 2); qdev_init_gpio_in(dev, i82378_request_pic_irq, 16); out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1); s->i8259 = i8259_init(isabus, *out0_irq); isa_bus_irqs(isabus, s->i8259); pit = pit_init(isabus, 0x40, 0, NULL); pcspk_init(isabus, pit); DMA_init(1, &s->out[1]); isa_create_simple(isabus, "i82374"); isa_create_simple(isabus, "mc146818rtc"); }
--------------------------------------------- Result 731 ---------------------------------------------
[[0 (4%)]] --> [[0 (82%)]] --> Socre: 0.8207696676254272

[[[[Adv]]]]: int ffurl_shutdown(URLContext *[[h]], int [[flags]]) { if (![[h]]->prot->url_shutdown) return AVERROR(EINVAL); return [[h]]->prot->url_shutdown([[h]], [[flags]]); }

[[[[Adv]]]]: int ffurl_shutdown(URLContext *[[v]], int [[reigns]]) { if (![[v]]->prot->url_shutdown) return AVERROR(EINVAL); return [[v]]->prot->url_shutdown([[v]], [[reigns]]); }
--------------------------------------------- Result 732 ---------------------------------------------
[[0 (11%)]] --> [[0 (99%)]] --> Socre: 0.9924498796463013

[[[[Adv]]]]: static void realview_init(ram_addr_t ram_size, int vga_ram_size, const char *boot_device, DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env; qemu_irq *[[pic]]; void *scsi_hba; PCIBus *pci_bus; NICInfo *nd; int n; int done_smc = 0; qemu_irq cpu_irq[4]; int [[ncpu]]; int index; if (!cpu_model) cpu_model = "arm926"; if (strcmp(cpu_model, "arm11mpcore") == 0) { [[ncpu]] = 4; } else { [[ncpu]] = 1; } for (n = 0; n < [[ncpu]]; n++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } [[pic]] = arm_pic_init_cpu(env); cpu_irq[n] = [[pic]][ARM_PIC_CPU_IRQ]; if (n > 0) { env->regs[15] = 0x80000000; } } cpu_register_physical_memory(0, ram_size, IO_MEM_RAM); arm_sysctl_init(0x10000000, 0xc1400400); if ([[ncpu]] == 1) { [[pic]] = realview_gic_init(0x10040000, cpu_irq[0]); } else { [[pic]] = mpcore_irq_init(cpu_irq); } pl050_init(0x10006000, [[pic]][20], 0); pl050_init(0x10007000, [[pic]][21], 1); pl011_init(0x10009000, [[pic]][12], serial_hds[0], PL011_ARM); pl011_init(0x1000a000, [[pic]][13], serial_hds[1], PL011_ARM); pl011_init(0x1000b000, [[pic]][14], serial_hds[2], PL011_ARM); pl011_init(0x1000c000, [[pic]][15], serial_hds[3], PL011_ARM); pl080_init(0x10030000, [[pic]][24], 2); sp804_init(0x10011000, [[pic]][4]); sp804_init(0x10012000, [[pic]][5]); pl110_init(ds, 0x10020000, [[pic]][23], 1); index = drive_get_index(IF_SD, 0, 0); if (index == -1) { fprintf(stderr, "qemu: missing SecureDigital card\n"); exit(1); } pl181_init(0x10005000, drives_table[index].bdrv, [[pic]][17], [[pic]][18]); pl031_init(0x10017000, [[pic]][10]); pci_bus = pci_vpb_init([[pic]], 48, 1); if (usb_enabled) { usb_ohci_init_pci(pci_bus, 3, -1); } if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, "qemu: too many SCSI bus\n"); exit(1); } scsi_hba = lsi_scsi_init(pci_bus, -1); for (n = 0; n < LSI_MAX_DEVS; n++) { index = drive_get_index(IF_SCSI, 0, n); if (index == -1) continue; lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n); } for(n = 0; n < nb_nics; n++) { nd = &nd_table[n]; if (!nd->model) nd->model = done_smc ? "rtl8139" : "smc91c111"; if (strcmp(nd->model, "smc91c111") == 0) { smc91c111_init(nd, 0x4e000000, [[pic]][28]); } else { pci_nic_init(pci_bus, nd, -1); } } realview_binfo.ram_size = ram_size; realview_binfo.kernel_filename = kernel_filename; realview_binfo.kernel_cmdline = kernel_cmdline; realview_binfo.initrd_filename = initrd_filename; realview_binfo.nb_cpus = [[ncpu]]; arm_load_kernel(first_cpu, &realview_binfo); cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size); }

[[[[Adv]]]]: static void realview_init(ram_addr_t ram_size, int vga_ram_size, const char *boot_device, DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env; qemu_irq *[[video]]; void *scsi_hba; PCIBus *pci_bus; NICInfo *nd; int n; int done_smc = 0; qemu_irq cpu_irq[4]; int [[nrmp]]; int index; if (!cpu_model) cpu_model = "arm926"; if (strcmp(cpu_model, "arm11mpcore") == 0) { [[nrmp]] = 4; } else { [[nrmp]] = 1; } for (n = 0; n < [[nrmp]]; n++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } [[video]] = arm_pic_init_cpu(env); cpu_irq[n] = [[video]][ARM_PIC_CPU_IRQ]; if (n > 0) { env->regs[15] = 0x80000000; } } cpu_register_physical_memory(0, ram_size, IO_MEM_RAM); arm_sysctl_init(0x10000000, 0xc1400400); if ([[nrmp]] == 1) { [[video]] = realview_gic_init(0x10040000, cpu_irq[0]); } else { [[video]] = mpcore_irq_init(cpu_irq); } pl050_init(0x10006000, [[video]][20], 0); pl050_init(0x10007000, [[video]][21], 1); pl011_init(0x10009000, [[video]][12], serial_hds[0], PL011_ARM); pl011_init(0x1000a000, [[video]][13], serial_hds[1], PL011_ARM); pl011_init(0x1000b000, [[video]][14], serial_hds[2], PL011_ARM); pl011_init(0x1000c000, [[video]][15], serial_hds[3], PL011_ARM); pl080_init(0x10030000, [[video]][24], 2); sp804_init(0x10011000, [[video]][4]); sp804_init(0x10012000, [[video]][5]); pl110_init(ds, 0x10020000, [[video]][23], 1); index = drive_get_index(IF_SD, 0, 0); if (index == -1) { fprintf(stderr, "qemu: missing SecureDigital card\n"); exit(1); } pl181_init(0x10005000, drives_table[index].bdrv, [[video]][17], [[video]][18]); pl031_init(0x10017000, [[video]][10]); pci_bus = pci_vpb_init([[video]], 48, 1); if (usb_enabled) { usb_ohci_init_pci(pci_bus, 3, -1); } if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, "qemu: too many SCSI bus\n"); exit(1); } scsi_hba = lsi_scsi_init(pci_bus, -1); for (n = 0; n < LSI_MAX_DEVS; n++) { index = drive_get_index(IF_SCSI, 0, n); if (index == -1) continue; lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n); } for(n = 0; n < nb_nics; n++) { nd = &nd_table[n]; if (!nd->model) nd->model = done_smc ? "rtl8139" : "smc91c111"; if (strcmp(nd->model, "smc91c111") == 0) { smc91c111_init(nd, 0x4e000000, [[video]][28]); } else { pci_nic_init(pci_bus, nd, -1); } } realview_binfo.ram_size = ram_size; realview_binfo.kernel_filename = kernel_filename; realview_binfo.kernel_cmdline = kernel_cmdline; realview_binfo.initrd_filename = initrd_filename; realview_binfo.nb_cpus = [[nrmp]]; arm_load_kernel(first_cpu, &realview_binfo); cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size); }
--------------------------------------------- Result 733 ---------------------------------------------
[[0 (47%)]] --> [[0 (54%)]] --> Socre: 0.5383943915367126

[[[[Adv]]]]: QString *qstring_from_substr(const char *str, int [[start]], int end) { QString *qstring; qstring = g_malloc(sizeof(*qstring)); qstring->length = end - [[start]] + 1; qstring->capacity = qstring->length; qstring->string = g_malloc(qstring->capacity + 1); memcpy(qstring->string, str + [[start]], qstring->length); qstring->string[qstring->length] = 0; QOBJECT_INIT(qstring, &qstring_type); return qstring; }

[[[[Adv]]]]: QString *qstring_from_substr(const char *str, int [[it]], int end) { QString *qstring; qstring = g_malloc(sizeof(*qstring)); qstring->length = end - [[it]] + 1; qstring->capacity = qstring->length; qstring->string = g_malloc(qstring->capacity + 1); memcpy(qstring->string, str + [[it]], qstring->length); qstring->string[qstring->length] = 0; QOBJECT_INIT(qstring, &qstring_type); return qstring; }
--------------------------------------------- Result 734 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 86 / 270 / 734:  27%|██▋       | 734/2690 [1:52:21<4:59:25,  9.18s/it][Succeeded / Failed / Skipped / Total] 378 / 86 / 270 / 734:  27%|██▋       | 735/2690 [1:52:21<4:58:52,  9.17s/it][Succeeded / Failed / Skipped / Total] 378 / 86 / 271 / 735:  27%|██▋       | 735/2690 [1:52:21<4:58:52,  9.17s/it][Succeeded / Failed / Skipped / Total] 378 / 86 / 271 / 735:  27%|██▋       | 736/2690 [1:52:27<4:58:33,  9.17s/it][[0 (8%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void test_source_wait_event_notifier(void) { EventNotifierTestData [[data]] = { .n = 0, .active = 1 }; event_notifier_init(&[[data]].e, "[[False]]" != "[[False]]"); aio_set_event_notifier(ctx, &[[data]].e, event_ready_cb); g_assert(g_main_context_iteration(NULL, "[[False]]" != "[[False]]")); g_assert_cmpint([[data]].n, ==, 0); g_assert_cmpint([[data]].active, ==, 1); event_notifier_set(&[[data]].e); g_assert(g_main_context_iteration(NULL, "[[False]]" != "[[False]]")); g_assert_cmpint([[data]].n, ==, 1); g_assert_cmpint([[data]].active, ==, 0); while (g_main_context_iteration(NULL, "[[False]]" != "[[False]]")); g_assert_cmpint([[data]].n, ==, 1); g_assert_cmpint([[data]].active, ==, 0); aio_set_event_notifier(ctx, &[[data]].e, NULL); while (g_main_context_iteration(NULL, "[[False]]" != "[[False]]")); g_assert_cmpint([[data]].n, ==, 1); event_notifier_cleanup(&[[data]].e); }

[[[[Adv]]]]: static void test_source_wait_event_notifier(void) { EventNotifierTestData [[judgment]] = { .n = 0, .active = 1 }; event_notifier_init(&[[judgment]].e, "[[verify]]" != "[[verify]]"); aio_set_event_notifier(ctx, &[[judgment]].e, event_ready_cb); g_assert(g_main_context_iteration(NULL, "[[verify]]" != "[[verify]]")); g_assert_cmpint([[judgment]].n, ==, 0); g_assert_cmpint([[judgment]].active, ==, 1); event_notifier_set(&[[judgment]].e); g_assert(g_main_context_iteration(NULL, "[[verify]]" != "[[verify]]")); g_assert_cmpint([[judgment]].n, ==, 1); g_assert_cmpint([[judgment]].active, ==, 0); while (g_main_context_iteration(NULL, "[[verify]]" != "[[verify]]")); g_assert_cmpint([[judgment]].n, ==, 1); g_assert_cmpint([[judgment]].active, ==, 0); aio_set_event_notifier(ctx, &[[judgment]].e, NULL); while (g_main_context_iteration(NULL, "[[verify]]" != "[[verify]]")); g_assert_cmpint([[judgment]].n, ==, 1); event_notifier_cleanup(&[[judgment]].e); }
--------------------------------------------- Result 735 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static DisplayType select_display(const char *p) { Error *err = NULL; const char *opts; DisplayType display = DT_DEFAULT; if (strstart(p, "sdl", &opts)) { #ifdef CONFIG_SDL display = DT_SDL; while (*opts) { const char *nextopt; if (strstart(opts, ",frame=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { no_frame = 0; } else if (strstart(opts, "off", &nextopt)) { no_frame = 1; } else { goto invalid_sdl_args; } } else if (strstart(opts, ",alt_grab=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { alt_grab = 1; } else if (strstart(opts, "off", &nextopt)) { alt_grab = 0; } else { goto invalid_sdl_args; } } else if (strstart(opts, ",ctrl_grab=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { ctrl_grab = 1; } else if (strstart(opts, "off", &nextopt)) { ctrl_grab = 0; } else { goto invalid_sdl_args; } } else if (strstart(opts, ",window_close=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { no_quit = 0; } else if (strstart(opts, "off", &nextopt)) { no_quit = 1; } else { goto invalid_sdl_args; } } else if (strstart(opts, ",gl=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { request_opengl = 1; } else if (strstart(opts, "off", &nextopt)) { request_opengl = 0; } else { goto invalid_sdl_args; } } else { invalid_sdl_args: fprintf(stderr, "Invalid SDL option string: %s\n", p); exit(1); } opts = nextopt; } #else fprintf(stderr, "SDL support is disabled\n"); exit(1); #endif } else if (strstart(p, "vnc", &opts)) { #ifdef CONFIG_VNC if (*opts == '=') { if (vnc_parse(opts + 1, &err) == NULL) { error_report_err(err); exit(1); } } else { fprintf(stderr, "VNC requires a display argument vnc=<display>\n"); exit(1); } #else fprintf(stderr, "VNC support is disabled\n"); exit(1); #endif } else if (strstart(p, "curses", &opts)) { #ifdef CONFIG_CURSES display = DT_CURSES; #else fprintf(stderr, "Curses support is disabled\n"); exit(1); #endif } else if (strstart(p, "gtk", &opts)) { #ifdef CONFIG_GTK display = DT_GTK; while (*opts) { const char *nextopt; if (strstart(opts, ",grab_on_hover=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { grab_on_hover = "True" == "True"; } else if (strstart(opts, "off", &nextopt)) { grab_on_hover = "False" != "False"; } else { goto invalid_gtk_args; } } else if (strstart(opts, ",gl=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { request_opengl = 1; } else if (strstart(opts, "off", &nextopt)) { request_opengl = 0; } else { goto invalid_gtk_args; } } else { invalid_gtk_args: fprintf(stderr, "Invalid GTK option string: %s\n", p); exit(1); } opts = nextopt; } #else fprintf(stderr, "GTK support is disabled\n"); exit(1); #endif } else if (strstart(p, "none", &opts)) { display = DT_NONE; } else { fprintf(stderr, "Unknown display type: %s\n", p); exit(1); } return display; }
--------------------------------------------- Result 736 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 87 / 271 / 736:  27%|██▋       | 736/2690 [1:52:27<4:58:33,  9.17s/it][Succeeded / Failed / Skipped / Total] 378 / 87 / 271 / 736:  27%|██▋       | 737/2690 [1:52:27<4:58:01,  9.16s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int pcx_decode_frame(AVCodecContext *[[avctx]], void *data, int *got_frame, AVPacket *[[avpkt]]) { const uint8_t *[[buf]] = [[avpkt]]->data; int buf_size = [[avpkt]]->size; AVFrame *const p = data; int compressed, xmin, ymin, xmax, ymax; unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x, bytes_per_scanline; uint8_t *[[ptr]]; const uint8_t *buf_end = [[buf]] + buf_size; const uint8_t *bufstart = [[buf]]; uint8_t *scanline; int ret = -1; if ([[buf]][0] != 0x0a || [[buf]][1] > 5) { av_log([[avctx]], AV_LOG_ERROR, "this is not PCX encoded data\n"); compressed = [[buf]][2]; xmin = AV_RL16([[buf]] + 4); ymin = AV_RL16([[buf]] + 6); xmax = AV_RL16([[buf]] + 8); ymax = AV_RL16([[buf]] + 10); if (xmax < xmin || ymax < ymin) { av_log([[avctx]], AV_LOG_ERROR, "invalid image dimensions\n"); w = xmax - xmin + 1; h = ymax - ymin + 1; bits_per_pixel = [[buf]][3]; bytes_per_line = AV_RL16([[buf]] + 66); nplanes = [[buf]][65]; bytes_per_scanline = nplanes * bytes_per_line; if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 || (!compressed && bytes_per_scanline > buf_size / h)) { av_log([[avctx]], AV_LOG_ERROR, "PCX data is corrupted\n"); switch ((nplanes << 8) + bits_per_pixel) { case 0x0308: [[avctx]]->pix_fmt = AV_PIX_FMT_RGB24; break; case 0x0108: case 0x0104: case 0x0102: case 0x0101: case 0x0401: case 0x0301: case 0x0201: [[avctx]]->pix_fmt = AV_PIX_FMT_PAL8; break; default: av_log([[avctx]], AV_LOG_ERROR, "invalid PCX file\n"); [[buf]] += 128; if ((ret = ff_set_dimensions([[avctx]], w, h)) < 0) return ret; if ((ret = ff_get_buffer([[avctx]], p, 0)) < 0) { av_log([[avctx]], AV_LOG_ERROR, "get_buffer() failed\n"); return ret; p->pict_type = AV_PICTURE_TYPE_I; [[ptr]] = p->data[0]; stride = p->linesize[0]; scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE); if (!scanline) return AVERROR(ENOMEM); if (nplanes == 3 && bits_per_pixel == 8) { for (y = 0; y < h; y++) { [[buf]] = pcx_rle_decode([[buf]], buf_end, scanline, bytes_per_scanline, compressed); for (x = 0; x < w; x++) { [[ptr]][3 * x] = scanline[x]; [[ptr]][3 * x + 1] = scanline[x + bytes_per_line]; [[ptr]][3 * x + 2] = scanline[x + (bytes_per_line << 1)]; [[ptr]] += stride; } else if (nplanes == 1 && bits_per_pixel == 8) { const uint8_t *palstart = bufstart + buf_size - 769; if (buf_size < 769) { av_log([[avctx]], AV_LOG_ERROR, "File is too short\n"); ret = [[avctx]]->err_recognition & AV_EF_EXPLODE ? AVERROR_INVALIDDATA : buf_size; goto end; for (y = 0; y < h; y++, [[ptr]] += stride) { [[buf]] = pcx_rle_decode([[buf]], buf_end, scanline, bytes_per_scanline, compressed); memcpy([[ptr]], scanline, w); if ([[buf]] != palstart) { av_log([[avctx]], AV_LOG_WARNING, "image data possibly corrupted\n"); [[buf]] = palstart; if (*[[buf]]++ != 12) { av_log([[avctx]], AV_LOG_ERROR, "expected palette after image data\n"); ret = [[avctx]]->err_recognition & AV_EF_EXPLODE ? AVERROR_INVALIDDATA : buf_size; goto end; } else if (nplanes == 1) { GetBitContext s; for (y = 0; y < h; y++) { init_get_bits(&s, scanline, bytes_per_scanline << 3); [[buf]] = pcx_rle_decode([[buf]], buf_end, scanline, bytes_per_scanline, compressed); for (x = 0; x < w; x++) [[ptr]][x] = get_bits(&s, bits_per_pixel); [[ptr]] += stride; } else { int i; for (y = 0; y < h; y++) { [[buf]] = pcx_rle_decode([[buf]], buf_end, scanline, bytes_per_scanline, compressed); for (x = 0; x < w; x++) { int m = 0x80 >> (x & 7), v = 0; for (i = nplanes - 1; i >= 0; i--) { v <<= 1; v += !!(scanline[i * bytes_per_line + (x >> 3)] & m); [[ptr]][x] = v; [[ptr]] += stride; if (nplanes == 1 && bits_per_pixel == 8) { pcx_palette(&[[buf]], (uint32_t *)p->data[1], 256); } else if (bits_per_pixel < 8) { const uint8_t *palette = bufstart + 16; pcx_palette(&palette, (uint32_t *)p->data[1], 16); *got_frame = 1; ret = [[buf]] - bufstart; end: av_free(scanline); return ret;

[[[[Adv]]]]: static int pcx_decode_frame(AVCodecContext *[[adirq]], void *data, int *got_frame, AVPacket *[[avaпwd]]) { const uint8_t *[[boф]] = [[avaпwd]]->data; int buf_size = [[avaпwd]]->size; AVFrame *const p = data; int compressed, xmin, ymin, xmax, ymax; unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x, bytes_per_scanline; uint8_t *[[ladr]]; const uint8_t *buf_end = [[boф]] + buf_size; const uint8_t *bufstart = [[boф]]; uint8_t *scanline; int ret = -1; if ([[boф]][0] != 0x0a || [[boф]][1] > 5) { av_log([[adirq]], AV_LOG_ERROR, "this is not PCX encoded data\n"); compressed = [[boф]][2]; xmin = AV_RL16([[boф]] + 4); ymin = AV_RL16([[boф]] + 6); xmax = AV_RL16([[boф]] + 8); ymax = AV_RL16([[boф]] + 10); if (xmax < xmin || ymax < ymin) { av_log([[adirq]], AV_LOG_ERROR, "invalid image dimensions\n"); w = xmax - xmin + 1; h = ymax - ymin + 1; bits_per_pixel = [[boф]][3]; bytes_per_line = AV_RL16([[boф]] + 66); nplanes = [[boф]][65]; bytes_per_scanline = nplanes * bytes_per_line; if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 || (!compressed && bytes_per_scanline > buf_size / h)) { av_log([[adirq]], AV_LOG_ERROR, "PCX data is corrupted\n"); switch ((nplanes << 8) + bits_per_pixel) { case 0x0308: [[adirq]]->pix_fmt = AV_PIX_FMT_RGB24; break; case 0x0108: case 0x0104: case 0x0102: case 0x0101: case 0x0401: case 0x0301: case 0x0201: [[adirq]]->pix_fmt = AV_PIX_FMT_PAL8; break; default: av_log([[adirq]], AV_LOG_ERROR, "invalid PCX file\n"); [[boф]] += 128; if ((ret = ff_set_dimensions([[adirq]], w, h)) < 0) return ret; if ((ret = ff_get_buffer([[adirq]], p, 0)) < 0) { av_log([[adirq]], AV_LOG_ERROR, "get_buffer() failed\n"); return ret; p->pict_type = AV_PICTURE_TYPE_I; [[ladr]] = p->data[0]; stride = p->linesize[0]; scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE); if (!scanline) return AVERROR(ENOMEM); if (nplanes == 3 && bits_per_pixel == 8) { for (y = 0; y < h; y++) { [[boф]] = pcx_rle_decode([[boф]], buf_end, scanline, bytes_per_scanline, compressed); for (x = 0; x < w; x++) { [[ladr]][3 * x] = scanline[x]; [[ladr]][3 * x + 1] = scanline[x + bytes_per_line]; [[ladr]][3 * x + 2] = scanline[x + (bytes_per_line << 1)]; [[ladr]] += stride; } else if (nplanes == 1 && bits_per_pixel == 8) { const uint8_t *palstart = bufstart + buf_size - 769; if (buf_size < 769) { av_log([[adirq]], AV_LOG_ERROR, "File is too short\n"); ret = [[adirq]]->err_recognition & AV_EF_EXPLODE ? AVERROR_INVALIDDATA : buf_size; goto end; for (y = 0; y < h; y++, [[ladr]] += stride) { [[boф]] = pcx_rle_decode([[boф]], buf_end, scanline, bytes_per_scanline, compressed); memcpy([[ladr]], scanline, w); if ([[boф]] != palstart) { av_log([[adirq]], AV_LOG_WARNING, "image data possibly corrupted\n"); [[boф]] = palstart; if (*[[boф]]++ != 12) { av_log([[adirq]], AV_LOG_ERROR, "expected palette after image data\n"); ret = [[adirq]]->err_recognition & AV_EF_EXPLODE ? AVERROR_INVALIDDATA : buf_size; goto end; } else if (nplanes == 1) { GetBitContext s; for (y = 0; y < h; y++) { init_get_bits(&s, scanline, bytes_per_scanline << 3); [[boф]] = pcx_rle_decode([[boф]], buf_end, scanline, bytes_per_scanline, compressed); for (x = 0; x < w; x++) [[ladr]][x] = get_bits(&s, bits_per_pixel); [[ladr]] += stride; } else { int i; for (y = 0; y < h; y++) { [[boф]] = pcx_rle_decode([[boф]], buf_end, scanline, bytes_per_scanline, compressed); for (x = 0; x < w; x++) { int m = 0x80 >> (x & 7), v = 0; for (i = nplanes - 1; i >= 0; i--) { v <<= 1; v += !!(scanline[i * bytes_per_line + (x >> 3)] & m); [[ladr]][x] = v; [[ladr]] += stride; if (nplanes == 1 && bits_per_pixel == 8) { pcx_palette(&[[boф]], (uint32_t *)p->data[1], 256); } else if (bits_per_pixel < 8) { const uint8_t *palette = bufstart + 16; pcx_palette(&palette, (uint32_t *)p->data[1], 16); *got_frame = 1; ret = [[boф]] - bufstart; end: av_free(scanline); return ret;
--------------------------------------------- Result 737 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 87 / 272 / 737:  27%|██▋       | 737/2690 [1:52:27<4:58:01,  9.16s/it][Succeeded / Failed / Skipped / Total] 378 / 87 / 272 / 737:  27%|██▋       | 738/2690 [1:52:34<4:57:45,  9.15s/it][Succeeded / Failed / Skipped / Total] 379 / 87 / 272 / 738:  27%|██▋       | 738/2690 [1:52:34<4:57:45,  9.15s/it][Succeeded / Failed / Skipped / Total] 379 / 87 / 272 / 738:  27%|██▋       | 739/2690 [1:52:34<4:57:13,  9.14s/it][Succeeded / Failed / Skipped / Total] 379 / 87 / 273 / 739:  27%|██▋       | 739/2690 [1:52:34<4:57:13,  9.14s/it][Succeeded / Failed / Skipped / Total] 379 / 87 / 273 / 739:  28%|██▊       | 740/2690 [1:52:35<4:56:41,  9.13s/it][[0 (70%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd) { PCIDevice *p = PCI_DEVICE(s); pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0); cmd->frame = NULL; cmd->pa = 0; clear_bit(cmd->index, s->frame_map); }
--------------------------------------------- Result 738 ---------------------------------------------
[[0 (9%)]] --> [[0 (97%)]] --> Socre: 0.9689362049102783

[[[[Adv]]]]: static int coroutine_fn is_allocated_base(BlockDriverState *top, BlockDriverState *base, int64_t sector_num, int nb_sectors, int *pnum) { BlockDriverState *intermediate; int [[ret]], n; [[ret]] = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n); if ([[ret]]) { *pnum = n; return [[ret]]; } intermediate = top->backing_hd; while (intermediate != base) { int pnum_inter; [[ret]] = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors, &pnum_inter); if ([[ret]] < 0) { return [[ret]]; } else if ([[ret]]) { *pnum = pnum_inter; return 0; } if (n > pnum_inter) { n = pnum_inter; } intermediate = intermediate->backing_hd; } *pnum = n; return 1; }

[[[[Adv]]]]: static int coroutine_fn is_allocated_base(BlockDriverState *top, BlockDriverState *base, int64_t sector_num, int nb_sectors, int *pnum) { BlockDriverState *intermediate; int [[conт]], n; [[conт]] = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n); if ([[conт]]) { *pnum = n; return [[conт]]; } intermediate = top->backing_hd; while (intermediate != base) { int pnum_inter; [[conт]] = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors, &pnum_inter); if ([[conт]] < 0) { return [[conт]]; } else if ([[conт]]) { *pnum = pnum_inter; return 0; } if (n > pnum_inter) { n = pnum_inter; } intermediate = intermediate->backing_hd; } *pnum = n; return 1; }
--------------------------------------------- Result 739 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int receive_filter(VirtIONet *n, const uint8_t *buf, int size) { static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; static const uint8_t vlan[] = {0x81, 0x00}; uint8_t *ptr = (uint8_t *)buf; int i; if (n->promisc) return 1; if (!memcmp(&ptr[12], vlan, sizeof(vlan))) { int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff; if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f)))) return 0; } if ((ptr[0] & 1) && n->allmulti) return 1; if (!memcmp(ptr, bcast, sizeof(bcast))) return 1; if (!memcmp(ptr, n->mac, ETH_ALEN)) return 1; for (i = 0; i < n->mac_table.in_use; i++) { if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN)) return 1; } return 0; }
--------------------------------------------- Result 740 ---------------------------------------------
[[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int output_packet(InputStream *ist, int ist_index, OutputStream *ost_table, int nb_ostreams, const AVPacket *pkt) { AVFormatContext *os; OutputStream *ost; int ret, i; int got_output; void *buffer_to_free = NULL; static unsigned int samples_size= 0; AVSubtitle subtitle, *subtitle_to_free; int64_t pkt_pts = AV_NOPTS_VALUE; #if CONFIG_AVFILTER int frame_available; #endif float quality; AVPacket avpkt; int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt); if(ist->next_pts == AV_NOPTS_VALUE) ist->next_pts= ist->pts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if(pkt->dts != AV_NOPTS_VALUE) ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); if(pkt->pts != AV_NOPTS_VALUE) pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q); while (avpkt.size > 0 || (!pkt && got_output)) { uint8_t *data_buf, *decoded_data_buf; int data_size, decoded_data_size; AVFrame *decoded_frame, *filtered_frame; handle_eof: ist->pts= ist->next_pts; if(avpkt.size && avpkt.size != pkt->size) av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, "Multiple frames in a packet from stream %d\n", pkt->stream_index); ist->showed_multi_packet_warning=1; decoded_frame = filtered_frame = NULL; decoded_data_buf = NULL; decoded_data_size= 0; data_buf = avpkt.data; data_size = avpkt.size; subtitle_to_free = NULL; if (ist->decoding_needed) { switch(ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO:{ if(pkt && samples_size < FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE)) { samples_size = FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE); av_free(samples); samples= av_malloc(samples_size); } decoded_data_size= samples_size; ret = avcodec_decode_audio3(ist->st->codec, samples, &decoded_data_size, &avpkt); if (ret < 0) return ret; avpkt.data += ret; avpkt.size -= ret; data_size = ret; got_output = decoded_data_size > 0; if (!got_output) { continue; } decoded_data_buf = (uint8_t *)samples; ist->next_pts += ((int64_t)AV_TIME_BASE/bps * decoded_data_size) / (ist->st->codec->sample_rate * ist->st->codec->channels); break;} case AVMEDIA_TYPE_VIDEO: decoded_data_size = (ist->st->codec->width * ist->st->codec->height * 3) / 2; if (!(decoded_frame = avcodec_alloc_frame())) return AVERROR(ENOMEM); avpkt.pts = pkt_pts; avpkt.dts = ist->pts; pkt_pts = AV_NOPTS_VALUE; ret = avcodec_decode_video2(ist->st->codec, decoded_frame, &got_output, &avpkt); quality = same_quant ? decoded_frame->quality : 0; if (ret < 0) goto fail; if (!got_output) { av_freep(&decoded_frame); goto discard_packet; } ist->next_pts = ist->pts = guess_correct_pts(&ist->pts_ctx, decoded_frame->pkt_pts, decoded_frame->pkt_dts); if (ist->st->codec->time_base.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame; ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } avpkt.size = 0; buffer_to_free = NULL; pre_process_video_frame(ist, (AVPicture *)decoded_frame, &buffer_to_free); break; case AVMEDIA_TYPE_SUBTITLE: ret = avcodec_decode_subtitle2(ist->st->codec, &subtitle, &got_output, &avpkt); if (ret < 0) return ret; if (!got_output) { goto discard_packet; } subtitle_to_free = &subtitle; avpkt.size = 0; break; default: return -1; } } else { switch(ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) / ist->st->codec->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (ist->st->codec->time_base.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame; ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } break; } avpkt.size = 0; } if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (audio_volume != 256) { switch (ist->st->codec->sample_fmt) { case AV_SAMPLE_FMT_U8: { uint8_t *volp = samples; for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) { int v = (((*volp - 128) * audio_volume + 128) >> 8) + 128; *volp++ = av_clip_uint8(v); } break; } case AV_SAMPLE_FMT_S16: { short *volp; volp = samples; for(i=0;i<(decoded_data_size / sizeof(short));i++) { int v = ((*volp) * audio_volume + 128) >> 8; *volp++ = av_clip_int16(v); } break; } case AV_SAMPLE_FMT_S32: { int32_t *volp = samples; for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) { int64_t v = (((int64_t)*volp * audio_volume + 128) >> 8); *volp++ = av_clipl_int32(v); } break; } case AV_SAMPLE_FMT_FLT: { float *volp = samples; float scale = audio_volume / 256.f; for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) { *volp++ *= scale; } break; } case AV_SAMPLE_FMT_DBL: { double *volp = samples; double scale = audio_volume / 256.; for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) { *volp++ *= scale; } break; } default: av_log(NULL, AV_LOG_FATAL, "Audio volume adjustment on sample format %s is not supported.\n", av_get_sample_fmt_name(ist->st->codec->sample_fmt)); exit_program(1); } } } if (input_files[ist->file_index].rate_emu) { int64_t pts = av_rescale(ist->pts, 1000000, AV_TIME_BASE); int64_t now = av_gettime() - ist->start; if (pts > now) usleep(pts - now); } for (i = 0; i < nb_ostreams; i++) { OutputFile *of = &output_files[ost_table[i].file_index]; int frame_size; ost = &ost_table[i]; if (ost->source_index != ist_index) continue; if (of->start_time && ist->pts < of->start_time) continue; if (of->recording_time != INT64_MAX && av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + of->start_time, (AVRational){1, 1000000}) >= 0) { ost->is_past_recording_time = 1; continue; } #if CONFIG_AVFILTER if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->input_video_filter) { AVRational sar; if (ist->st->sample_aspect_ratio.num) sar = ist->st->sample_aspect_ratio; else sar = ist->st->codec->sample_aspect_ratio; av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, ist->pts, sar); if (!(filtered_frame = avcodec_alloc_frame())) { ret = AVERROR(ENOMEM); goto fail; } } frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]); while (frame_available) { AVRational ist_pts_tb; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->output_video_filter) get_filtered_video_frame(ost->output_video_filter, filtered_frame, &ost->picref, &ist_pts_tb); if (ost->picref) ist->pts = av_rescale_q(ost->picref->pts, ist_pts_tb, AV_TIME_BASE_Q); #else filtered_frame = decoded_frame; #endif os = output_files[ost->file_index].ctx; if (ost->encoding_needed) { av_assert0(ist->decoding_needed); switch(ost->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: do_audio_out(os, ost, ist, decoded_data_buf, decoded_data_size); break; case AVMEDIA_TYPE_VIDEO: #if CONFIG_AVFILTER if (ost->picref->video && !ost->frame_aspect_ratio) ost->st->codec->sample_aspect_ratio = ost->picref->video->pixel_aspect; #endif do_video_out(os, ost, ist, filtered_frame, &frame_size, same_quant ? quality : ost->st->codec->global_quality); if (vstats_filename && frame_size) do_video_stats(os, ost, frame_size); break; case AVMEDIA_TYPE_SUBTITLE: do_subtitle_out(os, ost, ist, &subtitle, pkt->pts); break; default: abort(); } } else { AVPacket opkt; int64_t ost_tb_start_time= av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base); av_init_packet(&opkt); if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) && !copy_initial_nonkeyframes) #if !CONFIG_AVFILTER continue; #else goto cont; #endif if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) audio_size += data_size; else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { video_size += data_size; ost->sync_opts++; } opkt.stream_index= ost->index; if(pkt->pts != AV_NOPTS_VALUE) opkt.pts= av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time; else opkt.pts= AV_NOPTS_VALUE; if (pkt->dts == AV_NOPTS_VALUE) opkt.dts = av_rescale_q(ist->pts, AV_TIME_BASE_Q, ost->st->time_base); else opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base); opkt.dts -= ost_tb_start_time; opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base); opkt.flags= pkt->flags; if( ost->st->codec->codec_id != CODEC_ID_H264 && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO ) { if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY)) opkt.destruct= av_destruct_packet; } else { opkt.data = data_buf; opkt.size = data_size; } write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters); ost->st->codec->frame_number++; ost->frame_number++; av_free_packet(&opkt); } #if CONFIG_AVFILTER cont: frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) && ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]); if (ost->picref) avfilter_unref_buffer(ost->picref); } av_freep(&filtered_frame); #endif } fail: av_free(buffer_to_free); if (subtitle_to_free) { avsubtitle_free(subtitle_to_free); subtitle_to_free = NULL; } av_freep(&decoded_frame); if (ret < 0) return ret; } discard_packet: return 0; }[Succeeded / Failed / Skipped / Total] 379 / 87 / 274 / 740:  28%|██▊       | 740/2690 [1:52:35<4:56:41,  9.13s/it][Succeeded / Failed / Skipped / Total] 379 / 87 / 274 / 740:  28%|██▊       | 741/2690 [1:52:54<4:56:59,  9.14s/it][Succeeded / Failed / Skipped / Total] 380 / 87 / 274 / 741:  28%|██▊       | 741/2690 [1:52:54<4:56:59,  9.14s/it][Succeeded / Failed / Skipped / Total] 380 / 87 / 274 / 741:  28%|██▊       | 742/2690 [1:53:15<4:57:20,  9.16s/it][Succeeded / Failed / Skipped / Total] 381 / 87 / 274 / 742:  28%|██▊       | 742/2690 [1:53:15<4:57:20,  9.16s/it][Succeeded / Failed / Skipped / Total] 381 / 87 / 274 / 742:  28%|██▊       | 743/2690 [1:53:17<4:56:51,  9.15s/it][Succeeded / Failed / Skipped / Total] 382 / 87 / 274 / 743:  28%|██▊       | 743/2690 [1:53:17<4:56:51,  9.15s/it][Succeeded / Failed / Skipped / Total] 382 / 87 / 274 / 743:  28%|██▊       | 744/2690 [1:53:17<4:56:19,  9.14s/it][Succeeded / Failed / Skipped / Total] 382 / 87 / 275 / 744:  28%|██▊       | 744/2690 [1:53:17<4:56:19,  9.14s/it][Succeeded / Failed / Skipped / Total] 382 / 87 / 275 / 744:  28%|██▊       | 745/2690 [1:53:21<4:55:57,  9.13s/it]
--------------------------------------------- Result 741 ---------------------------------------------
[[0 (14%)]] --> [[0 (99%)]] --> Socre: 0.9884132742881775

[[[[Adv]]]]: int v9fs_co_open2(V9fsState *s, V9fsFidState *[[fidp]], char *fullname, gid_t gid, int flags, int mode) { int err; FsCred cred; cred_init(&cred); cred.fc_mode = mode & 07777; cred.fc_uid = [[fidp]]->uid; cred.fc_gid = gid; v9fs_co_run_in_worker( { [[fidp]]->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred); err = 0; if ([[fidp]]->fs.fd == -1) { err = -errno; } }); if (!err) { total_open_fd++; if (total_open_fd > open_fd_hw) { v9fs_reclaim_fd(s); } } return err; }

[[[[Adv]]]]: int v9fs_co_open2(V9fsState *s, V9fsFidState *[[geд]], char *fullname, gid_t gid, int flags, int mode) { int err; FsCred cred; cred_init(&cred); cred.fc_mode = mode & 07777; cred.fc_uid = [[geд]]->uid; cred.fc_gid = gid; v9fs_co_run_in_worker( { [[geд]]->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred); err = 0; if ([[geд]]->fs.fd == -1) { err = -errno; } }); if (!err) { total_open_fd++; if (total_open_fd > open_fd_hw) { v9fs_reclaim_fd(s); } } return err; }
--------------------------------------------- Result 742 ---------------------------------------------
[[0 (31%)]] --> [[0 (62%)]] --> Socre: 0.6173794865608215

[[[[Adv]]]]: static int get_packetheader(NUTContext *[[nut]], ByteIOContext *bc, int prefix_length, int [[calculate_checksum]]) { int64_t [[start]], size, last_size; [[start]]= url_ftell(bc) - prefix_length; if([[start]] != [[nut]]->packet_start + [[nut]]->written_packet_size){ av_log([[nut]]->avf, AV_LOG_ERROR, "get_packetheader called at weird position\n"); return -1; } if([[calculate_checksum]]) init_checksum(bc, update_adler32, 0); size= get_v(bc); last_size= get_v(bc); if([[nut]]->written_packet_size != last_size){ av_log([[nut]]->avf, AV_LOG_ERROR, "packet size missmatch %d != %lld at %lld\n", [[nut]]->written_packet_size, last_size, [[start]]); return -1; } [[nut]]->last_packet_start = [[nut]]->packet_start; [[nut]]->packet_start = [[start]]; [[nut]]->written_packet_size= size; return size; }

[[[[Adv]]]]: static int get_packetheader(NUTContext *[[mm]], ByteIOContext *bc, int prefix_length, int [[determineactivegrimeter]]) { int64_t [[fix]], size, last_size; [[fix]]= url_ftell(bc) - prefix_length; if([[fix]] != [[mm]]->packet_start + [[mm]]->written_packet_size){ av_log([[mm]]->avf, AV_LOG_ERROR, "get_packetheader called at weird position\n"); return -1; } if([[determineactivegrimeter]]) init_checksum(bc, update_adler32, 0); size= get_v(bc); last_size= get_v(bc); if([[mm]]->written_packet_size != last_size){ av_log([[mm]]->avf, AV_LOG_ERROR, "packet size missmatch %d != %lld at %lld\n", [[mm]]->written_packet_size, last_size, [[fix]]); return -1; } [[mm]]->last_packet_start = [[mm]]->packet_start; [[mm]]->packet_start = [[fix]]; [[mm]]->written_packet_size= size; return size; }
--------------------------------------------- Result 743 ---------------------------------------------
[[0 (42%)]] --> [[0 (69%)]] --> Socre: 0.6939612627029419

[[[[Adv]]]]: int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size) { int [[i]]; uint32_t state= pc->state; if (buf_size == 0) return 0; for([[i]]=0; [[i]]<buf_size; [[i]]++){ assert(pc->frame_start_found>=0 && pc->frame_start_found<=4); if(pc->frame_start_found&1){ if(state == EXT_START_CODE && (buf[[[i]]]&0xF0) != 0x80) pc->frame_start_found--; else if(state == EXT_START_CODE+2){ if((buf[[[i]]]&3) == 3) pc->frame_start_found= 0; else pc->frame_start_found= (pc->frame_start_found+1)&3; } state++; }else{ [[i]]= ff_find_start_code(buf+[[i]], buf+buf_size, &state) - buf - 1; if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){ [[i]]++; pc->frame_start_found=4; } if(state == SEQ_END_CODE){ pc->state=-1; return [[i]]+1; } if(pc->frame_start_found==2 && state == SEQ_START_CODE) pc->frame_start_found= 0; if(pc->frame_start_found<4 && state == EXT_START_CODE) pc->frame_start_found++; if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){ if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){ pc->frame_start_found=0; pc->state=-1; return [[i]]-3; } } } } pc->state= state; return END_NOT_FOUND; }

[[[[Adv]]]]: int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size) { int [[и]]; uint32_t state= pc->state; if (buf_size == 0) return 0; for([[и]]=0; [[и]]<buf_size; [[и]]++){ assert(pc->frame_start_found>=0 && pc->frame_start_found<=4); if(pc->frame_start_found&1){ if(state == EXT_START_CODE && (buf[[[и]]]&0xF0) != 0x80) pc->frame_start_found--; else if(state == EXT_START_CODE+2){ if((buf[[[и]]]&3) == 3) pc->frame_start_found= 0; else pc->frame_start_found= (pc->frame_start_found+1)&3; } state++; }else{ [[и]]= ff_find_start_code(buf+[[и]], buf+buf_size, &state) - buf - 1; if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){ [[и]]++; pc->frame_start_found=4; } if(state == SEQ_END_CODE){ pc->state=-1; return [[и]]+1; } if(pc->frame_start_found==2 && state == SEQ_START_CODE) pc->frame_start_found= 0; if(pc->frame_start_found<4 && state == EXT_START_CODE) pc->frame_start_found++; if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){ if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){ pc->frame_start_found=0; pc->state=-1; return [[и]]-3; } } } } pc->state= state; return END_NOT_FOUND; }
--------------------------------------------- Result 744 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal) { const uint8_t *data = nal->data; int length = nal->size; HEVCLocalContext *lc = s->HEVClc; int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int)); int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int)); int64_t offset; int startheader, cmpt = 0; int i, j, res = 0; if (!ret || !arg) { av_free(ret); av_free(arg); return AVERROR(ENOMEM); } if (!s->sList[1]) { ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1); for (i = 1; i < s->threads_number; i++) { s->sList[i] = av_malloc(sizeof(HEVCContext)); memcpy(s->sList[i], s, sizeof(HEVCContext)); s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext)); s->sList[i]->HEVClc = s->HEVClcList[i]; } } offset = (lc->gb.index >> 3); for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[0]; j < nal->skipped_bytes; j++) { if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) { startheader--; cmpt++; } } for (i = 1; i < s->sh.num_entry_point_offsets; i++) { offset += (s->sh.entry_point_offset[i - 1] - cmpt); for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[i]; j < nal->skipped_bytes; j++) { if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) { startheader--; cmpt++; } } s->sh.size[i - 1] = s->sh.entry_point_offset[i] - cmpt; s->sh.offset[i - 1] = offset; } if (s->sh.num_entry_point_offsets != 0) { offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt; if (length < offset) { av_log(s->avctx, AV_LOG_ERROR, "entry_point_offset table is corrupted\n"); res = AVERROR_INVALIDDATA; goto error; } s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset; s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset; } s->data = data; for (i = 1; i < s->threads_number; i++) { s->sList[i]->HEVClc->first_qp_group = 1; s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y; memcpy(s->sList[i], s, sizeof(HEVCContext)); s->sList[i]->HEVClc = s->HEVClcList[i]; } avpriv_atomic_int_set(&s->wpp_err, 0); ff_reset_entries(s->avctx); for (i = 0; i <= s->sh.num_entry_point_offsets; i++) { arg[i] = i; ret[i] = 0; } if (s->ps.pps->entropy_coding_sync_enabled_flag) s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1); for (i = 0; i <= s->sh.num_entry_point_offsets; i++) res += ret[i]; error: av_free(ret); av_free(arg); return res; }
--------------------------------------------- Result 745 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 383 / 87 / 275 / 745:  28%|██▊       | 745/2690 [1:53:21<4:55:57,  9.13s/it][Succeeded / Failed / Skipped / Total] 383 / 87 / 275 / 745:  28%|██▊       | 746/2690 [1:53:44<4:56:23,  9.15s/it][Succeeded / Failed / Skipped / Total] 384 / 87 / 275 / 746:  28%|██▊       | 746/2690 [1:53:44<4:56:23,  9.15s/it][Succeeded / Failed / Skipped / Total] 384 / 87 / 275 / 746:  28%|██▊       | 747/2690 [1:54:50<4:58:41,  9.22s/it][Succeeded / Failed / Skipped / Total] 385 / 87 / 275 / 747:  28%|██▊       | 747/2690 [1:54:50<4:58:41,  9.22s/it][Succeeded / Failed / Skipped / Total] 385 / 87 / 275 / 747:  28%|██▊       | 748/2690 [1:54:52<4:58:14,  9.21s/it][Succeeded / Failed / Skipped / Total] 385 / 88 / 275 / 748:  28%|██▊       | 748/2690 [1:54:52<4:58:14,  9.21s/it][[0 (10%)]] --> [[0 (69%)]] --> Socre: 0.6853659152984619

[[[[Adv]]]]: static void gen_tlbsx_440(DisasContext *[[ctx]]) { #if defined(CONFIG_USER_ONLY) gen_inval_exception([[ctx]], POWERPC_EXCP_PRIV_OPC); #else TCGv t0; if (unlikely([[ctx]]->pr)) { gen_inval_exception([[ctx]], POWERPC_EXCP_PRIV_OPC); return; } t0 = tcg_temp_new(); gen_addr_reg_index([[ctx]], t0); gen_helper_440_tlbsx(cpu_gpr[rD([[ctx]]->opcode)], cpu_env, t0); tcg_temp_free(t0); if (Rc([[ctx]]->opcode)) { int [[l1]] = gen_new_label(); tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so); tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD([[ctx]]->opcode)], -1, [[l1]]); tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02); gen_set_label([[l1]]); } #endif }

[[[[Adv]]]]: static void gen_tlbsx_440(DisasContext *[[6m]]) { #if defined(CONFIG_USER_ONLY) gen_inval_exception([[6m]], POWERPC_EXCP_PRIV_OPC); #else TCGv t0; if (unlikely([[6m]]->pr)) { gen_inval_exception([[6m]], POWERPC_EXCP_PRIV_OPC); return; } t0 = tcg_temp_new(); gen_addr_reg_index([[6m]], t0); gen_helper_440_tlbsx(cpu_gpr[rD([[6m]]->opcode)], cpu_env, t0); tcg_temp_free(t0); if (Rc([[6m]]->opcode)) { int [[lalm]] = gen_new_label(); tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so); tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD([[6m]]->opcode)], -1, [[lalm]]); tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02); gen_set_label([[lalm]]); } #endif }
--------------------------------------------- Result 746 ---------------------------------------------
[[0 (4%)]] --> [[0 (96%)]] --> Socre: 0.9581127762794495

[[[[Adv]]]]: static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s, hwaddr addr, int *miny, int *maxy) { DisplaySurface *surface = qemu_console_surface(s->con); int src_width, dest_width; drawfn [[fn]] = NULL; if (s->dest_width) [[fn]] = s->line_fn[s->transp][s->bpp]; if (![[fn]]) return; src_width = (s->xres + 3) & ~3; if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp) src_width *= 3; else if (s->bpp > pxa_lcdc_16bpp) src_width *= 4; else if (s->bpp > pxa_lcdc_8bpp) src_width *= 2; dest_width = s->xres * s->dest_width; *miny = 0; framebuffer_update_display(surface, s->sysmem, addr, s->xres, s->yres, src_width, dest_width, s->dest_width, s->invalidated, [[fn]], s->dma_ch[0].palette, miny, maxy); }

[[[[Adv]]]]: static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s, hwaddr addr, int *miny, int *maxy) { DisplaySurface *surface = qemu_console_surface(s->con); int src_width, dest_width; drawfn [[efν]] = NULL; if (s->dest_width) [[efν]] = s->line_fn[s->transp][s->bpp]; if (![[efν]]) return; src_width = (s->xres + 3) & ~3; if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp) src_width *= 3; else if (s->bpp > pxa_lcdc_16bpp) src_width *= 4; else if (s->bpp > pxa_lcdc_8bpp) src_width *= 2; dest_width = s->xres * s->dest_width; *miny = 0; framebuffer_update_display(surface, s->sysmem, addr, s->xres, s->yres, src_width, dest_width, s->dest_width, s->invalidated, [[efν]], s->dma_ch[0].palette, miny, maxy); }
--------------------------------------------- Result 747 ---------------------------------------------
[[0 (1%)]] --> [[0 (52%)]] --> Socre: 0.5180989503860474

[[[[Adv]]]]: build_dmar_q35(GArray *table_data, GArray *[[linker]]) { int [[dmar_start]] = table_data->len; AcpiTableDmar *[[dmar]]; AcpiDmarHardwareUnit *[[drhd]]; [[dmar]] = acpi_data_push(table_data, sizeof(*[[dmar]])); [[dmar]]->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1; [[dmar]]->flags = 0; [[drhd]] = acpi_data_push(table_data, sizeof(*[[drhd]])); [[drhd]]->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT); [[drhd]]->length = cpu_to_le16(sizeof(*[[drhd]])); [[drhd]]->flags = ACPI_DMAR_INCLUDE_PCI_ALL; [[drhd]]->pci_segment = cpu_to_le16(0); [[drhd]]->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR); build_header([[linker]], table_data, (void *)(table_data->data + [[dmar_start]]), "DMAR", table_data->len - [[dmar_start]], 1, NULL); }

[[[[Adv]]]]: build_dmar_q35(GArray *table_data, GArray *[[mailage]]) { int [[llmcrybirth]] = table_data->len; AcpiTableDmar *[[dmir]]; AcpiDmarHardwareUnit *[[psychologyh]]; [[dmir]] = acpi_data_push(table_data, sizeof(*[[dmir]])); [[dmir]]->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1; [[dmir]]->flags = 0; [[psychologyh]] = acpi_data_push(table_data, sizeof(*[[psychologyh]])); [[psychologyh]]->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT); [[psychologyh]]->length = cpu_to_le16(sizeof(*[[psychologyh]])); [[psychologyh]]->flags = ACPI_DMAR_INCLUDE_PCI_ALL; [[psychologyh]]->pci_segment = cpu_to_le16(0); [[psychologyh]]->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR); build_header([[mailage]], table_data, (void *)(table_data->data + [[llmcrybirth]]), "DMAR", table_data->len - [[llmcrybirth]], 1, NULL); }
--------------------------------------------- Result 748 ---------------------------------------------
[[0 (9%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static GtkWidget *gd_create_menu_machine(GtkDisplayState *[[s]], GtkAccelGroup *[[accel_group]]) { GtkWidget *[[machine_menu]]; GtkWidget *[[separator]]; [[machine_menu]] = gtk_menu_new(); gtk_menu_set_accel_group(GTK_MENU([[machine_menu]]), [[accel_group]]); [[s]]->pause_item = gtk_check_menu_item_new_with_mnemonic(_("_Pause")); gtk_menu_shell_append(GTK_MENU_SHELL([[machine_menu]]), [[s]]->pause_item); [[separator]] = gtk_separator_menu_item_new(); gtk_menu_shell_append(GTK_MENU_SHELL([[machine_menu]]), [[separator]]); [[s]]->reset_item = gtk_menu_item_new_with_mnemonic(_("_Reset")); gtk_menu_shell_append(GTK_MENU_SHELL([[machine_menu]]), [[s]]->reset_item); [[s]]->powerdown_item = gtk_menu_item_new_with_mnemonic(_("Power _Down")); gtk_menu_shell_append(GTK_MENU_SHELL([[machine_menu]]), [[s]]->powerdown_item); [[separator]] = gtk_separator_menu_item_new(); gtk_menu_shell_append(GTK_MENU_SHELL([[machine_menu]]), [[separator]]); [[s]]->quit_item = gtk_menu_item_new_with_mnemonic(_("_Quit")); gtk_menu_item_set_accel_path(GTK_MENU_ITEM([[s]]->quit_item), "<QEMU>/Machine/Quit"); gtk_accel_map_add_entry("<QEMU>/Machine/Quit", GDK_KEY_q, GDK_CONTROL_MASK); gtk_menu_shell_append(GTK_MENU_SHELL([[machine_menu]]), [[s]]->quit_item); return [[machine_menu]]; }

[[[[Adv]]]]: static GtkWidget *gd_create_menu_machine(GtkDisplayState *[[sts]], GtkAccelGroup *[[mattelisvirtualgang]]) { GtkWidget *[[child²mirror]]; GtkWidget *[[samresteditor]]; [[child²mirror]] = gtk_menu_new(); gtk_menu_set_accel_group(GTK_MENU([[child²mirror]]), [[mattelisvirtualgang]]); [[sts]]->pause_item = gtk_check_menu_item_new_with_mnemonic(_("_Pause")); gtk_menu_shell_append(GTK_MENU_SHELL([[child²mirror]]), [[sts]]->pause_item); [[samresteditor]] = gtk_separator_menu_item_new(); gtk_menu_shell_append(GTK_MENU_SHELL([[child²mirror]]), [[samresteditor]]); [[sts]]->reset_item = gtk_menu_item_new_with_mnemonic(_("_Reset")); gtk_menu_shell_append(GTK_MENU_SHELL([[child²mirror]]), [[sts]]->reset_item); [[sts]]->powerdown_item = gtk_menu_item_new_with_mnemonic(_("Power _Down")); gtk_menu_shell_append(GTK_MENU_SHELL([[child²mirror]]), [[sts]]->powerdown_item); [[samresteditor]] = gtk_separator_menu_item_new(); gtk_menu_shell_append(GTK_MENU_SHELL([[child²mirror]]), [[samresteditor]]); [[sts]]->quit_item = gtk_menu_item_new_with_mnemonic(_("_Quit")); gtk_menu_item_set_accel_path(GTK_MENU_ITEM([[sts]]->quit_item), "<QEMU>/Machine/Quit"); gtk_accel_map_add_entry("<QEMU>/Machine/Quit", GDK_KEY_q, GDK_CONTROL_MASK); gtk_menu_shell_append(GTK_MENU_SHELL([[child²mirror]]), [[sts]]->quit_item); return [[child²mirror]]; }
--------------------------------------------- Result 749 ---------------------------------------------
[[0 (17%)]] --> [[0 (53%)]] --> Socre: 0.5348044037818909

[[[[Adv]]]]: static av_cold int encode_init(AVCodecContext *avctx) { FFV1Context *[[s]] = [[avctx]]->priv_data; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get([[avctx]]->pix_fmt); int [[i]], j, k, m, ret; if ((ret = ff_ffv1_common_init([[avctx]])) < 0) return ret; [[s]]->version = 0; if (([[avctx]]->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) || [[avctx]]->slices > 1) [[s]]->version = FFMAX([[s]]->version, 2); if ([[avctx]]->slices == 0 && [[avctx]]->level < 0 && [[avctx]]->width * [[avctx]]->height > 720*576) [[s]]->version = FFMAX([[s]]->version, 2); if ([[avctx]]->level <= 0 && [[s]]->version == 2) { [[s]]->version = 3; } if ([[avctx]]->level >= 0 && [[avctx]]->level <= 4) { if ([[avctx]]->level < [[s]]->version) { av_log([[avctx]], AV_LOG_ERROR, "Version %d needed for requested features but %d requested\n", [[s]]->version, [[avctx]]->level); return AVERROR(EINVAL); } [[s]]->version = [[avctx]]->level; } if ([[s]]->ec < 0) { [[s]]->ec = ([[s]]->version >= 3); } if (([[s]]->version == 2 || [[s]]->version>3) && [[avctx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[avctx]], AV_LOG_ERROR, "Version 2 needed for requested features but version 2 is experimental and not enabled\n"); return AVERROR_INVALIDDATA; } #if FF_API_CODER_TYPE FF_DISABLE_DEPRECATION_WARNINGS if ([[avctx]]->coder_type != -1) [[s]]->ac = [[avctx]]->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE; else FF_ENABLE_DEPRECATION_WARNINGS #endif if ([[s]]->ac == 1) [[s]]->ac = AC_RANGE_CUSTOM_TAB; else if ([[s]]->ac == AC_RANGE_DEFAULT_TAB_FORCE) [[s]]->ac = AC_RANGE_DEFAULT_TAB; [[s]]->plane_count = 3; switch([[avctx]]->pix_fmt) { case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV420P9: case AV_PIX_FMT_YUVA444P9: case AV_PIX_FMT_YUVA422P9: case AV_PIX_FMT_YUVA420P9: if (![[avctx]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 9; case AV_PIX_FMT_GRAY10: case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: case AV_PIX_FMT_YUVA444P10: case AV_PIX_FMT_YUVA422P10: case AV_PIX_FMT_YUVA420P10: if (![[avctx]]->bits_per_raw_sample && ![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 10; case AV_PIX_FMT_GRAY12: case AV_PIX_FMT_YUV444P12: case AV_PIX_FMT_YUV420P12: case AV_PIX_FMT_YUV422P12: [[s]]->packed_at_lsb = 1; if (![[avctx]]->bits_per_raw_sample && ![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 12; case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV420P16: case AV_PIX_FMT_YUVA444P16: case AV_PIX_FMT_YUVA422P16: case AV_PIX_FMT_YUVA420P16: if (![[avctx]]->bits_per_raw_sample && ![[s]]->bits_per_raw_sample) { [[s]]->bits_per_raw_sample = 16; } else if (![[s]]->bits_per_raw_sample) { [[s]]->bits_per_raw_sample = [[avctx]]->bits_per_raw_sample; } if ([[s]]->bits_per_raw_sample <= 8) { av_log([[avctx]], AV_LOG_ERROR, "bits_per_raw_sample invalid\n"); return AVERROR_INVALIDDATA; } [[s]]->version = FFMAX([[s]]->version, 1); case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YA8: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA420P: [[s]]->chroma_planes = desc->nb_components < 3 ? 0 : 1; [[s]]->colorspace = 0; [[s]]->transparency = desc->nb_components == 4 || desc->nb_components == 2; if (![[avctx]]->bits_per_raw_sample && ![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 8; else if (![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 8; break; case AV_PIX_FMT_RGB32: [[s]]->colorspace = 1; [[s]]->transparency = 1; [[s]]->chroma_planes = 1; [[s]]->bits_per_raw_sample = 8; break; case AV_PIX_FMT_RGB48: [[s]]->colorspace = 1; [[s]]->chroma_planes = 1; [[s]]->bits_per_raw_sample = 16; [[s]]->use32bit = 1; [[s]]->version = FFMAX([[s]]->version, 1); if ([[avctx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[avctx]], AV_LOG_ERROR, "16bit RGB is experimental and under development, only use it for experiments\n"); return AVERROR_INVALIDDATA; } break; case AV_PIX_FMT_0RGB32: [[s]]->colorspace = 1; [[s]]->chroma_planes = 1; [[s]]->bits_per_raw_sample = 8; break; case AV_PIX_FMT_GBRP9: if (![[avctx]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 9; case AV_PIX_FMT_GBRP10: if (![[avctx]]->bits_per_raw_sample && ![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 10; case AV_PIX_FMT_GBRP12: if (![[avctx]]->bits_per_raw_sample && ![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 12; case AV_PIX_FMT_GBRP14: if (![[avctx]]->bits_per_raw_sample && ![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 14; case AV_PIX_FMT_GBRP16: if (![[avctx]]->bits_per_raw_sample && ![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = 16; else if (![[s]]->bits_per_raw_sample) [[s]]->bits_per_raw_sample = [[avctx]]->bits_per_raw_sample; [[s]]->colorspace = 1; [[s]]->chroma_planes = 1; if ([[s]]->bits_per_raw_sample >= 16) { [[s]]->use32bit = 1; if ([[avctx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[avctx]], AV_LOG_ERROR, "16bit RGB is experimental and under development, only use it for experiments\n"); return AVERROR_INVALIDDATA; } } [[s]]->version = FFMAX([[s]]->version, 1); break; default: av_log([[avctx]], AV_LOG_ERROR, "format not supported\n"); return AVERROR(ENOSYS); } av_assert0([[s]]->bits_per_raw_sample >= 8); if ([[s]]->bits_per_raw_sample > 8) { if ([[s]]->ac == AC_GOLOMB_RICE) { av_log([[avctx]], AV_LOG_INFO, "bits_per_raw_sample > 8, forcing range coder\n"); [[s]]->ac = AC_RANGE_CUSTOM_TAB; } } if ([[s]]->transparency) { av_log([[avctx]], AV_LOG_WARNING, "Storing alpha plane, this will require a recent FFV1 decoder to playback!\n"); } #if FF_API_PRIVATE_OPT FF_DISABLE_DEPRECATION_WARNINGS if ([[avctx]]->context_model) [[s]]->context_model = [[avctx]]->context_model; if ([[avctx]]->context_model > 1U) { av_log([[avctx]], AV_LOG_ERROR, "Invalid context model %d, valid values are 0 and 1\n", [[avctx]]->context_model); return AVERROR(EINVAL); } FF_ENABLE_DEPRECATION_WARNINGS #endif if ([[s]]->ac == AC_RANGE_CUSTOM_TAB) { for ([[i]] = 1; [[i]] < 256; [[i]]++) [[s]]->state_transition[[[i]]] = ver2_state[[[i]]]; } else { RangeCoder c; ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8); for ([[i]] = 1; [[i]] < 256; [[i]]++) [[s]]->state_transition[[[i]]] = c.one_state[[[i]]]; } for ([[i]] = 0; [[i]] < 256; [[i]]++) { [[s]]->quant_table_count = 2; if ([[s]]->bits_per_raw_sample <= 8) { [[s]]->quant_tables[0][0][[[i]]]= quant11[[[i]]]; [[s]]->quant_tables[0][1][[[i]]]= 11*quant11[[[i]]]; [[s]]->quant_tables[0][2][[[i]]]= 11*11*quant11[[[i]]]; [[s]]->quant_tables[1][0][[[i]]]= quant11[[[i]]]; [[s]]->quant_tables[1][1][[[i]]]= 11*quant11[[[i]]]; [[s]]->quant_tables[1][2][[[i]]]= 11*11*quant5 [[[i]]]; [[s]]->quant_tables[1][3][[[i]]]= 5*11*11*quant5 [[[i]]]; [[s]]->quant_tables[1][4][[[i]]]= 5*5*11*11*quant5 [[[i]]]; } else { [[s]]->quant_tables[0][0][[[i]]]= quant9_10bit[[[i]]]; [[s]]->quant_tables[0][1][[[i]]]= 11*quant9_10bit[[[i]]]; [[s]]->quant_tables[0][2][[[i]]]= 11*11*quant9_10bit[[[i]]]; [[s]]->quant_tables[1][0][[[i]]]= quant9_10bit[[[i]]]; [[s]]->quant_tables[1][1][[[i]]]= 11*quant9_10bit[[[i]]]; [[s]]->quant_tables[1][2][[[i]]]= 11*11*quant5_10bit[[[i]]]; [[s]]->quant_tables[1][3][[[i]]]= 5*11*11*quant5_10bit[[[i]]]; [[s]]->quant_tables[1][4][[[i]]]= 5*5*11*11*quant5_10bit[[[i]]]; } } [[s]]->context_count[0] = (11 * 11 * 11 + 1) / 2; [[s]]->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2; memcpy([[s]]->quant_table, [[s]]->quant_tables[[[s]]->context_model], sizeof([[s]]->quant_table)); for ([[i]] = 0; [[i]] < [[s]]->plane_count; [[i]]++) { PlaneContext *const p = &[[s]]->plane[[[i]]]; memcpy(p->quant_table, [[s]]->quant_table, sizeof(p->quant_table)); p->quant_table_index = [[s]]->context_model; p->context_count = [[s]]->context_count[p->quant_table_index]; } if ((ret = ff_ffv1_allocate_initial_states([[s]])) < 0) return ret; #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[avctx]]->coded_frame->pict_type = AV_PICTURE_TYPE_I; FF_ENABLE_DEPRECATION_WARNINGS #endif if (![[s]]->transparency) [[s]]->plane_count = 2; if (![[s]]->chroma_planes && [[s]]->version > 3) [[s]]->plane_count--; avcodec_get_chroma_sub_sample([[avctx]]->pix_fmt, &[[s]]->chroma_h_shift, &[[s]]->chroma_v_shift); [[s]]->picture_number = 0; if ([[avctx]]->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) { for ([[i]] = 0; [[i]] < [[s]]->quant_table_count; [[i]]++) { [[s]]->rc_stat2[[[i]]] = av_mallocz([[s]]->context_count[[[i]]] * sizeof(*[[s]]->rc_stat2[[[i]]])); if (![[s]]->rc_stat2[[[i]]]) return AVERROR(ENOMEM); } } if ([[avctx]]->stats_in) { char *p = [[avctx]]->stats_in; uint8_t (*best_state)[256] = av_malloc_array(256, 256); int gob_count = 0; char *next; if (!best_state) return AVERROR(ENOMEM); av_assert0([[s]]->version >= 2); for (;;) { for (j = 0; j < 256; j++) for ([[i]] = 0; [[i]] < 2; [[i]]++) { [[s]]->rc_stat[j][[[i]]] = strtol(p, &next, 0); if (next == p) { av_log([[avctx]], AV_LOG_ERROR, "2Pass file invalid at %d %d [%s]\n", j, [[i]], p); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; } for ([[i]] = 0; [[i]] < [[s]]->quant_table_count; [[i]]++) for (j = 0; j < [[s]]->context_count[[[i]]]; j++) { for (k = 0; k < 32; k++) for (m = 0; m < 2; m++) { [[s]]->rc_stat2[[[i]]][j][k][m] = strtol(p, &next, 0); if (next == p) { av_log([[avctx]], AV_LOG_ERROR, "2Pass file invalid at %d %d %d %d [%s]\n", [[i]], j, k, m, p); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; } } gob_count = strtol(p, &next, 0); if (next == p || gob_count <= 0) { av_log([[avctx]], AV_LOG_ERROR, "2Pass file invalid\n"); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; while (*p == '\n' || *p == ' ') p++; if (p[0] == 0) break; } if ([[s]]->ac == AC_RANGE_CUSTOM_TAB) sort_stt([[s]], [[s]]->state_transition); find_best_state(best_state, [[s]]->state_transition); for ([[i]] = 0; [[i]] < [[s]]->quant_table_count; [[i]]++) { for (k = 0; k < 32; k++) { double a=0, b=0; int jp = 0; for (j = 0; j < [[s]]->context_count[[[i]]]; j++) { double p = 128; if ([[s]]->rc_stat2[[[i]]][j][k][0] + [[s]]->rc_stat2[[[i]]][j][k][1] > 200 && j || a+b > 200) { if (a+b) p = 256.0 * b / (a + b); [[s]]->initial_states[[[i]]][jp][k] = best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)]; for(jp++; jp<j; jp++) [[s]]->initial_states[[[i]]][jp][k] = [[s]]->initial_states[[[i]]][jp-1][k]; a=b=0; } a += [[s]]->rc_stat2[[[i]]][j][k][0]; b += [[s]]->rc_stat2[[[i]]][j][k][1]; if (a+b) { p = 256.0 * b / (a + b); } [[s]]->initial_states[[[i]]][j][k] = best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)]; } } } av_freep(&best_state); } if ([[s]]->version > 1) { int plane_count = 1 + 2*[[s]]->chroma_planes + [[s]]->transparency; [[s]]->num_v_slices = ([[avctx]]->width > 352 || [[avctx]]->height > 288 || ![[avctx]]->slices) ? 2 : 1; if ([[avctx]]->height < 5) [[s]]->num_v_slices = 1; for (; [[s]]->num_v_slices < 32; [[s]]->num_v_slices++) { for ([[s]]->num_h_slices = [[s]]->num_v_slices; [[s]]->num_h_slices < 2*[[s]]->num_v_slices; [[s]]->num_h_slices++) { int maxw = ([[avctx]]->width + [[s]]->num_h_slices - 1) / [[s]]->num_h_slices; int maxh = ([[avctx]]->height + [[s]]->num_v_slices - 1) / [[s]]->num_v_slices; if ([[s]]->num_h_slices > [[avctx]]->width || [[s]]->num_v_slices > [[avctx]]->height) continue; if (maxw * maxh * (int64_t)([[s]]->bits_per_raw_sample+1) * plane_count > 8<<24) continue; if ([[avctx]]->slices == [[s]]->num_h_slices * [[s]]->num_v_slices && [[avctx]]->slices <= MAX_SLICES || ![[avctx]]->slices) goto slices_ok; } } av_log([[avctx]], AV_LOG_ERROR, "Unsupported number %d of slices requested, please specify a " "supported number with -slices (ex:4,6,9,12,16, ...)\n", [[avctx]]->slices); return AVERROR(ENOSYS); slices_ok: if ((ret = write_extradata([[s]])) < 0) return ret; } if ((ret = ff_ffv1_init_slice_contexts([[s]])) < 0) return ret; [[s]]->slice_count = [[s]]->max_slice_count; if ((ret = ff_ffv1_init_slices_state([[s]])) < 0) return ret; #define STATS_OUT_SIZE 1024 * 1024 * 6 if ([[avctx]]->flags & AV_CODEC_FLAG_PASS1) { [[avctx]]->stats_out = av_mallocz(STATS_OUT_SIZE); if (![[avctx]]->stats_out) return AVERROR(ENOMEM); for ([[i]] = 0; [[i]] < [[s]]->quant_table_count; [[i]]++) for (j = 0; j < [[s]]->max_slice_count; j++) { FFV1Context *sf = [[s]]->slice_context[j]; av_assert0(!sf->rc_stat2[[[i]]]); sf->rc_stat2[[[i]]] = av_mallocz([[s]]->context_count[[[i]]] * sizeof(*sf->rc_stat2[[[i]]])); if (!sf->rc_stat2[[[i]]]) return AVERROR(ENOMEM); } } return 0; }

[[[[Adv]]]]: static av_cold int encode_init(AVCodecContext *avctx) { FFV1Context *[[saint]] = [[auctingnx]]->priv_data; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get([[auctingnx]]->pix_fmt); int [[she]], j, k, m, ret; if ((ret = ff_ffv1_common_init([[auctingnx]])) < 0) return ret; [[saint]]->version = 0; if (([[auctingnx]]->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) || [[auctingnx]]->slices > 1) [[saint]]->version = FFMAX([[saint]]->version, 2); if ([[auctingnx]]->slices == 0 && [[auctingnx]]->level < 0 && [[auctingnx]]->width * [[auctingnx]]->height > 720*576) [[saint]]->version = FFMAX([[saint]]->version, 2); if ([[auctingnx]]->level <= 0 && [[saint]]->version == 2) { [[saint]]->version = 3; } if ([[auctingnx]]->level >= 0 && [[auctingnx]]->level <= 4) { if ([[auctingnx]]->level < [[saint]]->version) { av_log([[auctingnx]], AV_LOG_ERROR, "Version %d needed for requested features but %d requested\n", [[saint]]->version, [[auctingnx]]->level); return AVERROR(EINVAL); } [[saint]]->version = [[auctingnx]]->level; } if ([[saint]]->ec < 0) { [[saint]]->ec = ([[saint]]->version >= 3); } if (([[saint]]->version == 2 || [[saint]]->version>3) && [[auctingnx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[auctingnx]], AV_LOG_ERROR, "Version 2 needed for requested features but version 2 is experimental and not enabled\n"); return AVERROR_INVALIDDATA; } #if FF_API_CODER_TYPE FF_DISABLE_DEPRECATION_WARNINGS if ([[auctingnx]]->coder_type != -1) [[saint]]->ac = [[auctingnx]]->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE; else FF_ENABLE_DEPRECATION_WARNINGS #endif if ([[saint]]->ac == 1) [[saint]]->ac = AC_RANGE_CUSTOM_TAB; else if ([[saint]]->ac == AC_RANGE_DEFAULT_TAB_FORCE) [[saint]]->ac = AC_RANGE_DEFAULT_TAB; [[saint]]->plane_count = 3; switch([[auctingnx]]->pix_fmt) { case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV420P9: case AV_PIX_FMT_YUVA444P9: case AV_PIX_FMT_YUVA422P9: case AV_PIX_FMT_YUVA420P9: if (![[auctingnx]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 9; case AV_PIX_FMT_GRAY10: case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: case AV_PIX_FMT_YUVA444P10: case AV_PIX_FMT_YUVA422P10: case AV_PIX_FMT_YUVA420P10: if (![[auctingnx]]->bits_per_raw_sample && ![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 10; case AV_PIX_FMT_GRAY12: case AV_PIX_FMT_YUV444P12: case AV_PIX_FMT_YUV420P12: case AV_PIX_FMT_YUV422P12: [[saint]]->packed_at_lsb = 1; if (![[auctingnx]]->bits_per_raw_sample && ![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 12; case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV420P16: case AV_PIX_FMT_YUVA444P16: case AV_PIX_FMT_YUVA422P16: case AV_PIX_FMT_YUVA420P16: if (![[auctingnx]]->bits_per_raw_sample && ![[saint]]->bits_per_raw_sample) { [[saint]]->bits_per_raw_sample = 16; } else if (![[saint]]->bits_per_raw_sample) { [[saint]]->bits_per_raw_sample = [[auctingnx]]->bits_per_raw_sample; } if ([[saint]]->bits_per_raw_sample <= 8) { av_log([[auctingnx]], AV_LOG_ERROR, "bits_per_raw_sample invalid\n"); return AVERROR_INVALIDDATA; } [[saint]]->version = FFMAX([[saint]]->version, 1); case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YA8: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA420P: [[saint]]->chroma_planes = desc->nb_components < 3 ? 0 : 1; [[saint]]->colorspace = 0; [[saint]]->transparency = desc->nb_components == 4 || desc->nb_components == 2; if (![[auctingnx]]->bits_per_raw_sample && ![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 8; else if (![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 8; break; case AV_PIX_FMT_RGB32: [[saint]]->colorspace = 1; [[saint]]->transparency = 1; [[saint]]->chroma_planes = 1; [[saint]]->bits_per_raw_sample = 8; break; case AV_PIX_FMT_RGB48: [[saint]]->colorspace = 1; [[saint]]->chroma_planes = 1; [[saint]]->bits_per_raw_sample = 16; [[saint]]->use32bit = 1; [[saint]]->version = FFMAX([[saint]]->version, 1); if ([[auctingnx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[auctingnx]], AV_LOG_ERROR, "16bit RGB is experimental and under development, only use it for experiments\n"); return AVERROR_INVALIDDATA; } break; case AV_PIX_FMT_0RGB32: [[saint]]->colorspace = 1; [[saint]]->chroma_planes = 1; [[saint]]->bits_per_raw_sample = 8; break; case AV_PIX_FMT_GBRP9: if (![[auctingnx]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 9; case AV_PIX_FMT_GBRP10: if (![[auctingnx]]->bits_per_raw_sample && ![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 10; case AV_PIX_FMT_GBRP12: if (![[auctingnx]]->bits_per_raw_sample && ![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 12; case AV_PIX_FMT_GBRP14: if (![[auctingnx]]->bits_per_raw_sample && ![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 14; case AV_PIX_FMT_GBRP16: if (![[auctingnx]]->bits_per_raw_sample && ![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = 16; else if (![[saint]]->bits_per_raw_sample) [[saint]]->bits_per_raw_sample = [[auctingnx]]->bits_per_raw_sample; [[saint]]->colorspace = 1; [[saint]]->chroma_planes = 1; if ([[saint]]->bits_per_raw_sample >= 16) { [[saint]]->use32bit = 1; if ([[auctingnx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[auctingnx]], AV_LOG_ERROR, "16bit RGB is experimental and under development, only use it for experiments\n"); return AVERROR_INVALIDDATA; } } [[saint]]->version = FFMAX([[saint]]->version, 1); break; default: av_log([[auctingnx]], AV_LOG_ERROR, "format not supported\n"); return AVERROR(ENOSYS); } av_assert0([[saint]]->bits_per_raw_sample >= 8); if ([[saint]]->bits_per_raw_sample > 8) { if ([[saint]]->ac == AC_GOLOMB_RICE) { av_log([[auctingnx]], AV_LOG_INFO, "bits_per_raw_sample > 8, forcing range coder\n"); [[saint]]->ac = AC_RANGE_CUSTOM_TAB; } } if ([[saint]]->transparency) { av_log([[auctingnx]], AV_LOG_WARNING, "Storing alpha plane, this will require a recent FFV1 decoder to playback!\n"); } #if FF_API_PRIVATE_OPT FF_DISABLE_DEPRECATION_WARNINGS if ([[auctingnx]]->context_model) [[saint]]->context_model = [[auctingnx]]->context_model; if ([[auctingnx]]->context_model > 1U) { av_log([[auctingnx]], AV_LOG_ERROR, "Invalid context model %d, valid values are 0 and 1\n", [[auctingnx]]->context_model); return AVERROR(EINVAL); } FF_ENABLE_DEPRECATION_WARNINGS #endif if ([[saint]]->ac == AC_RANGE_CUSTOM_TAB) { for ([[she]] = 1; [[she]] < 256; [[she]]++) [[saint]]->state_transition[[[she]]] = ver2_state[[[she]]]; } else { RangeCoder c; ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8); for ([[she]] = 1; [[she]] < 256; [[she]]++) [[saint]]->state_transition[[[she]]] = c.one_state[[[she]]]; } for ([[she]] = 0; [[she]] < 256; [[she]]++) { [[saint]]->quant_table_count = 2; if ([[saint]]->bits_per_raw_sample <= 8) { [[saint]]->quant_tables[0][0][[[she]]]= quant11[[[she]]]; [[saint]]->quant_tables[0][1][[[she]]]= 11*quant11[[[she]]]; [[saint]]->quant_tables[0][2][[[she]]]= 11*11*quant11[[[she]]]; [[saint]]->quant_tables[1][0][[[she]]]= quant11[[[she]]]; [[saint]]->quant_tables[1][1][[[she]]]= 11*quant11[[[she]]]; [[saint]]->quant_tables[1][2][[[she]]]= 11*11*quant5 [[[she]]]; [[saint]]->quant_tables[1][3][[[she]]]= 5*11*11*quant5 [[[she]]]; [[saint]]->quant_tables[1][4][[[she]]]= 5*5*11*11*quant5 [[[she]]]; } else { [[saint]]->quant_tables[0][0][[[she]]]= quant9_10bit[[[she]]]; [[saint]]->quant_tables[0][1][[[she]]]= 11*quant9_10bit[[[she]]]; [[saint]]->quant_tables[0][2][[[she]]]= 11*11*quant9_10bit[[[she]]]; [[saint]]->quant_tables[1][0][[[she]]]= quant9_10bit[[[she]]]; [[saint]]->quant_tables[1][1][[[she]]]= 11*quant9_10bit[[[she]]]; [[saint]]->quant_tables[1][2][[[she]]]= 11*11*quant5_10bit[[[she]]]; [[saint]]->quant_tables[1][3][[[she]]]= 5*11*11*quant5_10bit[[[she]]]; [[saint]]->quant_tables[1][4][[[she]]]= 5*5*11*11*quant5_10bit[[[she]]]; } } [[saint]]->context_count[0] = (11 * 11 * 11 + 1) / 2; [[saint]]->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2; memcpy([[saint]]->quant_table, [[saint]]->quant_tables[[[saint]]->context_model], sizeof([[saint]]->quant_table)); for ([[she]] = 0; [[she]] < [[saint]]->plane_count; [[she]]++) { PlaneContext *const p = &[[saint]]->plane[[[she]]]; memcpy(p->quant_table, [[saint]]->quant_table, sizeof(p->quant_table)); p->quant_table_index = [[saint]]->context_model; p->context_count = [[saint]]->context_count[p->quant_table_index]; } if ((ret = ff_ffv1_allocate_initial_states([[saint]])) < 0) return ret; #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[auctingnx]]->coded_frame->pict_type = AV_PICTURE_TYPE_I; FF_ENABLE_DEPRECATION_WARNINGS #endif if (![[saint]]->transparency) [[saint]]->plane_count = 2; if (![[saint]]->chroma_planes && [[saint]]->version > 3) [[saint]]->plane_count--; avcodec_get_chroma_sub_sample([[auctingnx]]->pix_fmt, &[[saint]]->chroma_h_shift, &[[saint]]->chroma_v_shift); [[saint]]->picture_number = 0; if ([[auctingnx]]->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) { for ([[she]] = 0; [[she]] < [[saint]]->quant_table_count; [[she]]++) { [[saint]]->rc_stat2[[[she]]] = av_mallocz([[saint]]->context_count[[[she]]] * sizeof(*[[saint]]->rc_stat2[[[she]]])); if (![[saint]]->rc_stat2[[[she]]]) return AVERROR(ENOMEM); } } if ([[auctingnx]]->stats_in) { char *p = [[auctingnx]]->stats_in; uint8_t (*best_state)[256] = av_malloc_array(256, 256); int gob_count = 0; char *next; if (!best_state) return AVERROR(ENOMEM); av_assert0([[saint]]->version >= 2); for (;;) { for (j = 0; j < 256; j++) for ([[she]] = 0; [[she]] < 2; [[she]]++) { [[saint]]->rc_stat[j][[[she]]] = strtol(p, &next, 0); if (next == p) { av_log([[auctingnx]], AV_LOG_ERROR, "2Pass file invalid at %d %d [%s]\n", j, [[she]], p); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; } for ([[she]] = 0; [[she]] < [[saint]]->quant_table_count; [[she]]++) for (j = 0; j < [[saint]]->context_count[[[she]]]; j++) { for (k = 0; k < 32; k++) for (m = 0; m < 2; m++) { [[saint]]->rc_stat2[[[she]]][j][k][m] = strtol(p, &next, 0); if (next == p) { av_log([[auctingnx]], AV_LOG_ERROR, "2Pass file invalid at %d %d %d %d [%s]\n", [[she]], j, k, m, p); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; } } gob_count = strtol(p, &next, 0); if (next == p || gob_count <= 0) { av_log([[auctingnx]], AV_LOG_ERROR, "2Pass file invalid\n"); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; while (*p == '\n' || *p == ' ') p++; if (p[0] == 0) break; } if ([[saint]]->ac == AC_RANGE_CUSTOM_TAB) sort_stt([[saint]], [[saint]]->state_transition); find_best_state(best_state, [[saint]]->state_transition); for ([[she]] = 0; [[she]] < [[saint]]->quant_table_count; [[she]]++) { for (k = 0; k < 32; k++) { double a=0, b=0; int jp = 0; for (j = 0; j < [[saint]]->context_count[[[she]]]; j++) { double p = 128; if ([[saint]]->rc_stat2[[[she]]][j][k][0] + [[saint]]->rc_stat2[[[she]]][j][k][1] > 200 && j || a+b > 200) { if (a+b) p = 256.0 * b / (a + b); [[saint]]->initial_states[[[she]]][jp][k] = best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)]; for(jp++; jp<j; jp++) [[saint]]->initial_states[[[she]]][jp][k] = [[saint]]->initial_states[[[she]]][jp-1][k]; a=b=0; } a += [[saint]]->rc_stat2[[[she]]][j][k][0]; b += [[saint]]->rc_stat2[[[she]]][j][k][1]; if (a+b) { p = 256.0 * b / (a + b); } [[saint]]->initial_states[[[she]]][j][k] = best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)]; } } } av_freep(&best_state); } if ([[saint]]->version > 1) { int plane_count = 1 + 2*[[saint]]->chroma_planes + [[saint]]->transparency; [[saint]]->num_v_slices = ([[auctingnx]]->width > 352 || [[auctingnx]]->height > 288 || ![[auctingnx]]->slices) ? 2 : 1; if ([[auctingnx]]->height < 5) [[saint]]->num_v_slices = 1; for (; [[saint]]->num_v_slices < 32; [[saint]]->num_v_slices++) { for ([[saint]]->num_h_slices = [[saint]]->num_v_slices; [[saint]]->num_h_slices < 2*[[saint]]->num_v_slices; [[saint]]->num_h_slices++) { int maxw = ([[auctingnx]]->width + [[saint]]->num_h_slices - 1) / [[saint]]->num_h_slices; int maxh = ([[auctingnx]]->height + [[saint]]->num_v_slices - 1) / [[saint]]->num_v_slices; if ([[saint]]->num_h_slices > [[auctingnx]]->width || [[saint]]->num_v_slices > [[auctingnx]]->height) continue; if (maxw * maxh * (int64_t)([[saint]]->bits_per_raw_sample+1) * plane_count > 8<<24) continue; if ([[auctingnx]]->slices == [[saint]]->num_h_slices * [[saint]]->num_v_slices && [[auctingnx]]->slices <= MAX_SLICES || ![[auctingnx]]->slices) goto slices_ok; } } av_log([[auctingnx]], AV_LOG_ERROR, "Unsupported number %d of slices requested, please specify a " "supported number with -slices (ex:4,6,9,12,16, ...)\n", [[auctingnx]]->slices); return AVERROR(ENOSYS); slices_ok: if ((ret = write_extradata([[saint]])) < 0) return ret; } if ((ret = ff_ffv1_init_slice_contexts([[saint]])) < 0) return ret; [[saint]]->slice_count = [[saint]]->max_slice_count; if ((ret = ff_ffv1_init_slices_state([[saint]])) < 0) return ret; #define STATS_OUT_SIZE 1024 * 1024 * 6 if ([[auctingnx]]->flags & AV_CODEC_FLAG_PASS1) { [[auctingnx]]->stats_out = av_mallocz(STATS_OUT_SIZE); if (![[auctingnx]]->stats_out) return AVERROR(ENOMEM); for ([[she]] = 0; [[she]] < [[saint]]->quant_table_count; [[she]]++) for (j = 0; j < [[saint]]->max_slice_count; j++) { FFV1Context *sf = [[saint]]->slice_context[j]; av_assert0(!sf->rc_stat2[[[she]]]); sf->rc_stat2[[[she]]] = av_mallocz([[saint]]->context_count[[[she]]] * sizeof(*sf->rc_stat2[[[she]]])); if (!sf->rc_stat2[[[she]]]) return AVERROR(ENOMEM); } } return 0; }[Succeeded / Failed / Skipped / Total] 386 / 88 / 275 / 749:  28%|██▊       | 749/2690 [1:54:52<4:57:41,  9.20s/it][Succeeded / Failed / Skipped / Total] 386 / 88 / 275 / 749:  28%|██▊       | 750/2690 [1:55:16<4:58:10,  9.22s/it][Succeeded / Failed / Skipped / Total] 387 / 88 / 275 / 750:  28%|██▊       | 750/2690 [1:55:16<4:58:10,  9.22s/it][Succeeded / Failed / Skipped / Total] 387 / 88 / 275 / 750:  28%|██▊       | 751/2690 [1:56:07<4:59:50,  9.28s/it][Succeeded / Failed / Skipped / Total] 388 / 88 / 275 / 751:  28%|██▊       | 751/2690 [1:56:07<4:59:50,  9.28s/it][Succeeded / Failed / Skipped / Total] 388 / 88 / 275 / 751:  28%|██▊       | 752/2690 [1:56:08<4:59:18,  9.27s/it][Succeeded / Failed / Skipped / Total] 388 / 88 / 276 / 752:  28%|██▊       | 752/2690 [1:56:08<4:59:18,  9.27s/it][Succeeded / Failed / Skipped / Total] 388 / 88 / 276 / 752:  28%|██▊       | 753/2690 [1:56:08<4:58:46,  9.25s/it][Succeeded / Failed / Skipped / Total] 388 / 88 / 277 / 753:  28%|██▊       | 753/2690 [1:56:08<4:58:46,  9.25s/it][Succeeded / Failed / Skipped / Total] 388 / 88 / 277 / 753:  28%|██▊       | 754/2690 [1:56:10<4:58:17,  9.24s/it][Succeeded / Failed / Skipped / Total] 388 / 89 / 277 / 754:  28%|██▊       | 754/2690 [1:56:10<4:58:17,  9.24s/it][Succeeded / Failed / Skipped / Total] 388 / 89 / 277 / 754:  28%|██▊       | 755/2690 [1:56:18<4:58:05,  9.24s/it][Succeeded / Failed / Skipped / Total] 388 / 90 / 277 / 755:  28%|██▊       | 755/2690 [1:56:18<4:58:05,  9.24s/it][Succeeded / Failed / Skipped / Total] 388 / 90 / 277 / 755:  28%|██▊       | 756/2690 [1:56:42<4:58:33,  9.26s/it]
--------------------------------------------- Result 750 ---------------------------------------------
[[0 (69%)]] --> [[0 (14%)]] --> Socre: 0.8598673343658447

[[[[Adv]]]]: static int qemu_rdma_get_fd(void *opaque) { QEMUFileRDMA *[[rfile]] = opaque; RDMAContext *rdma = [[rfile]]->rdma; return rdma->comp_channel->fd; }

[[[[Adv]]]]: static int qemu_rdma_get_fd(void *opaque) { QEMUFileRDMA *[[digitalle]] = opaque; RDMAContext *rdma = [[digitalle]]->rdma; return rdma->comp_channel->fd; }
--------------------------------------------- Result 751 ---------------------------------------------
[[0 (87%)]] --> [[0 (40%)]] --> Socre: 0.6001570224761963

[[[[Adv]]]]: yuv2rgb_2_c_template(SwsContext *[[c]], const int16_t *[[buf]][2], const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target, int hasAlpha) { const int16_t *buf0 = [[buf]][0], *buf1 = [[buf]][1], *ubuf0 = ubuf[0], *ubuf1 = ubuf[1], *vbuf0 = vbuf[0], *vbuf1 = vbuf[1], *abuf0 = abuf[0], *abuf1 = abuf[1]; int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; int A1, A2; const void *r = [[c]]->table_rV[V], *g = ([[c]]->table_gU[U] + [[c]]->table_gV[V]), *b = [[c]]->table_bU[U]; if (hasAlpha) { A1 = (abuf0[i * 2 ] * yalpha1 + abuf1[i * 2 ] * yalpha) >> 19; A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19; } yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0, r, g, b, y, target, hasAlpha); } }

[[[[Adv]]]]: yuv2rgb_2_c_template(SwsContext *[[plan]], const int16_t *[[tauch]][2], const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target, int hasAlpha) { const int16_t *buf0 = [[tauch]][0], *buf1 = [[tauch]][1], *ubuf0 = ubuf[0], *ubuf1 = ubuf[1], *vbuf0 = vbuf[0], *vbuf1 = vbuf[1], *abuf0 = abuf[0], *abuf1 = abuf[1]; int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; int A1, A2; const void *r = [[plan]]->table_rV[V], *g = ([[plan]]->table_gU[U] + [[plan]]->table_gV[V]), *b = [[plan]]->table_bU[U]; if (hasAlpha) { A1 = (abuf0[i * 2 ] * yalpha1 + abuf1[i * 2 ] * yalpha) >> 19; A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19; } yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0, r, g, b, y, target, hasAlpha); } }
--------------------------------------------- Result 752 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int minimum_frame_bits(VC2EncContext *s) { int slice_x, slice_y, bits = 0; s->size_scaler = 64; for (slice_y = 0; slice_y < s->num_y; slice_y++) { for (slice_x = 0; slice_x < s->num_x; slice_x++) { bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil); } } return bits; }
--------------------------------------------- Result 753 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void fd_coroutine_enter(void *opaque) { FDYieldUntilData *data = opaque; qemu_set_fd_handler(data->fd, NULL, NULL, NULL); qemu_coroutine_enter(data->co, NULL); }
--------------------------------------------- Result 754 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void mv88w8618_flashcfg_write(void *[[opaque]], target_phys_addr_t [[offset]], uint64_t [[value]], unsigned [[size]]) { mv88w8618_flashcfg_state *[[s]] = [[opaque]]; switch ([[offset]]) { case MP_FLASHCFG_CFGR0: [[s]]->cfgr0 = [[value]]; break; } }

[[[[Adv]]]]: static void mv88w8618_flashcfg_write(void *[[enclave]], target_phys_addr_t [[extension]], uint64_t [[extension]], unsigned [[memory]]) { mv88w8618_flashcfg_state *[[height]] = [[enclave]]; switch ([[extension]]) { case MP_FLASHCFG_CFGR0: [[height]]->cfgr0 = [[extension]]; break; } }
--------------------------------------------- Result 755 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void dump_ppc_insns (CPUPPCState *[[env]]) { opc_handler_t **table, *handler; const char *[[p]], *q; uint8_t [[opc1]], opc2, opc3; printf("Instructions set:\n"); for ([[opc1]] = 0x00; [[opc1]] < PPC_CPU_OPCODES_LEN; [[opc1]]++) { table = [[env]]->opcodes; handler = table[[[opc1]]]; if (is_indirect_opcode(handler)) { for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) { table = [[env]]->opcodes; handler = [[env]]->opcodes[[[opc1]]]; table = ind_table(handler); handler = table[opc2]; if (is_indirect_opcode(handler)) { table = ind_table(handler); for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN; opc3++) { handler = table[opc3]; if (handler->handler != &gen_invalid) { [[p]] = strchr(handler->oname, '_'); if ([[p]] == NULL) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%s\n", [[opc1]], opc2, opc3, [[opc1]], (opc3 << 5) | opc2, handler->oname); } else { q = "speundef"; if (([[p]] - handler->oname) != strlen(q) || memcmp(handler->oname, q, strlen(q)) != 0) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%.*s\n", [[opc1]], opc2 << 1, opc3, [[opc1]], (opc3 << 6) | (opc2 << 1), (int)([[p]] - handler->oname), handler->oname); } if (strcmp([[p]] + 1, q) != 0) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%s\n", [[opc1]], (opc2 << 1) | 1, opc3, [[opc1]], (opc3 << 6) | (opc2 << 1) | 1, [[p]] + 1); } } } } } else { if (handler->handler != &gen_invalid) { printf("INSN: %02x %02x -- (%02d %04d) : %s\n", [[opc1]], opc2, [[opc1]], opc2, handler->oname); } } } } else { if (handler->handler != &gen_invalid) { printf("INSN: %02x -- -- (%02d ----) : %s\n", [[opc1]], [[opc1]], handler->oname); } } } }

[[[[Adv]]]]: static void dump_ppc_insns (CPUPPCState *[[erв]]) { opc_handler_t **table, *handler; const char *[[reference]], *q; uint8_t [[apfg]], opc2, opc3; printf("Instructions set:\n"); for ([[apfg]] = 0x00; [[apfg]] < PPC_CPU_OPCODES_LEN; [[apfg]]++) { table = [[erв]]->opcodes; handler = table[[[apfg]]]; if (is_indirect_opcode(handler)) { for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) { table = [[erв]]->opcodes; handler = [[erв]]->opcodes[[[apfg]]]; table = ind_table(handler); handler = table[opc2]; if (is_indirect_opcode(handler)) { table = ind_table(handler); for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN; opc3++) { handler = table[opc3]; if (handler->handler != &gen_invalid) { [[reference]] = strchr(handler->oname, '_'); if ([[reference]] == NULL) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%s\n", [[apfg]], opc2, opc3, [[apfg]], (opc3 << 5) | opc2, handler->oname); } else { q = "speundef"; if (([[reference]] - handler->oname) != strlen(q) || memcmp(handler->oname, q, strlen(q)) != 0) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%.*s\n", [[apfg]], opc2 << 1, opc3, [[apfg]], (opc3 << 6) | (opc2 << 1), (int)([[reference]] - handler->oname), handler->oname); } if (strcmp([[reference]] + 1, q) != 0) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%s\n", [[apfg]], (opc2 << 1) | 1, opc3, [[apfg]], (opc3 << 6) | (opc2 << 1) | 1, [[reference]] + 1); } } } } } else { if (handler->handler != &gen_invalid) { printf("INSN: %02x %02x -- (%02d %04d) : %s\n", [[apfg]], opc2, [[apfg]], opc2, handler->oname); } } } } else { if (handler->handler != &gen_invalid) { printf("INSN: %02x -- -- (%02d ----) : %s\n", [[apfg]], [[apfg]], handler->oname); } } } }
--------------------------------------------- Result 756 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 389 / 90 / 277 / 756:  28%|██▊       | 756/2690 [1:56:42<4:58:33,  9.26s/it][Succeeded / Failed / Skipped / Total] 389 / 90 / 277 / 756:  28%|██▊       | 757/2690 [1:56:43<4:58:02,  9.25s/it][Succeeded / Failed / Skipped / Total] 389 / 90 / 278 / 757:  28%|██▊       | 757/2690 [1:56:43<4:58:02,  9.25s/it][Succeeded / Failed / Skipped / Total] 389 / 90 / 278 / 757:  28%|██▊       | 758/2690 [1:56:45<4:57:34,  9.24s/it][[0 (92%)]] --> [[0 (41%)]] --> Socre: 0.5947007536888123

[[[[Adv]]]]: static void qcow_aio_write_cb(void *[[opaque]], int ret) { QCowAIOCB *acb = [[opaque]]; BlockDriverState *bs = acb->common.bs; BDRVQcowState *s = bs->opaque; int index_in_cluster; uint64_t cluster_offset; const uint8_t *src_buf; int [[n_end]]; acb->hd_aiocb = NULL; if (ret < 0) { fail: acb->common.cb(acb->common.opaque, ret); qemu_aio_release(acb); return; } acb->nb_sectors -= acb->n; acb->sector_num += acb->n; acb->buf += acb->n * 512; if (acb->nb_sectors == 0) { acb->common.cb(acb->common.opaque, 0); qemu_aio_release(acb); return; } index_in_cluster = acb->sector_num & (s->cluster_sectors - 1); [[n_end]] = index_in_cluster + acb->nb_sectors; if (s->crypt_method && [[n_end]] > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) [[n_end]] = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors; cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9, index_in_cluster, [[n_end]], &acb->n); if (!cluster_offset || (cluster_offset & 511) != 0) { ret = -EIO; goto fail; } if (s->crypt_method) { if (!acb->cluster_data) { acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); if (!acb->cluster_data) { ret = -ENOMEM; goto fail; } } encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf, acb->n, 1, &s->aes_encrypt_key); src_buf = acb->cluster_data; } else { src_buf = acb->buf; } acb->hd_aiocb = bdrv_aio_write(s->hd, (cluster_offset >> 9) + index_in_cluster, src_buf, acb->n, qcow_aio_write_cb, acb); if (acb->hd_aiocb == NULL) goto fail; }

[[[[Adv]]]]: static void qcow_aio_write_cb(void *[[leger]], int ret) { QCowAIOCB *acb = [[leger]]; BlockDriverState *bs = acb->common.bs; BDRVQcowState *s = bs->opaque; int index_in_cluster; uint64_t cluster_offset; const uint8_t *src_buf; int [[enlogwonder]]; acb->hd_aiocb = NULL; if (ret < 0) { fail: acb->common.cb(acb->common.opaque, ret); qemu_aio_release(acb); return; } acb->nb_sectors -= acb->n; acb->sector_num += acb->n; acb->buf += acb->n * 512; if (acb->nb_sectors == 0) { acb->common.cb(acb->common.opaque, 0); qemu_aio_release(acb); return; } index_in_cluster = acb->sector_num & (s->cluster_sectors - 1); [[enlogwonder]] = index_in_cluster + acb->nb_sectors; if (s->crypt_method && [[enlogwonder]] > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) [[enlogwonder]] = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors; cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9, index_in_cluster, [[enlogwonder]], &acb->n); if (!cluster_offset || (cluster_offset & 511) != 0) { ret = -EIO; goto fail; } if (s->crypt_method) { if (!acb->cluster_data) { acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); if (!acb->cluster_data) { ret = -ENOMEM; goto fail; } } encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf, acb->n, 1, &s->aes_encrypt_key); src_buf = acb->cluster_data; } else { src_buf = acb->buf; } acb->hd_aiocb = bdrv_aio_write(s->hd, (cluster_offset >> 9) + index_in_cluster, src_buf, acb->n, qcow_aio_write_cb, acb); if (acb->hd_aiocb == NULL) goto fail; }
--------------------------------------------- Result 757 ---------------------------------------------
[[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mxf_write_packet(AVFormatContext *s, AVPacket *pkt) { MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; AVStream *st = s->streams[pkt->stream_index]; MXFStreamContext *sc = st->priv_data; MXFIndexEntry ie = {0}; if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) { mxf->index_entries = av_realloc(mxf->index_entries, (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries)); if (!mxf->index_entries) { av_log(s, AV_LOG_ERROR, "could not allocate index entries\n"); return -1; } } if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) { if (!mxf_parse_mpeg2_frame(s, st, pkt, &ie)) { av_log(s, AV_LOG_ERROR, "could not get mpeg2 profile and level\n"); return -1; } } if (!mxf->header_written) { if (mxf->edit_unit_byte_count) { mxf_write_partition(s, 1, 2, header_open_partition_key, 1); mxf_write_klv_fill(s); mxf_write_index_table_segment(s); } else { mxf_write_partition(s, 0, 0, header_open_partition_key, 1); } mxf->header_written = 1; } if (st->index == 0) { if (!mxf->edit_unit_byte_count && (!mxf->edit_units_count || mxf->edit_units_count > EDIT_UNITS_PER_BODY) && !(ie.flags & 0x33)) { mxf_write_klv_fill(s); mxf_write_partition(s, 1, 2, body_partition_key, 0); mxf_write_klv_fill(s); mxf_write_index_table_segment(s); } mxf_write_klv_fill(s); mxf_write_system_item(s); if (!mxf->edit_unit_byte_count) { mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset; mxf->index_entries[mxf->edit_units_count].flags = ie.flags; mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref; mxf->body_offset += KAG_SIZE; } mxf->edit_units_count++; } else if (!mxf->edit_unit_byte_count && st->index == 1) { mxf->index_entries[mxf->edit_units_count-1].slice_offset = mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset; } mxf_write_klv_fill(s); avio_write(pb, sc->track_essence_element_key, 16); if (s->oformat == &ff_mxf_d10_muxer) { if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) mxf_write_d10_video_packet(s, st, pkt); else mxf_write_d10_audio_packet(s, st, pkt); } else { klv_encode_ber4_length(pb, pkt->size); avio_write(pb, pkt->data, pkt->size); mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size); } avio_flush(pb); return 0; }
--------------------------------------------- Result 758 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 390 / 90 / 278 / 758:  28%|██▊       | 758/2690 [1:56:45<4:57:34,  9.24s/it][Succeeded / Failed / Skipped / Total] 390 / 90 / 278 / 758:  28%|██▊       | 759/2690 [1:56:47<4:57:08,  9.23s/it][[0 (48%)]] --> [[0 (99%)]] --> Socre: 0.9927427768707275

[[[[Adv]]]]: static int usb_hub_handle_control(USBDevice *[[dev]], USBPacket *p, int request, int value, int index, int length, uint8_t *data) { USBHubState *s = (USBHubState *)dev; int ret; ret = usb_desc_handle_control(dev, p, request, value, index, length, data); if (ret >= 0) { return ret; } switch(request) { case EndpointOutRequest | USB_REQ_CLEAR_FEATURE: if (value == 0 && index != 0x81) { goto fail; } ret = 0; break; case DeviceRequest | USB_REQ_GET_INTERFACE: data[0] = 0; ret = 1; break; case DeviceOutRequest | USB_REQ_SET_INTERFACE: ret = 0; break; case GetHubStatus: data[0] = 0; data[1] = 0; data[2] = 0; data[3] = 0; ret = 4; break; case GetPortStatus: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; data[0] = port->wPortStatus; data[1] = port->wPortStatus >> 8; data[2] = port->wPortChange; data[3] = port->wPortChange >> 8; ret = 4; } break; case SetHubFeature: case ClearHubFeature: if (value == 0 || value == 1) { } else { goto fail; } ret = 0; break; case SetPortFeature: { unsigned int n = index - 1; USBHubPort *port; USBDevice *dev; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; dev = port->port.dev; switch(value) { case PORT_SUSPEND: port->wPortStatus |= PORT_STAT_SUSPEND; break; case PORT_RESET: if (dev) { usb_send_msg(dev, USB_MSG_RESET); port->wPortChange |= PORT_STAT_C_RESET; port->wPortStatus |= PORT_STAT_ENABLE; } break; case PORT_POWER: break; default: goto fail; } ret = 0; } break; case ClearPortFeature: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; switch(value) { case PORT_ENABLE: port->wPortStatus &= ~PORT_STAT_ENABLE; break; case PORT_C_ENABLE: port->wPortChange &= ~PORT_STAT_C_ENABLE; break; case PORT_SUSPEND: port->wPortStatus &= ~PORT_STAT_SUSPEND; break; case PORT_C_SUSPEND: port->wPortChange &= ~PORT_STAT_C_SUSPEND; break; case PORT_C_CONNECTION: port->wPortChange &= ~PORT_STAT_C_CONNECTION; break; case PORT_C_OVERCURRENT: port->wPortChange &= ~PORT_STAT_C_OVERCURRENT; break; case PORT_C_RESET: port->wPortChange &= ~PORT_STAT_C_RESET; break; default: goto fail; } ret = 0; } break; case GetHubDescriptor: { unsigned int n, limit, var_hub_size = 0; memcpy(data, qemu_hub_hub_descriptor, sizeof(qemu_hub_hub_descriptor)); data[2] = NUM_PORTS; limit = ((NUM_PORTS + 1 + 7) / 8) + 7; for (n = 7; n < limit; n++) { data[n] = 0x00; var_hub_size++; } limit = limit + ((NUM_PORTS + 7) / 8); for (;n < limit; n++) { data[n] = 0xff; var_hub_size++; } ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size; data[0] = ret; break; } default: fail: ret = USB_RET_STALL; break; } return ret; }

[[[[Adv]]]]: static int usb_hub_handle_control(USBDevice *[[detroit]], USBPacket *p, int request, int value, int index, int length, uint8_t *data) { USBHubState *s = (USBHubState *)dev; int ret; ret = usb_desc_handle_control(dev, p, request, value, index, length, data); if (ret >= 0) { return ret; } switch(request) { case EndpointOutRequest | USB_REQ_CLEAR_FEATURE: if (value == 0 && index != 0x81) { goto fail; } ret = 0; break; case DeviceRequest | USB_REQ_GET_INTERFACE: data[0] = 0; ret = 1; break; case DeviceOutRequest | USB_REQ_SET_INTERFACE: ret = 0; break; case GetHubStatus: data[0] = 0; data[1] = 0; data[2] = 0; data[3] = 0; ret = 4; break; case GetPortStatus: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; data[0] = port->wPortStatus; data[1] = port->wPortStatus >> 8; data[2] = port->wPortChange; data[3] = port->wPortChange >> 8; ret = 4; } break; case SetHubFeature: case ClearHubFeature: if (value == 0 || value == 1) { } else { goto fail; } ret = 0; break; case SetPortFeature: { unsigned int n = index - 1; USBHubPort *port; USBDevice *dev; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; dev = port->port.dev; switch(value) { case PORT_SUSPEND: port->wPortStatus |= PORT_STAT_SUSPEND; break; case PORT_RESET: if (dev) { usb_send_msg(dev, USB_MSG_RESET); port->wPortChange |= PORT_STAT_C_RESET; port->wPortStatus |= PORT_STAT_ENABLE; } break; case PORT_POWER: break; default: goto fail; } ret = 0; } break; case ClearPortFeature: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; switch(value) { case PORT_ENABLE: port->wPortStatus &= ~PORT_STAT_ENABLE; break; case PORT_C_ENABLE: port->wPortChange &= ~PORT_STAT_C_ENABLE; break; case PORT_SUSPEND: port->wPortStatus &= ~PORT_STAT_SUSPEND; break; case PORT_C_SUSPEND: port->wPortChange &= ~PORT_STAT_C_SUSPEND; break; case PORT_C_CONNECTION: port->wPortChange &= ~PORT_STAT_C_CONNECTION; break; case PORT_C_OVERCURRENT: port->wPortChange &= ~PORT_STAT_C_OVERCURRENT; break; case PORT_C_RESET: port->wPortChange &= ~PORT_STAT_C_RESET; break; default: goto fail; } ret = 0; } break; case GetHubDescriptor: { unsigned int n, limit, var_hub_size = 0; memcpy(data, qemu_hub_hub_descriptor, sizeof(qemu_hub_hub_descriptor)); data[2] = NUM_PORTS; limit = ((NUM_PORTS + 1 + 7) / 8) + 7; for (n = 7; n < limit; n++) { data[n] = 0x00; var_hub_size++; } limit = limit + ((NUM_PORTS + 7) / 8); for (;n < limit; n++) { data[n] = 0xff; var_hub_size++; } ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size; data[0] = ret; break; } default: fail: ret = USB_RET_STALL; break; } return ret; }
--------------------------------------------- Result 759 ---------------------------------------------
[[0 (36%)]] --> [[0 (56%)]] --> Socre: 0.5553054809570312

[[[[Adv]]]]: static int opt_input_file(const char *opt, const char *filename) { AVFormatContext *ic; AVInputFormat *file_iformat = NULL; int err, i, ret, rfps, rfps_base; int64_t timestamp; uint8_t [[buf]][128]; AVDictionary **opts; int orig_nb_streams; if (last_asked_format) { if (!(file_iformat = av_find_input_format(last_asked_format))) { fprintf(stderr, "Unknown input format: '%s'\n", last_asked_format); ffmpeg_exit(1); } last_asked_format = NULL; } if (!strcmp(filename, "-")) filename = "pipe:"; using_stdin |= !strncmp(filename, "pipe:", 5) || !strcmp(filename, "/dev/stdin"); ic = avformat_alloc_context(); if (!ic) { print_error(filename, AVERROR(ENOMEM)); ffmpeg_exit(1); } if (audio_sample_rate) { snprintf([[buf]], sizeof([[buf]]), "%d", audio_sample_rate); av_dict_set(&format_opts, "sample_rate", [[buf]], 0); } if (audio_channels) { snprintf([[buf]], sizeof([[buf]]), "%d", audio_channels); av_dict_set(&format_opts, "channels", [[buf]], 0); } if (frame_rate.num) { snprintf([[buf]], sizeof([[buf]]), "%d/%d", frame_rate.num, frame_rate.den); av_dict_set(&format_opts, "framerate", [[buf]], 0); } if (frame_width && frame_height) { snprintf([[buf]], sizeof([[buf]]), "%dx%d", frame_width, frame_height); av_dict_set(&format_opts, "video_size", [[buf]], 0); } if (frame_pix_fmt != PIX_FMT_NONE) av_dict_set(&format_opts, "pixel_format", av_get_pix_fmt_name(frame_pix_fmt), 0); ic->video_codec_id = find_codec_or_die(video_codec_name , AVMEDIA_TYPE_VIDEO , 0); ic->audio_codec_id = find_codec_or_die(audio_codec_name , AVMEDIA_TYPE_AUDIO , 0); ic->subtitle_codec_id= find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0); ic->flags |= AVFMT_FLAG_NONBLOCK; err = avformat_open_input(&ic, filename, file_iformat, &format_opts); if (err < 0) { print_error(filename, err); ffmpeg_exit(1); } assert_avoptions(format_opts); if(opt_programid) { int i, j; int found=0; for(i=0; i<ic->nb_streams; i++){ ic->streams[i]->discard= AVDISCARD_ALL; } for(i=0; i<ic->nb_programs; i++){ AVProgram *p= ic->programs[i]; if(p->id != opt_programid){ p->discard = AVDISCARD_ALL; }else{ found=1; for(j=0; j<p->nb_stream_indexes; j++){ ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT; } } } if(!found){ fprintf(stderr, "Specified program id not found\n"); ffmpeg_exit(1); } opt_programid=0; } if (loop_input) { av_log(NULL, AV_LOG_WARNING, "-loop_input is deprecated, use -loop 1\n"); ic->loop_input = loop_input; } opts = setup_find_stream_info_opts(ic, codec_opts); orig_nb_streams = ic->nb_streams; ret = avformat_find_stream_info(ic, opts); if (ret < 0 && verbose >= 0) { fprintf(stderr, "%s: could not find codec parameters\n", filename); av_close_input_file(ic); ffmpeg_exit(1); } timestamp = start_time; if (ic->start_time != AV_NOPTS_VALUE) timestamp += ic->start_time; if (start_time != 0) { ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD); if (ret < 0) { fprintf(stderr, "%s: could not seek to position %0.3f\n", filename, (double)timestamp / AV_TIME_BASE); } start_time = 0; } for(i=0;i<ic->nb_streams;i++) { AVStream *st = ic->streams[i]; AVCodecContext *dec = st->codec; InputStream *ist; dec->thread_count = thread_count; input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1); ist = &input_streams[nb_input_streams - 1]; ist->st = st; ist->file_index = nb_input_files; ist->discard = 1; ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0); if (i < nb_ts_scale) ist->ts_scale = ts_scale[i]; switch (dec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->dec = avcodec_find_decoder_by_name(audio_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); if(audio_disable) st->discard= AVDISCARD_ALL; break; case AVMEDIA_TYPE_VIDEO: ist->dec= avcodec_find_decoder_by_name(video_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); rfps = ic->streams[i]->r_frame_rate.num; rfps_base = ic->streams[i]->r_frame_rate.den; if (dec->lowres) { dec->flags |= CODEC_FLAG_EMU_EDGE; } if(me_threshold) dec->debug |= FF_DEBUG_MV; if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) { if (verbose >= 0) fprintf(stderr,"\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n", i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num, (float)rfps / rfps_base, rfps, rfps_base); } if(video_disable) st->discard= AVDISCARD_ALL; else if(video_discard) st->discard= video_discard; break; case AVMEDIA_TYPE_DATA: break; case AVMEDIA_TYPE_SUBTITLE: ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); if(subtitle_disable) st->discard = AVDISCARD_ALL; break; case AVMEDIA_TYPE_ATTACHMENT: case AVMEDIA_TYPE_UNKNOWN: break; default: abort(); } } if (verbose >= 0) av_dump_format(ic, nb_input_files, filename, 0); input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1); input_files[nb_input_files - 1].ctx = ic; input_files[nb_input_files - 1].ist_index = nb_input_streams - ic->nb_streams; input_files[nb_input_files - 1].ts_offset = input_ts_offset - (copy_ts ? 0 : timestamp); top_field_first = -1; frame_rate = (AVRational){0, 0}; frame_pix_fmt = PIX_FMT_NONE; frame_height = 0; frame_width = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; av_freep(&ts_scale); nb_ts_scale = 0; for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); av_freep(&video_codec_name); av_freep(&audio_codec_name); av_freep(&subtitle_codec_name); uninit_opts(); init_opts(); return 0; }

[[[[Adv]]]]: static int opt_input_file(const char *opt, const char *filename) { AVFormatContext *ic; AVInputFormat *file_iformat = NULL; int err, i, ret, rfps, rfps_base; int64_t timestamp; uint8_t [[nbф]][128]; AVDictionary **opts; int orig_nb_streams; if (last_asked_format) { if (!(file_iformat = av_find_input_format(last_asked_format))) { fprintf(stderr, "Unknown input format: '%s'\n", last_asked_format); ffmpeg_exit(1); } last_asked_format = NULL; } if (!strcmp(filename, "-")) filename = "pipe:"; using_stdin |= !strncmp(filename, "pipe:", 5) || !strcmp(filename, "/dev/stdin"); ic = avformat_alloc_context(); if (!ic) { print_error(filename, AVERROR(ENOMEM)); ffmpeg_exit(1); } if (audio_sample_rate) { snprintf([[nbф]], sizeof([[nbф]]), "%d", audio_sample_rate); av_dict_set(&format_opts, "sample_rate", [[nbф]], 0); } if (audio_channels) { snprintf([[nbф]], sizeof([[nbф]]), "%d", audio_channels); av_dict_set(&format_opts, "channels", [[nbф]], 0); } if (frame_rate.num) { snprintf([[nbф]], sizeof([[nbф]]), "%d/%d", frame_rate.num, frame_rate.den); av_dict_set(&format_opts, "framerate", [[nbф]], 0); } if (frame_width && frame_height) { snprintf([[nbф]], sizeof([[nbф]]), "%dx%d", frame_width, frame_height); av_dict_set(&format_opts, "video_size", [[nbф]], 0); } if (frame_pix_fmt != PIX_FMT_NONE) av_dict_set(&format_opts, "pixel_format", av_get_pix_fmt_name(frame_pix_fmt), 0); ic->video_codec_id = find_codec_or_die(video_codec_name , AVMEDIA_TYPE_VIDEO , 0); ic->audio_codec_id = find_codec_or_die(audio_codec_name , AVMEDIA_TYPE_AUDIO , 0); ic->subtitle_codec_id= find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0); ic->flags |= AVFMT_FLAG_NONBLOCK; err = avformat_open_input(&ic, filename, file_iformat, &format_opts); if (err < 0) { print_error(filename, err); ffmpeg_exit(1); } assert_avoptions(format_opts); if(opt_programid) { int i, j; int found=0; for(i=0; i<ic->nb_streams; i++){ ic->streams[i]->discard= AVDISCARD_ALL; } for(i=0; i<ic->nb_programs; i++){ AVProgram *p= ic->programs[i]; if(p->id != opt_programid){ p->discard = AVDISCARD_ALL; }else{ found=1; for(j=0; j<p->nb_stream_indexes; j++){ ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT; } } } if(!found){ fprintf(stderr, "Specified program id not found\n"); ffmpeg_exit(1); } opt_programid=0; } if (loop_input) { av_log(NULL, AV_LOG_WARNING, "-loop_input is deprecated, use -loop 1\n"); ic->loop_input = loop_input; } opts = setup_find_stream_info_opts(ic, codec_opts); orig_nb_streams = ic->nb_streams; ret = avformat_find_stream_info(ic, opts); if (ret < 0 && verbose >= 0) { fprintf(stderr, "%s: could not find codec parameters\n", filename); av_close_input_file(ic); ffmpeg_exit(1); } timestamp = start_time; if (ic->start_time != AV_NOPTS_VALUE) timestamp += ic->start_time; if (start_time != 0) { ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD); if (ret < 0) { fprintf(stderr, "%s: could not seek to position %0.3f\n", filename, (double)timestamp / AV_TIME_BASE); } start_time = 0; } for(i=0;i<ic->nb_streams;i++) { AVStream *st = ic->streams[i]; AVCodecContext *dec = st->codec; InputStream *ist; dec->thread_count = thread_count; input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1); ist = &input_streams[nb_input_streams - 1]; ist->st = st; ist->file_index = nb_input_files; ist->discard = 1; ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0); if (i < nb_ts_scale) ist->ts_scale = ts_scale[i]; switch (dec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->dec = avcodec_find_decoder_by_name(audio_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); if(audio_disable) st->discard= AVDISCARD_ALL; break; case AVMEDIA_TYPE_VIDEO: ist->dec= avcodec_find_decoder_by_name(video_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); rfps = ic->streams[i]->r_frame_rate.num; rfps_base = ic->streams[i]->r_frame_rate.den; if (dec->lowres) { dec->flags |= CODEC_FLAG_EMU_EDGE; } if(me_threshold) dec->debug |= FF_DEBUG_MV; if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) { if (verbose >= 0) fprintf(stderr,"\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n", i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num, (float)rfps / rfps_base, rfps, rfps_base); } if(video_disable) st->discard= AVDISCARD_ALL; else if(video_discard) st->discard= video_discard; break; case AVMEDIA_TYPE_DATA: break; case AVMEDIA_TYPE_SUBTITLE: ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); if(subtitle_disable) st->discard = AVDISCARD_ALL; break; case AVMEDIA_TYPE_ATTACHMENT: case AVMEDIA_TYPE_UNKNOWN: break; default: abort(); } } if (verbose >= 0) av_dump_format(ic, nb_input_files, filename, 0); input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1); input_files[nb_input_files - 1].ctx = ic; input_files[nb_input_files - 1].ist_index = nb_input_streams - ic->nb_streams; input_files[nb_input_files - 1].ts_offset = input_ts_offset - (copy_ts ? 0 : timestamp); top_field_first = -1; frame_rate = (AVRational){0, 0}; frame_pix_fmt = PIX_FMT_NONE; frame_height = 0; frame_width = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; av_freep(&ts_scale); nb_ts_scale = 0; for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); av_freep(&video_codec_name); av_freep(&audio_codec_name); av_freep(&subtitle_codec_name); uninit_opts(); init_opts(); return 0; }[Succeeded / Failed / Skipped / Total] 391 / 90 / 278 / 759:  28%|██▊       | 759/2690 [1:56:47<4:57:08,  9.23s/it][Succeeded / Failed / Skipped / Total] 391 / 90 / 278 / 759:  28%|██▊       | 760/2690 [1:57:35<4:58:38,  9.28s/it][Succeeded / Failed / Skipped / Total] 392 / 90 / 278 / 760:  28%|██▊       | 760/2690 [1:57:35<4:58:38,  9.28s/it][Succeeded / Failed / Skipped / Total] 392 / 90 / 278 / 760:  28%|██▊       | 761/2690 [1:57:43<4:58:23,  9.28s/it][Succeeded / Failed / Skipped / Total] 393 / 90 / 278 / 761:  28%|██▊       | 761/2690 [1:57:43<4:58:23,  9.28s/it][Succeeded / Failed / Skipped / Total] 393 / 90 / 278 / 761:  28%|██▊       | 762/2690 [1:57:50<4:58:09,  9.28s/it]
--------------------------------------------- Result 760 ---------------------------------------------
[[0 (3%)]] --> [[0 (66%)]] --> Socre: 0.6606157422065735

[[[[Adv]]]]: int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address, int access_type, int [[mmu_idx]], int [[is_softmmu]]) { uint32_t phys_addr; target_ulong [[page_size]]; int prot; int [[ret]], is_user; is_user = [[mmu_idx]] == MMU_USER_IDX; [[ret]] = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot, &[[page_size]]); if ([[ret]] == 0) { phys_addr &= ~(uint32_t)0x3ff; address &= ~(uint32_t)0x3ff; tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, [[mmu_idx]], [[page_size]]); return 0; } if (access_type == 2) { env->cp15.c5_insn = [[ret]]; env->cp15.c6_insn = address; env->exception_index = EXCP_PREFETCH_ABORT; } else { env->cp15.c5_data = [[ret]]; if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6)) env->cp15.c5_data |= (1 << 11); env->cp15.c6_data = address; env->exception_index = EXCP_DATA_ABORT; } return 1; }

[[[[Adv]]]]: int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address, int access_type, int [[myun²zpass]], int [[thisradboldvit]]) { uint32_t phys_addr; target_ulong [[squarequadwider]]; int prot; int [[trophyts]], is_user; is_user = [[myun²zpass]] == MMU_USER_IDX; [[trophyts]] = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot, &[[squarequadwider]]); if ([[trophyts]] == 0) { phys_addr &= ~(uint32_t)0x3ff; address &= ~(uint32_t)0x3ff; tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, [[myun²zpass]], [[squarequadwider]]); return 0; } if (access_type == 2) { env->cp15.c5_insn = [[trophyts]]; env->cp15.c6_insn = address; env->exception_index = EXCP_PREFETCH_ABORT; } else { env->cp15.c5_data = [[trophyts]]; if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6)) env->cp15.c5_data |= (1 << 11); env->cp15.c6_data = address; env->exception_index = EXCP_DATA_ABORT; } return 1; }
--------------------------------------------- Result 761 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9869790077209473

[[[[Adv]]]]: static inline int get_chroma_qp(H264Context *[[h]], int [[t]], int [[qscale]]){ return [[h]]->pps.chroma_qp_table[[[t]]][[[qscale]]]; }

[[[[Adv]]]]: static inline int get_chroma_qp(H264Context *[[v]], int [[τ]], int [[widenaci]]){ return [[v]]->pps.chroma_qp_table[[[τ]]][[[widenaci]]]; }
--------------------------------------------- Result 762 ---------------------------------------------
[[0 (32%)]] --> [[0 (76%)]] --> Socre: 0.7602733969688416

[[[[Adv]]]]: static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc, int plane_idx, int is_key, int is_chroma) { int blk, ret; int [[i]], j, bx, by; uint8_t *dst, *ref, *ref_start, *ref_end; int v, col[2]; const uint8_t *scan; int xoff, yoff; LOCAL_ALIGNED_16(int16_t, block, [64]); LOCAL_ALIGNED_16(int32_t, dctblock, [64]); int [[coordmap]][64]; int ybias = is_key ? -15 : 0; int qp; const int stride = frame->linesize[plane_idx]; int bw = is_chroma ? (c->avctx->width + 15) >> 4 : (c->avctx->width + 7) >> 3; int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3; binkb_init_bundles(c); ref_start = frame->data[plane_idx]; ref_end = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8; for ([[i]] = 0; [[i]] < 64; [[i]]++) [[coordmap]][[[i]]] = ([[i]] & 7) + ([[i]] >> 3) * stride; for (by = 0; by < bh; by++) { for ([[i]] = 0; [[i]] < BINKB_NB_SRC; [[i]]++) { if ((ret = binkb_read_bundle(c, bc, [[i]])) < 0) return ret; } dst = frame->data[plane_idx] + 8*by*stride; for (bx = 0; bx < bw; bx++, dst += 8) { blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES); switch (blk) { case 0: break; case 1: scan = bink_patterns[bitstream_read(bc, 4)]; [[i]] = 0; do { int mode = bitstream_read_bit(bc); int run = bitstream_read(bc, binkb_runbits[[[i]]]) + 1; [[i]] += run; if ([[i]] > 64) { av_log(c->avctx, AV_LOG_ERROR, "Run went out of bounds\n"); return AVERROR_INVALIDDATA; } if (mode) { v = binkb_get_value(c, BINKB_SRC_COLORS); for (j = 0; j < run; j++) dst[[[coordmap]][*scan++]] = v; } else { for (j = 0; j < run; j++) dst[[[coordmap]][*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); } } while ([[i]] < 63); if ([[i]] == 63) dst[[[coordmap]][*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); break; case 2: memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC); qp = binkb_get_value(c, BINKB_SRC_INTRA_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp); c->binkdsp.idct_put(dst, stride, dctblock); break; case 3: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8*stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } c->bdsp.clear_block(block); v = binkb_get_value(c, BINKB_SRC_INTER_COEFS); read_residue(bc, block, v); c->binkdsp.add_pixels8(dst, block, stride); break; case 4: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC); qp = binkb_get_value(c, BINKB_SRC_INTER_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp); c->binkdsp.idct_add(dst, stride, dctblock); break; case 5: v = binkb_get_value(c, BINKB_SRC_COLORS); c->bdsp.fill_block_tab[1](dst, v, stride, 8); break; case 6: for ([[i]] = 0; [[i]] < 2; [[i]]++) col[[[i]]] = binkb_get_value(c, BINKB_SRC_COLORS); for ([[i]] = 0; [[i]] < 8; [[i]]++) { v = binkb_get_value(c, BINKB_SRC_PATTERN); for (j = 0; j < 8; j++, v >>= 1) dst[[[i]]*stride + j] = col[v & 1]; } break; case 7: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } break; case 8: for ([[i]] = 0; [[i]] < 8; [[i]]++) memcpy(dst + [[i]]*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + [[i]]*8, 8); c->bundle[BINKB_SRC_COLORS].cur_ptr += 64; break; default: av_log(c->avctx, AV_LOG_ERROR, "Unknown block type %d\n", blk); return AVERROR_INVALIDDATA; } } } if (bitstream_tell(bc) & 0x1F) bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F)); return 0; }

[[[[Adv]]]]: static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc, int plane_idx, int is_key, int is_chroma) { int blk, ret; int [[v]], j, bx, by; uint8_t *dst, *ref, *ref_start, *ref_end; int v, col[2]; const uint8_t *scan; int xoff, yoff; LOCAL_ALIGNED_16(int16_t, block, [64]); LOCAL_ALIGNED_16(int32_t, dctblock, [64]); int [[scunraп]][64]; int ybias = is_key ? -15 : 0; int qp; const int stride = frame->linesize[plane_idx]; int bw = is_chroma ? (c->avctx->width + 15) >> 4 : (c->avctx->width + 7) >> 3; int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3; binkb_init_bundles(c); ref_start = frame->data[plane_idx]; ref_end = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8; for ([[v]] = 0; [[v]] < 64; [[v]]++) [[scunraп]][[[v]]] = ([[v]] & 7) + ([[v]] >> 3) * stride; for (by = 0; by < bh; by++) { for ([[v]] = 0; [[v]] < BINKB_NB_SRC; [[v]]++) { if ((ret = binkb_read_bundle(c, bc, [[v]])) < 0) return ret; } dst = frame->data[plane_idx] + 8*by*stride; for (bx = 0; bx < bw; bx++, dst += 8) { blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES); switch (blk) { case 0: break; case 1: scan = bink_patterns[bitstream_read(bc, 4)]; [[v]] = 0; do { int mode = bitstream_read_bit(bc); int run = bitstream_read(bc, binkb_runbits[[[v]]]) + 1; [[v]] += run; if ([[v]] > 64) { av_log(c->avctx, AV_LOG_ERROR, "Run went out of bounds\n"); return AVERROR_INVALIDDATA; } if (mode) { v = binkb_get_value(c, BINKB_SRC_COLORS); for (j = 0; j < run; j++) dst[[[scunraп]][*scan++]] = v; } else { for (j = 0; j < run; j++) dst[[[scunraп]][*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); } } while ([[v]] < 63); if ([[v]] == 63) dst[[[scunraп]][*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); break; case 2: memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC); qp = binkb_get_value(c, BINKB_SRC_INTRA_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp); c->binkdsp.idct_put(dst, stride, dctblock); break; case 3: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8*stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } c->bdsp.clear_block(block); v = binkb_get_value(c, BINKB_SRC_INTER_COEFS); read_residue(bc, block, v); c->binkdsp.add_pixels8(dst, block, stride); break; case 4: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC); qp = binkb_get_value(c, BINKB_SRC_INTER_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp); c->binkdsp.idct_add(dst, stride, dctblock); break; case 5: v = binkb_get_value(c, BINKB_SRC_COLORS); c->bdsp.fill_block_tab[1](dst, v, stride, 8); break; case 6: for ([[v]] = 0; [[v]] < 2; [[v]]++) col[[[v]]] = binkb_get_value(c, BINKB_SRC_COLORS); for ([[v]] = 0; [[v]] < 8; [[v]]++) { v = binkb_get_value(c, BINKB_SRC_PATTERN); for (j = 0; j < 8; j++, v >>= 1) dst[[[v]]*stride + j] = col[v & 1]; } break; case 7: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } break; case 8: for ([[v]] = 0; [[v]] < 8; [[v]]++) memcpy(dst + [[v]]*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + [[v]]*8, 8); c->bundle[BINKB_SRC_COLORS].cur_ptr += 64; break; default: av_log(c->avctx, AV_LOG_ERROR, "Unknown block type %d\n", blk); return AVERROR_INVALIDDATA; } } } if (bitstream_tell(bc) & 0x1F) bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F)); return 0; }[Succeeded / Failed / Skipped / Total] 394 / 90 / 278 / 762:  28%|██▊       | 762/2690 [1:57:50<4:58:09,  9.28s/it][Succeeded / Failed / Skipped / Total] 394 / 90 / 278 / 762:  28%|██▊       | 763/2690 [1:57:57<4:57:55,  9.28s/it][Succeeded / Failed / Skipped / Total] 394 / 91 / 278 / 763:  28%|██▊       | 763/2690 [1:57:57<4:57:55,  9.28s/it][Succeeded / Failed / Skipped / Total] 394 / 91 / 278 / 763:  28%|██▊       | 764/2690 [1:57:59<4:57:26,  9.27s/it][Succeeded / Failed / Skipped / Total] 395 / 91 / 278 / 764:  28%|██▊       | 764/2690 [1:57:59<4:57:26,  9.27s/it][Succeeded / Failed / Skipped / Total] 395 / 91 / 278 / 764:  28%|██▊       | 765/2690 [1:58:24<4:57:56,  9.29s/it][Succeeded / Failed / Skipped / Total] 396 / 91 / 278 / 765:  28%|██▊       | 765/2690 [1:58:24<4:57:56,  9.29s/it][Succeeded / Failed / Skipped / Total] 396 / 91 / 278 / 765:  28%|██▊       | 766/2690 [1:58:40<4:58:05,  9.30s/it][Succeeded / Failed / Skipped / Total] 396 / 92 / 278 / 766:  28%|██▊       | 766/2690 [1:58:40<4:58:05,  9.30s/it][Succeeded / Failed / Skipped / Total] 396 / 92 / 278 / 766:  29%|██▊       | 767/2690 [1:58:41<4:57:34,  9.28s/it][Succeeded / Failed / Skipped / Total] 396 / 92 / 279 / 767:  29%|██▊       | 767/2690 [1:58:41<4:57:34,  9.28s/it][Succeeded / Failed / Skipped / Total] 396 / 92 / 279 / 767:  29%|██▊       | 768/2690 [1:58:43<4:57:08,  9.28s/it]
--------------------------------------------- Result 763 ---------------------------------------------
[[0 (23%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void term_handle_byte(int [[ch]]) { switch(term_esc_state) { case IS_NORM: switch([[ch]]) { case 1: term_bol(); break; case 4: term_delete_char(); break; case 5: term_eol(); break; case 9: term_completion(); break; case 10: case 13: term_cmd_buf[term_cmd_buf_size] = '\0'; term_hist_add(term_cmd_buf); term_printf("\n"); term_handle_command(term_cmd_buf); term_show_prompt(); break; case 27: term_esc_state = IS_ESC; break; case 127: case 8: term_backspace(); break; case 155: term_esc_state = IS_CSI; break; default: if ([[ch]] >= 32) { term_insert_char([[ch]]); } break; } break; case IS_ESC: if ([[ch]] == '[') { term_esc_state = IS_CSI; term_esc_param = 0; } else { term_esc_state = IS_NORM; } break; case IS_CSI: switch([[ch]]) { case 'A': case 'F': term_up_char(); break; case 'B': case 'E': term_down_char(); break; case 'D': term_backward_char(); break; case 'C': term_forward_char(); break; case '0' ... '9': term_esc_param = term_esc_param * 10 + ([[ch]] - '0'); goto the_end; case '~': switch(term_esc_param) { case 1: term_bol(); break; case 3: term_delete_char(); break; case 4: term_eol(); break; } break; default: break; } term_esc_state = IS_NORM; the_end: break; } term_update(); }

[[[[Adv]]]]: static void term_handle_byte(int [[چ]]) { switch(term_esc_state) { case IS_NORM: switch([[چ]]) { case 1: term_bol(); break; case 4: term_delete_char(); break; case 5: term_eol(); break; case 9: term_completion(); break; case 10: case 13: term_cmd_buf[term_cmd_buf_size] = '\0'; term_hist_add(term_cmd_buf); term_printf("\n"); term_handle_command(term_cmd_buf); term_show_prompt(); break; case 27: term_esc_state = IS_ESC; break; case 127: case 8: term_backspace(); break; case 155: term_esc_state = IS_CSI; break; default: if ([[چ]] >= 32) { term_insert_char([[چ]]); } break; } break; case IS_ESC: if ([[چ]] == '[') { term_esc_state = IS_CSI; term_esc_param = 0; } else { term_esc_state = IS_NORM; } break; case IS_CSI: switch([[چ]]) { case 'A': case 'F': term_up_char(); break; case 'B': case 'E': term_down_char(); break; case 'D': term_backward_char(); break; case 'C': term_forward_char(); break; case '0' ... '9': term_esc_param = term_esc_param * 10 + ([[چ]] - '0'); goto the_end; case '~': switch(term_esc_param) { case 1: term_bol(); break; case 3: term_delete_char(); break; case 4: term_eol(); break; } break; default: break; } term_esc_state = IS_NORM; the_end: break; } term_update(); }
--------------------------------------------- Result 764 ---------------------------------------------
[[0 (89%)]] --> [[0 (43%)]] --> Socre: 0.5692476630210876

[[[[Adv]]]]: static int get_cpsr(QEMUFile *f, void *opaque, size_t [[size]]) { ARMCPU *cpu = opaque; CPUARMState *env = &cpu->env; uint32_t [[val]] = qemu_get_be32(f); env->aarch64 = (([[val]] & PSTATE_nRW) == 0); if (is_a64(env)) { pstate_write(env, [[val]]); return 0; } env->uncached_cpsr = [[val]] & CPSR_M; cpsr_write(env, [[val]], 0xffffffff, CPSRWriteRaw); return 0; }

[[[[Adv]]]]: static int get_cpsr(QEMUFile *f, void *opaque, size_t [[style]]) { ARMCPU *cpu = opaque; CPUARMState *env = &cpu->env; uint32_t [[fan]] = qemu_get_be32(f); env->aarch64 = (([[fan]] & PSTATE_nRW) == 0); if (is_a64(env)) { pstate_write(env, [[fan]]); return 0; } env->uncached_cpsr = [[fan]] & CPSR_M; cpsr_write(env, [[fan]], 0xffffffff, CPSRWriteRaw); return 0; }
--------------------------------------------- Result 765 ---------------------------------------------
[[0 (4%)]] --> [[0 (96%)]] --> Socre: 0.964913547039032

[[[[Adv]]]]: static void qbus_list_bus(DeviceState *dev, char *dest, int len) { BusState *child; const char *sep = " "; int [[pos]] = 0; [[pos]] += snprintf(dest+[[pos]], len-[[pos]],"child busses at \"%s\":", dev->id ? dev->id : dev->info->name); LIST_FOREACH(child, &dev->child_bus, sibling) { [[pos]] += snprintf(dest+[[pos]], len-[[pos]], "%s\"%s\"", sep, child->name); sep = ", "; } }

[[[[Adv]]]]: static void qbus_list_bus(DeviceState *dev, char *dest, int len) { BusState *child; const char *sep = " "; int [[пsm]] = 0; [[пsm]] += snprintf(dest+[[пsm]], len-[[пsm]],"child busses at \"%s\":", dev->id ? dev->id : dev->info->name); LIST_FOREACH(child, &dev->child_bus, sibling) { [[пsm]] += snprintf(dest+[[пsm]], len-[[пsm]], "%s\"%s\"", sep, child->name); sep = ", "; } }
--------------------------------------------- Result 766 ---------------------------------------------
[[0 (5%)]] --> [[[FAILED]]]

[[[[Adv]]]]: struct omap_l4_s *omap_l4_init(target_phys_addr_t [[base]], int [[ta_num]]) { struct omap_l4_s *[[bus]] = g_malloc0( sizeof(*[[bus]]) + [[ta_num]] * sizeof(*[[bus]]->ta)); [[bus]]->ta_num = [[ta_num]]; [[bus]]->base = [[base]]; #ifdef L4_MUX_HACK omap_l4_io_entries = 1; omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry)); omap_cpu_io_entry = cpu_register_io_memory(omap_l4_io_readfn, omap_l4_io_writefn, [[bus]], DEVICE_NATIVE_ENDIAN); # define L4_PAGES (0xb4000 / TARGET_PAGE_SIZE) omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES); #endif return [[bus]]; }

[[[[Adv]]]]: struct omap_l4_s *omap_l4_init(target_phys_addr_t [[foundation]], int [[ya2016tmed]]) { struct omap_l4_s *[[driver]] = g_malloc0( sizeof(*[[driver]]) + [[ya2016tmed]] * sizeof(*[[driver]]->ta)); [[driver]]->ta_num = [[ya2016tmed]]; [[driver]]->base = [[foundation]]; #ifdef L4_MUX_HACK omap_l4_io_entries = 1; omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry)); omap_cpu_io_entry = cpu_register_io_memory(omap_l4_io_readfn, omap_l4_io_writefn, [[driver]], DEVICE_NATIVE_ENDIAN); # define L4_PAGES (0xb4000 / TARGET_PAGE_SIZE) omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES); #endif return [[driver]]; }
--------------------------------------------- Result 767 ---------------------------------------------
[[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void cubieboard_init(QEMUMachineInitArgs *args) { CubieBoardState *s = g_new(CubieBoardState, 1); Error *err = NULL; s->a10 = AW_A10(object_new(TYPE_AW_A10)); object_property_set_bool(OBJECT(s->a10), "True" == "True", "realized", &err); if (err != NULL) { error_report("Couldn't realize Allwinner A10: %s\n", error_get_pretty(err)); exit(1); } memory_region_init_ram(&s->sdram, NULL, "cubieboard.ram", args->ram_size); vmstate_register_ram_global(&s->sdram); memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE, &s->sdram); cubieboard_binfo.ram_size = args->ram_size; cubieboard_binfo.kernel_filename = args->kernel_filename; cubieboard_binfo.kernel_cmdline = args->kernel_cmdline; arm_load_kernel(&s->a10->cpu, &cubieboard_binfo); }
--------------------------------------------- Result 768 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 397 / 92 / 279 / 768:  29%|██▊       | 768/2690 [1:58:43<4:57:08,  9.28s/it][Succeeded / Failed / Skipped / Total] 397 / 92 / 279 / 768:  29%|██▊       | 769/2690 [1:58:57<4:57:10,  9.28s/it][Succeeded / Failed / Skipped / Total] 398 / 92 / 279 / 769:  29%|██▊       | 769/2690 [1:58:57<4:57:10,  9.28s/it][Succeeded / Failed / Skipped / Total] 398 / 92 / 279 / 769:  29%|██▊       | 770/2690 [1:59:11<4:57:12,  9.29s/it][[0 (43%)]] --> [[0 (61%)]] --> Socre: 0.6113954782485962

[[[[Adv]]]]: static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number) { const char *p; char *q, buf1[20], c; int nd, len, addchar_count; int [[found_count]] = 0; q = buf; p = filename; for (;;) { c = *p; if (c == '\0') break; if (c == '%' && *(p+1) == '%') addchar_count = 2; else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) { nd = 0; addchar_count = 1; while (av_isdigit(*(p + addchar_count))) { nd = nd * 10 + *(p + addchar_count) - '0'; addchar_count++; } if (*(p + addchar_count) == placeholder) { len = snprintf(buf1, sizeof(buf1), "%0*"PRId64, (number < 0) ? nd : nd++, number); if (len < 1) goto fail; if ((q - buf + len) > buf_size - 1) goto fail; memcpy(q, buf1, len); q += len; p += (addchar_count + 1); addchar_count = 0; [[found_count]]++; } } else addchar_count = 1; while (addchar_count--) if ((q - buf) < buf_size - 1) *q++ = *p++; else goto fail; } *q = '\0'; return [[found_count]]; fail: *q = '\0'; return -1; }

[[[[Adv]]]]: static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number) { const char *p; char *q, buf1[20], c; int nd, len, addchar_count; int [[dugercross]] = 0; q = buf; p = filename; for (;;) { c = *p; if (c == '\0') break; if (c == '%' && *(p+1) == '%') addchar_count = 2; else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) { nd = 0; addchar_count = 1; while (av_isdigit(*(p + addchar_count))) { nd = nd * 10 + *(p + addchar_count) - '0'; addchar_count++; } if (*(p + addchar_count) == placeholder) { len = snprintf(buf1, sizeof(buf1), "%0*"PRId64, (number < 0) ? nd : nd++, number); if (len < 1) goto fail; if ((q - buf + len) > buf_size - 1) goto fail; memcpy(q, buf1, len); q += len; p += (addchar_count + 1); addchar_count = 0; [[dugercross]]++; } } else addchar_count = 1; while (addchar_count--) if ((q - buf) < buf_size - 1) *q++ = *p++; else goto fail; } *q = '\0'; return [[dugercross]]; fail: *q = '\0'; return -1; }
--------------------------------------------- Result 769 ---------------------------------------------
[[0 (78%)]] --> [[0 (44%)]] --> Socre: 0.5589629411697388

[[[[Adv]]]]: static int read_directory(BDRVVVFATState* s, int [[mapping_index]]) { mapping_t* mapping = array_get(&(s->mapping), [[mapping_index]]); direntry_t* direntry; const char* dirname = mapping->path; int first_cluster = mapping->begin; int [[parent_index]] = mapping->info.dir.parent_mapping_index; mapping_t* parent_mapping = (mapping_t*) ([[parent_index]] >= 0 ? array_get(&(s->mapping), [[parent_index]]) : NULL); int [[first_cluster_of_parent]] = parent_mapping ? parent_mapping->begin : -1; DIR* dir=opendir(dirname); struct dirent* entry; int i; assert(mapping->mode & MODE_DIRECTORY); if(!dir) { mapping->end = mapping->begin; return -1; } i = mapping->info.dir.first_dir_index = first_cluster == 0 ? 0 : s->directory.next; if (first_cluster != 0) { (void)create_short_and_long_name(s, i, ".", 1); (void)create_short_and_long_name(s, i, "..", 1); } while((entry=readdir(dir))) { unsigned int length=strlen(dirname)+2+strlen(entry->d_name); char* [[buffer]]; direntry_t* direntry; struct stat st; int is_dot=!strcmp(entry->d_name,"."); int is_dotdot=!strcmp(entry->d_name,".."); if(first_cluster == 0 && (is_dotdot || is_dot)) continue; [[buffer]] = g_malloc(length); snprintf([[buffer]],length,"%s/%s",dirname,entry->d_name); if(stat([[buffer]],&st)<0) { g_free([[buffer]]); continue; } if (!is_dot && !is_dotdot) { direntry = create_short_and_long_name(s, i, entry->d_name, 0); } else { direntry = array_get(&(s->directory), is_dot ? i : i + 1); } direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20); direntry->reserved[0]=direntry->reserved[1]=0; direntry->ctime=fat_datetime(st.st_ctime,1); direntry->cdate=fat_datetime(st.st_ctime,0); direntry->adate=fat_datetime(st.st_atime,0); direntry->begin_hi=0; direntry->mtime=fat_datetime(st.st_mtime,1); direntry->mdate=fat_datetime(st.st_mtime,0); if(is_dotdot) set_begin_of_direntry(direntry, [[first_cluster_of_parent]]); else if(is_dot) set_begin_of_direntry(direntry, first_cluster); else direntry->begin=0; if (st.st_size > 0x7fffffff) { fprintf(stderr, "File %s is larger than 2GB\n", [[buffer]]); g_free([[buffer]]); closedir(dir); return -2; } direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size); if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) { s->current_mapping = array_get_next(&(s->mapping)); s->current_mapping->begin=0; s->current_mapping->end=st.st_size; s->current_mapping->dir_index=s->directory.next-1; s->current_mapping->first_mapping_index = -1; if (S_ISDIR(st.st_mode)) { s->current_mapping->mode = MODE_DIRECTORY; s->current_mapping->info.dir.parent_mapping_index = [[mapping_index]]; } else { s->current_mapping->mode = MODE_UNDEFINED; s->current_mapping->info.file.offset = 0; } s->current_mapping->path=[[buffer]]; s->current_mapping->read_only = (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0; } else { g_free([[buffer]]); } } closedir(dir); while(s->directory.next%(0x10*s->sectors_per_cluster)) { direntry_t* direntry=array_get_next(&(s->directory)); memset(direntry,0,sizeof(direntry_t)); } #define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster) if ([[mapping_index]] == 0 && s->directory.next < ROOT_ENTRIES) { int cur = s->directory.next; array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1); s->directory.next = ROOT_ENTRIES; memset(array_get(&(s->directory), cur), 0, (ROOT_ENTRIES - cur) * sizeof(direntry_t)); } mapping = array_get(&(s->mapping), [[mapping_index]]); first_cluster += (s->directory.next - mapping->info.dir.first_dir_index) * 0x20 / s->cluster_size; mapping->end = first_cluster; direntry = array_get(&(s->directory), mapping->dir_index); set_begin_of_direntry(direntry, mapping->begin); return 0; }

[[[[Adv]]]]: static int read_directory(BDRVVVFATState* s, int [[missilecityos]]) { mapping_t* mapping = array_get(&(s->mapping), [[missilecityos]]); direntry_t* direntry; const char* dirname = mapping->path; int first_cluster = mapping->begin; int [[popingiris]] = mapping->info.dir.parent_mapping_index; mapping_t* parent_mapping = (mapping_t*) ([[popingiris]] >= 0 ? array_get(&(s->mapping), [[popingiris]]) : NULL); int [[2ndivefestivalingafterourmother]] = parent_mapping ? parent_mapping->begin : -1; DIR* dir=opendir(dirname); struct dirent* entry; int i; assert(mapping->mode & MODE_DIRECTORY); if(!dir) { mapping->end = mapping->begin; return -1; } i = mapping->info.dir.first_dir_index = first_cluster == 0 ? 0 : s->directory.next; if (first_cluster != 0) { (void)create_short_and_long_name(s, i, ".", 1); (void)create_short_and_long_name(s, i, "..", 1); } while((entry=readdir(dir))) { unsigned int length=strlen(dirname)+2+strlen(entry->d_name); char* [[loop]]; direntry_t* direntry; struct stat st; int is_dot=!strcmp(entry->d_name,"."); int is_dotdot=!strcmp(entry->d_name,".."); if(first_cluster == 0 && (is_dotdot || is_dot)) continue; [[loop]] = g_malloc(length); snprintf([[loop]],length,"%s/%s",dirname,entry->d_name); if(stat([[loop]],&st)<0) { g_free([[loop]]); continue; } if (!is_dot && !is_dotdot) { direntry = create_short_and_long_name(s, i, entry->d_name, 0); } else { direntry = array_get(&(s->directory), is_dot ? i : i + 1); } direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20); direntry->reserved[0]=direntry->reserved[1]=0; direntry->ctime=fat_datetime(st.st_ctime,1); direntry->cdate=fat_datetime(st.st_ctime,0); direntry->adate=fat_datetime(st.st_atime,0); direntry->begin_hi=0; direntry->mtime=fat_datetime(st.st_mtime,1); direntry->mdate=fat_datetime(st.st_mtime,0); if(is_dotdot) set_begin_of_direntry(direntry, [[2ndivefestivalingafterourmother]]); else if(is_dot) set_begin_of_direntry(direntry, first_cluster); else direntry->begin=0; if (st.st_size > 0x7fffffff) { fprintf(stderr, "File %s is larger than 2GB\n", [[loop]]); g_free([[loop]]); closedir(dir); return -2; } direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size); if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) { s->current_mapping = array_get_next(&(s->mapping)); s->current_mapping->begin=0; s->current_mapping->end=st.st_size; s->current_mapping->dir_index=s->directory.next-1; s->current_mapping->first_mapping_index = -1; if (S_ISDIR(st.st_mode)) { s->current_mapping->mode = MODE_DIRECTORY; s->current_mapping->info.dir.parent_mapping_index = [[missilecityos]]; } else { s->current_mapping->mode = MODE_UNDEFINED; s->current_mapping->info.file.offset = 0; } s->current_mapping->path=[[loop]]; s->current_mapping->read_only = (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0; } else { g_free([[loop]]); } } closedir(dir); while(s->directory.next%(0x10*s->sectors_per_cluster)) { direntry_t* direntry=array_get_next(&(s->directory)); memset(direntry,0,sizeof(direntry_t)); } #define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster) if ([[missilecityos]] == 0 && s->directory.next < ROOT_ENTRIES) { int cur = s->directory.next; array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1); s->directory.next = ROOT_ENTRIES; memset(array_get(&(s->directory), cur), 0, (ROOT_ENTRIES - cur) * sizeof(direntry_t)); } mapping = array_get(&(s->mapping), [[missilecityos]]); first_cluster += (s->directory.next - mapping->info.dir.first_dir_index) * 0x20 / s->cluster_size; mapping->end = first_cluster; direntry = array_get(&(s->directory), mapping->dir_index); set_begin_of_direntry(direntry, mapping->begin); return 0; }
--------------------------------------------- Result 770 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 399 / 92 / 279 / 770:  29%|██▊       | 770/2690 [1:59:11<4:57:12,  9.29s/it][Succeeded / Failed / Skipped / Total] 399 / 92 / 279 / 770:  29%|██▊       | 771/2690 [1:59:21<4:57:04,  9.29s/it][Succeeded / Failed / Skipped / Total] 400 / 92 / 279 / 771:  29%|██▊       | 771/2690 [1:59:21<4:57:04,  9.29s/it][Succeeded / Failed / Skipped / Total] 400 / 92 / 279 / 771:  29%|██▊       | 772/2690 [1:59:36<4:57:08,  9.30s/it][Succeeded / Failed / Skipped / Total] 401 / 92 / 279 / 772:  29%|██▊       | 772/2690 [1:59:36<4:57:08,  9.30s/it][Succeeded / Failed / Skipped / Total] 401 / 92 / 279 / 772:  29%|██▊       | 773/2690 [1:59:36<4:56:37,  9.28s/it][Succeeded / Failed / Skipped / Total] 401 / 92 / 280 / 773:  29%|██▊       | 773/2690 [1:59:36<4:56:37,  9.28s/it][Succeeded / Failed / Skipped / Total] 401 / 92 / 280 / 773:  29%|██▉       | 774/2690 [1:59:46<4:56:30,  9.29s/it][Succeeded / Failed / Skipped / Total] 402 / 92 / 280 / 774:  29%|██▉       | 774/2690 [1:59:46<4:56:30,  9.29s/it][Succeeded / Failed / Skipped / Total] 402 / 92 / 280 / 774:  29%|██▉       | 775/2690 [1:59:47<4:55:59,  9.27s/it][Succeeded / Failed / Skipped / Total] 402 / 92 / 281 / 775:  29%|██▉       | 775/2690 [1:59:47<4:55:59,  9.27s/it][Succeeded / Failed / Skipped / Total] 402 / 92 / 281 / 775:  29%|██▉       | 776/2690 [2:00:04<4:56:10,  9.28s/it][[0 (44%)]] --> [[0 (52%)]] --> Socre: 0.5205657482147217

[[[[Adv]]]]: static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame) { WMACodecContext *[[s]] = avctx->priv_data; float **audio = (float **) frame->extended_data; int len = frame->nb_samples; int window_index = [[s]]->frame_len_bits - [[s]]->block_len_bits; FFTContext *mdct = &[[s]]->mdct_ctx[window_index]; int ch; const float *win = [[s]]->windows[window_index]; int window_len = 1 << [[s]]->block_len_bits; float n = 2.0 * 32768.0 / window_len; for (ch = 0; ch < avctx->channels; ch++) { memcpy([[s]]->output, [[s]]->frame_out[ch], window_len * sizeof(*[[s]]->output)); [[s]]->fdsp->vector_fmul_scalar([[s]]->frame_out[ch], audio[ch], n, len); [[s]]->fdsp->vector_fmul_reverse(&[[s]]->output[window_len], [[s]]->frame_out[ch], win, len); [[s]]->fdsp->vector_fmul([[s]]->frame_out[ch], [[s]]->frame_out[ch], win, len); mdct->mdct_calc(mdct, [[s]]->coefs[ch], [[s]]->output); } }

[[[[Adv]]]]: static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame) { WMACodecContext *[[bars]] = avctx->priv_data; float **audio = (float **) frame->extended_data; int len = frame->nb_samples; int window_index = [[bars]]->frame_len_bits - [[bars]]->block_len_bits; FFTContext *mdct = &[[bars]]->mdct_ctx[window_index]; int ch; const float *win = [[bars]]->windows[window_index]; int window_len = 1 << [[bars]]->block_len_bits; float n = 2.0 * 32768.0 / window_len; for (ch = 0; ch < avctx->channels; ch++) { memcpy([[bars]]->output, [[bars]]->frame_out[ch], window_len * sizeof(*[[bars]]->output)); [[bars]]->fdsp->vector_fmul_scalar([[bars]]->frame_out[ch], audio[ch], n, len); [[bars]]->fdsp->vector_fmul_reverse(&[[bars]]->output[window_len], [[bars]]->frame_out[ch], win, len); [[bars]]->fdsp->vector_fmul([[bars]]->frame_out[ch], [[bars]]->frame_out[ch], win, len); mdct->mdct_calc(mdct, [[bars]]->coefs[ch], [[bars]]->output); } }
--------------------------------------------- Result 771 ---------------------------------------------
[[0 (78%)]] --> [[0 (30%)]] --> Socre: 0.6952612698078156

[[[[Adv]]]]: static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1, const uint8_t *s2, int stride) { int [[i]]; vec_u8 perm1 = vec_lvsl(0, s1); vec_u8 perm2 = vec_lvsl(0, s2); const vec_u8 zero = (const vec_u8)vec_splat_u8(0); vec_s16 shorts1, shorts2; for ([[i]] = 0; [[i]] < 4; [[i]]++) { vec_u8 pixl = vec_ld(0, s1); vec_u8 pixr = vec_ld(15, s1); vec_u8 bytes = vec_perm(pixl, pixr, perm1); shorts1 = (vec_s16)vec_mergeh(zero, bytes); pixl = vec_ld(0, s2); pixr = vec_ld(15, s2); bytes = vec_perm(pixl, pixr, perm2); shorts2 = (vec_s16)vec_mergeh(zero, bytes); shorts1 = vec_sub(shorts1, shorts2); vec_st(shorts1, 0, (vec_s16 *)block); s1 += stride; s2 += stride; block += 8; pixl = vec_ld(0, s1); pixr = vec_ld(15, s1); bytes = vec_perm(pixl, pixr, perm1); shorts1 = (vec_s16)vec_mergeh(zero, bytes); pixl = vec_ld(0, s2); pixr = vec_ld(15, s2); bytes = vec_perm(pixl, pixr, perm2); shorts2 = (vec_s16)vec_mergeh(zero, bytes); shorts1 = vec_sub(shorts1, shorts2); vec_st(shorts1, 0, (vec_s16 *)block); s1 += stride; s2 += stride; block += 8; } }

[[[[Adv]]]]: static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1, const uint8_t *s2, int stride) { int [[и]]; vec_u8 perm1 = vec_lvsl(0, s1); vec_u8 perm2 = vec_lvsl(0, s2); const vec_u8 zero = (const vec_u8)vec_splat_u8(0); vec_s16 shorts1, shorts2; for ([[и]] = 0; [[и]] < 4; [[и]]++) { vec_u8 pixl = vec_ld(0, s1); vec_u8 pixr = vec_ld(15, s1); vec_u8 bytes = vec_perm(pixl, pixr, perm1); shorts1 = (vec_s16)vec_mergeh(zero, bytes); pixl = vec_ld(0, s2); pixr = vec_ld(15, s2); bytes = vec_perm(pixl, pixr, perm2); shorts2 = (vec_s16)vec_mergeh(zero, bytes); shorts1 = vec_sub(shorts1, shorts2); vec_st(shorts1, 0, (vec_s16 *)block); s1 += stride; s2 += stride; block += 8; pixl = vec_ld(0, s1); pixr = vec_ld(15, s1); bytes = vec_perm(pixl, pixr, perm1); shorts1 = (vec_s16)vec_mergeh(zero, bytes); pixl = vec_ld(0, s2); pixr = vec_ld(15, s2); bytes = vec_perm(pixl, pixr, perm2); shorts2 = (vec_s16)vec_mergeh(zero, bytes); shorts1 = vec_sub(shorts1, shorts2); vec_st(shorts1, 0, (vec_s16 *)block); s1 += stride; s2 += stride; block += 8; } }
--------------------------------------------- Result 772 ---------------------------------------------
[[0 (24%)]] --> [[0 (68%)]] --> Socre: 0.6809732913970947

[[[[Adv]]]]: void esp_init(target_phys_addr_t espaddr, int it_shift, ESPDMAMemoryReadWriteFunc dma_memory_read, ESPDMAMemoryReadWriteFunc dma_memory_write, void *dma_opaque, qemu_irq [[irq]], qemu_irq *reset, qemu_irq *dma_enable) { DeviceState *dev; SysBusDevice *s; SysBusESPState *sysbus; ESPState *[[esp]]; dev = qdev_create(NULL, "esp"); sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev); [[esp]] = &sysbus->esp; [[esp]]->dma_memory_read = dma_memory_read; [[esp]]->dma_memory_write = dma_memory_write; [[esp]]->dma_opaque = dma_opaque; sysbus->it_shift = it_shift; [[esp]]->dma_enabled = 1; qdev_init_nofail(dev); s = sysbus_from_qdev(dev); sysbus_connect_irq(s, 0, [[irq]]); sysbus_mmio_map(s, 0, espaddr); *reset = qdev_get_gpio_in(dev, 0); *dma_enable = qdev_get_gpio_in(dev, 1); }

[[[[Adv]]]]: void esp_init(target_phys_addr_t espaddr, int it_shift, ESPDMAMemoryReadWriteFunc dma_memory_read, ESPDMAMemoryReadWriteFunc dma_memory_write, void *dma_opaque, qemu_irq [[vare]], qemu_irq *reset, qemu_irq *dma_enable) { DeviceState *dev; SysBusDevice *s; SysBusESPState *sysbus; ESPState *[[gispy]]; dev = qdev_create(NULL, "esp"); sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev); [[gispy]] = &sysbus->esp; [[gispy]]->dma_memory_read = dma_memory_read; [[gispy]]->dma_memory_write = dma_memory_write; [[gispy]]->dma_opaque = dma_opaque; sysbus->it_shift = it_shift; [[gispy]]->dma_enabled = 1; qdev_init_nofail(dev); s = sysbus_from_qdev(dev); sysbus_connect_irq(s, 0, [[vare]]); sysbus_mmio_map(s, 0, espaddr); *reset = qdev_get_gpio_in(dev, 0); *dma_enable = qdev_get_gpio_in(dev, 1); }
--------------------------------------------- Result 773 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void hds_free(AVFormatContext *s) { HDSContext *c = s->priv_data; int i, j; if (!c->streams) return; for (i = 0; i < s->nb_streams; i++) { OutputStream *os = &c->streams[i]; if (os->out) avio_close(os->out); os->out = NULL; if (os->ctx && os->ctx_inited) av_write_trailer(os->ctx); if (os->ctx && os->ctx->pb) av_free(os->ctx->pb); if (os->ctx) avformat_free_context(os->ctx); av_free(os->metadata); for (j = 0; j < os->nb_extra_packets; j++) av_free(os->extra_packets[j]); for (j = 0; j < os->nb_fragments; j++) av_free(os->fragments[j]); av_free(os->fragments); } av_freep(&c->streams); }
--------------------------------------------- Result 774 ---------------------------------------------
[[0 (64%)]] --> [[0 (6%)]] --> Socre: 0.9382600784301758

[[[[Adv]]]]: bool qio_task_propagate_error(QIOTask *task, Error **[[errp]]) { if (task->err) { error_propagate([[errp]], task->err); return "True" == "True"; } return "False" != "False"; }

[[[[Adv]]]]: bool qio_task_propagate_error(QIOTask *task, Error **[[irark]]) { if (task->err) { error_propagate([[irark]], task->err); return "True" == "True"; } return "False" != "False"; }
--------------------------------------------- Result 775 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void device_unparent(Object *obj) { DeviceState *dev = DEVICE(obj); BusState *bus; if (dev->realized) { object_property_set_bool(obj, "False" != "False", "realized", NULL); } while (dev->num_child_bus) { bus = QLIST_FIRST(&dev->child_bus); object_unparent(OBJECT(bus)); } if (dev->parent_bus) { bus_remove_child(dev->parent_bus, dev); object_unref(OBJECT(dev->parent_bus)); dev->parent_bus = NULL; } if (dev->pending_deleted_event) { g_assert(dev->canonical_path); qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path, &error_abort); g_free(dev->canonical_path); dev->canonical_path = NULL; } }
--------------------------------------------- Result 776 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 403 / 92 / 281 / 776:  29%|██▉       | 776/2690 [2:00:04<4:56:10,  9.28s/it][Succeeded / Failed / Skipped / Total] 403 / 92 / 281 / 776:  29%|██▉       | 777/2690 [2:00:27<4:56:34,  9.30s/it][Succeeded / Failed / Skipped / Total] 404 / 92 / 281 / 777:  29%|██▉       | 777/2690 [2:00:27<4:56:34,  9.30s/it][Succeeded / Failed / Skipped / Total] 404 / 92 / 281 / 777:  29%|██▉       | 778/2690 [2:00:37<4:56:26,  9.30s/it][Succeeded / Failed / Skipped / Total] 405 / 92 / 281 / 778:  29%|██▉       | 778/2690 [2:00:37<4:56:26,  9.30s/it][Succeeded / Failed / Skipped / Total] 405 / 92 / 281 / 778:  29%|██▉       | 779/2690 [2:00:51<4:56:29,  9.31s/it][Succeeded / Failed / Skipped / Total] 406 / 92 / 281 / 779:  29%|██▉       | 779/2690 [2:00:51<4:56:29,  9.31s/it][Succeeded / Failed / Skipped / Total] 406 / 92 / 281 / 779:  29%|██▉       | 780/2690 [2:00:52<4:55:59,  9.30s/it][Succeeded / Failed / Skipped / Total] 406 / 92 / 282 / 780:  29%|██▉       | 780/2690 [2:00:52<4:55:59,  9.30s/it][Succeeded / Failed / Skipped / Total] 406 / 92 / 282 / 780:  29%|██▉       | 781/2690 [2:01:08<4:56:07,  9.31s/it][[0 (6%)]] --> [[0 (55%)]] --> Socre: 0.5529072284698486

[[[[Adv]]]]: QBool *qbool_from_bool(bool value) { QBool *[[qb]]; [[qb]] = g_malloc(sizeof(*[[qb]])); [[qb]]->value = value; QOBJECT_INIT([[qb]], &qbool_type); return [[qb]]; }

[[[[Adv]]]]: QBool *qbool_from_bool(bool value) { QBool *[[bob]]; [[bob]] = g_malloc(sizeof(*[[bob]])); [[bob]]->value = value; QOBJECT_INIT([[bob]], &qbool_type); return [[bob]]; }
--------------------------------------------- Result 777 ---------------------------------------------
[[0 (46%)]] --> [[0 (79%)]] --> Socre: 0.7883598804473877

[[[[Adv]]]]: static void setup_rt_frame(int usig, struct emulated_sigaction *[[ka]], target_siginfo_t *info, target_sigset_t *set, CPUState *env) { struct rt_sigframe *frame = get_sigframe([[ka]], env, sizeof(*frame)); int err = 0; #if 0 if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame))) return 1; #endif __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err); __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err); err |= copy_siginfo_to_user(&frame->info, info); err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext)); err |= setup_sigcontext(&frame->uc.uc_mcontext, env, set->sig[0]); err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set)); if (err == 0) err = setup_return(env, [[ka]], &frame->retcode, frame, usig); if (err == 0) { env->regs[1] = (target_ulong)frame->pinfo; env->regs[2] = (target_ulong)frame->puc; } }

[[[[Adv]]]]: static void setup_rt_frame(int usig, struct emulated_sigaction *[[カ]], target_siginfo_t *info, target_sigset_t *set, CPUState *env) { struct rt_sigframe *frame = get_sigframe([[カ]], env, sizeof(*frame)); int err = 0; #if 0 if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame))) return 1; #endif __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err); __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err); err |= copy_siginfo_to_user(&frame->info, info); err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext)); err |= setup_sigcontext(&frame->uc.uc_mcontext, env, set->sig[0]); err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set)); if (err == 0) err = setup_return(env, [[カ]], &frame->retcode, frame, usig); if (err == 0) { env->regs[1] = (target_ulong)frame->pinfo; env->regs[2] = (target_ulong)frame->puc; } }
--------------------------------------------- Result 778 ---------------------------------------------
[[0 (95%)]] --> [[0 (46%)]] --> Socre: 0.5447824895381927

[[[[Adv]]]]: int ff_thread_get_buffer(AVCodecContext *[[avctx]], AVFrame *[[f]]) { PerThreadContext *[[p]] = [[avctx]]->thread_opaque; int *[[progress]], err; [[f]]->owner = [[avctx]]; ff_init_buffer_info([[avctx]], [[f]]); if (!([[avctx]]->active_thread_type&FF_THREAD_FRAME)) { [[f]]->thread_opaque = NULL; return [[avctx]]->get_buffer([[avctx]], [[f]]); } if ([[p]]->state != STATE_SETTING_UP && ([[avctx]]->codec->update_thread_context || (![[avctx]]->thread_safe_callbacks && [[avctx]]->get_buffer != avcodec_default_get_buffer))) { av_log([[avctx]], AV_LOG_ERROR, "get_buffer() cannot be called after ff_thread_finish_setup()\n"); return -1; } pthread_mutex_lock(&[[p]]->parent->buffer_mutex); [[f]]->thread_opaque = [[progress]] = allocate_progress([[p]]); if (![[progress]]) { pthread_mutex_unlock(&[[p]]->parent->buffer_mutex); return -1; } [[progress]][0] = [[progress]][1] = -1; if ([[avctx]]->thread_safe_callbacks || [[avctx]]->get_buffer == avcodec_default_get_buffer) { err = [[avctx]]->get_buffer([[avctx]], [[f]]); } else { [[p]]->requested_frame = [[f]]; [[p]]->state = STATE_GET_BUFFER; pthread_mutex_lock(&[[p]]->progress_mutex); pthread_cond_signal(&[[p]]->progress_cond); while ([[p]]->state != STATE_SETTING_UP) pthread_cond_wait(&[[p]]->progress_cond, &[[p]]->progress_mutex); err = [[p]]->result; pthread_mutex_unlock(&[[p]]->progress_mutex); if (![[avctx]]->codec->update_thread_context) ff_thread_finish_setup([[avctx]]); } pthread_mutex_unlock(&[[p]]->parent->buffer_mutex); return err; }

[[[[Adv]]]]: int ff_thread_get_buffer(AVCodecContext *[[anaco1]], AVFrame *[[all]]) { PerThreadContext *[[п]] = [[anaco1]]->thread_opaque; int *[[it]], err; [[all]]->owner = [[anaco1]]; ff_init_buffer_info([[anaco1]], [[all]]); if (!([[anaco1]]->active_thread_type&FF_THREAD_FRAME)) { [[all]]->thread_opaque = NULL; return [[anaco1]]->get_buffer([[anaco1]], [[all]]); } if ([[п]]->state != STATE_SETTING_UP && ([[anaco1]]->codec->update_thread_context || (![[anaco1]]->thread_safe_callbacks && [[anaco1]]->get_buffer != avcodec_default_get_buffer))) { av_log([[anaco1]], AV_LOG_ERROR, "get_buffer() cannot be called after ff_thread_finish_setup()\n"); return -1; } pthread_mutex_lock(&[[п]]->parent->buffer_mutex); [[all]]->thread_opaque = [[it]] = allocate_progress([[п]]); if (![[it]]) { pthread_mutex_unlock(&[[п]]->parent->buffer_mutex); return -1; } [[it]][0] = [[it]][1] = -1; if ([[anaco1]]->thread_safe_callbacks || [[anaco1]]->get_buffer == avcodec_default_get_buffer) { err = [[anaco1]]->get_buffer([[anaco1]], [[all]]); } else { [[п]]->requested_frame = [[all]]; [[п]]->state = STATE_GET_BUFFER; pthread_mutex_lock(&[[п]]->progress_mutex); pthread_cond_signal(&[[п]]->progress_cond); while ([[п]]->state != STATE_SETTING_UP) pthread_cond_wait(&[[п]]->progress_cond, &[[п]]->progress_mutex); err = [[п]]->result; pthread_mutex_unlock(&[[п]]->progress_mutex); if (![[anaco1]]->codec->update_thread_context) ff_thread_finish_setup([[anaco1]]); } pthread_mutex_unlock(&[[п]]->parent->buffer_mutex); return err; }
--------------------------------------------- Result 779 ---------------------------------------------
[[0 (83%)]] --> [[0 (47%)]] --> Socre: 0.5307689905166626

[[[[Adv]]]]: yuv2ya8_2_c(SwsContext *c, const int16_t *[[buf]][2], const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int [[dstW]], int yalpha, int uvalpha, int y) { int hasAlpha = abuf[0] && abuf[1]; const int16_t *buf0 = [[buf]][0], *buf1 = [[buf]][1], *abuf0 = hasAlpha ? abuf[0] : NULL, *abuf1 = hasAlpha ? abuf[1] : NULL; int yalpha1 = 4096 - yalpha; int [[i]]; for ([[i]] = 0; [[i]] < [[dstW]]; [[i]]++) { int Y = (buf0[[[i]] * 2] * yalpha1 + buf1[[[i]] * 2] * yalpha) >> 19; int A; Y = av_clip_uint8(Y); if (hasAlpha) { A = (abuf0[[[i]] * 2] * yalpha1 + abuf1[[[i]] * 2] * yalpha) >> 19; A = av_clip_uint8(A); } dest[[[i]] * 2 ] = Y; dest[[[i]] * 2 + 1] = hasAlpha ? A : 255; } }

[[[[Adv]]]]: yuv2ya8_2_c(SwsContext *c, const int16_t *[[bifo]][2], const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int [[deskne]], int yalpha, int uvalpha, int y) { int hasAlpha = abuf[0] && abuf[1]; const int16_t *buf0 = [[bifo]][0], *buf1 = [[bifo]][1], *abuf0 = hasAlpha ? abuf[0] : NULL, *abuf1 = hasAlpha ? abuf[1] : NULL; int yalpha1 = 4096 - yalpha; int [[family]]; for ([[family]] = 0; [[family]] < [[deskne]]; [[family]]++) { int Y = (buf0[[[family]] * 2] * yalpha1 + buf1[[[family]] * 2] * yalpha) >> 19; int A; Y = av_clip_uint8(Y); if (hasAlpha) { A = (abuf0[[[family]] * 2] * yalpha1 + abuf1[[[family]] * 2] * yalpha) >> 19; A = av_clip_uint8(A); } dest[[[family]] * 2 ] = Y; dest[[[family]] * 2 + 1] = hasAlpha ? A : 255; } }
--------------------------------------------- Result 780 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold void ff_wmv2_common_init(Wmv2Context * w){ MpegEncContext * const s= &w->s; ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA); ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB); }
--------------------------------------------- Result 781 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 407 / 92 / 282 / 781:  29%|██▉       | 781/2690 [2:01:08<4:56:07,  9.31s/it][Succeeded / Failed / Skipped / Total] 407 / 92 / 282 / 781:  29%|██▉       | 782/2690 [2:01:47<4:57:09,  9.34s/it][Succeeded / Failed / Skipped / Total] 408 / 92 / 282 / 782:  29%|██▉       | 782/2690 [2:01:47<4:57:09,  9.34s/it][Succeeded / Failed / Skipped / Total] 408 / 92 / 282 / 782:  29%|██▉       | 783/2690 [2:01:48<4:56:38,  9.33s/it][Succeeded / Failed / Skipped / Total] 408 / 92 / 283 / 783:  29%|██▉       | 783/2690 [2:01:48<4:56:38,  9.33s/it][Succeeded / Failed / Skipped / Total] 408 / 92 / 283 / 783:  29%|██▉       | 784/2690 [2:01:51<4:56:15,  9.33s/it][[0 (69%)]] --> [[0 (47%)]] --> Socre: 0.5257554650306702

[[[[Adv]]]]: static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index, uint64_t *buid, hwaddr *pio, hwaddr *mmio32, hwaddr *mmio64, unsigned n_dma, uint32_t *liobns, Error **[[errp]]) { const uint64_t base_buid = 0x800000020000000ULL; const int [[max_phbs]] = (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1; int i; QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON(([[max_phbs]] * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE); QEMU_BUILD_BUG_ON(([[max_phbs]] * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE); if (index >= [[max_phbs]]) { error_setg([[errp]], "\"index\" for PAPR PHB is too large (max %u)", [[max_phbs]] - 1); return; } *buid = base_buid + index; for (i = 0; i < n_dma; ++i) { liobns[i] = SPAPR_PCI_LIOBN(index, i); } *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE; *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE; *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE; }

[[[[Adv]]]]: static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index, uint64_t *buid, hwaddr *pio, hwaddr *mmio32, hwaddr *mmio64, unsigned n_dma, uint32_t *liobns, Error **[[theput]]) { const uint64_t base_buid = 0x800000020000000ULL; const int [[fygrambus]] = (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1; int i; QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON(([[fygrambus]] * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE); QEMU_BUILD_BUG_ON(([[fygrambus]] * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE); if (index >= [[fygrambus]]) { error_setg([[theput]], "\"index\" for PAPR PHB is too large (max %u)", [[fygrambus]] - 1); return; } *buid = base_buid + index; for (i = 0; i < n_dma; ++i) { liobns[i] = SPAPR_PCI_LIOBN(index, i); } *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE; *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE; *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE; }
--------------------------------------------- Result 782 ---------------------------------------------
[[0 (76%)]] --> [[0 (38%)]] --> Socre: 0.6215541362762451

[[[[Adv]]]]: static void ppc405ep_compute_clocks (ppc405ep_cpc_t *[[cpc]]) { uint32_t [[CPU_clk]], PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk; uint32_t [[UART0_clk]], UART1_clk; uint64_t VCO_out, PLL_out; int [[M]], D; VCO_out = 0; if (([[cpc]]->pllmr[1] & 0x80000000) && !([[cpc]]->pllmr[1] & 0x40000000)) { [[M]] = ((([[cpc]]->pllmr[1] >> 20) - 1) & 0xF) + 1; #ifdef DEBUG_CLOCKS_LL printf("FBMUL %01" PRIx32 " %d\n", ([[cpc]]->pllmr[1] >> 20) & 0xF, [[M]]); #endif D = 8 - (([[cpc]]->pllmr[1] >> 16) & 0x7); #ifdef DEBUG_CLOCKS_LL printf("FWDA %01" PRIx32 " %d\n", ([[cpc]]->pllmr[1] >> 16) & 0x7, D); #endif VCO_out = [[cpc]]->sysclk * [[M]] * D; if (VCO_out < 500000000UL || VCO_out > 1000000000UL) { printf("VCO out of range %" PRIu64 "\n", VCO_out); #if 0 [[cpc]]->pllmr[1] &= ~0x80000000; goto pll_bypass; #endif } PLL_out = VCO_out / D; [[cpc]]->boot |= 0x00000001; } else { #if 0 pll_bypass: #endif PLL_out = [[cpc]]->sysclk; if ([[cpc]]->pllmr[1] & 0x40000000) { [[cpc]]->boot &= ~0x00000001; } } D = (([[cpc]]->pllmr[0] >> 20) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("CCDV %01" PRIx32 " %d\n", ([[cpc]]->pllmr[0] >> 20) & 0x3, D); #endif [[CPU_clk]] = PLL_out / D; D = (([[cpc]]->pllmr[0] >> 16) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("CBDV %01" PRIx32 " %d\n", ([[cpc]]->pllmr[0] >> 16) & 0x3, D); #endif PLB_clk = [[CPU_clk]] / D; D = (([[cpc]]->pllmr[0] >> 12) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("OPDV %01" PRIx32 " %d\n", ([[cpc]]->pllmr[0] >> 12) & 0x3, D); #endif OPB_clk = PLB_clk / D; D = (([[cpc]]->pllmr[0] >> 8) & 0x3) + 2; #ifdef DEBUG_CLOCKS_LL printf("EPDV %01" PRIx32 " %d\n", ([[cpc]]->pllmr[0] >> 8) & 0x3, D); #endif EBC_clk = PLB_clk / D; D = (([[cpc]]->pllmr[0] >> 4) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("MPDV %01" PRIx32 " %d\n", ([[cpc]]->pllmr[0] >> 4) & 0x3, D); #endif MAL_clk = PLB_clk / D; D = ([[cpc]]->pllmr[0] & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("PPDV %01" PRIx32 " %d\n", [[cpc]]->pllmr[0] & 0x3, D); #endif PCI_clk = PLB_clk / D; D = (([[cpc]]->ucr - 1) & 0x7F) + 1; #ifdef DEBUG_CLOCKS_LL printf("U0DIV %01" PRIx32 " %d\n", [[cpc]]->ucr & 0x7F, D); #endif [[UART0_clk]] = PLL_out / D; D = ((([[cpc]]->ucr >> 8) - 1) & 0x7F) + 1; #ifdef DEBUG_CLOCKS_LL printf("U1DIV %01" PRIx32 " %d\n", ([[cpc]]->ucr >> 8) & 0x7F, D); #endif UART1_clk = PLL_out / D; #ifdef DEBUG_CLOCKS printf("Setup PPC405EP clocks - sysclk %" PRIu32 " VCO %" PRIu64 " PLL out %" PRIu64 " Hz\n", [[cpc]]->sysclk, VCO_out, PLL_out); printf("CPU %" PRIu32 " PLB %" PRIu32 " OPB %" PRIu32 " EBC %" PRIu32 " MAL %" PRIu32 " PCI %" PRIu32 " UART0 %" PRIu32 " UART1 %" PRIu32 "\n", [[CPU_clk]], PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk, [[UART0_clk]], UART1_clk); #endif clk_setup(&[[cpc]]->clk_setup[PPC405EP_CPU_CLK], [[CPU_clk]]); clk_setup(&[[cpc]]->clk_setup[PPC405EP_PLB_CLK], PLB_clk); clk_setup(&[[cpc]]->clk_setup[PPC405EP_OPB_CLK], OPB_clk); clk_setup(&[[cpc]]->clk_setup[PPC405EP_EBC_CLK], EBC_clk); clk_setup(&[[cpc]]->clk_setup[PPC405EP_MAL_CLK], MAL_clk); clk_setup(&[[cpc]]->clk_setup[PPC405EP_PCI_CLK], PCI_clk); clk_setup(&[[cpc]]->clk_setup[PPC405EP_UART0_CLK], [[UART0_clk]]); clk_setup(&[[cpc]]->clk_setup[PPC405EP_UART1_CLK], UART1_clk); }

[[[[Adv]]]]: static void ppc405ep_compute_clocks (ppc405ep_cpc_t *[[midi]]) { uint32_t [[8616proк]], PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk; uint32_t [[duct15wccx]], UART1_clk; uint64_t VCO_out, PLL_out; int [[rock]], D; VCO_out = 0; if (([[midi]]->pllmr[1] & 0x80000000) && !([[midi]]->pllmr[1] & 0x40000000)) { [[rock]] = ((([[midi]]->pllmr[1] >> 20) - 1) & 0xF) + 1; #ifdef DEBUG_CLOCKS_LL printf("FBMUL %01" PRIx32 " %d\n", ([[midi]]->pllmr[1] >> 20) & 0xF, [[rock]]); #endif D = 8 - (([[midi]]->pllmr[1] >> 16) & 0x7); #ifdef DEBUG_CLOCKS_LL printf("FWDA %01" PRIx32 " %d\n", ([[midi]]->pllmr[1] >> 16) & 0x7, D); #endif VCO_out = [[midi]]->sysclk * [[rock]] * D; if (VCO_out < 500000000UL || VCO_out > 1000000000UL) { printf("VCO out of range %" PRIu64 "\n", VCO_out); #if 0 [[midi]]->pllmr[1] &= ~0x80000000; goto pll_bypass; #endif } PLL_out = VCO_out / D; [[midi]]->boot |= 0x00000001; } else { #if 0 pll_bypass: #endif PLL_out = [[midi]]->sysclk; if ([[midi]]->pllmr[1] & 0x40000000) { [[midi]]->boot &= ~0x00000001; } } D = (([[midi]]->pllmr[0] >> 20) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("CCDV %01" PRIx32 " %d\n", ([[midi]]->pllmr[0] >> 20) & 0x3, D); #endif [[8616proк]] = PLL_out / D; D = (([[midi]]->pllmr[0] >> 16) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("CBDV %01" PRIx32 " %d\n", ([[midi]]->pllmr[0] >> 16) & 0x3, D); #endif PLB_clk = [[8616proк]] / D; D = (([[midi]]->pllmr[0] >> 12) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("OPDV %01" PRIx32 " %d\n", ([[midi]]->pllmr[0] >> 12) & 0x3, D); #endif OPB_clk = PLB_clk / D; D = (([[midi]]->pllmr[0] >> 8) & 0x3) + 2; #ifdef DEBUG_CLOCKS_LL printf("EPDV %01" PRIx32 " %d\n", ([[midi]]->pllmr[0] >> 8) & 0x3, D); #endif EBC_clk = PLB_clk / D; D = (([[midi]]->pllmr[0] >> 4) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("MPDV %01" PRIx32 " %d\n", ([[midi]]->pllmr[0] >> 4) & 0x3, D); #endif MAL_clk = PLB_clk / D; D = ([[midi]]->pllmr[0] & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("PPDV %01" PRIx32 " %d\n", [[midi]]->pllmr[0] & 0x3, D); #endif PCI_clk = PLB_clk / D; D = (([[midi]]->ucr - 1) & 0x7F) + 1; #ifdef DEBUG_CLOCKS_LL printf("U0DIV %01" PRIx32 " %d\n", [[midi]]->ucr & 0x7F, D); #endif [[duct15wccx]] = PLL_out / D; D = ((([[midi]]->ucr >> 8) - 1) & 0x7F) + 1; #ifdef DEBUG_CLOCKS_LL printf("U1DIV %01" PRIx32 " %d\n", ([[midi]]->ucr >> 8) & 0x7F, D); #endif UART1_clk = PLL_out / D; #ifdef DEBUG_CLOCKS printf("Setup PPC405EP clocks - sysclk %" PRIu32 " VCO %" PRIu64 " PLL out %" PRIu64 " Hz\n", [[midi]]->sysclk, VCO_out, PLL_out); printf("CPU %" PRIu32 " PLB %" PRIu32 " OPB %" PRIu32 " EBC %" PRIu32 " MAL %" PRIu32 " PCI %" PRIu32 " UART0 %" PRIu32 " UART1 %" PRIu32 "\n", [[8616proк]], PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk, [[duct15wccx]], UART1_clk); #endif clk_setup(&[[midi]]->clk_setup[PPC405EP_CPU_CLK], [[8616proк]]); clk_setup(&[[midi]]->clk_setup[PPC405EP_PLB_CLK], PLB_clk); clk_setup(&[[midi]]->clk_setup[PPC405EP_OPB_CLK], OPB_clk); clk_setup(&[[midi]]->clk_setup[PPC405EP_EBC_CLK], EBC_clk); clk_setup(&[[midi]]->clk_setup[PPC405EP_MAL_CLK], MAL_clk); clk_setup(&[[midi]]->clk_setup[PPC405EP_PCI_CLK], PCI_clk); clk_setup(&[[midi]]->clk_setup[PPC405EP_UART0_CLK], [[duct15wccx]]); clk_setup(&[[midi]]->clk_setup[PPC405EP_UART1_CLK], UART1_clk); }
--------------------------------------------- Result 783 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int ac3_decode_init(AVCodecContext *avctx) { AC3DecodeContext *s = avctx->priv_data; s->avctx = avctx; ff_ac3_common_init(); ac3_tables_init(); ff_mdct_init(&s->imdct_256, 8, 1, 1.0); ff_mdct_init(&s->imdct_512, 9, 1, 1.0); ff_kbd_window_init(s->window, 5.0, 256); dsputil_init(&s->dsp, avctx); ff_fmt_convert_init(&s->fmt_conv, avctx); av_lfg_init(&s->dith_state, 0); s->mul_bias = 32767.0f; if (avctx->channels > 0 && avctx->request_channels > 0 && avctx->request_channels < avctx->channels && avctx->request_channels <= 2) { avctx->channels = avctx->request_channels; } s->downmixed = 1; if (avctx->error_recognition >= FF_ER_CAREFUL) { s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE); if (!s->input_buffer) return AVERROR(ENOMEM); } avctx->sample_fmt = AV_SAMPLE_FMT_S16; return 0; }
--------------------------------------------- Result 784 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 409 / 92 / 283 / 784:  29%|██▉       | 784/2690 [2:01:51<4:56:15,  9.33s/it][Succeeded / Failed / Skipped / Total] 409 / 92 / 283 / 784:  29%|██▉       | 785/2690 [2:02:08<4:56:25,  9.34s/it][Succeeded / Failed / Skipped / Total] 410 / 92 / 283 / 785:  29%|██▉       | 785/2690 [2:02:08<4:56:25,  9.34s/it][Succeeded / Failed / Skipped / Total] 410 / 92 / 283 / 785:  29%|██▉       | 786/2690 [2:02:30<4:56:45,  9.35s/it][Succeeded / Failed / Skipped / Total] 410 / 93 / 283 / 786:  29%|██▉       | 786/2690 [2:02:30<4:56:45,  9.35s/it][Succeeded / Failed / Skipped / Total] 410 / 93 / 283 / 786:  29%|██▉       | 787/2690 [2:02:30<4:56:14,  9.34s/it][[0 (59%)]] --> [[0 (48%)]] --> Socre: 0.5205284357070923

[[[[Adv]]]]: void ff_mpeg1_encode_init(MpegEncContext *s) { static int done=0; common_init(s); if(!done){ int f_code; int [[mv]]; int i; done=1; init_rl(&rl_mpeg1); for(i=0; i<64; i++) { mpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i]; mpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i]; } init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len); for(i=-255; i<256; i++) { int adiff, index; int [[bits]], code; int diff=i; adiff = ABS(diff); if(diff<0) diff--; index = av_log2(2*adiff); [[bits]]= vlc_dc_lum_bits[index] + index; code= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1)); mpeg1_lum_dc_uni[i+255]= [[bits]] + (code<<8); [[bits]]= vlc_dc_chroma_bits[index] + index; code= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1)); mpeg1_chr_dc_uni[i+255]= [[bits]] + (code<<8); } mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) ); for(f_code=1; f_code<=MAX_FCODE; f_code++){ for([[mv]]=-MAX_MV; [[mv]]<=MAX_MV; [[mv]]++){ int len; if([[mv]]==0) len= mbMotionVectorTable[0][1]; else{ int val, bit_size, range, code; bit_size = f_code - 1; range = 1 << bit_size; val=[[mv]]; if (val < 0) val = -val; val--; code = (val >> bit_size) + 1; if(code<17){ len= mbMotionVectorTable[code][1] + 1 + bit_size; }else{ len= mbMotionVectorTable[16][1] + 2 + bit_size; } } mv_penalty[f_code][[[mv]]+MAX_MV]= len; } } for(f_code=MAX_FCODE; f_code>0; f_code--){ for([[mv]]=-(8<<f_code); [[mv]]<(8<<f_code); [[mv]]++){ fcode_tab[[[mv]]+MAX_MV]= f_code; } } } s->me.mv_penalty= mv_penalty; s->fcode_tab= fcode_tab; if(s->codec_id == CODEC_ID_MPEG1VIDEO){ s->min_qcoeff=-255; s->max_qcoeff= 255; }else{ s->min_qcoeff=-2047; s->max_qcoeff= 2047; } s->intra_ac_vlc_length= s->inter_ac_vlc_length= s->intra_ac_vlc_last_length= s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len; }

[[[[Adv]]]]: void ff_mpeg1_encode_init(MpegEncContext *s) { static int done=0; common_init(s); if(!done){ int f_code; int [[vc]]; int i; done=1; init_rl(&rl_mpeg1); for(i=0; i<64; i++) { mpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i]; mpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i]; } init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len); for(i=-255; i<256; i++) { int adiff, index; int [[pins]], code; int diff=i; adiff = ABS(diff); if(diff<0) diff--; index = av_log2(2*adiff); [[pins]]= vlc_dc_lum_bits[index] + index; code= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1)); mpeg1_lum_dc_uni[i+255]= [[pins]] + (code<<8); [[pins]]= vlc_dc_chroma_bits[index] + index; code= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1)); mpeg1_chr_dc_uni[i+255]= [[pins]] + (code<<8); } mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) ); for(f_code=1; f_code<=MAX_FCODE; f_code++){ for([[vc]]=-MAX_MV; [[vc]]<=MAX_MV; [[vc]]++){ int len; if([[vc]]==0) len= mbMotionVectorTable[0][1]; else{ int val, bit_size, range, code; bit_size = f_code - 1; range = 1 << bit_size; val=[[vc]]; if (val < 0) val = -val; val--; code = (val >> bit_size) + 1; if(code<17){ len= mbMotionVectorTable[code][1] + 1 + bit_size; }else{ len= mbMotionVectorTable[16][1] + 2 + bit_size; } } mv_penalty[f_code][[[vc]]+MAX_MV]= len; } } for(f_code=MAX_FCODE; f_code>0; f_code--){ for([[vc]]=-(8<<f_code); [[vc]]<(8<<f_code); [[vc]]++){ fcode_tab[[[vc]]+MAX_MV]= f_code; } } } s->me.mv_penalty= mv_penalty; s->fcode_tab= fcode_tab; if(s->codec_id == CODEC_ID_MPEG1VIDEO){ s->min_qcoeff=-255; s->max_qcoeff= 255; }else{ s->min_qcoeff=-2047; s->max_qcoeff= 2047; } s->intra_ac_vlc_length= s->inter_ac_vlc_length= s->intra_ac_vlc_last_length= s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len; }
--------------------------------------------- Result 785 ---------------------------------------------
[[0 (15%)]] --> [[0 (98%)]] --> Socre: 0.9768999814987183

[[[[Adv]]]]: static void count_frame_bits_fixed(AC3EncodeContext *s) { static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 }; int blk; int [[frame_bits]]; [[frame_bits]] = 16; if (s->eac3) { [[frame_bits]] += 35; [[frame_bits]] += 1 + 1 + 1; [[frame_bits]] += 2; [[frame_bits]] += 10; for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) [[frame_bits]] += 2 * s->fbw_channels + s->lfe_on; [[frame_bits]] += s->fbw_channels * 5; [[frame_bits]] += 10; [[frame_bits]]++; } else { [[frame_bits]] += 49; [[frame_bits]] += frame_bits_inc[s->channel_mode]; } for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { if (!s->eac3) { [[frame_bits]] += s->fbw_channels; [[frame_bits]] += s->fbw_channels; } [[frame_bits]]++; if (s->eac3) [[frame_bits]]++; if (!s->eac3) { [[frame_bits]] += 2 * s->fbw_channels; if (s->lfe_on) [[frame_bits]]++; [[frame_bits]]++; if (!blk) [[frame_bits]] += 2 + 2 + 2 + 2 + 3; } if (s->eac3) [[frame_bits]]++; if (!s->eac3) { [[frame_bits]]++; [[frame_bits]]++; } } [[frame_bits]]++; [[frame_bits]] += 1 + 16; s->frame_bits_fixed = [[frame_bits]]; }

[[[[Adv]]]]: static void count_frame_bits_fixed(AC3EncodeContext *s) { static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 }; int blk; int [[fieldfactordata]]; [[fieldfactordata]] = 16; if (s->eac3) { [[fieldfactordata]] += 35; [[fieldfactordata]] += 1 + 1 + 1; [[fieldfactordata]] += 2; [[fieldfactordata]] += 10; for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) [[fieldfactordata]] += 2 * s->fbw_channels + s->lfe_on; [[fieldfactordata]] += s->fbw_channels * 5; [[fieldfactordata]] += 10; [[fieldfactordata]]++; } else { [[fieldfactordata]] += 49; [[fieldfactordata]] += frame_bits_inc[s->channel_mode]; } for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { if (!s->eac3) { [[fieldfactordata]] += s->fbw_channels; [[fieldfactordata]] += s->fbw_channels; } [[fieldfactordata]]++; if (s->eac3) [[fieldfactordata]]++; if (!s->eac3) { [[fieldfactordata]] += 2 * s->fbw_channels; if (s->lfe_on) [[fieldfactordata]]++; [[fieldfactordata]]++; if (!blk) [[fieldfactordata]] += 2 + 2 + 2 + 2 + 3; } if (s->eac3) [[fieldfactordata]]++; if (!s->eac3) { [[fieldfactordata]]++; [[fieldfactordata]]++; } } [[fieldfactordata]]++; [[fieldfactordata]] += 1 + 16; s->frame_bits_fixed = [[fieldfactordata]]; }
--------------------------------------------- Result 786 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void tap_fd_set_offload(int [[fd]], int [[csum]], int [[tso4]], int tso6, int [[ecn]], int ufo) { unsigned int [[offload]] = 0; if ([[csum]]) { [[offload]] |= TUN_F_CSUM; if ([[tso4]]) [[offload]] |= TUN_F_TSO4; if (tso6) [[offload]] |= TUN_F_TSO6; if (([[tso4]] || tso6) && [[ecn]]) [[offload]] |= TUN_F_TSO_ECN; if (ufo) [[offload]] |= TUN_F_UFO; if (ioctl([[fd]], TUNSETOFFLOAD, [[offload]]) != 0) { [[offload]] &= ~TUN_F_UFO; if (ioctl([[fd]], TUNSETOFFLOAD, [[offload]]) != 0) { fprintf(stderr, "TUNSETOFFLOAD ioctl() failed: %s\n", strerror(errno));

[[[[Adv]]]]: void tap_fd_set_offload(int [[faд]], int [[cnu]], int [[tvo2]], int tso6, int [[ipx]], int ufo) { unsigned int [[athol]] = 0; if ([[cnu]]) { [[athol]] |= TUN_F_CSUM; if ([[tvo2]]) [[athol]] |= TUN_F_TSO4; if (tso6) [[athol]] |= TUN_F_TSO6; if (([[tvo2]] || tso6) && [[ipx]]) [[athol]] |= TUN_F_TSO_ECN; if (ufo) [[athol]] |= TUN_F_UFO; if (ioctl([[faд]], TUNSETOFFLOAD, [[athol]]) != 0) { [[athol]] &= ~TUN_F_UFO; if (ioctl([[faд]], TUNSETOFFLOAD, [[athol]]) != 0) { fprintf(stderr, "TUNSETOFFLOAD ioctl() failed: %s\n", strerror(errno));
--------------------------------------------- Result 787 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 411 / 93 / 283 / 787:  29%|██▉       | 787/2690 [2:02:30<4:56:14,  9.34s/it][Succeeded / Failed / Skipped / Total] 411 / 93 / 283 / 787:  29%|██▉       | 788/2690 [2:02:31<4:55:44,  9.33s/it][Succeeded / Failed / Skipped / Total] 411 / 93 / 284 / 788:  29%|██▉       | 788/2690 [2:02:31<4:55:44,  9.33s/it][Succeeded / Failed / Skipped / Total] 411 / 93 / 284 / 788:  29%|██▉       | 789/2690 [2:02:31<4:55:13,  9.32s/it][Succeeded / Failed / Skipped / Total] 411 / 93 / 285 / 789:  29%|██▉       | 789/2690 [2:02:31<4:55:13,  9.32s/it][Succeeded / Failed / Skipped / Total] 411 / 93 / 285 / 789:  29%|██▉       | 790/2690 [2:02:33<4:54:45,  9.31s/it][Succeeded / Failed / Skipped / Total] 412 / 93 / 285 / 790:  29%|██▉       | 790/2690 [2:02:33<4:54:45,  9.31s/it][Succeeded / Failed / Skipped / Total] 412 / 93 / 285 / 790:  29%|██▉       | 791/2690 [2:02:33<4:54:15,  9.30s/it][Succeeded / Failed / Skipped / Total] 412 / 93 / 286 / 791:  29%|██▉       | 791/2690 [2:02:33<4:54:15,  9.30s/it][Succeeded / Failed / Skipped / Total] 412 / 93 / 286 / 791:  29%|██▉       | 792/2690 [2:02:53<4:54:29,  9.31s/it][Succeeded / Failed / Skipped / Total] 413 / 93 / 286 / 792:  29%|██▉       | 792/2690 [2:02:53<4:54:29,  9.31s/it][Succeeded / Failed / Skipped / Total] 413 / 93 / 286 / 792:  29%|██▉       | 793/2690 [2:03:09<4:54:38,  9.32s/it][[0 (1%)]] --> [[0 (86%)]] --> Socre: 0.8582414388656616

[[[[Adv]]]]: static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *[[h]]) { const unsigned int index_a = 52 + qp + [[h]]->slice_alpha_c0_offset; const int [[alpha]] = alpha_table[index_a]; const int beta = (beta_table+52)[qp + [[h]]->slice_beta_offset]; if ([[alpha]] ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[index_a][bS[0]]; tc[1] = tc0_table[index_a][bS[1]]; tc[2] = tc0_table[index_a][bS[2]]; tc[3] = tc0_table[index_a][bS[3]]; [[h]]->s.dsp.h264_h_loop_filter_luma(pix, stride, [[alpha]], beta, tc); } else { [[h]]->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, [[alpha]], beta); } }

[[[[Adv]]]]: static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *[[frame]]) { const unsigned int index_a = 52 + qp + [[frame]]->slice_alpha_c0_offset; const int [[α]] = alpha_table[index_a]; const int beta = (beta_table+52)[qp + [[frame]]->slice_beta_offset]; if ([[α]] ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[index_a][bS[0]]; tc[1] = tc0_table[index_a][bS[1]]; tc[2] = tc0_table[index_a][bS[2]]; tc[3] = tc0_table[index_a][bS[3]]; [[frame]]->s.dsp.h264_h_loop_filter_luma(pix, stride, [[α]], beta, tc); } else { [[frame]]->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, [[α]], beta); } }
--------------------------------------------- Result 788 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int main() { int rd, rt, dsp; int result, resultdsp; rt = 0x12345678; result = 0xA000C000; resultdsp = 1; __asm ("shll.ph %0, %2, 0x0B\n\t" "rddsp %1\n\t" : "=r"(rd), "=r"(dsp) : "r"(rt) ); dsp = (dsp >> 22) & 0x01; assert(dsp == resultdsp); assert(rd == result); return 0; }
--------------------------------------------- Result 789 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor) { int count, x; uint8_t *out; out = outbuf; for(x = 0; x < w; x += count) { if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) { if(out + bpp + 1 > outbuf + out_size) return -1; *out++ = (count ^ xor) + add; memcpy(out, ptr, bpp); out += bpp; } else { count = count_pixels(ptr, w-x, bpp, 0); *out++ = count - 1; if(out + bpp*count > outbuf + out_size) return -1; memcpy(out, ptr, bpp * count); out += bpp * count; } ptr += count * bpp; } return out - outbuf; }
--------------------------------------------- Result 790 ---------------------------------------------
[[0 (8%)]] --> [[0 (98%)]] --> Socre: 0.9842098951339722

[[[[Adv]]]]: int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, uint8_t *buf, int buf_size) { int [[ret]]; *frame_size_ptr= 0; if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){ [[ret]] = avctx->codec->decode(avctx, samples, frame_size_ptr, buf, buf_size); avctx->frame_number++; }else [[ret]]= 0; return [[ret]]; }

[[[[Adv]]]]: int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, uint8_t *buf, int buf_size) { int [[onτ]]; *frame_size_ptr= 0; if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){ [[onτ]] = avctx->codec->decode(avctx, samples, frame_size_ptr, buf, buf_size); avctx->frame_number++; }else [[onτ]]= 0; return [[onτ]]; }
--------------------------------------------- Result 791 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int vm_stop(RunState state) { if (qemu_in_vcpu_thread()) { qemu_system_vmstop_request(state); cpu_stop_current(); return 0; } return do_vm_stop(state); }
--------------------------------------------- Result 792 ---------------------------------------------
[[0 (63%)]] --> [[0 (42%)]] --> Socre: 0.5757775008678436

[[[[Adv]]]]: static int vdpau_frames_init(AVHWFramesContext *ctx) { VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv; VDPAUFramesContext *priv = ctx->internal->priv; int [[i]]; switch (ctx->sw_format) { case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break; case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break; case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break; default: av_log(ctx, AV_LOG_ERROR, "Unsupported data layout: %s\n", av_get_pix_fmt_name(ctx->sw_format)); return AVERROR(ENOSYS); } for ([[i]] = 0; [[i]] < FF_ARRAY_ELEMS(vdpau_pix_fmts); [[i]]++) { if (vdpau_pix_fmts[[[i]]].chroma_type == priv->chroma_type) { priv->chroma_idx = [[i]]; priv->pix_fmts = device_priv->pix_fmts[[[i]]]; priv->nb_pix_fmts = device_priv->nb_pix_fmts[[[i]]]; break; } } if (!priv->pix_fmts) { av_log(ctx, AV_LOG_ERROR, "Unsupported chroma type: %d\n", priv->chroma_type); return AVERROR(ENOSYS); } if (!ctx->pool) { ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx, vdpau_pool_alloc, NULL); if (!ctx->internal->pool_internal) return AVERROR(ENOMEM); } priv->get_data = device_priv->get_data; priv->put_data = device_priv->put_data; return 0; }

[[[[Adv]]]]: static int vdpau_frames_init(AVHWFramesContext *ctx) { VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv; VDPAUFramesContext *priv = ctx->internal->priv; int [[clock]]; switch (ctx->sw_format) { case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break; case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break; case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break; default: av_log(ctx, AV_LOG_ERROR, "Unsupported data layout: %s\n", av_get_pix_fmt_name(ctx->sw_format)); return AVERROR(ENOSYS); } for ([[clock]] = 0; [[clock]] < FF_ARRAY_ELEMS(vdpau_pix_fmts); [[clock]]++) { if (vdpau_pix_fmts[[[clock]]].chroma_type == priv->chroma_type) { priv->chroma_idx = [[clock]]; priv->pix_fmts = device_priv->pix_fmts[[[clock]]]; priv->nb_pix_fmts = device_priv->nb_pix_fmts[[[clock]]]; break; } } if (!priv->pix_fmts) { av_log(ctx, AV_LOG_ERROR, "Unsupported chroma type: %d\n", priv->chroma_type); return AVERROR(ENOSYS); } if (!ctx->pool) { ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx, vdpau_pool_alloc, NULL); if (!ctx->internal->pool_internal) return AVERROR(ENOMEM); } priv->get_data = device_priv->get_data; priv->put_data = device_priv->put_data; return 0; }
--------------------------------------------- Result 793 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 414 / 93 / 286 / 793:  29%|██▉       | 793/2690 [2:03:09<4:54:38,  9.32s/it][Succeeded / Failed / Skipped / Total] 414 / 93 / 286 / 793:  30%|██▉       | 794/2690 [2:03:13<4:54:13,  9.31s/it][[0 (54%)]] --> [[0 (49%)]] --> Socre: 0.5075790286064148

[[[[Adv]]]]: void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb, int [[mb_x]], int mb_y, int layout) { VP8Macroblock *mb_edge[3] = { 0 , mb - 1 , 0 }; enum { CNT_ZERO, CNT_NEAREST, [[CNT_NEAR]], CNT_SPLITMV }; enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT }; int idx = CNT_ZERO; int [[cur_sign_bias]] = s->sign_bias[mb->ref_frame]; int8_t *sign_bias = s->sign_bias; VP56mv near_mv[4]; uint8_t cnt[4] = { 0 }; VP56RangeCoder *c = &s->c; if (!layout) { mb_edge[0] = mb + 2; mb_edge[2] = mb + 1; } else { mb_edge[0] = mb - s->mb_width - 1; mb_edge[2] = mb - s->mb_width - 2; } AV_ZERO32(&near_mv[0]); AV_ZERO32(&near_mv[1]); AV_ZERO32(&near_mv[2]); #define MV_EDGE_CHECK(n) \ { \ VP8Macroblock *edge = mb_edge[n]; \ int edge_ref = edge->ref_frame; \ if (edge_ref != VP56_FRAME_CURRENT) { \ uint32_t mv = AV_RN32A(&edge->mv); \ if (mv) { \ if (cur_sign_bias != sign_bias[edge_ref]) { \ \ mv = ~mv; \ mv = ((mv & 0x7fff7fff) + \ 0x00010001) ^ (mv & 0x80008000); \ } \ if (!n || mv != AV_RN32A(&near_mv[idx])) \ AV_WN32A(&near_mv[++idx], mv); \ cnt[idx] += 1 + (n != 2); \ } else \ cnt[CNT_ZERO] += 1 + (n != 2); \ } \ } MV_EDGE_CHECK(0) MV_EDGE_CHECK(1) MV_EDGE_CHECK(2) mb->partitioning = VP8_SPLITMVMODE_NONE; if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) { mb->mode = VP8_MVMODE_MV; if (cnt[CNT_SPLITMV] && AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT])) cnt[CNT_NEAREST] += 1; if (cnt[[[CNT_NEAR]]] > cnt[CNT_NEAREST]) { FFSWAP(uint8_t, cnt[CNT_NEAREST], cnt[[[CNT_NEAR]]]); FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[[[CNT_NEAR]]]); } if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) { if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[[[CNT_NEAR]]]][2])) { clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]); cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode == VP8_MVMODE_SPLIT) + (mb_edge[VP8_EDGE_TOP]->mode == VP8_MVMODE_SPLIT)) * 2 + (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT); if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) { mb->mode = VP8_MVMODE_SPLIT; mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1]; } else { mb->mv.y += vp8_read_mv_component(c, s->prob->mvc[0]); mb->mv.x += vp8_read_mv_component(c, s->prob->mvc[1]); mb->bmv[0] = mb->mv; } } else { clamp_mv(s, &mb->mv, &near_mv[[[CNT_NEAR]]]); mb->bmv[0] = mb->mv; } } else { clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]); mb->bmv[0] = mb->mv; } } else { mb->mode = VP8_MVMODE_ZERO; AV_ZERO32(&mb->mv); mb->bmv[0] = mb->mv; } }

[[[[Adv]]]]: void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb, int [[mibyj]], int mb_y, int layout) { VP8Macroblock *mb_edge[3] = { 0 , mb - 1 , 0 }; enum { CNT_ZERO, CNT_NEAREST, [[pvtt_second]], CNT_SPLITMV }; enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT }; int idx = CNT_ZERO; int [[vrar16toefulis]] = s->sign_bias[mb->ref_frame]; int8_t *sign_bias = s->sign_bias; VP56mv near_mv[4]; uint8_t cnt[4] = { 0 }; VP56RangeCoder *c = &s->c; if (!layout) { mb_edge[0] = mb + 2; mb_edge[2] = mb + 1; } else { mb_edge[0] = mb - s->mb_width - 1; mb_edge[2] = mb - s->mb_width - 2; } AV_ZERO32(&near_mv[0]); AV_ZERO32(&near_mv[1]); AV_ZERO32(&near_mv[2]); #define MV_EDGE_CHECK(n) \ { \ VP8Macroblock *edge = mb_edge[n]; \ int edge_ref = edge->ref_frame; \ if (edge_ref != VP56_FRAME_CURRENT) { \ uint32_t mv = AV_RN32A(&edge->mv); \ if (mv) { \ if (cur_sign_bias != sign_bias[edge_ref]) { \ \ mv = ~mv; \ mv = ((mv & 0x7fff7fff) + \ 0x00010001) ^ (mv & 0x80008000); \ } \ if (!n || mv != AV_RN32A(&near_mv[idx])) \ AV_WN32A(&near_mv[++idx], mv); \ cnt[idx] += 1 + (n != 2); \ } else \ cnt[CNT_ZERO] += 1 + (n != 2); \ } \ } MV_EDGE_CHECK(0) MV_EDGE_CHECK(1) MV_EDGE_CHECK(2) mb->partitioning = VP8_SPLITMVMODE_NONE; if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) { mb->mode = VP8_MVMODE_MV; if (cnt[CNT_SPLITMV] && AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT])) cnt[CNT_NEAREST] += 1; if (cnt[[[pvtt_second]]] > cnt[CNT_NEAREST]) { FFSWAP(uint8_t, cnt[CNT_NEAREST], cnt[[[pvtt_second]]]); FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[[[pvtt_second]]]); } if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) { if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[[[pvtt_second]]]][2])) { clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]); cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode == VP8_MVMODE_SPLIT) + (mb_edge[VP8_EDGE_TOP]->mode == VP8_MVMODE_SPLIT)) * 2 + (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT); if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) { mb->mode = VP8_MVMODE_SPLIT; mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1]; } else { mb->mv.y += vp8_read_mv_component(c, s->prob->mvc[0]); mb->mv.x += vp8_read_mv_component(c, s->prob->mvc[1]); mb->bmv[0] = mb->mv; } } else { clamp_mv(s, &mb->mv, &near_mv[[[pvtt_second]]]); mb->bmv[0] = mb->mv; } } else { clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]); mb->bmv[0] = mb->mv; } } else { mb->mode = VP8_MVMODE_ZERO; AV_ZERO32(&mb->mv); mb->bmv[0] = mb->mv; } }
--------------------------------------------- Result 794 ---------------------------------------------
[[0 (46%)]] --> [[0 (66%)]] --> Socre: 0.663224995136261

[[[[Adv]]]]: static int dca_decode_frame(AVCodecContext *[[avctx]], void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int lfe_samples; int num_core_channels = 0; int i, ret; float **samples_flt; DCAContext *s = [[avctx]]->priv_data; int channels, full_channels; int core_ss_end; s->xch_present = 0; s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer, DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE); if (s->dca_buffer_size == AVERROR_INVALIDDATA) { av_log([[avctx]], AV_LOG_ERROR, "Not a valid DCA frame\n"); return AVERROR_INVALIDDATA; } init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8); if ((ret = dca_parse_frame_header(s)) < 0) { return ret; } [[avctx]]->sample_rate = s->sample_rate; [[avctx]]->bit_rate = s->bit_rate; s->profile = FF_PROFILE_DTS; for (i = 0; i < (s->sample_blocks / 8); i++) { if ((ret = dca_decode_block(s, 0, i))) { av_log([[avctx]], AV_LOG_ERROR, "error decoding block\n"); return ret; } } num_core_channels = s->prim_channels; if (s->ext_coding) s->core_ext_mask = dca_ext_audio_descr_mask[s->ext_descr]; else s->core_ext_mask = 0; core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8; if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) { s->core_ext_mask = FFMAX(s->core_ext_mask, 0); skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31); while (core_ss_end - get_bits_count(&s->gb) >= 32) { uint32_t bits = get_bits_long(&s->gb, 32); switch (bits) { case 0x5a5a5a5a: { int ext_amode, xch_fsize; s->xch_base_channel = s->prim_channels; xch_fsize = show_bits(&s->gb, 10); if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) && (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1)) continue; skip_bits(&s->gb, 10); s->core_ext_mask |= DCA_EXT_XCH; if ((ext_amode = get_bits(&s->gb, 4)) != 1) { av_log([[avctx]], AV_LOG_ERROR, "XCh extension amode %d not" " supported!\n", ext_amode); continue; } dca_parse_audio_coding_header(s, s->xch_base_channel); for (i = 0; i < (s->sample_blocks / 8); i++) if ((ret = dca_decode_block(s, s->xch_base_channel, i))) { av_log([[avctx]], AV_LOG_ERROR, "error decoding XCh extension\n"); continue; } s->xch_present = 1; break; } case 0x47004a03: s->core_ext_mask |= DCA_EXT_XXCH; break; case 0x1d95f262: { int fsize96 = show_bits(&s->gb, 12) + 1; if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96) continue; av_log([[avctx]], AV_LOG_DEBUG, "X96 extension found at %d bits\n", get_bits_count(&s->gb)); skip_bits(&s->gb, 12); av_log([[avctx]], AV_LOG_DEBUG, "FSIZE96 = %d bytes\n", fsize96); av_log([[avctx]], AV_LOG_DEBUG, "REVNO = %d\n", get_bits(&s->gb, 4)); s->core_ext_mask |= DCA_EXT_X96; break; } } skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31); } } else { skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb)); } if (s->core_ext_mask & DCA_EXT_X96) s->profile = FF_PROFILE_DTS_96_24; else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH)) s->profile = FF_PROFILE_DTS_ES; if (s->dca_buffer_size - s->frame_size > 32 && get_bits_long(&s->gb, 32) == DCA_HD_MARKER) dca_exss_parse_header(s); [[avctx]]->profile = s->profile; full_channels = channels = s->prim_channels + !!s->lfe; if (s->amode < 16) { [[avctx]]->channel_layout = dca_core_channel_layout[s->amode]; if (s->prim_channels + !!s->lfe > 2 && [[avctx]]->request_channel_layout == AV_CH_LAYOUT_STEREO) { s->xch_disable = 1; } #if FF_API_REQUEST_CHANNELS FF_DISABLE_DEPRECATION_WARNINGS if (s->xch_present && !s->xch_disable && (![[avctx]]->request_channels || [[avctx]]->request_channels > num_core_channels + !!s->lfe)) { FF_ENABLE_DEPRECATION_WARNINGS #else if (s->xch_present && !s->xch_disable) { #endif avctx->channel_layout |= AV_CH_BACK_CENTER; if (s->lfe) { [[avctx]]->channel_layout |= AV_CH_LOW_FREQUENCY; s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode]; } else { s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode]; } } else { channels = num_core_channels + !!s->lfe; s->xch_present = 0; if (s->lfe) { [[avctx]]->channel_layout |= AV_CH_LOW_FREQUENCY; s->channel_order_tab = dca_channel_reorder_lfe[s->amode]; } else s->channel_order_tab = dca_channel_reorder_nolfe[s->amode]; } if (channels > !!s->lfe && s->channel_order_tab[channels - 1 - !!s->lfe] < 0) return AVERROR_INVALIDDATA; if (s->prim_channels + !!s->lfe > 2 && [[avctx]]->request_channel_layout == AV_CH_LAYOUT_STEREO) { channels = 2; s->output = s->prim_channels == 2 ? s->amode : DCA_STEREO; [[avctx]]->channel_layout = AV_CH_LAYOUT_STEREO; if (s->core_downmix && (s->core_downmix_amode == DCA_STEREO || s->core_downmix_amode == DCA_STEREO_TOTAL)) { int sign, code; for (i = 0; i < s->prim_channels + !!s->lfe; i++) { sign = s->core_downmix_codes[i][0] & 0x100 ? 1 : -1; code = s->core_downmix_codes[i][0] & 0x0FF; s->downmix_coef[i][0] = (!code ? 0.0f : sign * dca_dmixtable[code - 1]); sign = s->core_downmix_codes[i][1] & 0x100 ? 1 : -1; code = s->core_downmix_codes[i][1] & 0x0FF; s->downmix_coef[i][1] = (!code ? 0.0f : sign * dca_dmixtable[code - 1]); } s->output = s->core_downmix_amode; } else { int am = s->amode & DCA_CHANNEL_MASK; if (am >= FF_ARRAY_ELEMS(dca_default_coeffs)) { av_log(s->avctx, AV_LOG_ERROR, "Invalid channel mode %d\n", am); return AVERROR_INVALIDDATA; } if (s->prim_channels + !!s->lfe > FF_ARRAY_ELEMS(dca_default_coeffs[0])) { avpriv_request_sample(s->avctx, "Downmixing %d channels", s->prim_channels + !!s->lfe); return AVERROR_PATCHWELCOME; } for (i = 0; i < s->prim_channels + !!s->lfe; i++) { s->downmix_coef[i][0] = dca_default_coeffs[am][i][0]; s->downmix_coef[i][1] = dca_default_coeffs[am][i][1]; } } av_dlog(s->avctx, "Stereo downmix coeffs:\n"); for (i = 0; i < s->prim_channels + !!s->lfe; i++) { av_dlog(s->avctx, "L, input channel %d = %f\n", i, s->downmix_coef[i][0]); av_dlog(s->avctx, "R, input channel %d = %f\n", i, s->downmix_coef[i][1]); } av_dlog(s->avctx, "\n"); } } else { av_log([[avctx]], AV_LOG_ERROR, "Non standard configuration %d !\n", s->amode); return AVERROR_INVALIDDATA; } [[avctx]]->channels = channels; frame->nb_samples = 256 * (s->sample_blocks / 8); if ((ret = ff_get_buffer([[avctx]], frame, 0)) < 0) { av_log([[avctx]], AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } samples_flt = (float **)frame->extended_data; if ([[avctx]]->channels < full_channels) { ret = av_samples_get_buffer_size(NULL, full_channels - channels, frame->nb_samples, [[avctx]]->sample_fmt, 0); if (ret < 0) return ret; av_fast_malloc(&s->extra_channels_buffer, &s->extra_channels_buffer_size, ret); if (!s->extra_channels_buffer) return AVERROR(ENOMEM); ret = av_samples_fill_arrays((uint8_t **)s->extra_channels, NULL, s->extra_channels_buffer, full_channels - channels, frame->nb_samples, [[avctx]]->sample_fmt, 0); if (ret < 0) return ret; } for (i = 0; i < (s->sample_blocks / 8); i++) { int ch; for (ch = 0; ch < channels; ch++) s->samples_chanptr[ch] = samples_flt[ch] + i * 256; for (; ch < full_channels; ch++) s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256; dca_filter_channels(s, i); if ((s->source_pcm_res & 1) && s->xch_present) { float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]]; float *lt_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]]; float *rt_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]]; s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256); s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256); } } lfe_samples = 2 * s->lfe * (s->sample_blocks / 8); for (i = 0; i < 2 * s->lfe * 4; i++) s->lfe_data[i] = s->lfe_data[i + lfe_samples]; ret = ff_side_data_update_matrix_encoding(frame, (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ? AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE); if (ret < 0) return ret; *got_frame_ptr = 1; return buf_size; }

[[[[Adv]]]]: static int dca_decode_frame(AVCodecContext *[[eaglesp2]], void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int lfe_samples; int num_core_channels = 0; int i, ret; float **samples_flt; DCAContext *s = [[eaglesp2]]->priv_data; int channels, full_channels; int core_ss_end; s->xch_present = 0; s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer, DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE); if (s->dca_buffer_size == AVERROR_INVALIDDATA) { av_log([[eaglesp2]], AV_LOG_ERROR, "Not a valid DCA frame\n"); return AVERROR_INVALIDDATA; } init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8); if ((ret = dca_parse_frame_header(s)) < 0) { return ret; } [[eaglesp2]]->sample_rate = s->sample_rate; [[eaglesp2]]->bit_rate = s->bit_rate; s->profile = FF_PROFILE_DTS; for (i = 0; i < (s->sample_blocks / 8); i++) { if ((ret = dca_decode_block(s, 0, i))) { av_log([[eaglesp2]], AV_LOG_ERROR, "error decoding block\n"); return ret; } } num_core_channels = s->prim_channels; if (s->ext_coding) s->core_ext_mask = dca_ext_audio_descr_mask[s->ext_descr]; else s->core_ext_mask = 0; core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8; if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) { s->core_ext_mask = FFMAX(s->core_ext_mask, 0); skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31); while (core_ss_end - get_bits_count(&s->gb) >= 32) { uint32_t bits = get_bits_long(&s->gb, 32); switch (bits) { case 0x5a5a5a5a: { int ext_amode, xch_fsize; s->xch_base_channel = s->prim_channels; xch_fsize = show_bits(&s->gb, 10); if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) && (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1)) continue; skip_bits(&s->gb, 10); s->core_ext_mask |= DCA_EXT_XCH; if ((ext_amode = get_bits(&s->gb, 4)) != 1) { av_log([[eaglesp2]], AV_LOG_ERROR, "XCh extension amode %d not" " supported!\n", ext_amode); continue; } dca_parse_audio_coding_header(s, s->xch_base_channel); for (i = 0; i < (s->sample_blocks / 8); i++) if ((ret = dca_decode_block(s, s->xch_base_channel, i))) { av_log([[eaglesp2]], AV_LOG_ERROR, "error decoding XCh extension\n"); continue; } s->xch_present = 1; break; } case 0x47004a03: s->core_ext_mask |= DCA_EXT_XXCH; break; case 0x1d95f262: { int fsize96 = show_bits(&s->gb, 12) + 1; if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96) continue; av_log([[eaglesp2]], AV_LOG_DEBUG, "X96 extension found at %d bits\n", get_bits_count(&s->gb)); skip_bits(&s->gb, 12); av_log([[eaglesp2]], AV_LOG_DEBUG, "FSIZE96 = %d bytes\n", fsize96); av_log([[eaglesp2]], AV_LOG_DEBUG, "REVNO = %d\n", get_bits(&s->gb, 4)); s->core_ext_mask |= DCA_EXT_X96; break; } } skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31); } } else { skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb)); } if (s->core_ext_mask & DCA_EXT_X96) s->profile = FF_PROFILE_DTS_96_24; else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH)) s->profile = FF_PROFILE_DTS_ES; if (s->dca_buffer_size - s->frame_size > 32 && get_bits_long(&s->gb, 32) == DCA_HD_MARKER) dca_exss_parse_header(s); [[eaglesp2]]->profile = s->profile; full_channels = channels = s->prim_channels + !!s->lfe; if (s->amode < 16) { [[eaglesp2]]->channel_layout = dca_core_channel_layout[s->amode]; if (s->prim_channels + !!s->lfe > 2 && [[eaglesp2]]->request_channel_layout == AV_CH_LAYOUT_STEREO) { s->xch_disable = 1; } #if FF_API_REQUEST_CHANNELS FF_DISABLE_DEPRECATION_WARNINGS if (s->xch_present && !s->xch_disable && (![[eaglesp2]]->request_channels || [[eaglesp2]]->request_channels > num_core_channels + !!s->lfe)) { FF_ENABLE_DEPRECATION_WARNINGS #else if (s->xch_present && !s->xch_disable) { #endif avctx->channel_layout |= AV_CH_BACK_CENTER; if (s->lfe) { [[eaglesp2]]->channel_layout |= AV_CH_LOW_FREQUENCY; s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode]; } else { s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode]; } } else { channels = num_core_channels + !!s->lfe; s->xch_present = 0; if (s->lfe) { [[eaglesp2]]->channel_layout |= AV_CH_LOW_FREQUENCY; s->channel_order_tab = dca_channel_reorder_lfe[s->amode]; } else s->channel_order_tab = dca_channel_reorder_nolfe[s->amode]; } if (channels > !!s->lfe && s->channel_order_tab[channels - 1 - !!s->lfe] < 0) return AVERROR_INVALIDDATA; if (s->prim_channels + !!s->lfe > 2 && [[eaglesp2]]->request_channel_layout == AV_CH_LAYOUT_STEREO) { channels = 2; s->output = s->prim_channels == 2 ? s->amode : DCA_STEREO; [[eaglesp2]]->channel_layout = AV_CH_LAYOUT_STEREO; if (s->core_downmix && (s->core_downmix_amode == DCA_STEREO || s->core_downmix_amode == DCA_STEREO_TOTAL)) { int sign, code; for (i = 0; i < s->prim_channels + !!s->lfe; i++) { sign = s->core_downmix_codes[i][0] & 0x100 ? 1 : -1; code = s->core_downmix_codes[i][0] & 0x0FF; s->downmix_coef[i][0] = (!code ? 0.0f : sign * dca_dmixtable[code - 1]); sign = s->core_downmix_codes[i][1] & 0x100 ? 1 : -1; code = s->core_downmix_codes[i][1] & 0x0FF; s->downmix_coef[i][1] = (!code ? 0.0f : sign * dca_dmixtable[code - 1]); } s->output = s->core_downmix_amode; } else { int am = s->amode & DCA_CHANNEL_MASK; if (am >= FF_ARRAY_ELEMS(dca_default_coeffs)) { av_log(s->avctx, AV_LOG_ERROR, "Invalid channel mode %d\n", am); return AVERROR_INVALIDDATA; } if (s->prim_channels + !!s->lfe > FF_ARRAY_ELEMS(dca_default_coeffs[0])) { avpriv_request_sample(s->avctx, "Downmixing %d channels", s->prim_channels + !!s->lfe); return AVERROR_PATCHWELCOME; } for (i = 0; i < s->prim_channels + !!s->lfe; i++) { s->downmix_coef[i][0] = dca_default_coeffs[am][i][0]; s->downmix_coef[i][1] = dca_default_coeffs[am][i][1]; } } av_dlog(s->avctx, "Stereo downmix coeffs:\n"); for (i = 0; i < s->prim_channels + !!s->lfe; i++) { av_dlog(s->avctx, "L, input channel %d = %f\n", i, s->downmix_coef[i][0]); av_dlog(s->avctx, "R, input channel %d = %f\n", i, s->downmix_coef[i][1]); } av_dlog(s->avctx, "\n"); } } else { av_log([[eaglesp2]], AV_LOG_ERROR, "Non standard configuration %d !\n", s->amode); return AVERROR_INVALIDDATA; } [[eaglesp2]]->channels = channels; frame->nb_samples = 256 * (s->sample_blocks / 8); if ((ret = ff_get_buffer([[eaglesp2]], frame, 0)) < 0) { av_log([[eaglesp2]], AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } samples_flt = (float **)frame->extended_data; if ([[eaglesp2]]->channels < full_channels) { ret = av_samples_get_buffer_size(NULL, full_channels - channels, frame->nb_samples, [[eaglesp2]]->sample_fmt, 0); if (ret < 0) return ret; av_fast_malloc(&s->extra_channels_buffer, &s->extra_channels_buffer_size, ret); if (!s->extra_channels_buffer) return AVERROR(ENOMEM); ret = av_samples_fill_arrays((uint8_t **)s->extra_channels, NULL, s->extra_channels_buffer, full_channels - channels, frame->nb_samples, [[eaglesp2]]->sample_fmt, 0); if (ret < 0) return ret; } for (i = 0; i < (s->sample_blocks / 8); i++) { int ch; for (ch = 0; ch < channels; ch++) s->samples_chanptr[ch] = samples_flt[ch] + i * 256; for (; ch < full_channels; ch++) s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256; dca_filter_channels(s, i); if ((s->source_pcm_res & 1) && s->xch_present) { float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]]; float *lt_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]]; float *rt_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]]; s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256); s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256); } } lfe_samples = 2 * s->lfe * (s->sample_blocks / 8); for (i = 0; i < 2 * s->lfe * 4; i++) s->lfe_data[i] = s->lfe_data[i + lfe_samples]; ret = ff_side_data_update_matrix_encoding(frame, (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ? AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE); if (ret < 0) return ret; *got_frame_ptr = 1; return buf_size; }[Succeeded / Failed / Skipped / Total] 415 / 93 / 286 / 794:  30%|██▉       | 794/2690 [2:03:13<4:54:13,  9.31s/it][Succeeded / Failed / Skipped / Total] 415 / 93 / 286 / 794:  30%|██▉       | 795/2690 [2:03:13<4:53:43,  9.30s/it][Succeeded / Failed / Skipped / Total] 415 / 93 / 287 / 795:  30%|██▉       | 795/2690 [2:03:13<4:53:43,  9.30s/it][Succeeded / Failed / Skipped / Total] 415 / 93 / 287 / 795:  30%|██▉       | 796/2690 [2:03:33<4:54:00,  9.31s/it][Succeeded / Failed / Skipped / Total] 416 / 93 / 287 / 796:  30%|██▉       | 796/2690 [2:03:33<4:54:00,  9.31s/it][Succeeded / Failed / Skipped / Total] 416 / 93 / 287 / 796:  30%|██▉       | 797/2690 [2:03:35<4:53:33,  9.30s/it][Succeeded / Failed / Skipped / Total] 417 / 93 / 287 / 797:  30%|██▉       | 797/2690 [2:03:35<4:53:33,  9.30s/it][Succeeded / Failed / Skipped / Total] 417 / 93 / 287 / 797:  30%|██▉       | 798/2690 [2:03:55<4:53:49,  9.32s/it]
--------------------------------------------- Result 795 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int vc2_encode_init(AVCodecContext *avctx) { Plane *p; SubBand *b; int i, j, level, o, shift; const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt); const int depth = fmt->comp[0].depth; VC2EncContext *s = avctx->priv_data; s->picture_number = 0; s->q_ceil = DIRAC_MAX_QUANT_INDEX; s->ver.major = 2; s->ver.minor = 0; s->profile = 3; s->level = 3; s->base_vf = -1; s->strict_compliance = 1; s->q_avg = 0; s->slice_max_bytes = 0; s->slice_min_bytes = 0; s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) || (avctx->field_order == AV_FIELD_PROGRESSIVE)); for (i = 0; i < base_video_fmts_len; i++) { const VC2BaseVideoFormat *fmt = &base_video_fmts[i]; if (avctx->pix_fmt != fmt->pix_fmt) continue; if (avctx->time_base.num != fmt->time_base.num) continue; if (avctx->time_base.den != fmt->time_base.den) continue; if (avctx->width != fmt->width) continue; if (avctx->height != fmt->height) continue; if (s->interlaced != fmt->interlaced) continue; s->base_vf = i; s->level = base_video_fmts[i].level; break; } if (s->interlaced) av_log(avctx, AV_LOG_WARNING, "Interlacing enabled!\n"); if ((s->slice_width & (s->slice_width - 1)) || (s->slice_height & (s->slice_height - 1))) { av_log(avctx, AV_LOG_ERROR, "Slice size is not a power of two!\n"); return AVERROR_UNKNOWN; } if ((s->slice_width > avctx->width) || (s->slice_height > avctx->height)) { av_log(avctx, AV_LOG_ERROR, "Slice size is bigger than the image!\n"); return AVERROR_UNKNOWN; } if (s->base_vf <= 0) { if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) { s->strict_compliance = s->base_vf = 0; av_log(avctx, AV_LOG_WARNING, "Disabling strict compliance\n"); } else { av_log(avctx, AV_LOG_WARNING, "Given format does not strictly comply with " "the specifications, please add a -strict -1 flag to use it\n"); return AVERROR_UNKNOWN; } } else { av_log(avctx, AV_LOG_INFO, "Selected base video format = %i (%s)\n", s->base_vf, base_video_fmts[s->base_vf].name); } avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift); if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) { s->bpp = 1; s->bpp_idx = 1; s->diff_offset = 128; } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG || avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) { s->bpp = 1; s->bpp_idx = 2; s->diff_offset = 128; } else if (depth == 10) { s->bpp = 2; s->bpp_idx = 3; s->diff_offset = 512; } else { s->bpp = 2; s->bpp_idx = 4; s->diff_offset = 2048; } for (i = 0; i < 3; i++) { int w, h; p = &s->plane[i]; p->width = avctx->width >> (i ? s->chroma_x_shift : 0); p->height = avctx->height >> (i ? s->chroma_y_shift : 0); if (s->interlaced) p->height >>= 1; p->dwt_width = w = FFALIGN(p->width, (1 << s->wavelet_depth)); p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth)); p->coef_stride = FFALIGN(p->dwt_width, 32); p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef)); if (!p->coef_buf) goto alloc_fail; for (level = s->wavelet_depth-1; level >= 0; level--) { w = w >> 1; h = h >> 1; for (o = 0; o < 4; o++) { b = &p->band[level][o]; b->width = w; b->height = h; b->stride = p->coef_stride; shift = (o > 1)*b->height*b->stride + (o & 1)*b->width; b->buf = p->coef_buf + shift; } } if (ff_vc2enc_init_transforms(&s->transform_args[i].t, s->plane[i].coef_stride, s->plane[i].dwt_height)) goto alloc_fail; } s->num_x = s->plane[0].dwt_width/s->slice_width; s->num_y = s->plane[0].dwt_height/s->slice_height; s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs)); if (!s->slice_args) goto alloc_fail; s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len)); if (!s->coef_lut_len) goto alloc_fail; s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val)); if (!s->coef_lut_val) goto alloc_fail; for (i = 0; i < s->q_ceil; i++) { uint8_t *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB]; uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB]; for (j = 0; j < COEF_LUT_TAB; j++) { get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]), &len_lut[j], &val_lut[j]); if (len_lut[j] != 1) { len_lut[j] += 1; val_lut[j] <<= 1; } else { val_lut[j] = 1; } } } return 0; alloc_fail: vc2_encode_end(avctx); av_log(avctx, AV_LOG_ERROR, "Unable to allocate memory!\n"); return AVERROR(ENOMEM); }
--------------------------------------------- Result 796 ---------------------------------------------
[[0 (21%)]] --> [[0 (95%)]] --> Socre: 0.9539196491241455

[[[[Adv]]]]: void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type) { int y; uint8_t * [[fcode_tab]]= s->fcode_tab; int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code); for(y=0; y<s->mb_height; y++){ int x; int xy= (y+1)* (s->mb_width+2)+1; int i= y*s->mb_width; for(x=0; x<s->mb_width; x++) { if (s->mb_type[i] & type) { if ([[fcode_tab]][mv_table[xy][0] + MAX_MV] > f_code || [[fcode_tab]][mv_table[xy][0] + MAX_MV] == 0) { if(mv_table[xy][0]>0) mv_table[xy][0]= range-1; else mv_table[xy][0]= -range; } if ([[fcode_tab]][mv_table[xy][1] + MAX_MV] > f_code || [[fcode_tab]][mv_table[xy][1] + MAX_MV] == 0) { if(mv_table[xy][1]>0) mv_table[xy][1]= range-1; else mv_table[xy][1]= -range; } } xy++; i++; } } }

[[[[Adv]]]]: void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type) { int y; uint8_t * [[ф2lightprofile]]= s->fcode_tab; int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code); for(y=0; y<s->mb_height; y++){ int x; int xy= (y+1)* (s->mb_width+2)+1; int i= y*s->mb_width; for(x=0; x<s->mb_width; x++) { if (s->mb_type[i] & type) { if ([[ф2lightprofile]][mv_table[xy][0] + MAX_MV] > f_code || [[ф2lightprofile]][mv_table[xy][0] + MAX_MV] == 0) { if(mv_table[xy][0]>0) mv_table[xy][0]= range-1; else mv_table[xy][0]= -range; } if ([[ф2lightprofile]][mv_table[xy][1] + MAX_MV] > f_code || [[ф2lightprofile]][mv_table[xy][1] + MAX_MV] == 0) { if(mv_table[xy][1]>0) mv_table[xy][1]= range-1; else mv_table[xy][1]= -range; } } xy++; i++; } } }
--------------------------------------------- Result 797 ---------------------------------------------
[[0 (25%)]] --> [[0 (90%)]] --> Socre: 0.9044585824012756

[[[[Adv]]]]: static int nbd_establish_connection(BlockDriverState *bs) { BDRVNBDState *s = bs->opaque; int sock; int [[ret]]; off_t size; size_t blocksize; if (s->host_spec[0] == '/') { sock = unix_socket_outgoing(s->host_spec); } else { sock = tcp_socket_outgoing_spec(s->host_spec); } if (sock < 0) { logout("Failed to establish connection to NBD server\n"); return -errno; } [[ret]] = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size, &blocksize); if ([[ret]] < 0) { logout("Failed to negotiate with the NBD server\n"); closesocket(sock); return -errno; } socket_set_nonblock(sock); qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL, nbd_have_request, NULL, s); s->sock = sock; s->size = size; s->blocksize = blocksize; logout("Established connection with NBD server\n"); return 0; }

[[[[Adv]]]]: static int nbd_establish_connection(BlockDriverState *bs) { BDRVNBDState *s = bs->opaque; int sock; int [[レτ]]; off_t size; size_t blocksize; if (s->host_spec[0] == '/') { sock = unix_socket_outgoing(s->host_spec); } else { sock = tcp_socket_outgoing_spec(s->host_spec); } if (sock < 0) { logout("Failed to establish connection to NBD server\n"); return -errno; } [[レτ]] = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size, &blocksize); if ([[レτ]] < 0) { logout("Failed to negotiate with the NBD server\n"); closesocket(sock); return -errno; } socket_set_nonblock(sock); qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL, nbd_have_request, NULL, s); s->sock = sock; s->size = size; s->blocksize = blocksize; logout("Established connection with NBD server\n"); return 0; }
--------------------------------------------- Result 798 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 418 / 93 / 287 / 798:  30%|██▉       | 798/2690 [2:03:55<4:53:49,  9.32s/it][Succeeded / Failed / Skipped / Total] 418 / 93 / 287 / 798:  30%|██▉       | 799/2690 [2:03:56<4:53:18,  9.31s/it][Succeeded / Failed / Skipped / Total] 418 / 93 / 288 / 799:  30%|██▉       | 799/2690 [2:03:56<4:53:18,  9.31s/it][Succeeded / Failed / Skipped / Total] 418 / 93 / 288 / 799:  30%|██▉       | 800/2690 [2:03:56<4:52:48,  9.30s/it][Succeeded / Failed / Skipped / Total] 418 / 93 / 289 / 800:  30%|██▉       | 800/2690 [2:03:56<4:52:48,  9.30s/it][Succeeded / Failed / Skipped / Total] 418 / 93 / 289 / 800:  30%|██▉       | 801/2690 [2:03:57<4:52:18,  9.28s/it][Succeeded / Failed / Skipped / Total] 418 / 93 / 290 / 801:  30%|██▉       | 801/2690 [2:03:57<4:52:18,  9.28s/it][Succeeded / Failed / Skipped / Total] 418 / 93 / 290 / 801:  30%|██▉       | 802/2690 [2:04:15<4:52:30,  9.30s/it][Succeeded / Failed / Skipped / Total] 419 / 93 / 290 / 802:  30%|██▉       | 802/2690 [2:04:15<4:52:30,  9.30s/it][Succeeded / Failed / Skipped / Total] 419 / 93 / 290 / 802:  30%|██▉       | 803/2690 [2:04:16<4:52:02,  9.29s/it][Succeeded / Failed / Skipped / Total] 420 / 93 / 290 / 803:  30%|██▉       | 803/2690 [2:04:16<4:52:02,  9.29s/it][Succeeded / Failed / Skipped / Total] 420 / 93 / 290 / 803:  30%|██▉       | 804/2690 [2:04:18<4:51:36,  9.28s/it][[0 (4%)]] --> [[0 (56%)]] --> Socre: 0.5607191324234009

[[[[Adv]]]]: static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS]) { S390CPU *cpu = s390_env_get_cpu(env); const unsigned long *[[features]] = cpu->model->features; unsigned [[max_bit]] = 0; S390Feat feat; memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS); if (test_bit(S390_FEAT_ZARCH, [[features]])) { words[0] = 1ull << (63 - 2); } for (feat = find_first_bit([[features]], S390_FEAT_MAX); feat < S390_FEAT_MAX; feat = find_next_bit([[features]], S390_FEAT_MAX, feat + 1)) { const S390FeatDef *def = s390_feat_def(feat); if (def->type == S390_FEAT_TYPE_STFL) { unsigned [[bit]] = def->bit; if ([[bit]] > [[max_bit]]) { [[max_bit]] = [[bit]]; } assert([[bit]] / 64 < MAX_STFL_WORDS); words[[[bit]] / 64] |= 1ULL << (63 - [[bit]] % 64); } } return [[max_bit]] / 64; }

[[[[Adv]]]]: static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS]) { S390CPU *cpu = s390_env_get_cpu(env); const unsigned long *[[µ]] = cpu->model->features; unsigned [[joeerprint]] = 0; S390Feat feat; memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS); if (test_bit(S390_FEAT_ZARCH, [[µ]])) { words[0] = 1ull << (63 - 2); } for (feat = find_first_bit([[µ]], S390_FEAT_MAX); feat < S390_FEAT_MAX; feat = find_next_bit([[µ]], S390_FEAT_MAX, feat + 1)) { const S390FeatDef *def = s390_feat_def(feat); if (def->type == S390_FEAT_TYPE_STFL) { unsigned [[data]] = def->bit; if ([[data]] > [[joeerprint]]) { [[joeerprint]] = [[data]]; } assert([[data]] / 64 < MAX_STFL_WORDS); words[[[data]] / 64] |= 1ULL << (63 - [[data]] % 64); } } return [[joeerprint]] / 64; }
--------------------------------------------- Result 799 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData) { int n=0, x, y, i; tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation)); for (y=0; y<enc->height; y+=16) for (x=0; x<enc->width; x+=16) for(i=0; i<4; i++) { tempData->cel_evals[n ].sourceX = x + (i&1)*8; tempData->cel_evals[n++].sourceY = y + (i&2)*4; } }
--------------------------------------------- Result 800 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ea_read_packet(AVFormatContext *s, AVPacket *pkt) { EaDemuxContext *ea = s->priv_data; AVIOContext *pb = s->pb; int ret = 0; int packet_read = 0; unsigned int chunk_type, chunk_size; int key = 0; int av_uninit(num_samples); while (!packet_read) { chunk_type = avio_rl32(pb); chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8; switch (chunk_type) { case ISNh_TAG: avio_skip(pb, 32); chunk_size -= 32; case ISNd_TAG: case SCDl_TAG: case SNDC_TAG: case SDEN_TAG: if (!ea->audio_codec) { avio_skip(pb, chunk_size); break; } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR || ea->audio_codec == CODEC_ID_MP3) { num_samples = avio_rl32(pb); avio_skip(pb, 8); chunk_size -= 12; } ret = av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = ea->audio_stream_index; switch (ea->audio_codec) { case CODEC_ID_ADPCM_EA: case CODEC_ID_ADPCM_EA_R1: case CODEC_ID_ADPCM_EA_R2: case CODEC_ID_ADPCM_IMA_EA_EACS: pkt->duration = AV_RL32(pkt->data); break; case CODEC_ID_ADPCM_EA_R3: pkt->duration = AV_RB32(pkt->data); break; case CODEC_ID_ADPCM_IMA_EA_SEAD: pkt->duration = ret * 2 / ea->num_channels; break; case CODEC_ID_PCM_S16LE_PLANAR: case CODEC_ID_MP3: pkt->duration = num_samples; break; default: pkt->duration = chunk_size / (ea->bytes * ea->num_channels); } packet_read = 1; break; case 0: case ISNe_TAG: case SCEl_TAG: case SEND_TAG: case SEEN_TAG: ret = AVERROR(EIO); packet_read = 1; break; case MVIh_TAG: case kVGT_TAG: case pQGT_TAG: case TGQs_TAG: case MADk_TAG: key = AV_PKT_FLAG_KEY; case MVIf_TAG: case fVGT_TAG: case MADm_TAG: case MADe_TAG: avio_seek(pb, -8, SEEK_CUR); chunk_size += 8; goto get_video_packet; case mTCD_TAG: avio_skip(pb, 8); chunk_size -= 8; goto get_video_packet; case MV0K_TAG: case MPCh_TAG: case pIQT_TAG: key = AV_PKT_FLAG_KEY; case MV0F_TAG: get_video_packet: ret = av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = ea->video_stream_index; pkt->flags |= key; packet_read = 1; break; default: avio_skip(pb, chunk_size); break; } } return ret; }
--------------------------------------------- Result 801 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void type_initialize_interface(TypeImpl *ti, const char *parent) { InterfaceClass *new_iface; TypeInfo info = { }; TypeImpl *iface_impl; info.parent = parent; info.name = g_strdup_printf("%s::%s", ti->name, info.parent); info.abstract = "True" == "True"; iface_impl = type_register(&info); type_initialize(iface_impl); g_free((char *)info.name); new_iface = (InterfaceClass *)iface_impl->class; new_iface->concrete_class = ti->class; ti->class->interfaces = g_slist_append(ti->class->interfaces, iface_impl->class); }
--------------------------------------------- Result 802 ---------------------------------------------
[[0 (6%)]] --> [[0 (97%)]] --> Socre: 0.9684961438179016

[[[[Adv]]]]: aio_compute_timeout(AioContext *ctx) { int64_t [[deadline]]; int timeout = -1; QEMUBH *[[bh]]; for ([[bh]] = atomic_rcu_read(&ctx->first_bh); [[bh]]; [[bh]] = atomic_rcu_read(&[[bh]]->next)) { if ([[bh]]->scheduled) { if ([[bh]]->idle) { timeout = 10000000; } else { return 0; } } } [[deadline]] = timerlistgroup_deadline_ns(&ctx->tlg); if ([[deadline]] == 0) { return 0; } else { return qemu_soonest_timeout(timeout, [[deadline]]); } }

[[[[Adv]]]]: aio_compute_timeout(AioContext *ctx) { int64_t [[memorial]]; int timeout = -1; QEMUBH *[[भhem]]; for ([[भhem]] = atomic_rcu_read(&ctx->first_bh); [[भhem]]; [[भhem]] = atomic_rcu_read(&[[भhem]]->next)) { if ([[भhem]]->scheduled) { if ([[भhem]]->idle) { timeout = 10000000; } else { return 0; } } } [[memorial]] = timerlistgroup_deadline_ns(&ctx->tlg); if ([[memorial]] == 0) { return 0; } else { return qemu_soonest_timeout(timeout, [[memorial]]); } }
--------------------------------------------- Result 803 ---------------------------------------------
[[0 (13%)]] --> [[0 (88%)]] --> Socre: 0.879091203212738

[[[[Adv]]]]: S390CPU *s390x_new_cpu(const char *[[cpu_model]], uint32_t [[core_id]], Error **errp) { S390CPU *cpu; Error *err = NULL; cpu = cpu_s390x_create([[cpu_model]], &err); if (err != NULL) { goto out; } object_property_set_int(OBJECT(cpu), [[core_id]], "core-id", &err); if (err != NULL) { goto out; } object_property_set_bool(OBJECT(cpu), "[[True]]" == "[[True]]", "realized", &err); out: if (err) { error_propagate(errp, err); object_unref(OBJECT(cpu)); cpu = NULL; } return cpu; }

[[[[Adv]]]]: S390CPU *s390x_new_cpu(const char *[[video²tank]], uint32_t [[substratejacode]], Error **errp) { S390CPU *cpu; Error *err = NULL; cpu = cpu_s390x_create([[video²tank]], &err); if (err != NULL) { goto out; } object_property_set_int(OBJECT(cpu), [[substratejacode]], "core-id", &err); if (err != NULL) { goto out; } object_property_set_bool(OBJECT(cpu), "[[truth]]" == "[[truth]]", "realized", &err); out: if (err) { error_propagate(errp, err); object_unref(OBJECT(cpu)); cpu = NULL; } return cpu; }
--------------------------------------------- Result 804 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 421 / 93 / 290 / 804:  30%|██▉       | 804/2690 [2:04:18<4:51:36,  9.28s/it][Succeeded / Failed / Skipped / Total] 421 / 93 / 290 / 804:  30%|██▉       | 805/2690 [2:04:19<4:51:06,  9.27s/it][Succeeded / Failed / Skipped / Total] 421 / 93 / 291 / 805:  30%|██▉       | 805/2690 [2:04:19<4:51:06,  9.27s/it][Succeeded / Failed / Skipped / Total] 421 / 93 / 291 / 805:  30%|██▉       | 806/2690 [2:04:19<4:50:36,  9.26s/it][Succeeded / Failed / Skipped / Total] 421 / 93 / 292 / 806:  30%|██▉       | 806/2690 [2:04:19<4:50:36,  9.26s/it][Succeeded / Failed / Skipped / Total] 421 / 93 / 292 / 806:  30%|███       | 807/2690 [2:04:53<4:51:24,  9.29s/it][Succeeded / Failed / Skipped / Total] 422 / 93 / 292 / 807:  30%|███       | 807/2690 [2:04:53<4:51:24,  9.29s/it][Succeeded / Failed / Skipped / Total] 422 / 93 / 292 / 807:  30%|███       | 808/2690 [2:05:15<4:51:45,  9.30s/it][Succeeded / Failed / Skipped / Total] 423 / 93 / 292 / 808:  30%|███       | 808/2690 [2:05:15<4:51:45,  9.30s/it][Succeeded / Failed / Skipped / Total] 423 / 93 / 292 / 808:  30%|███       | 809/2690 [2:05:16<4:51:15,  9.29s/it][Succeeded / Failed / Skipped / Total] 424 / 93 / 292 / 809:  30%|███       | 809/2690 [2:05:16<4:51:15,  9.29s/it][Succeeded / Failed / Skipped / Total] 424 / 93 / 292 / 809:  30%|███       | 810/2690 [2:05:16<4:50:45,  9.28s/it][Succeeded / Failed / Skipped / Total] 424 / 93 / 293 / 810:  30%|███       | 810/2690 [2:05:16<4:50:46,  9.28s/it][Succeeded / Failed / Skipped / Total] 424 / 93 / 293 / 810:  30%|███       | 811/2690 [2:05:20<4:50:25,  9.27s/it][[0 (14%)]] --> [[0 (56%)]] --> Socre: 0.5579150915145874

[[[[Adv]]]]: static int video_open(VideoState *is){ int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL; int [[w]],h; if(is_full_screen) flags |= SDL_FULLSCREEN; else flags |= SDL_RESIZABLE; if (is_full_screen && fs_screen_width) { [[w]] = fs_screen_width; h = fs_screen_height; } else if(!is_full_screen && screen_width){ [[w]] = screen_width; h = screen_height; }else if (is->video_st && is->video_st->codec->width){ [[w]] = is->video_st->codec->width; h = is->video_st->codec->height; } else { [[w]] = 640; h = 480; } #ifndef SYS_DARWIN screen = SDL_SetVideoMode([[w]], h, 0, flags); #else screen = SDL_SetVideoMode([[w]], h, 24, flags); #endif if (!screen) { fprintf(stderr, "SDL: could not set video mode - exiting\n"); return -1; } SDL_WM_SetCaption("FFplay", "FFplay"); is->width = screen->w; is->height = screen->h; return 0; }

[[[[Adv]]]]: static int video_open(VideoState *is){ int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL; int [[ł]],h; if(is_full_screen) flags |= SDL_FULLSCREEN; else flags |= SDL_RESIZABLE; if (is_full_screen && fs_screen_width) { [[ł]] = fs_screen_width; h = fs_screen_height; } else if(!is_full_screen && screen_width){ [[ł]] = screen_width; h = screen_height; }else if (is->video_st && is->video_st->codec->width){ [[ł]] = is->video_st->codec->width; h = is->video_st->codec->height; } else { [[ł]] = 640; h = 480; } #ifndef SYS_DARWIN screen = SDL_SetVideoMode([[ł]], h, 0, flags); #else screen = SDL_SetVideoMode([[ł]], h, 24, flags); #endif if (!screen) { fprintf(stderr, "SDL: could not set video mode - exiting\n"); return -1; } SDL_WM_SetCaption("FFplay", "FFplay"); is->width = screen->w; is->height = screen->h; return 0; }
--------------------------------------------- Result 805 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void block_job_resume_all(void) { BlockJob *job = NULL; while ((job = block_job_next(job))) { AioContext *aio_context = blk_get_aio_context(job->blk); aio_context_acquire(aio_context); block_job_resume(job); aio_context_release(aio_context); } }
--------------------------------------------- Result 806 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int write_option(void *optctx, const OptionDef *po, const char *opt, const char *arg) { void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ? (uint8_t *)optctx + po->u.off : po->u.dst_ptr; int *dstcount; if (po->flags & OPT_SPEC) { SpecifierOpt **so = dst; char *p = strchr(opt, ':'); dstcount = (int *)(so + 1); *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1); (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : ""); dst = &(*so)[*dstcount - 1].u; } if (po->flags & OPT_STRING) { char *str; str = av_strdup(arg); av_freep(dst); *(char **)dst = str; } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) { *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX); } else if (po->flags & OPT_INT64) { *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX); } else if (po->flags & OPT_TIME) { *(int64_t *)dst = parse_time_or_die(opt, arg, 1); } else if (po->flags & OPT_FLOAT) { *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY); } else if (po->flags & OPT_DOUBLE) { *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY); } else if (po->u.func_arg) { int ret = po->u.func_arg(optctx, opt, arg); if (ret < 0) { av_log(NULL, AV_LOG_ERROR, "Failed to set value '%s' for option '%s'\n", arg, opt); return ret; } } if (po->flags & OPT_EXIT) exit_program(0); return 0; }
--------------------------------------------- Result 807 ---------------------------------------------
[[0 (97%)]] --> [[0 (29%)]] --> Socre: 0.7085347473621368

[[[[Adv]]]]: static void put_uint8(QEMUFile *f, void *[[pv]], size_t [[size]]) { uint8_t *v = [[pv]]; qemu_put_8s(f, v); }

[[[[Adv]]]]: static void put_uint8(QEMUFile *f, void *[[fan]], size_t [[list]]) { uint8_t *v = [[fan]]; qemu_put_8s(f, v); }
--------------------------------------------- Result 808 ---------------------------------------------
[[0 (17%)]] --> [[0 (67%)]] --> Socre: 0.6747080683708191

[[[[Adv]]]]: void qmp_migrate_set_speed(int64_t [[value]], Error **[[errp]]) { MigrationState *[[s]]; if ([[value]] < 0) { [[value]] = 0; } [[s]] = migrate_get_current(); [[s]]->bandwidth_limit = [[value]]; qemu_file_set_rate_limit([[s]]->file, [[s]]->bandwidth_limit); }

[[[[Adv]]]]: void qmp_migrate_set_speed(int64_t [[var]], Error **[[wpa]]) { MigrationState *[[was]]; if ([[var]] < 0) { [[var]] = 0; } [[was]] = migrate_get_current(); [[was]]->bandwidth_limit = [[var]]; qemu_file_set_rate_limit([[was]]->file, [[was]]->bandwidth_limit); }
--------------------------------------------- Result 809 ---------------------------------------------
[[0 (2%)]] --> [[0 (75%)]] --> Socre: 0.7483628392219543

[[[[Adv]]]]: static uint64_t nand_read(void *[[opaque]], target_phys_addr_t [[addr]], unsigned size) { struct nand_state_t *s = [[opaque]]; uint32_t [[r]]; int rdy; [[r]] = nand_getio(s->nand); nand_getpins(s->nand, &rdy); s->rdy = rdy; DNAND(printf("%s addr=%x r=%x\n", __func__, [[addr]], [[r]])); return [[r]]; }

[[[[Adv]]]]: static uint64_t nand_read(void *[[translucent]], target_phys_addr_t [[mxр]], unsigned size) { struct nand_state_t *s = [[translucent]]; uint32_t [[g]]; int rdy; [[g]] = nand_getio(s->nand); nand_getpins(s->nand, &rdy); s->rdy = rdy; DNAND(printf("%s addr=%x r=%x\n", __func__, [[mxр]], [[g]])); return [[g]]; }
--------------------------------------------- Result 810 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qemu_tcg_init_vcpu(CPUState *cpu) { char thread_name[VCPU_THREAD_NAME_SIZE]; static QemuCond *tcg_halt_cond; static QemuThread *tcg_cpu_thread; if (!tcg_cpu_thread) { cpu->thread = g_malloc0(sizeof(QemuThread)); cpu->halt_cond = g_malloc0(sizeof(QemuCond)); qemu_cond_init(cpu->halt_cond); tcg_halt_cond = cpu->halt_cond; snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/TCG", cpu->cpu_index); qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn, cpu, QEMU_THREAD_JOINABLE); #ifdef _WIN32 cpu->hThread = qemu_thread_get_handle(cpu->thread); #endif while (!cpu->created) { qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex); } tcg_cpu_thread = cpu->thread; } else { cpu->thread = tcg_cpu_thread; cpu->halt_cond = tcg_halt_cond; } }
--------------------------------------------- Result 811 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 425 / 93 / 293 / 811:  30%|███       | 811/2690 [2:05:20<4:50:25,  9.27s/it][Succeeded / Failed / Skipped / Total] 425 / 93 / 293 / 811:  30%|███       | 812/2690 [2:05:21<4:49:55,  9.26s/it][Succeeded / Failed / Skipped / Total] 425 / 93 / 294 / 812:  30%|███       | 812/2690 [2:05:21<4:49:55,  9.26s/it][Succeeded / Failed / Skipped / Total] 425 / 93 / 294 / 812:  30%|███       | 813/2690 [2:05:38<4:50:04,  9.27s/it][[0 (53%)]] --> [[0 (29%)]] --> Socre: 0.7141158282756805

[[[[Adv]]]]: static RemoveResult remove_hpte(PowerPCCPU *[[cpu]], target_ulong ptex, target_ulong avpn, target_ulong flags, target_ulong *vp, target_ulong *rp) { CPUPPCState *env = &[[cpu]]->env; uint64_t token; target_ulong v, r, rb; if (!valid_pte_index(env, ptex)) { return REMOVE_PARM; } token = ppc_hash64_start_access([[cpu]], ptex); v = ppc_hash64_load_hpte0([[cpu]], token, 0); r = ppc_hash64_load_hpte1([[cpu]], token, 0); ppc_hash64_stop_access(token); if ((v & HPTE64_V_VALID) == 0 || ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) || ((flags & H_ANDCOND) && (v & avpn) != 0)) { return REMOVE_NOT_FOUND; } *vp = v; *rp = r; ppc_hash64_store_hpte([[cpu]], ptex, HPTE64_V_HPTE_DIRTY, 0); rb = compute_tlbie_rb(v, r, ptex); ppc_tlb_invalidate_one(env, rb); return REMOVE_SUCCESS; }

[[[[Adv]]]]: static RemoveResult remove_hpte(PowerPCCPU *[[quad]], target_ulong ptex, target_ulong avpn, target_ulong flags, target_ulong *vp, target_ulong *rp) { CPUPPCState *env = &[[quad]]->env; uint64_t token; target_ulong v, r, rb; if (!valid_pte_index(env, ptex)) { return REMOVE_PARM; } token = ppc_hash64_start_access([[quad]], ptex); v = ppc_hash64_load_hpte0([[quad]], token, 0); r = ppc_hash64_load_hpte1([[quad]], token, 0); ppc_hash64_stop_access(token); if ((v & HPTE64_V_VALID) == 0 || ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) || ((flags & H_ANDCOND) && (v & avpn) != 0)) { return REMOVE_NOT_FOUND; } *vp = v; *rp = r; ppc_hash64_store_hpte([[quad]], ptex, HPTE64_V_HPTE_DIRTY, 0); rb = compute_tlbie_rb(v, r, ptex); ppc_tlb_invalidate_one(env, rb); return REMOVE_SUCCESS; }
--------------------------------------------- Result 812 ---------------------------------------------
[[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int decode_init(AVCodecContext * avctx) { MPADecodeContext *s = avctx->priv_data; static int init=0; int i, j, k; s->avctx = avctx; ff_mpadsp_init(&s->mpadsp); avctx->sample_fmt= OUT_FMT; s->error_recognition= avctx->error_recognition; if (!init && !avctx->parse_only) { int offset; for(i=0;i<64;i++) { int shift, mod; shift = (i / 3); mod = i % 3; scale_factor_modshift[i] = mod | (shift << 2); } for(i=0;i<15;i++) { int n, norm; n = i + 2; norm = ((INT64_C(1) << n) * FRAC_ONE) / ((1 << n) - 1); scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0 * 2.0), FRAC_BITS); scale_factor_mult[i][1] = MULLx(norm, FIXR(0.7937005259 * 2.0), FRAC_BITS); scale_factor_mult[i][2] = MULLx(norm, FIXR(0.6299605249 * 2.0), FRAC_BITS); av_dlog(avctx, "%d: norm=%x s=%x %x %x\n", i, norm, scale_factor_mult[i][0], scale_factor_mult[i][1], scale_factor_mult[i][2]); } RENAME(ff_mpa_synth_init)(RENAME(ff_mpa_synth_window)); offset = 0; for(i=1;i<16;i++) { const HuffTable *h = &mpa_huff_tables[i]; int xsize, x, y; uint8_t tmp_bits [512]; uint16_t tmp_codes[512]; memset(tmp_bits , 0, sizeof(tmp_bits )); memset(tmp_codes, 0, sizeof(tmp_codes)); xsize = h->xsize; j = 0; for(x=0;x<xsize;x++) { for(y=0;y<xsize;y++){ tmp_bits [(x << 5) | y | ((x&&y)<<4)]= h->bits [j ]; tmp_codes[(x << 5) | y | ((x&&y)<<4)]= h->codes[j++]; } } huff_vlc[i].table = huff_vlc_tables+offset; huff_vlc[i].table_allocated = huff_vlc_tables_sizes[i]; init_vlc(&huff_vlc[i], 7, 512, tmp_bits, 1, 1, tmp_codes, 2, 2, INIT_VLC_USE_NEW_STATIC); offset += huff_vlc_tables_sizes[i]; } assert(offset == FF_ARRAY_ELEMS(huff_vlc_tables)); offset = 0; for(i=0;i<2;i++) { huff_quad_vlc[i].table = huff_quad_vlc_tables+offset; huff_quad_vlc[i].table_allocated = huff_quad_vlc_tables_sizes[i]; init_vlc(&huff_quad_vlc[i], i == 0 ? 7 : 4, 16, mpa_quad_bits[i], 1, 1, mpa_quad_codes[i], 1, 1, INIT_VLC_USE_NEW_STATIC); offset += huff_quad_vlc_tables_sizes[i]; } assert(offset == FF_ARRAY_ELEMS(huff_quad_vlc_tables)); for(i=0;i<9;i++) { k = 0; for(j=0;j<22;j++) { band_index_long[i][j] = k; k += band_size_long[i][j]; } band_index_long[i][22] = k; } int_pow_init(); mpegaudio_tableinit(); for (i = 0; i < 4; i++) if (ff_mpa_quant_bits[i] < 0) for (j = 0; j < (1<<(-ff_mpa_quant_bits[i]+1)); j++) { int val1, val2, val3, steps; int val = j; steps = ff_mpa_quant_steps[i]; val1 = val % steps; val /= steps; val2 = val % steps; val3 = val / steps; division_tabs[i][j] = val1 + (val2 << 4) + (val3 << 8); } for(i=0;i<7;i++) { float f; INTFLOAT v; if (i != 6) { f = tan((double)i * M_PI / 12.0); v = FIXR(f / (1.0 + f)); } else { v = FIXR(1.0); } is_table[0][i] = v; is_table[1][6 - i] = v; } for(i=7;i<16;i++) is_table[0][i] = is_table[1][i] = 0.0; for(i=0;i<16;i++) { double f; int e, k; for(j=0;j<2;j++) { e = -(j + 1) * ((i + 1) >> 1); f = pow(2.0, e / 4.0); k = i & 1; is_table_lsf[j][k ^ 1][i] = FIXR(f); is_table_lsf[j][k][i] = FIXR(1.0); av_dlog(avctx, "is_table_lsf %d %d: %x %x\n", i, j, is_table_lsf[j][0][i], is_table_lsf[j][1][i]); } } for(i=0;i<8;i++) { float ci, cs, ca; ci = ci_table[i]; cs = 1.0 / sqrt(1.0 + ci * ci); ca = cs * ci; csa_table[i][0] = FIXHR(cs/4); csa_table[i][1] = FIXHR(ca/4); csa_table[i][2] = FIXHR(ca/4) + FIXHR(cs/4); csa_table[i][3] = FIXHR(ca/4) - FIXHR(cs/4); csa_table_float[i][0] = cs; csa_table_float[i][1] = ca; csa_table_float[i][2] = ca + cs; csa_table_float[i][3] = ca - cs; } for(i=0;i<36;i++) { for(j=0; j<4; j++){ double d; if(j==2 && i%3 != 1) continue; d= sin(M_PI * (i + 0.5) / 36.0); if(j==1){ if (i>=30) d= 0; else if(i>=24) d= sin(M_PI * (i - 18 + 0.5) / 12.0); else if(i>=18) d= 1; }else if(j==3){ if (i< 6) d= 0; else if(i< 12) d= sin(M_PI * (i - 6 + 0.5) / 12.0); else if(i< 18) d= 1; } d*= 0.5 / cos(M_PI*(2*i + 19)/72); if(j==2) mdct_win[j][i/3] = FIXHR((d / (1<<5))); else mdct_win[j][i ] = FIXHR((d / (1<<5))); } } for(j=0;j<4;j++) { for(i=0;i<36;i+=2) { mdct_win[j + 4][i] = mdct_win[j][i]; mdct_win[j + 4][i + 1] = -mdct_win[j][i + 1]; } } init = 1; } if (avctx->codec_id == CODEC_ID_MP3ADU) s->adu_mode = 1; return 0; }
--------------------------------------------- Result 813 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 426 / 93 / 294 / 813:  30%|███       | 813/2690 [2:05:38<4:50:04,  9.27s/it][Succeeded / Failed / Skipped / Total] 426 / 93 / 294 / 813:  30%|███       | 814/2690 [2:05:38<4:49:34,  9.26s/it][Succeeded / Failed / Skipped / Total] 426 / 93 / 295 / 814:  30%|███       | 814/2690 [2:05:38<4:49:34,  9.26s/it][Succeeded / Failed / Skipped / Total] 426 / 93 / 295 / 814:  30%|███       | 815/2690 [2:05:39<4:49:05,  9.25s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 295 / 815:  30%|███       | 815/2690 [2:05:39<4:49:05,  9.25s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 295 / 815:  30%|███       | 816/2690 [2:05:39<4:48:34,  9.24s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 296 / 816:  30%|███       | 816/2690 [2:05:39<4:48:34,  9.24s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 296 / 816:  30%|███       | 817/2690 [2:05:39<4:48:05,  9.23s/it][[0 (69%)]] --> [[0 (46%)]] --> Socre: 0.5399869680404663

[[[[Adv]]]]: int pcie_aer_init(PCIDevice *[[dev]], uint16_t offset, uint16_t size) { PCIExpressDevice *exp; pcie_add_capability([[dev]], PCI_EXT_CAP_ID_ERR, PCI_ERR_VER, offset, size); exp = &[[dev]]->exp; exp->aer_cap = offset; if ([[dev]]->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) { [[dev]]->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT; } if ([[dev]]->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) { return -EINVAL; } [[dev]]->exp.aer_log.log = g_malloc0(sizeof [[dev]]->exp.aer_log.log[0] * [[dev]]->exp.aer_log.log_max); pci_set_long([[dev]]->w1cmask + offset + PCI_ERR_UNCOR_STATUS, PCI_ERR_UNC_SUPPORTED); pci_set_long([[dev]]->config + offset + PCI_ERR_UNCOR_SEVER, PCI_ERR_UNC_SEVERITY_DEFAULT); pci_set_long([[dev]]->wmask + offset + PCI_ERR_UNCOR_SEVER, PCI_ERR_UNC_SUPPORTED); pci_long_test_and_set_mask([[dev]]->w1cmask + offset + PCI_ERR_COR_STATUS, PCI_ERR_COR_SUPPORTED); pci_set_long([[dev]]->config + offset + PCI_ERR_COR_MASK, PCI_ERR_COR_MASK_DEFAULT); pci_set_long([[dev]]->wmask + offset + PCI_ERR_COR_MASK, PCI_ERR_COR_SUPPORTED); if ([[dev]]->exp.aer_log.log_max > 0) { pci_set_long([[dev]]->config + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC | PCI_ERR_CAP_MHRC); pci_set_long([[dev]]->wmask + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE | PCI_ERR_CAP_MHRE); } else { pci_set_long([[dev]]->config + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC); pci_set_long([[dev]]->wmask + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE); } switch (pcie_cap_get_type([[dev]])) { case PCI_EXP_TYPE_ROOT_PORT: case PCI_EXP_TYPE_DOWNSTREAM: case PCI_EXP_TYPE_UPSTREAM: pci_word_test_and_set_mask([[dev]]->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_SERR); pci_long_test_and_set_mask([[dev]]->w1cmask + PCI_STATUS, PCI_SEC_STATUS_RCV_SYSTEM_ERROR); break; default: break; } return 0; }

[[[[Adv]]]]: int pcie_aer_init(PCIDevice *[[x]], uint16_t offset, uint16_t size) { PCIExpressDevice *exp; pcie_add_capability([[x]], PCI_EXT_CAP_ID_ERR, PCI_ERR_VER, offset, size); exp = &[[x]]->exp; exp->aer_cap = offset; if ([[x]]->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) { [[x]]->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT; } if ([[x]]->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) { return -EINVAL; } [[x]]->exp.aer_log.log = g_malloc0(sizeof [[x]]->exp.aer_log.log[0] * [[x]]->exp.aer_log.log_max); pci_set_long([[x]]->w1cmask + offset + PCI_ERR_UNCOR_STATUS, PCI_ERR_UNC_SUPPORTED); pci_set_long([[x]]->config + offset + PCI_ERR_UNCOR_SEVER, PCI_ERR_UNC_SEVERITY_DEFAULT); pci_set_long([[x]]->wmask + offset + PCI_ERR_UNCOR_SEVER, PCI_ERR_UNC_SUPPORTED); pci_long_test_and_set_mask([[x]]->w1cmask + offset + PCI_ERR_COR_STATUS, PCI_ERR_COR_SUPPORTED); pci_set_long([[x]]->config + offset + PCI_ERR_COR_MASK, PCI_ERR_COR_MASK_DEFAULT); pci_set_long([[x]]->wmask + offset + PCI_ERR_COR_MASK, PCI_ERR_COR_SUPPORTED); if ([[x]]->exp.aer_log.log_max > 0) { pci_set_long([[x]]->config + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC | PCI_ERR_CAP_MHRC); pci_set_long([[x]]->wmask + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE | PCI_ERR_CAP_MHRE); } else { pci_set_long([[x]]->config + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC); pci_set_long([[x]]->wmask + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE); } switch (pcie_cap_get_type([[x]])) { case PCI_EXP_TYPE_ROOT_PORT: case PCI_EXP_TYPE_DOWNSTREAM: case PCI_EXP_TYPE_UPSTREAM: pci_word_test_and_set_mask([[x]]->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_SERR); pci_long_test_and_set_mask([[x]]->w1cmask + PCI_STATUS, PCI_SEC_STATUS_RCV_SYSTEM_ERROR); break; default: break; } return 0; }
--------------------------------------------- Result 814 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr) { unsigned access_size_min = mr->ops->impl.min_access_size; unsigned access_size_max = mr->ops->impl.max_access_size; if (access_size_min == 0) { access_size_min = 1; } if (access_size_max == 0) { access_size_max = 4; } if (!mr->ops->impl.unaligned) { unsigned align_size_max = addr & -addr; if (align_size_max != 0 && align_size_max < access_size_max) { access_size_max = align_size_max; } } if (l > access_size_max) { l = access_size_max; } assert(l >= access_size_min); return l; }
--------------------------------------------- Result 815 ---------------------------------------------
[[0 (55%)]] --> [[0 (12%)]] --> Socre: 0.8804667666554451

[[[[Adv]]]]: ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *[[data]], size_t datalen) { ssize_t ret; #ifdef CONFIG_VNC_TLS if (vs->tls.session) { ret = vnc_client_write_tls(&vs->tls.session, [[data]], datalen); } else { #endif ret = send(vs->csock, (const void *)data, datalen, 0); #ifdef CONFIG_VNC_TLS } #endif VNC_DEBUG("Wrote wire %p %zd -> %ld\n", [[data]], datalen, ret); return vnc_client_io_error(vs, ret, socket_error()); }

[[[[Adv]]]]: ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *[[clock]], size_t datalen) { ssize_t ret; #ifdef CONFIG_VNC_TLS if (vs->tls.session) { ret = vnc_client_write_tls(&vs->tls.session, [[clock]], datalen); } else { #endif ret = send(vs->csock, (const void *)data, datalen, 0); #ifdef CONFIG_VNC_TLS } #endif VNC_DEBUG("Wrote wire %p %zd -> %ld\n", [[clock]], datalen, ret); return vnc_client_io_error(vs, ret, socket_error()); }
--------------------------------------------- Result 816 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void fw_cfg_add_file_callback(FWCfgState *s, const char *filename, FWCfgCallback select_cb, FWCfgWriteCallback write_cb, void *callback_opaque, void *data, size_t len, bool read_only) { int i, index, count; size_t dsize; MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine()); int order = 0; if (!s->files) { dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s); s->files = g_malloc0(dsize); fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize); } count = be32_to_cpu(s->files->count); assert(count < fw_cfg_file_slots(s)); if (mc->legacy_fw_cfg_order) { order = get_fw_cfg_order(s, filename); for (index = count; index > 0 && order < s->entry_order[index - 1]; index--); } else { for (index = count; index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0; index--); } for (i = count + 1; i > index; i--) { s->files->f[i] = s->files->f[i - 1]; s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i); s->entries[0][FW_CFG_FILE_FIRST + i] = s->entries[0][FW_CFG_FILE_FIRST + i - 1]; s->entry_order[i] = s->entry_order[i - 1]; } memset(&s->files->f[index], 0, sizeof(FWCfgFile)); memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry)); pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename); for (i = 0; i <= count; i++) { if (i != index && strcmp(s->files->f[index].name, s->files->f[i].name) == 0) { error_report("duplicate fw_cfg file name: %s", s->files->f[index].name); exit(1); } } fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index, select_cb, write_cb, callback_opaque, data, len, read_only); s->files->f[index].size = cpu_to_be32(len); s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index); s->entry_order[index] = order; trace_fw_cfg_add_file(s, index, s->files->f[index].name, len); s->files->count = cpu_to_be32(count+1); }
--------------------------------------------- Result 817 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 427 / 93 / 297 / 817:  30%|███       | 817/2690 [2:05:39<4:48:05,  9.23s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 298 / 818:  30%|███       | 818/2690 [2:05:39<4:47:35,  9.22s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 298 / 818:  30%|███       | 819/2690 [2:05:40<4:47:05,  9.21s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 299 / 819:  30%|███       | 819/2690 [2:05:40<4:47:05,  9.21s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 300 / 820:  30%|███       | 820/2690 [2:05:40<4:46:36,  9.20s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 300 / 820:  31%|███       | 821/2690 [2:05:41<4:46:08,  9.19s/it][Succeeded / Failed / Skipped / Total] 427 / 93 / 301 / 821:  31%|███       | 821/2690 [2:05:41<4:46:08,  9.19s/it][Succeeded / Failed / Skipped / Total] 428 / 93 / 301 / 822:  31%|███       | 822/2690 [2:06:02<4:46:24,  9.20s/it][Succeeded / Failed / Skipped / Total] 428 / 93 / 301 / 822:  31%|███       | 823/2690 [2:06:12<4:46:18,  9.20s/it][[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void stellaris_enet_save(QEMUFile *f, void *opaque) { stellaris_enet_state *s = (stellaris_enet_state *)opaque; int i; qemu_put_be32(f, s->ris); qemu_put_be32(f, s->im); qemu_put_be32(f, s->rctl); qemu_put_be32(f, s->tctl); qemu_put_be32(f, s->thr); qemu_put_be32(f, s->mctl); qemu_put_be32(f, s->mdv); qemu_put_be32(f, s->mtxd); qemu_put_be32(f, s->mrxd); qemu_put_be32(f, s->np); qemu_put_be32(f, s->tx_fifo_len); qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo)); for (i = 0; i < 31; i++) { qemu_put_be32(f, s->rx[i].len); qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data)); } qemu_put_be32(f, s->next_packet); qemu_put_be32(f, s->rx_fifo_offset); }
--------------------------------------------- Result 818 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void exit_program(void) { int i, j; for (i = 0; i < nb_filtergraphs; i++) { avfilter_graph_free(&filtergraphs[i]->graph); for (j = 0; j < filtergraphs[i]->nb_inputs; j++) { av_freep(&filtergraphs[i]->inputs[j]->name); av_freep(&filtergraphs[i]->inputs[j]); } av_freep(&filtergraphs[i]->inputs); for (j = 0; j < filtergraphs[i]->nb_outputs; j++) { av_freep(&filtergraphs[i]->outputs[j]->name); av_freep(&filtergraphs[i]->outputs[j]); } av_freep(&filtergraphs[i]->outputs); av_freep(&filtergraphs[i]->graph_desc); av_freep(&filtergraphs[i]); } av_freep(&filtergraphs); for (i = 0; i < nb_output_files; i++) { AVFormatContext *s = output_files[i]->ctx; if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb) avio_close(s->pb); avformat_free_context(s); av_dict_free(&output_files[i]->opts); av_freep(&output_files[i]); } for (i = 0; i < nb_output_streams; i++) { AVBitStreamFilterContext *bsfc = output_streams[i]->bitstream_filters; while (bsfc) { AVBitStreamFilterContext *next = bsfc->next; av_bitstream_filter_close(bsfc); bsfc = next; } output_streams[i]->bitstream_filters = NULL; avcodec_free_frame(&output_streams[i]->filtered_frame); av_freep(&output_streams[i]->forced_keyframes); av_freep(&output_streams[i]->avfilter); av_freep(&output_streams[i]->logfile_prefix); av_freep(&output_streams[i]); } for (i = 0; i < nb_input_files; i++) { avformat_close_input(&input_files[i]->ctx); av_freep(&input_files[i]); } for (i = 0; i < nb_input_streams; i++) { av_frame_free(&input_streams[i]->decoded_frame); av_frame_free(&input_streams[i]->filter_frame); av_dict_free(&input_streams[i]->opts); av_freep(&input_streams[i]->filters); av_freep(&input_streams[i]); } if (vstats_file) fclose(vstats_file); av_free(vstats_filename); av_freep(&input_streams); av_freep(&input_files); av_freep(&output_streams); av_freep(&output_files); uninit_opts(); avfilter_uninit(); avformat_network_deinit(); if (received_sigterm) { av_log(NULL, AV_LOG_INFO, "Received signal %d: terminating.\n", (int) received_sigterm); exit (255); } }
--------------------------------------------- Result 819 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs, int64_t sector_num, int nb_sectors, int *num_same) { int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8; uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE; uint8_t bitmap[BDRV_SECTOR_SIZE]; int ret; int changed; ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)); if (ret < 0) { return ret; } bitnum &= BITS_PER_BITMAP_SECTOR - 1; changed = cow_test_bit(bitnum, bitmap); *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors); return changed; }
--------------------------------------------- Result 820 ---------------------------------------------
[[0 (88%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void check_refcounts(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; int64_t size; int nb_clusters, refcount1, refcount2, i; QCowSnapshot *sn; uint16_t *refcount_table; size = bdrv_getlength(s->hd); nb_clusters = size_to_clusters(s, size); refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t)); inc_refcounts(bs, refcount_table, nb_clusters, 0, s->cluster_size); check_refcounts_l1(bs, refcount_table, nb_clusters, s->l1_table_offset, s->l1_size, 1); for(i = 0; i < s->nb_snapshots; i++) { sn = s->snapshots + i; check_refcounts_l1(bs, refcount_table, nb_clusters, sn->l1_table_offset, sn->l1_size, 0); } inc_refcounts(bs, refcount_table, nb_clusters, s->snapshots_offset, s->snapshots_size); inc_refcounts(bs, refcount_table, nb_clusters, s->refcount_table_offset, s->refcount_table_size * sizeof(uint64_t)); for(i = 0; i < s->refcount_table_size; i++) { int64_t offset; offset = s->refcount_table[i]; if (offset != 0) { inc_refcounts(bs, refcount_table, nb_clusters, offset, s->cluster_size); } } for(i = 0; i < nb_clusters; i++) { refcount1 = get_refcount(bs, i); refcount2 = refcount_table[i]; if (refcount1 != refcount2) fprintf(stderr, "ERROR cluster %d refcount=%d reference=%d\n", i, refcount1, refcount2); } qemu_free(refcount_table); }
--------------------------------------------- Result 821 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ipoctal_init(IPackDevice *ip) { IPOctalState *s = IPOCTAL(ip); unsigned i; for (i = 0; i < N_CHANNELS; i++) { SCC2698Channel *ch = &s->ch[i]; ch->ipoctal = s; if (ch->devpath) { const char chr_name[] = "ipoctal"; char label[ARRAY_SIZE(chr_name) + 2]; static int index; snprintf(label, sizeof(label), "%s%d", chr_name, index); ch->dev = qemu_chr_new(label, ch->devpath, NULL); if (ch->dev) { index++; qemu_chr_add_handlers(ch->dev, hostdev_can_receive, hostdev_receive, hostdev_event, ch); DPRINTF("Redirecting channel %u to %s (%s)\n", i, ch->devpath, label); } else { DPRINTF("Could not redirect channel %u to %s\n", i, ch->devpath); } } } return 0; }
--------------------------------------------- Result 822 ---------------------------------------------
[[0 (74%)]] --> [[0 (13%)]] --> Socre: 0.8692650198936462

[[[[Adv]]]]: static AddrRange addrrange_intersection(AddrRange r1, AddrRange [[r2]]) { uint64_t start = MAX(r1.start, [[r2]].start); uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end([[r2]]) - 1); return addrrange_make(start, end - start + 1); }

[[[[Adv]]]]: static AddrRange addrrange_intersection(AddrRange r1, AddrRange [[russell9]]) { uint64_t start = MAX(r1.start, [[russell9]].start); uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end([[russell9]]) - 1); return addrrange_make(start, end - start + 1); }
--------------------------------------------- Result 823 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 429 / 93 / 301 / 823:  31%|███       | 823/2690 [2:06:12<4:46:18,  9.20s/it][Succeeded / Failed / Skipped / Total] 429 / 93 / 301 / 823:  31%|███       | 824/2690 [2:06:13<4:45:49,  9.19s/it][Succeeded / Failed / Skipped / Total] 429 / 93 / 302 / 824:  31%|███       | 824/2690 [2:06:13<4:45:49,  9.19s/it][Succeeded / Failed / Skipped / Total] 429 / 93 / 302 / 824:  31%|███       | 825/2690 [2:06:22<4:45:40,  9.19s/it][Succeeded / Failed / Skipped / Total] 430 / 93 / 302 / 825:  31%|███       | 825/2690 [2:06:22<4:45:40,  9.19s/it][Succeeded / Failed / Skipped / Total] 430 / 93 / 302 / 825:  31%|███       | 826/2690 [2:06:22<4:45:11,  9.18s/it][Succeeded / Failed / Skipped / Total] 430 / 93 / 303 / 826:  31%|███       | 826/2690 [2:06:22<4:45:11,  9.18s/it][Succeeded / Failed / Skipped / Total] 430 / 93 / 303 / 826:  31%|███       | 827/2690 [2:06:32<4:45:03,  9.18s/it][[0 (20%)]] --> [[0 (58%)]] --> Socre: 0.5838643312454224

[[[[Adv]]]]: static int libgsm_decode_frame(AVCodecContext *[[avctx]], void *[[data]], int *data_size, AVPacket *avpkt) { uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int out_size = [[avctx]]->frame_size * av_get_bytes_per_sample([[avctx]]->sample_fmt); if (*data_size < out_size) { av_log([[avctx]], AV_LOG_ERROR, "Output buffer is too small\n"); return AVERROR(EINVAL); } if (buf_size < [[avctx]]->block_align) { av_log([[avctx]], AV_LOG_ERROR, "Packet is too small\n"); return AVERROR_INVALIDDATA; } switch([[avctx]]->codec_id) { case CODEC_ID_GSM: if(gsm_decode([[avctx]]->priv_data,buf,[[data]])) return -1; break; case CODEC_ID_GSM_MS: if(gsm_decode([[avctx]]->priv_data,buf,[[data]]) || gsm_decode([[avctx]]->priv_data,buf+33,((int16_t*)[[data]])+GSM_FRAME_SIZE)) return -1; } *data_size = out_size; return [[avctx]]->block_align; }

[[[[Adv]]]]: static int libgsm_decode_frame(AVCodecContext *[[esiti]], void *[[matrix]], int *data_size, AVPacket *avpkt) { uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int out_size = [[esiti]]->frame_size * av_get_bytes_per_sample([[esiti]]->sample_fmt); if (*data_size < out_size) { av_log([[esiti]], AV_LOG_ERROR, "Output buffer is too small\n"); return AVERROR(EINVAL); } if (buf_size < [[esiti]]->block_align) { av_log([[esiti]], AV_LOG_ERROR, "Packet is too small\n"); return AVERROR_INVALIDDATA; } switch([[esiti]]->codec_id) { case CODEC_ID_GSM: if(gsm_decode([[esiti]]->priv_data,buf,[[matrix]])) return -1; break; case CODEC_ID_GSM_MS: if(gsm_decode([[esiti]]->priv_data,buf,[[matrix]]) || gsm_decode([[esiti]]->priv_data,buf+33,((int16_t*)[[matrix]])+GSM_FRAME_SIZE)) return -1; } *data_size = out_size; return [[esiti]]->block_align; }
--------------------------------------------- Result 824 ---------------------------------------------
[[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int64_t do_strtosz(const char *nptr, char **end, const char default_suffix, int64_t unit) { int64_t retval; char *endptr; unsigned char c; int mul_required = 0; double val, mul, integral, fraction; errno = 0; val = strtod(nptr, &endptr); if (isnan(val) || endptr == nptr || errno != 0) { retval = -EINVAL; goto out; } fraction = modf(val, &integral); if (fraction != 0) { mul_required = 1; } c = *endptr; mul = suffix_mul(c, unit); if (mul >= 0) { endptr++; } else { mul = suffix_mul(default_suffix, unit); assert(mul >= 0); } if (mul == 1 && mul_required) { retval = -EINVAL; goto out; } if ((val * mul >= INT64_MAX) || val < 0) { retval = -ERANGE; goto out; } retval = val * mul; out: if (end) { *end = endptr; } else if (*endptr) { retval = -EINVAL; } return retval; }
--------------------------------------------- Result 825 ---------------------------------------------
[[0 (4%)]] --> [[0 (53%)]] --> Socre: 0.5286345481872559

[[[[Adv]]]]: bool timerlist_expired(QEMUTimerList *[[timer_list]]) { int64_t [[expire_time]]; if (!atomic_read(&[[timer_list]]->active_timers)) { return "[[False]]" != "[[False]]"; } qemu_mutex_lock(&[[timer_list]]->active_timers_lock); if (![[timer_list]]->active_timers) { qemu_mutex_unlock(&[[timer_list]]->active_timers_lock); return "[[False]]" != "[[False]]"; } [[expire_time]] = [[timer_list]]->active_timers->expire_time; qemu_mutex_unlock(&[[timer_list]]->active_timers_lock); return [[expire_time]] < qemu_clock_get_ns([[timer_list]]->clock->type); }

[[[[Adv]]]]: bool timerlist_expired(QEMUTimerList *[[grandfatherrya]]) { int64_t [[reinspelrwhile]]; if (!atomic_read(&[[grandfatherrya]]->active_timers)) { return "[[valid]]" != "[[valid]]"; } qemu_mutex_lock(&[[grandfatherrya]]->active_timers_lock); if (![[grandfatherrya]]->active_timers) { qemu_mutex_unlock(&[[grandfatherrya]]->active_timers_lock); return "[[valid]]" != "[[valid]]"; } [[reinspelrwhile]] = [[grandfatherrya]]->active_timers->expire_time; qemu_mutex_unlock(&[[grandfatherrya]]->active_timers_lock); return [[reinspelrwhile]] < qemu_clock_get_ns([[grandfatherrya]]->clock->type); }
--------------------------------------------- Result 826 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint32_t dcr_read_pob (void *opaque, int dcrn) { ppc4xx_pob_t *pob; uint32_t ret; pob = opaque; switch (dcrn) { case POB0_BEAR: ret = pob->bear; break; case POB0_BESR0: case POB0_BESR1: ret = pob->besr[dcrn - POB0_BESR0]; break; default: ret = 0; break; } return ret; }
--------------------------------------------- Result 827 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 431 / 93 / 303 / 827:  31%|███       | 827/2690 [2:06:32<4:45:03,  9.18s/it][Succeeded / Failed / Skipped / Total] 431 / 93 / 303 / 827:  31%|███       | 828/2690 [2:06:47<4:45:06,  9.19s/it][[0 (43%)]] --> [[0 (70%)]] --> Socre: 0.6956637501716614

[[[[Adv]]]]: static int wc3_read_header(AVFormatContext *s, AVFormatParameters *ap) { Wc3DemuxContext *[[wc3]] = s->priv_data; ByteIOContext *pb = s->pb; unsigned int fourcc_tag; unsigned int size; AVStream *st; unsigned char preamble[WC3_PREAMBLE_SIZE]; int ret = 0; int current_palette = 0; int bytes_to_read; int i; unsigned char rotate; [[wc3]]->width = WC3_DEFAULT_WIDTH; [[wc3]]->height = WC3_DEFAULT_HEIGHT; [[wc3]]->palettes = NULL; [[wc3]]->palette_count = 0; [[wc3]]->pts = 0; [[wc3]]->video_stream_index = [[wc3]]->audio_stream_index = 0; url_fseek(pb, 12, SEEK_CUR); if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); fourcc_tag = AV_RL32(&preamble[0]); size = (AV_RB32(&preamble[4]) + 1) & (~1); do { switch (fourcc_tag) { case SOND_TAG: case INDX_TAG: url_fseek(pb, size, SEEK_CUR); break; case _PC__TAG: url_fseek(pb, 8, SEEK_CUR); if ((ret = get_buffer(pb, preamble, 4)) != 4) return AVERROR(EIO); [[wc3]]->palette_count = AV_RL32(&preamble[0]); if((unsigned)[[wc3]]->palette_count >= UINT_MAX / PALETTE_SIZE){ [[wc3]]->palette_count= 0; return -1; } [[wc3]]->palettes = av_malloc([[wc3]]->palette_count * PALETTE_SIZE); break; case BNAM_TAG: if ((unsigned)size < 512) bytes_to_read = size; else bytes_to_read = 512; if ((ret = get_buffer(pb, s->title, bytes_to_read)) != bytes_to_read) return AVERROR(EIO); break; case SIZE_TAG: if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); [[wc3]]->width = AV_RL32(&preamble[0]); [[wc3]]->height = AV_RL32(&preamble[4]); break; case PALT_TAG: if ((unsigned)current_palette >= [[wc3]]->palette_count) return AVERROR_INVALIDDATA; if ((ret = get_buffer(pb, &[[wc3]]->palettes[current_palette * PALETTE_SIZE], PALETTE_SIZE)) != PALETTE_SIZE) return AVERROR(EIO); for (i = current_palette * PALETTE_SIZE; i < (current_palette + 1) * PALETTE_SIZE; i++) { rotate = (([[wc3]]->palettes[i] << 2) & 0xFF) | (([[wc3]]->palettes[i] >> 6) & 0xFF); [[wc3]]->palettes[i] = wc3_pal_lookup[rotate]; } current_palette++; break; default: av_log(s, AV_LOG_ERROR, " unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\n", preamble[0], preamble[1], preamble[2], preamble[3], preamble[0], preamble[1], preamble[2], preamble[3]); return AVERROR_INVALIDDATA; break; } if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); fourcc_tag = AV_RL32(&preamble[0]); size = (AV_RB32(&preamble[4]) + 1) & (~1); } while (fourcc_tag != BRCH_TAG); st = av_new_stream(s, 0); if (!st) return AVERROR(ENOMEM); av_set_pts_info(st, 33, 1, 90000); [[wc3]]->video_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_VIDEO; st->codec->codec_id = CODEC_ID_XAN_WC3; st->codec->codec_tag = 0; st->codec->width = [[wc3]]->width; st->codec->height = [[wc3]]->height; st->codec->palctrl = &[[wc3]]->palette_control; st = av_new_stream(s, 0); if (!st) return AVERROR(ENOMEM); av_set_pts_info(st, 33, 1, 90000); [[wc3]]->audio_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_PCM_S16LE; st->codec->codec_tag = 1; st->codec->channels = WC3_AUDIO_CHANNELS; st->codec->bits_per_sample = WC3_AUDIO_BITS; st->codec->sample_rate = WC3_SAMPLE_RATE; st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_sample; st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS; return 0; }

[[[[Adv]]]]: static int wc3_read_header(AVFormatContext *s, AVFormatParameters *ap) { Wc3DemuxContext *[[fra]] = s->priv_data; ByteIOContext *pb = s->pb; unsigned int fourcc_tag; unsigned int size; AVStream *st; unsigned char preamble[WC3_PREAMBLE_SIZE]; int ret = 0; int current_palette = 0; int bytes_to_read; int i; unsigned char rotate; [[fra]]->width = WC3_DEFAULT_WIDTH; [[fra]]->height = WC3_DEFAULT_HEIGHT; [[fra]]->palettes = NULL; [[fra]]->palette_count = 0; [[fra]]->pts = 0; [[fra]]->video_stream_index = [[fra]]->audio_stream_index = 0; url_fseek(pb, 12, SEEK_CUR); if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); fourcc_tag = AV_RL32(&preamble[0]); size = (AV_RB32(&preamble[4]) + 1) & (~1); do { switch (fourcc_tag) { case SOND_TAG: case INDX_TAG: url_fseek(pb, size, SEEK_CUR); break; case _PC__TAG: url_fseek(pb, 8, SEEK_CUR); if ((ret = get_buffer(pb, preamble, 4)) != 4) return AVERROR(EIO); [[fra]]->palette_count = AV_RL32(&preamble[0]); if((unsigned)[[fra]]->palette_count >= UINT_MAX / PALETTE_SIZE){ [[fra]]->palette_count= 0; return -1; } [[fra]]->palettes = av_malloc([[fra]]->palette_count * PALETTE_SIZE); break; case BNAM_TAG: if ((unsigned)size < 512) bytes_to_read = size; else bytes_to_read = 512; if ((ret = get_buffer(pb, s->title, bytes_to_read)) != bytes_to_read) return AVERROR(EIO); break; case SIZE_TAG: if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); [[fra]]->width = AV_RL32(&preamble[0]); [[fra]]->height = AV_RL32(&preamble[4]); break; case PALT_TAG: if ((unsigned)current_palette >= [[fra]]->palette_count) return AVERROR_INVALIDDATA; if ((ret = get_buffer(pb, &[[fra]]->palettes[current_palette * PALETTE_SIZE], PALETTE_SIZE)) != PALETTE_SIZE) return AVERROR(EIO); for (i = current_palette * PALETTE_SIZE; i < (current_palette + 1) * PALETTE_SIZE; i++) { rotate = (([[fra]]->palettes[i] << 2) & 0xFF) | (([[fra]]->palettes[i] >> 6) & 0xFF); [[fra]]->palettes[i] = wc3_pal_lookup[rotate]; } current_palette++; break; default: av_log(s, AV_LOG_ERROR, " unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\n", preamble[0], preamble[1], preamble[2], preamble[3], preamble[0], preamble[1], preamble[2], preamble[3]); return AVERROR_INVALIDDATA; break; } if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); fourcc_tag = AV_RL32(&preamble[0]); size = (AV_RB32(&preamble[4]) + 1) & (~1); } while (fourcc_tag != BRCH_TAG); st = av_new_stream(s, 0); if (!st) return AVERROR(ENOMEM); av_set_pts_info(st, 33, 1, 90000); [[fra]]->video_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_VIDEO; st->codec->codec_id = CODEC_ID_XAN_WC3; st->codec->codec_tag = 0; st->codec->width = [[fra]]->width; st->codec->height = [[fra]]->height; st->codec->palctrl = &[[fra]]->palette_control; st = av_new_stream(s, 0); if (!st) return AVERROR(ENOMEM); av_set_pts_info(st, 33, 1, 90000); [[fra]]->audio_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_PCM_S16LE; st->codec->codec_tag = 1; st->codec->channels = WC3_AUDIO_CHANNELS; st->codec->bits_per_sample = WC3_AUDIO_BITS; st->codec->sample_rate = WC3_SAMPLE_RATE; st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_sample; st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS; return 0; }
--------------------------------------------- Result 828 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 432 / 93 / 303 / 828:  31%|███       | 828/2690 [2:06:47<4:45:06,  9.19s/it][Succeeded / Failed / Skipped / Total] 432 / 93 / 303 / 828:  31%|███       | 829/2690 [2:07:06<4:45:19,  9.20s/it][Succeeded / Failed / Skipped / Total] 433 / 93 / 303 / 829:  31%|███       | 829/2690 [2:07:06<4:45:19,  9.20s/it][Succeeded / Failed / Skipped / Total] 433 / 93 / 303 / 829:  31%|███       | 830/2690 [2:07:06<4:44:51,  9.19s/it][[0 (41%)]] --> [[0 (64%)]] --> Socre: 0.6387940645217896

[[[[Adv]]]]: static inline int onenand_erase(OneNANDState *s, int sec, int num) { uint8_t *blankbuf, *tmpbuf; blankbuf = g_malloc(512); if (!blankbuf) { return 1; } tmpbuf = g_malloc(512); if (!tmpbuf) { g_free(blankbuf); return 1; } memset(blankbuf, 0xff, 512); for (; num > 0; num--, sec++) { if (s->bdrv_cur) { int [[erasesec]] = s->secs_cur + (sec >> 5); if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) { goto fail; } if (bdrv_read(s->bdrv_cur, [[erasesec]], tmpbuf, 1) < 0) { goto fail; } memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4); if (bdrv_write(s->bdrv_cur, [[erasesec]], tmpbuf, 1) < 0) { goto fail; } } else { if (sec + 1 > s->secs_cur) { goto fail; } memcpy(s->current + (sec << 9), blankbuf, 512); memcpy(s->current + (s->secs_cur << 9) + (sec << 4), blankbuf, 1 << 4); } } g_free(tmpbuf); g_free(blankbuf); return 0; fail: g_free(tmpbuf); g_free(blankbuf); return 1; }

[[[[Adv]]]]: static inline int onenand_erase(OneNANDState *s, int sec, int num) { uint8_t *blankbuf, *tmpbuf; blankbuf = g_malloc(512); if (!blankbuf) { return 1; } tmpbuf = g_malloc(512); if (!tmpbuf) { g_free(blankbuf); return 1; } memset(blankbuf, 0xff, 512); for (; num > 0; num--, sec++) { if (s->bdrv_cur) { int [[chalknseu]] = s->secs_cur + (sec >> 5); if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) { goto fail; } if (bdrv_read(s->bdrv_cur, [[chalknseu]], tmpbuf, 1) < 0) { goto fail; } memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4); if (bdrv_write(s->bdrv_cur, [[chalknseu]], tmpbuf, 1) < 0) { goto fail; } } else { if (sec + 1 > s->secs_cur) { goto fail; } memcpy(s->current + (sec << 9), blankbuf, 512); memcpy(s->current + (s->secs_cur << 9) + (sec << 4), blankbuf, 1 << 4); } } g_free(tmpbuf); g_free(blankbuf); return 0; fail: g_free(tmpbuf); g_free(blankbuf); return 1; }
--------------------------------------------- Result 829 ---------------------------------------------
[[0 (60%)]] --> [[0 (41%)]] --> Socre: 0.5886987745761871

[[[[Adv]]]]: static int vmdk_parse_extents(const char *[[desc]], BlockDriverState *bs, const char *desc_file_path, Error **errp) { int ret; char access[11]; char type[11]; char fname[512]; const char *p = [[desc]]; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; BDRVVmdkState *s = bs->opaque; VmdkExtent *extent; while (*p) { flat_offset = -1; ret = sscanf(p, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if (ret != 5 || flat_offset < 0) { error_setg(errp, "Invalid extent lines: \n%s", p); return -EINVAL; } } else if (!strcmp(type, "VMFS")) { if (ret == 4) { flat_offset = 0; } else { error_setg(errp, "Invalid extent lines:\n%s", p); return -EINVAL; } } else if (ret != 4) { error_setg(errp, "Invalid extent lines:\n%s", p); return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); extent_file = NULL; ret = bdrv_open(&extent_file, extent_path, NULL, NULL, bs->open_flags | BDRV_O_PROTOCOL, NULL, errp); if (ret) { return ret; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { ret = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, 0, &extent, errp); if (ret < 0) { return ret; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { char *buf = vmdk_read_desc(extent_file, 0, errp); if (!buf) { ret = -EINVAL; } else { ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp); } if (ret) { g_free(buf); return ret; } extent = &s->extents[s->num_extents - 1]; } else { error_setg(errp, "Unsupported extent type '%s'", type); return -ENOTSUP; } extent->type = g_strdup(type); next_line: while (*p) { if (*p == '\n') { p++; break; } p++; } } return 0; }

[[[[Adv]]]]: static int vmdk_parse_extents(const char *[[insct]], BlockDriverState *bs, const char *desc_file_path, Error **errp) { int ret; char access[11]; char type[11]; char fname[512]; const char *p = [[insct]]; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; BDRVVmdkState *s = bs->opaque; VmdkExtent *extent; while (*p) { flat_offset = -1; ret = sscanf(p, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if (ret != 5 || flat_offset < 0) { error_setg(errp, "Invalid extent lines: \n%s", p); return -EINVAL; } } else if (!strcmp(type, "VMFS")) { if (ret == 4) { flat_offset = 0; } else { error_setg(errp, "Invalid extent lines:\n%s", p); return -EINVAL; } } else if (ret != 4) { error_setg(errp, "Invalid extent lines:\n%s", p); return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); extent_file = NULL; ret = bdrv_open(&extent_file, extent_path, NULL, NULL, bs->open_flags | BDRV_O_PROTOCOL, NULL, errp); if (ret) { return ret; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { ret = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, 0, &extent, errp); if (ret < 0) { return ret; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { char *buf = vmdk_read_desc(extent_file, 0, errp); if (!buf) { ret = -EINVAL; } else { ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp); } if (ret) { g_free(buf); return ret; } extent = &s->extents[s->num_extents - 1]; } else { error_setg(errp, "Unsupported extent type '%s'", type); return -ENOTSUP; } extent->type = g_strdup(type); next_line: while (*p) { if (*p == '\n') { p++; break; } p++; } } return 0; }
--------------------------------------------- Result 830 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 433 / 93 / 304 / 830:  31%|███       | 830/2690 [2:07:06<4:44:51,  9.19s/it][Succeeded / Failed / Skipped / Total] 433 / 93 / 304 / 830:  31%|███       | 831/2690 [2:07:39<4:45:33,  9.22s/it][[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline int check_input_motion(MpegEncContext * s, int mb_x, int mb_y, int p_type){ MotionEstContext * const c= &s->me; Picture *p= s->current_picture_ptr; int mb_xy= mb_x + mb_y*s->mb_stride; int xy= 2*mb_x + 2*mb_y*s->b8_stride; int mb_type= s->current_picture.mb_type[mb_xy]; int flags= c->flags; int shift= (flags&FLAG_QPEL) + 1; int mask= (1<<shift)-1; int x, y, i; int d=0; me_cmp_func cmpf= s->dsp.sse[0]; me_cmp_func chroma_cmpf= s->dsp.sse[1]; assert(p_type==0 || !USES_LIST(mb_type, 1)); assert(IS_INTRA(mb_type) || USES_LIST(mb_type,0) || USES_LIST(mb_type,1)); if(IS_INTERLACED(mb_type)){ int xy2= xy + s->b8_stride; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA; c->stride<<=1; c->uvstride<<=1; init_interlaced_ref(s, 2); assert(s->flags & CODEC_FLAG_INTERLACED_ME); if(USES_LIST(mb_type, 0)){ int field_select0= p->ref_index[0][xy ]; int field_select1= p->ref_index[0][xy2]; assert(field_select0==0 ||field_select0==1); assert(field_select1==0 ||field_select1==1); if(p_type){ s->p_field_select_table[0][mb_xy]= field_select0; s->p_field_select_table[1][mb_xy]= field_select1; *(uint32_t*)s->p_field_mv_table[0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ]; *(uint32_t*)s->p_field_mv_table[1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER_I; }else{ s->b_field_select_table[0][0][mb_xy]= field_select0; s->b_field_select_table[0][1][mb_xy]= field_select1; *(uint32_t*)s->b_field_mv_table[0][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ]; *(uint32_t*)s->b_field_mv_table[0][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2]; s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_FORWARD_I; } x= p->motion_val[0][xy ][0]; y= p->motion_val[0][xy ][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0, 0, cmpf, chroma_cmpf, flags); x= p->motion_val[0][xy2][0]; y= p->motion_val[0][xy2][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1, 1, cmpf, chroma_cmpf, flags); } if(USES_LIST(mb_type, 1)){ int field_select0= p->ref_index[1][xy ]; int field_select1= p->ref_index[1][xy2]; assert(field_select0==0 ||field_select0==1); assert(field_select1==0 ||field_select1==1); s->b_field_select_table[1][0][mb_xy]= field_select0; s->b_field_select_table[1][1][mb_xy]= field_select1; *(uint32_t*)s->b_field_mv_table[1][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[1][xy ]; *(uint32_t*)s->b_field_mv_table[1][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[1][xy2]; if(USES_LIST(mb_type, 0)){ s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BIDIR_I; }else{ s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BACKWARD_I; } x= p->motion_val[1][xy ][0]; y= p->motion_val[1][xy ][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0+2, 0, cmpf, chroma_cmpf, flags); x= p->motion_val[1][xy2][0]; y= p->motion_val[1][xy2][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1+2, 1, cmpf, chroma_cmpf, flags); } c->stride>>=1; c->uvstride>>=1; }else if(IS_8X8(mb_type)){ cmpf= s->dsp.sse[1]; chroma_cmpf= s->dsp.sse[1]; init_mv4_ref(s); for(i=0; i<4; i++){ xy= s->block_index[i]; x= p->motion_val[0][xy][0]; y= p->motion_val[0][xy][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 1, 8, i, i, cmpf, chroma_cmpf, flags); } s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER4V; }else{ if(USES_LIST(mb_type, 0)){ if(p_type){ *(uint32_t*)s->p_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER; }else if(USES_LIST(mb_type, 1)){ *(uint32_t*)s->b_bidir_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy]; *(uint32_t*)s->b_bidir_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BIDIR; }else{ *(uint32_t*)s->b_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_FORWARD; } x= p->motion_val[0][xy][0]; y= p->motion_val[0][xy][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 0, 0, cmpf, chroma_cmpf, flags); }else if(USES_LIST(mb_type, 1)){ *(uint32_t*)s->b_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BACKWARD; x= p->motion_val[1][xy][0]; y= p->motion_val[1][xy][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 2, 0, cmpf, chroma_cmpf, flags); }else s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA; } return d; }
--------------------------------------------- Result 831 ---------------------------------------------
[[0 (44%)]] --> [[0 (98%)]] --> Socre: 0.98206627368927

[[[[Adv]]]]: void ff_estimate_p_frame_motion(MpegEncContext * s, int mb_x, int mb_y) { UINT8 *pix, *ppix; int sum, varc, vard, mx, my, range, dmin, xx, yy; int xmin, ymin, xmax, ymax; int rel_xmin, rel_ymin, rel_xmax, rel_ymax; int pred_x=0, pred_y=0; int P[6][2]; const int shift= 1+s->quarter_sample; int mb_type=0; uint8_t *ref_picture= s->last_picture[0]; get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code); switch(s->me_method) { case ME_ZERO: default: no_motion_search(s, &mx, &my); dmin = 0; break; case ME_FULL: dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture); break; case ME_LOG: dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture); break; case ME_PHODS: dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture); break; case ME_X1: case ME_EPZS: { const int [[mot_stride]] = s->block_wrap[0]; const int mot_xy = s->block_index[0]; rel_xmin= xmin - mb_x*16; rel_xmax= xmax - mb_x*16; rel_ymin= ymin - mb_y*16; rel_ymax= ymax - mb_y*16; P[0][0] = s->motion_val[mot_xy ][0]; P[0][1] = s->motion_val[mot_xy ][1]; P[1][0] = s->motion_val[mot_xy - 1][0]; P[1][1] = s->motion_val[mot_xy - 1][1]; if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift); if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motion_val[mot_xy - [[mot_stride]] ][0]; P[2][1] = s->motion_val[mot_xy - [[mot_stride]] ][1]; P[3][0] = s->motion_val[mot_xy - [[mot_stride]] + 2 ][0]; P[3][1] = s->motion_val[mot_xy - [[mot_stride]] + 2 ][1]; if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift); if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift); if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift); P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]); P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]); } if(s->out_format == FMT_H263){ pred_x = P[4][0]; pred_y = P[4][1]; }else { pred_x= P[1][0]; pred_y= P[1][1]; } } dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture); mx+= mb_x*16; my+= mb_y*16; break; } if(s->flags&CODEC_FLAG_4MV){ int block; mb_type|= MB_TYPE_INTER4V; for(block=0; block<4; block++){ int mx4, my4; int pred_x4, pred_y4; int dmin4; static const int off[4]= {2, 1, 1, -1}; const int [[mot_stride]] = s->block_wrap[0]; const int mot_xy = s->block_index[block]; const int block_x= mb_x*2 + (block&1); const int block_y= mb_y*2 + (block>>1); const int rel_xmin4= xmin - block_x*8; const int rel_xmax4= xmax - block_x*8 + 8; const int rel_ymin4= ymin - block_y*8; const int rel_ymax4= ymax - block_y*8 + 8; P[0][0] = s->motion_val[mot_xy ][0]; P[0][1] = s->motion_val[mot_xy ][1]; P[1][0] = s->motion_val[mot_xy - 1][0]; P[1][1] = s->motion_val[mot_xy - 1][1]; if(P[1][0] > (rel_xmax4<<shift)) P[1][0]= (rel_xmax4<<shift); if ((mb_y == 0 || s->first_slice_line || s->first_gob_line) && block<2) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motion_val[mot_xy - [[mot_stride]] ][0]; P[2][1] = s->motion_val[mot_xy - [[mot_stride]] ][1]; P[3][0] = s->motion_val[mot_xy - [[mot_stride]] + off[block]][0]; P[3][1] = s->motion_val[mot_xy - [[mot_stride]] + off[block]][1]; if(P[2][1] > (rel_ymax4<<shift)) P[2][1]= (rel_ymax4<<shift); if(P[3][0] < (rel_xmin4<<shift)) P[3][0]= (rel_xmin4<<shift); if(P[3][0] > (rel_xmax4<<shift)) P[3][0]= (rel_xmax4<<shift); if(P[3][1] > (rel_ymax4<<shift)) P[3][1]= (rel_ymax4<<shift); P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]); P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]); } if(s->out_format == FMT_H263){ pred_x4 = P[4][0]; pred_y4 = P[4][1]; }else { pred_x4= P[1][0]; pred_y4= P[1][1]; } P[5][0]= mx - mb_x*16; P[5][1]= my - mb_y*16; dmin4 = epzs_motion_search4(s, block, &mx4, &my4, P, pred_x4, pred_y4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, ref_picture); halfpel_motion_search4(s, &mx4, &my4, dmin4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, pred_x4, pred_y4, block_x, block_y, ref_picture); s->motion_val[ s->block_index[block] ][0]= mx4; s->motion_val[ s->block_index[block] ][1]= my4; } } xx = mb_x * 16; yy = mb_y * 16; pix = s->new_picture[0] + (yy * s->linesize) + xx; ppix = ref_picture + (my * s->linesize) + mx; sum = pix_sum(pix, s->linesize); #if 0 varc = pix_dev(pix, s->linesize, (sum+128)>>8) + INTER_BIAS; vard = pix_abs16x16(pix, ppix, s->linesize); #else sum= (sum+8)>>4; varc = ((pix_norm1(pix, s->linesize) - sum*sum + 128 + 500)>>8); vard = (pix_norm(pix, ppix, s->linesize)+128)>>8; #endif s->mb_var[s->mb_width * mb_y + mb_x] = varc; s->avg_mb_var+= varc; s->mc_mb_var += vard; #if 0 printf("varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\n", varc, s->avg_mb_var, sum, vard, mx - xx, my - yy); #endif if(s->flags&CODEC_FLAG_HQ){ if (vard*2 + 200 > varc) mb_type|= MB_TYPE_INTRA; if (varc*2 + 200 > vard){ mb_type|= MB_TYPE_INTER; halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture); }else{ mx = mx*2 - mb_x*32; my = my*2 - mb_y*32; } }else{ if (vard <= 64 || vard < varc) { mb_type|= MB_TYPE_INTER; if (s->me_method != ME_ZERO) { halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture); } else { mx -= 16 * mb_x; my -= 16 * mb_y; } #if 0 if (vard < 10) { skip++; fprintf(stderr,"\nEarly skip: %d vard: %2d varc: %5d dmin: %d", skip, vard, varc, dmin); } #endif }else{ mb_type|= MB_TYPE_INTRA; mx = 0; my = 0; } } s->mb_type[mb_y*s->mb_width + mb_x]= mb_type; set_p_mv_tables(s, mx, my); }

[[[[Adv]]]]: void ff_estimate_p_frame_motion(MpegEncContext * s, int mb_x, int mb_y) { UINT8 *pix, *ppix; int sum, varc, vard, mx, my, range, dmin, xx, yy; int xmin, ymin, xmax, ymax; int rel_xmin, rel_ymin, rel_xmax, rel_ymax; int pred_x=0, pred_y=0; int P[6][2]; const int shift= 1+s->quarter_sample; int mb_type=0; uint8_t *ref_picture= s->last_picture[0]; get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code); switch(s->me_method) { case ME_ZERO: default: no_motion_search(s, &mx, &my); dmin = 0; break; case ME_FULL: dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture); break; case ME_LOG: dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture); break; case ME_PHODS: dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture); break; case ME_X1: case ME_EPZS: { const int [[panтandnext]] = s->block_wrap[0]; const int mot_xy = s->block_index[0]; rel_xmin= xmin - mb_x*16; rel_xmax= xmax - mb_x*16; rel_ymin= ymin - mb_y*16; rel_ymax= ymax - mb_y*16; P[0][0] = s->motion_val[mot_xy ][0]; P[0][1] = s->motion_val[mot_xy ][1]; P[1][0] = s->motion_val[mot_xy - 1][0]; P[1][1] = s->motion_val[mot_xy - 1][1]; if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift); if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motion_val[mot_xy - [[panтandnext]] ][0]; P[2][1] = s->motion_val[mot_xy - [[panтandnext]] ][1]; P[3][0] = s->motion_val[mot_xy - [[panтandnext]] + 2 ][0]; P[3][1] = s->motion_val[mot_xy - [[panтandnext]] + 2 ][1]; if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift); if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift); if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift); P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]); P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]); } if(s->out_format == FMT_H263){ pred_x = P[4][0]; pred_y = P[4][1]; }else { pred_x= P[1][0]; pred_y= P[1][1]; } } dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture); mx+= mb_x*16; my+= mb_y*16; break; } if(s->flags&CODEC_FLAG_4MV){ int block; mb_type|= MB_TYPE_INTER4V; for(block=0; block<4; block++){ int mx4, my4; int pred_x4, pred_y4; int dmin4; static const int off[4]= {2, 1, 1, -1}; const int [[panтandnext]] = s->block_wrap[0]; const int mot_xy = s->block_index[block]; const int block_x= mb_x*2 + (block&1); const int block_y= mb_y*2 + (block>>1); const int rel_xmin4= xmin - block_x*8; const int rel_xmax4= xmax - block_x*8 + 8; const int rel_ymin4= ymin - block_y*8; const int rel_ymax4= ymax - block_y*8 + 8; P[0][0] = s->motion_val[mot_xy ][0]; P[0][1] = s->motion_val[mot_xy ][1]; P[1][0] = s->motion_val[mot_xy - 1][0]; P[1][1] = s->motion_val[mot_xy - 1][1]; if(P[1][0] > (rel_xmax4<<shift)) P[1][0]= (rel_xmax4<<shift); if ((mb_y == 0 || s->first_slice_line || s->first_gob_line) && block<2) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motion_val[mot_xy - [[panтandnext]] ][0]; P[2][1] = s->motion_val[mot_xy - [[panтandnext]] ][1]; P[3][0] = s->motion_val[mot_xy - [[panтandnext]] + off[block]][0]; P[3][1] = s->motion_val[mot_xy - [[panтandnext]] + off[block]][1]; if(P[2][1] > (rel_ymax4<<shift)) P[2][1]= (rel_ymax4<<shift); if(P[3][0] < (rel_xmin4<<shift)) P[3][0]= (rel_xmin4<<shift); if(P[3][0] > (rel_xmax4<<shift)) P[3][0]= (rel_xmax4<<shift); if(P[3][1] > (rel_ymax4<<shift)) P[3][1]= (rel_ymax4<<shift); P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]); P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]); } if(s->out_format == FMT_H263){ pred_x4 = P[4][0]; pred_y4 = P[4][1]; }else { pred_x4= P[1][0]; pred_y4= P[1][1]; } P[5][0]= mx - mb_x*16; P[5][1]= my - mb_y*16; dmin4 = epzs_motion_search4(s, block, &mx4, &my4, P, pred_x4, pred_y4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, ref_picture); halfpel_motion_search4(s, &mx4, &my4, dmin4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, pred_x4, pred_y4, block_x, block_y, ref_picture); s->motion_val[ s->block_index[block] ][0]= mx4; s->motion_val[ s->block_index[block] ][1]= my4; } } xx = mb_x * 16; yy = mb_y * 16; pix = s->new_picture[0] + (yy * s->linesize) + xx; ppix = ref_picture + (my * s->linesize) + mx; sum = pix_sum(pix, s->linesize); #if 0 varc = pix_dev(pix, s->linesize, (sum+128)>>8) + INTER_BIAS; vard = pix_abs16x16(pix, ppix, s->linesize); #else sum= (sum+8)>>4; varc = ((pix_norm1(pix, s->linesize) - sum*sum + 128 + 500)>>8); vard = (pix_norm(pix, ppix, s->linesize)+128)>>8; #endif s->mb_var[s->mb_width * mb_y + mb_x] = varc; s->avg_mb_var+= varc; s->mc_mb_var += vard; #if 0 printf("varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\n", varc, s->avg_mb_var, sum, vard, mx - xx, my - yy); #endif if(s->flags&CODEC_FLAG_HQ){ if (vard*2 + 200 > varc) mb_type|= MB_TYPE_INTRA; if (varc*2 + 200 > vard){ mb_type|= MB_TYPE_INTER; halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture); }else{ mx = mx*2 - mb_x*32; my = my*2 - mb_y*32; } }else{ if (vard <= 64 || vard < varc) { mb_type|= MB_TYPE_INTER; if (s->me_method != ME_ZERO) { halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture); } else { mx -= 16 * mb_x; my -= 16 * mb_y; } #if 0 if (vard < 10) { skip++; fprintf(stderr,"\nEarly skip: %d vard: %2d varc: %5d dmin: %d", skip, vard, varc, dmin); } #endif }else{ mb_type|= MB_TYPE_INTRA; mx = 0; my = 0; } } s->mb_type[mb_y*s->mb_width + mb_x]= mb_type; set_p_mv_tables(s, mx, my); }[Succeeded / Failed / Skipped / Total] 434 / 93 / 304 / 831:  31%|███       | 831/2690 [2:07:39<4:45:33,  9.22s/it][Succeeded / Failed / Skipped / Total] 434 / 93 / 304 / 831:  31%|███       | 832/2690 [2:07:45<4:45:18,  9.21s/it][Succeeded / Failed / Skipped / Total] 434 / 94 / 304 / 832:  31%|███       | 832/2690 [2:07:45<4:45:18,  9.21s/it][Succeeded / Failed / Skipped / Total] 434 / 94 / 304 / 832:  31%|███       | 833/2690 [2:08:01<4:45:24,  9.22s/it][Succeeded / Failed / Skipped / Total] 435 / 94 / 304 / 833:  31%|███       | 833/2690 [2:08:01<4:45:24,  9.22s/it][Succeeded / Failed / Skipped / Total] 435 / 94 / 304 / 833:  31%|███       | 834/2690 [2:08:04<4:45:00,  9.21s/it][Succeeded / Failed / Skipped / Total] 436 / 94 / 304 / 834:  31%|███       | 834/2690 [2:08:04<4:45:00,  9.21s/it][Succeeded / Failed / Skipped / Total] 436 / 94 / 304 / 834:  31%|███       | 835/2690 [2:08:09<4:44:43,  9.21s/it][Succeeded / Failed / Skipped / Total] 437 / 94 / 304 / 835:  31%|███       | 835/2690 [2:08:09<4:44:43,  9.21s/it][Succeeded / Failed / Skipped / Total] 437 / 94 / 304 / 835:  31%|███       | 836/2690 [2:08:24<4:44:46,  9.22s/it]
--------------------------------------------- Result 832 ---------------------------------------------
[[0 (78%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int check_refcounts_l1(BlockDriverState *[[bs]], BdrvCheckResult *res, uint16_t **refcount_table, int64_t *refcount_table_size, int64_t l1_table_offset, int l1_size, int [[flags]]) { BDRVQcowState *[[s]] = [[bs]]->opaque; uint64_t *[[l1_table]] = NULL, l2_offset, l1_size2; int [[i]], ret; l1_size2 = l1_size * sizeof(uint64_t); ret = inc_refcounts([[bs]], res, refcount_table, refcount_table_size, l1_table_offset, l1_size2); if (ret < 0) { goto fail; } if (l1_size2 > 0) { [[l1_table]] = g_try_malloc(l1_size2); if ([[l1_table]] == NULL) { ret = -ENOMEM; res->check_errors++; goto fail; } ret = bdrv_pread([[bs]]->file, l1_table_offset, [[l1_table]], l1_size2); if (ret < 0) { fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n"); res->check_errors++; goto fail; } for([[i]] = 0;[[i]] < l1_size; [[i]]++) be64_to_cpus(&[[l1_table]][[[i]]]); } for([[i]] = 0; [[i]] < l1_size; [[i]]++) { l2_offset = [[l1_table]][[[i]]]; if (l2_offset) { l2_offset &= L1E_OFFSET_MASK; ret = inc_refcounts([[bs]], res, refcount_table, refcount_table_size, l2_offset, [[s]]->cluster_size); if (ret < 0) { goto fail; } if (offset_into_cluster([[s]], l2_offset)) { fprintf(stderr, "ERROR l2_offset=%" PRIx64 ": Table is not " "cluster aligned; L1 entry corrupted\n", l2_offset); res->corruptions++; } ret = check_refcounts_l2([[bs]], res, refcount_table, refcount_table_size, l2_offset, [[flags]]); if (ret < 0) { goto fail; } } } g_free([[l1_table]]); return 0; fail: g_free([[l1_table]]); return ret; }

[[[[Adv]]]]: static int check_refcounts_l1(BlockDriverState *[[cox]], BdrvCheckResult *res, uint16_t **refcount_table, int64_t *refcount_table_size, int64_t l1_table_offset, int l1_size, int [[variables]]) { BDRVQcowState *[[scale]] = [[cox]]->opaque; uint64_t *[[lp0_desk]] = NULL, l2_offset, l1_size2; int [[iii]], ret; l1_size2 = l1_size * sizeof(uint64_t); ret = inc_refcounts([[cox]], res, refcount_table, refcount_table_size, l1_table_offset, l1_size2); if (ret < 0) { goto fail; } if (l1_size2 > 0) { [[lp0_desk]] = g_try_malloc(l1_size2); if ([[lp0_desk]] == NULL) { ret = -ENOMEM; res->check_errors++; goto fail; } ret = bdrv_pread([[cox]]->file, l1_table_offset, [[lp0_desk]], l1_size2); if (ret < 0) { fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n"); res->check_errors++; goto fail; } for([[iii]] = 0;[[iii]] < l1_size; [[iii]]++) be64_to_cpus(&[[lp0_desk]][[[iii]]]); } for([[iii]] = 0; [[iii]] < l1_size; [[iii]]++) { l2_offset = [[lp0_desk]][[[iii]]]; if (l2_offset) { l2_offset &= L1E_OFFSET_MASK; ret = inc_refcounts([[cox]], res, refcount_table, refcount_table_size, l2_offset, [[scale]]->cluster_size); if (ret < 0) { goto fail; } if (offset_into_cluster([[scale]], l2_offset)) { fprintf(stderr, "ERROR l2_offset=%" PRIx64 ": Table is not " "cluster aligned; L1 entry corrupted\n", l2_offset); res->corruptions++; } ret = check_refcounts_l2([[cox]], res, refcount_table, refcount_table_size, l2_offset, [[variables]]); if (ret < 0) { goto fail; } } } g_free([[lp0_desk]]); return 0; fail: g_free([[lp0_desk]]); return ret; }
--------------------------------------------- Result 833 ---------------------------------------------
[[0 (87%)]] --> [[0 (48%)]] --> Socre: 0.5161719918251038

[[[[Adv]]]]: static int default_lockmgr_cb(void **[[arg]], enum AVLockOp op) { void * volatile * [[mutex]] = [[arg]]; int err; switch (op) { case AV_LOCK_CREATE: return 0; case AV_LOCK_OBTAIN: if (!*[[mutex]]) { pthread_mutex_t *[[tmp]] = av_malloc(sizeof(pthread_mutex_t)); if (![[tmp]]) return AVERROR(ENOMEM); if ((err = pthread_mutex_init([[tmp]], NULL))) { av_free([[tmp]]); return AVERROR(err); } if (avpriv_atomic_ptr_cas([[mutex]], NULL, [[tmp]])) { pthread_mutex_destroy([[tmp]]); av_free([[tmp]]); } } if ((err = pthread_mutex_lock(*[[mutex]]))) return AVERROR(err); return 0; case AV_LOCK_RELEASE: if ((err = pthread_mutex_unlock(*[[mutex]]))) return AVERROR(err); return 0; case AV_LOCK_DESTROY: if (*[[mutex]]) pthread_mutex_destroy(*[[mutex]]); av_free(*[[mutex]]); avpriv_atomic_ptr_cas([[mutex]], *[[mutex]], NULL); return 0; } return 1; }

[[[[Adv]]]]: static int default_lockmgr_cb(void **[[bgp]], enum AVLockOp op) { void * volatile * [[noc]] = [[bgp]]; int err; switch (op) { case AV_LOCK_CREATE: return 0; case AV_LOCK_OBTAIN: if (!*[[noc]]) { pthread_mutex_t *[[aslink]] = av_malloc(sizeof(pthread_mutex_t)); if (![[aslink]]) return AVERROR(ENOMEM); if ((err = pthread_mutex_init([[aslink]], NULL))) { av_free([[aslink]]); return AVERROR(err); } if (avpriv_atomic_ptr_cas([[noc]], NULL, [[aslink]])) { pthread_mutex_destroy([[aslink]]); av_free([[aslink]]); } } if ((err = pthread_mutex_lock(*[[noc]]))) return AVERROR(err); return 0; case AV_LOCK_RELEASE: if ((err = pthread_mutex_unlock(*[[noc]]))) return AVERROR(err); return 0; case AV_LOCK_DESTROY: if (*[[noc]]) pthread_mutex_destroy(*[[noc]]); av_free(*[[noc]]); avpriv_atomic_ptr_cas([[noc]], *[[noc]], NULL); return 0; } return 1; }
--------------------------------------------- Result 834 ---------------------------------------------
[[0 (41%)]] --> [[0 (60%)]] --> Socre: 0.5993169546127319

[[[[Adv]]]]: av_cold int ff_vaapi_encode_close(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->priv_data; VAAPIEncodePicture *[[pic]], *next; for ([[pic]] = ctx->pic_start; [[pic]]; [[pic]] = next) { next = [[pic]]->next; vaapi_encode_free(avctx, [[pic]]); } if (ctx->va_context != VA_INVALID_ID) { vaDestroyContext(ctx->hwctx->display, ctx->va_context); ctx->va_context = VA_INVALID_ID; } if (ctx->va_config != VA_INVALID_ID) { vaDestroyConfig(ctx->hwctx->display, ctx->va_config); ctx->va_config = VA_INVALID_ID; } if (ctx->codec->close) ctx->codec->close(avctx); av_buffer_pool_uninit(&ctx->output_buffer_pool); av_freep(&ctx->codec_sequence_params); av_freep(&ctx->codec_picture_params); av_buffer_unref(&ctx->recon_frames_ref); av_buffer_unref(&ctx->input_frames_ref); av_buffer_unref(&ctx->device_ref); av_freep(&ctx->priv_data); return 0; }

[[[[Adv]]]]: av_cold int ff_vaapi_encode_close(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->priv_data; VAAPIEncodePicture *[[vic]], *next; for ([[vic]] = ctx->pic_start; [[vic]]; [[vic]] = next) { next = [[vic]]->next; vaapi_encode_free(avctx, [[vic]]); } if (ctx->va_context != VA_INVALID_ID) { vaDestroyContext(ctx->hwctx->display, ctx->va_context); ctx->va_context = VA_INVALID_ID; } if (ctx->va_config != VA_INVALID_ID) { vaDestroyConfig(ctx->hwctx->display, ctx->va_config); ctx->va_config = VA_INVALID_ID; } if (ctx->codec->close) ctx->codec->close(avctx); av_buffer_pool_uninit(&ctx->output_buffer_pool); av_freep(&ctx->codec_sequence_params); av_freep(&ctx->codec_picture_params); av_buffer_unref(&ctx->recon_frames_ref); av_buffer_unref(&ctx->input_frames_ref); av_buffer_unref(&ctx->device_ref); av_freep(&ctx->priv_data); return 0; }
--------------------------------------------- Result 835 ---------------------------------------------
[[0 (43%)]] --> [[0 (99%)]] --> Socre: 0.992741048336029

[[[[Adv]]]]: static ssize_t socket_read(int sockfd, void *buff, size_t size) { ssize_t [[retval]], total = 0; while (size) { [[retval]] = read(sockfd, buff, size); if ([[retval]] == 0) { return -EIO; } if ([[retval]] < 0) { if (errno == EINTR) { continue; } return -errno; } size -= [[retval]]; buff += [[retval]]; total += [[retval]]; } return total; }

[[[[Adv]]]]: static ssize_t socket_read(int sockfd, void *buff, size_t size) { ssize_t [[epetл]], total = 0; while (size) { [[epetл]] = read(sockfd, buff, size); if ([[epetл]] == 0) { return -EIO; } if ([[epetл]] < 0) { if (errno == EINTR) { continue; } return -errno; } size -= [[epetл]]; buff += [[epetл]]; total += [[epetл]]; } return total; }
--------------------------------------------- Result 836 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 438 / 94 / 304 / 836:  31%|███       | 836/2690 [2:08:24<4:44:46,  9.22s/it][Succeeded / Failed / Skipped / Total] 438 / 94 / 304 / 836:  31%|███       | 837/2690 [2:08:25<4:44:18,  9.21s/it][Succeeded / Failed / Skipped / Total] 438 / 94 / 305 / 837:  31%|███       | 837/2690 [2:08:25<4:44:18,  9.21s/it][Succeeded / Failed / Skipped / Total] 438 / 94 / 305 / 837:  31%|███       | 838/2690 [2:08:32<4:44:05,  9.20s/it][Succeeded / Failed / Skipped / Total] 439 / 94 / 305 / 838:  31%|███       | 838/2690 [2:08:32<4:44:05,  9.20s/it][Succeeded / Failed / Skipped / Total] 439 / 94 / 305 / 838:  31%|███       | 839/2690 [2:08:33<4:43:37,  9.19s/it][[0 (2%)]] --> [[0 (97%)]] --> Socre: 0.9743747115135193

[[[[Adv]]]]: AioContext *blk_get_aio_context(BlockBackend *[[blk]]) { return bdrv_get_aio_context([[blk]]->bs); }

[[[[Adv]]]]: AioContext *blk_get_aio_context(BlockBackend *[[бst]]) { return bdrv_get_aio_context([[бst]]->bs); }
--------------------------------------------- Result 837 ---------------------------------------------
[[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mpc7_decode_frame(AVCodecContext * avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size; MPCContext *c = avctx->priv_data; GetBitContext gb; int i, ch; int mb = -1; Band *bands = c->bands; int off, ret, last_frame, skip; int bits_used, bits_avail; memset(bands, 0, sizeof(*bands) * (c->maxbands + 1)); buf_size = avpkt->size & ~3; if (buf_size <= 0) { av_log(avctx, AV_LOG_ERROR, "packet size is too small (%i bytes)\n", avpkt->size); return AVERROR_INVALIDDATA; } if (buf_size != avpkt->size) { av_log(avctx, AV_LOG_WARNING, "packet size is not a multiple of 4. " "extra bytes at the end will be skipped.\n"); } skip = buf[0]; last_frame = buf[1]; buf += 4; buf_size -= 4; c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE; if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } av_fast_padded_malloc(&c->bits, &c->buf_size, buf_size); if (!c->bits) return AVERROR(ENOMEM); c->dsp.bswap_buf((uint32_t *)c->bits, (const uint32_t *)buf, buf_size >> 2); init_get_bits(&gb, c->bits, buf_size * 8); skip_bits_long(&gb, skip); for(i = 0; i <= c->maxbands; i++){ for(ch = 0; ch < 2; ch++){ int t = 4; if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5; if(t == 4) bands[i].res[ch] = get_bits(&gb, 4); else bands[i].res[ch] = bands[i-1].res[ch] + t; } if(bands[i].res[0] || bands[i].res[1]){ mb = i; if(c->MSS) bands[i].msf = get_bits1(&gb); } } for(i = 0; i <= mb; i++) for(ch = 0; ch < 2; ch++) if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1); for(i = 0; i <= mb; i++){ for(ch = 0; ch < 2; ch++){ if(bands[i].res[ch]){ bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i]; bands[i].scf_idx[ch][0] = get_scale_idx(&gb, bands[i].scf_idx[ch][2]); switch(bands[i].scfi[ch]){ case 0: bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]); bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]); break; case 1: bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]); bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1]; break; case 2: bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0]; bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]); break; case 3: bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0]; break; } c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2]; } } } memset(c->Q, 0, sizeof(c->Q)); off = 0; for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND) for(ch = 0; ch < 2; ch++) idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off); ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2); bits_used = get_bits_count(&gb); bits_avail = buf_size * 8; if (!last_frame && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))) { av_log(avctx, AV_LOG_ERROR, "Error decoding frame: used %i of %i bits\n", bits_used, bits_avail); return -1; } if(c->frames_to_skip){ c->frames_to_skip--; *got_frame_ptr = 0; return avpkt->size; } *got_frame_ptr = 1; *(AVFrame *)data = c->frame; return avpkt->size; }
--------------------------------------------- Result 838 ---------------------------------------------
[[0 (48%)]] --> [[0 (99%)]] --> Socre: 0.9940659999847412

[[[[Adv]]]]: static int vfio_load_rom(VFIODevice *vdev) { uint64_t size = vdev->rom_size; char name[32]; off_t off = 0, voff = vdev->rom_offset; ssize_t bytes; void *[[ptr]]; if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) { return 0; } DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); snprintf(name, sizeof(name), "vfio[%04x:%02x:%02x.%x].rom", vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size); [[ptr]] = memory_region_get_ram_ptr(&vdev->pdev.rom); memset([[ptr]], 0xff, size); while (size) { bytes = pread(vdev->fd, [[ptr]] + off, size, voff + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } error_report("vfio: Error reading device ROM: %m"); memory_region_destroy(&vdev->pdev.rom); return -errno; } } pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom); vdev->pdev.has_rom = "True" == "True"; return 0; }

[[[[Adv]]]]: static int vfio_load_rom(VFIODevice *vdev) { uint64_t size = vdev->rom_size; char name[32]; off_t off = 0, voff = vdev->rom_offset; ssize_t bytes; void *[[eprin]]; if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) { return 0; } DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); snprintf(name, sizeof(name), "vfio[%04x:%02x:%02x.%x].rom", vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size); [[eprin]] = memory_region_get_ram_ptr(&vdev->pdev.rom); memset([[eprin]], 0xff, size); while (size) { bytes = pread(vdev->fd, [[eprin]] + off, size, voff + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } error_report("vfio: Error reading device ROM: %m"); memory_region_destroy(&vdev->pdev.rom); return -errno; } } pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom); vdev->pdev.has_rom = "True" == "True"; return 0; }
--------------------------------------------- Result 839 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 439 / 94 / 306 / 839:  31%|███       | 839/2690 [2:08:33<4:43:37,  9.19s/it][Succeeded / Failed / Skipped / Total] 439 / 94 / 306 / 839:  31%|███       | 840/2690 [2:09:13<4:44:36,  9.23s/it][Succeeded / Failed / Skipped / Total] 440 / 94 / 306 / 840:  31%|███       | 840/2690 [2:09:13<4:44:36,  9.23s/it][Succeeded / Failed / Skipped / Total] 440 / 94 / 306 / 840:  31%|███▏      | 841/2690 [2:09:16<4:44:12,  9.22s/it][Succeeded / Failed / Skipped / Total] 441 / 94 / 306 / 841:  31%|███▏      | 841/2690 [2:09:16<4:44:12,  9.22s/it][Succeeded / Failed / Skipped / Total] 441 / 94 / 306 / 841:  31%|███▏      | 842/2690 [2:09:26<4:44:05,  9.22s/it][Succeeded / Failed / Skipped / Total] 442 / 94 / 306 / 842:  31%|███▏      | 842/2690 [2:09:26<4:44:05,  9.22s/it][Succeeded / Failed / Skipped / Total] 442 / 94 / 306 / 842:  31%|███▏      | 843/2690 [2:09:34<4:43:53,  9.22s/it][[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb) { av_log(avctx, AV_LOG_DEBUG, "Header: %0X\n", show_bits(gb, 32)); v->profile = get_bits(gb, 2); if (v->profile == PROFILE_COMPLEX) { av_log(avctx, AV_LOG_WARNING, "WMV3 Complex Profile is not fully supported\n"); } if (v->profile == PROFILE_ADVANCED) { v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz; v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz; return decode_sequence_header_adv(v, gb); } else { v->zz_8x4 = wmv2_scantableA; v->zz_4x8 = wmv2_scantableB; v->res_y411 = get_bits1(gb); v->res_sprite = get_bits1(gb); if (v->res_y411) { av_log(avctx, AV_LOG_ERROR, "Old interlaced mode is not supported\n"); return -1; } if (v->res_sprite) { av_log(avctx, AV_LOG_ERROR, "WMVP is not fully supported\n"); } } v->frmrtq_postproc = get_bits(gb, 3); v->bitrtq_postproc = get_bits(gb, 5); v->s.loop_filter = get_bits1(gb); if(v->s.loop_filter == 1 && v->profile == PROFILE_SIMPLE) { av_log(avctx, AV_LOG_ERROR, "LOOPFILTER shall not be enabled in Simple Profile\n"); } if(v->s.avctx->skip_loop_filter >= AVDISCARD_ALL) v->s.loop_filter = 0; v->res_x8 = get_bits1(gb); v->multires = get_bits1(gb); v->res_fasttx = get_bits1(gb); if (!v->res_fasttx) { v->vc1dsp.vc1_inv_trans_8x8 = ff_simple_idct_8; v->vc1dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add; v->vc1dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add; v->vc1dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add; v->vc1dsp.vc1_inv_trans_8x8_dc = ff_simple_idct_add_8; v->vc1dsp.vc1_inv_trans_8x4_dc = ff_simple_idct84_add; v->vc1dsp.vc1_inv_trans_4x8_dc = ff_simple_idct48_add; v->vc1dsp.vc1_inv_trans_4x4_dc = ff_simple_idct44_add; } v->fastuvmc = get_bits1(gb); if (!v->profile && !v->fastuvmc) { av_log(avctx, AV_LOG_ERROR, "FASTUVMC unavailable in Simple Profile\n"); return -1; } v->extended_mv = get_bits1(gb); if (!v->profile && v->extended_mv) { av_log(avctx, AV_LOG_ERROR, "Extended MVs unavailable in Simple Profile\n"); return -1; } v->dquant = get_bits(gb, 2); v->vstransform = get_bits1(gb); v->res_transtab = get_bits1(gb); if (v->res_transtab) { av_log(avctx, AV_LOG_ERROR, "1 for reserved RES_TRANSTAB is forbidden\n"); return -1; } v->overlap = get_bits1(gb); v->s.resync_marker = get_bits1(gb); v->rangered = get_bits1(gb); if (v->rangered && v->profile == PROFILE_SIMPLE) { av_log(avctx, AV_LOG_INFO, "RANGERED should be set to 0 in Simple Profile\n"); } v->s.max_b_frames = avctx->max_b_frames = get_bits(gb, 3); v->quantizer_mode = get_bits(gb, 2); v->finterpflag = get_bits1(gb); if (v->res_sprite) { v->s.avctx->width = v->s.avctx->coded_width = get_bits(gb, 11); v->s.avctx->height = v->s.avctx->coded_height = get_bits(gb, 11); skip_bits(gb, 5); v->res_x8 = get_bits1(gb); if (get_bits1(gb)) { av_log(avctx, AV_LOG_ERROR, "Unsupported sprite feature\n"); return -1; } skip_bits(gb, 3); v->res_rtm_flag = 0; } else { v->res_rtm_flag = get_bits1(gb); } if (!v->res_rtm_flag) { av_log(avctx, AV_LOG_ERROR, "Old WMV3 version detected, some frames may be decoded incorrectly\n"); } if(!v->res_fasttx) skip_bits(gb, 16); av_log(avctx, AV_LOG_DEBUG, "Profile %i:\nfrmrtq_postproc=%i, bitrtq_postproc=%i\n" "LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\n" "Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\n" "DQuant=%i, Quantizer mode=%i, Max B frames=%i\n", v->profile, v->frmrtq_postproc, v->bitrtq_postproc, v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv, v->rangered, v->vstransform, v->overlap, v->s.resync_marker, v->dquant, v->quantizer_mode, avctx->max_b_frames ); return 0; }
--------------------------------------------- Result 840 ---------------------------------------------
[[0 (66%)]] --> [[0 (41%)]] --> Socre: 0.5940459072589874

[[[[Adv]]]]: static int rle_unpack(const unsigned char *[[src]], int src_len, int src_count, unsigned char *dest, int dest_len) { const unsigned char *[[ps]]; const unsigned char *ps_end; unsigned char *pd; int i, l; unsigned char *dest_end = dest + dest_len; [[ps]] = [[src]]; ps_end = [[src]] + src_len; pd = dest; if (src_count & 1) { if (ps_end - [[ps]] < 1) return 0; *pd++ = *[[ps]]++; } src_count >>= 1; i = 0; do { if (ps_end - [[ps]] < 1) break; l = *[[ps]]++; if (l & 0x80) { l = (l & 0x7F) * 2; if (pd + l > dest_end || ps_end - [[ps]] < l) return [[ps]] - [[src]]; memcpy(pd, [[ps]], l); [[ps]] += l; pd += l; } else { if (pd + i > dest_end || ps_end - [[ps]] < 2) return [[ps]] - [[src]]; for (i = 0; i < l; i++) { *pd++ = [[ps]][0]; *pd++ = [[ps]][1]; } [[ps]] += 2; } i += l; } while (i < src_count); return [[ps]] - [[src]]; }

[[[[Adv]]]]: static int rle_unpack(const unsigned char *[[procs]], int src_len, int src_count, unsigned char *dest, int dest_len) { const unsigned char *[[stat]]; const unsigned char *ps_end; unsigned char *pd; int i, l; unsigned char *dest_end = dest + dest_len; [[stat]] = [[procs]]; ps_end = [[procs]] + src_len; pd = dest; if (src_count & 1) { if (ps_end - [[stat]] < 1) return 0; *pd++ = *[[stat]]++; } src_count >>= 1; i = 0; do { if (ps_end - [[stat]] < 1) break; l = *[[stat]]++; if (l & 0x80) { l = (l & 0x7F) * 2; if (pd + l > dest_end || ps_end - [[stat]] < l) return [[stat]] - [[procs]]; memcpy(pd, [[stat]], l); [[stat]] += l; pd += l; } else { if (pd + i > dest_end || ps_end - [[stat]] < 2) return [[stat]] - [[procs]]; for (i = 0; i < l; i++) { *pd++ = [[stat]][0]; *pd++ = [[stat]][1]; } [[stat]] += 2; } i += l; } while (i < src_count); return [[stat]] - [[procs]]; }
--------------------------------------------- Result 841 ---------------------------------------------
[[0 (4%)]] --> [[0 (74%)]] --> Socre: 0.7361165881156921

[[[[Adv]]]]: UuidInfo *qmp_query_uuid(Error **[[errp]]) { UuidInfo *[[info]] = g_malloc0(sizeof(*[[info]])); char [[uuid]][64]; snprintf([[uuid]], sizeof([[uuid]]), UUID_FMT, qemu_uuid[0], qemu_uuid[1], qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5], qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9], qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13], qemu_uuid[14], qemu_uuid[15]); [[info]]->UUID = g_strdup([[uuid]]); return [[info]]; }

[[[[Adv]]]]: UuidInfo *qmp_query_uuid(Error **[[iesp]]) { UuidInfo *[[intake]] = g_malloc0(sizeof(*[[intake]])); char [[med]][64]; snprintf([[med]], sizeof([[med]]), UUID_FMT, qemu_uuid[0], qemu_uuid[1], qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5], qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9], qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13], qemu_uuid[14], qemu_uuid[15]); [[intake]]->UUID = g_strdup([[med]]); return [[intake]]; }
--------------------------------------------- Result 842 ---------------------------------------------
[[0 (70%)]] --> [[0 (44%)]] --> Socre: 0.5635617673397064

[[[[Adv]]]]: static int s390_virtio_rng_init(VirtIOS390Device *[[s390_dev]]) { VirtIORNGS390 *[[dev]] = VIRTIO_RNG_S390([[s390_dev]]); DeviceState *[[vdev]] = DEVICE(&[[dev]]->vdev); qdev_set_parent_bus([[vdev]], BUS(&[[s390_dev]]->bus)); if (qdev_init([[vdev]]) < 0) { return -1; } object_property_set_link(OBJECT([[dev]]), OBJECT([[dev]]->vdev.conf.default_backend), "rng", NULL); return s390_virtio_device_init([[s390_dev]], VIRTIO_DEVICE([[vdev]])); }

[[[[Adv]]]]: static int s390_virtio_rng_init(VirtIOS390Device *[[i4001codepark]]) { VirtIORNGS390 *[[feedback]] = VIRTIO_RNG_S390([[i4001codepark]]); DeviceState *[[gda]] = DEVICE(&[[feedback]]->vdev); qdev_set_parent_bus([[gda]], BUS(&[[i4001codepark]]->bus)); if (qdev_init([[gda]]) < 0) { return -1; } object_property_set_link(OBJECT([[feedback]]), OBJECT([[feedback]]->vdev.conf.default_backend), "rng", NULL); return s390_virtio_device_init([[i4001codepark]], VIRTIO_DEVICE([[gda]])); }
--------------------------------------------- Result 843 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 443 / 94 / 306 / 843:  31%|███▏      | 843/2690 [2:09:34<4:43:53,  9.22s/it][Succeeded / Failed / Skipped / Total] 443 / 94 / 306 / 843:  31%|███▏      | 844/2690 [2:09:47<4:43:52,  9.23s/it][Succeeded / Failed / Skipped / Total] 444 / 94 / 306 / 844:  31%|███▏      | 844/2690 [2:09:47<4:43:52,  9.23s/it][Succeeded / Failed / Skipped / Total] 444 / 94 / 306 / 844:  31%|███▏      | 845/2690 [2:09:53<4:43:37,  9.22s/it][Succeeded / Failed / Skipped / Total] 445 / 94 / 306 / 845:  31%|███▏      | 845/2690 [2:09:53<4:43:37,  9.22s/it][Succeeded / Failed / Skipped / Total] 445 / 94 / 306 / 845:  31%|███▏      | 846/2690 [2:10:22<4:44:10,  9.25s/it][[0 (8%)]] --> [[0 (99%)]] --> Socre: 0.9877734780311584

[[[[Adv]]]]: static void apic_update_irq(APICState *s) { int [[irrv]], ppr; if (!(s->spurious_vec & APIC_SV_ENABLE)) return; [[irrv]] = get_highest_priority_int(s->irr); if ([[irrv]] < 0) return; ppr = apic_get_ppr(s); if (ppr && ([[irrv]] & 0xf0) <= (ppr & 0xf0)) return; cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD); }

[[[[Adv]]]]: static void apic_update_irq(APICState *s) { int [[wasрv]], ppr; if (!(s->spurious_vec & APIC_SV_ENABLE)) return; [[wasрv]] = get_highest_priority_int(s->irr); if ([[wasрv]] < 0) return; ppr = apic_get_ppr(s); if (ppr && ([[wasрv]] & 0xf0) <= (ppr & 0xf0)) return; cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD); }
--------------------------------------------- Result 844 ---------------------------------------------
[[0 (46%)]] --> [[0 (79%)]] --> Socre: 0.7917470335960388

[[[[Adv]]]]: static void coroutine_fn qed_aio_complete(QEDAIOCB *acb) { BDRVQEDState *[[s]] = acb_to_s(acb); qemu_iovec_destroy(&acb->cur_qiov); qed_unref_l2_cache_entry(acb->request.l2_table); if (acb->flags & QED_AIOCB_ZERO) { qemu_vfree(acb->qiov->iov[0].iov_base); acb->qiov->iov[0].iov_base = NULL; } if (acb == [[s]]->allocating_acb) { [[s]]->allocating_acb = NULL; if (!qemu_co_queue_empty(&[[s]]->allocating_write_reqs)) { qemu_co_enter_next(&[[s]]->allocating_write_reqs); } else if ([[s]]->header.features & QED_F_NEED_CHECK) { qed_start_need_check_timer([[s]]); } } }

[[[[Adv]]]]: static void coroutine_fn qed_aio_complete(QEDAIOCB *acb) { BDRVQEDState *[[v]] = acb_to_s(acb); qemu_iovec_destroy(&acb->cur_qiov); qed_unref_l2_cache_entry(acb->request.l2_table); if (acb->flags & QED_AIOCB_ZERO) { qemu_vfree(acb->qiov->iov[0].iov_base); acb->qiov->iov[0].iov_base = NULL; } if (acb == [[v]]->allocating_acb) { [[v]]->allocating_acb = NULL; if (!qemu_co_queue_empty(&[[v]]->allocating_write_reqs)) { qemu_co_enter_next(&[[v]]->allocating_write_reqs); } else if ([[v]]->header.features & QED_F_NEED_CHECK) { qed_start_need_check_timer([[v]]); } } }
--------------------------------------------- Result 845 ---------------------------------------------
[[0 (16%)]] --> [[0 (54%)]] --> Socre: 0.53863924741745

[[[[Adv]]]]: setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate, CPUX86State *[[env]], abi_ulong mask, abi_ulong [[fpstate_addr]]) { CPUState *cs = CPU(x86_env_get_cpu([[env]])); int err = 0; uint16_t magic; __put_user([[env]]->segs[R_GS].selector, (unsigned int *)&sc->gs); __put_user([[env]]->segs[R_FS].selector, (unsigned int *)&sc->fs); __put_user([[env]]->segs[R_ES].selector, (unsigned int *)&sc->es); __put_user([[env]]->segs[R_DS].selector, (unsigned int *)&sc->ds); __put_user([[env]]->regs[R_EDI], &sc->edi); __put_user([[env]]->regs[R_ESI], &sc->esi); __put_user([[env]]->regs[R_EBP], &sc->ebp); __put_user([[env]]->regs[R_ESP], &sc->esp); __put_user([[env]]->regs[R_EBX], &sc->ebx); __put_user([[env]]->regs[R_EDX], &sc->edx); __put_user([[env]]->regs[R_ECX], &sc->ecx); __put_user([[env]]->regs[R_EAX], &sc->eax); __put_user(cs->exception_index, &sc->trapno); __put_user([[env]]->error_code, &sc->err); __put_user([[env]]->eip, &sc->eip); __put_user([[env]]->segs[R_CS].selector, (unsigned int *)&sc->cs); __put_user([[env]]->eflags, &sc->eflags); __put_user([[env]]->regs[R_ESP], &sc->esp_at_signal); __put_user([[env]]->segs[R_SS].selector, (unsigned int *)&sc->ss); cpu_x86_fsave([[env]], [[fpstate_addr]], 1); fpstate->status = fpstate->sw; magic = 0xffff; __put_user(magic, &fpstate->magic); __put_user([[fpstate_addr]], &sc->fpstate); __put_user(mask, &sc->oldmask); __put_user([[env]]->cr[2], &sc->cr2); return err; }

[[[[Adv]]]]: setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate, CPUX86State *[[heв]], abi_ulong mask, abi_ulong [[fcvesτrxlk]]) { CPUState *cs = CPU(x86_env_get_cpu([[heв]])); int err = 0; uint16_t magic; __put_user([[heв]]->segs[R_GS].selector, (unsigned int *)&sc->gs); __put_user([[heв]]->segs[R_FS].selector, (unsigned int *)&sc->fs); __put_user([[heв]]->segs[R_ES].selector, (unsigned int *)&sc->es); __put_user([[heв]]->segs[R_DS].selector, (unsigned int *)&sc->ds); __put_user([[heв]]->regs[R_EDI], &sc->edi); __put_user([[heв]]->regs[R_ESI], &sc->esi); __put_user([[heв]]->regs[R_EBP], &sc->ebp); __put_user([[heв]]->regs[R_ESP], &sc->esp); __put_user([[heв]]->regs[R_EBX], &sc->ebx); __put_user([[heв]]->regs[R_EDX], &sc->edx); __put_user([[heв]]->regs[R_ECX], &sc->ecx); __put_user([[heв]]->regs[R_EAX], &sc->eax); __put_user(cs->exception_index, &sc->trapno); __put_user([[heв]]->error_code, &sc->err); __put_user([[heв]]->eip, &sc->eip); __put_user([[heв]]->segs[R_CS].selector, (unsigned int *)&sc->cs); __put_user([[heв]]->eflags, &sc->eflags); __put_user([[heв]]->regs[R_ESP], &sc->esp_at_signal); __put_user([[heв]]->segs[R_SS].selector, (unsigned int *)&sc->ss); cpu_x86_fsave([[heв]], [[fcvesτrxlk]], 1); fpstate->status = fpstate->sw; magic = 0xffff; __put_user(magic, &fpstate->magic); __put_user([[fcvesτrxlk]], &sc->fpstate); __put_user(mask, &sc->oldmask); __put_user([[heв]]->cr[2], &sc->cr2); return err; }
--------------------------------------------- Result 846 ---------------------------------------------
[[0 (38%)]] --> [[0 (76%)]] --> Socre: 0.7563374042510986

[[[[Adv]]]]: int load_multiboot(void *fw_cfg, FILE *f, const char *[[kernel_filename]], const char *initrd_filename, const char *kernel_cmdline, int kernel_file_size, uint8_t *header) { int i, is_multiboot = 0; uint32_t flags = 0; uint32_t mh_entry_addr; uint32_t mh_load_addr; uint32_t mb_kernel_size; MultibootState mbs; uint8_t bootinfo[MBI_SIZE]; uint8_t *mb_bootinfo_data; for (i = 0; i < (8192 - 48); i += 4) { if (ldl_p(header+i) == 0x1BADB002) { uint32_t checksum = ldl_p(header+i+8); flags = ldl_p(header+i+4); checksum += flags; checksum += (uint32_t)0x1BADB002; if (!checksum) { is_multiboot = 1; break; } } } if (!is_multiboot) return 0; mb_debug("qemu: I believe we found a multiboot image!\n"); memset(bootinfo, 0, sizeof(bootinfo)); memset(&mbs, 0, sizeof(mbs)); if (flags & 0x00000004) { fprintf(stderr, "qemu: multiboot knows VBE. we don't.\n"); } if (!(flags & 0x00010000)) { uint64_t elf_entry; uint64_t elf_low, elf_high; int kernel_size; fclose(f); if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) { fprintf(stderr, "Cannot load x86-64 image, give a 32bit one.\n"); exit(1); } kernel_size = load_elf([[kernel_filename]], NULL, NULL, &elf_entry, &elf_low, &elf_high, 0, ELF_MACHINE, 0); if (kernel_size < 0) { fprintf(stderr, "Error while loading elf kernel\n"); exit(1); } mh_load_addr = elf_low; mb_kernel_size = elf_high - elf_low; mh_entry_addr = elf_entry; mbs.mb_buf = g_malloc(mb_kernel_size); if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) { fprintf(stderr, "Error while fetching elf kernel from rom\n"); exit(1); } mb_debug("qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\n", mb_kernel_size, (size_t)mh_entry_addr); } else { uint32_t mh_header_addr = ldl_p(header+i+12); uint32_t mh_load_end_addr = ldl_p(header+i+20); uint32_t mh_bss_end_addr = ldl_p(header+i+24); mh_load_addr = ldl_p(header+i+16); uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr); uint32_t mb_load_size = 0; mh_entry_addr = ldl_p(header+i+28); if (mh_load_end_addr) { mb_kernel_size = mh_bss_end_addr - mh_load_addr; mb_load_size = mh_load_end_addr - mh_load_addr; } else { mb_kernel_size = kernel_file_size - mb_kernel_text_offset; mb_load_size = mb_kernel_size; } mb_debug("multiboot: mh_header_addr = %#x\n", mh_header_addr); mb_debug("multiboot: mh_load_addr = %#x\n", mh_load_addr); mb_debug("multiboot: mh_load_end_addr = %#x\n", mh_load_end_addr); mb_debug("multiboot: mh_bss_end_addr = %#x\n", mh_bss_end_addr); mb_debug("qemu: loading multiboot kernel (%#x bytes) at %#x\n", mb_load_size, mh_load_addr); mbs.mb_buf = g_malloc(mb_kernel_size); fseek(f, mb_kernel_text_offset, SEEK_SET); if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) { fprintf(stderr, "fread() failed\n"); exit(1); } memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size); fclose(f); } mbs.mb_buf_phys = mh_load_addr; mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size); mbs.offset_mbinfo = mbs.mb_buf_size; mbs.mb_buf_size += strlen([[kernel_filename]]) + 1; mbs.mb_buf_size += strlen(kernel_cmdline) + 1; if (initrd_filename) { const char *r = initrd_filename; mbs.mb_buf_size += strlen(r) + 1; mbs.mb_mods_avail = 1; while (*(r = get_opt_value(NULL, 0, r))) { mbs.mb_mods_avail++; r++; } mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail; } mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size); mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size); mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE; if (initrd_filename) { char *next_initrd, not_last; mbs.offset_mods = mbs.mb_buf_size; do { char *next_space; int mb_mod_length; uint32_t offs = mbs.mb_buf_size; next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename); not_last = *next_initrd; *next_initrd = '\0'; target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename); if ((next_space = strchr(initrd_filename, ' '))) *next_space = '\0'; mb_debug("multiboot loading module: %s\n", initrd_filename); mb_mod_length = get_image_size(initrd_filename); if (mb_mod_length < 0) { fprintf(stderr, "Failed to open file '%s'\n", initrd_filename); exit(1); } mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size); mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size); load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs); mb_add_mod(&mbs, mbs.mb_buf_phys + offs, mbs.mb_buf_phys + offs + mb_mod_length, c); mb_debug("mod_start: %p\nmod_end: %p\n cmdline: "TARGET_FMT_plx"\n", (char *)mbs.mb_buf + offs, (char *)mbs.mb_buf + offs + mb_mod_length, c); initrd_filename = next_initrd+1; } while (not_last); } char kcmdline[strlen([[kernel_filename]]) + strlen(kernel_cmdline) + 2]; snprintf(kcmdline, sizeof(kcmdline), "%s %s", [[kernel_filename]], kernel_cmdline); stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline)); stl_p(bootinfo + MBI_MODS_ADDR, mbs.mb_buf_phys + mbs.offset_mbinfo); stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY | MULTIBOOT_FLAGS_BOOT_DEVICE | MULTIBOOT_FLAGS_CMDLINE | MULTIBOOT_FLAGS_MODULES | MULTIBOOT_FLAGS_MMAP); stl_p(bootinfo + MBI_MEM_LOWER, 640); stl_p(bootinfo + MBI_MEM_UPPER, (ram_size / 1024) - 1024); stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); stl_p(bootinfo + MBI_MMAP_ADDR, ADDR_E820_MAP); mb_debug("multiboot: mh_entry_addr = %#x\n", mh_entry_addr); mb_debug(" mb_buf_phys = "TARGET_FMT_plx"\n", mbs.mb_buf_phys); mb_debug(" mod_start = "TARGET_FMT_plx"\n", mbs.mb_buf_phys + mbs.offset_mods); mb_debug(" mb_mods_count = %d\n", mbs.mb_mods_count); mb_bootinfo_data = g_malloc(sizeof(bootinfo)); memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo)); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size); fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA, mbs.mb_buf, mbs.mb_buf_size); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo)); fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data, sizeof(bootinfo)); option_rom[nb_option_roms].name = "multiboot.bin"; option_rom[nb_option_roms].bootindex = 0; nb_option_roms++; return 1; }

[[[[Adv]]]]: int load_multiboot(void *fw_cfg, FILE *f, const char *[[lografpayid]], const char *initrd_filename, const char *kernel_cmdline, int kernel_file_size, uint8_t *header) { int i, is_multiboot = 0; uint32_t flags = 0; uint32_t mh_entry_addr; uint32_t mh_load_addr; uint32_t mb_kernel_size; MultibootState mbs; uint8_t bootinfo[MBI_SIZE]; uint8_t *mb_bootinfo_data; for (i = 0; i < (8192 - 48); i += 4) { if (ldl_p(header+i) == 0x1BADB002) { uint32_t checksum = ldl_p(header+i+8); flags = ldl_p(header+i+4); checksum += flags; checksum += (uint32_t)0x1BADB002; if (!checksum) { is_multiboot = 1; break; } } } if (!is_multiboot) return 0; mb_debug("qemu: I believe we found a multiboot image!\n"); memset(bootinfo, 0, sizeof(bootinfo)); memset(&mbs, 0, sizeof(mbs)); if (flags & 0x00000004) { fprintf(stderr, "qemu: multiboot knows VBE. we don't.\n"); } if (!(flags & 0x00010000)) { uint64_t elf_entry; uint64_t elf_low, elf_high; int kernel_size; fclose(f); if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) { fprintf(stderr, "Cannot load x86-64 image, give a 32bit one.\n"); exit(1); } kernel_size = load_elf([[lografpayid]], NULL, NULL, &elf_entry, &elf_low, &elf_high, 0, ELF_MACHINE, 0); if (kernel_size < 0) { fprintf(stderr, "Error while loading elf kernel\n"); exit(1); } mh_load_addr = elf_low; mb_kernel_size = elf_high - elf_low; mh_entry_addr = elf_entry; mbs.mb_buf = g_malloc(mb_kernel_size); if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) { fprintf(stderr, "Error while fetching elf kernel from rom\n"); exit(1); } mb_debug("qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\n", mb_kernel_size, (size_t)mh_entry_addr); } else { uint32_t mh_header_addr = ldl_p(header+i+12); uint32_t mh_load_end_addr = ldl_p(header+i+20); uint32_t mh_bss_end_addr = ldl_p(header+i+24); mh_load_addr = ldl_p(header+i+16); uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr); uint32_t mb_load_size = 0; mh_entry_addr = ldl_p(header+i+28); if (mh_load_end_addr) { mb_kernel_size = mh_bss_end_addr - mh_load_addr; mb_load_size = mh_load_end_addr - mh_load_addr; } else { mb_kernel_size = kernel_file_size - mb_kernel_text_offset; mb_load_size = mb_kernel_size; } mb_debug("multiboot: mh_header_addr = %#x\n", mh_header_addr); mb_debug("multiboot: mh_load_addr = %#x\n", mh_load_addr); mb_debug("multiboot: mh_load_end_addr = %#x\n", mh_load_end_addr); mb_debug("multiboot: mh_bss_end_addr = %#x\n", mh_bss_end_addr); mb_debug("qemu: loading multiboot kernel (%#x bytes) at %#x\n", mb_load_size, mh_load_addr); mbs.mb_buf = g_malloc(mb_kernel_size); fseek(f, mb_kernel_text_offset, SEEK_SET); if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) { fprintf(stderr, "fread() failed\n"); exit(1); } memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size); fclose(f); } mbs.mb_buf_phys = mh_load_addr; mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size); mbs.offset_mbinfo = mbs.mb_buf_size; mbs.mb_buf_size += strlen([[lografpayid]]) + 1; mbs.mb_buf_size += strlen(kernel_cmdline) + 1; if (initrd_filename) { const char *r = initrd_filename; mbs.mb_buf_size += strlen(r) + 1; mbs.mb_mods_avail = 1; while (*(r = get_opt_value(NULL, 0, r))) { mbs.mb_mods_avail++; r++; } mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail; } mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size); mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size); mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE; if (initrd_filename) { char *next_initrd, not_last; mbs.offset_mods = mbs.mb_buf_size; do { char *next_space; int mb_mod_length; uint32_t offs = mbs.mb_buf_size; next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename); not_last = *next_initrd; *next_initrd = '\0'; target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename); if ((next_space = strchr(initrd_filename, ' '))) *next_space = '\0'; mb_debug("multiboot loading module: %s\n", initrd_filename); mb_mod_length = get_image_size(initrd_filename); if (mb_mod_length < 0) { fprintf(stderr, "Failed to open file '%s'\n", initrd_filename); exit(1); } mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size); mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size); load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs); mb_add_mod(&mbs, mbs.mb_buf_phys + offs, mbs.mb_buf_phys + offs + mb_mod_length, c); mb_debug("mod_start: %p\nmod_end: %p\n cmdline: "TARGET_FMT_plx"\n", (char *)mbs.mb_buf + offs, (char *)mbs.mb_buf + offs + mb_mod_length, c); initrd_filename = next_initrd+1; } while (not_last); } char kcmdline[strlen([[lografpayid]]) + strlen(kernel_cmdline) + 2]; snprintf(kcmdline, sizeof(kcmdline), "%s %s", [[lografpayid]], kernel_cmdline); stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline)); stl_p(bootinfo + MBI_MODS_ADDR, mbs.mb_buf_phys + mbs.offset_mbinfo); stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY | MULTIBOOT_FLAGS_BOOT_DEVICE | MULTIBOOT_FLAGS_CMDLINE | MULTIBOOT_FLAGS_MODULES | MULTIBOOT_FLAGS_MMAP); stl_p(bootinfo + MBI_MEM_LOWER, 640); stl_p(bootinfo + MBI_MEM_UPPER, (ram_size / 1024) - 1024); stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); stl_p(bootinfo + MBI_MMAP_ADDR, ADDR_E820_MAP); mb_debug("multiboot: mh_entry_addr = %#x\n", mh_entry_addr); mb_debug(" mb_buf_phys = "TARGET_FMT_plx"\n", mbs.mb_buf_phys); mb_debug(" mod_start = "TARGET_FMT_plx"\n", mbs.mb_buf_phys + mbs.offset_mods); mb_debug(" mb_mods_count = %d\n", mbs.mb_mods_count); mb_bootinfo_data = g_malloc(sizeof(bootinfo)); memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo)); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size); fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA, mbs.mb_buf, mbs.mb_buf_size); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo)); fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data, sizeof(bootinfo)); option_rom[nb_option_roms].name = "multiboot.bin"; option_rom[nb_option_roms].bootindex = 0; nb_option_roms++; return 1; }[Succeeded / Failed / Skipped / Total] 446 / 94 / 306 / 846:  31%|███▏      | 846/2690 [2:10:22<4:44:10,  9.25s/it][Succeeded / Failed / Skipped / Total] 446 / 94 / 306 / 846:  31%|███▏      | 847/2690 [2:10:42<4:44:25,  9.26s/it][Succeeded / Failed / Skipped / Total] 447 / 94 / 306 / 847:  31%|███▏      | 847/2690 [2:10:42<4:44:25,  9.26s/it][Succeeded / Failed / Skipped / Total] 447 / 94 / 306 / 847:  32%|███▏      | 848/2690 [2:10:59<4:44:32,  9.27s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 306 / 848:  32%|███▏      | 848/2690 [2:10:59<4:44:32,  9.27s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 306 / 848:  32%|███▏      | 849/2690 [2:11:00<4:44:04,  9.26s/it]
--------------------------------------------- Result 847 ---------------------------------------------
[[0 (12%)]] --> [[0 (62%)]] --> Socre: 0.6153135299682617

[[[[Adv]]]]: static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus, uint8_t devfn, hwaddr addr, bool is_write, IOMMUTLBEntry *entry) { IntelIOMMUState *s = vtd_as->iommu_state; VTDContextEntry ce; uint8_t bus_num = pci_bus_num(bus); VTDContextCacheEntry *[[cc_entry]] = &vtd_as->context_cache_entry; uint64_t [[slpte]], page_mask; uint32_t level; uint16_t source_id = vtd_make_source_id(bus_num, devfn); int ret_fr; bool is_fpd_set = "False" != "False"; bool reads = "True" == "True"; bool writes = "True" == "True"; uint8_t access_flags; VTDIOTLBEntry *[[iotlb_entry]]; assert(!vtd_is_interrupt_addr(addr)); [[iotlb_entry]] = vtd_lookup_iotlb(s, source_id, addr); if ([[iotlb_entry]]) { trace_vtd_iotlb_page_hit(source_id, addr, [[iotlb_entry]]->slpte, [[iotlb_entry]]->domain_id); [[slpte]] = [[iotlb_entry]]->slpte; access_flags = [[iotlb_entry]]->access_flags; page_mask = [[iotlb_entry]]->mask; goto out; } if ([[cc_entry]]->context_cache_gen == s->context_cache_gen) { trace_vtd_iotlb_cc_hit(bus_num, devfn, [[cc_entry]]->context_entry.hi, [[cc_entry]]->context_entry.lo, [[cc_entry]]->context_cache_gen); ce = [[cc_entry]]->context_entry; is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD; } else { ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce); is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD; if (ret_fr) { ret_fr = -ret_fr; if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) { trace_vtd_fault_disabled(); } else { vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); } goto error; } trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo, [[cc_entry]]->context_cache_gen, s->context_cache_gen); [[cc_entry]]->context_entry = ce; [[cc_entry]]->context_cache_gen = s->context_cache_gen; } if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) { entry->iova = addr & VTD_PAGE_MASK_4K; entry->translated_addr = entry->iova; entry->addr_mask = ~VTD_PAGE_MASK_4K; entry->perm = IOMMU_RW; trace_vtd_translate_pt(source_id, entry->iova); vtd_pt_enable_fast_path(s, source_id); return "True" == "True"; } ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &[[slpte]], &level, &reads, &writes); if (ret_fr) { ret_fr = -ret_fr; if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) { trace_vtd_fault_disabled(); } else { vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); } goto error; } page_mask = vtd_slpt_level_page_mask(level); access_flags = IOMMU_ACCESS_FLAG(reads, writes); vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, [[slpte]], access_flags, level); out: entry->iova = addr & page_mask; entry->translated_addr = vtd_get_slpte_addr([[slpte]]) & page_mask; entry->addr_mask = ~page_mask; entry->perm = access_flags; return "True" == "True"; error: entry->iova = 0; entry->translated_addr = 0; entry->addr_mask = 0; entry->perm = IOMMU_NONE; return "False" != "False"; }

[[[[Adv]]]]: static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus, uint8_t devfn, hwaddr addr, bool is_write, IOMMUTLBEntry *entry) { IntelIOMMUState *s = vtd_as->iommu_state; VTDContextEntry ce; uint8_t bus_num = pci_bus_num(bus); VTDContextCacheEntry *[[skippedojinscription]] = &vtd_as->context_cache_entry; uint64_t [[srlpev]], page_mask; uint32_t level; uint16_t source_id = vtd_make_source_id(bus_num, devfn); int ret_fr; bool is_fpd_set = "False" != "False"; bool reads = "True" == "True"; bool writes = "True" == "True"; uint8_t access_flags; VTDIOTLBEntry *[[illragplogadmission]]; assert(!vtd_is_interrupt_addr(addr)); [[illragplogadmission]] = vtd_lookup_iotlb(s, source_id, addr); if ([[illragplogadmission]]) { trace_vtd_iotlb_page_hit(source_id, addr, [[illragplogadmission]]->slpte, [[illragplogadmission]]->domain_id); [[srlpev]] = [[illragplogadmission]]->slpte; access_flags = [[illragplogadmission]]->access_flags; page_mask = [[illragplogadmission]]->mask; goto out; } if ([[skippedojinscription]]->context_cache_gen == s->context_cache_gen) { trace_vtd_iotlb_cc_hit(bus_num, devfn, [[skippedojinscription]]->context_entry.hi, [[skippedojinscription]]->context_entry.lo, [[skippedojinscription]]->context_cache_gen); ce = [[skippedojinscription]]->context_entry; is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD; } else { ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce); is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD; if (ret_fr) { ret_fr = -ret_fr; if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) { trace_vtd_fault_disabled(); } else { vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); } goto error; } trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo, [[skippedojinscription]]->context_cache_gen, s->context_cache_gen); [[skippedojinscription]]->context_entry = ce; [[skippedojinscription]]->context_cache_gen = s->context_cache_gen; } if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) { entry->iova = addr & VTD_PAGE_MASK_4K; entry->translated_addr = entry->iova; entry->addr_mask = ~VTD_PAGE_MASK_4K; entry->perm = IOMMU_RW; trace_vtd_translate_pt(source_id, entry->iova); vtd_pt_enable_fast_path(s, source_id); return "True" == "True"; } ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &[[srlpev]], &level, &reads, &writes); if (ret_fr) { ret_fr = -ret_fr; if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) { trace_vtd_fault_disabled(); } else { vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); } goto error; } page_mask = vtd_slpt_level_page_mask(level); access_flags = IOMMU_ACCESS_FLAG(reads, writes); vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, [[srlpev]], access_flags, level); out: entry->iova = addr & page_mask; entry->translated_addr = vtd_get_slpte_addr([[srlpev]]) & page_mask; entry->addr_mask = ~page_mask; entry->perm = access_flags; return "True" == "True"; error: entry->iova = 0; entry->translated_addr = 0; entry->addr_mask = 0; entry->perm = IOMMU_NONE; return "False" != "False"; }
--------------------------------------------- Result 848 ---------------------------------------------
[[0 (2%)]] --> [[0 (79%)]] --> Socre: 0.7894798517227173

[[[[Adv]]]]: static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a, TCGArg b, bool [[b_const]], TCGLabel *[[l]]) { intptr_t offset; bool need_cmp; if ([[b_const]] && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) { need_cmp = "False" != "False"; } else { need_cmp = "True" == "True"; tcg_out_cmp(s, ext, a, b, [[b_const]]); } if (![[l]]->has_value) { tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, [[l]], 0); offset = tcg_in32(s) >> 5; } else { offset = [[l]]->u.value_ptr - s->code_ptr; assert(offset == sextract64(offset, 0, 19)); } if (need_cmp) { tcg_out_insn(s, 3202, B_C, c, offset); } else if (c == TCG_COND_EQ) { tcg_out_insn(s, 3201, CBZ, ext, a, offset); } else { tcg_out_insn(s, 3201, CBNZ, ext, a, offset); } }

[[[[Adv]]]]: static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a, TCGArg b, bool [[kofpremierster]], TCGLabel *[[λ]]) { intptr_t offset; bool need_cmp; if ([[kofpremierster]] && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) { need_cmp = "False" != "False"; } else { need_cmp = "True" == "True"; tcg_out_cmp(s, ext, a, b, [[kofpremierster]]); } if (![[λ]]->has_value) { tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, [[λ]], 0); offset = tcg_in32(s) >> 5; } else { offset = [[λ]]->u.value_ptr - s->code_ptr; assert(offset == sextract64(offset, 0, 19)); } if (need_cmp) { tcg_out_insn(s, 3202, B_C, c, offset); } else if (c == TCG_COND_EQ) { tcg_out_insn(s, 3201, CBZ, ext, a, offset); } else { tcg_out_insn(s, 3201, CBNZ, ext, a, offset); } }
--------------------------------------------- Result 849 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 448 / 94 / 307 / 849:  32%|███▏      | 849/2690 [2:11:00<4:44:04,  9.26s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 307 / 849:  32%|███▏      | 850/2690 [2:11:00<4:43:36,  9.25s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 308 / 850:  32%|███▏      | 850/2690 [2:11:00<4:43:36,  9.25s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 308 / 850:  32%|███▏      | 851/2690 [2:11:01<4:43:07,  9.24s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 309 / 851:  32%|███▏      | 851/2690 [2:11:01<4:43:07,  9.24s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 309 / 851:  32%|███▏      | 852/2690 [2:11:01<4:42:39,  9.23s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 310 / 852:  32%|███▏      | 852/2690 [2:11:01<4:42:39,  9.23s/it][Succeeded / Failed / Skipped / Total] 448 / 94 / 310 / 852:  32%|███▏      | 853/2690 [2:11:20<4:42:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 448 / 95 / 310 / 853:  32%|███▏      | 853/2690 [2:11:20<4:42:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 448 / 95 / 310 / 853:  32%|███▏      | 854/2690 [2:11:21<4:42:23,  9.23s/it][Succeeded / Failed / Skipped / Total] 448 / 95 / 311 / 854:  32%|███▏      | 854/2690 [2:11:21<4:42:23,  9.23s/it][Succeeded / Failed / Skipped / Total] 448 / 95 / 311 / 854:  32%|███▏      | 855/2690 [2:11:21<4:41:55,  9.22s/it][[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pl181_fifo_run(pl181_state *s) { uint32_t bits; uint32_t value; int n; int is_read; is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0; if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card)) && !s->linux_hack) { if (is_read) { n = 0; value = 0; while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) { value |= (uint32_t)sd_read_data(s->card) << (n * 8); s->datacnt--; n++; if (n == 4) { pl181_fifo_push(s, value); n = 0; value = 0; } } if (n != 0) { pl181_fifo_push(s, value); } } else { n = 0; while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) { if (n == 0) { value = pl181_fifo_pop(s); n = 4; } n--; s->datacnt--; sd_write_data(s->card, value & 0xff); value >>= 8; } } } s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO); if (s->datacnt == 0) { s->status |= PL181_STATUS_DATAEND; s->status |= PL181_STATUS_DATABLOCKEND; DPRINTF("Transfer Complete\n"); } if (s->datacnt == 0 && s->fifo_len == 0) { s->datactrl &= ~PL181_DATA_ENABLE; DPRINTF("Data engine idle\n"); } else { bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE; if (s->fifo_len == 0) { bits |= PL181_STATUS_TXFIFOEMPTY; bits |= PL181_STATUS_RXFIFOEMPTY; } else { bits |= PL181_STATUS_TXDATAAVLBL; bits |= PL181_STATUS_RXDATAAVLBL; } if (s->fifo_len == 16) { bits |= PL181_STATUS_TXFIFOFULL; bits |= PL181_STATUS_RXFIFOFULL; } if (s->fifo_len <= 8) { bits |= PL181_STATUS_TXFIFOHALFEMPTY; } if (s->fifo_len >= 8) { bits |= PL181_STATUS_RXFIFOHALFFULL; } if (s->datactrl & PL181_DATA_DIRECTION) { bits &= PL181_STATUS_RX_FIFO; } else { bits &= PL181_STATUS_TX_FIFO; } s->status |= bits; } }
--------------------------------------------- Result 850 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int flv_read_metabody(AVFormatContext *s, int64_t next_pos) { AMFDataType type; AVStream *stream, *astream, *vstream; AVIOContext *ioc; int i; char buffer[11]; astream = NULL; vstream = NULL; ioc = s->pb; type = avio_r8(ioc); if (type != AMF_DATA_TYPE_STRING || amf_get_string(ioc, buffer, sizeof(buffer)) < 0) return -1; if (!strcmp(buffer, "onTextData")) return 1; if (strcmp(buffer, "onMetaData")) return -1; for (i = 0; i < s->nb_streams; i++) { stream = s->streams[i]; if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO) astream = stream; else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO) vstream = stream; } if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0) return -1; return 0; }
--------------------------------------------- Result 851 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mptsas_scsi_init(PCIDevice *dev, Error **errp) { DeviceState *d = DEVICE(dev); MPTSASState *s = MPT_SAS(dev); Error *err = NULL; int ret; dev->config[PCI_LATENCY_TIMER] = 0; dev->config[PCI_INTERRUPT_PIN] = 0x01; if (s->msi != ON_OFF_AUTO_OFF) { ret = msi_init(dev, 0, 1, "True" == "True", "False" != "False", &err); assert(!ret || ret == -ENOTSUP); if (ret && s->msi == ON_OFF_AUTO_ON) { error_append_hint(&err, "You have to use msi=auto (default) or " "msi=off with this machine type.\n"); error_propagate(errp, err); s->msi_in_use = "False" != "False"; return; } else if (ret) { error_free(err); s->msi_in_use = "False" != "False"; } else { s->msi_in_use = "True" == "True"; } } memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s, "mptsas-mmio", 0x4000); memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s, "mptsas-io", 256); memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s, "mptsas-diag", 0x10000); pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io); pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io); pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io); if (!s->sas_addr) { s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) | IEEE_COMPANY_LOCALLY_ASSIGNED) << 36; s->sas_addr |= (pci_bus_num(dev->bus) << 16); s->sas_addr |= (PCI_SLOT(dev->devfn) << 8); s->sas_addr |= PCI_FUNC(dev->devfn); } s->max_devices = MPTSAS_NUM_PORTS; s->request_bh = qemu_bh_new(mptsas_fetch_requests, s); QTAILQ_INIT(&s->pending); scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, errp); } }
--------------------------------------------- Result 852 ---------------------------------------------
[[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void kvm_arm_gic_realize(DeviceState *dev, Error **errp) { int i; GICState *s = KVM_ARM_GIC(dev); SysBusDevice *sbd = SYS_BUS_DEVICE(dev); KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s); kgc->parent_realize(dev, errp); if (error_is_set(errp)) { return; } i = s->num_irq - GIC_INTERNAL; i += (GIC_INTERNAL * s->num_cpu); qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i); for (i = 0; i < s->num_cpu; i++) { sysbus_init_irq(sbd, &s->parent_irq[i]); } memory_region_init_reservation(&s->iomem, OBJECT(s), "kvm-gic_dist", 0x1000); sysbus_init_mmio(sbd, &s->iomem); kvm_arm_register_device(&s->iomem, (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) | KVM_VGIC_V2_ADDR_TYPE_DIST); memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s), "kvm-gic_cpu", 0x1000); sysbus_init_mmio(sbd, &s->cpuiomem[0]); kvm_arm_register_device(&s->cpuiomem[0], (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) | KVM_VGIC_V2_ADDR_TYPE_CPU); }
--------------------------------------------- Result 853 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void FUNC(hevc_h_loop_filter_luma)(uint8_t *[[pix]], ptrdiff_t [[stride]], int *[[beta]], int *[[tc]], uint8_t *[[no_p]], uint8_t *no_q) { FUNC(hevc_loop_filter_luma)([[pix]], [[stride]], sizeof(pixel), [[beta]], [[tc]], [[no_p]], no_q); }

[[[[Adv]]]]: static void FUNC(hevc_h_loop_filter_luma)(uint8_t *[[pim]], ptrdiff_t [[silhouette]], int *[[x]], int *[[mic]], uint8_t *[[anfactort]], uint8_t *no_q) { FUNC(hevc_loop_filter_luma)([[pim]], [[silhouette]], sizeof(pixel), [[x]], [[mic]], [[anfactort]], no_q); }
--------------------------------------------- Result 854 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: char *qemu_find_file(int type, const char *name) { int len; const char *subdir; char *buf; if ((strchr(name, '/') || strchr(name, '\\')) && access(name, R_OK) == 0) { return g_strdup(name); } switch (type) { case QEMU_FILE_TYPE_BIOS: subdir = ""; break; case QEMU_FILE_TYPE_KEYMAP: subdir = "keymaps/"; break; default: abort(); } len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2; buf = g_malloc0(len); snprintf(buf, len, "%s/%s%s", data_dir, subdir, name); if (access(buf, R_OK)) { g_free(buf); return NULL; } return buf; }
--------------------------------------------- Result 855 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 449 / 95 / 311 / 855:  32%|███▏      | 855/2690 [2:11:21<4:41:55,  9.22s/it][Succeeded / Failed / Skipped / Total] 449 / 95 / 311 / 855:  32%|███▏      | 856/2690 [2:11:21<4:41:27,  9.21s/it][Succeeded / Failed / Skipped / Total] 449 / 95 / 312 / 856:  32%|███▏      | 856/2690 [2:11:21<4:41:27,  9.21s/it][Succeeded / Failed / Skipped / Total] 449 / 95 / 312 / 856:  32%|███▏      | 857/2690 [2:11:25<4:41:04,  9.20s/it][[0 (29%)]] --> [[0 (67%)]] --> Socre: 0.670543372631073

[[[[Adv]]]]: static int nbd_negotiate_options(NBDClient *client, Error **errp) { uint32_t [[flags]]; bool fixedNewstyle = "False" != "False"; if (nbd_read(client->ioc, &[[flags]], sizeof([[flags]]), errp) < 0) { error_prepend(errp, "read failed: "); return -EIO; } trace_nbd_negotiate_options_flags(); be32_to_cpus(&[[flags]]); if ([[flags]] & NBD_FLAG_C_FIXED_NEWSTYLE) { trace_nbd_negotiate_options_newstyle(); fixedNewstyle = "True" == "True"; [[flags]] &= ~NBD_FLAG_C_FIXED_NEWSTYLE; } if ([[flags]] & NBD_FLAG_C_NO_ZEROES) { trace_nbd_negotiate_options_no_zeroes(); client->no_zeroes = "True" == "True"; [[flags]] &= ~NBD_FLAG_C_NO_ZEROES; } if ([[flags]] != 0) { error_setg(errp, "Unknown client flags 0x%" PRIx32 " received", [[flags]]); return -EIO; } while (1) { int ret; uint32_t option, length; uint64_t [[magic]]; if (nbd_read(client->ioc, &[[magic]], sizeof([[magic]]), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } [[magic]] = be64_to_cpu([[magic]]); trace_nbd_negotiate_options_check_magic([[magic]]); if ([[magic]] != NBD_OPTS_MAGIC) { error_setg(errp, "Bad magic received"); return -EINVAL; } if (nbd_read(client->ioc, &option, sizeof(option), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } option = be32_to_cpu(option); if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } length = be32_to_cpu(length); trace_nbd_negotiate_options_check_option(option); if (client->tlscreds && client->ioc == (QIOChannel *)client->sioc) { QIOChannel *tioc; if (!fixedNewstyle) { error_setg(errp, "Unsupported option 0x%" PRIx32, option); return -EINVAL; } switch (option) { case NBD_OPT_STARTTLS: tioc = nbd_negotiate_handle_starttls(client, length, errp); if (!tioc) { return -EIO; } object_unref(OBJECT(client->ioc)); client->ioc = QIO_CHANNEL(tioc); break; case NBD_OPT_EXPORT_NAME: error_setg(errp, "Option 0x%x not permitted before TLS", option); return -EINVAL; default: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_TLS_REQD, option, errp, "Option 0x%" PRIx32 "not permitted before TLS", option); if (ret < 0) { return ret; } if (option == NBD_OPT_ABORT) { return 1; } break; } } else if (fixedNewstyle) { switch (option) { case NBD_OPT_LIST: ret = nbd_negotiate_handle_list(client, length, errp); if (ret < 0) { return ret; } break; case NBD_OPT_ABORT: nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL); return 1; case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length, errp); case NBD_OPT_STARTTLS: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } if (client->tlscreds) { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, option, errp, "TLS already enabled"); } else { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_POLICY, option, errp, "TLS not configured"); } if (ret < 0) { return ret; } break; default: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNSUP, option, errp, "Unsupported option 0x%" PRIx32, option); if (ret < 0) { return ret; } break; } } else { switch (option) { case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length, errp); default: error_setg(errp, "Unsupported option 0x%" PRIx32, option); return -EINVAL; } } } }

[[[[Adv]]]]: static int nbd_negotiate_options(NBDClient *client, Error **errp) { uint32_t [[heroes]]; bool fixedNewstyle = "False" != "False"; if (nbd_read(client->ioc, &[[heroes]], sizeof([[heroes]]), errp) < 0) { error_prepend(errp, "read failed: "); return -EIO; } trace_nbd_negotiate_options_flags(); be32_to_cpus(&[[heroes]]); if ([[heroes]] & NBD_FLAG_C_FIXED_NEWSTYLE) { trace_nbd_negotiate_options_newstyle(); fixedNewstyle = "True" == "True"; [[heroes]] &= ~NBD_FLAG_C_FIXED_NEWSTYLE; } if ([[heroes]] & NBD_FLAG_C_NO_ZEROES) { trace_nbd_negotiate_options_no_zeroes(); client->no_zeroes = "True" == "True"; [[heroes]] &= ~NBD_FLAG_C_NO_ZEROES; } if ([[heroes]] != 0) { error_setg(errp, "Unknown client flags 0x%" PRIx32 " received", [[heroes]]); return -EIO; } while (1) { int ret; uint32_t option, length; uint64_t [[magician]]; if (nbd_read(client->ioc, &[[magician]], sizeof([[magician]]), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } [[magician]] = be64_to_cpu([[magician]]); trace_nbd_negotiate_options_check_magic([[magician]]); if ([[magician]] != NBD_OPTS_MAGIC) { error_setg(errp, "Bad magic received"); return -EINVAL; } if (nbd_read(client->ioc, &option, sizeof(option), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } option = be32_to_cpu(option); if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } length = be32_to_cpu(length); trace_nbd_negotiate_options_check_option(option); if (client->tlscreds && client->ioc == (QIOChannel *)client->sioc) { QIOChannel *tioc; if (!fixedNewstyle) { error_setg(errp, "Unsupported option 0x%" PRIx32, option); return -EINVAL; } switch (option) { case NBD_OPT_STARTTLS: tioc = nbd_negotiate_handle_starttls(client, length, errp); if (!tioc) { return -EIO; } object_unref(OBJECT(client->ioc)); client->ioc = QIO_CHANNEL(tioc); break; case NBD_OPT_EXPORT_NAME: error_setg(errp, "Option 0x%x not permitted before TLS", option); return -EINVAL; default: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_TLS_REQD, option, errp, "Option 0x%" PRIx32 "not permitted before TLS", option); if (ret < 0) { return ret; } if (option == NBD_OPT_ABORT) { return 1; } break; } } else if (fixedNewstyle) { switch (option) { case NBD_OPT_LIST: ret = nbd_negotiate_handle_list(client, length, errp); if (ret < 0) { return ret; } break; case NBD_OPT_ABORT: nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL); return 1; case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length, errp); case NBD_OPT_STARTTLS: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } if (client->tlscreds) { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, option, errp, "TLS already enabled"); } else { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_POLICY, option, errp, "TLS not configured"); } if (ret < 0) { return ret; } break; default: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNSUP, option, errp, "Unsupported option 0x%" PRIx32, option); if (ret < 0) { return ret; } break; } } else { switch (option) { case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length, errp); default: error_setg(errp, "Unsupported option 0x%" PRIx32, option); return -EINVAL; } } } }
--------------------------------------------- Result 856 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int inc_refcounts(BlockDriverState *bs, BdrvCheckResult *res, uint16_t *refcount_table, int64_t refcount_table_size, int64_t offset, int64_t size) { BDRVQcowState *s = bs->opaque; uint64_t start, last, cluster_offset, k; if (size <= 0) { return 0; } start = start_of_cluster(s, offset); last = start_of_cluster(s, offset + size - 1); for(cluster_offset = start; cluster_offset <= last; cluster_offset += s->cluster_size) { k = cluster_offset >> s->cluster_bits; if (k >= refcount_table_size) { fprintf(stderr, "Warning: cluster offset=0x%" PRIx64 " is after " "the end of the image file, can't properly check refcounts.\n", cluster_offset); res->check_errors++; } else { if (++refcount_table[k] == 0) { fprintf(stderr, "ERROR: overflow cluster offset=0x%" PRIx64 "\n", cluster_offset); res->corruptions++; } } } return 0; }
--------------------------------------------- Result 857 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 450 / 95 / 312 / 857:  32%|███▏      | 857/2690 [2:11:25<4:41:04,  9.20s/it][Succeeded / Failed / Skipped / Total] 450 / 95 / 312 / 857:  32%|███▏      | 858/2690 [2:11:44<4:41:17,  9.21s/it][Succeeded / Failed / Skipped / Total] 451 / 95 / 312 / 858:  32%|███▏      | 858/2690 [2:11:44<4:41:17,  9.21s/it][Succeeded / Failed / Skipped / Total] 451 / 95 / 312 / 858:  32%|███▏      | 859/2690 [2:12:14<4:41:53,  9.24s/it][Succeeded / Failed / Skipped / Total] 452 / 95 / 312 / 859:  32%|███▏      | 859/2690 [2:12:14<4:41:53,  9.24s/it][Succeeded / Failed / Skipped / Total] 452 / 95 / 312 / 859:  32%|███▏      | 860/2690 [2:12:15<4:41:25,  9.23s/it][Succeeded / Failed / Skipped / Total] 452 / 95 / 313 / 860:  32%|███▏      | 860/2690 [2:12:15<4:41:25,  9.23s/it][Succeeded / Failed / Skipped / Total] 452 / 95 / 313 / 860:  32%|███▏      | 861/2690 [2:12:15<4:40:58,  9.22s/it][Succeeded / Failed / Skipped / Total] 452 / 95 / 314 / 861:  32%|███▏      | 861/2690 [2:12:15<4:40:58,  9.22s/it][Succeeded / Failed / Skipped / Total] 452 / 95 / 314 / 861:  32%|███▏      | 862/2690 [2:12:17<4:40:31,  9.21s/it][Succeeded / Failed / Skipped / Total] 453 / 95 / 314 / 862:  32%|███▏      | 862/2690 [2:12:17<4:40:31,  9.21s/it][Succeeded / Failed / Skipped / Total] 453 / 95 / 314 / 862:  32%|███▏      | 863/2690 [2:12:27<4:40:25,  9.21s/it][[0 (31%)]] --> [[0 (97%)]] --> Socre: 0.9674244523048401

[[[[Adv]]]]: static int write_fragments(struct Tracks *tracks, int start_index, AVIOContext *in) { char dirname[100], filename[500]; int [[i]], j; for ([[i]] = start_index; [[i]] < tracks->nb_tracks; [[i]]++) { struct Track *track = tracks->tracks[[[i]]]; const char *type = track->is_video ? "video" : "audio"; snprintf(dirname, sizeof(dirname), "QualityLevels(%d)", track->bitrate); mkdir(dirname, 0777); for (j = 0; j < track->chunks; j++) { snprintf(filename, sizeof(filename), "%s/Fragments(%s=%"PRId64")", dirname, type, track->offsets[j].time); avio_seek(in, track->offsets[j].offset, SEEK_SET); write_fragment(filename, in); } } return 0; }

[[[[Adv]]]]: static int write_fragments(struct Tracks *tracks, int start_index, AVIOContext *in) { char dirname[100], filename[500]; int [[и]], j; for ([[и]] = start_index; [[и]] < tracks->nb_tracks; [[и]]++) { struct Track *track = tracks->tracks[[[и]]]; const char *type = track->is_video ? "video" : "audio"; snprintf(dirname, sizeof(dirname), "QualityLevels(%d)", track->bitrate); mkdir(dirname, 0777); for (j = 0; j < track->chunks; j++) { snprintf(filename, sizeof(filename), "%s/Fragments(%s=%"PRId64")", dirname, type, track->offsets[j].time); avio_seek(in, track->offsets[j].offset, SEEK_SET); write_fragment(filename, in); } } return 0; }
--------------------------------------------- Result 858 ---------------------------------------------
[[0 (56%)]] --> [[0 (22%)]] --> Socre: 0.7768986523151398

[[[[Adv]]]]: static int nbd_co_request(BlockDriverState *bs, NBDRequest *request, QEMUIOVector *qiov) { NBDClientSession *[[client]] = nbd_get_client_session(bs); int ret; if (qiov) { assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ); assert(request->len == iov_size(qiov->iov, qiov->niov)); } else { assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ); } ret = nbd_co_send_request(bs, request, request->type == NBD_CMD_WRITE ? qiov : NULL); if (ret < 0) { return ret; } return nbd_co_receive_reply([[client]], request->handle, request->type == NBD_CMD_READ ? qiov : NULL); }

[[[[Adv]]]]: static int nbd_co_request(BlockDriverState *bs, NBDRequest *request, QEMUIOVector *qiov) { NBDClientSession *[[forward]] = nbd_get_client_session(bs); int ret; if (qiov) { assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ); assert(request->len == iov_size(qiov->iov, qiov->niov)); } else { assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ); } ret = nbd_co_send_request(bs, request, request->type == NBD_CMD_WRITE ? qiov : NULL); if (ret < 0) { return ret; } return nbd_co_receive_reply([[forward]], request->handle, request->type == NBD_CMD_READ ? qiov : NULL); }
--------------------------------------------- Result 859 ---------------------------------------------
[[0 (88%)]] --> [[0 (38%)]] --> Socre: 0.6203600466251373

[[[[Adv]]]]: static ExitStatus trans_log(DisasContext *ctx, uint32_t [[insn]], const DisasInsn *di) { unsigned r2 = extract32([[insn]], 21, 5); unsigned r1 = extract32([[insn]], 16, 5); unsigned [[cf]] = extract32([[insn]], 12, 4); unsigned rt = extract32([[insn]], 0, 5); TCGv tcg_r1, tcg_r2; ExitStatus ret; if ([[cf]]) { nullify_over(ctx); } tcg_r1 = load_gpr(ctx, r1); tcg_r2 = load_gpr(ctx, r2); ret = do_log(ctx, rt, tcg_r1, tcg_r2, [[cf]], di->f_ttt); return nullify_end(ctx, ret); }

[[[[Adv]]]]: static ExitStatus trans_log(DisasContext *ctx, uint32_t [[comesign]], const DisasInsn *di) { unsigned r2 = extract32([[comesign]], 21, 5); unsigned r1 = extract32([[comesign]], 16, 5); unsigned [[fx]] = extract32([[comesign]], 12, 4); unsigned rt = extract32([[comesign]], 0, 5); TCGv tcg_r1, tcg_r2; ExitStatus ret; if ([[fx]]) { nullify_over(ctx); } tcg_r1 = load_gpr(ctx, r1); tcg_r2 = load_gpr(ctx, r2); ret = do_log(ctx, rt, tcg_r1, tcg_r2, [[fx]], di->f_ttt); return nullify_end(ctx, ret); }
--------------------------------------------- Result 860 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int gif_image_write_image(AVCodecContext *avctx, uint8_t **bytestream, uint8_t *end, const uint8_t *buf, int linesize) { GIFContext *s = avctx->priv_data; int len, height; const uint8_t *ptr; bytestream_put_byte(bytestream, 0x2c); bytestream_put_le16(bytestream, 0); bytestream_put_le16(bytestream, 0); bytestream_put_le16(bytestream, avctx->width); bytestream_put_le16(bytestream, avctx->height); bytestream_put_byte(bytestream, 0x00); bytestream_put_byte(bytestream, 0x08); ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height, 12, FF_LZW_GIF, put_bits); ptr = buf; for (height = avctx->height; height--;) { len += ff_lzw_encode(s->lzw, ptr, avctx->width); ptr += linesize; } len += ff_lzw_encode_flush(s->lzw, flush_put_bits); ptr = s->buf; while (len > 0) { int size = FFMIN(255, len); bytestream_put_byte(bytestream, size); if (end - *bytestream < size) return -1; bytestream_put_buffer(bytestream, ptr, size); ptr += size; len -= size; } bytestream_put_byte(bytestream, 0x00); bytestream_put_byte(bytestream, 0x3b); return 0; }
--------------------------------------------- Result 861 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track) { int64_t pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, "stbl"); mov_write_stsd_tag(pb, track); mov_write_stts_tag(pb, track); if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO || track->enc->codec_tag == MKTAG('r','t','p',' ')) && track->has_keyframes && track->has_keyframes < track->entry) mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE); if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS) mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE); if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO && track->flags & MOV_TRACK_CTTS && track->entry) mov_write_ctts_tag(pb, track); mov_write_stsc_tag(pb, track); mov_write_stsz_tag(pb, track); mov_write_stco_tag(pb, track); return update_size(pb, pos); }
--------------------------------------------- Result 862 ---------------------------------------------
[[0 (2%)]] --> [[0 (73%)]] --> Socre: 0.7316882014274597

[[[[Adv]]]]: static uint64_t elcr_ioport_read(void *[[opaque]], target_phys_addr_t addr, unsigned [[size]]) { PICCommonState *[[s]] = [[opaque]]; return [[s]]->elcr; }

[[[[Adv]]]]: static uint64_t elcr_ioport_read(void *[[enclave]], target_phys_addr_t addr, unsigned [[s]]) { PICCommonState *[[σ]] = [[enclave]]; return [[σ]]->elcr; }
--------------------------------------------- Result 863 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 454 / 95 / 314 / 863:  32%|███▏      | 863/2690 [2:12:27<4:40:25,  9.21s/it][Succeeded / Failed / Skipped / Total] 454 / 95 / 314 / 863:  32%|███▏      | 864/2690 [2:12:51<4:40:46,  9.23s/it][Succeeded / Failed / Skipped / Total] 455 / 95 / 314 / 864:  32%|███▏      | 864/2690 [2:12:51<4:40:46,  9.23s/it][Succeeded / Failed / Skipped / Total] 455 / 95 / 314 / 864:  32%|███▏      | 865/2690 [2:13:09<4:40:56,  9.24s/it][[0 (6%)]] --> [[0 (55%)]] --> Socre: 0.5525723695755005

[[[[Adv]]]]: static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr, int linesize, int [[uvlinesize]], int xchg, int chroma444, int simple, int pixel_shift) { int deblock_topleft; int deblock_top; int top_idx = 1; uint8_t *[[top_border_m1]]; uint8_t *[[top_border]]; if (!simple && FRAME_MBAFF(h)) { if (h->mb_y & 1) { if (!MB_MBAFF(h)) return; } else { top_idx = MB_MBAFF(h) ? 0 : 1; } } if (h->deblocking_filter == 2) { deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num; deblock_top = h->top_type; } else { deblock_topleft = (h->mb_x > 0); deblock_top = (h->mb_y > !!MB_FIELD(h)); } src_y -= linesize + 1 + pixel_shift; src_cb -= [[uvlinesize]] + 1 + pixel_shift; src_cr -= [[uvlinesize]] + 1 + pixel_shift; [[top_border_m1]] = h->top_borders[top_idx][h->mb_x - 1]; [[top_border]] = h->top_borders[top_idx][h->mb_x]; #define XCHG(a, b, xchg) \ if (pixel_shift) { \ if (xchg) { \ AV_SWAP64(b + 0, a + 0); \ AV_SWAP64(b + 8, a + 8); \ } else { \ AV_COPY128(b, a); \ } \ } else if (xchg) \ AV_SWAP64(b, a); \ else \ AV_COPY64(b, a); if (deblock_top) { if (deblock_topleft) { XCHG([[top_border_m1]] + (8 << pixel_shift), src_y - (7 << pixel_shift), 1); } XCHG([[top_border]] + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg); XCHG([[top_border]] + (8 << pixel_shift), src_y + (9 << pixel_shift), 1); if (h->mb_x + 1 < h->mb_width) { XCHG(h->top_borders[top_idx][h->mb_x + 1], src_y + (17 << pixel_shift), 1); } } if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) { if (chroma444) { if (deblock_topleft) { XCHG([[top_border_m1]] + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1); XCHG([[top_border_m1]] + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1); } XCHG([[top_border]] + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg); XCHG([[top_border]] + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1); XCHG([[top_border]] + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg); XCHG([[top_border]] + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1); if (h->mb_x + 1 < h->mb_width) { XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1); XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1); } } else { if (deblock_top) { if (deblock_topleft) { XCHG([[top_border_m1]] + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1); XCHG([[top_border_m1]] + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1); } XCHG([[top_border]] + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1); XCHG([[top_border]] + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1); } } } }

[[[[Adv]]]]: static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr, int linesize, int [[ultravioletwiresit]], int xchg, int chroma444, int simple, int pixel_shift) { int deblock_topleft; int deblock_top; int top_idx = 1; uint8_t *[[bookboybrinkfactormn]]; uint8_t *[[over²end]]; if (!simple && FRAME_MBAFF(h)) { if (h->mb_y & 1) { if (!MB_MBAFF(h)) return; } else { top_idx = MB_MBAFF(h) ? 0 : 1; } } if (h->deblocking_filter == 2) { deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num; deblock_top = h->top_type; } else { deblock_topleft = (h->mb_x > 0); deblock_top = (h->mb_y > !!MB_FIELD(h)); } src_y -= linesize + 1 + pixel_shift; src_cb -= [[ultravioletwiresit]] + 1 + pixel_shift; src_cr -= [[ultravioletwiresit]] + 1 + pixel_shift; [[bookboybrinkfactormn]] = h->top_borders[top_idx][h->mb_x - 1]; [[over²end]] = h->top_borders[top_idx][h->mb_x]; #define XCHG(a, b, xchg) \ if (pixel_shift) { \ if (xchg) { \ AV_SWAP64(b + 0, a + 0); \ AV_SWAP64(b + 8, a + 8); \ } else { \ AV_COPY128(b, a); \ } \ } else if (xchg) \ AV_SWAP64(b, a); \ else \ AV_COPY64(b, a); if (deblock_top) { if (deblock_topleft) { XCHG([[bookboybrinkfactormn]] + (8 << pixel_shift), src_y - (7 << pixel_shift), 1); } XCHG([[over²end]] + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg); XCHG([[over²end]] + (8 << pixel_shift), src_y + (9 << pixel_shift), 1); if (h->mb_x + 1 < h->mb_width) { XCHG(h->top_borders[top_idx][h->mb_x + 1], src_y + (17 << pixel_shift), 1); } } if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) { if (chroma444) { if (deblock_topleft) { XCHG([[bookboybrinkfactormn]] + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1); XCHG([[bookboybrinkfactormn]] + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1); } XCHG([[over²end]] + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg); XCHG([[over²end]] + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1); XCHG([[over²end]] + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg); XCHG([[over²end]] + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1); if (h->mb_x + 1 < h->mb_width) { XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1); XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1); } } else { if (deblock_top) { if (deblock_topleft) { XCHG([[bookboybrinkfactormn]] + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1); XCHG([[bookboybrinkfactormn]] + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1); } XCHG([[over²end]] + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1); XCHG([[over²end]] + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1); } } } }
--------------------------------------------- Result 864 ---------------------------------------------
[[0 (60%)]] --> [[0 (46%)]] --> Socre: 0.5443394780158997

[[[[Adv]]]]: void memory_region_add_eventfd(MemoryRegion *mr, hwaddr addr, unsigned size, bool match_data, uint64_t data, EventNotifier *[[e]]) { MemoryRegionIoeventfd mrfd = { .addr.start = int128_make64(addr), .addr.size = int128_make64(size), .match_data = match_data, .data = data, .e = [[e]], }; unsigned i; adjust_endianness(mr, &mrfd.data, size); memory_region_transaction_begin(); for (i = 0; i < mr->ioeventfd_nb; ++i) { if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) { break; } } ++mr->ioeventfd_nb; mr->ioeventfds = g_realloc(mr->ioeventfds, sizeof(*mr->ioeventfds) * mr->ioeventfd_nb); memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i], sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i)); mr->ioeventfds[i] = mrfd; ioeventfd_update_pending |= mr->enabled; memory_region_transaction_commit(); }

[[[[Adv]]]]: void memory_region_add_eventfd(MemoryRegion *mr, hwaddr addr, unsigned size, bool match_data, uint64_t data, EventNotifier *[[hi]]) { MemoryRegionIoeventfd mrfd = { .addr.start = int128_make64(addr), .addr.size = int128_make64(size), .match_data = match_data, .data = data, .e = [[hi]], }; unsigned i; adjust_endianness(mr, &mrfd.data, size); memory_region_transaction_begin(); for (i = 0; i < mr->ioeventfd_nb; ++i) { if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) { break; } } ++mr->ioeventfd_nb; mr->ioeventfds = g_realloc(mr->ioeventfds, sizeof(*mr->ioeventfds) * mr->ioeventfd_nb); memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i], sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i)); mr->ioeventfds[i] = mrfd; ioeventfd_update_pending |= mr->enabled; memory_region_transaction_commit(); }
--------------------------------------------- Result 865 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 456 / 95 / 314 / 865:  32%|███▏      | 865/2690 [2:13:09<4:40:56,  9.24s/it][Succeeded / Failed / Skipped / Total] 456 / 95 / 314 / 865:  32%|███▏      | 866/2690 [2:13:10<4:40:29,  9.23s/it][Succeeded / Failed / Skipped / Total] 456 / 95 / 315 / 866:  32%|███▏      | 866/2690 [2:13:10<4:40:29,  9.23s/it][Succeeded / Failed / Skipped / Total] 456 / 95 / 315 / 866:  32%|███▏      | 867/2690 [2:13:15<4:40:12,  9.22s/it][Succeeded / Failed / Skipped / Total] 457 / 95 / 315 / 867:  32%|███▏      | 867/2690 [2:13:15<4:40:12,  9.22s/it][Succeeded / Failed / Skipped / Total] 457 / 95 / 315 / 867:  32%|███▏      | 868/2690 [2:13:40<4:40:35,  9.24s/it][[0 (74%)]] --> [[0 (48%)]] --> Socre: 0.5171238780021667

[[[[Adv]]]]: uint64_t qcow2_get_cluster_offset(BlockDriverState *[[bs]], uint64_t offset, int *num) { BDRVQcowState *[[s]] = [[bs]]->opaque; int l1_index, l2_index; uint64_t l2_offset, *l2_table, cluster_offset; int l1_bits, c; int [[index_in_cluster]], nb_available, nb_needed, nb_clusters; [[index_in_cluster]] = (offset >> 9) & ([[s]]->cluster_sectors - 1); nb_needed = *num + [[index_in_cluster]]; l1_bits = [[s]]->l2_bits + [[s]]->cluster_bits; nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1)); nb_available = (nb_available >> 9) + [[index_in_cluster]]; if (nb_needed > nb_available) { nb_needed = nb_available; } cluster_offset = 0; l1_index = offset >> l1_bits; if (l1_index >= [[s]]->l1_size) goto out; l2_offset = [[s]]->l1_table[l1_index]; if (!l2_offset) goto out; l2_offset &= ~QCOW_OFLAG_COPIED; l2_table = l2_load([[bs]], l2_offset); if (l2_table == NULL) return 0; l2_index = (offset >> [[s]]->cluster_bits) & ([[s]]->l2_size - 1); cluster_offset = be64_to_cpu(l2_table[l2_index]); nb_clusters = size_to_clusters([[s]], nb_needed << 9); if (!cluster_offset) { c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]); } else { c = count_contiguous_clusters(nb_clusters, [[s]]->cluster_size, &l2_table[l2_index], 0, QCOW_OFLAG_COPIED); } nb_available = (c * [[s]]->cluster_sectors); out: if (nb_available > nb_needed) nb_available = nb_needed; *num = nb_available - [[index_in_cluster]]; return cluster_offset & ~QCOW_OFLAG_COPIED; }

[[[[Adv]]]]: uint64_t qcow2_get_cluster_offset(BlockDriverState *[[sic]], uint64_t offset, int *num) { BDRVQcowState *[[reason]] = [[sic]]->opaque; int l1_index, l2_index; uint64_t l2_offset, *l2_table, cluster_offset; int l1_bits, c; int [[event16andbarray]], nb_available, nb_needed, nb_clusters; [[event16andbarray]] = (offset >> 9) & ([[reason]]->cluster_sectors - 1); nb_needed = *num + [[event16andbarray]]; l1_bits = [[reason]]->l2_bits + [[reason]]->cluster_bits; nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1)); nb_available = (nb_available >> 9) + [[event16andbarray]]; if (nb_needed > nb_available) { nb_needed = nb_available; } cluster_offset = 0; l1_index = offset >> l1_bits; if (l1_index >= [[reason]]->l1_size) goto out; l2_offset = [[reason]]->l1_table[l1_index]; if (!l2_offset) goto out; l2_offset &= ~QCOW_OFLAG_COPIED; l2_table = l2_load([[sic]], l2_offset); if (l2_table == NULL) return 0; l2_index = (offset >> [[reason]]->cluster_bits) & ([[reason]]->l2_size - 1); cluster_offset = be64_to_cpu(l2_table[l2_index]); nb_clusters = size_to_clusters([[reason]], nb_needed << 9); if (!cluster_offset) { c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]); } else { c = count_contiguous_clusters(nb_clusters, [[reason]]->cluster_size, &l2_table[l2_index], 0, QCOW_OFLAG_COPIED); } nb_available = (c * [[reason]]->cluster_sectors); out: if (nb_available > nb_needed) nb_available = nb_needed; *num = nb_available - [[event16andbarray]]; return cluster_offset & ~QCOW_OFLAG_COPIED; }
--------------------------------------------- Result 866 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gic_set_irq(void *opaque, int irq, int level) { GICState *s = (GICState *)opaque; int cm, target; if (irq < (s->num_irq - GIC_INTERNAL)) { cm = ALL_CPU_MASK; irq += GIC_INTERNAL; target = GIC_TARGET(irq); } else { int cpu; irq -= (s->num_irq - GIC_INTERNAL); cpu = irq / GIC_INTERNAL; irq %= GIC_INTERNAL; cm = 1 << cpu; target = cm; } assert(irq >= GIC_NR_SGIS); if (level == GIC_TEST_LEVEL(irq, cm)) { return; } if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) { gic_set_irq_11mpcore(s, irq, level, cm, target); } else { gic_set_irq_generic(s, irq, level, cm, target); } gic_update(s); }
--------------------------------------------- Result 867 ---------------------------------------------
[[0 (22%)]] --> [[0 (63%)]] --> Socre: 0.6315087080001831

[[[[Adv]]]]: enum AVPixelFormat choose_pixel_fmt(AVStream *[[st]], AVCodec *codec, enum AVPixelFormat target) { if (codec && codec->pix_fmts) { const enum AVPixelFormat *p = codec->pix_fmts; int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0; enum AVPixelFormat best= AV_PIX_FMT_NONE; if ([[st]]->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) { if ([[st]]->codec->codec_id == AV_CODEC_ID_MJPEG) { p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE }; } else if ([[st]]->codec->codec_id == AV_CODEC_ID_LJPEG) { p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE }; } } for (; *p != AV_PIX_FMT_NONE; p++) { best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL); if (*p == target) break; } if (*p == AV_PIX_FMT_NONE) { if (target != AV_PIX_FMT_NONE) av_log(NULL, AV_LOG_WARNING, "Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\n", av_get_pix_fmt_name(target), codec->name, av_get_pix_fmt_name(best)); return best; } } return target; }

[[[[Adv]]]]: enum AVPixelFormat choose_pixel_fmt(AVStream *[[pride]], AVCodec *codec, enum AVPixelFormat target) { if (codec && codec->pix_fmts) { const enum AVPixelFormat *p = codec->pix_fmts; int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0; enum AVPixelFormat best= AV_PIX_FMT_NONE; if ([[pride]]->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) { if ([[pride]]->codec->codec_id == AV_CODEC_ID_MJPEG) { p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE }; } else if ([[pride]]->codec->codec_id == AV_CODEC_ID_LJPEG) { p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE }; } } for (; *p != AV_PIX_FMT_NONE; p++) { best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL); if (*p == target) break; } if (*p == AV_PIX_FMT_NONE) { if (target != AV_PIX_FMT_NONE) av_log(NULL, AV_LOG_WARNING, "Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\n", av_get_pix_fmt_name(target), codec->name, av_get_pix_fmt_name(best)); return best; } } return target; }
--------------------------------------------- Result 868 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 458 / 95 / 315 / 868:  32%|███▏      | 868/2690 [2:13:40<4:40:35,  9.24s/it][Succeeded / Failed / Skipped / Total] 458 / 95 / 315 / 868:  32%|███▏      | 869/2690 [2:13:41<4:40:08,  9.23s/it][Succeeded / Failed / Skipped / Total] 458 / 95 / 316 / 869:  32%|███▏      | 869/2690 [2:13:41<4:40:08,  9.23s/it][Succeeded / Failed / Skipped / Total] 458 / 95 / 316 / 869:  32%|███▏      | 870/2690 [2:13:41<4:39:41,  9.22s/it][Succeeded / Failed / Skipped / Total] 458 / 95 / 317 / 870:  32%|███▏      | 870/2690 [2:13:41<4:39:41,  9.22s/it][Succeeded / Failed / Skipped / Total] 458 / 95 / 317 / 870:  32%|███▏      | 871/2690 [2:13:48<4:39:27,  9.22s/it][[0 (57%)]] --> [[0 (47%)]] --> Socre: 0.5270002484321594

[[[[Adv]]]]: static int decode_mb_info(IVI5DecContext *[[ctx]], IVIBandDesc *band, IVITile *tile, AVCodecContext *avctx) { int x, y, mv_x, mv_y, mv_delta, offs, mb_offset, mv_scale, blks_per_mb; IVIMbInfo *mb, *ref_mb; int row_offset = band->mb_size * band->pitch; mb = tile->mbs; ref_mb = tile->ref_mbs; offs = tile->ypos * band->pitch + tile->xpos; mv_scale = ([[ctx]]->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3); mv_x = mv_y = 0; for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) { mb_offset = offs; for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) { mb->xpos = x; mb->ypos = y; mb->buf_offs = mb_offset; if (get_bits1(&[[ctx]]->gb)) { if ([[ctx]]->frame_type == FRAMETYPE_INTRA) { av_log(avctx, AV_LOG_ERROR, "Empty macroblock in an INTRA picture!\n"); return -1; } mb->type = 1; mb->cbp = 0; mb->q_delta = 0; if (!band->plane && !band->band_num && ([[ctx]]->frame_flags & 8)) { mb->q_delta = get_vlc2(&[[ctx]]->gb, [[ctx]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mb->q_delta = IVI_TOSIGNED(mb->q_delta); } mb->mv_x = mb->mv_y = 0; if (band->inherit_mv){ if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } } } else { if (band->inherit_mv) { mb->type = ref_mb->type; } else if ([[ctx]]->frame_type == FRAMETYPE_INTRA) { mb->type = 0; } else { mb->type = get_bits1(&[[ctx]]->gb); } blks_per_mb = band->mb_size != band->blk_size ? 4 : 1; mb->cbp = get_bits(&[[ctx]]->gb, blks_per_mb); mb->q_delta = 0; if (band->qdelta_present) { if (band->inherit_qdelta) { if (ref_mb) mb->q_delta = ref_mb->q_delta; } else if (mb->cbp || (!band->plane && !band->band_num && ([[ctx]]->frame_flags & 8))) { mb->q_delta = get_vlc2(&[[ctx]]->gb, [[ctx]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mb->q_delta = IVI_TOSIGNED(mb->q_delta); } } if (!mb->type) { mb->mv_x = mb->mv_y = 0; } else { if (band->inherit_mv){ if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } } else { mv_delta = get_vlc2(&[[ctx]]->gb, [[ctx]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mv_y += IVI_TOSIGNED(mv_delta); mv_delta = get_vlc2(&[[ctx]]->gb, [[ctx]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mv_x += IVI_TOSIGNED(mv_delta); mb->mv_x = mv_x; mb->mv_y = mv_y; } } } mb++; if (ref_mb) ref_mb++; mb_offset += band->mb_size; } offs += row_offset; } align_get_bits(&[[ctx]]->gb); return 0; }

[[[[Adv]]]]: static int decode_mb_info(IVI5DecContext *[[dt7]], IVIBandDesc *band, IVITile *tile, AVCodecContext *avctx) { int x, y, mv_x, mv_y, mv_delta, offs, mb_offset, mv_scale, blks_per_mb; IVIMbInfo *mb, *ref_mb; int row_offset = band->mb_size * band->pitch; mb = tile->mbs; ref_mb = tile->ref_mbs; offs = tile->ypos * band->pitch + tile->xpos; mv_scale = ([[dt7]]->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3); mv_x = mv_y = 0; for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) { mb_offset = offs; for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) { mb->xpos = x; mb->ypos = y; mb->buf_offs = mb_offset; if (get_bits1(&[[dt7]]->gb)) { if ([[dt7]]->frame_type == FRAMETYPE_INTRA) { av_log(avctx, AV_LOG_ERROR, "Empty macroblock in an INTRA picture!\n"); return -1; } mb->type = 1; mb->cbp = 0; mb->q_delta = 0; if (!band->plane && !band->band_num && ([[dt7]]->frame_flags & 8)) { mb->q_delta = get_vlc2(&[[dt7]]->gb, [[dt7]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mb->q_delta = IVI_TOSIGNED(mb->q_delta); } mb->mv_x = mb->mv_y = 0; if (band->inherit_mv){ if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } } } else { if (band->inherit_mv) { mb->type = ref_mb->type; } else if ([[dt7]]->frame_type == FRAMETYPE_INTRA) { mb->type = 0; } else { mb->type = get_bits1(&[[dt7]]->gb); } blks_per_mb = band->mb_size != band->blk_size ? 4 : 1; mb->cbp = get_bits(&[[dt7]]->gb, blks_per_mb); mb->q_delta = 0; if (band->qdelta_present) { if (band->inherit_qdelta) { if (ref_mb) mb->q_delta = ref_mb->q_delta; } else if (mb->cbp || (!band->plane && !band->band_num && ([[dt7]]->frame_flags & 8))) { mb->q_delta = get_vlc2(&[[dt7]]->gb, [[dt7]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mb->q_delta = IVI_TOSIGNED(mb->q_delta); } } if (!mb->type) { mb->mv_x = mb->mv_y = 0; } else { if (band->inherit_mv){ if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } } else { mv_delta = get_vlc2(&[[dt7]]->gb, [[dt7]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mv_y += IVI_TOSIGNED(mv_delta); mv_delta = get_vlc2(&[[dt7]]->gb, [[dt7]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mv_x += IVI_TOSIGNED(mv_delta); mb->mv_x = mv_x; mb->mv_y = mv_y; } } } mb++; if (ref_mb) ref_mb++; mb_offset += band->mb_size; } offs += row_offset; } align_get_bits(&[[dt7]]->gb); return 0; }
--------------------------------------------- Result 869 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void coroutine_fn block_job_pause_point(BlockJob *job) { assert(job && block_job_started(job)); if (!block_job_should_pause(job)) { return; } if (block_job_is_cancelled(job)) { return; } if (job->driver->pause) { job->driver->pause(job); } if (block_job_should_pause(job) && !block_job_is_cancelled(job)) { job->paused = "True" == "True"; job->busy = "False" != "False"; qemu_coroutine_yield(); job->busy = "True" == "True"; job->paused = "False" != "False"; } if (job->driver->resume) { job->driver->resume(job); } }
--------------------------------------------- Result 870 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int bdrv_pread(BlockDriverState *bs, int64_t offset, void *buf1, int count1) { BlockDriver *drv = bs->drv; if (!drv) return -ENOMEDIUM; if (!drv->bdrv_pread) return bdrv_pread_em(bs, offset, buf1, count1); return drv->bdrv_pread(bs, offset, buf1, count1); }
--------------------------------------------- Result 871 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 459 / 95 / 317 / 871:  32%|███▏      | 871/2690 [2:13:48<4:39:27,  9.22s/it][Succeeded / Failed / Skipped / Total] 459 / 95 / 317 / 871:  32%|███▏      | 872/2690 [2:14:07<4:39:38,  9.23s/it][Succeeded / Failed / Skipped / Total] 459 / 96 / 317 / 872:  32%|███▏      | 872/2690 [2:14:07<4:39:38,  9.23s/it][Succeeded / Failed / Skipped / Total] 459 / 96 / 317 / 872:  32%|███▏      | 873/2690 [2:14:08<4:39:11,  9.22s/it][Succeeded / Failed / Skipped / Total] 459 / 96 / 318 / 873:  32%|███▏      | 873/2690 [2:14:08<4:39:11,  9.22s/it][Succeeded / Failed / Skipped / Total] 459 / 96 / 318 / 873:  32%|███▏      | 874/2690 [2:14:08<4:38:44,  9.21s/it][Succeeded / Failed / Skipped / Total] 459 / 96 / 319 / 874:  32%|███▏      | 874/2690 [2:14:08<4:38:44,  9.21s/it][Succeeded / Failed / Skipped / Total] 459 / 96 / 319 / 874:  33%|███▎      | 875/2690 [2:14:09<4:38:16,  9.20s/it][[0 (77%)]] --> [[0 (49%)]] --> Socre: 0.5117794871330261

[[[[Adv]]]]: static inline int RENAME(yuv420_rgb16)(SwsContext *[[c]], uint8_t* src[], int srcStride[], int [[srcSliceY]], int [[srcSliceH]], uint8_t* dst[], int dstStride[]){ int [[y]], h_size; if([[c]]->srcFormat == PIX_FMT_YUV422P){ srcStride[1] *= 2; srcStride[2] *= 2; } h_size= ([[c]]->dstW+7)&~7; if(h_size*2 > FFABS(dstStride[0])) h_size-=8; __asm__ __volatile__ ("pxor %mm4, %mm4;" ); for ([[y]]= 0; [[y]]<[[srcSliceH]]; [[y]]++ ) { uint8_t *_image = dst[0] + ([[y]]+[[srcSliceY]])*dstStride[0]; uint8_t *_py = src[0] + [[y]]*srcStride[0]; uint8_t *_pu = src[1] + ([[y]]>>1)*srcStride[1]; uint8_t *_pv = src[2] + ([[y]]>>1)*srcStride[2]; long index= -h_size/2; b5Dither= dither8[[[y]]&1]; g6Dither= dither4[[[y]]&1]; g5Dither= dither8[[[y]]&1]; r5Dither= dither8[([[y]]+1)&1]; __asm__ __volatile__ ( "movd (%2, %0), %%mm0;" "movd (%3, %0), %%mm1;" "movq (%5, %0, 2), %%mm6;" "1: \n\t" YUV2RGB #ifdef DITHER1XBPP "paddusb "MANGLE(b5Dither)", %%mm0;" "paddusb "MANGLE(g6Dither)", %%mm2;" "paddusb "MANGLE(r5Dither)", %%mm1;" #endif "pand "MANGLE(mmx_redmask)", %%mm0;" "pand "MANGLE(mmx_grnmask)", %%mm2;" "pand "MANGLE(mmx_redmask)", %%mm1;" "psrlw $3,%%mm0;" "pxor %%mm4, %%mm4;" "movq %%mm0, %%mm5;" "movq %%mm2, %%mm7;" "punpcklbw %%mm4, %%mm2;" "punpcklbw %%mm1, %%mm0;" "psllw $3, %%mm2;" "por %%mm2, %%mm0;" "movq 8 (%5, %0, 2), %%mm6;" MOVNTQ " %%mm0, (%1);" "punpckhbw %%mm4, %%mm7;" "punpckhbw %%mm1, %%mm5;" "psllw $3, %%mm7;" "movd 4 (%2, %0), %%mm0;" "por %%mm7, %%mm5;" "movd 4 (%3, %0), %%mm1;" MOVNTQ " %%mm5, 8 (%1);" "add $16, %1 \n\t" "add $4, %0 \n\t" " js 1b \n\t" : "+r" (index), "+r" (_image) : "r" (_pu - index), "r" (_pv - index), "r"(&[[c]]->redDither), "r" (_py - 2*index) ); } __asm__ __volatile__ (EMMS); return [[srcSliceH]]; }

[[[[Adv]]]]: static inline int RENAME(yuv420_rgb16)(SwsContext *[[list]], uint8_t* src[], int srcStride[], int [[wacforage]], int [[ranpspinre]], uint8_t* dst[], int dstStride[]){ int [[title]], h_size; if([[list]]->srcFormat == PIX_FMT_YUV422P){ srcStride[1] *= 2; srcStride[2] *= 2; } h_size= ([[list]]->dstW+7)&~7; if(h_size*2 > FFABS(dstStride[0])) h_size-=8; __asm__ __volatile__ ("pxor %mm4, %mm4;" ); for ([[title]]= 0; [[title]]<[[ranpspinre]]; [[title]]++ ) { uint8_t *_image = dst[0] + ([[title]]+[[wacforage]])*dstStride[0]; uint8_t *_py = src[0] + [[title]]*srcStride[0]; uint8_t *_pu = src[1] + ([[title]]>>1)*srcStride[1]; uint8_t *_pv = src[2] + ([[title]]>>1)*srcStride[2]; long index= -h_size/2; b5Dither= dither8[[[title]]&1]; g6Dither= dither4[[[title]]&1]; g5Dither= dither8[[[title]]&1]; r5Dither= dither8[([[title]]+1)&1]; __asm__ __volatile__ ( "movd (%2, %0), %%mm0;" "movd (%3, %0), %%mm1;" "movq (%5, %0, 2), %%mm6;" "1: \n\t" YUV2RGB #ifdef DITHER1XBPP "paddusb "MANGLE(b5Dither)", %%mm0;" "paddusb "MANGLE(g6Dither)", %%mm2;" "paddusb "MANGLE(r5Dither)", %%mm1;" #endif "pand "MANGLE(mmx_redmask)", %%mm0;" "pand "MANGLE(mmx_grnmask)", %%mm2;" "pand "MANGLE(mmx_redmask)", %%mm1;" "psrlw $3,%%mm0;" "pxor %%mm4, %%mm4;" "movq %%mm0, %%mm5;" "movq %%mm2, %%mm7;" "punpcklbw %%mm4, %%mm2;" "punpcklbw %%mm1, %%mm0;" "psllw $3, %%mm2;" "por %%mm2, %%mm0;" "movq 8 (%5, %0, 2), %%mm6;" MOVNTQ " %%mm0, (%1);" "punpckhbw %%mm4, %%mm7;" "punpckhbw %%mm1, %%mm5;" "psllw $3, %%mm7;" "movd 4 (%2, %0), %%mm0;" "por %%mm7, %%mm5;" "movd 4 (%3, %0), %%mm1;" MOVNTQ " %%mm5, 8 (%1);" "add $16, %1 \n\t" "add $4, %0 \n\t" " js 1b \n\t" : "+r" (index), "+r" (_image) : "r" (_pu - index), "r" (_pv - index), "r"(&[[list]]->redDither), "r" (_py - 2*index) ); } __asm__ __volatile__ (EMMS); return [[ranpspinre]]; }
--------------------------------------------- Result 872 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: VIOsPAPRDevice *vty_lookup(sPAPRMachineState *[[spapr]], target_ulong [[reg]]) { VIOsPAPRDevice *[[sdev]]; [[sdev]] = spapr_vio_find_by_reg([[spapr]]->vio_bus, [[reg]]); if (![[sdev]] && [[reg]] == 0) { return spapr_vty_get_default([[spapr]]->vio_bus); return [[sdev]];

[[[[Adv]]]]: VIOsPAPRDevice *vty_lookup(sPAPRMachineState *[[vrр]], target_ulong [[ste]]) { VIOsPAPRDevice *[[2dej]]; [[2dej]] = spapr_vio_find_by_reg([[vrр]]->vio_bus, [[ste]]); if (![[2dej]] && [[ste]] == 0) { return spapr_vty_get_default([[vrр]]->vio_bus); return [[2dej]];
--------------------------------------------- Result 873 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int pvpanic_init(ISABus *bus) { isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE); return 0; }
--------------------------------------------- Result 874 ---------------------------------------------
[[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint32_t gic_dist_readb(void *opaque, hwaddr offset, MemTxAttrs attrs) { GICState *s = (GICState *)opaque; uint32_t res; int irq; int i; int cpu; int cm; int mask; cpu = gic_get_current_cpu(s); cm = 1 << cpu; if (offset < 0x100) { if (offset == 0) return s->enabled; if (offset == 4) return ((s->num_irq / 32) - 1) | ((NUM_CPU(s) - 1) << 5) | (s->security_extn << 10); if (offset < 0x08) return 0; if (offset >= 0x80) { res = 0; if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) { irq = (offset - 0x080) * 8 + GIC_BASE_IRQ; if (irq >= s->num_irq) { goto bad_reg; } for (i = 0; i < 8; i++) { if (GIC_TEST_GROUP(irq + i, cm)) { res |= (1 << i); } } } return res; } goto bad_reg; } else if (offset < 0x200) { if (offset < 0x180) irq = (offset - 0x100) * 8; else irq = (offset - 0x180) * 8; irq += GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = 0; for (i = 0; i < 8; i++) { if (GIC_TEST_ENABLED(irq + i, cm)) { res |= (1 << i); } } } else if (offset < 0x300) { if (offset < 0x280) irq = (offset - 0x200) * 8; else irq = (offset - 0x280) * 8; irq += GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = 0; mask = (irq < GIC_INTERNAL) ? cm : ALL_CPU_MASK; for (i = 0; i < 8; i++) { if (gic_test_pending(s, irq + i, mask)) { res |= (1 << i); } } } else if (offset < 0x400) { irq = (offset - 0x300) * 8 + GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = 0; mask = (irq < GIC_INTERNAL) ? cm : ALL_CPU_MASK; for (i = 0; i < 8; i++) { if (GIC_TEST_ACTIVE(irq + i, mask)) { res |= (1 << i); } } } else if (offset < 0x800) { irq = (offset - 0x400) + GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = GIC_GET_PRIORITY(irq, cpu); } else if (offset < 0xc00) { if (s->num_cpu == 1 && s->revision != REV_11MPCORE) { res = 0; } else { irq = (offset - 0x800) + GIC_BASE_IRQ; if (irq >= s->num_irq) { goto bad_reg; } if (irq >= 29 && irq <= 31) { res = cm; } else { res = GIC_TARGET(irq); } } } else if (offset < 0xf00) { irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = 0; for (i = 0; i < 4; i++) { if (GIC_TEST_MODEL(irq + i)) res |= (1 << (i * 2)); if (GIC_TEST_EDGE_TRIGGER(irq + i)) res |= (2 << (i * 2)); } } else if (offset < 0xf10) { goto bad_reg; } else if (offset < 0xf30) { if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) { goto bad_reg; } if (offset < 0xf20) { irq = (offset - 0xf10); } else { irq = (offset - 0xf20); } res = s->sgi_pending[irq][cpu]; } else if (offset < 0xfe0) { goto bad_reg; } else { if (offset & 3) { res = 0; } else { res = gic_id[(offset - 0xfe0) >> 2]; } } return res; bad_reg: qemu_log_mask(LOG_GUEST_ERROR, "gic_dist_readb: Bad offset %x\n", (int)offset); return 0; }
--------------------------------------------- Result 875 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 459 / 96 / 320 / 875:  33%|███▎      | 875/2690 [2:14:09<4:38:16,  9.20s/it][Succeeded / Failed / Skipped / Total] 459 / 96 / 320 / 875:  33%|███▎      | 876/2690 [2:14:50<4:39:13,  9.24s/it][Succeeded / Failed / Skipped / Total] 459 / 97 / 320 / 876:  33%|███▎      | 876/2690 [2:14:50<4:39:13,  9.24s/it][Succeeded / Failed / Skipped / Total] 459 / 97 / 320 / 876:  33%|███▎      | 877/2690 [2:14:50<4:38:45,  9.23s/it][Succeeded / Failed / Skipped / Total] 459 / 97 / 321 / 877:  33%|███▎      | 877/2690 [2:14:50<4:38:45,  9.23s/it][Succeeded / Failed / Skipped / Total] 459 / 97 / 321 / 877:  33%|███▎      | 878/2690 [2:15:23<4:39:25,  9.25s/it][Succeeded / Failed / Skipped / Total] 460 / 97 / 321 / 878:  33%|███▎      | 878/2690 [2:15:23<4:39:25,  9.25s/it][Succeeded / Failed / Skipped / Total] 460 / 97 / 321 / 878:  33%|███▎      | 879/2690 [2:15:24<4:38:58,  9.24s/it][Succeeded / Failed / Skipped / Total] 460 / 97 / 322 / 879:  33%|███▎      | 879/2690 [2:15:24<4:38:58,  9.24s/it][Succeeded / Failed / Skipped / Total] 460 / 97 / 322 / 879:  33%|███▎      | 880/2690 [2:15:30<4:38:42,  9.24s/it][[0 (69%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline int get_segment_6xx_tlb(CPUPPCState *env, mmu_ctx_t *ctx, target_ulong eaddr, int rw, int type) { hwaddr hash; target_ulong vsid; int ds, pr, target_page_bits; int ret; target_ulong sr, pgidx; pr = msr_pr; ctx->eaddr = eaddr; sr = env->sr[eaddr >> 28]; ctx->key = (((sr & 0x20000000) && (pr != 0)) || ((sr & 0x40000000) && (pr == 0))) ? 1 : 0; ds = sr & 0x80000000 ? 1 : 0; ctx->nx = sr & 0x10000000 ? 1 : 0; vsid = sr & 0x00FFFFFF; target_page_bits = TARGET_PAGE_BITS; qemu_log_mask(CPU_LOG_MMU, "Check segment v=" TARGET_FMT_lx " %d " TARGET_FMT_lx " nip=" TARGET_FMT_lx " lr=" TARGET_FMT_lx " ir=%d dr=%d pr=%d %d t=%d\n", eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir, (int)msr_dr, pr != 0 ? 1 : 0, rw, type); pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits; hash = vsid ^ pgidx; ctx->ptem = (vsid << 7) | (pgidx >> 10); qemu_log_mask(CPU_LOG_MMU, "pte segment: key=%d ds %d nx %d vsid " TARGET_FMT_lx "\n", ctx->key, ds, ctx->nx, vsid); ret = -1; if (!ds) { if (type != ACCESS_CODE || ctx->nx == 0) { qemu_log_mask(CPU_LOG_MMU, "htab_base " TARGET_FMT_plx " htab_mask " TARGET_FMT_plx " hash " TARGET_FMT_plx "\n", env->htab_base, env->htab_mask, hash); ctx->hash[0] = hash; ctx->hash[1] = ~hash; ctx->raddr = (hwaddr)-1ULL; ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type); #if defined(DUMP_PAGE_TABLES) if (qemu_loglevel_mask(CPU_LOG_MMU)) { CPUState *cs = ENV_GET_CPU(env); hwaddr curaddr; uint32_t a0, a1, a2, a3; qemu_log("Page table: " TARGET_FMT_plx " len " TARGET_FMT_plx "\n", env->htab_base, env->htab_mask + 0x80); for (curaddr = env->htab_base; curaddr < (env->htab_base + env->htab_mask + 0x80); curaddr += 16) { a0 = ldl_phys(cs->as, curaddr); a1 = ldl_phys(cs->as, curaddr + 4); a2 = ldl_phys(cs->as, curaddr + 8); a3 = ldl_phys(cs->as, curaddr + 12); if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) { qemu_log(TARGET_FMT_plx ": %08x %08x %08x %08x\n", curaddr, a0, a1, a2, a3); } } } #endif } else { qemu_log_mask(CPU_LOG_MMU, "No access allowed\n"); ret = -3; } } else { target_ulong sr; qemu_log_mask(CPU_LOG_MMU, "direct store...\n"); sr = env->sr[eaddr >> 28]; if ((sr & 0x1FF00000) >> 20 == 0x07f) { ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF); ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC; return 0; } switch (type) { case ACCESS_INT: break; case ACCESS_CODE: return -4; case ACCESS_FLOAT: return -4; case ACCESS_RES: return -4; case ACCESS_CACHE: ctx->raddr = eaddr; return 0; case ACCESS_EXT: return -4; default: qemu_log_mask(CPU_LOG_MMU, "ERROR: instruction should not need " "address translation\n"); return -4; } if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) { ctx->raddr = eaddr; ret = 2; } else { ret = -2; } } return ret; }
--------------------------------------------- Result 876 ---------------------------------------------
[[0 (17%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void slirp_socket_save(QEMUFile *[[f]], struct socket *[[so]]) { qemu_put_be32([[f]], [[so]]->so_urgc); qemu_put_be16([[f]], [[so]]->so_ffamily); switch ([[so]]->so_ffamily) { case AF_INET: qemu_put_be32([[f]], [[so]]->so_faddr.s_addr); qemu_put_be16([[f]], [[so]]->so_fport); break; default: error_report( "so_ffamily unknown, unable to save so_faddr and so_fport\n"); } qemu_put_be16([[f]], [[so]]->so_lfamily); switch ([[so]]->so_lfamily) { case AF_INET: qemu_put_be32([[f]], [[so]]->so_laddr.s_addr); qemu_put_be16([[f]], [[so]]->so_lport); break; default: error_report( "so_ffamily unknown, unable to save so_laddr and so_lport\n"); } qemu_put_byte([[f]], [[so]]->so_iptos); qemu_put_byte([[f]], [[so]]->so_emu); qemu_put_byte([[f]], [[so]]->so_type); qemu_put_be32([[f]], [[so]]->so_state); slirp_sbuf_save([[f]], &[[so]]->so_rcv); slirp_sbuf_save([[f]], &[[so]]->so_snd); slirp_tcp_save([[f]], [[so]]->so_tcpcb); }

[[[[Adv]]]]: static void slirp_socket_save(QEMUFile *[[sf]], struct socket *[[say]]) { qemu_put_be32([[sf]], [[say]]->so_urgc); qemu_put_be16([[sf]], [[say]]->so_ffamily); switch ([[say]]->so_ffamily) { case AF_INET: qemu_put_be32([[sf]], [[say]]->so_faddr.s_addr); qemu_put_be16([[sf]], [[say]]->so_fport); break; default: error_report( "so_ffamily unknown, unable to save so_faddr and so_fport\n"); } qemu_put_be16([[sf]], [[say]]->so_lfamily); switch ([[say]]->so_lfamily) { case AF_INET: qemu_put_be32([[sf]], [[say]]->so_laddr.s_addr); qemu_put_be16([[sf]], [[say]]->so_lport); break; default: error_report( "so_ffamily unknown, unable to save so_laddr and so_lport\n"); } qemu_put_byte([[sf]], [[say]]->so_iptos); qemu_put_byte([[sf]], [[say]]->so_emu); qemu_put_byte([[sf]], [[say]]->so_type); qemu_put_be32([[sf]], [[say]]->so_state); slirp_sbuf_save([[sf]], &[[say]]->so_rcv); slirp_sbuf_save([[sf]], &[[say]]->so_snd); slirp_tcp_save([[sf]], [[say]]->so_tcpcb); }
--------------------------------------------- Result 877 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void object_property_allow_set_link(Object *obj, const char *name, Object *val, Error **errp) { }
--------------------------------------------- Result 878 ---------------------------------------------
[[0 (96%)]] --> [[0 (48%)]] --> Socre: 0.5167342126369476

[[[[Adv]]]]: int avpriv_dca_convert_bitstream(const uint8_t *[[src]], int src_size, uint8_t *dst, int max_size) { uint32_t [[mrk]]; int [[i]], tmp; const uint16_t *[[ssrc]] = (const uint16_t *) [[src]]; uint16_t *sdst = (uint16_t *) dst; PutBitContext pb; if ((unsigned) src_size > (unsigned) max_size) src_size = max_size; [[mrk]] = AV_RB32([[src]]); switch ([[mrk]]) { case DCA_SYNCWORD_CORE_BE: memcpy(dst, [[src]], src_size); return src_size; case DCA_SYNCWORD_CORE_LE: for ([[i]] = 0; [[i]] < (src_size + 1) >> 1; [[i]]++) *sdst++ = av_bswap16(*[[ssrc]]++); return src_size; case DCA_SYNCWORD_CORE_14B_BE: case DCA_SYNCWORD_CORE_14B_LE: init_put_bits(&pb, dst, max_size); for ([[i]] = 0; [[i]] < (src_size + 1) >> 1; [[i]]++, [[src]] += 2) { tmp = (([[mrk]] == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16([[src]]) : AV_RL16([[src]])) & 0x3FFF; put_bits(&pb, 14, tmp); } flush_put_bits(&pb); return (put_bits_count(&pb) + 7) >> 3; default: return AVERROR_INVALIDDATA; } }

[[[[Adv]]]]: int avpriv_dca_convert_bitstream(const uint8_t *[[rdd]], int src_size, uint8_t *dst, int max_size) { uint32_t [[jdock]]; int [[on]], tmp; const uint16_t *[[pof]] = (const uint16_t *) [[rdd]]; uint16_t *sdst = (uint16_t *) dst; PutBitContext pb; if ((unsigned) src_size > (unsigned) max_size) src_size = max_size; [[jdock]] = AV_RB32([[rdd]]); switch ([[jdock]]) { case DCA_SYNCWORD_CORE_BE: memcpy(dst, [[rdd]], src_size); return src_size; case DCA_SYNCWORD_CORE_LE: for ([[on]] = 0; [[on]] < (src_size + 1) >> 1; [[on]]++) *sdst++ = av_bswap16(*[[pof]]++); return src_size; case DCA_SYNCWORD_CORE_14B_BE: case DCA_SYNCWORD_CORE_14B_LE: init_put_bits(&pb, dst, max_size); for ([[on]] = 0; [[on]] < (src_size + 1) >> 1; [[on]]++, [[rdd]] += 2) { tmp = (([[jdock]] == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16([[rdd]]) : AV_RL16([[rdd]])) & 0x3FFF; put_bits(&pb, 14, tmp); } flush_put_bits(&pb); return (put_bits_count(&pb) + 7) >> 3; default: return AVERROR_INVALIDDATA; } }
--------------------------------------------- Result 879 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused) { RENAME(nvXXtoUV)(dstV, dstU, src1, width); }
--------------------------------------------- Result 880 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 460 / 98 / 322 / 880:  33%|███▎      | 880/2690 [2:15:30<4:38:42,  9.24s/it][Succeeded / Failed / Skipped / Total] 460 / 98 / 322 / 880:  33%|███▎      | 881/2690 [2:15:30<4:38:15,  9.23s/it][Succeeded / Failed / Skipped / Total] 460 / 99 / 322 / 881:  33%|███▎      | 881/2690 [2:15:30<4:38:15,  9.23s/it][Succeeded / Failed / Skipped / Total] 460 / 99 / 322 / 881:  33%|███▎      | 882/2690 [2:15:30<4:37:47,  9.22s/it][Succeeded / Failed / Skipped / Total] 460 / 99 / 323 / 882:  33%|███▎      | 882/2690 [2:15:30<4:37:47,  9.22s/it][Succeeded / Failed / Skipped / Total] 460 / 99 / 323 / 882:  33%|███▎      | 883/2690 [2:15:31<4:37:20,  9.21s/it][Succeeded / Failed / Skipped / Total] 460 / 99 / 324 / 883:  33%|███▎      | 883/2690 [2:15:31<4:37:20,  9.21s/it][Succeeded / Failed / Skipped / Total] 460 / 99 / 324 / 883:  33%|███▎      | 884/2690 [2:15:56<4:37:44,  9.23s/it][Succeeded / Failed / Skipped / Total] 461 / 99 / 324 / 884:  33%|███▎      | 884/2690 [2:15:56<4:37:44,  9.23s/it][Succeeded / Failed / Skipped / Total] 461 / 99 / 324 / 884:  33%|███▎      | 885/2690 [2:15:58<4:37:18,  9.22s/it][[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void mix_3f_1r_to_mono(AC3DecodeContext *[[ctx]]) { int [[i]]; float (*output)[256] = [[ctx]]->audio_block.block_output; for ([[i]] = 0; [[i]] < 256; [[i]]++) output[1][[[i]]] = (output[2][[[i]]] + output[3][[[i]]] + output[4][[[i]]]); memset(output[2], 0, sizeof(output[2])); memset(output[3], 0, sizeof(output[3])); memset(output[4], 0, sizeof(output[4])); }

[[[[Adv]]]]: static inline void mix_3f_1r_to_mono(AC3DecodeContext *[[waxd]]) { int [[king]]; float (*output)[256] = [[waxd]]->audio_block.block_output; for ([[king]] = 0; [[king]] < 256; [[king]]++) output[1][[[king]]] = (output[2][[[king]]] + output[3][[[king]]] + output[4][[[king]]]); memset(output[2], 0, sizeof(output[2])); memset(output[3], 0, sizeof(output[3])); memset(output[4], 0, sizeof(output[4])); }
--------------------------------------------- Result 881 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static TRBCCode xhci_disable_ep(XHCIState *[[xhci]], unsigned int [[slotid]], unsigned int epid) { XHCISlot *[[slot]]; XHCIEPContext *[[epctx]]; int [[i]]; trace_usb_xhci_ep_disable([[slotid]], epid); assert([[slotid]] >= 1 && [[slotid]] <= [[xhci]]->numslots); assert(epid >= 1 && epid <= 31); [[slot]] = &[[xhci]]->slots[[[slotid]]-1]; if (![[slot]]->eps[epid-1]) { DPRINTF("xhci: slot %d ep %d already disabled\n", [[slotid]], epid); return CC_SUCCESS; xhci_ep_nuke_xfers([[xhci]], [[slotid]], epid); [[epctx]] = [[slot]]->eps[epid-1]; if ([[epctx]]->nr_pstreams) { xhci_free_streams([[epctx]]); xhci_set_ep_state([[xhci]], [[epctx]], NULL, EP_DISABLED); timer_free([[epctx]]->kick_timer); g_free([[epctx]]); [[slot]]->eps[epid-1] = NULL; return CC_SUCCESS;

[[[[Adv]]]]: static TRBCCode xhci_disable_ep(XHCIState *[[хsci]], unsigned int [[flatd]], unsigned int epid) { XHCISlot *[[place]]; XHCIEPContext *[[jete8]]; int [[sign]]; trace_usb_xhci_ep_disable([[flatd]], epid); assert([[flatd]] >= 1 && [[flatd]] <= [[хsci]]->numslots); assert(epid >= 1 && epid <= 31); [[place]] = &[[хsci]]->slots[[[flatd]]-1]; if (![[place]]->eps[epid-1]) { DPRINTF("xhci: slot %d ep %d already disabled\n", [[flatd]], epid); return CC_SUCCESS; xhci_ep_nuke_xfers([[хsci]], [[flatd]], epid); [[jete8]] = [[place]]->eps[epid-1]; if ([[jete8]]->nr_pstreams) { xhci_free_streams([[jete8]]); xhci_set_ep_state([[хsci]], [[jete8]], NULL, EP_DISABLED); timer_free([[jete8]]->kick_timer); g_free([[jete8]]); [[place]]->eps[epid-1] = NULL; return CC_SUCCESS;
--------------------------------------------- Result 882 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride) { PixletContext *ctx = avctx->priv_data; GetBitContext *b = &ctx->gbit; unsigned cnt1, nbits, k, j = 0, i = 0; int64_t value, state = 3; int rlen, escape, flag = 0; while (i < size) { nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14); cnt1 = get_unary(b, 0, 8); if (cnt1 < 8) { value = show_bits(b, nbits); if (value <= 1) { skip_bits(b, nbits - 1); escape = ((1 << nbits) - 1) * cnt1; } else { skip_bits(b, nbits); escape = value + ((1 << nbits) - 1) * cnt1 - 1; } } else { escape = get_bits(b, 16); } value = -((escape + flag) & 1) | 1; dst[j++] = value * ((escape + flag + 1) >> 1); i++; if (j == width) { j = 0; dst += stride; } state = 120 * (escape + flag) + state - (120 * state >> 8); flag = 0; if (state * 4 > 0xFF || i >= size) continue; nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24; escape = av_mod_uintp2(16383, nbits); cnt1 = get_unary(b, 0, 8); if (cnt1 > 7) { rlen = get_bits(b, 16); } else { value = show_bits(b, nbits); if (value > 1) { skip_bits(b, nbits); rlen = value + escape * cnt1 - 1; } else { skip_bits(b, nbits - 1); rlen = escape * cnt1; } } if (i + rlen > size) return AVERROR_INVALIDDATA; i += rlen; for (k = 0; k < rlen; k++) { dst[j++] = 0; if (j == width) { j = 0; dst += stride; } } state = 0; flag = rlen < 0xFFFF ? 1 : 0; } align_get_bits(b); return get_bits_count(b) >> 3; }
--------------------------------------------- Result 883 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int request_frame(AVFilterLink *link) { AVFilterContext *ctx = link->src; IDETContext *idet = ctx->priv; do { int ret; if (idet->eof) return AVERROR_EOF; ret = ff_request_frame(link->src->inputs[0]); if (ret == AVERROR_EOF && idet->cur) { AVFrame *next = av_frame_clone(idet->next); if (!next) return AVERROR(ENOMEM); filter_frame(link->src->inputs[0], next); idet->eof = 1; } else if (ret < 0) { return ret; } } while (!idet->cur); return 0; }
--------------------------------------------- Result 884 ---------------------------------------------
[[0 (6%)]] --> [[0 (96%)]] --> Socre: 0.956889808177948

[[[[Adv]]]]: static uint64_t lan9118_readl(void *[[opaque]], target_phys_addr_t [[offset]], unsigned size) { lan9118_state *s = (lan9118_state *)[[opaque]]; if ([[offset]] < 0x20) { return rx_fifo_pop(s); } switch ([[offset]]) { case 0x40: return rx_status_fifo_pop(s); case 0x44: return s->rx_status_fifo[s->tx_status_fifo_head]; case 0x48: return tx_status_fifo_pop(s); case 0x4c: return s->tx_status_fifo[s->tx_status_fifo_head]; case CSR_ID_REV: return 0x01180001; case CSR_IRQ_CFG: return s->irq_cfg; case CSR_INT_STS: return s->int_sts; case CSR_INT_EN: return s->int_en; case CSR_BYTE_TEST: return 0x87654321; case CSR_FIFO_INT: return s->fifo_int; case CSR_RX_CFG: return s->rx_cfg; case CSR_TX_CFG: return s->tx_cfg; case CSR_HW_CFG: return s->hw_cfg; case CSR_RX_DP_CTRL: return 0; case CSR_RX_FIFO_INF: return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2); case CSR_TX_FIFO_INF: return (s->tx_status_fifo_used << 16) | (s->tx_fifo_size - s->txp->fifo_used); case CSR_PMT_CTRL: return s->pmt_ctrl; case CSR_GPIO_CFG: return s->gpio_cfg; case CSR_GPT_CFG: return s->gpt_cfg; case CSR_GPT_CNT: return ptimer_get_count(s->timer); case CSR_WORD_SWAP: return s->word_swap; case CSR_FREE_RUN: return (qemu_get_clock_ns(vm_clock) / 40) - s->free_timer_start; case CSR_RX_DROP: return 0; case CSR_MAC_CSR_CMD: return s->mac_cmd; case CSR_MAC_CSR_DATA: return s->mac_data; case CSR_AFC_CFG: return s->afc_cfg; case CSR_E2P_CMD: return s->e2p_cmd; case CSR_E2P_DATA: return s->e2p_data; } hw_error("lan9118_read: Bad reg 0x%x\n", (int)[[offset]]); return 0; }

[[[[Adv]]]]: static uint64_t lan9118_readl(void *[[ɛ]], target_phys_addr_t [[ac]], unsigned size) { lan9118_state *s = (lan9118_state *)[[ɛ]]; if ([[ac]] < 0x20) { return rx_fifo_pop(s); } switch ([[ac]]) { case 0x40: return rx_status_fifo_pop(s); case 0x44: return s->rx_status_fifo[s->tx_status_fifo_head]; case 0x48: return tx_status_fifo_pop(s); case 0x4c: return s->tx_status_fifo[s->tx_status_fifo_head]; case CSR_ID_REV: return 0x01180001; case CSR_IRQ_CFG: return s->irq_cfg; case CSR_INT_STS: return s->int_sts; case CSR_INT_EN: return s->int_en; case CSR_BYTE_TEST: return 0x87654321; case CSR_FIFO_INT: return s->fifo_int; case CSR_RX_CFG: return s->rx_cfg; case CSR_TX_CFG: return s->tx_cfg; case CSR_HW_CFG: return s->hw_cfg; case CSR_RX_DP_CTRL: return 0; case CSR_RX_FIFO_INF: return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2); case CSR_TX_FIFO_INF: return (s->tx_status_fifo_used << 16) | (s->tx_fifo_size - s->txp->fifo_used); case CSR_PMT_CTRL: return s->pmt_ctrl; case CSR_GPIO_CFG: return s->gpio_cfg; case CSR_GPT_CFG: return s->gpt_cfg; case CSR_GPT_CNT: return ptimer_get_count(s->timer); case CSR_WORD_SWAP: return s->word_swap; case CSR_FREE_RUN: return (qemu_get_clock_ns(vm_clock) / 40) - s->free_timer_start; case CSR_RX_DROP: return 0; case CSR_MAC_CSR_CMD: return s->mac_cmd; case CSR_MAC_CSR_DATA: return s->mac_data; case CSR_AFC_CFG: return s->afc_cfg; case CSR_E2P_CMD: return s->e2p_cmd; case CSR_E2P_DATA: return s->e2p_data; } hw_error("lan9118_read: Bad reg 0x%x\n", (int)[[ac]]); return 0; }
--------------------------------------------- Result 885 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 462 / 99 / 324 / 885:  33%|███▎      | 885/2690 [2:15:58<4:37:18,  9.22s/it][Succeeded / Failed / Skipped / Total] 462 / 99 / 324 / 885:  33%|███▎      | 886/2690 [2:15:58<4:36:52,  9.21s/it][Succeeded / Failed / Skipped / Total] 462 / 99 / 325 / 886:  33%|███▎      | 886/2690 [2:15:58<4:36:52,  9.21s/it][Succeeded / Failed / Skipped / Total] 462 / 99 / 325 / 886:  33%|███▎      | 887/2690 [2:16:06<4:36:40,  9.21s/it][Succeeded / Failed / Skipped / Total] 463 / 99 / 325 / 887:  33%|███▎      | 887/2690 [2:16:06<4:36:40,  9.21s/it][Succeeded / Failed / Skipped / Total] 463 / 99 / 325 / 887:  33%|███▎      | 888/2690 [2:16:33<4:37:07,  9.23s/it][[0 (39%)]] --> [[0 (99%)]] --> Socre: 0.9853823184967041

[[[[Adv]]]]: static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num, int nb_sectors, QEMUIOVector *[[qiov]], int offset) { BDRVNBDState *s = bs->opaque; struct nbd_request request; struct nbd_reply reply; request.type = NBD_CMD_READ; request.from = sector_num * 512; request.len = nb_sectors * 512; nbd_coroutine_start(s, &request); if (nbd_co_send_request(s, &request, NULL, 0) == -1) { reply.error = errno; } else { nbd_co_receive_reply(s, &request, &reply, [[qiov]]->iov, offset); } nbd_coroutine_end(s, &request); return -reply.error; }

[[[[Adv]]]]: static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num, int nb_sectors, QEMUIOVector *[[llов]], int offset) { BDRVNBDState *s = bs->opaque; struct nbd_request request; struct nbd_reply reply; request.type = NBD_CMD_READ; request.from = sector_num * 512; request.len = nb_sectors * 512; nbd_coroutine_start(s, &request); if (nbd_co_send_request(s, &request, NULL, 0) == -1) { reply.error = errno; } else { nbd_co_receive_reply(s, &request, &reply, [[llов]]->iov, offset); } nbd_coroutine_end(s, &request); return -reply.error; }
--------------------------------------------- Result 886 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int sd_do_command(SDState *sd, SDRequest *req, uint8_t *response) { uint32_t last_status = sd->card_status; sd_rsp_type_t rtype; int rsplen; if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) { return 0; } if (sd_req_crc_validate(req)) { sd->card_status &= ~COM_CRC_ERROR; return 0; } sd->card_status &= ~CARD_STATUS_B; sd_set_status(sd); if (last_status & CARD_IS_LOCKED) { if (!cmd_valid_while_locked(sd, req)) { sd->card_status |= ILLEGAL_COMMAND; fprintf(stderr, "SD: Card is locked\n"); return 0; } } if (last_status & APP_CMD) { rtype = sd_app_command(sd, *req); sd->card_status &= ~APP_CMD; } else rtype = sd_normal_command(sd, *req); sd->current_cmd = req->cmd; switch (rtype) { case sd_r1: case sd_r1b: sd_response_r1_make(sd, response, last_status); rsplen = 4; break; case sd_r2_i: memcpy(response, sd->cid, sizeof(sd->cid)); rsplen = 16; break; case sd_r2_s: memcpy(response, sd->csd, sizeof(sd->csd)); rsplen = 16; break; case sd_r3: sd_response_r3_make(sd, response); rsplen = 4; break; case sd_r6: sd_response_r6_make(sd, response); rsplen = 4; break; case sd_r7: sd_response_r7_make(sd, response); rsplen = 4; break; case sd_r0: default: rsplen = 0; break; } if (sd->card_status & ILLEGAL_COMMAND) rsplen = 0; #ifdef DEBUG_SD if (rsplen) { int i; DPRINTF("Response:"); for (i = 0; i < rsplen; i++) printf(" %02x", response[i]); printf(" state %d\n", sd->state); } else { DPRINTF("No response %d\n", sd->state); } #endif return rsplen; }
--------------------------------------------- Result 887 ---------------------------------------------
[[0 (99%)]] --> [[0 (24%)]] --> Socre: 0.7566907554864883

[[[[Adv]]]]: static int dpcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size) { DPCMContext *s = avctx->priv_data; int in, out = 0; int [[predictor]][2]; int channel_number = 0; short *output_samples = data; int shift[2]; unsigned char byte; short diff; if (!buf_size) return 0; switch(avctx->codec->id) { case CODEC_ID_ROQ_DPCM: if (s->channels == 1) [[predictor]][0] = AV_RL16(&buf[6]); else { [[predictor]][0] = buf[7] << 8; [[predictor]][1] = buf[6] << 8; } SE_16BIT([[predictor]][0]); SE_16BIT([[predictor]][1]); for (in = 8, out = 0; in < buf_size; in++, out++) { [[predictor]][channel_number] += s->roq_square_array[buf[in]]; [[predictor]][channel_number] = av_clip_int16([[predictor]][channel_number]); output_samples[out] = [[predictor]][channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_INTERPLAY_DPCM: in = 6; [[predictor]][0] = AV_RL16(&buf[in]); in += 2; SE_16BIT([[predictor]][0]) output_samples[out++] = [[predictor]][0]; if (s->channels == 2) { [[predictor]][1] = AV_RL16(&buf[in]); in += 2; SE_16BIT([[predictor]][1]) output_samples[out++] = [[predictor]][1]; } while (in < buf_size) { [[predictor]][channel_number] += interplay_delta_table[buf[in++]]; [[predictor]][channel_number] = av_clip_int16([[predictor]][channel_number]); output_samples[out++] = [[predictor]][channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_XAN_DPCM: in = 0; shift[0] = shift[1] = 4; [[predictor]][0] = AV_RL16(&buf[in]); in += 2; SE_16BIT([[predictor]][0]); if (s->channels == 2) { [[predictor]][1] = AV_RL16(&buf[in]); in += 2; SE_16BIT([[predictor]][1]); } while (in < buf_size) { byte = buf[in++]; diff = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[channel_number]++; else shift[channel_number] -= (2 * (byte & 3)); if (shift[channel_number] < 0) shift[channel_number] = 0; diff >>= shift[channel_number]; [[predictor]][channel_number] += diff; [[predictor]][channel_number] = av_clip_int16([[predictor]][channel_number]); output_samples[out++] = [[predictor]][channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_SOL_DPCM: in = 0; if (avctx->codec_tag != 3) { if(*data_size/4 < buf_size) while (in < buf_size) { int n1, n2; n1 = (buf[in] >> 4) & 0xF; n2 = buf[in++] & 0xF; s->sample[0] += s->sol_table[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; output_samples[out++] = (s->sample[0] - 128) << 8; s->sample[s->channels - 1] += s->sol_table[n2]; if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0; if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255; output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8; } } else { while (in < buf_size) { int n; n = buf[in++]; if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F]; else s->sample[channel_number] += s->sol_table[n & 0x7F]; s->sample[channel_number] = av_clip_int16(s->sample[channel_number]); output_samples[out++] = s->sample[channel_number]; channel_number ^= s->channels - 1; } } break; } *data_size = out * sizeof(short); return buf_size; }

[[[[Adv]]]]: static int dpcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size) { DPCMContext *s = avctx->priv_data; int in, out = 0; int [[plana]][2]; int channel_number = 0; short *output_samples = data; int shift[2]; unsigned char byte; short diff; if (!buf_size) return 0; switch(avctx->codec->id) { case CODEC_ID_ROQ_DPCM: if (s->channels == 1) [[plana]][0] = AV_RL16(&buf[6]); else { [[plana]][0] = buf[7] << 8; [[plana]][1] = buf[6] << 8; } SE_16BIT([[plana]][0]); SE_16BIT([[plana]][1]); for (in = 8, out = 0; in < buf_size; in++, out++) { [[plana]][channel_number] += s->roq_square_array[buf[in]]; [[plana]][channel_number] = av_clip_int16([[plana]][channel_number]); output_samples[out] = [[plana]][channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_INTERPLAY_DPCM: in = 6; [[plana]][0] = AV_RL16(&buf[in]); in += 2; SE_16BIT([[plana]][0]) output_samples[out++] = [[plana]][0]; if (s->channels == 2) { [[plana]][1] = AV_RL16(&buf[in]); in += 2; SE_16BIT([[plana]][1]) output_samples[out++] = [[plana]][1]; } while (in < buf_size) { [[plana]][channel_number] += interplay_delta_table[buf[in++]]; [[plana]][channel_number] = av_clip_int16([[plana]][channel_number]); output_samples[out++] = [[plana]][channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_XAN_DPCM: in = 0; shift[0] = shift[1] = 4; [[plana]][0] = AV_RL16(&buf[in]); in += 2; SE_16BIT([[plana]][0]); if (s->channels == 2) { [[plana]][1] = AV_RL16(&buf[in]); in += 2; SE_16BIT([[plana]][1]); } while (in < buf_size) { byte = buf[in++]; diff = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[channel_number]++; else shift[channel_number] -= (2 * (byte & 3)); if (shift[channel_number] < 0) shift[channel_number] = 0; diff >>= shift[channel_number]; [[plana]][channel_number] += diff; [[plana]][channel_number] = av_clip_int16([[plana]][channel_number]); output_samples[out++] = [[plana]][channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_SOL_DPCM: in = 0; if (avctx->codec_tag != 3) { if(*data_size/4 < buf_size) while (in < buf_size) { int n1, n2; n1 = (buf[in] >> 4) & 0xF; n2 = buf[in++] & 0xF; s->sample[0] += s->sol_table[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; output_samples[out++] = (s->sample[0] - 128) << 8; s->sample[s->channels - 1] += s->sol_table[n2]; if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0; if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255; output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8; } } else { while (in < buf_size) { int n; n = buf[in++]; if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F]; else s->sample[channel_number] += s->sol_table[n & 0x7F]; s->sample[channel_number] = av_clip_int16(s->sample[channel_number]); output_samples[out++] = s->sample[channel_number]; channel_number ^= s->channels - 1; } } break; } *data_size = out * sizeof(short); return buf_size; }
--------------------------------------------- Result 888 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 464 / 99 / 325 / 888:  33%|███▎      | 888/2690 [2:16:33<4:37:07,  9.23s/it][Succeeded / Failed / Skipped / Total] 464 / 99 / 325 / 888:  33%|███▎      | 889/2690 [2:17:12<4:37:57,  9.26s/it][Succeeded / Failed / Skipped / Total] 465 / 99 / 325 / 889:  33%|███▎      | 889/2690 [2:17:12<4:37:57,  9.26s/it][Succeeded / Failed / Skipped / Total] 465 / 99 / 325 / 889:  33%|███▎      | 890/2690 [2:17:28<4:38:01,  9.27s/it][[0 (28%)]] --> [[0 (55%)]] --> Socre: 0.546920120716095

[[[[Adv]]]]: static int dpcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; DPCMContext *s = avctx->priv_data; int in, out = 0; int predictor[2]; int ch = 0; int stereo = s->channels - 1; short *output_samples = data; int shift[2]; unsigned char byte; short [[diff]]; if (!buf_size) return 0; if(*data_size/2 < buf_size) return -1; switch(avctx->codec->id) { case CODEC_ID_ROQ_DPCM: if (stereo) { predictor[0] = buf[7] << 8; predictor[1] = buf[6] << 8; } else { predictor[0] = AV_RL16(&buf[6]); } SE_16BIT(predictor[0]); SE_16BIT(predictor[1]); for (in = 8, out = 0; in < buf_size; in++, out++) { predictor[ch] += s->roq_square_array[buf[in]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_INTERPLAY_DPCM: in = 6; predictor[0] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[0]) output_samples[out++] = predictor[0]; if (stereo) { predictor[1] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[1]) output_samples[out++] = predictor[1]; } while (in < buf_size) { predictor[ch] += interplay_delta_table[buf[in++]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out++] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_XAN_DPCM: in = 0; shift[0] = shift[1] = 4; predictor[0] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[0]); if (stereo) { predictor[1] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[1]); } while (in < buf_size) { byte = buf[in++]; [[diff]] = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[ch]++; else shift[ch] -= (2 * (byte & 3)); if (shift[ch] < 0) shift[ch] = 0; [[diff]] >>= shift[ch]; predictor[ch] += [[diff]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out++] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_SOL_DPCM: in = 0; if (avctx->codec_tag != 3) { if(*data_size/4 < buf_size) return -1; while (in < buf_size) { int n1, n2; n1 = (buf[in] >> 4) & 0xF; n2 = buf[in++] & 0xF; s->sample[0] += s->sol_table[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; output_samples[out++] = (s->sample[0] - 128) << 8; s->sample[stereo] += s->sol_table[n2]; if (s->sample[stereo] < 0) s->sample[stereo] = 0; if (s->sample[stereo] > 255) s->sample[stereo] = 255; output_samples[out++] = (s->sample[stereo] - 128) << 8; } } else { while (in < buf_size) { int n; n = buf[in++]; if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F]; else s->sample[ch] += s->sol_table[n & 0x7F]; s->sample[ch] = av_clip_int16(s->sample[ch]); output_samples[out++] = s->sample[ch]; ch ^= stereo; } } break; } *data_size = out * sizeof(short); return buf_size; }

[[[[Adv]]]]: static int dpcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; DPCMContext *s = avctx->priv_data; int in, out = 0; int predictor[2]; int ch = 0; int stereo = s->channels - 1; short *output_samples = data; int shift[2]; unsigned char byte; short [[द0]]; if (!buf_size) return 0; if(*data_size/2 < buf_size) return -1; switch(avctx->codec->id) { case CODEC_ID_ROQ_DPCM: if (stereo) { predictor[0] = buf[7] << 8; predictor[1] = buf[6] << 8; } else { predictor[0] = AV_RL16(&buf[6]); } SE_16BIT(predictor[0]); SE_16BIT(predictor[1]); for (in = 8, out = 0; in < buf_size; in++, out++) { predictor[ch] += s->roq_square_array[buf[in]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_INTERPLAY_DPCM: in = 6; predictor[0] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[0]) output_samples[out++] = predictor[0]; if (stereo) { predictor[1] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[1]) output_samples[out++] = predictor[1]; } while (in < buf_size) { predictor[ch] += interplay_delta_table[buf[in++]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out++] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_XAN_DPCM: in = 0; shift[0] = shift[1] = 4; predictor[0] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[0]); if (stereo) { predictor[1] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[1]); } while (in < buf_size) { byte = buf[in++]; [[द0]] = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[ch]++; else shift[ch] -= (2 * (byte & 3)); if (shift[ch] < 0) shift[ch] = 0; [[द0]] >>= shift[ch]; predictor[ch] += [[द0]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out++] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_SOL_DPCM: in = 0; if (avctx->codec_tag != 3) { if(*data_size/4 < buf_size) return -1; while (in < buf_size) { int n1, n2; n1 = (buf[in] >> 4) & 0xF; n2 = buf[in++] & 0xF; s->sample[0] += s->sol_table[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; output_samples[out++] = (s->sample[0] - 128) << 8; s->sample[stereo] += s->sol_table[n2]; if (s->sample[stereo] < 0) s->sample[stereo] = 0; if (s->sample[stereo] > 255) s->sample[stereo] = 255; output_samples[out++] = (s->sample[stereo] - 128) << 8; } } else { while (in < buf_size) { int n; n = buf[in++]; if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F]; else s->sample[ch] += s->sol_table[n & 0x7F]; s->sample[ch] = av_clip_int16(s->sample[ch]); output_samples[out++] = s->sample[ch]; ch ^= stereo; } } break; } *data_size = out * sizeof(short); return buf_size; }
--------------------------------------------- Result 889 ---------------------------------------------
[[0 (82%)]] --> [[0 (47%)]] --> Socre: 0.5341112613677979

[[[[Adv]]]]: static void picmemset(PicContext *[[s]], AVFrame *frame, unsigned value, int run, int *[[x]], int *y, int *plane, int bits_per_plane) { uint8_t *d; int [[shift]] = *plane * bits_per_plane; unsigned mask = ((1 << bits_per_plane) - 1) << [[shift]]; value <<= [[shift]]; while (run > 0) { int j; for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) { d = frame->data[0] + *y * frame->linesize[0]; d[*[[x]]] |= (value >> j) & mask; *[[x]] += 1; if (*[[x]] == [[s]]->width) { *y -= 1; *[[x]] = 0; if (*y < 0) { *y = [[s]]->height - 1; *plane += 1; if (*plane >= [[s]]->nb_planes) return; value <<= bits_per_plane; mask <<= bits_per_plane; } } } run--; } }

[[[[Adv]]]]: static void picmemset(PicContext *[[clock]], AVFrame *frame, unsigned value, int run, int *[[geometry]], int *y, int *plane, int bits_per_plane) { uint8_t *d; int [[movement]] = *plane * bits_per_plane; unsigned mask = ((1 << bits_per_plane) - 1) << [[movement]]; value <<= [[movement]]; while (run > 0) { int j; for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) { d = frame->data[0] + *y * frame->linesize[0]; d[*[[geometry]]] |= (value >> j) & mask; *[[geometry]] += 1; if (*[[geometry]] == [[clock]]->width) { *y -= 1; *[[geometry]] = 0; if (*y < 0) { *y = [[clock]]->height - 1; *plane += 1; if (*plane >= [[clock]]->nb_planes) return; value <<= bits_per_plane; mask <<= bits_per_plane; } } } run--; } }
--------------------------------------------- Result 890 ---------------------------------------------
[[0 (72%)]] --> [[0 (47%)]] --> Socre: 0.5269391536712646

[[[[Adv]]]]: mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int [[mp_imgflag]], int w, int h){ MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf)); mp_image_t* [[mpi]]=NULL; int w2; int number = mp_imgtype >> 16; av_assert0(vf->next == NULL); if(vf->w==0 && w>0) vf->w=w; if(vf->h==0 && h>0) vf->h=h; av_assert0(w == -1 || w >= vf->w); av_assert0(h == -1 || h >= vf->h); av_assert0(vf->w > 0); av_assert0(vf->h > 0); av_log(m->avfctx, AV_LOG_DEBUG, "get_image: %d:%d, vf: %d:%d\n", w,h,vf->w,vf->h); if (w == -1) w = vf->w; if (h == -1) h = vf->h; w2=([[mp_imgflag]]&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w; switch(mp_imgtype & 0xff){ case MP_IMGTYPE_EXPORT: if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h); [[mpi]]=vf->imgctx.export_images[0]; break; case MP_IMGTYPE_STATIC: if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h); [[mpi]]=vf->imgctx.static_images[0]; break; case MP_IMGTYPE_TEMP: if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h); [[mpi]]=vf->imgctx.temp_images[0]; break; case MP_IMGTYPE_IPB: if(!([[mp_imgflag]]&MP_IMGFLAG_READABLE)){ if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h); [[mpi]]=vf->imgctx.temp_images[0]; break; } case MP_IMGTYPE_IP: if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h); [[mpi]]=vf->imgctx.static_images[vf->imgctx.static_idx]; vf->imgctx.static_idx^=1; break; case MP_IMGTYPE_NUMBERED: if (number == -1) { int i; for (i = 0; i < NUM_NUMBERED_MPI; i++) if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count) break; number = i; } if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL; if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h); [[mpi]] = vf->imgctx.numbered_images[number]; [[mpi]]->number = number; break; } if([[mpi]]){ [[mpi]]->type=mp_imgtype; [[mpi]]->w=vf->w; [[mpi]]->h=vf->h; [[mpi]]->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS; [[mpi]]->flags|=[[mp_imgflag]]&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE); if(!vf->draw_slice) [[mpi]]->flags&=~MP_IMGFLAG_DRAW_CALLBACK; if([[mpi]]->width!=w2 || [[mpi]]->height!=h){ if([[mpi]]->flags&MP_IMGFLAG_ALLOCATED){ if([[mpi]]->width<w2 || [[mpi]]->height<h){ av_free([[mpi]]->planes[0]); [[mpi]]->flags&=~MP_IMGFLAG_ALLOCATED; mp_msg(MSGT_VFILTER,MSGL_V,"vf.c: have to REALLOCATE buffer memory :(\n"); } } { [[mpi]]->width=w2; [[mpi]]->chroma_width=(w2 + (1<<[[mpi]]->chroma_x_shift) - 1)>>[[mpi]]->chroma_x_shift; [[mpi]]->height=h; [[mpi]]->chroma_height=(h + (1<<[[mpi]]->chroma_y_shift) - 1)>>[[mpi]]->chroma_y_shift; } } if(![[mpi]]->bpp) mp_image_setfmt([[mpi]],outfmt); if(!([[mpi]]->flags&MP_IMGFLAG_ALLOCATED) && [[mpi]]->type>MP_IMGTYPE_EXPORT){ av_assert0(!vf->get_image); if(vf->get_image) vf->get_image(vf,[[mpi]]); if(!([[mpi]]->flags&MP_IMGFLAG_DIRECT)){ if (![[mpi]]->bpp) { mp_msg(MSGT_DECVIDEO, MSGL_FATAL, "vf_get_image: Tried to allocate a format that can not be allocated!\n"); return NULL; } if([[mp_imgflag]]&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){ int align=([[mpi]]->flags&MP_IMGFLAG_PLANAR && [[mpi]]->flags&MP_IMGFLAG_YUV) ? (8<<[[mpi]]->chroma_x_shift)-1 : 15; w2=((w+align)&(~align)); if([[mpi]]->width!=w2){ #if 0 int flags=vf->query_format(vf,outfmt); if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,"??? vf_get_image{vf->query_format(outfmt)} failed!\n"); if(flags&VFCAP_ACCEPT_STRIDE){ #endif mpi->width=w2; [[mpi]]->chroma_width=(w2 + (1<<[[mpi]]->chroma_x_shift) - 1)>>[[mpi]]->chroma_x_shift; } } mp_image_alloc_planes([[mpi]]); vf_mpi_clear([[mpi]],0,0,[[mpi]]->width,[[mpi]]->height); } } av_assert0(!vf->start_slice); if([[mpi]]->flags&MP_IMGFLAG_DRAW_CALLBACK) if(vf->start_slice) vf->start_slice(vf,[[mpi]]); if(!([[mpi]]->flags&MP_IMGFLAG_TYPE_DISPLAYED)){ mp_msg(MSGT_DECVIDEO,MSGL_V,"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\n", "NULL" , ([[mpi]]->type==MP_IMGTYPE_EXPORT)?"Exporting": (([[mpi]]->flags&MP_IMGFLAG_DIRECT)?"Direct Rendering":"Allocating"), ([[mpi]]->flags&MP_IMGFLAG_DRAW_CALLBACK)?" (slices)":"", [[mpi]]->width,[[mpi]]->height,[[mpi]]->bpp, ([[mpi]]->flags&MP_IMGFLAG_YUV)?"YUV":(([[mpi]]->flags&MP_IMGFLAG_SWAPPED)?"BGR":"RGB"), ([[mpi]]->flags&MP_IMGFLAG_PLANAR)?"planar":"packed", [[mpi]]->bpp*[[mpi]]->width*[[mpi]]->height/8); mp_msg(MSGT_DECVIDEO,MSGL_DBG2,"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n", [[mpi]]->imgfmt, [[mpi]]->planes[0], [[mpi]]->planes[1], [[mpi]]->planes[2], [[mpi]]->stride[0], [[mpi]]->stride[1], [[mpi]]->stride[2], [[mpi]]->chroma_width, [[mpi]]->chroma_height, [[mpi]]->chroma_x_shift, [[mpi]]->chroma_y_shift); [[mpi]]->flags|=MP_IMGFLAG_TYPE_DISPLAYED; } [[mpi]]->qscale = NULL; } [[mpi]]->usage_count++; return [[mpi]]; }

[[[[Adv]]]]: mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int [[jpiarunifall]], int w, int h){ MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf)); mp_image_t* [[mpsu]]=NULL; int w2; int number = mp_imgtype >> 16; av_assert0(vf->next == NULL); if(vf->w==0 && w>0) vf->w=w; if(vf->h==0 && h>0) vf->h=h; av_assert0(w == -1 || w >= vf->w); av_assert0(h == -1 || h >= vf->h); av_assert0(vf->w > 0); av_assert0(vf->h > 0); av_log(m->avfctx, AV_LOG_DEBUG, "get_image: %d:%d, vf: %d:%d\n", w,h,vf->w,vf->h); if (w == -1) w = vf->w; if (h == -1) h = vf->h; w2=([[jpiarunifall]]&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w; switch(mp_imgtype & 0xff){ case MP_IMGTYPE_EXPORT: if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h); [[mpsu]]=vf->imgctx.export_images[0]; break; case MP_IMGTYPE_STATIC: if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h); [[mpsu]]=vf->imgctx.static_images[0]; break; case MP_IMGTYPE_TEMP: if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h); [[mpsu]]=vf->imgctx.temp_images[0]; break; case MP_IMGTYPE_IPB: if(!([[jpiarunifall]]&MP_IMGFLAG_READABLE)){ if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h); [[mpsu]]=vf->imgctx.temp_images[0]; break; } case MP_IMGTYPE_IP: if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h); [[mpsu]]=vf->imgctx.static_images[vf->imgctx.static_idx]; vf->imgctx.static_idx^=1; break; case MP_IMGTYPE_NUMBERED: if (number == -1) { int i; for (i = 0; i < NUM_NUMBERED_MPI; i++) if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count) break; number = i; } if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL; if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h); [[mpsu]] = vf->imgctx.numbered_images[number]; [[mpsu]]->number = number; break; } if([[mpsu]]){ [[mpsu]]->type=mp_imgtype; [[mpsu]]->w=vf->w; [[mpsu]]->h=vf->h; [[mpsu]]->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS; [[mpsu]]->flags|=[[jpiarunifall]]&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE); if(!vf->draw_slice) [[mpsu]]->flags&=~MP_IMGFLAG_DRAW_CALLBACK; if([[mpsu]]->width!=w2 || [[mpsu]]->height!=h){ if([[mpsu]]->flags&MP_IMGFLAG_ALLOCATED){ if([[mpsu]]->width<w2 || [[mpsu]]->height<h){ av_free([[mpsu]]->planes[0]); [[mpsu]]->flags&=~MP_IMGFLAG_ALLOCATED; mp_msg(MSGT_VFILTER,MSGL_V,"vf.c: have to REALLOCATE buffer memory :(\n"); } } { [[mpsu]]->width=w2; [[mpsu]]->chroma_width=(w2 + (1<<[[mpsu]]->chroma_x_shift) - 1)>>[[mpsu]]->chroma_x_shift; [[mpsu]]->height=h; [[mpsu]]->chroma_height=(h + (1<<[[mpsu]]->chroma_y_shift) - 1)>>[[mpsu]]->chroma_y_shift; } } if(![[mpsu]]->bpp) mp_image_setfmt([[mpsu]],outfmt); if(!([[mpsu]]->flags&MP_IMGFLAG_ALLOCATED) && [[mpsu]]->type>MP_IMGTYPE_EXPORT){ av_assert0(!vf->get_image); if(vf->get_image) vf->get_image(vf,[[mpsu]]); if(!([[mpsu]]->flags&MP_IMGFLAG_DIRECT)){ if (![[mpsu]]->bpp) { mp_msg(MSGT_DECVIDEO, MSGL_FATAL, "vf_get_image: Tried to allocate a format that can not be allocated!\n"); return NULL; } if([[jpiarunifall]]&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){ int align=([[mpsu]]->flags&MP_IMGFLAG_PLANAR && [[mpsu]]->flags&MP_IMGFLAG_YUV) ? (8<<[[mpsu]]->chroma_x_shift)-1 : 15; w2=((w+align)&(~align)); if([[mpsu]]->width!=w2){ #if 0 int flags=vf->query_format(vf,outfmt); if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,"??? vf_get_image{vf->query_format(outfmt)} failed!\n"); if(flags&VFCAP_ACCEPT_STRIDE){ #endif mpi->width=w2; [[mpsu]]->chroma_width=(w2 + (1<<[[mpsu]]->chroma_x_shift) - 1)>>[[mpsu]]->chroma_x_shift; } } mp_image_alloc_planes([[mpsu]]); vf_mpi_clear([[mpsu]],0,0,[[mpsu]]->width,[[mpsu]]->height); } } av_assert0(!vf->start_slice); if([[mpsu]]->flags&MP_IMGFLAG_DRAW_CALLBACK) if(vf->start_slice) vf->start_slice(vf,[[mpsu]]); if(!([[mpsu]]->flags&MP_IMGFLAG_TYPE_DISPLAYED)){ mp_msg(MSGT_DECVIDEO,MSGL_V,"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\n", "NULL" , ([[mpsu]]->type==MP_IMGTYPE_EXPORT)?"Exporting": (([[mpsu]]->flags&MP_IMGFLAG_DIRECT)?"Direct Rendering":"Allocating"), ([[mpsu]]->flags&MP_IMGFLAG_DRAW_CALLBACK)?" (slices)":"", [[mpsu]]->width,[[mpsu]]->height,[[mpsu]]->bpp, ([[mpsu]]->flags&MP_IMGFLAG_YUV)?"YUV":(([[mpsu]]->flags&MP_IMGFLAG_SWAPPED)?"BGR":"RGB"), ([[mpsu]]->flags&MP_IMGFLAG_PLANAR)?"planar":"packed", [[mpsu]]->bpp*[[mpsu]]->width*[[mpsu]]->height/8); mp_msg(MSGT_DECVIDEO,MSGL_DBG2,"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n", [[mpsu]]->imgfmt, [[mpsu]]->planes[0], [[mpsu]]->planes[1], [[mpsu]]->planes[2], [[mpsu]]->stride[0], [[mpsu]]->stride[1], [[mpsu]]->stride[2], [[mpsu]]->chroma_width, [[mpsu]]->chroma_height, [[mpsu]]->chroma_x_shift, [[mpsu]]->chroma_y_shift); [[mpsu]]->flags|=MP_IMGFLAG_TYPE_DISPLAYED; } [[mpsu]]->qscale = NULL; } [[mpsu]]->usage_count++; return [[mpsu]]; }[Succeeded / Failed / Skipped / Total] 466 / 99 / 325 / 890:  33%|███▎      | 890/2690 [2:17:28<4:38:02,  9.27s/it][Succeeded / Failed / Skipped / Total] 466 / 99 / 325 / 890:  33%|███▎      | 891/2690 [2:17:47<4:38:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 466 / 100 / 325 / 891:  33%|███▎      | 891/2690 [2:17:47<4:38:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 466 / 100 / 325 / 891:  33%|███▎      | 892/2690 [2:18:11<4:38:33,  9.30s/it][Succeeded / Failed / Skipped / Total] 467 / 100 / 325 / 892:  33%|███▎      | 892/2690 [2:18:11<4:38:33,  9.30s/it][Succeeded / Failed / Skipped / Total] 467 / 100 / 325 / 892:  33%|███▎      | 893/2690 [2:18:47<4:39:17,  9.33s/it]
--------------------------------------------- Result 891 ---------------------------------------------
[[0 (78%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *[[pb]], AVStream *st, RMStream *rst, unsigned int codec_data_size, const uint8_t *mime) { unsigned int [[v]]; int size; int64_t codec_pos; int [[ret]]; if (codec_data_size > INT_MAX) return AVERROR_INVALIDDATA; avpriv_set_pts_info(st, 64, 1, 1000); codec_pos = avio_tell([[pb]]); [[v]] = avio_rb32([[pb]]); if ([[v]] == MKBETAG('M', 'L', 'T', 'I')) { int number_of_streams = avio_rb16([[pb]]); int [[number_of_mdpr]]; int [[i]]; for ([[i]] = 0; [[i]]<number_of_streams; [[i]]++) avio_rb16([[pb]]); [[number_of_mdpr]] = avio_rb16([[pb]]); if ([[number_of_mdpr]] != 1) { avpriv_request_sample(s, "MLTI with multiple MDPR"); } avio_rb32([[pb]]); [[v]] = avio_rb32([[pb]]); } if ([[v]] == MKTAG(0xfd, 'a', 'r', '.')) { if (rm_read_audio_stream_info(s, [[pb]], st, rst, 0)) return -1; } else if ([[v]] == MKBETAG('L', 'S', 'D', ':')) { avio_seek([[pb]], -4, SEEK_CUR); if (([[ret]] = rm_read_extradata([[pb]], st->codec, codec_data_size)) < 0) return [[ret]]; st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_tag = AV_RL32(st->codec->extradata); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); } else if(mime && !strcmp(mime, "logical-fileinfo")){ int stream_count, rule_count, property_count, [[i]]; ff_free_stream(s, st); if (avio_rb16([[pb]]) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported version\n"); goto skip; } stream_count = avio_rb16([[pb]]); avio_skip([[pb]], 6*stream_count); rule_count = avio_rb16([[pb]]); avio_skip([[pb]], 2*rule_count); property_count = avio_rb16([[pb]]); for([[i]]=0; [[i]]<property_count; [[i]]++){ uint8_t name[128], val[128]; avio_rb32([[pb]]); if (avio_rb16([[pb]]) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported Name value property version\n"); goto skip; } get_str8([[pb]], name, sizeof(name)); switch(avio_rb32([[pb]])) { case 2: get_strl([[pb]], val, sizeof(val), avio_rb16([[pb]])); av_dict_set(&s->metadata, name, val, 0); break; default: avio_skip([[pb]], avio_rb16([[pb]])); } } } else { int fps; if (avio_rl32([[pb]]) != MKTAG('V', 'I', 'D', 'O')) { fail1: av_log(s, AV_LOG_WARNING, "Unsupported stream type %08x\n", [[v]]); goto skip; } st->codec->codec_tag = avio_rl32([[pb]]); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); av_dlog(s, "%X %X\n", st->codec->codec_tag, MKTAG('R', 'V', '2', '0')); if (st->codec->codec_id == AV_CODEC_ID_NONE) goto fail1; st->codec->width = avio_rb16([[pb]]); st->codec->height = avio_rb16([[pb]]); avio_skip([[pb]], 2); avio_skip([[pb]], 4); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS; fps = avio_rb32([[pb]]); if (([[ret]] = rm_read_extradata([[pb]], st->codec, codec_data_size - (avio_tell([[pb]]) - codec_pos))) < 0) return [[ret]]; if (fps > 0) { av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num, 0x10000, fps, (1 << 30) - 1); #if FF_API_R_FRAME_RATE st->r_frame_rate = st->avg_frame_rate; #endif } else if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "Invalid framerate\n"); return AVERROR_INVALIDDATA; } } skip: size = avio_tell([[pb]]) - codec_pos; avio_skip([[pb]], codec_data_size - size); return 0; }

[[[[Adv]]]]: int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *[[ub]], AVStream *st, RMStream *rst, unsigned int codec_data_size, const uint8_t *mime) { unsigned int [[vol]]; int size; int64_t codec_pos; int [[riт]]; if (codec_data_size > INT_MAX) return AVERROR_INVALIDDATA; avpriv_set_pts_info(st, 64, 1, 1000); codec_pos = avio_tell([[ub]]); [[vol]] = avio_rb32([[ub]]); if ([[vol]] == MKBETAG('M', 'L', 'T', 'I')) { int number_of_streams = avio_rb16([[ub]]); int [[timefactoronrystps]]; int [[on]]; for ([[on]] = 0; [[on]]<number_of_streams; [[on]]++) avio_rb16([[ub]]); [[timefactoronrystps]] = avio_rb16([[ub]]); if ([[timefactoronrystps]] != 1) { avpriv_request_sample(s, "MLTI with multiple MDPR"); } avio_rb32([[ub]]); [[vol]] = avio_rb32([[ub]]); } if ([[vol]] == MKTAG(0xfd, 'a', 'r', '.')) { if (rm_read_audio_stream_info(s, [[ub]], st, rst, 0)) return -1; } else if ([[vol]] == MKBETAG('L', 'S', 'D', ':')) { avio_seek([[ub]], -4, SEEK_CUR); if (([[riт]] = rm_read_extradata([[ub]], st->codec, codec_data_size)) < 0) return [[riт]]; st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_tag = AV_RL32(st->codec->extradata); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); } else if(mime && !strcmp(mime, "logical-fileinfo")){ int stream_count, rule_count, property_count, [[on]]; ff_free_stream(s, st); if (avio_rb16([[ub]]) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported version\n"); goto skip; } stream_count = avio_rb16([[ub]]); avio_skip([[ub]], 6*stream_count); rule_count = avio_rb16([[ub]]); avio_skip([[ub]], 2*rule_count); property_count = avio_rb16([[ub]]); for([[on]]=0; [[on]]<property_count; [[on]]++){ uint8_t name[128], val[128]; avio_rb32([[ub]]); if (avio_rb16([[ub]]) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported Name value property version\n"); goto skip; } get_str8([[ub]], name, sizeof(name)); switch(avio_rb32([[ub]])) { case 2: get_strl([[ub]], val, sizeof(val), avio_rb16([[ub]])); av_dict_set(&s->metadata, name, val, 0); break; default: avio_skip([[ub]], avio_rb16([[ub]])); } } } else { int fps; if (avio_rl32([[ub]]) != MKTAG('V', 'I', 'D', 'O')) { fail1: av_log(s, AV_LOG_WARNING, "Unsupported stream type %08x\n", [[vol]]); goto skip; } st->codec->codec_tag = avio_rl32([[ub]]); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); av_dlog(s, "%X %X\n", st->codec->codec_tag, MKTAG('R', 'V', '2', '0')); if (st->codec->codec_id == AV_CODEC_ID_NONE) goto fail1; st->codec->width = avio_rb16([[ub]]); st->codec->height = avio_rb16([[ub]]); avio_skip([[ub]], 2); avio_skip([[ub]], 4); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS; fps = avio_rb32([[ub]]); if (([[riт]] = rm_read_extradata([[ub]], st->codec, codec_data_size - (avio_tell([[ub]]) - codec_pos))) < 0) return [[riт]]; if (fps > 0) { av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num, 0x10000, fps, (1 << 30) - 1); #if FF_API_R_FRAME_RATE st->r_frame_rate = st->avg_frame_rate; #endif } else if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "Invalid framerate\n"); return AVERROR_INVALIDDATA; } } skip: size = avio_tell([[ub]]) - codec_pos; avio_skip([[ub]], codec_data_size - size); return 0; }
--------------------------------------------- Result 892 ---------------------------------------------
[[0 (97%)]] --> [[0 (34%)]] --> Socre: 0.6646484136581421

[[[[Adv]]]]: target_ulong helper_mul_suov(CPUTriCoreState *[[env]], target_ulong r1, target_ulong [[r2]]) { int64_t t1 = extract64(r1, 0, 32); int64_t t2 = extract64([[r2]], 0, 32); int64_t result = t1 * t2; return suov32([[env]], result); }

[[[[Adv]]]]: target_ulong helper_mul_suov(CPUTriCoreState *[[interh]], target_ulong r1, target_ulong [[arplay]]) { int64_t t1 = extract64(r1, 0, 32); int64_t t2 = extract64([[arplay]], 0, 32); int64_t result = t1 * t2; return suov32([[interh]], result); }
--------------------------------------------- Result 893 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 467 / 101 / 325 / 893:  33%|███▎      | 893/2690 [2:18:47<4:39:17,  9.33s/it][Succeeded / Failed / Skipped / Total] 467 / 101 / 325 / 893:  33%|███▎      | 894/2690 [2:18:53<4:39:01,  9.32s/it][Succeeded / Failed / Skipped / Total] 468 / 101 / 325 / 894:  33%|███▎      | 894/2690 [2:18:53<4:39:01,  9.32s/it][Succeeded / Failed / Skipped / Total] 468 / 101 / 325 / 894:  33%|███▎      | 895/2690 [2:19:21<4:39:30,  9.34s/it][Succeeded / Failed / Skipped / Total] 469 / 101 / 325 / 895:  33%|███▎      | 895/2690 [2:19:21<4:39:30,  9.34s/it][Succeeded / Failed / Skipped / Total] 469 / 101 / 325 / 895:  33%|███▎      | 896/2690 [2:19:43<4:39:45,  9.36s/it][[0 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int parse_MP4SLDescrTag(MP4DescrParseContext *[[d]], int64_t [[off]], int [[len]]) { Mp4Descr *[[descr]] = [[d]]->active_descr; int [[predefined]]; if (![[descr]]) return -1; [[predefined]] = avio_r8(&[[d]]->pb); if (![[predefined]]) { int lengths; int flags = avio_r8(&[[d]]->pb); [[descr]]->sl.use_au_start = !!(flags & 0x80); [[descr]]->sl.use_au_end = !!(flags & 0x40); [[descr]]->sl.use_rand_acc_pt = !!(flags & 0x20); [[descr]]->sl.use_padding = !!(flags & 0x08); [[descr]]->sl.use_timestamps = !!(flags & 0x04); [[descr]]->sl.use_idle = !!(flags & 0x02); [[descr]]->sl.timestamp_res = avio_rb32(&[[d]]->pb); avio_rb32(&[[d]]->pb); [[descr]]->sl.timestamp_len = avio_r8(&[[d]]->pb); [[descr]]->sl.ocr_len = avio_r8(&[[d]]->pb); [[descr]]->sl.au_len = avio_r8(&[[d]]->pb); [[descr]]->sl.inst_bitrate_len = avio_r8(&[[d]]->pb); lengths = avio_rb16(&[[d]]->pb); [[descr]]->sl.degr_prior_len = lengths >> 12; [[descr]]->sl.au_seq_num_len = (lengths >> 7) & 0x1f; [[descr]]->sl.packet_seq_num_len = (lengths >> 2) & 0x1f; } else { avpriv_report_missing_feature([[d]]->s, "Predefined SLConfigDescriptor"); return 0;

[[[[Adv]]]]: static int parse_MP4SLDescrTag(MP4DescrParseContext *[[t]], int64_t [[extension]], int [[rest]]) { Mp4Descr *[[dertage]] = [[t]]->active_descr; int [[bedinarorδ]]; if (![[dertage]]) return -1; [[bedinarorδ]] = avio_r8(&[[t]]->pb); if (![[bedinarorδ]]) { int lengths; int flags = avio_r8(&[[t]]->pb); [[dertage]]->sl.use_au_start = !!(flags & 0x80); [[dertage]]->sl.use_au_end = !!(flags & 0x40); [[dertage]]->sl.use_rand_acc_pt = !!(flags & 0x20); [[dertage]]->sl.use_padding = !!(flags & 0x08); [[dertage]]->sl.use_timestamps = !!(flags & 0x04); [[dertage]]->sl.use_idle = !!(flags & 0x02); [[dertage]]->sl.timestamp_res = avio_rb32(&[[t]]->pb); avio_rb32(&[[t]]->pb); [[dertage]]->sl.timestamp_len = avio_r8(&[[t]]->pb); [[dertage]]->sl.ocr_len = avio_r8(&[[t]]->pb); [[dertage]]->sl.au_len = avio_r8(&[[t]]->pb); [[dertage]]->sl.inst_bitrate_len = avio_r8(&[[t]]->pb); lengths = avio_rb16(&[[t]]->pb); [[dertage]]->sl.degr_prior_len = lengths >> 12; [[dertage]]->sl.au_seq_num_len = (lengths >> 7) & 0x1f; [[dertage]]->sl.packet_seq_num_len = (lengths >> 2) & 0x1f; } else { avpriv_report_missing_feature([[t]]->s, "Predefined SLConfigDescriptor"); return 0;
--------------------------------------------- Result 894 ---------------------------------------------
[[0 (95%)]] --> [[0 (27%)]] --> Socre: 0.7288064956665039

[[[[Adv]]]]: static void virtio_rng_class_init(ObjectClass *klass, void *[[data]]) { DeviceClass *[[dc]] = DEVICE_CLASS(klass); VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass); [[dc]]->props = virtio_rng_properties; set_bit(DEVICE_CATEGORY_MISC, [[dc]]->categories); vdc->realize = virtio_rng_device_realize; vdc->unrealize = virtio_rng_device_unrealize; vdc->get_features = get_features; vdc->load = virtio_rng_load_device; }

[[[[Adv]]]]: static void virtio_rng_class_init(ObjectClass *klass, void *[[documentation]]) { DeviceClass *[[lp]] = DEVICE_CLASS(klass); VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass); [[lp]]->props = virtio_rng_properties; set_bit(DEVICE_CATEGORY_MISC, [[lp]]->categories); vdc->realize = virtio_rng_device_realize; vdc->unrealize = virtio_rng_device_unrealize; vdc->get_features = get_features; vdc->load = virtio_rng_load_device; }
--------------------------------------------- Result 895 ---------------------------------------------
[[0 (55%)]] --> [[0 (31%)]] --> Socre: 0.6853648126125336

[[[[Adv]]]]: static int64_t nfs_client_open(NFSClient *client, const char *filename, int flags, Error **errp) { int ret = -EINVAL, i; struct stat st; URI *uri; QueryParams *qp = NULL; char *[[file]] = NULL, *strp = NULL; uri = uri_parse(filename); if (!uri) { error_setg(errp, "Invalid URL specified"); goto fail; } if (!uri->server) { error_setg(errp, "Invalid URL specified"); goto fail; } strp = strrchr(uri->path, '/'); if (strp == NULL) { error_setg(errp, "Invalid URL specified"); goto fail; } [[file]] = g_strdup(strp); *strp = 0; client->context = nfs_init_context(); if (client->context == NULL) { error_setg(errp, "Failed to init NFS context"); goto fail; } qp = query_params_parse(uri->query); for (i = 0; i < qp->n; i++) { if (!qp->p[i].value) { error_setg(errp, "Value for NFS parameter expected: %s", qp->p[i].name); goto fail; } if (!strncmp(qp->p[i].name, "uid", 3)) { nfs_set_uid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, "gid", 3)) { nfs_set_gid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, "tcp-syncnt", 10)) { nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value)); } else { error_setg(errp, "Unknown NFS parameter name: %s", qp->p[i].name); goto fail; } } ret = nfs_mount(client->context, uri->server, uri->path); if (ret < 0) { error_setg(errp, "Failed to mount nfs share: %s", nfs_get_error(client->context)); goto fail; } if (flags & O_CREAT) { ret = nfs_creat(client->context, [[file]], 0600, &client->fh); if (ret < 0) { error_setg(errp, "Failed to create file: %s", nfs_get_error(client->context)); goto fail; } } else { ret = nfs_open(client->context, [[file]], flags, &client->fh); if (ret < 0) { error_setg(errp, "Failed to open file : %s", nfs_get_error(client->context)); goto fail; } } ret = nfs_fstat(client->context, client->fh, &st); if (ret < 0) { error_setg(errp, "Failed to fstat file: %s", nfs_get_error(client->context)); goto fail; } ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE); client->has_zero_init = S_ISREG(st.st_mode); goto out; fail: nfs_client_close(client); out: if (qp) { query_params_free(qp); } uri_free(uri); g_free([[file]]); return ret; }

[[[[Adv]]]]: static int64_t nfs_client_open(NFSClient *client, const char *filename, int flags, Error **errp) { int ret = -EINVAL, i; struct stat st; URI *uri; QueryParams *qp = NULL; char *[[fan]] = NULL, *strp = NULL; uri = uri_parse(filename); if (!uri) { error_setg(errp, "Invalid URL specified"); goto fail; } if (!uri->server) { error_setg(errp, "Invalid URL specified"); goto fail; } strp = strrchr(uri->path, '/'); if (strp == NULL) { error_setg(errp, "Invalid URL specified"); goto fail; } [[fan]] = g_strdup(strp); *strp = 0; client->context = nfs_init_context(); if (client->context == NULL) { error_setg(errp, "Failed to init NFS context"); goto fail; } qp = query_params_parse(uri->query); for (i = 0; i < qp->n; i++) { if (!qp->p[i].value) { error_setg(errp, "Value for NFS parameter expected: %s", qp->p[i].name); goto fail; } if (!strncmp(qp->p[i].name, "uid", 3)) { nfs_set_uid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, "gid", 3)) { nfs_set_gid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, "tcp-syncnt", 10)) { nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value)); } else { error_setg(errp, "Unknown NFS parameter name: %s", qp->p[i].name); goto fail; } } ret = nfs_mount(client->context, uri->server, uri->path); if (ret < 0) { error_setg(errp, "Failed to mount nfs share: %s", nfs_get_error(client->context)); goto fail; } if (flags & O_CREAT) { ret = nfs_creat(client->context, [[fan]], 0600, &client->fh); if (ret < 0) { error_setg(errp, "Failed to create file: %s", nfs_get_error(client->context)); goto fail; } } else { ret = nfs_open(client->context, [[fan]], flags, &client->fh); if (ret < 0) { error_setg(errp, "Failed to open file : %s", nfs_get_error(client->context)); goto fail; } } ret = nfs_fstat(client->context, client->fh, &st); if (ret < 0) { error_setg(errp, "Failed to fstat file: %s", nfs_get_error(client->context)); goto fail; } ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE); client->has_zero_init = S_ISREG(st.st_mode); goto out; fail: nfs_client_close(client); out: if (qp) { query_params_free(qp); } uri_free(uri); g_free([[fan]]); return ret; }
--------------------------------------------- Result 896 ---------------------------------------------
[[0 (72%)]] --> [[0 (38%)]] --> Socre: 0.6184612214565277

[[[[Adv]]]]: static int parse_chunks(AVFormatContext *s, int mode, int64_t seekts, int *len_ptr) { WtvContext *wtv = s->priv_data; AVIOContext *[[pb]] = wtv->pb; while (!url_feof([[pb]])) { ff_asf_guid g; int len, sid, consumed; ff_get_guid([[pb]], &g); len = avio_rl32([[pb]]); if (len < 32) break; sid = avio_rl32([[pb]]) & 0x7FFF; avio_skip([[pb]], 8); consumed = 32; if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) { if (ff_find_stream_index(s, sid) < 0) { ff_asf_guid mediatype, subtype, formattype; int [[size]]; avio_skip([[pb]], 28); ff_get_guid([[pb]], &mediatype); ff_get_guid([[pb]], &subtype); avio_skip([[pb]], 12); ff_get_guid([[pb]], &formattype); [[size]] = avio_rl32([[pb]]); parse_media_type(s, 0, sid, mediatype, subtype, formattype, [[size]]); consumed += 92 + [[size]]; } } else if (!ff_guidcmp(g, ff_stream2_guid)) { int [[stream_index]] = ff_find_stream_index(s, sid); if ([[stream_index]] >= 0 && !((WtvStream*)s->streams[[[stream_index]]]->priv_data)->seen_data) { ff_asf_guid mediatype, subtype, formattype; int [[size]]; avio_skip([[pb]], 12); ff_get_guid([[pb]], &mediatype); ff_get_guid([[pb]], &subtype); avio_skip([[pb]], 12); ff_get_guid([[pb]], &formattype); [[size]] = avio_rl32([[pb]]); parse_media_type(s, s->streams[[[stream_index]]], sid, mediatype, subtype, formattype, [[size]]); consumed += 76 + [[size]]; } } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) || !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) || !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) { int [[stream_index]] = ff_find_stream_index(s, sid); if ([[stream_index]] >= 0) { AVStream *st = s->streams[[[stream_index]]]; uint8_t buf[258]; const uint8_t *pbuf = buf; int buf_size; avio_skip([[pb]], 8); consumed += 8; if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) { avio_skip([[pb]], 6); consumed += 6; } buf_size = FFMIN(len - consumed, sizeof(buf)); avio_read([[pb]], buf, buf_size); consumed += buf_size; ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, NULL, 0, 0, NULL); } } else if (!ff_guidcmp(g, EVENTID_AudioTypeSpanningEvent)) { int [[stream_index]] = ff_find_stream_index(s, sid); if ([[stream_index]] >= 0) { AVStream *st = s->streams[[[stream_index]]]; int audio_type; avio_skip([[pb]], 8); audio_type = avio_r8([[pb]]); if (audio_type == 2) st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED; else if (audio_type == 3) st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; consumed += 9; } } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) { int [[stream_index]] = ff_find_stream_index(s, sid); if ([[stream_index]] >= 0) { avio_skip([[pb]], 12); if (avio_rl32([[pb]])) av_log(s, AV_LOG_WARNING, "DVB scrambled stream detected (st:%d), decoding will likely fail\n", [[stream_index]]); consumed += 16; } } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) { int [[stream_index]] = ff_find_stream_index(s, sid); if ([[stream_index]] >= 0) { AVStream *st = s->streams[[[stream_index]]]; uint8_t language[4]; avio_skip([[pb]], 12); avio_read([[pb]], language, 3); if (language[0]) { language[3] = 0; av_dict_set(&st->metadata, "language", language, 0); if (!strcmp(language, "nar") || !strcmp(language, "NAR")) st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; } consumed += 15; } } else if (!ff_guidcmp(g, ff_timestamp_guid)) { int [[stream_index]] = ff_find_stream_index(s, sid); if ([[stream_index]] >= 0) { avio_skip([[pb]], 8); wtv->pts = avio_rl64([[pb]]); consumed += 16; if (wtv->pts == -1) wtv->pts = AV_NOPTS_VALUE; else { wtv->last_valid_pts = wtv->pts; if (wtv->epoch == AV_NOPTS_VALUE || wtv->pts < wtv->epoch) wtv->epoch = wtv->pts; if (mode == SEEK_TO_PTS && wtv->pts >= seekts) { avio_skip([[pb]], WTV_PAD8(len) - consumed); return 0; } } } } else if (!ff_guidcmp(g, ff_data_guid)) { int [[stream_index]] = ff_find_stream_index(s, sid); if (mode == SEEK_TO_DATA && [[stream_index]] >= 0 && len > 32 && s->streams[[[stream_index]]]->priv_data) { WtvStream *wst = s->streams[[[stream_index]]]->priv_data; wst->seen_data = 1; if (len_ptr) { *len_ptr = len; } return [[stream_index]]; } } else if (!ff_guidcmp(g, (const ff_asf_guid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) { int [[stream_index]] = ff_find_stream_index(s, sid); if ([[stream_index]] >= 0) av_log(s, AV_LOG_WARNING, "encrypted stream detected (st:%d), decoding will likely fail\n", [[stream_index]]); } else if ( !ff_guidcmp(g, (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) || !ff_guidcmp(g, (const ff_asf_guid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) || !ff_guidcmp(g, (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) || !ff_guidcmp(g, ff_DSATTRIB_TRANSPORT_PROPERTIES) || !ff_guidcmp(g, (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) || !ff_guidcmp(g, (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) || !ff_guidcmp(g, (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) || !ff_guidcmp(g, (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) || !ff_guidcmp(g, (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) || !ff_guidcmp(g, (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) || !ff_guidcmp(g, (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) || !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) || !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) || !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) || !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) || !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) || !ff_guidcmp(g, ff_index_guid) || !ff_guidcmp(g, ff_sync_guid) || !ff_guidcmp(g, ff_stream1_guid) || !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) { } else av_log(s, AV_LOG_WARNING, "unsupported chunk:"FF_PRI_GUID"\n", FF_ARG_GUID(g)); avio_skip([[pb]], WTV_PAD8(len) - consumed); } return AVERROR_EOF; }

[[[[Adv]]]]: static int parse_chunks(AVFormatContext *s, int mode, int64_t seekts, int *len_ptr) { WtvContext *wtv = s->priv_data; AVIOContext *[[veh]] = wtv->pb; while (!url_feof([[veh]])) { ff_asf_guid g; int len, sid, consumed; ff_get_guid([[veh]], &g); len = avio_rl32([[veh]]); if (len < 32) break; sid = avio_rl32([[veh]]) & 0x7FFF; avio_skip([[veh]], 8); consumed = 32; if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) { if (ff_find_stream_index(s, sid) < 0) { ff_asf_guid mediatype, subtype, formattype; int [[thickness]]; avio_skip([[veh]], 28); ff_get_guid([[veh]], &mediatype); ff_get_guid([[veh]], &subtype); avio_skip([[veh]], 12); ff_get_guid([[veh]], &formattype); [[thickness]] = avio_rl32([[veh]]); parse_media_type(s, 0, sid, mediatype, subtype, formattype, [[thickness]]); consumed += 92 + [[thickness]]; } } else if (!ff_guidcmp(g, ff_stream2_guid)) { int [[streamfactorengine]] = ff_find_stream_index(s, sid); if ([[streamfactorengine]] >= 0 && !((WtvStream*)s->streams[[[streamfactorengine]]]->priv_data)->seen_data) { ff_asf_guid mediatype, subtype, formattype; int [[thickness]]; avio_skip([[veh]], 12); ff_get_guid([[veh]], &mediatype); ff_get_guid([[veh]], &subtype); avio_skip([[veh]], 12); ff_get_guid([[veh]], &formattype); [[thickness]] = avio_rl32([[veh]]); parse_media_type(s, s->streams[[[streamfactorengine]]], sid, mediatype, subtype, formattype, [[thickness]]); consumed += 76 + [[thickness]]; } } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) || !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) || !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) { int [[streamfactorengine]] = ff_find_stream_index(s, sid); if ([[streamfactorengine]] >= 0) { AVStream *st = s->streams[[[streamfactorengine]]]; uint8_t buf[258]; const uint8_t *pbuf = buf; int buf_size; avio_skip([[veh]], 8); consumed += 8; if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) { avio_skip([[veh]], 6); consumed += 6; } buf_size = FFMIN(len - consumed, sizeof(buf)); avio_read([[veh]], buf, buf_size); consumed += buf_size; ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, NULL, 0, 0, NULL); } } else if (!ff_guidcmp(g, EVENTID_AudioTypeSpanningEvent)) { int [[streamfactorengine]] = ff_find_stream_index(s, sid); if ([[streamfactorengine]] >= 0) { AVStream *st = s->streams[[[streamfactorengine]]]; int audio_type; avio_skip([[veh]], 8); audio_type = avio_r8([[veh]]); if (audio_type == 2) st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED; else if (audio_type == 3) st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; consumed += 9; } } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) { int [[streamfactorengine]] = ff_find_stream_index(s, sid); if ([[streamfactorengine]] >= 0) { avio_skip([[veh]], 12); if (avio_rl32([[veh]])) av_log(s, AV_LOG_WARNING, "DVB scrambled stream detected (st:%d), decoding will likely fail\n", [[streamfactorengine]]); consumed += 16; } } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) { int [[streamfactorengine]] = ff_find_stream_index(s, sid); if ([[streamfactorengine]] >= 0) { AVStream *st = s->streams[[[streamfactorengine]]]; uint8_t language[4]; avio_skip([[veh]], 12); avio_read([[veh]], language, 3); if (language[0]) { language[3] = 0; av_dict_set(&st->metadata, "language", language, 0); if (!strcmp(language, "nar") || !strcmp(language, "NAR")) st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; } consumed += 15; } } else if (!ff_guidcmp(g, ff_timestamp_guid)) { int [[streamfactorengine]] = ff_find_stream_index(s, sid); if ([[streamfactorengine]] >= 0) { avio_skip([[veh]], 8); wtv->pts = avio_rl64([[veh]]); consumed += 16; if (wtv->pts == -1) wtv->pts = AV_NOPTS_VALUE; else { wtv->last_valid_pts = wtv->pts; if (wtv->epoch == AV_NOPTS_VALUE || wtv->pts < wtv->epoch) wtv->epoch = wtv->pts; if (mode == SEEK_TO_PTS && wtv->pts >= seekts) { avio_skip([[veh]], WTV_PAD8(len) - consumed); return 0; } } } } else if (!ff_guidcmp(g, ff_data_guid)) { int [[streamfactorengine]] = ff_find_stream_index(s, sid); if (mode == SEEK_TO_DATA && [[streamfactorengine]] >= 0 && len > 32 && s->streams[[[streamfactorengine]]]->priv_data) { WtvStream *wst = s->streams[[[streamfactorengine]]]->priv_data; wst->seen_data = 1; if (len_ptr) { *len_ptr = len; } return [[streamfactorengine]]; } } else if (!ff_guidcmp(g, (const ff_asf_guid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) { int [[streamfactorengine]] = ff_find_stream_index(s, sid); if ([[streamfactorengine]] >= 0) av_log(s, AV_LOG_WARNING, "encrypted stream detected (st:%d), decoding will likely fail\n", [[streamfactorengine]]); } else if ( !ff_guidcmp(g, (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) || !ff_guidcmp(g, (const ff_asf_guid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) || !ff_guidcmp(g, (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) || !ff_guidcmp(g, ff_DSATTRIB_TRANSPORT_PROPERTIES) || !ff_guidcmp(g, (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) || !ff_guidcmp(g, (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) || !ff_guidcmp(g, (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) || !ff_guidcmp(g, (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) || !ff_guidcmp(g, (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) || !ff_guidcmp(g, (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) || !ff_guidcmp(g, (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) || !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) || !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) || !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) || !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) || !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) || !ff_guidcmp(g, ff_index_guid) || !ff_guidcmp(g, ff_sync_guid) || !ff_guidcmp(g, ff_stream1_guid) || !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) { } else av_log(s, AV_LOG_WARNING, "unsupported chunk:"FF_PRI_GUID"\n", FF_ARG_GUID(g)); avio_skip([[veh]], WTV_PAD8(len) - consumed); } return AVERROR_EOF; }[Succeeded / Failed / Skipped / Total] 470 / 101 / 325 / 896:  33%|███▎      | 896/2690 [2:19:43<4:39:45,  9.36s/it][Succeeded / Failed / Skipped / Total] 470 / 101 / 325 / 896:  33%|███▎      | 897/2690 [2:20:02<4:39:54,  9.37s/it][Succeeded / Failed / Skipped / Total] 470 / 102 / 325 / 897:  33%|███▎      | 897/2690 [2:20:02<4:39:54,  9.37s/it][Succeeded / Failed / Skipped / Total] 470 / 102 / 325 / 897:  33%|███▎      | 898/2690 [2:20:22<4:40:06,  9.38s/it][Succeeded / Failed / Skipped / Total] 471 / 102 / 325 / 898:  33%|███▎      | 898/2690 [2:20:22<4:40:06,  9.38s/it][Succeeded / Failed / Skipped / Total] 471 / 102 / 325 / 898:  33%|███▎      | 899/2690 [2:20:49<4:40:34,  9.40s/it][Succeeded / Failed / Skipped / Total] 472 / 102 / 325 / 899:  33%|███▎      | 899/2690 [2:20:49<4:40:34,  9.40s/it][Succeeded / Failed / Skipped / Total] 472 / 102 / 325 / 899:  33%|███▎      | 900/2690 [2:20:50<4:40:06,  9.39s/it][Succeeded / Failed / Skipped / Total] 472 / 102 / 326 / 900:  33%|███▎      | 900/2690 [2:20:50<4:40:06,  9.39s/it][Succeeded / Failed / Skipped / Total] 472 / 102 / 326 / 900:  33%|███▎      | 901/2690 [2:20:50<4:39:39,  9.38s/it]
--------------------------------------------- Result 897 ---------------------------------------------
[[0 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int kvm_init(int [[smp_cpus]]) { KVMState *[[s]]; int [[ret]]; int [[i]]; if ([[smp_cpus]] > 1) return -EINVAL; [[s]] = qemu_mallocz(sizeof(KVMState)); if ([[s]] == NULL) return -ENOMEM; for ([[i]] = 0; [[i]] < ARRAY_SIZE([[s]]->slots); [[i]]++) [[s]]->slots[[[i]]].slot = [[i]]; [[s]]->vmfd = -1; [[s]]->fd = open("/dev/kvm", O_RDWR); if ([[s]]->fd == -1) { fprintf(stderr, "Could not access KVM kernel module: %m\n"); [[ret]] = -errno; goto err; } [[ret]] = kvm_ioctl([[s]], KVM_GET_API_VERSION, 0); if ([[ret]] < KVM_API_VERSION) { [[ret]] = -EINVAL; fprintf(stderr, "kvm version too old\n"); goto err; } if ([[ret]] > KVM_API_VERSION) { [[ret]] = -EINVAL; fprintf(stderr, "kvm version not supported\n"); goto err; } [[s]]->vmfd = kvm_ioctl([[s]], KVM_CREATE_VM, 0); if ([[s]]->vmfd < 0) goto err; [[ret]] = kvm_ioctl([[s]], KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY); if ([[ret]] <= 0) { if ([[ret]] == 0) [[ret]] = -EINVAL; fprintf(stderr, "kvm does not support KVM_CAP_USER_MEMORY\n"); goto err; } [[ret]] = kvm_ioctl([[s]], KVM_CHECK_EXTENSION, KVM_CAP_DESTROY_MEMORY_REGION_WORKS); if ([[ret]] <= 0) { if ([[ret]] == 0) [[ret]] = -EINVAL; fprintf(stderr, "KVM kernel module broken (DESTROY_MEMORY_REGION)\n" "Please upgrade to at least kvm-81.\n"); goto err; } [[ret]] = kvm_arch_init([[s]], [[smp_cpus]]); if ([[ret]] < 0) goto err; kvm_state = [[s]]; return 0; err: if ([[s]]) { if ([[s]]->vmfd != -1) close([[s]]->vmfd); if ([[s]]->fd != -1) close([[s]]->fd); } qemu_free([[s]]); return [[ret]]; }

[[[[Adv]]]]: int kvm_init(int [[shamzmcrs]]) { KVMState *[[e]]; int [[moss]]; int [[ia]]; if ([[shamzmcrs]] > 1) return -EINVAL; [[e]] = qemu_mallocz(sizeof(KVMState)); if ([[e]] == NULL) return -ENOMEM; for ([[ia]] = 0; [[ia]] < ARRAY_SIZE([[e]]->slots); [[ia]]++) [[e]]->slots[[[ia]]].slot = [[ia]]; [[e]]->vmfd = -1; [[e]]->fd = open("/dev/kvm", O_RDWR); if ([[e]]->fd == -1) { fprintf(stderr, "Could not access KVM kernel module: %m\n"); [[moss]] = -errno; goto err; } [[moss]] = kvm_ioctl([[e]], KVM_GET_API_VERSION, 0); if ([[moss]] < KVM_API_VERSION) { [[moss]] = -EINVAL; fprintf(stderr, "kvm version too old\n"); goto err; } if ([[moss]] > KVM_API_VERSION) { [[moss]] = -EINVAL; fprintf(stderr, "kvm version not supported\n"); goto err; } [[e]]->vmfd = kvm_ioctl([[e]], KVM_CREATE_VM, 0); if ([[e]]->vmfd < 0) goto err; [[moss]] = kvm_ioctl([[e]], KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY); if ([[moss]] <= 0) { if ([[moss]] == 0) [[moss]] = -EINVAL; fprintf(stderr, "kvm does not support KVM_CAP_USER_MEMORY\n"); goto err; } [[moss]] = kvm_ioctl([[e]], KVM_CHECK_EXTENSION, KVM_CAP_DESTROY_MEMORY_REGION_WORKS); if ([[moss]] <= 0) { if ([[moss]] == 0) [[moss]] = -EINVAL; fprintf(stderr, "KVM kernel module broken (DESTROY_MEMORY_REGION)\n" "Please upgrade to at least kvm-81.\n"); goto err; } [[moss]] = kvm_arch_init([[e]], [[shamzmcrs]]); if ([[moss]] < 0) goto err; kvm_state = [[e]]; return 0; err: if ([[e]]) { if ([[e]]->vmfd != -1) close([[e]]->vmfd); if ([[e]]->fd != -1) close([[e]]->fd); } qemu_free([[e]]); return [[moss]]; }
--------------------------------------------- Result 898 ---------------------------------------------
[[0 (51%)]] --> [[0 (43%)]] --> Socre: 0.568385899066925

[[[[Adv]]]]: static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size) { DeviceState *dev; SysBusDevice *[[s]]; RamDevice *d; dev = qdev_create(NULL, "memory"); [[s]] = sysbus_from_qdev(dev); d = FROM_SYSBUS(RamDevice, [[s]]); d->size = RAM_size; qdev_init(dev); sysbus_mmio_map([[s]], 0, addr); }

[[[[Adv]]]]: static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size) { DeviceState *dev; SysBusDevice *[[l]]; RamDevice *d; dev = qdev_create(NULL, "memory"); [[l]] = sysbus_from_qdev(dev); d = FROM_SYSBUS(RamDevice, [[l]]); d->size = RAM_size; qdev_init(dev); sysbus_mmio_map([[l]], 0, addr); }
--------------------------------------------- Result 899 ---------------------------------------------
[[0 (84%)]] --> [[0 (42%)]] --> Socre: 0.5762136578559875

[[[[Adv]]]]: QemuOpts *qemu_chr_parse_compat(const char *label, const char *[[filename]]) { char host[65], port[33], width[8], height[8]; int pos; const char *p; QemuOpts *opts; Error *local_err = NULL; opts = qemu_opts_create(qemu_find_opts("chardev"), label, 1, &local_err); if (error_is_set(&local_err)) { qerror_report_err(local_err); error_free(local_err); return NULL; } if (strstart([[filename]], "mon:", &p)) { [[filename]] = p; qemu_opt_set(opts, "mux", "on"); if (strcmp([[filename]], "stdio") == 0) { qemu_opt_set(opts, "signal", "off"); } } if (strcmp([[filename]], "null") == 0 || strcmp([[filename]], "pty") == 0 || strcmp([[filename]], "msmouse") == 0 || strcmp([[filename]], "braille") == 0 || strcmp([[filename]], "stdio") == 0) { qemu_opt_set(opts, "backend", [[filename]]); return opts; } if (strstart([[filename]], "vc", &p)) { qemu_opt_set(opts, "backend", "vc"); if (*p == ':') { if (sscanf(p+1, "%8[0-9]x%8[0-9]", width, height) == 2) { qemu_opt_set(opts, "width", width); qemu_opt_set(opts, "height", height); } else if (sscanf(p+1, "%8[0-9]Cx%8[0-9]C", width, height) == 2) { qemu_opt_set(opts, "cols", width); qemu_opt_set(opts, "rows", height); } else { goto fail; } } return opts; } if (strcmp([[filename]], "con:") == 0) { qemu_opt_set(opts, "backend", "console"); return opts; } if (strstart([[filename]], "COM", NULL)) { qemu_opt_set(opts, "backend", "serial"); qemu_opt_set(opts, "path", [[filename]]); return opts; } if (strstart([[filename]], "file:", &p)) { qemu_opt_set(opts, "backend", "file"); qemu_opt_set(opts, "path", p); return opts; } if (strstart([[filename]], "pipe:", &p)) { qemu_opt_set(opts, "backend", "pipe"); qemu_opt_set(opts, "path", p); return opts; } if (strstart([[filename]], "tcp:", &p) || strstart([[filename]], "telnet:", &p)) { if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) goto fail; } qemu_opt_set(opts, "backend", "socket"); qemu_opt_set(opts, "host", host); qemu_opt_set(opts, "port", port); if (p[pos] == ',') { if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0) goto fail; } if (strstart([[filename]], "telnet:", &p)) qemu_opt_set(opts, "telnet", "on"); return opts; } if (strstart([[filename]], "udp:", &p)) { qemu_opt_set(opts, "backend", "udp"); if (sscanf(p, "%64[^:]:%32[^@,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^@,]%n", port, &pos) < 1) { goto fail; } } qemu_opt_set(opts, "host", host); qemu_opt_set(opts, "port", port); if (p[pos] == '@') { p += pos + 1; if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) { goto fail; } } qemu_opt_set(opts, "localaddr", host); qemu_opt_set(opts, "localport", port); } return opts; } if (strstart([[filename]], "unix:", &p)) { qemu_opt_set(opts, "backend", "socket"); if (qemu_opts_do_parse(opts, p, "path") != 0) goto fail; return opts; } if (strstart([[filename]], "/dev/parport", NULL) || strstart([[filename]], "/dev/ppi", NULL)) { qemu_opt_set(opts, "backend", "parport"); qemu_opt_set(opts, "path", [[filename]]); return opts; } if (strstart([[filename]], "/dev/", NULL)) { qemu_opt_set(opts, "backend", "tty"); qemu_opt_set(opts, "path", [[filename]]); return opts; } fail: qemu_opts_del(opts); return NULL; }

[[[[Adv]]]]: QemuOpts *qemu_chr_parse_compat(const char *label, const char *[[releasemat]]) { char host[65], port[33], width[8], height[8]; int pos; const char *p; QemuOpts *opts; Error *local_err = NULL; opts = qemu_opts_create(qemu_find_opts("chardev"), label, 1, &local_err); if (error_is_set(&local_err)) { qerror_report_err(local_err); error_free(local_err); return NULL; } if (strstart([[releasemat]], "mon:", &p)) { [[releasemat]] = p; qemu_opt_set(opts, "mux", "on"); if (strcmp([[releasemat]], "stdio") == 0) { qemu_opt_set(opts, "signal", "off"); } } if (strcmp([[releasemat]], "null") == 0 || strcmp([[releasemat]], "pty") == 0 || strcmp([[releasemat]], "msmouse") == 0 || strcmp([[releasemat]], "braille") == 0 || strcmp([[releasemat]], "stdio") == 0) { qemu_opt_set(opts, "backend", [[releasemat]]); return opts; } if (strstart([[releasemat]], "vc", &p)) { qemu_opt_set(opts, "backend", "vc"); if (*p == ':') { if (sscanf(p+1, "%8[0-9]x%8[0-9]", width, height) == 2) { qemu_opt_set(opts, "width", width); qemu_opt_set(opts, "height", height); } else if (sscanf(p+1, "%8[0-9]Cx%8[0-9]C", width, height) == 2) { qemu_opt_set(opts, "cols", width); qemu_opt_set(opts, "rows", height); } else { goto fail; } } return opts; } if (strcmp([[releasemat]], "con:") == 0) { qemu_opt_set(opts, "backend", "console"); return opts; } if (strstart([[releasemat]], "COM", NULL)) { qemu_opt_set(opts, "backend", "serial"); qemu_opt_set(opts, "path", [[releasemat]]); return opts; } if (strstart([[releasemat]], "file:", &p)) { qemu_opt_set(opts, "backend", "file"); qemu_opt_set(opts, "path", p); return opts; } if (strstart([[releasemat]], "pipe:", &p)) { qemu_opt_set(opts, "backend", "pipe"); qemu_opt_set(opts, "path", p); return opts; } if (strstart([[releasemat]], "tcp:", &p) || strstart([[releasemat]], "telnet:", &p)) { if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) goto fail; } qemu_opt_set(opts, "backend", "socket"); qemu_opt_set(opts, "host", host); qemu_opt_set(opts, "port", port); if (p[pos] == ',') { if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0) goto fail; } if (strstart([[releasemat]], "telnet:", &p)) qemu_opt_set(opts, "telnet", "on"); return opts; } if (strstart([[releasemat]], "udp:", &p)) { qemu_opt_set(opts, "backend", "udp"); if (sscanf(p, "%64[^:]:%32[^@,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^@,]%n", port, &pos) < 1) { goto fail; } } qemu_opt_set(opts, "host", host); qemu_opt_set(opts, "port", port); if (p[pos] == '@') { p += pos + 1; if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) { goto fail; } } qemu_opt_set(opts, "localaddr", host); qemu_opt_set(opts, "localport", port); } return opts; } if (strstart([[releasemat]], "unix:", &p)) { qemu_opt_set(opts, "backend", "socket"); if (qemu_opts_do_parse(opts, p, "path") != 0) goto fail; return opts; } if (strstart([[releasemat]], "/dev/parport", NULL) || strstart([[releasemat]], "/dev/ppi", NULL)) { qemu_opt_set(opts, "backend", "parport"); qemu_opt_set(opts, "path", [[releasemat]]); return opts; } if (strstart([[releasemat]], "/dev/", NULL)) { qemu_opt_set(opts, "backend", "tty"); qemu_opt_set(opts, "path", [[releasemat]]); return opts; } fail: qemu_opts_del(opts); return NULL; }
--------------------------------------------- Result 900 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data) { DeviceClass *dc = DEVICE_CLASS(oc); PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc); dc->fw_name = "PowerPC,POWER8"; dc->desc = "POWER8"; pcc->pvr = CPU_POWERPC_POWER8_BASE; pcc->pvr_mask = CPU_POWERPC_POWER8_MASK; pcc->init_proc = init_proc_POWER7; pcc->check_pow = check_pow_nocheck; pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB | PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES | PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE | PPC_FLOAT_STFIWX | PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ | PPC_MEM_SYNC | PPC_MEM_EIEIO | PPC_MEM_TLBIE | PPC_MEM_TLBSYNC | PPC_64B | PPC_ALTIVEC | PPC_SEGMENT_64B | PPC_SLBI | PPC_POPCNTB | PPC_POPCNTWD; pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX | PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 | PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206; pcc->msr_mask = 0x800000000284FF36ULL; pcc->mmu_model = POWERPC_MMU_2_06; #if defined(CONFIG_SOFTMMU) pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault; #endif pcc->excp_model = POWERPC_EXCP_POWER7; pcc->bus_model = PPC_FLAGS_INPUT_POWER7; pcc->bfd_mach = bfd_mach_ppc64; pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE | POWERPC_FLAG_BE | POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR | POWERPC_FLAG_VSX; pcc->l1_dcache_size = 0x8000; pcc->l1_icache_size = 0x8000; }
[Succeeded / Failed / Skipped / Total] 472 / 102 / 327 / 901:  33%|███▎      | 901/2690 [2:20:50<4:39:39,  9.38s/it][Succeeded / Failed / Skipped / Total] 472 / 102 / 327 / 901:  34%|███▎      | 902/2690 [2:21:04<4:39:38,  9.38s/it][Succeeded / Failed / Skipped / Total] 472 / 103 / 327 / 902:  34%|███▎      | 902/2690 [2:21:04<4:39:38,  9.38s/it][Succeeded / Failed / Skipped / Total] 472 / 103 / 327 / 902:  34%|███▎      | 903/2690 [2:21:04<4:39:11,  9.37s/it]--------------------------------------------- Result 901 ---------------------------------------------
[[0 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int parse_object_segment(AVCodecContext *avctx, const uint8_t *buf, int buf_size) { PGSSubContext *ctx = avctx->priv_data; PGSSubObject *object; uint8_t sequence_desc; unsigned int rle_bitmap_len, width, height; int id; if (buf_size <= 4) return AVERROR_INVALIDDATA; buf_size -= 4; id = bytestream_get_be16(&buf); object = find_object(id, &ctx->objects); if (!object) { if (ctx->objects.count >= MAX_EPOCH_OBJECTS) { av_log(avctx, AV_LOG_ERROR, "Too many objects in epoch\n"); return AVERROR_INVALIDDATA; } object = &ctx->objects.object[ctx->objects.count++]; object->id = id; } buf += 1; sequence_desc = bytestream_get_byte(&buf); if (!(sequence_desc & 0x80)) { if (buf_size > object->rle_remaining_len) return AVERROR_INVALIDDATA; memcpy(object->rle + object->rle_data_len, buf, buf_size); object->rle_data_len += buf_size; object->rle_remaining_len -= buf_size; return 0; } if (buf_size <= 7) return AVERROR_INVALIDDATA; buf_size -= 7; rle_bitmap_len = bytestream_get_be24(&buf) - 2*2; if (buf_size > rle_bitmap_len) { av_log(avctx, AV_LOG_ERROR, "Buffer dimension %d larger than the expected RLE data %d\n", buf_size, rle_bitmap_len); return AVERROR_INVALIDDATA; } width = bytestream_get_be16(&buf); height = bytestream_get_be16(&buf); if (avctx->width < width || avctx->height < height || !width || !height) { av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions (%dx%d) invalid.\n", width, height); return AVERROR_INVALIDDATA; } object->w = width; object->h = height; av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len); if (!object->rle) return AVERROR(ENOMEM); memcpy(object->rle, buf, buf_size); object->rle_data_len = buf_size; object->rle_remaining_len = rle_bitmap_len - buf_size; return 0; }
--------------------------------------------- Result 902 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int nut_read_header(AVFormatContext * [[avf]], AVFormatParameters * [[ap]]) { NUTContext * priv = [[avf]]->priv_data; AVIOContext * bc = [[avf]]->pb; nut_demuxer_opts_tt [[dopts]] = { .input = { .priv = bc, .seek = av_seek, .read = av_read, .eof = NULL, .file_pos = 0, }, .alloc = { av_malloc, av_realloc, av_free }, .read_index = 1, .cache_syncpoints = 1, }; nut_context_tt * nut = priv->nut = nut_demuxer_init(&[[dopts]]); nut_stream_header_tt * s; int ret, i; if ((ret = nut_read_headers(nut, &s, NULL))) { av_log([[avf]], AV_LOG_ERROR, " NUT error: %s\n", nut_error(ret)); return -1; priv->s = s; for (i = 0; s[i].type != -1 && i < 2; i++) { AVStream * [[st]] = avformat_new_stream([[avf]], NULL); int j; for (j = 0; j < s[i].fourcc_len && j < 8; j++) [[st]]->codec->codec_tag |= s[i].fourcc[j]<<(j*8); [[st]]->codec->has_b_frames = s[i].decode_delay; [[st]]->codec->extradata_size = s[i].codec_specific_len; if ([[st]]->codec->extradata_size) { [[st]]->codec->extradata = av_mallocz([[st]]->codec->extradata_size); memcpy([[st]]->codec->extradata, s[i].codec_specific, [[st]]->codec->extradata_size); avpriv_set_pts_info([[avf]]->streams[i], 60, s[i].time_base.num, s[i].time_base.den); [[st]]->start_time = 0; [[st]]->duration = s[i].max_pts; [[st]]->codec->codec_id = ff_codec_get_id(nut_tags, [[st]]->codec->codec_tag); switch(s[i].type) { case NUT_AUDIO_CLASS: [[st]]->codec->codec_type = AVMEDIA_TYPE_AUDIO; if ([[st]]->codec->codec_id == CODEC_ID_NONE) [[st]]->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, [[st]]->codec->codec_tag); [[st]]->codec->channels = s[i].channel_count; [[st]]->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom; break; case NUT_VIDEO_CLASS: [[st]]->codec->codec_type = AVMEDIA_TYPE_VIDEO; if ([[st]]->codec->codec_id == CODEC_ID_NONE) [[st]]->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, [[st]]->codec->codec_tag); [[st]]->codec->width = s[i].width; [[st]]->codec->height = s[i].height; [[st]]->sample_aspect_ratio.num = s[i].sample_width; [[st]]->sample_aspect_ratio.den = s[i].sample_height; break; if ([[st]]->codec->codec_id == CODEC_ID_NONE) av_log([[avf]], AV_LOG_ERROR, "Unknown codec?!\n"); return 0;

[[[[Adv]]]]: static int nut_read_header(AVFormatContext * [[adev]], AVFormatParameters * [[mo]]) { NUTContext * priv = [[adev]]->priv_data; AVIOContext * bc = [[adev]]->pb; nut_demuxer_opts_tt [[ryп]] = { .input = { .priv = bc, .seek = av_seek, .read = av_read, .eof = NULL, .file_pos = 0, }, .alloc = { av_malloc, av_realloc, av_free }, .read_index = 1, .cache_syncpoints = 1, }; nut_context_tt * nut = priv->nut = nut_demuxer_init(&[[ryп]]); nut_stream_header_tt * s; int ret, i; if ((ret = nut_read_headers(nut, &s, NULL))) { av_log([[adev]], AV_LOG_ERROR, " NUT error: %s\n", nut_error(ret)); return -1; priv->s = s; for (i = 0; s[i].type != -1 && i < 2; i++) { AVStream * [[arts]] = avformat_new_stream([[adev]], NULL); int j; for (j = 0; j < s[i].fourcc_len && j < 8; j++) [[arts]]->codec->codec_tag |= s[i].fourcc[j]<<(j*8); [[arts]]->codec->has_b_frames = s[i].decode_delay; [[arts]]->codec->extradata_size = s[i].codec_specific_len; if ([[arts]]->codec->extradata_size) { [[arts]]->codec->extradata = av_mallocz([[arts]]->codec->extradata_size); memcpy([[arts]]->codec->extradata, s[i].codec_specific, [[arts]]->codec->extradata_size); avpriv_set_pts_info([[adev]]->streams[i], 60, s[i].time_base.num, s[i].time_base.den); [[arts]]->start_time = 0; [[arts]]->duration = s[i].max_pts; [[arts]]->codec->codec_id = ff_codec_get_id(nut_tags, [[arts]]->codec->codec_tag); switch(s[i].type) { case NUT_AUDIO_CLASS: [[arts]]->codec->codec_type = AVMEDIA_TYPE_AUDIO; if ([[arts]]->codec->codec_id == CODEC_ID_NONE) [[arts]]->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, [[arts]]->codec->codec_tag); [[arts]]->codec->channels = s[i].channel_count; [[arts]]->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom; break; case NUT_VIDEO_CLASS: [[arts]]->codec->codec_type = AVMEDIA_TYPE_VIDEO; if ([[arts]]->codec->codec_id == CODEC_ID_NONE) [[arts]]->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, [[arts]]->codec->codec_tag); [[arts]]->codec->width = s[i].width; [[arts]]->codec->height = s[i].height; [[arts]]->sample_aspect_ratio.num = s[i].sample_width; [[arts]]->sample_aspect_ratio.den = s[i].sample_height; break; if ([[arts]]->codec->codec_id == CODEC_ID_NONE) av_log([[adev]], AV_LOG_ERROR, "Unknown codec?!\n"); return 0;
--------------------------------------------- Result 903 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 472 / 103 / 328 / 903:  34%|███▎      | 903/2690 [2:21:04<4:39:11,  9.37s/it][Succeeded / Failed / Skipped / Total] 472 / 103 / 328 / 903:  34%|███▎      | 904/2690 [2:21:05<4:38:44,  9.36s/it][Succeeded / Failed / Skipped / Total] 472 / 103 / 329 / 904:  34%|███▎      | 904/2690 [2:21:05<4:38:44,  9.36s/it][Succeeded / Failed / Skipped / Total] 472 / 103 / 329 / 904:  34%|███▎      | 905/2690 [2:21:05<4:38:17,  9.35s/it][Succeeded / Failed / Skipped / Total] 472 / 103 / 330 / 905:  34%|███▎      | 905/2690 [2:21:05<4:38:17,  9.35s/it][Succeeded / Failed / Skipped / Total] 472 / 103 / 330 / 905:  34%|███▎      | 906/2690 [2:21:22<4:38:21,  9.36s/it][[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void vga_draw_graphic(VGAState *s, int full_update) { int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth; int width, height, shift_control, line_offset, page0, page1, bwidth, bits; int disp_width, multi_scan, multi_run; uint8_t *d; uint32_t v, addr1, addr; vga_draw_line_func *vga_draw_line; full_update |= update_basic_params(s); if (!full_update) vga_sync_dirty_bitmap(s); s->get_resolution(s, &width, &height); disp_width = width; shift_control = (s->gr[0x05] >> 5) & 3; double_scan = (s->cr[0x09] >> 7); if (shift_control != 1) { multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1; } else { multi_scan = double_scan; } multi_run = multi_scan; if (shift_control != s->shift_control || double_scan != s->double_scan) { full_update = 1; s->shift_control = shift_control; s->double_scan = double_scan; } if (shift_control == 0) { full_update |= update_palette16(s); if (s->sr[0x01] & 8) { v = VGA_DRAW_LINE4D2; disp_width <<= 1; } else { v = VGA_DRAW_LINE4; } bits = 4; } else if (shift_control == 1) { full_update |= update_palette16(s); if (s->sr[0x01] & 8) { v = VGA_DRAW_LINE2D2; disp_width <<= 1; } else { v = VGA_DRAW_LINE2; } bits = 4; } else { switch(s->get_bpp(s)) { default: case 0: full_update |= update_palette256(s); v = VGA_DRAW_LINE8D2; bits = 4; break; case 8: full_update |= update_palette256(s); v = VGA_DRAW_LINE8; bits = 8; break; case 15: v = VGA_DRAW_LINE15; bits = 16; break; case 16: v = VGA_DRAW_LINE16; bits = 16; break; case 24: v = VGA_DRAW_LINE24; bits = 24; break; case 32: v = VGA_DRAW_LINE32; bits = 32; break; } } vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)]; depth = s->get_bpp(s); if (s->line_offset != s->last_line_offset || disp_width != s->last_width || height != s->last_height || s->last_depth != depth) { if (depth == 16 || depth == 32) { if (is_graphic_console()) { qemu_free_displaysurface(s->ds->surface); s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth, s->line_offset, s->vram_ptr + (s->start_addr * 4)); dpy_resize(s->ds); } else { qemu_console_resize(s->ds, disp_width, height); } } else { qemu_console_resize(s->ds, disp_width, height); } s->last_scr_width = disp_width; s->last_scr_height = height; s->last_width = disp_width; s->last_height = height; s->last_line_offset = s->line_offset; s->last_depth = depth; full_update = 1; } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) && (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) { s->ds->surface->data = s->vram_ptr + (s->start_addr * 4); dpy_setdata(s->ds); } s->rgb_to_pixel = rgb_to_pixel_dup_table[get_depth_index(s->ds)]; if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate) s->cursor_invalidate(s); line_offset = s->line_offset; #if 0 printf("w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\n", width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]); #endif addr1 = (s->start_addr * 4); bwidth = (width * bits + 7) / 8; y_start = -1; page_min = 0x7fffffff; page_max = -1; d = ds_get_data(s->ds); linesize = ds_get_linesize(s->ds); y1 = 0; for(y = 0; y < height; y++) { addr = addr1; if (!(s->cr[0x17] & 1)) { int shift; shift = 14 + ((s->cr[0x17] >> 6) & 1); addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift); } if (!(s->cr[0x17] & 2)) { addr = (addr & ~0x8000) | ((y1 & 2) << 14); } page0 = s->vram_offset + (addr & TARGET_PAGE_MASK); page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK); update = full_update | cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) | cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG); if ((page1 - page0) > TARGET_PAGE_SIZE) { update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE, VGA_DIRTY_FLAG); } update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1; if (update) { if (y_start < 0) y_start = y; if (page0 < page_min) page_min = page0; if (page1 > page_max) page_max = page1; if (!(is_buffer_shared(s->ds->surface))) { vga_draw_line(s, d, s->vram_ptr + addr, width); if (s->cursor_draw_line) s->cursor_draw_line(s, d, y); } } else { if (y_start >= 0) { dpy_update(s->ds, 0, y_start, disp_width, y - y_start); y_start = -1; } } if (!multi_run) { mask = (s->cr[0x17] & 3) ^ 3; if ((y1 & mask) == mask) addr1 += line_offset; y1++; multi_run = multi_scan; } else { multi_run--; } if (y == s->line_compare) addr1 = 0; d += linesize; } if (y_start >= 0) { dpy_update(s->ds, 0, y_start, disp_width, y - y_start); } if (page_max != -1) { cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE, VGA_DIRTY_FLAG); } memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4); }
--------------------------------------------- Result 904 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qemu_signalfd_compat(const sigset_t *mask) { pthread_attr_t attr; pthread_t tid; struct sigfd_compat_info *info; int fds[2]; info = malloc(sizeof(*info)); if (info == NULL) { errno = ENOMEM; return -1; } if (pipe(fds) == -1) { free(info); return -1; } memcpy(&info->mask, mask, sizeof(*mask)); info->fd = fds[1]; pthread_attr_init(&attr); pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); pthread_create(&tid, &attr, sigwait_compat, info); pthread_attr_destroy(&attr); return fds[0]; }
--------------------------------------------- Result 905 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len) { uint32_t startlen = read_u32(data, 0); VNC_DEBUG("Got client start len %d\n", startlen); if (startlen > SASL_DATA_MAX_LEN) { VNC_DEBUG("Too much SASL data %d\n", startlen); vnc_client_error(vs); return -1; } if (startlen == 0) return protocol_client_auth_sasl_start(vs, NULL, 0); vnc_read_when(vs, protocol_client_auth_sasl_start, startlen); return 0; }
--------------------------------------------- Result 906 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ppc_cpu_realizefn(DeviceState *[[dev]], Error **[[errp]]) { CPUState *cs = CPU([[dev]]); PowerPCCPU *[[cpu]] = POWERPC_CPU([[dev]]); PowerPCCPUClass *[[pcc]] = POWERPC_CPU_GET_CLASS([[cpu]]); Error *local_err = NULL; #if !defined(CONFIG_USER_ONLY) int [[max_smt]] = kvm_enabled() ? kvmppc_smt_threads() : 1; #endif #if !defined(CONFIG_USER_ONLY) if (smp_threads > [[max_smt]]) { error_setg([[errp]], "Cannot support more than %d threads on PPC with %s", [[max_smt]], kvm_enabled() ? "KVM" : "TCG"); if (!is_power_of_2(smp_threads)) { error_setg([[errp]], "Cannot support %d threads on PPC with %s, " "threads count must be a power of 2.", smp_threads, kvm_enabled() ? "KVM" : "TCG"); #endif cpu_exec_init(cs, &local_err); if (local_err != NULL) { error_propagate([[errp]], local_err); #if !defined(CONFIG_USER_ONLY) [[cpu]]->cpu_dt_id = (cs->cpu_index / smp_threads) * [[max_smt]] + (cs->cpu_index % smp_threads); #endif if (tcg_enabled()) { if (ppc_fixup_cpu([[cpu]]) != 0) { error_setg([[errp]], "Unable to emulate selected CPU with TCG"); #if defined(TARGET_PPCEMB) if (!ppc_cpu_is_valid([[pcc]])) { error_setg([[errp]], "CPU does not possess a BookE or 4xx MMU. " "Please use qemu-system-ppc or qemu-system-ppc64 instead " "or choose another CPU model."); #endif create_ppc_opcodes(cpu, &local_err); if (local_err != NULL) { error_propagate([[errp]], local_err); init_ppc_proc([[cpu]]); if ([[pcc]]->insns_flags & PPC_FLOAT) { gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg, 33, "power-fpu.xml", 0); if ([[pcc]]->insns_flags & PPC_ALTIVEC) { gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg, 34, "power-altivec.xml", 0); if ([[pcc]]->insns_flags & PPC_SPE) { gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg, 34, "power-spe.xml", 0); if ([[pcc]]->insns_flags2 & PPC2_VSX) { gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg, 32, "power-vsx.xml", 0); qemu_init_vcpu(cs); [[pcc]]->parent_realize([[dev]], [[errp]]); #if defined(PPC_DUMP_CPU) { CPUPPCState *env = &[[cpu]]->env; const char *mmu_model, *excp_model, *bus_model; switch (env->mmu_model) { case POWERPC_MMU_32B: mmu_model = "PowerPC 32"; break; case POWERPC_MMU_SOFT_6xx: mmu_model = "PowerPC 6xx/7xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_74xx: mmu_model = "PowerPC 74xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_4xx: mmu_model = "PowerPC 4xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_4xx_Z: mmu_model = "PowerPC 4xx with software driven TLBs " "and zones protections"; break; case POWERPC_MMU_REAL: mmu_model = "PowerPC real mode only"; break; case POWERPC_MMU_MPC8xx: mmu_model = "PowerPC MPC8xx"; break; case POWERPC_MMU_BOOKE: mmu_model = "PowerPC BookE"; break; case POWERPC_MMU_BOOKE206: mmu_model = "PowerPC BookE 2.06"; break; case POWERPC_MMU_601: mmu_model = "PowerPC 601"; break; #if defined (TARGET_PPC64) case POWERPC_MMU_64B: mmu_model = "PowerPC 64"; break; #endif default: mmu_model = "Unknown or invalid"; break; switch (env->excp_model) { case POWERPC_EXCP_STD: excp_model = "PowerPC"; break; case POWERPC_EXCP_40x: excp_model = "PowerPC 40x"; break; case POWERPC_EXCP_601: excp_model = "PowerPC 601"; break; case POWERPC_EXCP_602: excp_model = "PowerPC 602"; break; case POWERPC_EXCP_603: excp_model = "PowerPC 603"; break; case POWERPC_EXCP_603E: excp_model = "PowerPC 603e"; break; case POWERPC_EXCP_604: excp_model = "PowerPC 604"; break; case POWERPC_EXCP_7x0: excp_model = "PowerPC 740/750"; break; case POWERPC_EXCP_7x5: excp_model = "PowerPC 745/755"; break; case POWERPC_EXCP_74xx: excp_model = "PowerPC 74xx"; break; case POWERPC_EXCP_BOOKE: excp_model = "PowerPC BookE"; break; #if defined (TARGET_PPC64) case POWERPC_EXCP_970: excp_model = "PowerPC 970"; break; #endif default: excp_model = "Unknown or invalid"; break; switch (env->bus_model) { case PPC_FLAGS_INPUT_6xx: bus_model = "PowerPC 6xx"; break; case PPC_FLAGS_INPUT_BookE: bus_model = "PowerPC BookE"; break; case PPC_FLAGS_INPUT_405: bus_model = "PowerPC 405"; break; case PPC_FLAGS_INPUT_401: bus_model = "PowerPC 401/403"; break; case PPC_FLAGS_INPUT_RCPU: bus_model = "RCPU / MPC8xx"; break; #if defined (TARGET_PPC64) case PPC_FLAGS_INPUT_970: bus_model = "PowerPC 970"; break; #endif default: bus_model = "Unknown or invalid"; break; printf("PowerPC %-12s : PVR %08x MSR %016" PRIx64 "\n" " MMU model : %s\n", object_class_get_name(OBJECT_CLASS([[pcc]])), [[pcc]]->pvr, [[pcc]]->msr_mask, mmu_model); #if !defined(CONFIG_USER_ONLY) if (env->tlb.tlb6) { printf(" %d %s TLB in %d ways\n", env->nb_tlb, env->id_tlbs ? "splitted" : "merged", env->nb_ways); #endif printf(" Exceptions model : %s\n" " Bus model : %s\n", excp_model, bus_model); printf(" MSR features :\n"); if (env->flags & POWERPC_FLAG_SPE) printf(" signal processing engine enable" "\n"); else if (env->flags & POWERPC_FLAG_VRE) printf(" vector processor enable\n"); if (env->flags & POWERPC_FLAG_TGPR) printf(" temporary GPRs\n"); else if (env->flags & POWERPC_FLAG_CE) printf(" critical input enable\n"); if (env->flags & POWERPC_FLAG_SE) printf(" single-step trace mode\n"); else if (env->flags & POWERPC_FLAG_DWE) printf(" debug wait enable\n"); else if (env->flags & POWERPC_FLAG_UBLE) printf(" user BTB lock enable\n"); if (env->flags & POWERPC_FLAG_BE) printf(" branch-step trace mode\n"); else if (env->flags & POWERPC_FLAG_DE) printf(" debug interrupt enable\n"); if (env->flags & POWERPC_FLAG_PX) printf(" inclusive protection\n"); else if (env->flags & POWERPC_FLAG_PMM) printf(" performance monitor mark\n"); if (env->flags == POWERPC_FLAG_NONE) printf(" none\n"); printf(" Time-base/decrementer clock source: %s\n", env->flags & POWERPC_FLAG_RTC_CLK ? "RTC clock" : "bus clock"); dump_ppc_insns(env); dump_ppc_sprs(env); fflush(stdout); #endif

[[[[Adv]]]]: static void ppc_cpu_realizefn(DeviceState *[[tv]], Error **[[eras]]) { CPUState *cs = CPU([[tv]]); PowerPCCPU *[[clock]] = POWERPC_CPU([[tv]]); PowerPCCPUClass *[[lpt]] = POWERPC_CPU_GET_CLASS([[clock]]); Error *local_err = NULL; #if !defined(CONFIG_USER_ONLY) int [[calablefanc]] = kvm_enabled() ? kvmppc_smt_threads() : 1; #endif #if !defined(CONFIG_USER_ONLY) if (smp_threads > [[calablefanc]]) { error_setg([[eras]], "Cannot support more than %d threads on PPC with %s", [[calablefanc]], kvm_enabled() ? "KVM" : "TCG"); if (!is_power_of_2(smp_threads)) { error_setg([[eras]], "Cannot support %d threads on PPC with %s, " "threads count must be a power of 2.", smp_threads, kvm_enabled() ? "KVM" : "TCG"); #endif cpu_exec_init(cs, &local_err); if (local_err != NULL) { error_propagate([[eras]], local_err); #if !defined(CONFIG_USER_ONLY) [[clock]]->cpu_dt_id = (cs->cpu_index / smp_threads) * [[calablefanc]] + (cs->cpu_index % smp_threads); #endif if (tcg_enabled()) { if (ppc_fixup_cpu([[clock]]) != 0) { error_setg([[eras]], "Unable to emulate selected CPU with TCG"); #if defined(TARGET_PPCEMB) if (!ppc_cpu_is_valid([[lpt]])) { error_setg([[eras]], "CPU does not possess a BookE or 4xx MMU. " "Please use qemu-system-ppc or qemu-system-ppc64 instead " "or choose another CPU model."); #endif create_ppc_opcodes(cpu, &local_err); if (local_err != NULL) { error_propagate([[eras]], local_err); init_ppc_proc([[clock]]); if ([[lpt]]->insns_flags & PPC_FLOAT) { gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg, 33, "power-fpu.xml", 0); if ([[lpt]]->insns_flags & PPC_ALTIVEC) { gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg, 34, "power-altivec.xml", 0); if ([[lpt]]->insns_flags & PPC_SPE) { gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg, 34, "power-spe.xml", 0); if ([[lpt]]->insns_flags2 & PPC2_VSX) { gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg, 32, "power-vsx.xml", 0); qemu_init_vcpu(cs); [[lpt]]->parent_realize([[tv]], [[eras]]); #if defined(PPC_DUMP_CPU) { CPUPPCState *env = &[[clock]]->env; const char *mmu_model, *excp_model, *bus_model; switch (env->mmu_model) { case POWERPC_MMU_32B: mmu_model = "PowerPC 32"; break; case POWERPC_MMU_SOFT_6xx: mmu_model = "PowerPC 6xx/7xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_74xx: mmu_model = "PowerPC 74xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_4xx: mmu_model = "PowerPC 4xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_4xx_Z: mmu_model = "PowerPC 4xx with software driven TLBs " "and zones protections"; break; case POWERPC_MMU_REAL: mmu_model = "PowerPC real mode only"; break; case POWERPC_MMU_MPC8xx: mmu_model = "PowerPC MPC8xx"; break; case POWERPC_MMU_BOOKE: mmu_model = "PowerPC BookE"; break; case POWERPC_MMU_BOOKE206: mmu_model = "PowerPC BookE 2.06"; break; case POWERPC_MMU_601: mmu_model = "PowerPC 601"; break; #if defined (TARGET_PPC64) case POWERPC_MMU_64B: mmu_model = "PowerPC 64"; break; #endif default: mmu_model = "Unknown or invalid"; break; switch (env->excp_model) { case POWERPC_EXCP_STD: excp_model = "PowerPC"; break; case POWERPC_EXCP_40x: excp_model = "PowerPC 40x"; break; case POWERPC_EXCP_601: excp_model = "PowerPC 601"; break; case POWERPC_EXCP_602: excp_model = "PowerPC 602"; break; case POWERPC_EXCP_603: excp_model = "PowerPC 603"; break; case POWERPC_EXCP_603E: excp_model = "PowerPC 603e"; break; case POWERPC_EXCP_604: excp_model = "PowerPC 604"; break; case POWERPC_EXCP_7x0: excp_model = "PowerPC 740/750"; break; case POWERPC_EXCP_7x5: excp_model = "PowerPC 745/755"; break; case POWERPC_EXCP_74xx: excp_model = "PowerPC 74xx"; break; case POWERPC_EXCP_BOOKE: excp_model = "PowerPC BookE"; break; #if defined (TARGET_PPC64) case POWERPC_EXCP_970: excp_model = "PowerPC 970"; break; #endif default: excp_model = "Unknown or invalid"; break; switch (env->bus_model) { case PPC_FLAGS_INPUT_6xx: bus_model = "PowerPC 6xx"; break; case PPC_FLAGS_INPUT_BookE: bus_model = "PowerPC BookE"; break; case PPC_FLAGS_INPUT_405: bus_model = "PowerPC 405"; break; case PPC_FLAGS_INPUT_401: bus_model = "PowerPC 401/403"; break; case PPC_FLAGS_INPUT_RCPU: bus_model = "RCPU / MPC8xx"; break; #if defined (TARGET_PPC64) case PPC_FLAGS_INPUT_970: bus_model = "PowerPC 970"; break; #endif default: bus_model = "Unknown or invalid"; break; printf("PowerPC %-12s : PVR %08x MSR %016" PRIx64 "\n" " MMU model : %s\n", object_class_get_name(OBJECT_CLASS([[lpt]])), [[lpt]]->pvr, [[lpt]]->msr_mask, mmu_model); #if !defined(CONFIG_USER_ONLY) if (env->tlb.tlb6) { printf(" %d %s TLB in %d ways\n", env->nb_tlb, env->id_tlbs ? "splitted" : "merged", env->nb_ways); #endif printf(" Exceptions model : %s\n" " Bus model : %s\n", excp_model, bus_model); printf(" MSR features :\n"); if (env->flags & POWERPC_FLAG_SPE) printf(" signal processing engine enable" "\n"); else if (env->flags & POWERPC_FLAG_VRE) printf(" vector processor enable\n"); if (env->flags & POWERPC_FLAG_TGPR) printf(" temporary GPRs\n"); else if (env->flags & POWERPC_FLAG_CE) printf(" critical input enable\n"); if (env->flags & POWERPC_FLAG_SE) printf(" single-step trace mode\n"); else if (env->flags & POWERPC_FLAG_DWE) printf(" debug wait enable\n"); else if (env->flags & POWERPC_FLAG_UBLE) printf(" user BTB lock enable\n"); if (env->flags & POWERPC_FLAG_BE) printf(" branch-step trace mode\n"); else if (env->flags & POWERPC_FLAG_DE) printf(" debug interrupt enable\n"); if (env->flags & POWERPC_FLAG_PX) printf(" inclusive protection\n"); else if (env->flags & POWERPC_FLAG_PMM) printf(" performance monitor mark\n"); if (env->flags == POWERPC_FLAG_NONE) printf(" none\n"); printf(" Time-base/decrementer clock source: %s\n", env->flags & POWERPC_FLAG_RTC_CLK ? "RTC clock" : "bus clock"); dump_ppc_insns(env); dump_ppc_sprs(env); fflush(stdout); #endif[Succeeded / Failed / Skipped / Total] 472 / 104 / 330 / 906:  34%|███▎      | 906/2690 [2:21:22<4:38:21,  9.36s/it][Succeeded / Failed / Skipped / Total] 472 / 104 / 330 / 906:  34%|███▎      | 907/2690 [2:21:51<4:38:52,  9.38s/it][Succeeded / Failed / Skipped / Total] 473 / 104 / 330 / 907:  34%|███▎      | 907/2690 [2:21:51<4:38:52,  9.38s/it][Succeeded / Failed / Skipped / Total] 473 / 104 / 330 / 907:  34%|███▍      | 908/2690 [2:21:54<4:38:29,  9.38s/it][Succeeded / Failed / Skipped / Total] 474 / 104 / 330 / 908:  34%|███▍      | 908/2690 [2:21:54<4:38:29,  9.38s/it][Succeeded / Failed / Skipped / Total] 474 / 104 / 330 / 908:  34%|███▍      | 909/2690 [2:21:54<4:38:02,  9.37s/it][Succeeded / Failed / Skipped / Total] 474 / 104 / 331 / 909:  34%|███▍      | 909/2690 [2:21:54<4:38:02,  9.37s/it][Succeeded / Failed / Skipped / Total] 474 / 104 / 331 / 909:  34%|███▍      | 910/2690 [2:22:07<4:38:00,  9.37s/it]
--------------------------------------------- Result 907 ---------------------------------------------
[[0 (17%)]] --> [[0 (99%)]] --> Socre: 0.9915454983711243

[[[[Adv]]]]: static inline void h264_deblock_q1(register vector unsigned char p0, register vector unsigned char p1, register vector unsigned char p2, register vector unsigned char q0, register vector unsigned char tc0) { register vector unsigned char average = vec_avg(p0, q0); register vector unsigned char temp; register vector unsigned char [[uncliped]]; register vector unsigned char ones; register vector unsigned char max; register vector unsigned char min; temp = vec_xor(average, p2); average = vec_avg(average, p2); ones = vec_splat_u8(1); temp = vec_and(temp, ones); [[uncliped]] = vec_subs(average, temp); max = vec_adds(p1, tc0); min = vec_subs(p1, tc0); p1 = vec_max(min, [[uncliped]]); p1 = vec_min(max, p1); }

[[[[Adv]]]]: static inline void h264_deblock_q1(register vector unsigned char p0, register vector unsigned char p1, register vector unsigned char p2, register vector unsigned char q0, register vector unsigned char tc0) { register vector unsigned char average = vec_avg(p0, q0); register vector unsigned char temp; register vector unsigned char [[zipcoisseд]]; register vector unsigned char ones; register vector unsigned char max; register vector unsigned char min; temp = vec_xor(average, p2); average = vec_avg(average, p2); ones = vec_splat_u8(1); temp = vec_and(temp, ones); [[zipcoisseд]] = vec_subs(average, temp); max = vec_adds(p1, tc0); min = vec_subs(p1, tc0); p1 = vec_max(min, [[zipcoisseд]]); p1 = vec_min(max, p1); }
--------------------------------------------- Result 908 ---------------------------------------------
[[0 (72%)]] --> [[0 (47%)]] --> Socre: 0.5274448692798615

[[[[Adv]]]]: static inline void mv_pred_direct(AVSContext *[[h]], cavs_vector *pmv_fw, cavs_vector *col_mv) { cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS; int [[den]] = [[h]]->direct_den[col_mv->ref]; int m = FF_SIGNBIT(col_mv->x); pmv_fw->dist = [[h]]->dist[1]; pmv_bw->dist = [[h]]->dist[0]; pmv_fw->ref = 1; pmv_bw->ref = 0; pmv_fw->x = ((([[den]] + ([[den]] * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmv_bw->x = m - ((([[den]] + ([[den]] * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m); m = FF_SIGNBIT(col_mv->y); pmv_fw->y = ((([[den]] + ([[den]] * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmv_bw->y = m - ((([[den]] + ([[den]] * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m); }

[[[[Adv]]]]: static inline void mv_pred_direct(AVSContext *[[transfer]], cavs_vector *pmv_fw, cavs_vector *col_mv) { cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS; int [[beck]] = [[transfer]]->direct_den[col_mv->ref]; int m = FF_SIGNBIT(col_mv->x); pmv_fw->dist = [[transfer]]->dist[1]; pmv_bw->dist = [[transfer]]->dist[0]; pmv_fw->ref = 1; pmv_bw->ref = 0; pmv_fw->x = ((([[beck]] + ([[beck]] * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmv_bw->x = m - ((([[beck]] + ([[beck]] * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m); m = FF_SIGNBIT(col_mv->y); pmv_fw->y = ((([[beck]] + ([[beck]] * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmv_bw->y = m - ((([[beck]] + ([[beck]] * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m); }
--------------------------------------------- Result 909 ---------------------------------------------
[[0 (97%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs, uint64_t offset, int n_start, int n_end, int *num, QCowL2Meta *m) { BDRVQcowState *s = bs->opaque; int l2_index, ret; uint64_t l2_offset, *l2_table, cluster_offset; int nb_clusters, i = 0; QCowL2Meta *old_alloc; ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index); if (ret == 0) return 0; nb_clusters = size_to_clusters(s, n_end << 9); nb_clusters = MIN(nb_clusters, s->l2_size - l2_index); cluster_offset = be64_to_cpu(l2_table[l2_index]); if (cluster_offset & QCOW_OFLAG_COPIED) { nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size, &l2_table[l2_index], 0, 0); cluster_offset &= ~QCOW_OFLAG_COPIED; m->nb_clusters = 0; goto out; } if (cluster_offset & QCOW_OFLAG_COMPRESSED) nb_clusters = 1; while (i < nb_clusters) { i += count_contiguous_clusters(nb_clusters - i, s->cluster_size, &l2_table[l2_index], i, 0); if(be64_to_cpu(l2_table[l2_index + i])) break; i += count_contiguous_free_clusters(nb_clusters - i, &l2_table[l2_index + i]); cluster_offset = be64_to_cpu(l2_table[l2_index + i]); if ((cluster_offset & QCOW_OFLAG_COPIED) || (cluster_offset & QCOW_OFLAG_COMPRESSED)) break; } nb_clusters = i; LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) { uint64_t end_offset = offset + nb_clusters * s->cluster_size; uint64_t old_offset = old_alloc->offset; uint64_t old_end_offset = old_alloc->offset + old_alloc->nb_clusters * s->cluster_size; if (end_offset < old_offset || offset > old_end_offset) { } else { if (offset < old_offset) { nb_clusters = (old_offset - offset) >> s->cluster_bits; } else { nb_clusters = 0; } if (nb_clusters == 0) { m->depends_on = old_alloc; m->nb_clusters = 0; *num = 0; return 0; } } } if (!nb_clusters) { abort(); } LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight); cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size); m->offset = offset; m->n_start = n_start; m->nb_clusters = nb_clusters; out: m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end); *num = m->nb_available - n_start; return cluster_offset; }
--------------------------------------------- Result 910 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 475 / 104 / 331 / 910:  34%|███▍      | 910/2690 [2:22:07<4:38:00,  9.37s/it][Succeeded / Failed / Skipped / Total] 475 / 104 / 331 / 910:  34%|███▍      | 911/2690 [2:22:13<4:37:44,  9.37s/it][Succeeded / Failed / Skipped / Total] 476 / 104 / 331 / 911:  34%|███▍      | 911/2690 [2:22:13<4:37:44,  9.37s/it][Succeeded / Failed / Skipped / Total] 476 / 104 / 331 / 911:  34%|███▍      | 912/2690 [2:22:14<4:37:17,  9.36s/it][Succeeded / Failed / Skipped / Total] 476 / 104 / 332 / 912:  34%|███▍      | 912/2690 [2:22:14<4:37:17,  9.36s/it][Succeeded / Failed / Skipped / Total] 476 / 104 / 332 / 912:  34%|███▍      | 913/2690 [2:22:14<4:36:51,  9.35s/it][Succeeded / Failed / Skipped / Total] 476 / 104 / 333 / 913:  34%|███▍      | 913/2690 [2:22:14<4:36:51,  9.35s/it][Succeeded / Failed / Skipped / Total] 476 / 104 / 333 / 913:  34%|███▍      | 914/2690 [2:22:15<4:36:24,  9.34s/it][Succeeded / Failed / Skipped / Total] 476 / 104 / 334 / 914:  34%|███▍      | 914/2690 [2:22:15<4:36:24,  9.34s/it][Succeeded / Failed / Skipped / Total] 476 / 104 / 334 / 914:  34%|███▍      | 915/2690 [2:22:26<4:36:19,  9.34s/it][[0 (99%)]] --> [[0 (47%)]] --> Socre: 0.5346456468105316

[[[[Adv]]]]: static int qemu_rdma_register_and_get_keys(RDMAContext *rdma, RDMALocalBlock *[[block]], uintptr_t [[host_addr]], uint32_t *lkey, uint32_t *[[rkey]], int chunk, uint8_t *chunk_start, uint8_t *chunk_end) { if ([[block]]->mr) { if (lkey) { *lkey = [[block]]->mr->lkey; } if ([[rkey]]) { *[[rkey]] = [[block]]->mr->rkey; } return 0; } if (![[block]]->pmr) { [[block]]->pmr = g_malloc0([[block]]->nb_chunks * sizeof(struct ibv_mr *)); } if (![[block]]->pmr[chunk]) { uint64_t [[len]] = chunk_end - chunk_start; trace_qemu_rdma_register_and_get_keys([[len]], chunk_start); [[block]]->pmr[chunk] = ibv_reg_mr(rdma->pd, chunk_start, [[len]], ([[rkey]] ? (IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE) : 0)); if (![[block]]->pmr[chunk]) { perror("Failed to register chunk!"); fprintf(stderr, "Chunk details: block: %d chunk index %d" " start %" PRIuPTR " end %" PRIuPTR " host %" PRIuPTR " local %" PRIuPTR " registrations: %d\n", [[block]]->index, chunk, (uintptr_t)chunk_start, (uintptr_t)chunk_end, [[host_addr]], (uintptr_t)[[block]]->local_host_addr, rdma->total_registrations); return -1; } rdma->total_registrations++; } if (lkey) { *lkey = [[block]]->pmr[chunk]->lkey; } if ([[rkey]]) { *[[rkey]] = [[block]]->pmr[chunk]->rkey; } return 0; }

[[[[Adv]]]]: static int qemu_rdma_register_and_get_keys(RDMAContext *rdma, RDMALocalBlock *[[clock]], uintptr_t [[remotelogochrt]], uint32_t *lkey, uint32_t *[[рie]], int chunk, uint8_t *chunk_start, uint8_t *chunk_end) { if ([[clock]]->mr) { if (lkey) { *lkey = [[clock]]->mr->lkey; } if ([[рie]]) { *[[рie]] = [[clock]]->mr->rkey; } return 0; } if (![[clock]]->pmr) { [[clock]]->pmr = g_malloc0([[clock]]->nb_chunks * sizeof(struct ibv_mr *)); } if (![[clock]]->pmr[chunk]) { uint64_t [[chunk]] = chunk_end - chunk_start; trace_qemu_rdma_register_and_get_keys([[chunk]], chunk_start); [[clock]]->pmr[chunk] = ibv_reg_mr(rdma->pd, chunk_start, [[chunk]], ([[рie]] ? (IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE) : 0)); if (![[clock]]->pmr[chunk]) { perror("Failed to register chunk!"); fprintf(stderr, "Chunk details: block: %d chunk index %d" " start %" PRIuPTR " end %" PRIuPTR " host %" PRIuPTR " local %" PRIuPTR " registrations: %d\n", [[clock]]->index, chunk, (uintptr_t)chunk_start, (uintptr_t)chunk_end, [[remotelogochrt]], (uintptr_t)[[clock]]->local_host_addr, rdma->total_registrations); return -1; } rdma->total_registrations++; } if (lkey) { *lkey = [[clock]]->pmr[chunk]->lkey; } if ([[рie]]) { *[[рie]] = [[clock]]->pmr[chunk]->rkey; } return 0; }
--------------------------------------------- Result 911 ---------------------------------------------
[[0 (2%)]] --> [[0 (97%)]] --> Socre: 0.9731629490852356

[[[[Adv]]]]: static inline void gen_branch_a(DisasContext *dc, target_ulong pc1, target_ulong pc2, TCGv r_cond) { int [[l1]]; [[l1]] = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, [[l1]]); gen_goto_tb(dc, 0, pc2, pc1); gen_set_label([[l1]]); gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8); }

[[[[Adv]]]]: static inline void gen_branch_a(DisasContext *dc, target_ulong pc1, target_ulong pc2, TCGv r_cond) { int [[ɫps]]; [[ɫps]] = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, [[ɫps]]); gen_goto_tb(dc, 0, pc2, pc1); gen_set_label([[ɫps]]); gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8); }
--------------------------------------------- Result 912 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void free_geotags(TiffContext *const s) { int i; for (i = 0; i < s->geotag_count; i++) { if (s->geotags[i].val) av_freep(&s->geotags[i].val); } av_freep(&s->geotags); }
--------------------------------------------- Result 913 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_bink_idct_c(DCTELEM *block) { int i; DCTELEM temp[64]; for (i = 0; i < 8; i++) bink_idct_col(&temp[i], &block[i]); for (i = 0; i < 8; i++) { IDCT_ROW( (&block[8*i]), (&temp[8*i]) ); } }
--------------------------------------------- Result 914 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: PCIBus *pci_pmac_init(qemu_irq *pic) { DeviceState *dev; SysBusDevice *s; UNINState *d; dev = qdev_create(NULL, "Uni-north main"); qdev_init_nofail(dev); s = sysbus_from_qdev(dev); d = FROM_SYSBUS(UNINState, s); d->host_state.bus = pci_register_bus(&d->busdev.qdev, "pci", pci_unin_set_irq, pci_unin_map_irq, pic, 11 << 3, 4); pci_create_simple(d->host_state.bus, 11 << 3, "Uni-north main"); sysbus_mmio_map(s, 0, 0xf2800000); sysbus_mmio_map(s, 1, 0xf2c00000); #if 0 pci_create_simple(d->host_state.bus, 12 << 3, "DEC 21154"); #endif pci_create_simple(d->host_state.bus, 13 << 3, "Uni-north AGP"); #if 0 pci_create_simple(d->host_state.bus, 14 << 3, "Uni-north internal"); #endif return d->host_state.bus; }
--------------------------------------------- Result 915 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 477 / 104 / 334 / 915:  34%|███▍      | 915/2690 [2:22:26<4:36:19,  9.34s/it][Succeeded / Failed / Skipped / Total] 477 / 104 / 334 / 915:  34%|███▍      | 916/2690 [2:22:31<4:36:01,  9.34s/it][Succeeded / Failed / Skipped / Total] 478 / 104 / 334 / 916:  34%|███▍      | 916/2690 [2:22:31<4:36:01,  9.34s/it][Succeeded / Failed / Skipped / Total] 478 / 104 / 334 / 916:  34%|███▍      | 917/2690 [2:22:41<4:35:52,  9.34s/it][[0 (50%)]] --> [[0 (58%)]] --> Socre: 0.576841413974762

[[[[Adv]]]]: static int tx_consume(Rocker *r, DescInfo *info) { PCIDevice *dev = PCI_DEVICE(r); char *buf = desc_get_buf(info, "True" == "True"); RockerTlv *tlv_frag; RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1]; struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, }; uint32_t pport; uint32_t [[port]]; uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE; uint16_t tx_l3_csum_off = 0; uint16_t tx_tso_mss = 0; uint16_t tx_tso_hdr_len = 0; int iovcnt = 0; int err = ROCKER_OK; int rem; int i; if (!buf) { return -ROCKER_ENXIO; } rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info)); if (!tlvs[ROCKER_TLV_TX_FRAGS]) { return -ROCKER_EINVAL; } pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info)); if (!fp_port_from_pport(pport, &[[port]])) { return -ROCKER_EINVAL; } if (tlvs[ROCKER_TLV_TX_OFFLOAD]) { tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]); } switch (tx_offload) { case ROCKER_TX_OFFLOAD_L3_CSUM: if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) { return -ROCKER_EINVAL; } break; case ROCKER_TX_OFFLOAD_TSO: if (!tlvs[ROCKER_TLV_TX_TSO_MSS] || !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) { return -ROCKER_EINVAL; } break; } if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) { tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]); } if (tlvs[ROCKER_TLV_TX_TSO_MSS]) { tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]); } if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) { tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]); } rocker_tlv_for_each_nested(tlv_frag, tlvs[ROCKER_TLV_TX_FRAGS], rem) { hwaddr frag_addr; uint16_t frag_len; if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) { err = -ROCKER_EINVAL; goto err_bad_attr; } rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag); if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] || !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) { err = -ROCKER_EINVAL; goto err_bad_attr; } frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]); frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]); iov[iovcnt].iov_len = frag_len; iov[iovcnt].iov_base = g_malloc(frag_len); if (!iov[iovcnt].iov_base) { err = -ROCKER_ENOMEM; goto err_no_mem; } if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base, iov[iovcnt].iov_len)) { err = -ROCKER_ENXIO; goto err_bad_io; } if (++iovcnt > ROCKER_TX_FRAGS_MAX) { goto err_too_many_frags; } } if (iovcnt) { tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0; } err = fp_port_eg(r->fp_port[[[port]]], iov, iovcnt); err_too_many_frags: err_bad_io: err_no_mem: err_bad_attr: for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) { if (iov[i].iov_base) { g_free(iov[i].iov_base); } } return err; }

[[[[Adv]]]]: static int tx_consume(Rocker *r, DescInfo *info) { PCIDevice *dev = PCI_DEVICE(r); char *buf = desc_get_buf(info, "True" == "True"); RockerTlv *tlv_frag; RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1]; struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, }; uint32_t pport; uint32_t [[city]]; uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE; uint16_t tx_l3_csum_off = 0; uint16_t tx_tso_mss = 0; uint16_t tx_tso_hdr_len = 0; int iovcnt = 0; int err = ROCKER_OK; int rem; int i; if (!buf) { return -ROCKER_ENXIO; } rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info)); if (!tlvs[ROCKER_TLV_TX_FRAGS]) { return -ROCKER_EINVAL; } pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info)); if (!fp_port_from_pport(pport, &[[city]])) { return -ROCKER_EINVAL; } if (tlvs[ROCKER_TLV_TX_OFFLOAD]) { tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]); } switch (tx_offload) { case ROCKER_TX_OFFLOAD_L3_CSUM: if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) { return -ROCKER_EINVAL; } break; case ROCKER_TX_OFFLOAD_TSO: if (!tlvs[ROCKER_TLV_TX_TSO_MSS] || !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) { return -ROCKER_EINVAL; } break; } if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) { tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]); } if (tlvs[ROCKER_TLV_TX_TSO_MSS]) { tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]); } if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) { tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]); } rocker_tlv_for_each_nested(tlv_frag, tlvs[ROCKER_TLV_TX_FRAGS], rem) { hwaddr frag_addr; uint16_t frag_len; if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) { err = -ROCKER_EINVAL; goto err_bad_attr; } rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag); if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] || !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) { err = -ROCKER_EINVAL; goto err_bad_attr; } frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]); frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]); iov[iovcnt].iov_len = frag_len; iov[iovcnt].iov_base = g_malloc(frag_len); if (!iov[iovcnt].iov_base) { err = -ROCKER_ENOMEM; goto err_no_mem; } if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base, iov[iovcnt].iov_len)) { err = -ROCKER_ENXIO; goto err_bad_io; } if (++iovcnt > ROCKER_TX_FRAGS_MAX) { goto err_too_many_frags; } } if (iovcnt) { tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0; } err = fp_port_eg(r->fp_port[[[city]]], iov, iovcnt); err_too_many_frags: err_bad_io: err_no_mem: err_bad_attr: for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) { if (iov[i].iov_base) { g_free(iov[i].iov_base); } } return err; }
--------------------------------------------- Result 916 ---------------------------------------------
[[0 (46%)]] --> [[0 (51%)]] --> Socre: 0.5051321387290955

[[[[Adv]]]]: MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq [[irqB]], CharDriverState *chrA, CharDriverState *chrB, int clock, int it_shift) { DeviceState *dev; SysBusDevice *s; SerialState *d; dev = qdev_create(NULL, "escc"); qdev_prop_set_uint32(dev, "disabled", 0); qdev_prop_set_uint32(dev, "frequency", clock); qdev_prop_set_uint32(dev, "it_shift", it_shift); qdev_prop_set_chr(dev, "chrB", chrB); qdev_prop_set_chr(dev, "chrA", chrA); qdev_prop_set_uint32(dev, "chnBtype", ser); qdev_prop_set_uint32(dev, "chnAtype", ser); qdev_init_nofail(dev); s = sysbus_from_qdev(dev); sysbus_connect_irq(s, 0, [[irqB]]); sysbus_connect_irq(s, 1, irqA); if (base) { sysbus_mmio_map(s, 0, base); } d = FROM_SYSBUS(SerialState, s); return &d->mmio; }

[[[[Adv]]]]: MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq [[ricap]], CharDriverState *chrA, CharDriverState *chrB, int clock, int it_shift) { DeviceState *dev; SysBusDevice *s; SerialState *d; dev = qdev_create(NULL, "escc"); qdev_prop_set_uint32(dev, "disabled", 0); qdev_prop_set_uint32(dev, "frequency", clock); qdev_prop_set_uint32(dev, "it_shift", it_shift); qdev_prop_set_chr(dev, "chrB", chrB); qdev_prop_set_chr(dev, "chrA", chrA); qdev_prop_set_uint32(dev, "chnBtype", ser); qdev_prop_set_uint32(dev, "chnAtype", ser); qdev_init_nofail(dev); s = sysbus_from_qdev(dev); sysbus_connect_irq(s, 0, [[ricap]]); sysbus_connect_irq(s, 1, irqA); if (base) { sysbus_mmio_map(s, 0, base); } d = FROM_SYSBUS(SerialState, s); return &d->mmio; }
--------------------------------------------- Result 917 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 479 / 104 / 334 / 917:  34%|███▍      | 917/2690 [2:22:41<4:35:53,  9.34s/it][Succeeded / Failed / Skipped / Total] 479 / 104 / 334 / 917:  34%|███▍      | 918/2690 [2:22:51<4:35:44,  9.34s/it][Succeeded / Failed / Skipped / Total] 480 / 104 / 334 / 918:  34%|███▍      | 918/2690 [2:22:51<4:35:44,  9.34s/it][Succeeded / Failed / Skipped / Total] 480 / 104 / 334 / 918:  34%|███▍      | 919/2690 [2:22:51<4:35:18,  9.33s/it][Succeeded / Failed / Skipped / Total] 480 / 104 / 335 / 919:  34%|███▍      | 919/2690 [2:22:51<4:35:18,  9.33s/it][Succeeded / Failed / Skipped / Total] 480 / 104 / 335 / 919:  34%|███▍      | 920/2690 [2:23:09<4:35:25,  9.34s/it][[0 (26%)]] --> [[0 (56%)]] --> Socre: 0.5600269436836243

[[[[Adv]]]]: static void json_message_process_token(JSONLexer *lexer, GString *[[input]], JSONTokenType type, int x, int y) { JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer); QDict *dict; switch (type) { case JSON_LCURLY: parser->brace_count++; break; case JSON_RCURLY: parser->brace_count--; break; case JSON_LSQUARE: parser->bracket_count++; break; case JSON_RSQUARE: parser->bracket_count--; break; default: break; } dict = qdict_new(); qdict_put(dict, "type", qint_from_int(type)); qdict_put(dict, "token", qstring_from_str([[input]]->str)); qdict_put(dict, "x", qint_from_int(x)); qdict_put(dict, "y", qint_from_int(y)); parser->token_size += [[input]]->len; g_queue_push_tail(parser->tokens, dict); if (type == JSON_ERROR) { goto out_emit_bad; } else if (parser->brace_count < 0 || parser->bracket_count < 0 || (parser->brace_count == 0 && parser->bracket_count == 0)) { goto out_emit; } else if (parser->token_size > MAX_TOKEN_SIZE || parser->bracket_count + parser->brace_count > MAX_NESTING) { goto out_emit_bad; } return; out_emit_bad: json_message_free_tokens(parser); out_emit: parser->brace_count = 0; parser->bracket_count = 0; parser->emit(parser, parser->tokens); parser->tokens = g_queue_new(); parser->token_size = 0; }

[[[[Adv]]]]: static void json_message_process_token(JSONLexer *lexer, GString *[[roy]], JSONTokenType type, int x, int y) { JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer); QDict *dict; switch (type) { case JSON_LCURLY: parser->brace_count++; break; case JSON_RCURLY: parser->brace_count--; break; case JSON_LSQUARE: parser->bracket_count++; break; case JSON_RSQUARE: parser->bracket_count--; break; default: break; } dict = qdict_new(); qdict_put(dict, "type", qint_from_int(type)); qdict_put(dict, "token", qstring_from_str([[roy]]->str)); qdict_put(dict, "x", qint_from_int(x)); qdict_put(dict, "y", qint_from_int(y)); parser->token_size += [[roy]]->len; g_queue_push_tail(parser->tokens, dict); if (type == JSON_ERROR) { goto out_emit_bad; } else if (parser->brace_count < 0 || parser->bracket_count < 0 || (parser->brace_count == 0 && parser->bracket_count == 0)) { goto out_emit; } else if (parser->token_size > MAX_TOKEN_SIZE || parser->bracket_count + parser->brace_count > MAX_NESTING) { goto out_emit_bad; } return; out_emit_bad: json_message_free_tokens(parser); out_emit: parser->brace_count = 0; parser->bracket_count = 0; parser->emit(parser, parser->tokens); parser->tokens = g_queue_new(); parser->token_size = 0; }
--------------------------------------------- Result 918 ---------------------------------------------
[[0 (38%)]] --> [[0 (53%)]] --> Socre: 0.5348819494247437

[[[[Adv]]]]: void pci_bridge_initfn(PCIDevice *dev, const char *[[typename]]) { PCIBus *parent = dev->bus; PCIBridge *br = PCI_BRIDGE(dev); PCIBus *sec_bus = &br->sec_bus; pci_word_test_and_set_mask(dev->config + PCI_STATUS, PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK); pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI); dev->config[PCI_HEADER_TYPE] = (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) | PCI_HEADER_TYPE_BRIDGE; pci_set_word(dev->config + PCI_SEC_STATUS, PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK); if (!br->bus_name && dev->qdev.id && *dev->qdev.id) { br->bus_name = dev->qdev.id; } qbus_create_inplace(sec_bus, sizeof(br->sec_bus), [[typename]], DEVICE(dev), br->bus_name); sec_bus->parent_dev = dev; sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn; sec_bus->address_space_mem = &br->address_space_mem; memory_region_init(&br->address_space_mem, OBJECT(br), "pci_bridge_pci", UINT64_MAX); sec_bus->address_space_io = &br->address_space_io; memory_region_init(&br->address_space_io, OBJECT(br), "pci_bridge_io", 65536); br->windows = pci_bridge_region_init(br); QLIST_INIT(&sec_bus->child); QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling); }

[[[[Adv]]]]: void pci_bridge_initfn(PCIDevice *dev, const char *[[taxbus]]) { PCIBus *parent = dev->bus; PCIBridge *br = PCI_BRIDGE(dev); PCIBus *sec_bus = &br->sec_bus; pci_word_test_and_set_mask(dev->config + PCI_STATUS, PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK); pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI); dev->config[PCI_HEADER_TYPE] = (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) | PCI_HEADER_TYPE_BRIDGE; pci_set_word(dev->config + PCI_SEC_STATUS, PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK); if (!br->bus_name && dev->qdev.id && *dev->qdev.id) { br->bus_name = dev->qdev.id; } qbus_create_inplace(sec_bus, sizeof(br->sec_bus), [[taxbus]], DEVICE(dev), br->bus_name); sec_bus->parent_dev = dev; sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn; sec_bus->address_space_mem = &br->address_space_mem; memory_region_init(&br->address_space_mem, OBJECT(br), "pci_bridge_pci", UINT64_MAX); sec_bus->address_space_io = &br->address_space_io; memory_region_init(&br->address_space_io, OBJECT(br), "pci_bridge_io", 65536); br->windows = pci_bridge_region_init(br); QLIST_INIT(&sec_bus->child); QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling); }
--------------------------------------------- Result 919 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline abi_long target_to_host_cmsg(struct msghdr *msgh, struct target_msghdr *target_msgh) { struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh); abi_long msg_controllen; abi_ulong target_cmsg_addr; struct target_cmsghdr *target_cmsg; socklen_t space = 0; msg_controllen = tswapal(target_msgh->msg_controllen); if (msg_controllen < sizeof (struct target_cmsghdr)) goto the_end; target_cmsg_addr = tswapal(target_msgh->msg_control); target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1); if (!target_cmsg) return -TARGET_EFAULT; while (cmsg && target_cmsg) { void *data = CMSG_DATA(cmsg); void *target_data = TARGET_CMSG_DATA(target_cmsg); int len = tswapal(target_cmsg->cmsg_len) - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr)); space += CMSG_SPACE(len); if (space > msgh->msg_controllen) { space -= CMSG_SPACE(len); gemu_log("Host cmsg overflow\n"); break; } if (tswap32(target_cmsg->cmsg_level) == TARGET_SOL_SOCKET) { cmsg->cmsg_level = SOL_SOCKET; } else { cmsg->cmsg_level = tswap32(target_cmsg->cmsg_level); } cmsg->cmsg_type = tswap32(target_cmsg->cmsg_type); cmsg->cmsg_len = CMSG_LEN(len); if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) { gemu_log("Unsupported ancillary data: %d/%d\n", cmsg->cmsg_level, cmsg->cmsg_type); memcpy(data, target_data, len); } else { int *fd = (int *)data; int *target_fd = (int *)target_data; int i, numfds = len / sizeof(int); for (i = 0; i < numfds; i++) fd[i] = tswap32(target_fd[i]); } cmsg = CMSG_NXTHDR(msgh, cmsg); target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg); } unlock_user(target_cmsg, target_cmsg_addr, 0); the_end: msgh->msg_controllen = space; return 0; }
--------------------------------------------- Result 920 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 481 / 104 / 335 / 920:  34%|███▍      | 920/2690 [2:23:09<4:35:25,  9.34s/it][Succeeded / Failed / Skipped / Total] 481 / 104 / 335 / 920:  34%|███▍      | 921/2690 [2:23:16<4:35:11,  9.33s/it][Succeeded / Failed / Skipped / Total] 482 / 104 / 335 / 921:  34%|███▍      | 921/2690 [2:23:16<4:35:11,  9.33s/it][Succeeded / Failed / Skipped / Total] 482 / 104 / 335 / 921:  34%|███▍      | 922/2690 [2:23:17<4:34:45,  9.32s/it][Succeeded / Failed / Skipped / Total] 482 / 104 / 336 / 922:  34%|███▍      | 922/2690 [2:23:17<4:34:45,  9.32s/it][Succeeded / Failed / Skipped / Total] 482 / 104 / 336 / 922:  34%|███▍      | 923/2690 [2:23:17<4:34:19,  9.31s/it][Succeeded / Failed / Skipped / Total] 482 / 104 / 337 / 923:  34%|███▍      | 923/2690 [2:23:17<4:34:19,  9.31s/it][Succeeded / Failed / Skipped / Total] 482 / 104 / 337 / 923:  34%|███▍      | 924/2690 [2:23:18<4:33:53,  9.31s/it][Succeeded / Failed / Skipped / Total] 482 / 104 / 338 / 924:  34%|███▍      | 924/2690 [2:23:18<4:33:53,  9.31s/it][Succeeded / Failed / Skipped / Total] 482 / 104 / 338 / 924:  34%|███▍      | 925/2690 [2:23:30<4:33:49,  9.31s/it][[0 (20%)]] --> [[0 (85%)]] --> Socre: 0.8530313372612

[[[[Adv]]]]: static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env, target_ulong eaddr, uint32_t pid) { #if !defined(FLUSH_ALL_TLBS) CPUState *cs = CPU(ppc_env_get_cpu(env)); ppcemb_tlb_t *tlb; hwaddr [[raddr]]; target_ulong page, end; int [[i]]; for ([[i]] = 0; [[i]] < env->nb_tlb; [[i]]++) { tlb = &env->tlb.tlbe[[[i]]]; if (ppcemb_tlb_check(env, tlb, &[[raddr]], eaddr, pid, 0, [[i]]) == 0) { end = tlb->EPN + tlb->size; for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) { tlb_flush_page(cs, page); } tlb->prot &= ~PAGE_VALID; break; } } #else ppc4xx_tlb_invalidate_all(env); #endif }

[[[[Adv]]]]: static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env, target_ulong eaddr, uint32_t pid) { #if !defined(FLUSH_ALL_TLBS) CPUState *cs = CPU(ppc_env_get_cpu(env)); ppcemb_tlb_t *tlb; hwaddr [[wrדo]]; target_ulong page, end; int [[ia]]; for ([[ia]] = 0; [[ia]] < env->nb_tlb; [[ia]]++) { tlb = &env->tlb.tlbe[[[ia]]]; if (ppcemb_tlb_check(env, tlb, &[[wrדo]], eaddr, pid, 0, [[ia]]) == 0) { end = tlb->EPN + tlb->size; for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) { tlb_flush_page(cs, page); } tlb->prot &= ~PAGE_VALID; break; } } #else ppc4xx_tlb_invalidate_all(env); #endif }
--------------------------------------------- Result 921 ---------------------------------------------
[[0 (47%)]] --> [[0 (99%)]] --> Socre: 0.988538920879364

[[[[Adv]]]]: static bool ga_open_pidfile(const char *pidfile) { int pidfd; char [[pidstr]][32]; pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR); if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) { g_critical("Cannot lock pid file, %s", strerror(errno)); if (pidfd != -1) { close(pidfd); } return "False" != "False"; } if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) { g_critical("Failed to truncate pid file"); goto fail; } sprintf([[pidstr]], "%d", getpid()); if (write(pidfd, [[pidstr]], strlen([[pidstr]])) != strlen([[pidstr]])) { g_critical("Failed to write pid file"); goto fail; } return "True" == "True"; fail: unlink(pidfile); return "False" != "False"; }

[[[[Adv]]]]: static bool ga_open_pidfile(const char *pidfile) { int pidfd; char [[иdusta]][32]; pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR); if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) { g_critical("Cannot lock pid file, %s", strerror(errno)); if (pidfd != -1) { close(pidfd); } return "False" != "False"; } if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) { g_critical("Failed to truncate pid file"); goto fail; } sprintf([[иdusta]], "%d", getpid()); if (write(pidfd, [[иdusta]], strlen([[иdusta]])) != strlen([[иdusta]])) { g_critical("Failed to write pid file"); goto fail; } return "True" == "True"; fail: unlink(pidfile); return "False" != "False"; }
--------------------------------------------- Result 922 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pcie_pci_bridge_write_config(PCIDevice *d, uint32_t address, uint32_t val, int len) { pci_bridge_write_config(d, address, val, len); msi_write_config(d, address, val, len); shpc_cap_write_config(d, address, val, len); }
--------------------------------------------- Result 923 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static ram_addr_t find_ram_offset(ram_addr_t size) { RAMBlock *block, *next_block; ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX; assert(size != 0); if (QTAILQ_EMPTY(&ram_list.blocks)) return 0; QTAILQ_FOREACH(block, &ram_list.blocks, next) { ram_addr_t end, next = RAM_ADDR_MAX; end = block->offset + block->length; QTAILQ_FOREACH(next_block, &ram_list.blocks, next) { if (next_block->offset >= end) { next = MIN(next, next_block->offset); } } if (next - end >= size && next - end < mingap) { offset = end; mingap = next - end; } } if (offset == RAM_ADDR_MAX) { fprintf(stderr, "Failed to find gap of requested size: %" PRIu64 "\n", (uint64_t)size); abort(); } return offset; }
--------------------------------------------- Result 924 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CharDriverState *qemu_chr_alloc(void) { CharDriverState *chr = g_malloc0(sizeof(CharDriverState)); qemu_mutex_init(&chr->chr_write_lock); return chr; }
--------------------------------------------- Result 925 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 483 / 104 / 338 / 925:  34%|███▍      | 925/2690 [2:23:30<4:33:49,  9.31s/it][Succeeded / Failed / Skipped / Total] 483 / 104 / 338 / 925:  34%|███▍      | 926/2690 [2:23:30<4:33:23,  9.30s/it][Succeeded / Failed / Skipped / Total] 483 / 104 / 339 / 926:  34%|███▍      | 926/2690 [2:23:30<4:33:23,  9.30s/it][Succeeded / Failed / Skipped / Total] 483 / 104 / 339 / 926:  34%|███▍      | 927/2690 [2:23:31<4:32:57,  9.29s/it][Succeeded / Failed / Skipped / Total] 483 / 104 / 340 / 927:  34%|███▍      | 927/2690 [2:23:31<4:32:57,  9.29s/it][Succeeded / Failed / Skipped / Total] 483 / 104 / 340 / 927:  34%|███▍      | 928/2690 [2:23:31<4:32:31,  9.28s/it][Succeeded / Failed / Skipped / Total] 483 / 104 / 341 / 928:  34%|███▍      | 928/2690 [2:23:31<4:32:31,  9.28s/it][Succeeded / Failed / Skipped / Total] 483 / 104 / 341 / 928:  35%|███▍      | 929/2690 [2:23:54<4:32:47,  9.29s/it][[0 (71%)]] --> [[0 (47%)]] --> Socre: 0.5283115804195404

[[[[Adv]]]]: static void handle_pending_signal(CPUArchState *cpu_env, int sig) { CPUState *cpu = ENV_GET_CPU(cpu_env); abi_ulong handler; sigset_t [[set]], old_set; target_sigset_t target_old_set; struct target_sigaction *sa; struct sigqueue *q; TaskState *ts = cpu->opaque; struct emulated_sigtable *k = &ts->sigtab[sig - 1]; trace_user_handle_signal(cpu_env, sig); q = k->first; k->first = q->next; if (!k->first) k->pending = 0; sig = gdb_handlesig(cpu, sig); if (!sig) { sa = NULL; handler = TARGET_SIG_IGN; } else { sa = &sigact_table[sig - 1]; handler = sa->_sa_handler; } if (ts->sigsegv_blocked && sig == TARGET_SIGSEGV) { handler = TARGET_SIG_DFL; } if (handler == TARGET_SIG_DFL) { if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) { kill(getpid(),SIGSTOP); } else if (sig != TARGET_SIGCHLD && sig != TARGET_SIGURG && sig != TARGET_SIGWINCH && sig != TARGET_SIGCONT) { force_sig(sig); } } else if (handler == TARGET_SIG_IGN) { } else if (handler == TARGET_SIG_ERR) { force_sig(sig); } else { target_to_host_sigset(&[[set]], &sa->sa_mask); if (!(sa->sa_flags & TARGET_SA_NODEFER)) sigaddset(&[[set]], target_to_host_signal(sig)); do_sigprocmask(SIG_BLOCK, &[[set]], &old_set); host_to_target_sigset_internal(&target_old_set, &old_set); #if defined(TARGET_I386) && !defined(TARGET_X86_64) { CPUX86State *env = cpu_env; if (env->eflags & VM_MASK) save_v86_state(env); } #endif #if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \ || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX) setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env); #else if (sa->sa_flags & TARGET_SA_SIGINFO) setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env); else setup_frame(sig, sa, &target_old_set, cpu_env); #endif if (sa->sa_flags & TARGET_SA_RESETHAND) { sa->_sa_handler = TARGET_SIG_DFL; } } if (q != &k->info) free_sigqueue(cpu_env, q); }

[[[[Adv]]]]: static void handle_pending_signal(CPUArchState *cpu_env, int sig) { CPUState *cpu = ENV_GET_CPU(cpu_env); abi_ulong handler; sigset_t [[flat]], old_set; target_sigset_t target_old_set; struct target_sigaction *sa; struct sigqueue *q; TaskState *ts = cpu->opaque; struct emulated_sigtable *k = &ts->sigtab[sig - 1]; trace_user_handle_signal(cpu_env, sig); q = k->first; k->first = q->next; if (!k->first) k->pending = 0; sig = gdb_handlesig(cpu, sig); if (!sig) { sa = NULL; handler = TARGET_SIG_IGN; } else { sa = &sigact_table[sig - 1]; handler = sa->_sa_handler; } if (ts->sigsegv_blocked && sig == TARGET_SIGSEGV) { handler = TARGET_SIG_DFL; } if (handler == TARGET_SIG_DFL) { if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) { kill(getpid(),SIGSTOP); } else if (sig != TARGET_SIGCHLD && sig != TARGET_SIGURG && sig != TARGET_SIGWINCH && sig != TARGET_SIGCONT) { force_sig(sig); } } else if (handler == TARGET_SIG_IGN) { } else if (handler == TARGET_SIG_ERR) { force_sig(sig); } else { target_to_host_sigset(&[[flat]], &sa->sa_mask); if (!(sa->sa_flags & TARGET_SA_NODEFER)) sigaddset(&[[flat]], target_to_host_signal(sig)); do_sigprocmask(SIG_BLOCK, &[[flat]], &old_set); host_to_target_sigset_internal(&target_old_set, &old_set); #if defined(TARGET_I386) && !defined(TARGET_X86_64) { CPUX86State *env = cpu_env; if (env->eflags & VM_MASK) save_v86_state(env); } #endif #if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \ || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX) setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env); #else if (sa->sa_flags & TARGET_SA_SIGINFO) setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env); else setup_frame(sig, sa, &target_old_set, cpu_env); #endif if (sa->sa_flags & TARGET_SA_RESETHAND) { sa->_sa_handler = TARGET_SIG_DFL; } } if (q != &k->info) free_sigqueue(cpu_env, q); }
--------------------------------------------- Result 926 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void flush_queued_work(CPUState *cpu) { struct qemu_work_item *wi; if (cpu->queued_work_first == NULL) { return; } while ((wi = cpu->queued_work_first)) { cpu->queued_work_first = wi->next; wi->func(wi->data); wi->done = "True" == "True"; if (wi->free) { g_free(wi); } } cpu->queued_work_last = NULL; qemu_cond_broadcast(&qemu_work_cond); }
--------------------------------------------- Result 927 ---------------------------------------------
[[0 (68%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int validate_guest_space(unsigned long guest_base, unsigned long guest_size) { unsigned long real_start, test_page_addr; test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask); if (test_page_addr >= guest_base && test_page_addr <= (guest_base + guest_size)) { return -1; } real_start = (unsigned long) mmap((void *)test_page_addr, qemu_host_page_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (real_start == -1ul) { return 0; } if (real_start != test_page_addr) { munmap((void *)real_start, qemu_host_page_size); return 0; } __put_user(5, (uint32_t *)g2h(0xffff0ffcul)); if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) { perror("Protecting guest commpage"); exit(-1); } return 1; }
--------------------------------------------- Result 928 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: long do_sigreturn(CPUCRISState *env) { struct target_signal_frame *frame; abi_ulong frame_addr; target_sigset_t target_set; sigset_t set; int i; frame_addr = env->regs[R_SP]; if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1)) goto badframe; if (__get_user(target_set.sig[0], &frame->sc.oldmask)) goto badframe; for(i = 1; i < TARGET_NSIG_WORDS; i++) { if (__get_user(target_set.sig[i], &frame->extramask[i - 1])) goto badframe; } target_to_host_sigset_internal(&set, &target_set); do_sigprocmask(SIG_SETMASK, &set, NULL); restore_sigcontext(&frame->sc, env); unlock_user_struct(frame, frame_addr, 0); return env->regs[10]; badframe: unlock_user_struct(frame, frame_addr, 0); force_sig(TARGET_SIGSEGV); }
--------------------------------------------- Result 929 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 484 / 104 / 341 / 929:  35%|███▍      | 929/2690 [2:23:54<4:32:47,  9.29s/it][Succeeded / Failed / Skipped / Total] 484 / 104 / 341 / 929:  35%|███▍      | 930/2690 [2:24:12<4:32:55,  9.30s/it][Succeeded / Failed / Skipped / Total] 485 / 104 / 341 / 930:  35%|███▍      | 930/2690 [2:24:12<4:32:55,  9.30s/it][Succeeded / Failed / Skipped / Total] 485 / 104 / 341 / 930:  35%|███▍      | 931/2690 [2:24:13<4:32:29,  9.29s/it][[0 (34%)]] --> [[0 (61%)]] --> Socre: 0.6061897277832031

[[[[Adv]]]]: static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *[[outbuf]]) { SCSIRequest *req = &r->req; SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev); uint64_t [[nb_sectors]]; int buflen = 0; int ret; switch (req->cmd.buf[0]) { case TEST_UNIT_READY: if (!bdrv_is_inserted(s->bs)) goto not_ready; break; case REQUEST_SENSE: if (req->cmd.xfer < 4) goto illegal_request; buflen = scsi_device_get_sense(&s->qdev, [[outbuf]], req->cmd.xfer, (req->cmd.buf[1] & 1) == 0); break; case INQUIRY: buflen = scsi_disk_emulate_inquiry(req, [[outbuf]]); if (buflen < 0) goto illegal_request; break; case MODE_SENSE: case MODE_SENSE_10: buflen = scsi_disk_emulate_mode_sense(req, [[outbuf]]); if (buflen < 0) goto illegal_request; break; case READ_TOC: buflen = scsi_disk_emulate_read_toc(req, [[outbuf]]); if (buflen < 0) goto illegal_request; break; case RESERVE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RESERVE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case RELEASE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RELEASE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case START_STOP: if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) { bdrv_eject(s->bs, !(req->cmd.buf[4] & 1)); } break; case ALLOW_MEDIUM_REMOVAL: bdrv_set_locked(s->bs, req->cmd.buf[4] & 1); break; case READ_CAPACITY_10: memset([[outbuf]], 0, 8); bdrv_get_geometry(s->bs, &[[nb_sectors]]); if (![[nb_sectors]]) goto not_ready; [[nb_sectors]] /= s->cluster_size; [[nb_sectors]]--; s->max_lba = [[nb_sectors]]; if ([[nb_sectors]] > UINT32_MAX) [[nb_sectors]] = UINT32_MAX; [[outbuf]][0] = ([[nb_sectors]] >> 24) & 0xff; [[outbuf]][1] = ([[nb_sectors]] >> 16) & 0xff; [[outbuf]][2] = ([[nb_sectors]] >> 8) & 0xff; [[outbuf]][3] = [[nb_sectors]] & 0xff; [[outbuf]][4] = 0; [[outbuf]][5] = 0; [[outbuf]][6] = s->cluster_size * 2; [[outbuf]][7] = 0; buflen = 8; break; case SYNCHRONIZE_CACHE: ret = bdrv_flush(s->bs); if (ret < 0) { if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) { return -1; } } break; case GET_CONFIGURATION: memset([[outbuf]], 0, 8); [[outbuf]][7] = 8; buflen = 8; break; case SERVICE_ACTION_IN: if ((req->cmd.buf[1] & 31) == 0x10) { DPRINTF("SAI READ CAPACITY(16)\n"); memset([[outbuf]], 0, req->cmd.xfer); bdrv_get_geometry(s->bs, &[[nb_sectors]]); if (![[nb_sectors]]) goto not_ready; [[nb_sectors]] /= s->cluster_size; [[nb_sectors]]--; s->max_lba = [[nb_sectors]]; [[outbuf]][0] = ([[nb_sectors]] >> 56) & 0xff; [[outbuf]][1] = ([[nb_sectors]] >> 48) & 0xff; [[outbuf]][2] = ([[nb_sectors]] >> 40) & 0xff; [[outbuf]][3] = ([[nb_sectors]] >> 32) & 0xff; [[outbuf]][4] = ([[nb_sectors]] >> 24) & 0xff; [[outbuf]][5] = ([[nb_sectors]] >> 16) & 0xff; [[outbuf]][6] = ([[nb_sectors]] >> 8) & 0xff; [[outbuf]][7] = [[nb_sectors]] & 0xff; [[outbuf]][8] = 0; [[outbuf]][9] = 0; [[outbuf]][10] = s->cluster_size * 2; [[outbuf]][11] = 0; [[outbuf]][12] = 0; [[outbuf]][13] = get_physical_block_exp(&s->qdev.conf); if (s->qdev.conf.discard_granularity) { [[outbuf]][14] = 0x80; } buflen = req->cmd.xfer; break; } DPRINTF("Unsupported Service Action In\n"); goto illegal_request; case REPORT_LUNS: if (req->cmd.xfer < 16) goto illegal_request; memset([[outbuf]], 0, 16); [[outbuf]][3] = 8; buflen = 16; break; case VERIFY_10: break; default: scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); return -1; } return buflen; not_ready: if (!bdrv_is_inserted(s->bs)) { scsi_check_condition(r, SENSE_CODE(NO_MEDIUM)); } else { scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY)); } return -1; illegal_request: scsi_check_condition(r, SENSE_CODE(INVALID_FIELD)); return -1; }

[[[[Adv]]]]: static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *[[themanф]]) { SCSIRequest *req = &r->req; SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev); uint64_t [[smrpublicvar]]; int buflen = 0; int ret; switch (req->cmd.buf[0]) { case TEST_UNIT_READY: if (!bdrv_is_inserted(s->bs)) goto not_ready; break; case REQUEST_SENSE: if (req->cmd.xfer < 4) goto illegal_request; buflen = scsi_device_get_sense(&s->qdev, [[themanф]], req->cmd.xfer, (req->cmd.buf[1] & 1) == 0); break; case INQUIRY: buflen = scsi_disk_emulate_inquiry(req, [[themanф]]); if (buflen < 0) goto illegal_request; break; case MODE_SENSE: case MODE_SENSE_10: buflen = scsi_disk_emulate_mode_sense(req, [[themanф]]); if (buflen < 0) goto illegal_request; break; case READ_TOC: buflen = scsi_disk_emulate_read_toc(req, [[themanф]]); if (buflen < 0) goto illegal_request; break; case RESERVE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RESERVE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case RELEASE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RELEASE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case START_STOP: if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) { bdrv_eject(s->bs, !(req->cmd.buf[4] & 1)); } break; case ALLOW_MEDIUM_REMOVAL: bdrv_set_locked(s->bs, req->cmd.buf[4] & 1); break; case READ_CAPACITY_10: memset([[themanф]], 0, 8); bdrv_get_geometry(s->bs, &[[smrpublicvar]]); if (![[smrpublicvar]]) goto not_ready; [[smrpublicvar]] /= s->cluster_size; [[smrpublicvar]]--; s->max_lba = [[smrpublicvar]]; if ([[smrpublicvar]] > UINT32_MAX) [[smrpublicvar]] = UINT32_MAX; [[themanф]][0] = ([[smrpublicvar]] >> 24) & 0xff; [[themanф]][1] = ([[smrpublicvar]] >> 16) & 0xff; [[themanф]][2] = ([[smrpublicvar]] >> 8) & 0xff; [[themanф]][3] = [[smrpublicvar]] & 0xff; [[themanф]][4] = 0; [[themanф]][5] = 0; [[themanф]][6] = s->cluster_size * 2; [[themanф]][7] = 0; buflen = 8; break; case SYNCHRONIZE_CACHE: ret = bdrv_flush(s->bs); if (ret < 0) { if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) { return -1; } } break; case GET_CONFIGURATION: memset([[themanф]], 0, 8); [[themanф]][7] = 8; buflen = 8; break; case SERVICE_ACTION_IN: if ((req->cmd.buf[1] & 31) == 0x10) { DPRINTF("SAI READ CAPACITY(16)\n"); memset([[themanф]], 0, req->cmd.xfer); bdrv_get_geometry(s->bs, &[[smrpublicvar]]); if (![[smrpublicvar]]) goto not_ready; [[smrpublicvar]] /= s->cluster_size; [[smrpublicvar]]--; s->max_lba = [[smrpublicvar]]; [[themanф]][0] = ([[smrpublicvar]] >> 56) & 0xff; [[themanф]][1] = ([[smrpublicvar]] >> 48) & 0xff; [[themanф]][2] = ([[smrpublicvar]] >> 40) & 0xff; [[themanф]][3] = ([[smrpublicvar]] >> 32) & 0xff; [[themanф]][4] = ([[smrpublicvar]] >> 24) & 0xff; [[themanф]][5] = ([[smrpublicvar]] >> 16) & 0xff; [[themanф]][6] = ([[smrpublicvar]] >> 8) & 0xff; [[themanф]][7] = [[smrpublicvar]] & 0xff; [[themanф]][8] = 0; [[themanф]][9] = 0; [[themanф]][10] = s->cluster_size * 2; [[themanф]][11] = 0; [[themanф]][12] = 0; [[themanф]][13] = get_physical_block_exp(&s->qdev.conf); if (s->qdev.conf.discard_granularity) { [[themanф]][14] = 0x80; } buflen = req->cmd.xfer; break; } DPRINTF("Unsupported Service Action In\n"); goto illegal_request; case REPORT_LUNS: if (req->cmd.xfer < 16) goto illegal_request; memset([[themanф]], 0, 16); [[themanф]][3] = 8; buflen = 16; break; case VERIFY_10: break; default: scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); return -1; } return buflen; not_ready: if (!bdrv_is_inserted(s->bs)) { scsi_check_condition(r, SENSE_CODE(NO_MEDIUM)); } else { scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY)); } return -1; illegal_request: scsi_check_condition(r, SENSE_CODE(INVALID_FIELD)); return -1; }
--------------------------------------------- Result 930 ---------------------------------------------
[[0 (10%)]] --> [[0 (96%)]] --> Socre: 0.9618021845817566

[[[[Adv]]]]: void qemu_pixman_linebuf_fill(pixman_image_t *[[linebuf]], pixman_image_t *[[fb]], int [[width]], int [[y]]) { pixman_image_composite(PIXMAN_OP_SRC, [[fb]], NULL, [[linebuf]], 0, [[y]], 0, 0, 0, 0, [[width]], 1); }

[[[[Adv]]]]: void qemu_pixman_linebuf_fill(pixman_image_t *[[filmlig]], pixman_image_t *[[vб]], int [[aisle]], int [[value]]) { pixman_image_composite(PIXMAN_OP_SRC, [[vб]], NULL, [[filmlig]], 0, [[value]], 0, 0, 0, 0, [[aisle]], 1); }
[Succeeded / Failed / Skipped / Total] 485 / 104 / 342 / 931:  35%|███▍      | 931/2690 [2:24:13<4:32:29,  9.29s/it][Succeeded / Failed / Skipped / Total] 485 / 104 / 342 / 931:  35%|███▍      | 932/2690 [2:24:35<4:32:45,  9.31s/it][Succeeded / Failed / Skipped / Total] 486 / 104 / 342 / 932:  35%|███▍      | 932/2690 [2:24:35<4:32:45,  9.31s/it][Succeeded / Failed / Skipped / Total] 486 / 104 / 342 / 932:  35%|███▍      | 933/2690 [2:24:55<4:32:55,  9.32s/it]--------------------------------------------- Result 931 ---------------------------------------------
[[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp) { unsigned int cssid = 0; unsigned int ssid = 0; unsigned int schid; unsigned int devno; bool have_devno = "False" != "False"; bool found = "False" != "False"; SubchDev *sch; int num; DeviceState *parent = DEVICE(dev); Error *err = NULL; VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev); VirtIODevice *vdev; sch = g_malloc0(sizeof(SubchDev)); sch->driver_data = dev; dev->sch = sch; dev->indicators = NULL; sch->channel_prog = 0x0; sch->last_cmd_valid = "False" != "False"; sch->thinint_active = "False" != "False"; if (dev->bus_id) { num = sscanf(dev->bus_id, "%x.%x.%04x", &cssid, &ssid, &devno); if (num == 3) { if ((cssid > MAX_CSSID) || (ssid > MAX_SSID)) { error_setg(errp, "Invalid cssid or ssid: cssid %x, ssid %x", cssid, ssid); goto out_err; } if (cssid != VIRTUAL_CSSID) { error_setg(errp, "cssid %x not valid for virtio devices", cssid); goto out_err; } if (css_devno_used(cssid, ssid, devno)) { error_setg(errp, "Device %x.%x.%04x already exists", cssid, ssid, devno); goto out_err; } sch->cssid = cssid; sch->ssid = ssid; sch->devno = devno; have_devno = "True" == "True"; } else { error_setg(errp, "Malformed devno parameter '%s'", dev->bus_id); goto out_err; } } if (have_devno) { for (schid = 0; schid <= MAX_SCHID; schid++) { if (!css_find_subch(1, cssid, ssid, schid)) { sch->schid = schid; css_subch_assign(cssid, ssid, schid, devno, sch); found = "True" == "True"; break; } } if (!found) { error_setg(errp, "No free subchannel found for %x.%x.%04x", cssid, ssid, devno); goto out_err; } trace_virtio_ccw_new_device(cssid, ssid, schid, devno, "user-configured"); } else { cssid = VIRTUAL_CSSID; for (ssid = 0; ssid <= MAX_SSID; ssid++) { for (schid = 0; schid <= MAX_SCHID; schid++) { if (!css_find_subch(1, cssid, ssid, schid)) { sch->cssid = cssid; sch->ssid = ssid; sch->schid = schid; devno = schid; while (css_devno_used(cssid, ssid, devno)) { if (devno == MAX_SCHID) { devno = 0; } else if (devno == schid - 1) { error_setg(errp, "No free devno found"); goto out_err; } else { devno++; } } sch->devno = devno; css_subch_assign(cssid, ssid, schid, devno, sch); found = "True" == "True"; break; } } if (found) { break; } } if (!found) { error_setg(errp, "Virtual channel subsystem is full!"); goto out_err; } trace_virtio_ccw_new_device(cssid, ssid, schid, devno, "auto-configured"); } css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE); sch->ccw_cb = virtio_ccw_cb; memset(&sch->id, 0, sizeof(SenseId)); sch->id.reserved = 0xff; sch->id.cu_type = VIRTIO_CCW_CU_TYPE; if (k->realize) { k->realize(dev, &err); } if (err) { error_propagate(errp, err); css_subch_assign(cssid, ssid, schid, devno, NULL); goto out_err; } vdev = virtio_ccw_get_vdev(sch); sch->id.cu_model = vdev->device_id; dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus, dev->host_features[0]); virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY); virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE); css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid, parent->hotplugged, 1); return; out_err: dev->sch = NULL; g_free(sch); }
--------------------------------------------- Result 932 ---------------------------------------------
[[0 (77%)]] --> [[0 (50%)]] --> Socre: 0.5009035170078278

[[[[Adv]]]]: static void usbredir_interrupt_packet(void *priv, uint32_t [[id]], struct usb_redir_interrupt_packet_header *interrupt_packet, uint8_t *data, int data_len) { USBRedirDevice *[[dev]] = priv; uint8_t ep = interrupt_packet->endpoint; DPRINTF("interrupt-in status %d ep %02X len %d id %u\n", interrupt_packet->status, ep, data_len, [[id]]); if ([[dev]]->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) { ERROR("received int packet for non interrupt endpoint %02X\n", ep); free(data); return; } if (ep & USB_DIR_IN) { if ([[dev]]->endpoint[EP2I(ep)].interrupt_started == 0) { DPRINTF("received int packet while not started ep %02X\n", ep); free(data); return; } bufp_alloc([[dev]], data, data_len, interrupt_packet->status, ep); } else { int len = interrupt_packet->length; AsyncURB *[[aurb]] = async_find([[dev]], [[id]]); if (![[aurb]]) { return; } if ([[aurb]]->interrupt_packet.endpoint != interrupt_packet->endpoint) { ERROR("return int packet mismatch, please report this!\n"); len = USB_RET_NAK; } if ([[aurb]]->packet) { [[aurb]]->packet->len = usbredir_handle_status([[dev]], interrupt_packet->status, len); usb_packet_complete(&[[dev]]->dev, [[aurb]]->packet); } async_free([[dev]], [[aurb]]); } }

[[[[Adv]]]]: static void usbredir_interrupt_packet(void *priv, uint32_t [[identification]], struct usb_redir_interrupt_packet_header *interrupt_packet, uint8_t *data, int data_len) { USBRedirDevice *[[nov]] = priv; uint8_t ep = interrupt_packet->endpoint; DPRINTF("interrupt-in status %d ep %02X len %d id %u\n", interrupt_packet->status, ep, data_len, [[identification]]); if ([[nov]]->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) { ERROR("received int packet for non interrupt endpoint %02X\n", ep); free(data); return; } if (ep & USB_DIR_IN) { if ([[nov]]->endpoint[EP2I(ep)].interrupt_started == 0) { DPRINTF("received int packet while not started ep %02X\n", ep); free(data); return; } bufp_alloc([[nov]], data, data_len, interrupt_packet->status, ep); } else { int len = interrupt_packet->length; AsyncURB *[[anglerce]] = async_find([[nov]], [[identification]]); if (![[anglerce]]) { return; } if ([[anglerce]]->interrupt_packet.endpoint != interrupt_packet->endpoint) { ERROR("return int packet mismatch, please report this!\n"); len = USB_RET_NAK; } if ([[anglerce]]->packet) { [[anglerce]]->packet->len = usbredir_handle_status([[nov]], interrupt_packet->status, len); usb_packet_complete(&[[nov]]->dev, [[anglerce]]->packet); } async_free([[nov]], [[anglerce]]); } }
--------------------------------------------- Result 933 ---------------------------------------------
[[0 (18%)]] --> [[0 (83%)]] --> Socre: 0.8342044949531555

[[[[Adv]]]]: void mpeg1_encode_mb(MpegEncContext *[[s]], DCTELEM block[6][64], int [[motion_x]], int motion_y) { int i, cbp; const int mb_x = [[s]]->mb_x; const int [[mb_y]] = [[s]]->mb_y; const int first_mb= mb_x == [[s]]->resync_mb_x && [[mb_y]] == [[s]]->resync_mb_y; cbp = 0; for(i=0;i<6;i++) { if ([[s]]->block_last_index[i] >= 0) cbp |= 1 << (5 - i); } if (cbp == 0 && !first_mb && (mb_x != [[s]]->mb_width - 1 || ([[mb_y]] != [[s]]->mb_height - 1 && [[s]]->codec_id == CODEC_ID_MPEG1VIDEO)) && (([[s]]->pict_type == P_TYPE && [[s]]->mv_type == MV_TYPE_16X16 && ([[motion_x]] | motion_y) == 0) || ([[s]]->pict_type == B_TYPE && [[s]]->mv_dir == [[s]]->last_mv_dir && ((([[s]]->mv_dir & MV_DIR_FORWARD) ? (([[s]]->mv[0][0][0] - [[s]]->last_mv[0][0][0])|([[s]]->mv[0][0][1] - [[s]]->last_mv[0][0][1])) : 0) | (([[s]]->mv_dir & MV_DIR_BACKWARD) ? (([[s]]->mv[1][0][0] - [[s]]->last_mv[1][0][0])|([[s]]->mv[1][0][1] - [[s]]->last_mv[1][0][1])) : 0)) == 0))) { [[s]]->mb_skip_run++; [[s]]->qscale -= [[s]]->dquant; [[s]]->skip_count++; [[s]]->misc_bits++; [[s]]->last_bits++; if([[s]]->pict_type == P_TYPE){ [[s]]->last_mv[0][1][0]= [[s]]->last_mv[0][0][0]= [[s]]->last_mv[0][1][1]= [[s]]->last_mv[0][0][1]= 0; } } else { if(first_mb){ assert([[s]]->mb_skip_run == 0); encode_mb_skip_run([[s]], [[s]]->mb_x); }else{ encode_mb_skip_run([[s]], [[s]]->mb_skip_run); } if ([[s]]->pict_type == I_TYPE) { if([[s]]->dquant && cbp){ put_mb_modes([[s]], 2, 1, 0, 0); put_bits(&[[s]]->pb, 5, [[s]]->qscale); }else{ put_mb_modes([[s]], 1, 1, 0, 0); [[s]]->qscale -= [[s]]->dquant; } [[s]]->misc_bits+= get_bits_diff([[s]]); [[s]]->i_count++; } else if ([[s]]->mb_intra) { if([[s]]->dquant && cbp){ put_mb_modes([[s]], 6, 0x01, 0, 0); put_bits(&[[s]]->pb, 5, [[s]]->qscale); }else{ put_mb_modes([[s]], 5, 0x03, 0, 0); [[s]]->qscale -= [[s]]->dquant; } [[s]]->misc_bits+= get_bits_diff([[s]]); [[s]]->i_count++; memset([[s]]->last_mv, 0, sizeof([[s]]->last_mv)); } else if ([[s]]->pict_type == P_TYPE) { if([[s]]->mv_type == MV_TYPE_16X16){ if (cbp != 0) { if (([[motion_x]]|motion_y) == 0) { if([[s]]->dquant){ put_mb_modes([[s]], 5, 1, 0, 0); put_bits(&[[s]]->pb, 5, [[s]]->qscale); }else{ put_mb_modes([[s]], 2, 1, 0, 0); } [[s]]->misc_bits+= get_bits_diff([[s]]); } else { if([[s]]->dquant){ put_mb_modes([[s]], 5, 2, 1, 0); put_bits(&[[s]]->pb, 5, [[s]]->qscale); }else{ put_mb_modes([[s]], 1, 1, 1, 0); } [[s]]->misc_bits+= get_bits_diff([[s]]); mpeg1_encode_motion([[s]], [[motion_x]] - [[s]]->last_mv[0][0][0], [[s]]->f_code); mpeg1_encode_motion([[s]], motion_y - [[s]]->last_mv[0][0][1], [[s]]->f_code); [[s]]->mv_bits+= get_bits_diff([[s]]); } } else { put_bits(&[[s]]->pb, 3, 1); if (![[s]]->frame_pred_frame_dct) put_bits(&[[s]]->pb, 2, 2); [[s]]->misc_bits+= get_bits_diff([[s]]); mpeg1_encode_motion([[s]], [[motion_x]] - [[s]]->last_mv[0][0][0], [[s]]->f_code); mpeg1_encode_motion([[s]], motion_y - [[s]]->last_mv[0][0][1], [[s]]->f_code); [[s]]->qscale -= [[s]]->dquant; [[s]]->mv_bits+= get_bits_diff([[s]]); } [[s]]->last_mv[0][1][0]= [[s]]->last_mv[0][0][0]= [[motion_x]]; [[s]]->last_mv[0][1][1]= [[s]]->last_mv[0][0][1]= motion_y; }else{ assert(![[s]]->frame_pred_frame_dct && [[s]]->mv_type == MV_TYPE_FIELD); if (cbp) { if([[s]]->dquant){ put_mb_modes([[s]], 5, 2, 1, 1); put_bits(&[[s]]->pb, 5, [[s]]->qscale); }else{ put_mb_modes([[s]], 1, 1, 1, 1); } } else { put_bits(&[[s]]->pb, 3, 1); put_bits(&[[s]]->pb, 2, 1); [[s]]->qscale -= [[s]]->dquant; } [[s]]->misc_bits+= get_bits_diff([[s]]); for(i=0; i<2; i++){ put_bits(&[[s]]->pb, 1, [[s]]->field_select[0][i]); mpeg1_encode_motion([[s]], [[s]]->mv[0][i][0] - [[s]]->last_mv[0][i][0] , [[s]]->f_code); mpeg1_encode_motion([[s]], [[s]]->mv[0][i][1] - ([[s]]->last_mv[0][i][1]>>1), [[s]]->f_code); [[s]]->last_mv[0][i][0]= [[s]]->mv[0][i][0]; [[s]]->last_mv[0][i][1]= 2*[[s]]->mv[0][i][1]; } [[s]]->mv_bits+= get_bits_diff([[s]]); } if(cbp) put_bits(&[[s]]->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); [[s]]->f_count++; } else{ static const int mb_type_len[4]={0,3,4,2}; if([[s]]->mv_type == MV_TYPE_16X16){ if (cbp){ if ([[s]]->dquant) { if([[s]]->mv_dir == MV_DIR_FORWARD) put_mb_modes([[s]], 6, 3, 1, 0); else put_mb_modes([[s]], mb_type_len[[[s]]->mv_dir]+3, 2, 1, 0); put_bits(&[[s]]->pb, 5, [[s]]->qscale); } else { put_mb_modes([[s]], mb_type_len[[[s]]->mv_dir], 3, 1, 0); } }else{ put_bits(&[[s]]->pb, mb_type_len[[[s]]->mv_dir], 2); if (![[s]]->frame_pred_frame_dct) put_bits(&[[s]]->pb, 2, 2); [[s]]->qscale -= [[s]]->dquant; } [[s]]->misc_bits += get_bits_diff([[s]]); if ([[s]]->mv_dir&MV_DIR_FORWARD){ mpeg1_encode_motion([[s]], [[s]]->mv[0][0][0] - [[s]]->last_mv[0][0][0], [[s]]->f_code); mpeg1_encode_motion([[s]], [[s]]->mv[0][0][1] - [[s]]->last_mv[0][0][1], [[s]]->f_code); [[s]]->last_mv[0][0][0]=[[s]]->last_mv[0][1][0]= [[s]]->mv[0][0][0]; [[s]]->last_mv[0][0][1]=[[s]]->last_mv[0][1][1]= [[s]]->mv[0][0][1]; [[s]]->f_count++; } if ([[s]]->mv_dir&MV_DIR_BACKWARD){ mpeg1_encode_motion([[s]], [[s]]->mv[1][0][0] - [[s]]->last_mv[1][0][0], [[s]]->b_code); mpeg1_encode_motion([[s]], [[s]]->mv[1][0][1] - [[s]]->last_mv[1][0][1], [[s]]->b_code); [[s]]->last_mv[1][0][0]=[[s]]->last_mv[1][1][0]= [[s]]->mv[1][0][0]; [[s]]->last_mv[1][0][1]=[[s]]->last_mv[1][1][1]= [[s]]->mv[1][0][1]; [[s]]->b_count++; } }else{ assert([[s]]->mv_type == MV_TYPE_FIELD); assert(![[s]]->frame_pred_frame_dct); if (cbp){ if ([[s]]->dquant) { if([[s]]->mv_dir == MV_DIR_FORWARD) put_mb_modes([[s]], 6, 3, 1, 1); else put_mb_modes([[s]], mb_type_len[[[s]]->mv_dir]+3, 2, 1, 1); put_bits(&[[s]]->pb, 5, [[s]]->qscale); } else { put_mb_modes([[s]], mb_type_len[[[s]]->mv_dir], 3, 1, 1); } }else{ put_bits(&[[s]]->pb, mb_type_len[[[s]]->mv_dir], 2); put_bits(&[[s]]->pb, 2, 1); [[s]]->qscale -= [[s]]->dquant; } [[s]]->misc_bits += get_bits_diff([[s]]); if ([[s]]->mv_dir&MV_DIR_FORWARD){ for(i=0; i<2; i++){ put_bits(&[[s]]->pb, 1, [[s]]->field_select[0][i]); mpeg1_encode_motion([[s]], [[s]]->mv[0][i][0] - [[s]]->last_mv[0][i][0] , [[s]]->f_code); mpeg1_encode_motion([[s]], [[s]]->mv[0][i][1] - ([[s]]->last_mv[0][i][1]>>1), [[s]]->f_code); [[s]]->last_mv[0][i][0]= [[s]]->mv[0][i][0]; [[s]]->last_mv[0][i][1]= 2*[[s]]->mv[0][i][1]; } [[s]]->f_count++; } if ([[s]]->mv_dir&MV_DIR_BACKWARD){ for(i=0; i<2; i++){ put_bits(&[[s]]->pb, 1, [[s]]->field_select[1][i]); mpeg1_encode_motion([[s]], [[s]]->mv[1][i][0] - [[s]]->last_mv[1][i][0] , [[s]]->b_code); mpeg1_encode_motion([[s]], [[s]]->mv[1][i][1] - ([[s]]->last_mv[1][i][1]>>1), [[s]]->b_code); [[s]]->last_mv[1][i][0]= [[s]]->mv[1][i][0]; [[s]]->last_mv[1][i][1]= 2*[[s]]->mv[1][i][1]; } [[s]]->b_count++; } } [[s]]->mv_bits += get_bits_diff([[s]]); if(cbp) put_bits(&[[s]]->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); } for(i=0;i<6;i++) { if (cbp & (1 << (5 - i))) { mpeg1_encode_block([[s]], block[i], i); } } [[s]]->mb_skip_run = 0; if([[s]]->mb_intra) [[s]]->i_tex_bits+= get_bits_diff([[s]]); else [[s]]->p_tex_bits+= get_bits_diff([[s]]); } }

[[[[Adv]]]]: void mpeg1_encode_mb(MpegEncContext *[[bits]], DCTELEM block[6][64], int [[miromprix]], int motion_y) { int i, cbp; const int mb_x = [[bits]]->mb_x; const int [[ja²xx]] = [[bits]]->mb_y; const int first_mb= mb_x == [[bits]]->resync_mb_x && [[ja²xx]] == [[bits]]->resync_mb_y; cbp = 0; for(i=0;i<6;i++) { if ([[bits]]->block_last_index[i] >= 0) cbp |= 1 << (5 - i); } if (cbp == 0 && !first_mb && (mb_x != [[bits]]->mb_width - 1 || ([[ja²xx]] != [[bits]]->mb_height - 1 && [[bits]]->codec_id == CODEC_ID_MPEG1VIDEO)) && (([[bits]]->pict_type == P_TYPE && [[bits]]->mv_type == MV_TYPE_16X16 && ([[miromprix]] | motion_y) == 0) || ([[bits]]->pict_type == B_TYPE && [[bits]]->mv_dir == [[bits]]->last_mv_dir && ((([[bits]]->mv_dir & MV_DIR_FORWARD) ? (([[bits]]->mv[0][0][0] - [[bits]]->last_mv[0][0][0])|([[bits]]->mv[0][0][1] - [[bits]]->last_mv[0][0][1])) : 0) | (([[bits]]->mv_dir & MV_DIR_BACKWARD) ? (([[bits]]->mv[1][0][0] - [[bits]]->last_mv[1][0][0])|([[bits]]->mv[1][0][1] - [[bits]]->last_mv[1][0][1])) : 0)) == 0))) { [[bits]]->mb_skip_run++; [[bits]]->qscale -= [[bits]]->dquant; [[bits]]->skip_count++; [[bits]]->misc_bits++; [[bits]]->last_bits++; if([[bits]]->pict_type == P_TYPE){ [[bits]]->last_mv[0][1][0]= [[bits]]->last_mv[0][0][0]= [[bits]]->last_mv[0][1][1]= [[bits]]->last_mv[0][0][1]= 0; } } else { if(first_mb){ assert([[bits]]->mb_skip_run == 0); encode_mb_skip_run([[bits]], [[bits]]->mb_x); }else{ encode_mb_skip_run([[bits]], [[bits]]->mb_skip_run); } if ([[bits]]->pict_type == I_TYPE) { if([[bits]]->dquant && cbp){ put_mb_modes([[bits]], 2, 1, 0, 0); put_bits(&[[bits]]->pb, 5, [[bits]]->qscale); }else{ put_mb_modes([[bits]], 1, 1, 0, 0); [[bits]]->qscale -= [[bits]]->dquant; } [[bits]]->misc_bits+= get_bits_diff([[bits]]); [[bits]]->i_count++; } else if ([[bits]]->mb_intra) { if([[bits]]->dquant && cbp){ put_mb_modes([[bits]], 6, 0x01, 0, 0); put_bits(&[[bits]]->pb, 5, [[bits]]->qscale); }else{ put_mb_modes([[bits]], 5, 0x03, 0, 0); [[bits]]->qscale -= [[bits]]->dquant; } [[bits]]->misc_bits+= get_bits_diff([[bits]]); [[bits]]->i_count++; memset([[bits]]->last_mv, 0, sizeof([[bits]]->last_mv)); } else if ([[bits]]->pict_type == P_TYPE) { if([[bits]]->mv_type == MV_TYPE_16X16){ if (cbp != 0) { if (([[miromprix]]|motion_y) == 0) { if([[bits]]->dquant){ put_mb_modes([[bits]], 5, 1, 0, 0); put_bits(&[[bits]]->pb, 5, [[bits]]->qscale); }else{ put_mb_modes([[bits]], 2, 1, 0, 0); } [[bits]]->misc_bits+= get_bits_diff([[bits]]); } else { if([[bits]]->dquant){ put_mb_modes([[bits]], 5, 2, 1, 0); put_bits(&[[bits]]->pb, 5, [[bits]]->qscale); }else{ put_mb_modes([[bits]], 1, 1, 1, 0); } [[bits]]->misc_bits+= get_bits_diff([[bits]]); mpeg1_encode_motion([[bits]], [[miromprix]] - [[bits]]->last_mv[0][0][0], [[bits]]->f_code); mpeg1_encode_motion([[bits]], motion_y - [[bits]]->last_mv[0][0][1], [[bits]]->f_code); [[bits]]->mv_bits+= get_bits_diff([[bits]]); } } else { put_bits(&[[bits]]->pb, 3, 1); if (![[bits]]->frame_pred_frame_dct) put_bits(&[[bits]]->pb, 2, 2); [[bits]]->misc_bits+= get_bits_diff([[bits]]); mpeg1_encode_motion([[bits]], [[miromprix]] - [[bits]]->last_mv[0][0][0], [[bits]]->f_code); mpeg1_encode_motion([[bits]], motion_y - [[bits]]->last_mv[0][0][1], [[bits]]->f_code); [[bits]]->qscale -= [[bits]]->dquant; [[bits]]->mv_bits+= get_bits_diff([[bits]]); } [[bits]]->last_mv[0][1][0]= [[bits]]->last_mv[0][0][0]= [[miromprix]]; [[bits]]->last_mv[0][1][1]= [[bits]]->last_mv[0][0][1]= motion_y; }else{ assert(![[bits]]->frame_pred_frame_dct && [[bits]]->mv_type == MV_TYPE_FIELD); if (cbp) { if([[bits]]->dquant){ put_mb_modes([[bits]], 5, 2, 1, 1); put_bits(&[[bits]]->pb, 5, [[bits]]->qscale); }else{ put_mb_modes([[bits]], 1, 1, 1, 1); } } else { put_bits(&[[bits]]->pb, 3, 1); put_bits(&[[bits]]->pb, 2, 1); [[bits]]->qscale -= [[bits]]->dquant; } [[bits]]->misc_bits+= get_bits_diff([[bits]]); for(i=0; i<2; i++){ put_bits(&[[bits]]->pb, 1, [[bits]]->field_select[0][i]); mpeg1_encode_motion([[bits]], [[bits]]->mv[0][i][0] - [[bits]]->last_mv[0][i][0] , [[bits]]->f_code); mpeg1_encode_motion([[bits]], [[bits]]->mv[0][i][1] - ([[bits]]->last_mv[0][i][1]>>1), [[bits]]->f_code); [[bits]]->last_mv[0][i][0]= [[bits]]->mv[0][i][0]; [[bits]]->last_mv[0][i][1]= 2*[[bits]]->mv[0][i][1]; } [[bits]]->mv_bits+= get_bits_diff([[bits]]); } if(cbp) put_bits(&[[bits]]->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); [[bits]]->f_count++; } else{ static const int mb_type_len[4]={0,3,4,2}; if([[bits]]->mv_type == MV_TYPE_16X16){ if (cbp){ if ([[bits]]->dquant) { if([[bits]]->mv_dir == MV_DIR_FORWARD) put_mb_modes([[bits]], 6, 3, 1, 0); else put_mb_modes([[bits]], mb_type_len[[[bits]]->mv_dir]+3, 2, 1, 0); put_bits(&[[bits]]->pb, 5, [[bits]]->qscale); } else { put_mb_modes([[bits]], mb_type_len[[[bits]]->mv_dir], 3, 1, 0); } }else{ put_bits(&[[bits]]->pb, mb_type_len[[[bits]]->mv_dir], 2); if (![[bits]]->frame_pred_frame_dct) put_bits(&[[bits]]->pb, 2, 2); [[bits]]->qscale -= [[bits]]->dquant; } [[bits]]->misc_bits += get_bits_diff([[bits]]); if ([[bits]]->mv_dir&MV_DIR_FORWARD){ mpeg1_encode_motion([[bits]], [[bits]]->mv[0][0][0] - [[bits]]->last_mv[0][0][0], [[bits]]->f_code); mpeg1_encode_motion([[bits]], [[bits]]->mv[0][0][1] - [[bits]]->last_mv[0][0][1], [[bits]]->f_code); [[bits]]->last_mv[0][0][0]=[[bits]]->last_mv[0][1][0]= [[bits]]->mv[0][0][0]; [[bits]]->last_mv[0][0][1]=[[bits]]->last_mv[0][1][1]= [[bits]]->mv[0][0][1]; [[bits]]->f_count++; } if ([[bits]]->mv_dir&MV_DIR_BACKWARD){ mpeg1_encode_motion([[bits]], [[bits]]->mv[1][0][0] - [[bits]]->last_mv[1][0][0], [[bits]]->b_code); mpeg1_encode_motion([[bits]], [[bits]]->mv[1][0][1] - [[bits]]->last_mv[1][0][1], [[bits]]->b_code); [[bits]]->last_mv[1][0][0]=[[bits]]->last_mv[1][1][0]= [[bits]]->mv[1][0][0]; [[bits]]->last_mv[1][0][1]=[[bits]]->last_mv[1][1][1]= [[bits]]->mv[1][0][1]; [[bits]]->b_count++; } }else{ assert([[bits]]->mv_type == MV_TYPE_FIELD); assert(![[bits]]->frame_pred_frame_dct); if (cbp){ if ([[bits]]->dquant) { if([[bits]]->mv_dir == MV_DIR_FORWARD) put_mb_modes([[bits]], 6, 3, 1, 1); else put_mb_modes([[bits]], mb_type_len[[[bits]]->mv_dir]+3, 2, 1, 1); put_bits(&[[bits]]->pb, 5, [[bits]]->qscale); } else { put_mb_modes([[bits]], mb_type_len[[[bits]]->mv_dir], 3, 1, 1); } }else{ put_bits(&[[bits]]->pb, mb_type_len[[[bits]]->mv_dir], 2); put_bits(&[[bits]]->pb, 2, 1); [[bits]]->qscale -= [[bits]]->dquant; } [[bits]]->misc_bits += get_bits_diff([[bits]]); if ([[bits]]->mv_dir&MV_DIR_FORWARD){ for(i=0; i<2; i++){ put_bits(&[[bits]]->pb, 1, [[bits]]->field_select[0][i]); mpeg1_encode_motion([[bits]], [[bits]]->mv[0][i][0] - [[bits]]->last_mv[0][i][0] , [[bits]]->f_code); mpeg1_encode_motion([[bits]], [[bits]]->mv[0][i][1] - ([[bits]]->last_mv[0][i][1]>>1), [[bits]]->f_code); [[bits]]->last_mv[0][i][0]= [[bits]]->mv[0][i][0]; [[bits]]->last_mv[0][i][1]= 2*[[bits]]->mv[0][i][1]; } [[bits]]->f_count++; } if ([[bits]]->mv_dir&MV_DIR_BACKWARD){ for(i=0; i<2; i++){ put_bits(&[[bits]]->pb, 1, [[bits]]->field_select[1][i]); mpeg1_encode_motion([[bits]], [[bits]]->mv[1][i][0] - [[bits]]->last_mv[1][i][0] , [[bits]]->b_code); mpeg1_encode_motion([[bits]], [[bits]]->mv[1][i][1] - ([[bits]]->last_mv[1][i][1]>>1), [[bits]]->b_code); [[bits]]->last_mv[1][i][0]= [[bits]]->mv[1][i][0]; [[bits]]->last_mv[1][i][1]= 2*[[bits]]->mv[1][i][1]; } [[bits]]->b_count++; } } [[bits]]->mv_bits += get_bits_diff([[bits]]); if(cbp) put_bits(&[[bits]]->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); } for(i=0;i<6;i++) { if (cbp & (1 << (5 - i))) { mpeg1_encode_block([[bits]], block[i], i); } } [[bits]]->mb_skip_run = 0; if([[bits]]->mb_intra) [[bits]]->i_tex_bits+= get_bits_diff([[bits]]); else [[bits]]->p_tex_bits+= get_bits_diff([[bits]]); } }[Succeeded / Failed / Skipped / Total] 487 / 104 / 342 / 933:  35%|███▍      | 933/2690 [2:24:55<4:32:55,  9.32s/it][Succeeded / Failed / Skipped / Total] 487 / 104 / 342 / 933:  35%|███▍      | 934/2690 [2:25:22<4:33:19,  9.34s/it][Succeeded / Failed / Skipped / Total] 488 / 104 / 342 / 934:  35%|███▍      | 934/2690 [2:25:22<4:33:19,  9.34s/it][Succeeded / Failed / Skipped / Total] 488 / 104 / 342 / 934:  35%|███▍      | 935/2690 [2:25:43<4:33:31,  9.35s/it][Succeeded / Failed / Skipped / Total] 489 / 104 / 342 / 935:  35%|███▍      | 935/2690 [2:25:43<4:33:31,  9.35s/it][Succeeded / Failed / Skipped / Total] 489 / 104 / 342 / 935:  35%|███▍      | 936/2690 [2:25:44<4:33:05,  9.34s/it][Succeeded / Failed / Skipped / Total] 489 / 104 / 343 / 936:  35%|███▍      | 936/2690 [2:25:44<4:33:05,  9.34s/it][Succeeded / Failed / Skipped / Total] 489 / 104 / 343 / 936:  35%|███▍      | 937/2690 [2:25:44<4:32:39,  9.33s/it]
--------------------------------------------- Result 934 ---------------------------------------------
[[0 (90%)]] --> [[0 (44%)]] --> Socre: 0.5647139549255371

[[[[Adv]]]]: static inline void RENAME(rgb24tobgr24)(const uint8_t *[[src]], uint8_t *[[dst]], long [[src_size]]) { unsigned i; #ifdef HAVE_MMX long mmx_size= 23 - [[src_size]]; asm volatile ( "test %%"REG_a", %%"REG_a" \n\t" "jns 2f \n\t" "movq "MANGLE(mask24r)", %%mm5 \n\t" "movq "MANGLE(mask24g)", %%mm6 \n\t" "movq "MANGLE(mask24b)", %%mm7 \n\t" ASMALIGN(4) "1: \n\t" PREFETCH" 32(%1, %%"REG_a") \n\t" "movq (%1, %%"REG_a"), %%mm0 \n\t" "movq (%1, %%"REG_a"), %%mm1 \n\t" "movq 2(%1, %%"REG_a"), %%mm2 \n\t" "psllq $16, %%mm0 \n\t" "pand %%mm5, %%mm0 \n\t" "pand %%mm6, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" "movq 6(%1, %%"REG_a"), %%mm0 \n\t" MOVNTQ" %%mm1, (%2, %%"REG_a")\n\t" "movq 8(%1, %%"REG_a"), %%mm1 \n\t" "movq 10(%1, %%"REG_a"), %%mm2 \n\t" "pand %%mm7, %%mm0 \n\t" "pand %%mm5, %%mm1 \n\t" "pand %%mm6, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" "movq 14(%1, %%"REG_a"), %%mm0 \n\t" MOVNTQ" %%mm1, 8(%2, %%"REG_a")\n\t" "movq 16(%1, %%"REG_a"), %%mm1 \n\t" "movq 18(%1, %%"REG_a"), %%mm2 \n\t" "pand %%mm6, %%mm0 \n\t" "pand %%mm7, %%mm1 \n\t" "pand %%mm5, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" MOVNTQ" %%mm1, 16(%2, %%"REG_a")\n\t" "add $24, %%"REG_a" \n\t" " js 1b \n\t" "2: \n\t" : "+a" (mmx_size) : "r" ([[src]]-mmx_size), "r"([[dst]]-mmx_size) ); __asm __volatile(SFENCE:::"memory"); __asm __volatile(EMMS:::"memory"); if(mmx_size==23) return; [[src]]+= [[src_size]]; [[dst]]+= [[src_size]]; [[src_size]]= 23-mmx_size; [[src]]-= [[src_size]]; [[dst]]-= [[src_size]]; #endif for(i=0; i<[[src_size]]; i+=3) { register uint8_t x; x = [[src]][i + 2]; [[dst]][i + 1] = [[src]][i + 1]; [[dst]][i + 2] = [[src]][i + 0]; [[dst]][i + 0] = x; } }

[[[[Adv]]]]: static inline void RENAME(rgb24tobgr24)(const uint8_t *[[dack]], uint8_t *[[daт]], long [[trcaclasstype]]) { unsigned i; #ifdef HAVE_MMX long mmx_size= 23 - [[trcaclasstype]]; asm volatile ( "test %%"REG_a", %%"REG_a" \n\t" "jns 2f \n\t" "movq "MANGLE(mask24r)", %%mm5 \n\t" "movq "MANGLE(mask24g)", %%mm6 \n\t" "movq "MANGLE(mask24b)", %%mm7 \n\t" ASMALIGN(4) "1: \n\t" PREFETCH" 32(%1, %%"REG_a") \n\t" "movq (%1, %%"REG_a"), %%mm0 \n\t" "movq (%1, %%"REG_a"), %%mm1 \n\t" "movq 2(%1, %%"REG_a"), %%mm2 \n\t" "psllq $16, %%mm0 \n\t" "pand %%mm5, %%mm0 \n\t" "pand %%mm6, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" "movq 6(%1, %%"REG_a"), %%mm0 \n\t" MOVNTQ" %%mm1, (%2, %%"REG_a")\n\t" "movq 8(%1, %%"REG_a"), %%mm1 \n\t" "movq 10(%1, %%"REG_a"), %%mm2 \n\t" "pand %%mm7, %%mm0 \n\t" "pand %%mm5, %%mm1 \n\t" "pand %%mm6, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" "movq 14(%1, %%"REG_a"), %%mm0 \n\t" MOVNTQ" %%mm1, 8(%2, %%"REG_a")\n\t" "movq 16(%1, %%"REG_a"), %%mm1 \n\t" "movq 18(%1, %%"REG_a"), %%mm2 \n\t" "pand %%mm6, %%mm0 \n\t" "pand %%mm7, %%mm1 \n\t" "pand %%mm5, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" MOVNTQ" %%mm1, 16(%2, %%"REG_a")\n\t" "add $24, %%"REG_a" \n\t" " js 1b \n\t" "2: \n\t" : "+a" (mmx_size) : "r" ([[dack]]-mmx_size), "r"([[daт]]-mmx_size) ); __asm __volatile(SFENCE:::"memory"); __asm __volatile(EMMS:::"memory"); if(mmx_size==23) return; [[dack]]+= [[trcaclasstype]]; [[daт]]+= [[trcaclasstype]]; [[trcaclasstype]]= 23-mmx_size; [[dack]]-= [[trcaclasstype]]; [[daт]]-= [[trcaclasstype]]; #endif for(i=0; i<[[trcaclasstype]]; i+=3) { register uint8_t x; x = [[dack]][i + 2]; [[daт]][i + 1] = [[dack]][i + 1]; [[daт]][i + 2] = [[dack]][i + 0]; [[daт]][i + 0] = x; } }
--------------------------------------------- Result 935 ---------------------------------------------
[[0 (63%)]] --> [[0 (14%)]] --> Socre: 0.8579521179199219

[[[[Adv]]]]: GIOStatus ga_channel_write_all(GAChannel *[[c]], const char *buf, size_t size) { GIOStatus status = G_IO_STATUS_NORMAL; size_t count; while (size) { status = ga_channel_write([[c]], buf, size, &count); if (status == G_IO_STATUS_NORMAL) { size -= count; buf += count; } else if (status != G_IO_STATUS_AGAIN) { break; } } return status; }

[[[[Adv]]]]: GIOStatus ga_channel_write_all(GAChannel *[[major]], const char *buf, size_t size) { GIOStatus status = G_IO_STATUS_NORMAL; size_t count; while (size) { status = ga_channel_write([[major]], buf, size, &count); if (status == G_IO_STATUS_NORMAL) { size -= count; buf += count; } else if (status != G_IO_STATUS_AGAIN) { break; } } return status; }
--------------------------------------------- Result 936 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int channelmap_query_formats(AVFilterContext *ctx) { ChannelMapContext *s = ctx->priv; ff_set_common_formats(ctx, ff_planar_sample_fmts()); ff_set_common_samplerates(ctx, ff_all_samplerates()); ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts); ff_channel_layouts_ref(s->channel_layouts, &ctx->outputs[0]->in_channel_layouts); return 0; }
--------------------------------------------- Result 937 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 490 / 104 / 343 / 937:  35%|███▍      | 937/2690 [2:25:44<4:32:39,  9.33s/it][Succeeded / Failed / Skipped / Total] 490 / 104 / 343 / 937:  35%|███▍      | 938/2690 [2:25:44<4:32:13,  9.32s/it][Succeeded / Failed / Skipped / Total] 490 / 104 / 344 / 938:  35%|███▍      | 938/2690 [2:25:44<4:32:13,  9.32s/it][Succeeded / Failed / Skipped / Total] 490 / 104 / 344 / 938:  35%|███▍      | 939/2690 [2:25:44<4:31:46,  9.31s/it][Succeeded / Failed / Skipped / Total] 490 / 104 / 345 / 939:  35%|███▍      | 939/2690 [2:25:44<4:31:46,  9.31s/it][Succeeded / Failed / Skipped / Total] 490 / 104 / 345 / 939:  35%|███▍      | 940/2690 [2:25:45<4:31:21,  9.30s/it][Succeeded / Failed / Skipped / Total] 490 / 104 / 346 / 940:  35%|███▍      | 940/2690 [2:25:45<4:31:21,  9.30s/it][Succeeded / Failed / Skipped / Total] 490 / 104 / 346 / 940:  35%|███▍      | 941/2690 [2:26:12<4:31:44,  9.32s/it][[0 (62%)]] --> [[0 (45%)]] --> Socre: 0.5524888932704926

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = data; int buf_index = 0; Picture *[[out]]; int [[i]], out_idx; int ret; h->flags = avctx->flags; if (buf_size == 0) { out: h->cur_pic_ptr = NULL; h->first_field = 0; [[out]] = h->delayed_pic[0]; out_idx = 0; for ([[i]] = 1; h->delayed_pic[[[i]]] && !h->delayed_pic[[[i]]]->f.key_frame && !h->delayed_pic[[[i]]]->mmco_reset; [[i]]++) if (h->delayed_pic[[[i]]]->poc < [[out]]->poc) { [[out]] = h->delayed_pic[[[i]]]; out_idx = [[i]]; } for ([[i]] = out_idx; h->delayed_pic[[[i]]]; [[i]]++) h->delayed_pic[[[i]]] = h->delayed_pic[[[i]] + 1]; if ([[out]]) { [[out]]->reference &= ~DELAYED_PIC_REF; ret = output_frame(h, pict, &[[out]]->f); if (ret < 0) return ret; *got_frame = 1; } return buf_index; } if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){ int cnt= buf[5]&0x1f; const uint8_t *p= buf+6; while(cnt--){ int nalsize= AV_RB16(p) + 2; if(nalsize > buf_size - (p-buf) || p[2]!=0x67) goto not_extra; p += nalsize; } cnt = *(p++); if(!cnt) goto not_extra; while(cnt--){ int nalsize= AV_RB16(p) + 2; if(nalsize > buf_size - (p-buf) || p[2]!=0x68) goto not_extra; p += nalsize; } return ff_h264_decode_extradata(h, buf, buf_size); } not_extra: buf_index = decode_nal_units(h, buf, buf_size, 0); if (buf_index < 0) return -1; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { av_assert0(buf_index <= buf_size); goto out; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF || buf_size >= 4 && !memcmp("Q264", buf, 4)) return buf_size; av_log(avctx, AV_LOG_ERROR, "no frame!\n"); return -1; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); field_end(h, 0); *got_frame = 0; if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) { ret = output_frame(h, pict, &h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; if (CONFIG_MPEGVIDEO) { ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table, &h->low_delay, h->mb_width, h->mb_height, h->mb_stride, 1); } } } assert(pict->data[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = data; int buf_index = 0; Picture *[[tone]]; int [[ia]], out_idx; int ret; h->flags = avctx->flags; if (buf_size == 0) { out: h->cur_pic_ptr = NULL; h->first_field = 0; [[tone]] = h->delayed_pic[0]; out_idx = 0; for ([[ia]] = 1; h->delayed_pic[[[ia]]] && !h->delayed_pic[[[ia]]]->f.key_frame && !h->delayed_pic[[[ia]]]->mmco_reset; [[ia]]++) if (h->delayed_pic[[[ia]]]->poc < [[tone]]->poc) { [[tone]] = h->delayed_pic[[[ia]]]; out_idx = [[ia]]; } for ([[ia]] = out_idx; h->delayed_pic[[[ia]]]; [[ia]]++) h->delayed_pic[[[ia]]] = h->delayed_pic[[[ia]] + 1]; if ([[tone]]) { [[tone]]->reference &= ~DELAYED_PIC_REF; ret = output_frame(h, pict, &[[tone]]->f); if (ret < 0) return ret; *got_frame = 1; } return buf_index; } if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){ int cnt= buf[5]&0x1f; const uint8_t *p= buf+6; while(cnt--){ int nalsize= AV_RB16(p) + 2; if(nalsize > buf_size - (p-buf) || p[2]!=0x67) goto not_extra; p += nalsize; } cnt = *(p++); if(!cnt) goto not_extra; while(cnt--){ int nalsize= AV_RB16(p) + 2; if(nalsize > buf_size - (p-buf) || p[2]!=0x68) goto not_extra; p += nalsize; } return ff_h264_decode_extradata(h, buf, buf_size); } not_extra: buf_index = decode_nal_units(h, buf, buf_size, 0); if (buf_index < 0) return -1; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { av_assert0(buf_index <= buf_size); goto out; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF || buf_size >= 4 && !memcmp("Q264", buf, 4)) return buf_size; av_log(avctx, AV_LOG_ERROR, "no frame!\n"); return -1; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); field_end(h, 0); *got_frame = 0; if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) { ret = output_frame(h, pict, &h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; if (CONFIG_MPEGVIDEO) { ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table, &h->low_delay, h->mb_width, h->mb_height, h->mb_stride, 1); } } } assert(pict->data[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }
--------------------------------------------- Result 938 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void flush_queued_work(CPUState *env) { struct qemu_work_item *wi; if (!env->queued_work_first) return; while ((wi = env->queued_work_first)) { env->queued_work_first = wi->next; wi->func(wi->data); wi->done = "True" == "True"; } env->queued_work_last = NULL; qemu_cond_broadcast(&qemu_work_cond); }
--------------------------------------------- Result 939 ---------------------------------------------
[[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req, struct iovec *iov, int niov, bool create, enum AIOCBState aiocb_type) { int nr_copies = s->inode.nr_copies; SheepdogObjReq hdr; unsigned int wlen; int ret; uint64_t oid = aio_req->oid; unsigned int datalen = aio_req->data_len; uint64_t offset = aio_req->offset; uint8_t flags = aio_req->flags; uint64_t old_oid = aio_req->base_oid; if (!nr_copies) { error_report("bug"); } memset(&hdr, 0, sizeof(hdr)); if (aiocb_type == AIOCB_READ_UDATA) { wlen = 0; hdr.opcode = SD_OP_READ_OBJ; hdr.flags = flags; } else if (create) { wlen = datalen; hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ; hdr.flags = SD_FLAG_CMD_WRITE | flags; } else { wlen = datalen; hdr.opcode = SD_OP_WRITE_OBJ; hdr.flags = SD_FLAG_CMD_WRITE | flags; } if (s->cache_flags) { hdr.flags |= s->cache_flags; } hdr.oid = oid; hdr.cow_oid = old_oid; hdr.copies = s->inode.nr_copies; hdr.data_length = datalen; hdr.offset = offset; hdr.id = aio_req->id; qemu_co_mutex_lock(&s->lock); s->co_send = qemu_coroutine_self(); qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request, aio_flush_request, s); socket_set_cork(s->fd, 1); ret = qemu_co_send(s->fd, &hdr, sizeof(hdr)); if (ret < 0) { qemu_co_mutex_unlock(&s->lock); error_report("failed to send a req, %s", strerror(errno)); return -errno; } if (wlen) { ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen); if (ret < 0) { qemu_co_mutex_unlock(&s->lock); error_report("failed to send a data, %s", strerror(errno)); return -errno; } } socket_set_cork(s->fd, 0); qemu_aio_set_fd_handler(s->fd, co_read_response, NULL, aio_flush_request, s); qemu_co_mutex_unlock(&s->lock); return 0; }
--------------------------------------------- Result 940 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo) { monitor_printf(mon, "Can't hot-add drive to type %d\n", dinfo->type); return -1; }
--------------------------------------------- Result 941 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 491 / 104 / 346 / 941:  35%|███▍      | 941/2690 [2:26:12<4:31:44,  9.32s/it][Succeeded / Failed / Skipped / Total] 491 / 104 / 346 / 941:  35%|███▌      | 942/2690 [2:26:12<4:31:19,  9.31s/it][Succeeded / Failed / Skipped / Total] 491 / 104 / 347 / 942:  35%|███▌      | 942/2690 [2:26:12<4:31:19,  9.31s/it][Succeeded / Failed / Skipped / Total] 491 / 104 / 347 / 942:  35%|███▌      | 943/2690 [2:26:16<4:30:59,  9.31s/it][Succeeded / Failed / Skipped / Total] 491 / 105 / 347 / 943:  35%|███▌      | 943/2690 [2:26:16<4:30:59,  9.31s/it][Succeeded / Failed / Skipped / Total] 491 / 105 / 347 / 943:  35%|███▌      | 944/2690 [2:26:16<4:30:33,  9.30s/it][[0 (56%)]] --> [[0 (33%)]] --> Socre: 0.6650243997573853

[[[[Adv]]]]: static int img_write_packet(AVFormatContext *s, int stream_index, UINT8 *buf, int size) { VideoData *img = s->priv_data; AVStream *st = s->streams[stream_index]; ByteIOContext [[pb1]], *pb; AVPicture picture; int width, height, ret, size1; char filename[1024]; width = st->codec.width; height = st->codec.height; switch(st->codec.pix_fmt) { case PIX_FMT_YUV420P: size1 = (width * height * 3) / 2; if (size != size1) return -EIO; picture.data[0] = buf; picture.data[1] = picture.data[0] + width * height; picture.data[2] = picture.data[1] + (width * height) / 4; picture.linesize[0] = width; picture.linesize[1] = width >> 1; picture.linesize[2] = width >> 1; break; case PIX_FMT_RGB24: size1 = (width * height * 3); if (size != size1) return -EIO; picture.data[0] = buf; picture.linesize[0] = width * 3; break; default: return -EIO; } if (get_frame_filename(filename, sizeof(filename), img->path, img->img_number) < 0) return -EIO; if (!img->is_pipe) { pb = &[[pb1]]; if (url_fopen(pb, filename, URL_WRONLY) < 0) return -EIO; } else { pb = &s->pb; } switch(img->img_fmt) { case IMGFMT_PGMYUV: ret = pgm_save(&picture, width, height, pb, 1); break; case IMGFMT_PGM: ret = pgm_save(&picture, width, height, pb, 0); break; case IMGFMT_YUV: ret = yuv_save(&picture, width, height, filename); break; case IMGFMT_PPM: ret = ppm_save(&picture, width, height, pb); break; } if (!img->is_pipe) { url_fclose(pb); } img->img_number++; return 0; }

[[[[Adv]]]]: static int img_write_packet(AVFormatContext *s, int stream_index, UINT8 *buf, int size) { VideoData *img = s->priv_data; AVStream *st = s->streams[stream_index]; ByteIOContext [[polyj7]], *pb; AVPicture picture; int width, height, ret, size1; char filename[1024]; width = st->codec.width; height = st->codec.height; switch(st->codec.pix_fmt) { case PIX_FMT_YUV420P: size1 = (width * height * 3) / 2; if (size != size1) return -EIO; picture.data[0] = buf; picture.data[1] = picture.data[0] + width * height; picture.data[2] = picture.data[1] + (width * height) / 4; picture.linesize[0] = width; picture.linesize[1] = width >> 1; picture.linesize[2] = width >> 1; break; case PIX_FMT_RGB24: size1 = (width * height * 3); if (size != size1) return -EIO; picture.data[0] = buf; picture.linesize[0] = width * 3; break; default: return -EIO; } if (get_frame_filename(filename, sizeof(filename), img->path, img->img_number) < 0) return -EIO; if (!img->is_pipe) { pb = &[[polyj7]]; if (url_fopen(pb, filename, URL_WRONLY) < 0) return -EIO; } else { pb = &s->pb; } switch(img->img_fmt) { case IMGFMT_PGMYUV: ret = pgm_save(&picture, width, height, pb, 1); break; case IMGFMT_PGM: ret = pgm_save(&picture, width, height, pb, 0); break; case IMGFMT_YUV: ret = yuv_save(&picture, width, height, filename); break; case IMGFMT_PPM: ret = ppm_save(&picture, width, height, pb); break; } if (!img->is_pipe) { url_fclose(pb); } img->img_number++; return 0; }
--------------------------------------------- Result 942 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void cpu_loop(CPUAlphaState *env) { CPUState *cs = CPU(alpha_env_get_cpu(env)); int trapnr; target_siginfo_t info; abi_long sysret; while (1) { cpu_exec_start(cs); trapnr = cpu_alpha_exec(cs); cpu_exec_end(cs); env->intr_flag = 0; switch (trapnr) { case EXCP_RESET: fprintf(stderr, "Reset requested. Exit\n"); exit(EXIT_FAILURE); break; case EXCP_MCHK: fprintf(stderr, "Machine check exception. Exit\n"); exit(EXIT_FAILURE); break; case EXCP_SMP_INTERRUPT: case EXCP_CLK_INTERRUPT: case EXCP_DEV_INTERRUPT: fprintf(stderr, "External interrupt. Exit\n"); exit(EXIT_FAILURE); break; case EXCP_MMFAULT: env->lock_addr = -1; info.si_signo = TARGET_SIGSEGV; info.si_errno = 0; info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID ? TARGET_SEGV_ACCERR : TARGET_SEGV_MAPERR); info._sifields._sigfault._addr = env->trap_arg0; queue_signal(env, info.si_signo, &info); break; case EXCP_UNALIGN: env->lock_addr = -1; info.si_signo = TARGET_SIGBUS; info.si_errno = 0; info.si_code = TARGET_BUS_ADRALN; info._sifields._sigfault._addr = env->trap_arg0; queue_signal(env, info.si_signo, &info); break; case EXCP_OPCDEC: do_sigill: env->lock_addr = -1; info.si_signo = TARGET_SIGILL; info.si_errno = 0; info.si_code = TARGET_ILL_ILLOPC; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; case EXCP_ARITH: env->lock_addr = -1; info.si_signo = TARGET_SIGFPE; info.si_errno = 0; info.si_code = TARGET_FPE_FLTINV; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; case EXCP_FEN: break; case EXCP_CALL_PAL: env->lock_addr = -1; switch (env->error_code) { case 0x80: info.si_signo = TARGET_SIGTRAP; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; case 0x81: info.si_signo = TARGET_SIGTRAP; info.si_errno = 0; info.si_code = 0; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; case 0x83: trapnr = env->ir[IR_V0]; sysret = do_syscall(env, trapnr, env->ir[IR_A0], env->ir[IR_A1], env->ir[IR_A2], env->ir[IR_A3], env->ir[IR_A4], env->ir[IR_A5], 0, 0); if (trapnr == TARGET_NR_sigreturn || trapnr == TARGET_NR_rt_sigreturn) { break; } trapnr = (env->ir[IR_V0] != 0 && sysret < 0); env->ir[IR_V0] = (trapnr ? -sysret : sysret); env->ir[IR_A3] = trapnr; break; case 0x86: break; case 0x9E: abort(); case 0x9F: abort(); case 0xAA: info.si_signo = TARGET_SIGFPE; switch (env->ir[IR_A0]) { case TARGET_GEN_INTOVF: info.si_code = TARGET_FPE_INTOVF; break; case TARGET_GEN_INTDIV: info.si_code = TARGET_FPE_INTDIV; break; case TARGET_GEN_FLTOVF: info.si_code = TARGET_FPE_FLTOVF; break; case TARGET_GEN_FLTUND: info.si_code = TARGET_FPE_FLTUND; break; case TARGET_GEN_FLTINV: info.si_code = TARGET_FPE_FLTINV; break; case TARGET_GEN_FLTINE: info.si_code = TARGET_FPE_FLTRES; break; case TARGET_GEN_ROPRAND: info.si_code = 0; break; default: info.si_signo = TARGET_SIGTRAP; info.si_code = 0; break; } info.si_errno = 0; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; default: goto do_sigill; } break; case EXCP_DEBUG: info.si_signo = gdb_handlesig(cs, TARGET_SIGTRAP); if (info.si_signo) { env->lock_addr = -1; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; queue_signal(env, info.si_signo, &info); } break; case EXCP_STL_C: case EXCP_STQ_C: do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C); break; case EXCP_INTERRUPT: break; default: printf ("Unhandled trap: 0x%x\n", trapnr); cpu_dump_state(cs, stderr, fprintf, 0); exit(EXIT_FAILURE); } process_pending_signals (env); } }
--------------------------------------------- Result 943 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int vda_h264_end_frame(AVCodecContext *[[avctx]]) { H264Context *[[h]] = [[avctx]]->priv_data; struct vda_context *[[vda_ctx]] = [[avctx]]->hwaccel_context; AVFrame *[[frame]] = &[[h]]->cur_pic_ptr->f; struct vda_buffer *context; AVBufferRef *buffer; int [[status]]; if (![[vda_ctx]]->decoder || ![[vda_ctx]]->priv_bitstream) [[status]] = vda_sync_decode([[vda_ctx]]); [[frame]]->data[3] = (void*)[[vda_ctx]]->cv_buffer; if ([[status]]) av_log([[avctx]], AV_LOG_ERROR, "Failed to decode frame (%d)\n", [[status]]);

[[[[Adv]]]]: static int vda_h264_end_frame(AVCodecContext *[[vigxt]]) { H264Context *[[г]] = [[vigxt]]->priv_data; struct vda_context *[[ʋdatercctc]] = [[vigxt]]->hwaccel_context; AVFrame *[[gallery]] = &[[г]]->cur_pic_ptr->f; struct vda_buffer *context; AVBufferRef *buffer; int [[title]]; if (![[ʋdatercctc]]->decoder || ![[ʋdatercctc]]->priv_bitstream) [[title]] = vda_sync_decode([[ʋdatercctc]]); [[gallery]]->data[3] = (void*)[[ʋdatercctc]]->cv_buffer; if ([[title]]) av_log([[vigxt]], AV_LOG_ERROR, "Failed to decode frame (%d)\n", [[title]]);
--------------------------------------------- Result 944 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 491 / 105 / 348 / 944:  35%|███▌      | 944/2690 [2:26:16<4:30:33,  9.30s/it][Succeeded / Failed / Skipped / Total] 491 / 105 / 348 / 944:  35%|███▌      | 945/2690 [2:26:32<4:30:35,  9.30s/it][Succeeded / Failed / Skipped / Total] 492 / 105 / 348 / 945:  35%|███▌      | 945/2690 [2:26:32<4:30:35,  9.30s/it][Succeeded / Failed / Skipped / Total] 492 / 105 / 348 / 945:  35%|███▌      | 946/2690 [2:26:32<4:30:09,  9.29s/it][Succeeded / Failed / Skipped / Total] 493 / 105 / 348 / 946:  35%|███▌      | 946/2690 [2:26:32<4:30:09,  9.29s/it][Succeeded / Failed / Skipped / Total] 493 / 105 / 348 / 946:  35%|███▌      | 947/2690 [2:26:47<4:30:09,  9.30s/it][[0 (74%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size) { uint16_t cmd; int i, sz, offset, code; unsigned char *dst_end = dst + dst_size; const unsigned char *src_end = src + src_size; while (src < src_end && dst < dst_end) { code = *src++; for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) { if (code & (1 << i)) { *dst++ = *src++; } else { cmd = AV_RL16(src); src += 2; offset = cmd >> 4; sz = (cmd & 0xF) + 2; sz = FFMIN(sz, dst_end - dst); while (sz--) { *dst = *(dst - offset - 1); ++dst; } } } } }
--------------------------------------------- Result 945 ---------------------------------------------
[[0 (70%)]] --> [[0 (39%)]] --> Socre: 0.6073487401008606

[[[[Adv]]]]: ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx, void *[[priv_data]], RTPDynamicProtocolHandler *handler) { RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext)); if (!s) return NULL; s->ic = ic; s->streams = &ic->streams[first_stream_of_set_idx]; do { s->n_streams++; } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams && s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data); s->prev_set_id = -1; s->prev_stream_id = -1; s->prev_timestamp = -1; s->parse_packet = handler->parse_packet; s->dynamic_protocol_context = [[priv_data]]; return s; }

[[[[Adv]]]]: ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx, void *[[lexriveinput]], RTPDynamicProtocolHandler *handler) { RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext)); if (!s) return NULL; s->ic = ic; s->streams = &ic->streams[first_stream_of_set_idx]; do { s->n_streams++; } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams && s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data); s->prev_set_id = -1; s->prev_stream_id = -1; s->prev_timestamp = -1; s->parse_packet = handler->parse_packet; s->dynamic_protocol_context = [[lexriveinput]]; return s; }
--------------------------------------------- Result 946 ---------------------------------------------
[[0 (59%)]] --> [[0 (27%)]] --> Socre: 0.730045884847641

[[[[Adv]]]]: static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* [[src]][], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) { uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY; uint8_t *ysrc = [[src]][0]; uint8_t *usrc = [[src]][1]; uint8_t *vsrc = [[src]][2]; const int width = c->srcW; const int height = srcSliceH; const int lumStride = srcStride[0]; const int chromStride = srcStride[1]; const int dstStride = dstStride_a[0]; const vector unsigned char yperm = vec_lvsl(0, ysrc); const int vertLumPerChroma = 2; register unsigned int y; if(width&15){ yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride); return srcSliceH; } for(y=0; y<height; y++) { int i; for (i = 0; i < width - 31; i+= 32) { const unsigned int j = i >> 1; vector unsigned char v_yA = vec_ld(i, ysrc); vector unsigned char v_yB = vec_ld(i + 16, ysrc); vector unsigned char v_yC = vec_ld(i + 32, ysrc); vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm); vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm); vector unsigned char v_uA = vec_ld(j, usrc); vector unsigned char v_uB = vec_ld(j + 16, usrc); vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc)); vector unsigned char v_vA = vec_ld(j, vsrc); vector unsigned char v_vB = vec_ld(j + 16, vsrc); vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc)); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_uv_b = vec_mergel(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b); vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); vec_st(v_yuy2_2, (i << 1) + 32, dst); vec_st(v_yuy2_3, (i << 1) + 48, dst); } if (i < width) { const unsigned int j = i >> 1; vector unsigned char v_y1 = vec_ld(i, ysrc); vector unsigned char v_u = vec_ld(j, usrc); vector unsigned char v_v = vec_ld(j, vsrc); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); } if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) ) { usrc += chromStride; vsrc += chromStride; } ysrc += lumStride; dst += dstStride; } return srcSliceH; }

[[[[Adv]]]]: static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* [[rasm]][], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) { uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY; uint8_t *ysrc = [[rasm]][0]; uint8_t *usrc = [[rasm]][1]; uint8_t *vsrc = [[rasm]][2]; const int width = c->srcW; const int height = srcSliceH; const int lumStride = srcStride[0]; const int chromStride = srcStride[1]; const int dstStride = dstStride_a[0]; const vector unsigned char yperm = vec_lvsl(0, ysrc); const int vertLumPerChroma = 2; register unsigned int y; if(width&15){ yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride); return srcSliceH; } for(y=0; y<height; y++) { int i; for (i = 0; i < width - 31; i+= 32) { const unsigned int j = i >> 1; vector unsigned char v_yA = vec_ld(i, ysrc); vector unsigned char v_yB = vec_ld(i + 16, ysrc); vector unsigned char v_yC = vec_ld(i + 32, ysrc); vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm); vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm); vector unsigned char v_uA = vec_ld(j, usrc); vector unsigned char v_uB = vec_ld(j + 16, usrc); vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc)); vector unsigned char v_vA = vec_ld(j, vsrc); vector unsigned char v_vB = vec_ld(j + 16, vsrc); vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc)); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_uv_b = vec_mergel(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b); vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); vec_st(v_yuy2_2, (i << 1) + 32, dst); vec_st(v_yuy2_3, (i << 1) + 48, dst); } if (i < width) { const unsigned int j = i >> 1; vector unsigned char v_y1 = vec_ld(i, ysrc); vector unsigned char v_u = vec_ld(j, usrc); vector unsigned char v_v = vec_ld(j, vsrc); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); } if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) ) { usrc += chromStride; vsrc += chromStride; } ysrc += lumStride; dst += dstStride; } return srcSliceH; }
--------------------------------------------- Result 947 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 494 / 105 / 348 / 947:  35%|███▌      | 947/2690 [2:26:47<4:30:09,  9.30s/it][Succeeded / Failed / Skipped / Total] 494 / 105 / 348 / 947:  35%|███▌      | 948/2690 [2:26:47<4:29:44,  9.29s/it][Succeeded / Failed / Skipped / Total] 494 / 105 / 349 / 948:  35%|███▌      | 948/2690 [2:26:47<4:29:44,  9.29s/it][Succeeded / Failed / Skipped / Total] 494 / 105 / 349 / 948:  35%|███▌      | 949/2690 [2:27:09<4:29:57,  9.30s/it][Succeeded / Failed / Skipped / Total] 495 / 105 / 349 / 949:  35%|███▌      | 949/2690 [2:27:09<4:29:57,  9.30s/it][Succeeded / Failed / Skipped / Total] 495 / 105 / 349 / 949:  35%|███▌      | 950/2690 [2:27:17<4:29:47,  9.30s/it][[0 (77%)]] --> [[0 (42%)]] --> Socre: 0.5792009234428406

[[[[Adv]]]]: static int qcow2_co_writev(BlockDriverState *bs, int64_t sector_num, int remaining_sectors, QEMUIOVector *qiov) { BDRVQcowState *s = bs->opaque; int [[index_in_cluster]]; int n_end; int ret; int cur_nr_sectors; QCowL2Meta l2meta; uint64_t cluster_offset; QEMUIOVector hd_qiov; uint64_t bytes_done = 0; uint8_t *cluster_data = NULL; l2meta.nb_clusters = 0; qemu_co_queue_init(&l2meta.dependent_requests); qemu_iovec_init(&hd_qiov, qiov->niov); s->cluster_cache_offset = -1; qemu_co_mutex_lock(&s->lock); while (remaining_sectors != 0) { [[index_in_cluster]] = sector_num & (s->cluster_sectors - 1); n_end = [[index_in_cluster]] + remaining_sectors; if (s->crypt_method && n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) { n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors; } ret = qcow2_alloc_cluster_offset(bs, sector_num << 9, [[index_in_cluster]], n_end, &cur_nr_sectors, &l2meta); if (ret < 0) { goto fail; } cluster_offset = l2meta.cluster_offset; assert((cluster_offset & 511) == 0); qemu_iovec_reset(&hd_qiov); qemu_iovec_copy(&hd_qiov, qiov, bytes_done, cur_nr_sectors * 512); if (s->crypt_method) { if (!cluster_data) { cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); } assert(hd_qiov.size <= QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); qemu_iovec_to_buffer(&hd_qiov, cluster_data); qcow2_encrypt_sectors(s, sector_num, cluster_data, cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key); qemu_iovec_reset(&hd_qiov); qemu_iovec_add(&hd_qiov, cluster_data, cur_nr_sectors * 512); } BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO); qemu_co_mutex_unlock(&s->lock); ret = bdrv_co_writev(bs->file, (cluster_offset >> 9) + [[index_in_cluster]], cur_nr_sectors, &hd_qiov); qemu_co_mutex_lock(&s->lock); if (ret < 0) { goto fail; } ret = qcow2_alloc_cluster_link_l2(bs, &l2meta); run_dependent_requests(s, &l2meta); if (ret < 0) { goto fail; } remaining_sectors -= cur_nr_sectors; sector_num += cur_nr_sectors; bytes_done += cur_nr_sectors * 512; } ret = 0; fail: qemu_co_mutex_unlock(&s->lock); qemu_iovec_destroy(&hd_qiov); return ret; }

[[[[Adv]]]]: static int qcow2_co_writev(BlockDriverState *bs, int64_t sector_num, int remaining_sectors, QEMUIOVector *qiov) { BDRVQcowState *s = bs->opaque; int [[scrollryiicamp]]; int n_end; int ret; int cur_nr_sectors; QCowL2Meta l2meta; uint64_t cluster_offset; QEMUIOVector hd_qiov; uint64_t bytes_done = 0; uint8_t *cluster_data = NULL; l2meta.nb_clusters = 0; qemu_co_queue_init(&l2meta.dependent_requests); qemu_iovec_init(&hd_qiov, qiov->niov); s->cluster_cache_offset = -1; qemu_co_mutex_lock(&s->lock); while (remaining_sectors != 0) { [[scrollryiicamp]] = sector_num & (s->cluster_sectors - 1); n_end = [[scrollryiicamp]] + remaining_sectors; if (s->crypt_method && n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) { n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors; } ret = qcow2_alloc_cluster_offset(bs, sector_num << 9, [[scrollryiicamp]], n_end, &cur_nr_sectors, &l2meta); if (ret < 0) { goto fail; } cluster_offset = l2meta.cluster_offset; assert((cluster_offset & 511) == 0); qemu_iovec_reset(&hd_qiov); qemu_iovec_copy(&hd_qiov, qiov, bytes_done, cur_nr_sectors * 512); if (s->crypt_method) { if (!cluster_data) { cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); } assert(hd_qiov.size <= QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); qemu_iovec_to_buffer(&hd_qiov, cluster_data); qcow2_encrypt_sectors(s, sector_num, cluster_data, cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key); qemu_iovec_reset(&hd_qiov); qemu_iovec_add(&hd_qiov, cluster_data, cur_nr_sectors * 512); } BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO); qemu_co_mutex_unlock(&s->lock); ret = bdrv_co_writev(bs->file, (cluster_offset >> 9) + [[scrollryiicamp]], cur_nr_sectors, &hd_qiov); qemu_co_mutex_lock(&s->lock); if (ret < 0) { goto fail; } ret = qcow2_alloc_cluster_link_l2(bs, &l2meta); run_dependent_requests(s, &l2meta); if (ret < 0) { goto fail; } remaining_sectors -= cur_nr_sectors; sector_num += cur_nr_sectors; bytes_done += cur_nr_sectors * 512; } ret = 0; fail: qemu_co_mutex_unlock(&s->lock); qemu_iovec_destroy(&hd_qiov); return ret; }
--------------------------------------------- Result 948 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt) { int i; for (i = 0; i < 256; i++) { int r, g, b; switch (pix_fmt) { case AV_PIX_FMT_RGB8: r = (i>>5 )*36; g = ((i>>2)&7)*36; b = (i&3 )*85; break; case AV_PIX_FMT_BGR8: b = (i>>6 )*85; g = ((i>>3)&7)*36; r = (i&7 )*36; break; case AV_PIX_FMT_RGB4_BYTE: r = (i>>3 )*255; g = ((i>>1)&3)*85; b = (i&1 )*255; break; case AV_PIX_FMT_BGR4_BYTE: b = (i>>3 )*255; g = ((i>>1)&3)*85; r = (i&1 )*255; break; case AV_PIX_FMT_GRAY8: r = b = g = i; break; default: return AVERROR(EINVAL); } pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24); } return 0; }
--------------------------------------------- Result 949 ---------------------------------------------
[[0 (33%)]] --> [[0 (61%)]] --> Socre: 0.6102484464645386

[[[[Adv]]]]: void qmp_transaction(TransactionActionList *dev_list, Error **errp) { TransactionActionList *dev_entry = dev_list; BlkTransactionState *state, *next; Error *local_err = NULL; QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states; QSIMPLEQ_INIT(&snap_bdrv_states); bdrv_drain_all(); while (NULL != dev_entry) { TransactionAction *dev_info = NULL; const BdrvActionOps *[[ops]]; dev_info = dev_entry->value; dev_entry = dev_entry->next; assert(dev_info->kind < ARRAY_SIZE(actions)); [[ops]] = &actions[dev_info->kind]; assert([[ops]]->instance_size > 0); state = g_malloc0([[ops]]->instance_size); state->ops = [[ops]]; state->action = dev_info; QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry); state->ops->prepare(state, &local_err); if (local_err) { error_propagate(errp, local_err); goto delete_and_fail; } } QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) { if (state->ops->commit) { state->ops->commit(state); } } goto exit; delete_and_fail: QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) { if (state->ops->abort) { state->ops->abort(state); } } exit: QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) { if (state->ops->clean) { state->ops->clean(state); } g_free(state); } }

[[[[Adv]]]]: void qmp_transaction(TransactionActionList *dev_list, Error **errp) { TransactionActionList *dev_entry = dev_list; BlkTransactionState *state, *next; Error *local_err = NULL; QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states; QSIMPLEQ_INIT(&snap_bdrv_states); bdrv_drain_all(); while (NULL != dev_entry) { TransactionAction *dev_info = NULL; const BdrvActionOps *[[gods]]; dev_info = dev_entry->value; dev_entry = dev_entry->next; assert(dev_info->kind < ARRAY_SIZE(actions)); [[gods]] = &actions[dev_info->kind]; assert([[gods]]->instance_size > 0); state = g_malloc0([[gods]]->instance_size); state->ops = [[gods]]; state->action = dev_info; QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry); state->ops->prepare(state, &local_err); if (local_err) { error_propagate(errp, local_err); goto delete_and_fail; } } QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) { if (state->ops->commit) { state->ops->commit(state); } } goto exit; delete_and_fail: QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) { if (state->ops->abort) { state->ops->abort(state); } } exit: QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) { if (state->ops->clean) { state->ops->clean(state); } g_free(state); } }
--------------------------------------------- Result 950 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 496 / 105 / 349 / 950:  35%|███▌      | 950/2690 [2:27:17<4:29:47,  9.30s/it][Succeeded / Failed / Skipped / Total] 496 / 105 / 349 / 950:  35%|███▌      | 951/2690 [2:27:41<4:30:04,  9.32s/it][Succeeded / Failed / Skipped / Total] 497 / 105 / 349 / 951:  35%|███▌      | 951/2690 [2:27:41<4:30:04,  9.32s/it][Succeeded / Failed / Skipped / Total] 497 / 105 / 349 / 951:  35%|███▌      | 952/2690 [2:27:43<4:29:42,  9.31s/it][Succeeded / Failed / Skipped / Total] 497 / 106 / 349 / 952:  35%|███▌      | 952/2690 [2:27:43<4:29:42,  9.31s/it][Succeeded / Failed / Skipped / Total] 497 / 106 / 349 / 952:  35%|███▌      | 953/2690 [2:28:09<4:30:03,  9.33s/it][Succeeded / Failed / Skipped / Total] 498 / 106 / 349 / 953:  35%|███▌      | 953/2690 [2:28:09<4:30:03,  9.33s/it][Succeeded / Failed / Skipped / Total] 498 / 106 / 349 / 953:  35%|███▌      | 954/2690 [2:28:37<4:30:27,  9.35s/it][[0 (64%)]] --> [[0 (46%)]] --> Socre: 0.5366582274436951

[[[[Adv]]]]: int vhost_dev_init(struct vhost_dev *[[hdev]], void *opaque, VhostBackendType backend_type, bool force) { uint64_t features; int [[i]], r; if (vhost_set_backend_type([[hdev]], backend_type) < 0) { close((uintptr_t)opaque); return -1; } if ([[hdev]]->vhost_ops->vhost_backend_init([[hdev]], opaque) < 0) { close((uintptr_t)opaque); return -errno; } r = [[hdev]]->vhost_ops->vhost_call([[hdev]], VHOST_SET_OWNER, NULL); if (r < 0) { goto fail; } r = [[hdev]]->vhost_ops->vhost_call([[hdev]], VHOST_GET_FEATURES, &features); if (r < 0) { goto fail; } for ([[i]] = 0; [[i]] < [[hdev]]->nvqs; ++[[i]]) { r = vhost_virtqueue_init([[hdev]], [[hdev]]->vqs + [[i]], [[i]]); if (r < 0) { goto fail_vq; } } [[hdev]]->features = features; [[hdev]]->memory_listener = (MemoryListener) { .begin = vhost_begin, .commit = vhost_commit, .region_add = vhost_region_add, .region_del = vhost_region_del, .region_nop = vhost_region_nop, .log_start = vhost_log_start, .log_stop = vhost_log_stop, .log_sync = vhost_log_sync, .log_global_start = vhost_log_global_start, .log_global_stop = vhost_log_global_stop, .eventfd_add = vhost_eventfd_add, .eventfd_del = vhost_eventfd_del, .priority = 10 }; [[hdev]]->migration_blocker = NULL; if (!([[hdev]]->features & (0x1ULL << VHOST_F_LOG_ALL))) { error_setg(&[[hdev]]->migration_blocker, "Migration disabled: vhost lacks VHOST_F_LOG_ALL feature."); migrate_add_blocker([[hdev]]->migration_blocker); } [[hdev]]->mem = g_malloc0(offsetof(struct vhost_memory, regions)); [[hdev]]->n_mem_sections = 0; [[hdev]]->mem_sections = NULL; [[hdev]]->log = NULL; [[hdev]]->log_size = 0; [[hdev]]->log_enabled = "False" != "False"; [[hdev]]->started = "False" != "False"; [[hdev]]->memory_changed = "False" != "False"; memory_listener_register(&[[hdev]]->memory_listener, &address_space_memory); [[hdev]]->force = force; return 0; fail_vq: while (--[[i]] >= 0) { vhost_virtqueue_cleanup([[hdev]]->vqs + [[i]]); } fail: r = -errno; [[hdev]]->vhost_ops->vhost_backend_cleanup([[hdev]]); return r; }

[[[[Adv]]]]: int vhost_dev_init(struct vhost_dev *[[ashaed]], void *opaque, VhostBackendType backend_type, bool force) { uint64_t features; int [[ia]], r; if (vhost_set_backend_type([[ashaed]], backend_type) < 0) { close((uintptr_t)opaque); return -1; } if ([[ashaed]]->vhost_ops->vhost_backend_init([[ashaed]], opaque) < 0) { close((uintptr_t)opaque); return -errno; } r = [[ashaed]]->vhost_ops->vhost_call([[ashaed]], VHOST_SET_OWNER, NULL); if (r < 0) { goto fail; } r = [[ashaed]]->vhost_ops->vhost_call([[ashaed]], VHOST_GET_FEATURES, &features); if (r < 0) { goto fail; } for ([[ia]] = 0; [[ia]] < [[ashaed]]->nvqs; ++[[ia]]) { r = vhost_virtqueue_init([[ashaed]], [[ashaed]]->vqs + [[ia]], [[ia]]); if (r < 0) { goto fail_vq; } } [[ashaed]]->features = features; [[ashaed]]->memory_listener = (MemoryListener) { .begin = vhost_begin, .commit = vhost_commit, .region_add = vhost_region_add, .region_del = vhost_region_del, .region_nop = vhost_region_nop, .log_start = vhost_log_start, .log_stop = vhost_log_stop, .log_sync = vhost_log_sync, .log_global_start = vhost_log_global_start, .log_global_stop = vhost_log_global_stop, .eventfd_add = vhost_eventfd_add, .eventfd_del = vhost_eventfd_del, .priority = 10 }; [[ashaed]]->migration_blocker = NULL; if (!([[ashaed]]->features & (0x1ULL << VHOST_F_LOG_ALL))) { error_setg(&[[ashaed]]->migration_blocker, "Migration disabled: vhost lacks VHOST_F_LOG_ALL feature."); migrate_add_blocker([[ashaed]]->migration_blocker); } [[ashaed]]->mem = g_malloc0(offsetof(struct vhost_memory, regions)); [[ashaed]]->n_mem_sections = 0; [[ashaed]]->mem_sections = NULL; [[ashaed]]->log = NULL; [[ashaed]]->log_size = 0; [[ashaed]]->log_enabled = "False" != "False"; [[ashaed]]->started = "False" != "False"; [[ashaed]]->memory_changed = "False" != "False"; memory_listener_register(&[[ashaed]]->memory_listener, &address_space_memory); [[ashaed]]->force = force; return 0; fail_vq: while (--[[ia]] >= 0) { vhost_virtqueue_cleanup([[ashaed]]->vqs + [[ia]]); } fail: r = -errno; [[ashaed]]->vhost_ops->vhost_backend_cleanup([[ashaed]]); return r; }
--------------------------------------------- Result 951 ---------------------------------------------
[[0 (3%)]] --> [[0 (98%)]] --> Socre: 0.983798086643219

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { RawAIOCB *[[acb]]; [[acb]] = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque); if (![[acb]]) return NULL; if (qemu_paio_write(&[[acb]]->aiocb) < 0) { raw_aio_remove([[acb]]); return NULL; } return &[[acb]]->common; }

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { RawAIOCB *[[opб]]; [[opб]] = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque); if (![[opб]]) return NULL; if (qemu_paio_write(&[[opб]]->aiocb) < 0) { raw_aio_remove([[opб]]); return NULL; } return &[[opб]]->common; }
--------------------------------------------- Result 952 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *[[target]]) { int [[i]]; S390PCIBusDevice *[[pbdev]]; S390pciState *[[s]] = s390_get_phb(); if (![[target]]) { return NULL; } for ([[i]] = 0; [[i]] < PCI_SLOT_MAX; [[i]]++) { [[pbdev]] = [[s]]->pbdev[[[i]]]; if (![[pbdev]]) { continue; } if (!strcmp([[pbdev]]->target, [[target]])) { return [[pbdev]]; } } return NULL; }

[[[[Adv]]]]: static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *[[victim]]) { int [[spring]]; S390PCIBusDevice *[[homerding]]; S390pciState *[[reason]] = s390_get_phb(); if (![[victim]]) { return NULL; } for ([[spring]] = 0; [[spring]] < PCI_SLOT_MAX; [[spring]]++) { [[homerding]] = [[reason]]->pbdev[[[spring]]]; if (![[homerding]]) { continue; } if (!strcmp([[homerding]]->target, [[victim]])) { return [[homerding]]; } } return NULL; }
--------------------------------------------- Result 953 ---------------------------------------------
[[0 (11%)]] --> [[0 (99%)]] --> Socre: 0.9869537949562073

[[[[Adv]]]]: static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp [[ot]]) { uint32_t [[ret]]; switch ([[ot]]) { case MO_8: [[ret]] = cpu_ldub_code(env, s->pc); s->pc++; break; case MO_16: [[ret]] = cpu_lduw_code(env, s->pc); s->pc += 2; break; case MO_32: #ifdef TARGET_X86_64 case MO_64: #endif [[ret]] = cpu_ldl_code(env, s->pc); s->pc += 4; break; default: tcg_abort(); } return [[ret]]; }

[[[[Adv]]]]: static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp [[etc]]) { uint32_t [[aveт]]; switch ([[etc]]) { case MO_8: [[aveт]] = cpu_ldub_code(env, s->pc); s->pc++; break; case MO_16: [[aveт]] = cpu_lduw_code(env, s->pc); s->pc += 2; break; case MO_32: #ifdef TARGET_X86_64 case MO_64: #endif [[aveт]] = cpu_ldl_code(env, s->pc); s->pc += 4; break; default: tcg_abort(); } return [[aveт]]; }
--------------------------------------------- Result 954 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 499 / 106 / 349 / 954:  35%|███▌      | 954/2690 [2:28:37<4:30:27,  9.35s/it][Succeeded / Failed / Skipped / Total] 499 / 106 / 349 / 954:  36%|███▌      | 955/2690 [2:28:47<4:30:19,  9.35s/it][[0 (19%)]] --> [[0 (66%)]] --> Socre: 0.6634510159492493

[[[[Adv]]]]: static int intel_hda_init(PCIDevice *pci) { IntelHDAState *[[d]] = DO_UPCAST(IntelHDAState, pci, pci); uint8_t *[[conf]] = [[d]]->pci.config; [[d]]->name = [[d]]->pci.qdev.info->name; pci_config_set_vendor_id([[conf]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[conf]], 0x2668); pci_config_set_revision([[conf]], 1); pci_config_set_class([[conf]], PCI_CLASS_MULTIMEDIA_HD_AUDIO); pci_config_set_interrupt_pin([[conf]], 1); [[conf]][0x40] = 0x01; [[d]]->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read, intel_hda_mmio_write, [[d]], DEVICE_NATIVE_ENDIAN); pci_register_bar_simple(&[[d]]->pci, 0, 0x4000, 0, [[d]]->mmio_addr); if ([[d]]->msi) { msi_init(&[[d]]->pci, 0x50, 1, "[[True]]" == "[[True]]", "[[False]]" != "[[False]]"); } hda_codec_bus_init(&[[d]]->pci.qdev, &[[d]]->codecs, intel_hda_response, intel_hda_xfer); return 0; }

[[[[Adv]]]]: static int intel_hda_init(PCIDevice *pci) { IntelHDAState *[[δ]] = DO_UPCAST(IntelHDAState, pci, pci); uint8_t *[[drewus]] = [[δ]]->pci.config; [[δ]]->name = [[δ]]->pci.qdev.info->name; pci_config_set_vendor_id([[drewus]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[drewus]], 0x2668); pci_config_set_revision([[drewus]], 1); pci_config_set_class([[drewus]], PCI_CLASS_MULTIMEDIA_HD_AUDIO); pci_config_set_interrupt_pin([[drewus]], 1); [[drewus]][0x40] = 0x01; [[δ]]->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read, intel_hda_mmio_write, [[δ]], DEVICE_NATIVE_ENDIAN); pci_register_bar_simple(&[[δ]]->pci, 0, 0x4000, 0, [[δ]]->mmio_addr); if ([[δ]]->msi) { msi_init(&[[δ]]->pci, 0x50, 1, "[[lie]]" == "[[lie]]", "[[fraud]]" != "[[fraud]]"); } hda_codec_bus_init(&[[δ]]->pci.qdev, &[[δ]]->codecs, intel_hda_response, intel_hda_xfer); return 0; }
--------------------------------------------- Result 955 ---------------------------------------------
[[0 (5%)]] --> [[0 (81%)]] --> Socre: 0.8074333667755127

[[[[Adv]]]]: static inline void pred_direct_motion(H264Context * const [[h]], int *mb_type){ MpegEncContext * const [[s]] = &[[h]]->s; const int mb_xy = [[s]]->mb_x + [[s]]->mb_y*[[s]]->mb_stride; const int b8_xy = 2*[[s]]->mb_x + 2*[[s]]->mb_y*[[h]]->b8_stride; const int b4_xy = 4*[[s]]->mb_x + 4*[[s]]->mb_y*[[h]]->b_stride; const int mb_type_col = [[h]]->ref_list[1][0].mb_type[mb_xy]; const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &[[h]]->ref_list[1][0].motion_val[0][b4_xy]; const int8_t *l1ref0 = &[[h]]->ref_list[1][0].ref_index[0][b8_xy]; const int is_b8x8 = IS_8X8(*mb_type); int sub_mb_type; int i8, i4; if(IS_8X8(mb_type_col) && ![[h]]->sps.direct_8x8_inference_flag){ sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *mb_type = MB_TYPE_8x8; }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){ sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; }else{ sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *mb_type = MB_TYPE_8x8; } if(!is_b8x8) *mb_type |= MB_TYPE_DIRECT2; tprintf("mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\n", *mb_type, sub_mb_type, is_b8x8, mb_type_col); if([[h]]->direct_spatial_mv_pred){ int ref[2]; int mv[2][2]; int list; for(list=0; list<2; list++){ int refa = [[h]]->ref_cache[list][scan8[0] - 1]; int refb = [[h]]->ref_cache[list][scan8[0] - 8]; int refc = [[h]]->ref_cache[list][scan8[0] - 8 + 4]; if(refc == -2) refc = [[h]]->ref_cache[list][scan8[0] - 8 - 1]; ref[list] = refa; if(ref[list] < 0 || (refb < ref[list] && refb >= 0)) ref[list] = refb; if(ref[list] < 0 || (refc < ref[list] && refc >= 0)) ref[list] = refc; if(ref[list] < 0) ref[list] = -1; } if(ref[0] < 0 && ref[1] < 0){ ref[0] = ref[1] = 0; mv[0][0] = mv[0][1] = mv[1][0] = mv[1][1] = 0; }else{ for(list=0; list<2; list++){ if(ref[list] >= 0) pred_motion([[h]], 0, 4, list, ref[list], &mv[list][0], &mv[list][1]); else mv[list][0] = mv[list][1] = 0; } } if(ref[1] < 0){ *mb_type &= ~MB_TYPE_P0L1; sub_mb_type &= ~MB_TYPE_P0L1; }else if(ref[0] < 0){ *mb_type &= ~MB_TYPE_P0L0; sub_mb_type &= ~MB_TYPE_P0L0; } if(IS_16X16(*mb_type)){ fill_rectangle(&[[h]]->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1); fill_rectangle(&[[h]]->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1); if(!IS_INTRA(mb_type_col) && l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){ if(ref[0] > 0) fill_rectangle(&[[h]]->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); else fill_rectangle(&[[h]]->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); if(ref[1] > 0) fill_rectangle(&[[h]]->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); else fill_rectangle(&[[h]]->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ fill_rectangle(&[[h]]->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); fill_rectangle(&[[h]]->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; if(is_b8x8 && !IS_DIRECT([[h]]->sub_mb_type[i8])) continue; [[h]]->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&[[h]]->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4); fill_rectangle(&[[h]]->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4); fill_rectangle(&[[h]]->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1); fill_rectangle(&[[h]]->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1); if(!IS_INTRA(mb_type_col) && l1ref0[x8 + y8*[[h]]->b8_stride] == 0){ for(i4=0; i4<4; i4++){ const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*[[h]]->b_stride]; if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){ if(ref[0] == 0) *(uint32_t*)[[h]]->mv_cache[0][scan8[i8*4+i4]] = 0; if(ref[1] == 0) *(uint32_t*)[[h]]->mv_cache[1][scan8[i8*4+i4]] = 0; } } } } } }else{ if(IS_16X16(*mb_type)){ fill_rectangle(&[[h]]->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1); if(IS_INTRA(mb_type_col)){ fill_rectangle(&[[h]]->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1); fill_rectangle(&[[h]]-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); fill_rectangle(&[[h]]-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ const int ref0 = l1ref0[0]; const int dist_scale_factor = [[h]]->dist_scale_factor[ref0]; const int16_t *mv_col = l1mv0[0]; int mv_l0[2]; mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8; mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8; fill_rectangle(&[[h]]->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1); fill_rectangle(&[[h]]-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4); fill_rectangle(&[[h]]-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; int ref0, dist_scale_factor; if(is_b8x8 && !IS_DIRECT([[h]]->sub_mb_type[i8])) continue; [[h]]->sub_mb_type[i8] = sub_mb_type; if(IS_INTRA(mb_type_col)){ fill_rectangle(&[[h]]->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1); fill_rectangle(&[[h]]->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1); fill_rectangle(&[[h]]-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4); fill_rectangle(&[[h]]-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4); continue; } ref0 = l1ref0[x8 + y8*[[h]]->b8_stride]; dist_scale_factor = [[h]]->dist_scale_factor[ref0]; fill_rectangle(&[[h]]->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1); fill_rectangle(&[[h]]->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1); for(i4=0; i4<4; i4++){ const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*[[h]]->b_stride]; int16_t *mv_l0 = [[h]]->mv_cache[0][scan8[i8*4+i4]]; mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8; mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8; *(uint32_t*)[[h]]->mv_cache[1][scan8[i8*4+i4]] = pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]); } } } } }

[[[[Adv]]]]: static inline void pred_direct_motion(H264Context * const [[florence]], int *mb_type){ MpegEncContext * const [[gs]] = &[[florence]]->s; const int mb_xy = [[gs]]->mb_x + [[gs]]->mb_y*[[gs]]->mb_stride; const int b8_xy = 2*[[gs]]->mb_x + 2*[[gs]]->mb_y*[[florence]]->b8_stride; const int b4_xy = 4*[[gs]]->mb_x + 4*[[gs]]->mb_y*[[florence]]->b_stride; const int mb_type_col = [[florence]]->ref_list[1][0].mb_type[mb_xy]; const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &[[florence]]->ref_list[1][0].motion_val[0][b4_xy]; const int8_t *l1ref0 = &[[florence]]->ref_list[1][0].ref_index[0][b8_xy]; const int is_b8x8 = IS_8X8(*mb_type); int sub_mb_type; int i8, i4; if(IS_8X8(mb_type_col) && ![[florence]]->sps.direct_8x8_inference_flag){ sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *mb_type = MB_TYPE_8x8; }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){ sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; }else{ sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *mb_type = MB_TYPE_8x8; } if(!is_b8x8) *mb_type |= MB_TYPE_DIRECT2; tprintf("mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\n", *mb_type, sub_mb_type, is_b8x8, mb_type_col); if([[florence]]->direct_spatial_mv_pred){ int ref[2]; int mv[2][2]; int list; for(list=0; list<2; list++){ int refa = [[florence]]->ref_cache[list][scan8[0] - 1]; int refb = [[florence]]->ref_cache[list][scan8[0] - 8]; int refc = [[florence]]->ref_cache[list][scan8[0] - 8 + 4]; if(refc == -2) refc = [[florence]]->ref_cache[list][scan8[0] - 8 - 1]; ref[list] = refa; if(ref[list] < 0 || (refb < ref[list] && refb >= 0)) ref[list] = refb; if(ref[list] < 0 || (refc < ref[list] && refc >= 0)) ref[list] = refc; if(ref[list] < 0) ref[list] = -1; } if(ref[0] < 0 && ref[1] < 0){ ref[0] = ref[1] = 0; mv[0][0] = mv[0][1] = mv[1][0] = mv[1][1] = 0; }else{ for(list=0; list<2; list++){ if(ref[list] >= 0) pred_motion([[florence]], 0, 4, list, ref[list], &mv[list][0], &mv[list][1]); else mv[list][0] = mv[list][1] = 0; } } if(ref[1] < 0){ *mb_type &= ~MB_TYPE_P0L1; sub_mb_type &= ~MB_TYPE_P0L1; }else if(ref[0] < 0){ *mb_type &= ~MB_TYPE_P0L0; sub_mb_type &= ~MB_TYPE_P0L0; } if(IS_16X16(*mb_type)){ fill_rectangle(&[[florence]]->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1); fill_rectangle(&[[florence]]->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1); if(!IS_INTRA(mb_type_col) && l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){ if(ref[0] > 0) fill_rectangle(&[[florence]]->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); else fill_rectangle(&[[florence]]->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); if(ref[1] > 0) fill_rectangle(&[[florence]]->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); else fill_rectangle(&[[florence]]->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ fill_rectangle(&[[florence]]->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); fill_rectangle(&[[florence]]->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; if(is_b8x8 && !IS_DIRECT([[florence]]->sub_mb_type[i8])) continue; [[florence]]->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&[[florence]]->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4); fill_rectangle(&[[florence]]->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4); fill_rectangle(&[[florence]]->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1); fill_rectangle(&[[florence]]->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1); if(!IS_INTRA(mb_type_col) && l1ref0[x8 + y8*[[florence]]->b8_stride] == 0){ for(i4=0; i4<4; i4++){ const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*[[florence]]->b_stride]; if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){ if(ref[0] == 0) *(uint32_t*)[[florence]]->mv_cache[0][scan8[i8*4+i4]] = 0; if(ref[1] == 0) *(uint32_t*)[[florence]]->mv_cache[1][scan8[i8*4+i4]] = 0; } } } } } }else{ if(IS_16X16(*mb_type)){ fill_rectangle(&[[florence]]->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1); if(IS_INTRA(mb_type_col)){ fill_rectangle(&[[florence]]->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1); fill_rectangle(&[[florence]]-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); fill_rectangle(&[[florence]]-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ const int ref0 = l1ref0[0]; const int dist_scale_factor = [[florence]]->dist_scale_factor[ref0]; const int16_t *mv_col = l1mv0[0]; int mv_l0[2]; mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8; mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8; fill_rectangle(&[[florence]]->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1); fill_rectangle(&[[florence]]-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4); fill_rectangle(&[[florence]]-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; int ref0, dist_scale_factor; if(is_b8x8 && !IS_DIRECT([[florence]]->sub_mb_type[i8])) continue; [[florence]]->sub_mb_type[i8] = sub_mb_type; if(IS_INTRA(mb_type_col)){ fill_rectangle(&[[florence]]->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1); fill_rectangle(&[[florence]]->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1); fill_rectangle(&[[florence]]-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4); fill_rectangle(&[[florence]]-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4); continue; } ref0 = l1ref0[x8 + y8*[[florence]]->b8_stride]; dist_scale_factor = [[florence]]->dist_scale_factor[ref0]; fill_rectangle(&[[florence]]->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1); fill_rectangle(&[[florence]]->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1); for(i4=0; i4<4; i4++){ const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*[[florence]]->b_stride]; int16_t *mv_l0 = [[florence]]->mv_cache[0][scan8[i8*4+i4]]; mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8; mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8; *(uint32_t*)[[florence]]->mv_cache[1][scan8[i8*4+i4]] = pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]); } } } } }[Succeeded / Failed / Skipped / Total] 500 / 106 / 349 / 955:  36%|███▌      | 955/2690 [2:28:47<4:30:19,  9.35s/it][Succeeded / Failed / Skipped / Total] 500 / 106 / 349 / 955:  36%|███▌      | 956/2690 [2:28:52<4:30:02,  9.34s/it][Succeeded / Failed / Skipped / Total] 501 / 106 / 349 / 956:  36%|███▌      | 956/2690 [2:28:52<4:30:02,  9.34s/it][Succeeded / Failed / Skipped / Total] 501 / 106 / 349 / 956:  36%|███▌      | 957/2690 [2:29:10<4:30:07,  9.35s/it][Succeeded / Failed / Skipped / Total] 502 / 106 / 349 / 957:  36%|███▌      | 957/2690 [2:29:10<4:30:07,  9.35s/it][Succeeded / Failed / Skipped / Total] 502 / 106 / 349 / 957:  36%|███▌      | 958/2690 [2:29:27<4:30:12,  9.36s/it][Succeeded / Failed / Skipped / Total] 503 / 106 / 349 / 958:  36%|███▌      | 958/2690 [2:29:27<4:30:12,  9.36s/it][Succeeded / Failed / Skipped / Total] 503 / 106 / 349 / 958:  36%|███▌      | 959/2690 [2:29:27<4:29:47,  9.35s/it][Succeeded / Failed / Skipped / Total] 503 / 106 / 350 / 959:  36%|███▌      | 959/2690 [2:29:27<4:29:47,  9.35s/it][Succeeded / Failed / Skipped / Total] 503 / 106 / 350 / 959:  36%|███▌      | 960/2690 [2:29:29<4:29:23,  9.34s/it][Succeeded / Failed / Skipped / Total] 504 / 106 / 350 / 960:  36%|███▌      | 960/2690 [2:29:29<4:29:23,  9.34s/it][Succeeded / Failed / Skipped / Total] 504 / 106 / 350 / 960:  36%|███▌      | 961/2690 [2:29:29<4:28:57,  9.33s/it][Succeeded / Failed / Skipped / Total] 504 / 106 / 351 / 961:  36%|███▌      | 961/2690 [2:29:29<4:28:57,  9.33s/it][Succeeded / Failed / Skipped / Total] 504 / 106 / 351 / 961:  36%|███▌      | 962/2690 [2:29:30<4:28:32,  9.32s/it]
--------------------------------------------- Result 956 ---------------------------------------------
[[0 (5%)]] --> [[0 (66%)]] --> Socre: 0.6569751501083374

[[[[Adv]]]]: static void bdrv_throttle_write_timer_cb(void *[[opaque]]) { BlockDriverState *[[bs]] = [[opaque]]; qemu_co_enter_next(&[[bs]]->throttled_reqs[1]); }

[[[[Adv]]]]: static void bdrv_throttle_write_timer_cb(void *[[emissions]]) { BlockDriverState *[[mist]] = [[emissions]]; qemu_co_enter_next(&[[mist]]->throttled_reqs[1]); }
--------------------------------------------- Result 957 ---------------------------------------------
[[0 (14%)]] --> [[0 (98%)]] --> Socre: 0.9808370471000671

[[[[Adv]]]]: static int kvm_put_xcrs(CPUState *env) { #ifdef KVM_CAP_XCRS struct kvm_xcrs [[xcrs]]; if (!kvm_has_xcrs()) return 0; [[xcrs]].nr_xcrs = 1; [[xcrs]].flags = 0; [[xcrs]].xcrs[0].xcr = 0; [[xcrs]].xcrs[0].value = env->xcr0; return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &[[xcrs]]); #else return 0; #endif }

[[[[Adv]]]]: static int kvm_put_xcrs(CPUState *env) { #ifdef KVM_CAP_XCRS struct kvm_xcrs [[ₓcottp]]; if (!kvm_has_xcrs()) return 0; [[ₓcottp]].nr_xcrs = 1; [[ₓcottp]].flags = 0; [[ₓcottp]].xcrs[0].xcr = 0; [[ₓcottp]].xcrs[0].value = env->xcr0; return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &[[ₓcottp]]); #else return 0; #endif }
--------------------------------------------- Result 958 ---------------------------------------------
[[0 (9%)]] --> [[0 (70%)]] --> Socre: 0.7008416652679443

[[[[Adv]]]]: static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h, int rw, int type, int target_page_bits) { hwaddr pteg_off; target_ulong [[pte0]], pte1; int i, good = -1; int [[ret]], r; [[ret]] = -1; pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32); for (i = 0; i < 8; i++) { if (env->external_htab) { [[pte0]] = ldl_p(env->external_htab + pteg_off + (i * 8)); pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4); } else { [[pte0]] = ldl_phys(env->htab_base + pteg_off + (i * 8)); pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4); } r = pte_check_hash32(ctx, [[pte0]], pte1, h, rw, type); LOG_MMU("Load pte from %08" HWADDR_PRIx " => " TARGET_FMT_lx " " TARGET_FMT_lx " %d %d %d " TARGET_FMT_lx "\n", pteg_off + (i * 8), [[pte0]], pte1, (int)([[pte0]] >> 31), h, (int)(([[pte0]] >> 6) & 1), ctx->ptem); switch (r) { case -3: return -1; case -2: [[ret]] = -2; good = i; break; case -1: default: break; case 0: [[ret]] = 0; good = i; goto done; } } if (good != -1) { done: LOG_MMU("found PTE at addr %08" HWADDR_PRIx " prot=%01x ret=%d\n", ctx->raddr, ctx->prot, [[ret]]); pte1 = ctx->raddr; if (pte_update_flags(ctx, &pte1, [[ret]], rw) == 1) { if (env->external_htab) { stl_p(env->external_htab + pteg_off + (good * 8) + 4, pte1); } else { stl_phys_notdirty(env->htab_base + pteg_off + (good * 8) + 4, pte1); } } } if (target_page_bits != TARGET_PAGE_BITS) { ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1)) & TARGET_PAGE_MASK; } return [[ret]]; }

[[[[Adv]]]]: static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h, int rw, int type, int target_page_bits) { hwaddr pteg_off; target_ulong [[psiεv]], pte1; int i, good = -1; int [[revт]], r; [[revт]] = -1; pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32); for (i = 0; i < 8; i++) { if (env->external_htab) { [[psiεv]] = ldl_p(env->external_htab + pteg_off + (i * 8)); pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4); } else { [[psiεv]] = ldl_phys(env->htab_base + pteg_off + (i * 8)); pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4); } r = pte_check_hash32(ctx, [[psiεv]], pte1, h, rw, type); LOG_MMU("Load pte from %08" HWADDR_PRIx " => " TARGET_FMT_lx " " TARGET_FMT_lx " %d %d %d " TARGET_FMT_lx "\n", pteg_off + (i * 8), [[psiεv]], pte1, (int)([[psiεv]] >> 31), h, (int)(([[psiεv]] >> 6) & 1), ctx->ptem); switch (r) { case -3: return -1; case -2: [[revт]] = -2; good = i; break; case -1: default: break; case 0: [[revт]] = 0; good = i; goto done; } } if (good != -1) { done: LOG_MMU("found PTE at addr %08" HWADDR_PRIx " prot=%01x ret=%d\n", ctx->raddr, ctx->prot, [[revт]]); pte1 = ctx->raddr; if (pte_update_flags(ctx, &pte1, [[revт]], rw) == 1) { if (env->external_htab) { stl_p(env->external_htab + pteg_off + (good * 8) + 4, pte1); } else { stl_phys_notdirty(env->htab_base + pteg_off + (good * 8) + 4, pte1); } } } if (target_page_bits != TARGET_PAGE_BITS) { ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1)) & TARGET_PAGE_MASK; } return [[revт]]; }
--------------------------------------------- Result 959 ---------------------------------------------
[[0 (2%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { struct tm tm; if (nret != 8) { rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); return; } qemu_get_timedate(&tm, spapr->rtc_offset); rtas_st(rets, 0, RTAS_OUT_SUCCESS); rtas_st(rets, 1, tm.tm_year + 1900); rtas_st(rets, 2, tm.tm_mon + 1); rtas_st(rets, 3, tm.tm_mday); rtas_st(rets, 4, tm.tm_hour); rtas_st(rets, 5, tm.tm_min); rtas_st(rets, 6, tm.tm_sec); rtas_st(rets, 7, 0); }
--------------------------------------------- Result 960 ---------------------------------------------
[[0 (38%)]] --> [[0 (67%)]] --> Socre: 0.6696672439575195

[[[[Adv]]]]: static uint32_t gt64120_read_config(PCIDevice *d, uint32_t [[address]], int len) { uint32_t val = pci_default_read_config(d, [[address]], len); #ifdef TARGET_WORDS_BIGENDIAN val = bswap32(val); #endif return val; }

[[[[Adv]]]]: static uint32_t gt64120_read_config(PCIDevice *d, uint32_t [[office]], int len) { uint32_t val = pci_default_read_config(d, [[office]], len); #ifdef TARGET_WORDS_BIGENDIAN val = bswap32(val); #endif return val; }
--------------------------------------------- Result 961 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int create_stream(AVFormatContext *s) { XCBGrabContext *c = s->priv_data; AVStream *st = avformat_new_stream(s, NULL); xcb_get_geometry_cookie_t gc; xcb_get_geometry_reply_t *geo; int ret; if (!st) return AVERROR(ENOMEM); ret = av_parse_video_size(&c->width, &c->height, c->video_size); if (ret < 0) return ret; ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate); if (ret < 0) return ret; avpriv_set_pts_info(st, 64, 1, 1000000); gc = xcb_get_geometry(c->conn, c->screen->root); geo = xcb_get_geometry_reply(c->conn, gc, NULL); c->width = FFMIN(geo->width, c->width); c->height = FFMIN(geo->height, c->height); c->time_base = (AVRational){ st->avg_frame_rate.den, st->avg_frame_rate.num }; c->time_frame = av_gettime(); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_RAWVIDEO; st->codec->width = c->width; st->codec->height = c->height; st->codec->time_base = c->time_base; ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt); free(geo); return ret; }
--------------------------------------------- Result 962 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 504 / 106 / 352 / 962:  36%|███▌      | 962/2690 [2:29:30<4:28:32,  9.32s/it][Succeeded / Failed / Skipped / Total] 504 / 106 / 352 / 962:  36%|███▌      | 963/2690 [2:29:57<4:28:55,  9.34s/it][[0 (98%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vorbis_parse_setup_hdr_codebooks(vorbis_context *vc) { unsigned cb; uint8_t *tmp_vlc_bits; uint32_t *tmp_vlc_codes; GetBitContext *gb = &vc->gb; uint16_t *codebook_multiplicands; int ret = 0; vc->codebook_count = get_bits(gb, 8) + 1; av_dlog(NULL, " Codebooks: %d \n", vc->codebook_count); vc->codebooks = av_mallocz(vc->codebook_count * sizeof(*vc->codebooks)); tmp_vlc_bits = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_bits)); tmp_vlc_codes = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_codes)); codebook_multiplicands = av_malloc(V_MAX_VLCS * sizeof(*codebook_multiplicands)); for (cb = 0; cb < vc->codebook_count; ++cb) { vorbis_codebook *codebook_setup = &vc->codebooks[cb]; unsigned ordered, t, entries, used_entries = 0; av_dlog(NULL, " %u. Codebook\n", cb); if (get_bits(gb, 24) != 0x564342) { av_log(vc->avctx, AV_LOG_ERROR, " %u. Codebook setup data corrupt.\n", cb); ret = AVERROR_INVALIDDATA; goto error; } codebook_setup->dimensions=get_bits(gb, 16); if (codebook_setup->dimensions > 16 || codebook_setup->dimensions == 0) { av_log(vc->avctx, AV_LOG_ERROR, " %u. Codebook's dimension is invalid (%d).\n", cb, codebook_setup->dimensions); ret = AVERROR_INVALIDDATA; goto error; } entries = get_bits(gb, 24); if (entries > V_MAX_VLCS) { av_log(vc->avctx, AV_LOG_ERROR, " %u. Codebook has too many entries (%u).\n", cb, entries); ret = AVERROR_INVALIDDATA; goto error; } ordered = get_bits1(gb); av_dlog(NULL, " codebook_dimensions %d, codebook_entries %u\n", codebook_setup->dimensions, entries); if (!ordered) { unsigned ce, flag; unsigned sparse = get_bits1(gb); av_dlog(NULL, " not ordered \n"); if (sparse) { av_dlog(NULL, " sparse \n"); used_entries = 0; for (ce = 0; ce < entries; ++ce) { flag = get_bits1(gb); if (flag) { tmp_vlc_bits[ce] = get_bits(gb, 5) + 1; ++used_entries; } else tmp_vlc_bits[ce] = 0; } } else { av_dlog(NULL, " not sparse \n"); used_entries = entries; for (ce = 0; ce < entries; ++ce) tmp_vlc_bits[ce] = get_bits(gb, 5) + 1; } } else { unsigned current_entry = 0; unsigned current_length = get_bits(gb, 5) + 1; av_dlog(NULL, " ordered, current length: %u\n", current_length); used_entries = entries; for (; current_entry < used_entries && current_length <= 32; ++current_length) { unsigned i, number; av_dlog(NULL, " number bits: %u ", ilog(entries - current_entry)); number = get_bits(gb, ilog(entries - current_entry)); av_dlog(NULL, " number: %u\n", number); for (i = current_entry; i < number+current_entry; ++i) if (i < used_entries) tmp_vlc_bits[i] = current_length; current_entry+=number; } if (current_entry>used_entries) { av_log(vc->avctx, AV_LOG_ERROR, " More codelengths than codes in codebook. \n"); ret = AVERROR_INVALIDDATA; goto error; } } codebook_setup->lookup_type = get_bits(gb, 4); av_dlog(NULL, " lookup type: %d : %s \n", codebook_setup->lookup_type, codebook_setup->lookup_type ? "vq" : "no lookup"); if (codebook_setup->lookup_type == 1) { unsigned i, j, k; unsigned codebook_lookup_values = ff_vorbis_nth_root(entries, codebook_setup->dimensions); float codebook_minimum_value = vorbisfloat2float(get_bits_long(gb, 32)); float codebook_delta_value = vorbisfloat2float(get_bits_long(gb, 32)); unsigned codebook_value_bits = get_bits(gb, 4) + 1; unsigned codebook_sequence_p = get_bits1(gb); av_dlog(NULL, " We expect %d numbers for building the codevectors. \n", codebook_lookup_values); av_dlog(NULL, " delta %f minmum %f \n", codebook_delta_value, codebook_minimum_value); for (i = 0; i < codebook_lookup_values; ++i) { codebook_multiplicands[i] = get_bits(gb, codebook_value_bits); av_dlog(NULL, " multiplicands*delta+minmum : %e \n", (float)codebook_multiplicands[i] * codebook_delta_value + codebook_minimum_value); av_dlog(NULL, " multiplicand %u\n", codebook_multiplicands[i]); } codebook_setup->codevectors = used_entries ? av_mallocz(used_entries * codebook_setup->dimensions * sizeof(*codebook_setup->codevectors)) : NULL; for (j = 0, i = 0; i < entries; ++i) { unsigned dim = codebook_setup->dimensions; if (tmp_vlc_bits[i]) { float last = 0.0; unsigned lookup_offset = i; av_dlog(vc->avctx, "Lookup offset %u ,", i); for (k = 0; k < dim; ++k) { unsigned multiplicand_offset = lookup_offset % codebook_lookup_values; codebook_setup->codevectors[j * dim + k] = codebook_multiplicands[multiplicand_offset] * codebook_delta_value + codebook_minimum_value + last; if (codebook_sequence_p) last = codebook_setup->codevectors[j * dim + k]; lookup_offset/=codebook_lookup_values; } tmp_vlc_bits[j] = tmp_vlc_bits[i]; av_dlog(vc->avctx, "real lookup offset %u, vector: ", j); for (k = 0; k < dim; ++k) av_dlog(vc->avctx, " %f ", codebook_setup->codevectors[j * dim + k]); av_dlog(vc->avctx, "\n"); ++j; } } if (j != used_entries) { av_log(vc->avctx, AV_LOG_ERROR, "Bug in codevector vector building code. \n"); ret = AVERROR_INVALIDDATA; goto error; } entries = used_entries; } else if (codebook_setup->lookup_type >= 2) { av_log(vc->avctx, AV_LOG_ERROR, "Codebook lookup type not supported. \n"); ret = AVERROR_INVALIDDATA; goto error; } if (ff_vorbis_len2vlc(tmp_vlc_bits, tmp_vlc_codes, entries)) { av_log(vc->avctx, AV_LOG_ERROR, " Invalid code lengths while generating vlcs. \n"); ret = AVERROR_INVALIDDATA; goto error; } codebook_setup->maxdepth = 0; for (t = 0; t < entries; ++t) if (tmp_vlc_bits[t] >= codebook_setup->maxdepth) codebook_setup->maxdepth = tmp_vlc_bits[t]; if (codebook_setup->maxdepth > 3 * V_NB_BITS) codebook_setup->nb_bits = V_NB_BITS2; else codebook_setup->nb_bits = V_NB_BITS; codebook_setup->maxdepth = (codebook_setup->maxdepth+codebook_setup->nb_bits - 1) / codebook_setup->nb_bits; if ((ret = init_vlc(&codebook_setup->vlc, codebook_setup->nb_bits, entries, tmp_vlc_bits, sizeof(*tmp_vlc_bits), sizeof(*tmp_vlc_bits), tmp_vlc_codes, sizeof(*tmp_vlc_codes), sizeof(*tmp_vlc_codes), INIT_VLC_LE))) { av_log(vc->avctx, AV_LOG_ERROR, " Error generating vlc tables. \n"); goto error; } } av_free(tmp_vlc_bits); av_free(tmp_vlc_codes); av_free(codebook_multiplicands); return 0; error: av_free(tmp_vlc_bits); av_free(tmp_vlc_codes); av_free(codebook_multiplicands); return ret; }
--------------------------------------------- Result 963 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 505 / 106 / 352 / 963:  36%|███▌      | 963/2690 [2:29:57<4:28:55,  9.34s/it][Succeeded / Failed / Skipped / Total] 505 / 106 / 352 / 963:  36%|███▌      | 964/2690 [2:30:12<4:28:57,  9.35s/it][Succeeded / Failed / Skipped / Total] 506 / 106 / 352 / 964:  36%|███▌      | 964/2690 [2:30:12<4:28:57,  9.35s/it][Succeeded / Failed / Skipped / Total] 506 / 106 / 352 / 964:  36%|███▌      | 965/2690 [2:30:23<4:28:49,  9.35s/it][Succeeded / Failed / Skipped / Total] 507 / 106 / 352 / 965:  36%|███▌      | 965/2690 [2:30:23<4:28:49,  9.35s/it][Succeeded / Failed / Skipped / Total] 507 / 106 / 352 / 965:  36%|███▌      | 966/2690 [2:30:23<4:28:24,  9.34s/it][Succeeded / Failed / Skipped / Total] 507 / 106 / 353 / 966:  36%|███▌      | 966/2690 [2:30:23<4:28:24,  9.34s/it][Succeeded / Failed / Skipped / Total] 507 / 106 / 353 / 966:  36%|███▌      | 967/2690 [2:30:32<4:28:14,  9.34s/it][Succeeded / Failed / Skipped / Total] 508 / 106 / 353 / 967:  36%|███▌      | 967/2690 [2:30:32<4:28:14,  9.34s/it][Succeeded / Failed / Skipped / Total] 508 / 106 / 353 / 967:  36%|███▌      | 968/2690 [2:30:46<4:28:12,  9.35s/it][[0 (62%)]] --> [[0 (32%)]] --> Socre: 0.680642694234848

[[[[Adv]]]]: static int htab_save_later_pass(QEMUFile *[[f]], sPAPREnvironment *spapr, int64_t max_ns) { bool final = max_ns < 0; int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; int examined = 0, sent = 0; int index = spapr->htab_save_index; int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME); assert(!spapr->htab_first_pass); do { int chunkstart, invalidstart; while ((index < htabslots) && !HPTE_DIRTY(HPTE(spapr->htab, index))) { index++; examined++; } chunkstart = index; while ((index < htabslots) && HPTE_DIRTY(HPTE(spapr->htab, index)) && HPTE_VALID(HPTE(spapr->htab, index))) { CLEAN_HPTE(HPTE(spapr->htab, index)); index++; examined++; } invalidstart = index; while ((index < htabslots) && HPTE_DIRTY(HPTE(spapr->htab, index)) && !HPTE_VALID(HPTE(spapr->htab, index))) { CLEAN_HPTE(HPTE(spapr->htab, index)); index++; examined++; } if (index > chunkstart) { int n_valid = invalidstart - chunkstart; int n_invalid = index - invalidstart; qemu_put_be32([[f]], chunkstart); qemu_put_be16([[f]], n_valid); qemu_put_be16([[f]], n_invalid); qemu_put_buffer([[f]], HPTE(spapr->htab, chunkstart), HASH_PTE_SIZE_64 * n_valid); sent += index - chunkstart; if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) { break; } } if (examined >= htabslots) { break; } if (index >= htabslots) { assert(index == htabslots); index = 0; } } while ((examined < htabslots) && (!qemu_file_rate_limit([[f]]) || final)); if (index >= htabslots) { assert(index == htabslots); index = 0; } spapr->htab_save_index = index; return (examined >= htabslots) && (sent == 0) ? 1 : 0; }

[[[[Adv]]]]: static int htab_save_later_pass(QEMUFile *[[pin]], sPAPREnvironment *spapr, int64_t max_ns) { bool final = max_ns < 0; int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; int examined = 0, sent = 0; int index = spapr->htab_save_index; int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME); assert(!spapr->htab_first_pass); do { int chunkstart, invalidstart; while ((index < htabslots) && !HPTE_DIRTY(HPTE(spapr->htab, index))) { index++; examined++; } chunkstart = index; while ((index < htabslots) && HPTE_DIRTY(HPTE(spapr->htab, index)) && HPTE_VALID(HPTE(spapr->htab, index))) { CLEAN_HPTE(HPTE(spapr->htab, index)); index++; examined++; } invalidstart = index; while ((index < htabslots) && HPTE_DIRTY(HPTE(spapr->htab, index)) && !HPTE_VALID(HPTE(spapr->htab, index))) { CLEAN_HPTE(HPTE(spapr->htab, index)); index++; examined++; } if (index > chunkstart) { int n_valid = invalidstart - chunkstart; int n_invalid = index - invalidstart; qemu_put_be32([[pin]], chunkstart); qemu_put_be16([[pin]], n_valid); qemu_put_be16([[pin]], n_invalid); qemu_put_buffer([[pin]], HPTE(spapr->htab, chunkstart), HASH_PTE_SIZE_64 * n_valid); sent += index - chunkstart; if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) { break; } } if (examined >= htabslots) { break; } if (index >= htabslots) { assert(index == htabslots); index = 0; } } while ((examined < htabslots) && (!qemu_file_rate_limit([[pin]]) || final)); if (index >= htabslots) { assert(index == htabslots); index = 0; } spapr->htab_save_index = index; return (examined >= htabslots) && (sent == 0) ? 1 : 0; }
--------------------------------------------- Result 964 ---------------------------------------------
[[0 (3%)]] --> [[0 (94%)]] --> Socre: 0.9380223155021667

[[[[Adv]]]]: static ExitStatus gen_bcond_internal(DisasContext *[[ctx]], TCGCond cond, TCGv cmp, int32_t [[disp]]) { uint64_t [[dest]] = [[ctx]]->pc + ([[disp]] << 2); int lab_true = gen_new_label(); if (use_goto_tb([[ctx]], [[dest]])) { tcg_gen_brcondi_i64(cond, cmp, 0, lab_true); tcg_gen_goto_tb(0); tcg_gen_movi_i64(cpu_pc, [[ctx]]->pc); tcg_gen_exit_tb((uintptr_t)[[ctx]]->tb); gen_set_label(lab_true); tcg_gen_goto_tb(1); tcg_gen_movi_i64(cpu_pc, [[dest]]); tcg_gen_exit_tb((uintptr_t)[[ctx]]->tb + 1); return EXIT_GOTO_TB; } else { TCGv_i64 z = tcg_const_i64(0); TCGv_i64 d = tcg_const_i64([[dest]]); TCGv_i64 p = tcg_const_i64([[ctx]]->pc); tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p); tcg_temp_free_i64(z); tcg_temp_free_i64(d); tcg_temp_free_i64(p); return EXIT_PC_UPDATED; } }

[[[[Adv]]]]: static ExitStatus gen_bcond_internal(DisasContext *[[tum]], TCGCond cond, TCGv cmp, int32_t [[proser]]) { uint64_t [[flatτ]] = [[tum]]->pc + ([[proser]] << 2); int lab_true = gen_new_label(); if (use_goto_tb([[tum]], [[flatτ]])) { tcg_gen_brcondi_i64(cond, cmp, 0, lab_true); tcg_gen_goto_tb(0); tcg_gen_movi_i64(cpu_pc, [[tum]]->pc); tcg_gen_exit_tb((uintptr_t)[[tum]]->tb); gen_set_label(lab_true); tcg_gen_goto_tb(1); tcg_gen_movi_i64(cpu_pc, [[flatτ]]); tcg_gen_exit_tb((uintptr_t)[[tum]]->tb + 1); return EXIT_GOTO_TB; } else { TCGv_i64 z = tcg_const_i64(0); TCGv_i64 d = tcg_const_i64([[flatτ]]); TCGv_i64 p = tcg_const_i64([[tum]]->pc); tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p); tcg_temp_free_i64(z); tcg_temp_free_i64(d); tcg_temp_free_i64(p); return EXIT_PC_UPDATED; } }
--------------------------------------------- Result 965 ---------------------------------------------
[[0 (7%)]] --> [[0 (99%)]] --> Socre: 0.9869399070739746

[[[[Adv]]]]: static abi_long do_socket(int domain, int type, int protocol) { int target_type = type; int [[ret]]; [[ret]] = target_to_host_sock_type(&type); if ([[ret]]) { return [[ret]]; } if (domain == PF_NETLINK) return -TARGET_EAFNOSUPPORT; if (domain == AF_PACKET || (domain == AF_INET && type == SOCK_PACKET)) { protocol = tswap16(protocol); } [[ret]] = get_errno(socket(domain, type, protocol)); if ([[ret]] >= 0) { [[ret]] = sock_flags_fixup([[ret]], target_type); if (type == SOCK_PACKET) { fd_trans_register([[ret]], &target_packet_trans); } } return [[ret]]; }

[[[[Adv]]]]: static abi_long do_socket(int domain, int type, int protocol) { int target_type = type; int [[レtte]]; [[レtte]] = target_to_host_sock_type(&type); if ([[レtte]]) { return [[レtte]]; } if (domain == PF_NETLINK) return -TARGET_EAFNOSUPPORT; if (domain == AF_PACKET || (domain == AF_INET && type == SOCK_PACKET)) { protocol = tswap16(protocol); } [[レtte]] = get_errno(socket(domain, type, protocol)); if ([[レtte]] >= 0) { [[レtte]] = sock_flags_fixup([[レtte]], target_type); if (type == SOCK_PACKET) { fd_trans_register([[レtte]], &target_packet_trans); } } return [[レtte]]; }
--------------------------------------------- Result 966 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void process_incoming_migration(QEMUFile *f) { if (qemu_loadvm_state(f) < 0) { fprintf(stderr, "load of migration failed\n"); exit(0); } qemu_announce_self(); DPRINTF("successfully loaded vm state\n"); incoming_expected = "False" != "False"; if (autostart) { vm_start(); } else { runstate_set(RSTATE_PRE_LAUNCH); } }
--------------------------------------------- Result 967 ---------------------------------------------
[[0 (33%)]] --> [[0 (97%)]] --> Socre: 0.9736731648445129

[[[[Adv]]]]: int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int [[buf_len]]) { PowerPCCPU *cpu = ppc_env_get_cpu(env); CPUState *cs = CPU(cpu); uint32_t *hc = (uint32_t*)buf; struct kvm_ppc_pvinfo pvinfo; if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) && !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) { memcpy(buf, pvinfo.hcall, [[buf_len]]); return 0; } hc[0] = 0x3860ffff; hc[1] = 0x60000000; hc[2] = 0x60000000; hc[3] = 0x60000000; return 0; }

[[[[Adv]]]]: int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int [[chuфvirtualnet]]) { PowerPCCPU *cpu = ppc_env_get_cpu(env); CPUState *cs = CPU(cpu); uint32_t *hc = (uint32_t*)buf; struct kvm_ppc_pvinfo pvinfo; if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) && !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) { memcpy(buf, pvinfo.hcall, [[chuфvirtualnet]]); return 0; } hc[0] = 0x3860ffff; hc[1] = 0x60000000; hc[2] = 0x60000000; hc[3] = 0x60000000; return 0; }
--------------------------------------------- Result 968 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 509 / 106 / 353 / 968:  36%|███▌      | 968/2690 [2:30:46<4:28:12,  9.35s/it][Succeeded / Failed / Skipped / Total] 510 / 106 / 353 / 969:  36%|███▌      | 969/2690 [2:30:46<4:27:46,  9.34s/it][Succeeded / Failed / Skipped / Total] 510 / 106 / 353 / 969:  36%|███▌      | 970/2690 [2:30:46<4:27:21,  9.33s/it][Succeeded / Failed / Skipped / Total] 510 / 106 / 354 / 970:  36%|███▌      | 970/2690 [2:30:46<4:27:21,  9.33s/it][Succeeded / Failed / Skipped / Total] 510 / 106 / 355 / 971:  36%|███▌      | 971/2690 [2:30:47<4:26:56,  9.32s/it][Succeeded / Failed / Skipped / Total] 510 / 106 / 355 / 971:  36%|███▌      | 972/2690 [2:31:04<4:27:00,  9.33s/it][Succeeded / Failed / Skipped / Total] 511 / 106 / 355 / 972:  36%|███▌      | 972/2690 [2:31:04<4:27:00,  9.33s/it][Succeeded / Failed / Skipped / Total] 511 / 106 / 355 / 972:  36%|███▌      | 973/2690 [2:31:19<4:27:02,  9.33s/it][[0 (48%)]] --> [[0 (64%)]] --> Socre: 0.6444892287254333

[[[[Adv]]]]: static int rv40_decode_mb_info(RV34DecContext *r) { MpegEncContext *s = &r->s; GetBitContext *gb = &s->gb; int q, i; int prev_type = 0; int mb_pos = s->mb_x + s->mb_y * s->mb_stride; int [[blocks]][RV34_MB_TYPES] = {0}; int count = 0; if(!r->s.mb_skip_run) r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1; if(--r->s.mb_skip_run) return RV34_MB_SKIP; if(r->avail_cache[6-1]) [[blocks]][r->mb_type[mb_pos - 1]]++; if(r->avail_cache[6-4]){ [[blocks]][r->mb_type[mb_pos - s->mb_stride]]++; if(r->avail_cache[6-2]) [[blocks]][r->mb_type[mb_pos - s->mb_stride + 1]]++; if(r->avail_cache[6-5]) [[blocks]][r->mb_type[mb_pos - s->mb_stride - 1]]++; } for(i = 0; i < RV34_MB_TYPES; i++){ if([[blocks]][i] > count){ count = [[blocks]][i]; prev_type = i; } } if(s->pict_type == AV_PICTURE_TYPE_P){ prev_type = block_num_to_ptype_vlc_num[prev_type]; q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1); if(q < PBTYPE_ESCAPE) return q; q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1); av_log(s->avctx, AV_LOG_ERROR, "Dquant for P-frame\n"); }else{ prev_type = block_num_to_btype_vlc_num[prev_type]; q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1); if(q < PBTYPE_ESCAPE) return q; q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1); av_log(s->avctx, AV_LOG_ERROR, "Dquant for B-frame\n"); } return 0; }

[[[[Adv]]]]: static int rv40_decode_mb_info(RV34DecContext *r) { MpegEncContext *s = &r->s; GetBitContext *gb = &s->gb; int q, i; int prev_type = 0; int mb_pos = s->mb_x + s->mb_y * s->mb_stride; int [[matrices]][RV34_MB_TYPES] = {0}; int count = 0; if(!r->s.mb_skip_run) r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1; if(--r->s.mb_skip_run) return RV34_MB_SKIP; if(r->avail_cache[6-1]) [[matrices]][r->mb_type[mb_pos - 1]]++; if(r->avail_cache[6-4]){ [[matrices]][r->mb_type[mb_pos - s->mb_stride]]++; if(r->avail_cache[6-2]) [[matrices]][r->mb_type[mb_pos - s->mb_stride + 1]]++; if(r->avail_cache[6-5]) [[matrices]][r->mb_type[mb_pos - s->mb_stride - 1]]++; } for(i = 0; i < RV34_MB_TYPES; i++){ if([[matrices]][i] > count){ count = [[matrices]][i]; prev_type = i; } } if(s->pict_type == AV_PICTURE_TYPE_P){ prev_type = block_num_to_ptype_vlc_num[prev_type]; q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1); if(q < PBTYPE_ESCAPE) return q; q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1); av_log(s->avctx, AV_LOG_ERROR, "Dquant for P-frame\n"); }else{ prev_type = block_num_to_btype_vlc_num[prev_type]; q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1); if(q < PBTYPE_ESCAPE) return q; q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1); av_log(s->avctx, AV_LOG_ERROR, "Dquant for B-frame\n"); } return 0; }
--------------------------------------------- Result 969 ---------------------------------------------
[[0 (7%)]] --> [[0 (53%)]] --> Socre: 0.5304855704307556

[[[[Adv]]]]: void qmp_block_job_set_speed(const char *[[device]], int64_t [[speed]], Error **[[errp]]) { BlockJob *[[job]] = find_block_job([[device]]); if (![[job]]) { error_set([[errp]], QERR_BLOCK_JOB_NOT_ACTIVE, [[device]]); return; } block_job_set_speed([[job]], [[speed]], [[errp]]); }

[[[[Adv]]]]: void qmp_block_job_set_speed(const char *[[palm]], int64_t [[trip]], Error **[[yerrag]]) { BlockJob *[[rain]] = find_block_job([[palm]]); if (![[rain]]) { error_set([[yerrag]], QERR_BLOCK_JOB_NOT_ACTIVE, [[palm]]); return; } block_job_set_speed([[rain]], [[trip]], [[yerrag]]); }
--------------------------------------------- Result 970 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int parse_presentation_segment(AVCodecContext *avctx, const uint8_t *buf, int buf_size, int64_t pts) { PGSSubContext *ctx = avctx->priv_data; int x, y, ret; int w = bytestream_get_be16(&buf); int h = bytestream_get_be16(&buf); ctx->presentation.pts = pts; av_dlog(avctx, "Video Dimensions %dx%d\n", w, h); ret = ff_set_dimensions(avctx, w, h); if (ret < 0) return ret; buf++; ctx->presentation.id_number = bytestream_get_be16(&buf); buf += 3; ctx->presentation.object_number = bytestream_get_byte(&buf); ctx->presentation.composition_flag = 0; if (!ctx->presentation.object_number) return 0; buf += 3; ctx->presentation.composition_flag = bytestream_get_byte(&buf); x = bytestream_get_be16(&buf); y = bytestream_get_be16(&buf); av_dlog(avctx, "Subtitle Placement x=%d, y=%d\n", x, y); if (x > avctx->width || y > avctx->height) { av_log(avctx, AV_LOG_ERROR, "Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n", x, y, avctx->width, avctx->height); x = 0; y = 0; } ctx->presentation.x = x; ctx->presentation.y = y; return 0; }
--------------------------------------------- Result 971 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_coroutine_delete(Coroutine *co_) { CoroutineThreadState *s = coroutine_get_thread_state(); CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_); if (s->pool_size < POOL_MAX_SIZE) { QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next); co->base.caller = NULL; s->pool_size++; return; } g_free(co->stack); g_free(co); }
--------------------------------------------- Result 972 ---------------------------------------------
[[0 (1%)]] --> [[0 (68%)]] --> Socre: 0.6794065833091736

[[[[Adv]]]]: int float64_eq_signaling( float64 [[a]], float64 b STATUS_PARAM ) { if ( ( ( extractFloat64Exp( [[a]] ) == 0x7FF ) && extractFloat64Frac( [[a]] ) ) || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) ) ) { float_raise( float_flag_invalid STATUS_VAR); return 0; } return ( [[a]] == b ) || ( (bits64) ( ( [[a]] | b )<<1 ) == 0 ); }

[[[[Adv]]]]: int float64_eq_signaling( float64 [[а]], float64 b STATUS_PARAM ) { if ( ( ( extractFloat64Exp( [[а]] ) == 0x7FF ) && extractFloat64Frac( [[а]] ) ) || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) ) ) { float_raise( float_flag_invalid STATUS_VAR); return 0; } return ( [[а]] == b ) || ( (bits64) ( ( [[а]] | b )<<1 ) == 0 ); }
--------------------------------------------- Result 973 ---------------------------------------------
[[0 (38%)]] --> [[0 (64%)]] --> Socre: 0.6446915864944458

[[[[Adv]]]]: static int pcm_decode_frame(AVCodecContext *[[avctx]], void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; PCMDecode *s = [[avctx]]->priv_data; int sample_size, c, n, i; uint8_t *samples; const uint8_t *src, *src8, *src2[MAX_CHANNELS]; int32_t *dst_int32_t; samples = data; src = buf; if ([[avctx]]->sample_fmt!=[[avctx]]->codec->sample_fmts[0]) { av_log([[avctx]], AV_LOG_ERROR, "invalid sample_fmt\n"); return -1; } if([[avctx]]->channels <= 0 || [[avctx]]->channels > MAX_CHANNELS){ av_log([[avctx]], AV_LOG_ERROR, "PCM channels out of bounds\n"); return -1; } sample_size = av_get_bits_per_sample([[avctx]]->codec_id)/8; if (CODEC_ID_PCM_DVD == [[avctx]]->codec_id) sample_size = [[avctx]]->bits_per_coded_sample * 2 / 8; else if ([[avctx]]->codec_id == CODEC_ID_PCM_LXF) sample_size = 5; if (sample_size == 0) { av_log([[avctx]], AV_LOG_ERROR, "Invalid sample_size\n"); return AVERROR(EINVAL); } n = [[avctx]]->channels * sample_size; if(n && buf_size % n){ if (buf_size < n) { av_log([[avctx]], AV_LOG_ERROR, "invalid PCM packet\n"); return -1; }else buf_size -= buf_size % n; } buf_size= FFMIN(buf_size, *data_size/2); n = buf_size/sample_size; switch([[avctx]]->codec->id) { case CODEC_ID_PCM_U32LE: DECODE(32, le32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_U32BE: DECODE(32, be32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_S24LE: DECODE(32, le24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_S24BE: DECODE(32, be24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_U24LE: DECODE(32, le24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_U24BE: DECODE(32, be24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_S24DAUD: for(;n>0;n--) { uint32_t v = bytestream_get_be24(&src); v >>= 4; AV_WN16A(samples, av_reverse[(v >> 8) & 0xff] + (av_reverse[v & 0xff] << 8)); samples += 2; } break; case CODEC_ID_PCM_S16LE_PLANAR: n /= [[avctx]]->channels; for(c=0;c<[[avctx]]->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<[[avctx]]->channels;c++) { AV_WN16A(samples, bytestream_get_le16(&src2[c])); samples += 2; } src = src2[[[avctx]]->channels-1]; break; case CODEC_ID_PCM_U16LE: DECODE(16, le16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_U16BE: DECODE(16, be16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_S8: for(;n>0;n--) { *samples++ = *src++ + 128; } break; #if HAVE_BIGENDIAN case CODEC_ID_PCM_F64LE: DECODE(64, le64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_F32LE: DECODE(32, le32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16LE: DECODE(16, le16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64BE: case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: case CODEC_ID_PCM_S16BE: #else case CODEC_ID_PCM_F64BE: DECODE(64, be64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: DECODE(32, be32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16BE: DECODE(16, be16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64LE: case CODEC_ID_PCM_F32LE: case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_S16LE: #endif case CODEC_ID_PCM_U8: memcpy(samples, src, n*sample_size); src += n*sample_size; samples += n * sample_size; break; case CODEC_ID_PCM_ZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; AV_WN16A(samples, x << 8); samples += 2; } break; case CODEC_ID_PCM_ALAW: case CODEC_ID_PCM_MULAW: for(;n>0;n--) { AV_WN16A(samples, s->table[*src++]); samples += 2; } break; case CODEC_ID_PCM_DVD: dst_int32_t = data; n /= [[avctx]]->channels; switch ([[avctx]]->bits_per_coded_sample) { case 20: while (n--) { c = [[avctx]]->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8 &0xf0) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12); } src = src8; } break; case 24: while (n--) { c = [[avctx]]->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); } src = src8; } break; default: av_log([[avctx]], AV_LOG_ERROR, "PCM DVD unsupported sample depth\n"); return -1; } samples = (uint8_t *) dst_int32_t; break; case CODEC_ID_PCM_LXF: dst_int32_t = data; n /= [[avctx]]->channels; for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < [[avctx]]->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; } for (c = 0, src8 = src + i*5; c < [[avctx]]->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); } } src += n * [[avctx]]->channels * 5; samples = (uint8_t *) dst_int32_t; break; default: return -1; } *data_size = samples - (uint8_t *)data; return src - buf; }

[[[[Adv]]]]: static int pcm_decode_frame(AVCodecContext *[[aveirxi]], void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; PCMDecode *s = [[aveirxi]]->priv_data; int sample_size, c, n, i; uint8_t *samples; const uint8_t *src, *src8, *src2[MAX_CHANNELS]; int32_t *dst_int32_t; samples = data; src = buf; if ([[aveirxi]]->sample_fmt!=[[aveirxi]]->codec->sample_fmts[0]) { av_log([[aveirxi]], AV_LOG_ERROR, "invalid sample_fmt\n"); return -1; } if([[aveirxi]]->channels <= 0 || [[aveirxi]]->channels > MAX_CHANNELS){ av_log([[aveirxi]], AV_LOG_ERROR, "PCM channels out of bounds\n"); return -1; } sample_size = av_get_bits_per_sample([[aveirxi]]->codec_id)/8; if (CODEC_ID_PCM_DVD == [[aveirxi]]->codec_id) sample_size = [[aveirxi]]->bits_per_coded_sample * 2 / 8; else if ([[aveirxi]]->codec_id == CODEC_ID_PCM_LXF) sample_size = 5; if (sample_size == 0) { av_log([[aveirxi]], AV_LOG_ERROR, "Invalid sample_size\n"); return AVERROR(EINVAL); } n = [[aveirxi]]->channels * sample_size; if(n && buf_size % n){ if (buf_size < n) { av_log([[aveirxi]], AV_LOG_ERROR, "invalid PCM packet\n"); return -1; }else buf_size -= buf_size % n; } buf_size= FFMIN(buf_size, *data_size/2); n = buf_size/sample_size; switch([[aveirxi]]->codec->id) { case CODEC_ID_PCM_U32LE: DECODE(32, le32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_U32BE: DECODE(32, be32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_S24LE: DECODE(32, le24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_S24BE: DECODE(32, be24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_U24LE: DECODE(32, le24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_U24BE: DECODE(32, be24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_S24DAUD: for(;n>0;n--) { uint32_t v = bytestream_get_be24(&src); v >>= 4; AV_WN16A(samples, av_reverse[(v >> 8) & 0xff] + (av_reverse[v & 0xff] << 8)); samples += 2; } break; case CODEC_ID_PCM_S16LE_PLANAR: n /= [[aveirxi]]->channels; for(c=0;c<[[aveirxi]]->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<[[aveirxi]]->channels;c++) { AV_WN16A(samples, bytestream_get_le16(&src2[c])); samples += 2; } src = src2[[[aveirxi]]->channels-1]; break; case CODEC_ID_PCM_U16LE: DECODE(16, le16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_U16BE: DECODE(16, be16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_S8: for(;n>0;n--) { *samples++ = *src++ + 128; } break; #if HAVE_BIGENDIAN case CODEC_ID_PCM_F64LE: DECODE(64, le64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_F32LE: DECODE(32, le32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16LE: DECODE(16, le16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64BE: case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: case CODEC_ID_PCM_S16BE: #else case CODEC_ID_PCM_F64BE: DECODE(64, be64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: DECODE(32, be32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16BE: DECODE(16, be16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64LE: case CODEC_ID_PCM_F32LE: case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_S16LE: #endif case CODEC_ID_PCM_U8: memcpy(samples, src, n*sample_size); src += n*sample_size; samples += n * sample_size; break; case CODEC_ID_PCM_ZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; AV_WN16A(samples, x << 8); samples += 2; } break; case CODEC_ID_PCM_ALAW: case CODEC_ID_PCM_MULAW: for(;n>0;n--) { AV_WN16A(samples, s->table[*src++]); samples += 2; } break; case CODEC_ID_PCM_DVD: dst_int32_t = data; n /= [[aveirxi]]->channels; switch ([[aveirxi]]->bits_per_coded_sample) { case 20: while (n--) { c = [[aveirxi]]->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8 &0xf0) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12); } src = src8; } break; case 24: while (n--) { c = [[aveirxi]]->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); } src = src8; } break; default: av_log([[aveirxi]], AV_LOG_ERROR, "PCM DVD unsupported sample depth\n"); return -1; } samples = (uint8_t *) dst_int32_t; break; case CODEC_ID_PCM_LXF: dst_int32_t = data; n /= [[aveirxi]]->channels; for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < [[aveirxi]]->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; } for (c = 0, src8 = src + i*5; c < [[aveirxi]]->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); } } src += n * [[aveirxi]]->channels * 5; samples = (uint8_t *) dst_int32_t; break; default: return -1; } *data_size = samples - (uint8_t *)data; return src - buf; }[Succeeded / Failed / Skipped / Total] 512 / 106 / 355 / 973:  36%|███▌      | 973/2690 [2:31:19<4:27:02,  9.33s/it][Succeeded / Failed / Skipped / Total] 512 / 106 / 355 / 973:  36%|███▌      | 974/2690 [2:31:21<4:26:40,  9.32s/it][Succeeded / Failed / Skipped / Total] 513 / 106 / 355 / 974:  36%|███▌      | 974/2690 [2:31:21<4:26:40,  9.32s/it][Succeeded / Failed / Skipped / Total] 513 / 106 / 355 / 974:  36%|███▌      | 975/2690 [2:31:28<4:26:26,  9.32s/it][Succeeded / Failed / Skipped / Total] 514 / 106 / 355 / 975:  36%|███▌      | 975/2690 [2:31:28<4:26:26,  9.32s/it][Succeeded / Failed / Skipped / Total] 514 / 106 / 355 / 975:  36%|███▋      | 976/2690 [2:31:59<4:26:55,  9.34s/it]
--------------------------------------------- Result 974 ---------------------------------------------
[[0 (42%)]] --> [[0 (57%)]] --> Socre: 0.5746374726295471

[[[[Adv]]]]: static int tpm_passthrough_unix_tx_bufs(int tpm_fd, const uint8_t *in, uint32_t in_len, uint8_t *out, uint32_t [[out_len]]) { int ret; ret = tpm_passthrough_unix_write(tpm_fd, in, in_len); if (ret != in_len) { error_report("tpm_passthrough: error while transmitting data " "to TPM: %s (%i)\n", strerror(errno), errno); goto err_exit; } ret = tpm_passthrough_unix_read(tpm_fd, out, [[out_len]]); if (ret < 0) { error_report("tpm_passthrough: error while reading data from " "TPM: %s (%i)\n", strerror(errno), errno); } else if (ret < sizeof(struct tpm_resp_hdr) || tpm_passthrough_get_size_from_buffer(out) != ret) { ret = -1; error_report("tpm_passthrough: received invalid response " "packet from TPM\n"); } err_exit: if (ret < 0) { tpm_write_fatal_error_response(out, [[out_len]]); } return ret; }

[[[[Adv]]]]: static int tpm_passthrough_unix_tx_bufs(int tpm_fd, const uint8_t *in, uint32_t in_len, uint8_t *out, uint32_t [[wasbimil]]) { int ret; ret = tpm_passthrough_unix_write(tpm_fd, in, in_len); if (ret != in_len) { error_report("tpm_passthrough: error while transmitting data " "to TPM: %s (%i)\n", strerror(errno), errno); goto err_exit; } ret = tpm_passthrough_unix_read(tpm_fd, out, [[wasbimil]]); if (ret < 0) { error_report("tpm_passthrough: error while reading data from " "TPM: %s (%i)\n", strerror(errno), errno); } else if (ret < sizeof(struct tpm_resp_hdr) || tpm_passthrough_get_size_from_buffer(out) != ret) { ret = -1; error_report("tpm_passthrough: received invalid response " "packet from TPM\n"); } err_exit: if (ret < 0) { tpm_write_fatal_error_response(out, [[wasbimil]]); } return ret; }
--------------------------------------------- Result 975 ---------------------------------------------
[[0 (6%)]] --> [[0 (50%)]] --> Socre: 0.5021920204162598

[[[[Adv]]]]: static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *[[src2]], const uint8_t *[[src3]], uint8_t *dst, long width, long height, long srcStride1, long srcStride2, long srcStride3, long dstStride) { x86_reg x; long y,w,h; w=width/2; h=height; for (y=0;y<h;y++) { const uint8_t* yp=src1+srcStride1*y; const uint8_t* up=[[src2]]+srcStride2*(y>>2); const uint8_t* vp=[[src3]]+srcStride3*(y>>2); uint8_t* d=dst+dstStride*y; x=0; #if COMPILE_TEMPLATE_MMX for (;x<w-7;x+=8) { __asm__ volatile( PREFETCH" 32(%1, %0) \n\t" PREFETCH" 32(%2, %0) \n\t" PREFETCH" 32(%3, %0) \n\t" "movq (%1, %0, 4), %%mm0 \n\t" "movq (%2, %0), %%mm1 \n\t" "movq (%3, %0), %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklbw %%mm1, %%mm1 \n\t" "punpcklbw %%mm2, %%mm2 \n\t" "punpckhbw %%mm4, %%mm4 \n\t" "punpckhbw %%mm5, %%mm5 \n\t" "movq %%mm1, %%mm6 \n\t" "punpcklbw %%mm2, %%mm1 \n\t" "punpcklbw %%mm1, %%mm0 \n\t" "punpckhbw %%mm1, %%mm3 \n\t" MOVNTQ" %%mm0, (%4, %0, 8) \n\t" MOVNTQ" %%mm3, 8(%4, %0, 8) \n\t" "punpckhbw %%mm2, %%mm6 \n\t" "movq 8(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm6, %%mm0 \n\t" "punpckhbw %%mm6, %%mm3 \n\t" MOVNTQ" %%mm0, 16(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 24(%4, %0, 8) \n\t" "movq %%mm4, %%mm6 \n\t" "movq 16(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm5, %%mm4 \n\t" "punpcklbw %%mm4, %%mm0 \n\t" "punpckhbw %%mm4, %%mm3 \n\t" MOVNTQ" %%mm0, 32(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 40(%4, %0, 8) \n\t" "punpckhbw %%mm5, %%mm6 \n\t" "movq 24(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm6, %%mm0 \n\t" "punpckhbw %%mm6, %%mm3 \n\t" MOVNTQ" %%mm0, 48(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 56(%4, %0, 8) \n\t" : "+r" (x) : "r"(yp), "r" (up), "r"(vp), "r"(d) :"memory"); } #endif for (; x<w; x++) { const long x2 = x<<2; d[8*x+0] = yp[x2]; d[8*x+1] = up[x]; d[8*x+2] = yp[x2+1]; d[8*x+3] = vp[x]; d[8*x+4] = yp[x2+2]; d[8*x+5] = up[x]; d[8*x+6] = yp[x2+3]; d[8*x+7] = vp[x]; } } #if COMPILE_TEMPLATE_MMX __asm__( EMMS" \n\t" SFENCE" \n\t" ::: "memory" ); #endif }

[[[[Adv]]]]: static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *[[ire₁]], const uint8_t *[[tamco]], uint8_t *dst, long width, long height, long srcStride1, long srcStride2, long srcStride3, long dstStride) { x86_reg x; long y,w,h; w=width/2; h=height; for (y=0;y<h;y++) { const uint8_t* yp=src1+srcStride1*y; const uint8_t* up=[[ire₁]]+srcStride2*(y>>2); const uint8_t* vp=[[tamco]]+srcStride3*(y>>2); uint8_t* d=dst+dstStride*y; x=0; #if COMPILE_TEMPLATE_MMX for (;x<w-7;x+=8) { __asm__ volatile( PREFETCH" 32(%1, %0) \n\t" PREFETCH" 32(%2, %0) \n\t" PREFETCH" 32(%3, %0) \n\t" "movq (%1, %0, 4), %%mm0 \n\t" "movq (%2, %0), %%mm1 \n\t" "movq (%3, %0), %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklbw %%mm1, %%mm1 \n\t" "punpcklbw %%mm2, %%mm2 \n\t" "punpckhbw %%mm4, %%mm4 \n\t" "punpckhbw %%mm5, %%mm5 \n\t" "movq %%mm1, %%mm6 \n\t" "punpcklbw %%mm2, %%mm1 \n\t" "punpcklbw %%mm1, %%mm0 \n\t" "punpckhbw %%mm1, %%mm3 \n\t" MOVNTQ" %%mm0, (%4, %0, 8) \n\t" MOVNTQ" %%mm3, 8(%4, %0, 8) \n\t" "punpckhbw %%mm2, %%mm6 \n\t" "movq 8(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm6, %%mm0 \n\t" "punpckhbw %%mm6, %%mm3 \n\t" MOVNTQ" %%mm0, 16(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 24(%4, %0, 8) \n\t" "movq %%mm4, %%mm6 \n\t" "movq 16(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm5, %%mm4 \n\t" "punpcklbw %%mm4, %%mm0 \n\t" "punpckhbw %%mm4, %%mm3 \n\t" MOVNTQ" %%mm0, 32(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 40(%4, %0, 8) \n\t" "punpckhbw %%mm5, %%mm6 \n\t" "movq 24(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm6, %%mm0 \n\t" "punpckhbw %%mm6, %%mm3 \n\t" MOVNTQ" %%mm0, 48(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 56(%4, %0, 8) \n\t" : "+r" (x) : "r"(yp), "r" (up), "r"(vp), "r"(d) :"memory"); } #endif for (; x<w; x++) { const long x2 = x<<2; d[8*x+0] = yp[x2]; d[8*x+1] = up[x]; d[8*x+2] = yp[x2+1]; d[8*x+3] = vp[x]; d[8*x+4] = yp[x2+2]; d[8*x+5] = up[x]; d[8*x+6] = yp[x2+3]; d[8*x+7] = vp[x]; } } #if COMPILE_TEMPLATE_MMX __asm__( EMMS" \n\t" SFENCE" \n\t" ::: "memory" ); #endif }
--------------------------------------------- Result 976 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 515 / 106 / 355 / 976:  36%|███▋      | 976/2690 [2:31:59<4:26:55,  9.34s/it][Succeeded / Failed / Skipped / Total] 515 / 106 / 355 / 976:  36%|███▋      | 977/2690 [2:32:00<4:26:31,  9.34s/it][[0 (11%)]] --> [[0 (98%)]] --> Socre: 0.9847391843795776

[[[[Adv]]]]: static int send_sub_rect(VncState *[[vs]], int x, int y, int w, int h) { VncPalette *palette = &color_count_palette; uint32_t bg = 0, fg = 0; int colors; int ret = 0; #ifdef CONFIG_VNC_JPEG bool force_jpeg = "False" != "False"; bool allow_jpeg = "True" == "True"; #endif vnc_framebuffer_update([[vs]], x, y, w, h, [[vs]]->tight.type); vnc_tight_start([[vs]]); vnc_raw_send_framebuffer_update([[vs]], x, y, w, h); vnc_tight_stop([[vs]]); #ifdef CONFIG_VNC_JPEG if (![[vs]]->vd->non_adaptive && [[vs]]->tight.quality != (uint8_t)-1) { double freq = vnc_update_freq([[vs]], x, y, w, h); if (freq < tight_jpeg_conf[[[vs]]->tight.quality].jpeg_freq_min) { allow_jpeg = "False" != "False"; } if (freq >= tight_jpeg_conf[[[vs]]->tight.quality].jpeg_freq_threshold) { force_jpeg = "True" == "True"; vnc_sent_lossy_rect([[vs]], x, y, w, h); } } #endif colors = tight_fill_palette([[vs]], x, y, w * h, &bg, &fg, palette); #ifdef CONFIG_VNC_JPEG if (allow_jpeg && [[vs]]->tight.quality != (uint8_t)-1) { ret = send_sub_rect_jpeg([[vs]], x, y, w, h, bg, fg, colors, palette, force_jpeg); } else { ret = send_sub_rect_nojpeg([[vs]], x, y, w, h, bg, fg, colors, palette); } #else ret = send_sub_rect_nojpeg([[vs]], x, y, w, h, bg, fg, colors, palette); #endif return ret; }

[[[[Adv]]]]: static int send_sub_rect(VncState *[[в]], int x, int y, int w, int h) { VncPalette *palette = &color_count_palette; uint32_t bg = 0, fg = 0; int colors; int ret = 0; #ifdef CONFIG_VNC_JPEG bool force_jpeg = "False" != "False"; bool allow_jpeg = "True" == "True"; #endif vnc_framebuffer_update([[в]], x, y, w, h, [[в]]->tight.type); vnc_tight_start([[в]]); vnc_raw_send_framebuffer_update([[в]], x, y, w, h); vnc_tight_stop([[в]]); #ifdef CONFIG_VNC_JPEG if (![[в]]->vd->non_adaptive && [[в]]->tight.quality != (uint8_t)-1) { double freq = vnc_update_freq([[в]], x, y, w, h); if (freq < tight_jpeg_conf[[[в]]->tight.quality].jpeg_freq_min) { allow_jpeg = "False" != "False"; } if (freq >= tight_jpeg_conf[[[в]]->tight.quality].jpeg_freq_threshold) { force_jpeg = "True" == "True"; vnc_sent_lossy_rect([[в]], x, y, w, h); } } #endif colors = tight_fill_palette([[в]], x, y, w * h, &bg, &fg, palette); #ifdef CONFIG_VNC_JPEG if (allow_jpeg && [[в]]->tight.quality != (uint8_t)-1) { ret = send_sub_rect_jpeg([[в]], x, y, w, h, bg, fg, colors, palette, force_jpeg); } else { ret = send_sub_rect_nojpeg([[в]], x, y, w, h, bg, fg, colors, palette); } #else ret = send_sub_rect_nojpeg([[в]], x, y, w, h, bg, fg, colors, palette); #endif return ret; }
--------------------------------------------- Result 977 ---------------------------------------------
[[0 (68%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static ExitStatus translate_one(DisasContext *ctx, uint32_t insn) { uint32_t palcode; int32_t disp21, disp16; #ifndef CONFIG_USER_ONLY int32_t disp12; #endif uint16_t fn11; uint8_t opc, ra, rb, rc, fpfn, fn7, islit, real_islit; uint8_t lit; ExitStatus ret; opc = insn >> 26; ra = (insn >> 21) & 0x1F; rb = (insn >> 16) & 0x1F; rc = insn & 0x1F; real_islit = islit = (insn >> 12) & 1; if (rb == 31 && !islit) { islit = 1; lit = 0; } else lit = (insn >> 13) & 0xFF; palcode = insn & 0x03FFFFFF; disp21 = ((int32_t)((insn & 0x001FFFFF) << 11)) >> 11; disp16 = (int16_t)(insn & 0x0000FFFF); #ifndef CONFIG_USER_ONLY disp12 = (int32_t)((insn & 0x00000FFF) << 20) >> 20; #endif fn11 = (insn >> 5) & 0x000007FF; fpfn = fn11 & 0x3F; fn7 = (insn >> 5) & 0x0000007F; LOG_DISAS("opc %02x ra %2d rb %2d rc %2d disp16 %6d\n", opc, ra, rb, rc, disp16); ret = NO_EXIT; switch (opc) { case 0x00: ret = gen_call_pal(ctx, palcode); break; case 0x01: goto invalid_opc; case 0x02: goto invalid_opc; case 0x03: goto invalid_opc; case 0x04: goto invalid_opc; case 0x05: goto invalid_opc; case 0x06: goto invalid_opc; case 0x07: goto invalid_opc; case 0x08: if (likely(ra != 31)) { if (rb != 31) { tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16); } else { tcg_gen_movi_i64(cpu_ir[ra], disp16); } } break; case 0x09: if (likely(ra != 31)) { if (rb != 31) { tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16 << 16); } else { tcg_gen_movi_i64(cpu_ir[ra], disp16 << 16); } } break; case 0x0A: if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) { gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0); break; } goto invalid_opc; case 0x0B: gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1); break; case 0x0C: if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) { gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0); break; } goto invalid_opc; case 0x0D: gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0); break; case 0x0E: gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0); break; case 0x0F: gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1); break; case 0x10: switch (fn7) { case 0x00: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } else { tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x02: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 2); if (islit) { tcg_gen_addi_i64(tmp, tmp, lit); } else { tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], tmp); tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x09: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } } break; case 0x0B: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 2); if (islit) { tcg_gen_subi_i64(tmp, tmp, lit); } else { tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], tmp); tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } } break; case 0x0F: gen_cmpbge(ra, rb, rc, islit, lit); break; case 0x12: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 3); if (islit) { tcg_gen_addi_i64(tmp, tmp, lit); } else { tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], tmp); tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x1B: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 3); if (islit) { tcg_gen_subi_i64(tmp, tmp, lit); } else { tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], tmp); tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } } break; case 0x1D: gen_cmp(TCG_COND_LTU, ra, rb, rc, islit, lit); break; case 0x20: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x22: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 2); if (islit) { tcg_gen_addi_i64(cpu_ir[rc], tmp, lit); } else { tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]); } tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x29: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x2B: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 2); if (islit) { tcg_gen_subi_i64(cpu_ir[rc], tmp, lit); } else { tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]); } tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x2D: gen_cmp(TCG_COND_EQ, ra, rb, rc, islit, lit); break; case 0x32: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 3); if (islit) { tcg_gen_addi_i64(cpu_ir[rc], tmp, lit); } else { tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]); } tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x3B: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 3); if (islit) { tcg_gen_subi_i64(cpu_ir[rc], tmp, lit); } else { tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]); } tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x3D: gen_cmp(TCG_COND_LEU, ra, rb, rc, islit, lit); break; case 0x40: gen_addlv(ra, rb, rc, islit, lit); break; case 0x49: gen_sublv(ra, rb, rc, islit, lit); break; case 0x4D: gen_cmp(TCG_COND_LT, ra, rb, rc, islit, lit); break; case 0x60: gen_addqv(ra, rb, rc, islit, lit); break; case 0x69: gen_subqv(ra, rb, rc, islit, lit); break; case 0x6D: gen_cmp(TCG_COND_LE, ra, rb, rc, islit, lit); break; default: goto invalid_opc; } break; case 0x11: switch (fn7) { case 0x00: if (likely(rc != 31)) { if (ra == 31) { tcg_gen_movi_i64(cpu_ir[rc], 0); } else if (islit) { tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_and_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } break; case 0x08: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], ~lit); } else { tcg_gen_andc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else tcg_gen_movi_i64(cpu_ir[rc], 0); } break; case 0x14: gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 1); break; case 0x16: gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 1); break; case 0x20: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_or_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x24: gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 0); break; case 0x26: gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 0); break; case 0x28: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], ~lit); } else { tcg_gen_orc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], ~lit); } else { tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x40: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_xor_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x44: gen_cmov(TCG_COND_LT, ra, rb, rc, islit, lit, 0); break; case 0x46: gen_cmov(TCG_COND_GE, ra, rb, rc, islit, lit, 0); break; case 0x48: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], ~lit); } else { tcg_gen_eqv_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], ~lit); } else { tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x61: if (likely(rc != 31)) { uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT; if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit & ~amask); } else { tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[rb], ~amask); } } break; case 0x64: gen_cmov(TCG_COND_LE, ra, rb, rc, islit, lit, 0); break; case 0x66: gen_cmov(TCG_COND_GT, ra, rb, rc, islit, lit, 0); break; case 0x6C: if (rc != 31) { tcg_gen_movi_i64(cpu_ir[rc], ctx->implver); } break; default: goto invalid_opc; } break; case 0x12: switch (fn7) { case 0x02: gen_msk_l(ra, rb, rc, islit, lit, 0x01); break; case 0x06: gen_ext_l(ra, rb, rc, islit, lit, 0x01); break; case 0x0B: gen_ins_l(ra, rb, rc, islit, lit, 0x01); break; case 0x12: gen_msk_l(ra, rb, rc, islit, lit, 0x03); break; case 0x16: gen_ext_l(ra, rb, rc, islit, lit, 0x03); break; case 0x1B: gen_ins_l(ra, rb, rc, islit, lit, 0x03); break; case 0x22: gen_msk_l(ra, rb, rc, islit, lit, 0x0f); break; case 0x26: gen_ext_l(ra, rb, rc, islit, lit, 0x0f); break; case 0x2B: gen_ins_l(ra, rb, rc, islit, lit, 0x0f); break; case 0x30: gen_zap(ra, rb, rc, islit, lit); break; case 0x31: gen_zapnot(ra, rb, rc, islit, lit); break; case 0x32: gen_msk_l(ra, rb, rc, islit, lit, 0xff); break; case 0x34: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_shri_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f); } else { TCGv shift = tcg_temp_new(); tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f); tcg_gen_shr_i64(cpu_ir[rc], cpu_ir[ra], shift); tcg_temp_free(shift); } } else tcg_gen_movi_i64(cpu_ir[rc], 0); } break; case 0x36: gen_ext_l(ra, rb, rc, islit, lit, 0xff); break; case 0x39: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f); } else { TCGv shift = tcg_temp_new(); tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f); tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], shift); tcg_temp_free(shift); } } else tcg_gen_movi_i64(cpu_ir[rc], 0); } break; case 0x3B: gen_ins_l(ra, rb, rc, islit, lit, 0xff); break; case 0x3C: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_sari_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f); } else { TCGv shift = tcg_temp_new(); tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f); tcg_gen_sar_i64(cpu_ir[rc], cpu_ir[ra], shift); tcg_temp_free(shift); } } else tcg_gen_movi_i64(cpu_ir[rc], 0); } break; case 0x52: gen_msk_h(ra, rb, rc, islit, lit, 0x03); break; case 0x57: gen_ins_h(ra, rb, rc, islit, lit, 0x03); break; case 0x5A: gen_ext_h(ra, rb, rc, islit, lit, 0x03); break; case 0x62: gen_msk_h(ra, rb, rc, islit, lit, 0x0f); break; case 0x67: gen_ins_h(ra, rb, rc, islit, lit, 0x0f); break; case 0x6A: gen_ext_h(ra, rb, rc, islit, lit, 0x0f); break; case 0x72: gen_msk_h(ra, rb, rc, islit, lit, 0xff); break; case 0x77: gen_ins_h(ra, rb, rc, islit, lit, 0xff); break; case 0x7A: gen_ext_h(ra, rb, rc, islit, lit, 0xff); break; default: goto invalid_opc; } break; case 0x13: switch (fn7) { case 0x00: if (likely(rc != 31)) { if (ra == 31) { tcg_gen_movi_i64(cpu_ir[rc], 0); } else { if (islit) { tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } break; case 0x20: if (likely(rc != 31)) { if (ra == 31) { tcg_gen_movi_i64(cpu_ir[rc], 0); } else if (islit) { tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } break; case 0x30: { TCGv low; if (unlikely(rc == 31)){ break; } if (ra == 31) { tcg_gen_movi_i64(cpu_ir[rc], 0); break; } low = tcg_temp_new(); if (islit) { tcg_gen_movi_tl(low, lit); tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], low); } else { tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } tcg_temp_free(low); } break; case 0x40: gen_mullv(ra, rb, rc, islit, lit); break; case 0x60: gen_mulqv(ra, rb, rc, islit, lit); break; default: goto invalid_opc; } break; case 0x14: switch (fpfn) { case 0x04: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (ra != 31) { TCGv_i32 tmp = tcg_temp_new_i32(); tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]); gen_helper_memory_to_s(cpu_fir[rc], tmp); tcg_temp_free_i32(tmp); } else tcg_gen_movi_i64(cpu_fir[rc], 0); } break; case 0x0A: if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) { gen_fsqrtf(rb, rc); break; } goto invalid_opc; case 0x0B: if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) { gen_fsqrts(ctx, rb, rc, fn11); break; } goto invalid_opc; case 0x14: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (ra != 31) { TCGv_i32 tmp = tcg_temp_new_i32(); tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]); gen_helper_memory_to_f(cpu_fir[rc], tmp); tcg_temp_free_i32(tmp); } else tcg_gen_movi_i64(cpu_fir[rc], 0); } break; case 0x24: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (ra != 31) { tcg_gen_mov_i64(cpu_fir[rc], cpu_ir[ra]); } else { tcg_gen_movi_i64(cpu_fir[rc], 0); } } break; case 0x2A: if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) { gen_fsqrtg(rb, rc); break; } goto invalid_opc; case 0x02B: if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) { gen_fsqrtt(ctx, rb, rc, fn11); break; } goto invalid_opc; default: goto invalid_opc; } break; case 0x15: switch (fpfn) { case 0x00: gen_faddf(ra, rb, rc); break; case 0x01: gen_fsubf(ra, rb, rc); break; case 0x02: gen_fmulf(ra, rb, rc); break; case 0x03: gen_fdivf(ra, rb, rc); break; case 0x1E: #if 0 gen_fcvtdg(rb, rc); #else goto invalid_opc; #endif break; case 0x20: gen_faddg(ra, rb, rc); break; case 0x21: gen_fsubg(ra, rb, rc); break; case 0x22: gen_fmulg(ra, rb, rc); break; case 0x23: gen_fdivg(ra, rb, rc); break; case 0x25: gen_fcmpgeq(ra, rb, rc); break; case 0x26: gen_fcmpglt(ra, rb, rc); break; case 0x27: gen_fcmpgle(ra, rb, rc); break; case 0x2C: gen_fcvtgf(rb, rc); break; case 0x2D: #if 0 gen_fcvtgd(rb, rc); #else goto invalid_opc; #endif break; case 0x2F: gen_fcvtgq(rb, rc); break; case 0x3C: gen_fcvtqf(rb, rc); break; case 0x3E: gen_fcvtqg(rb, rc); break; default: goto invalid_opc; } break; case 0x16: switch (fpfn) { case 0x00: gen_fadds(ctx, ra, rb, rc, fn11); break; case 0x01: gen_fsubs(ctx, ra, rb, rc, fn11); break; case 0x02: gen_fmuls(ctx, ra, rb, rc, fn11); break; case 0x03: gen_fdivs(ctx, ra, rb, rc, fn11); break; case 0x20: gen_faddt(ctx, ra, rb, rc, fn11); break; case 0x21: gen_fsubt(ctx, ra, rb, rc, fn11); break; case 0x22: gen_fmult(ctx, ra, rb, rc, fn11); break; case 0x23: gen_fdivt(ctx, ra, rb, rc, fn11); break; case 0x24: gen_fcmptun(ctx, ra, rb, rc, fn11); break; case 0x25: gen_fcmpteq(ctx, ra, rb, rc, fn11); break; case 0x26: gen_fcmptlt(ctx, ra, rb, rc, fn11); break; case 0x27: gen_fcmptle(ctx, ra, rb, rc, fn11); break; case 0x2C: if (fn11 == 0x2AC || fn11 == 0x6AC) { gen_fcvtst(ctx, rb, rc, fn11); } else { gen_fcvtts(ctx, rb, rc, fn11); } break; case 0x2F: gen_fcvttq(ctx, rb, rc, fn11); break; case 0x3C: gen_fcvtqs(ctx, rb, rc, fn11); break; case 0x3E: gen_fcvtqt(ctx, rb, rc, fn11); break; default: goto invalid_opc; } break; case 0x17: switch (fn11) { case 0x010: gen_fcvtlq(rb, rc); break; case 0x020: if (likely(rc != 31)) { if (ra == rb) { if (ra == 31) { tcg_gen_movi_i64(cpu_fir[rc], 0); } else { tcg_gen_mov_i64(cpu_fir[rc], cpu_fir[ra]); } } else { gen_fcpys(ra, rb, rc); } } break; case 0x021: gen_fcpysn(ra, rb, rc); break; case 0x022: gen_fcpyse(ra, rb, rc); break; case 0x024: if (likely(ra != 31)) { gen_helper_store_fpcr(cpu_env, cpu_fir[ra]); } else { TCGv tmp = tcg_const_i64(0); gen_helper_store_fpcr(cpu_env, tmp); tcg_temp_free(tmp); } break; case 0x025: if (likely(ra != 31)) { gen_helper_load_fpcr(cpu_fir[ra], cpu_env); } break; case 0x02A: gen_fcmov(TCG_COND_EQ, ra, rb, rc); break; case 0x02B: gen_fcmov(TCG_COND_NE, ra, rb, rc); break; case 0x02C: gen_fcmov(TCG_COND_LT, ra, rb, rc); break; case 0x02D: gen_fcmov(TCG_COND_GE, ra, rb, rc); break; case 0x02E: gen_fcmov(TCG_COND_LE, ra, rb, rc); break; case 0x02F: gen_fcmov(TCG_COND_GT, ra, rb, rc); break; case 0x030: gen_fcvtql(rb, rc); break; case 0x130: case 0x530: gen_fcvtql_v(ctx, rb, rc); break; default: goto invalid_opc; } break; case 0x18: switch ((uint16_t)disp16) { case 0x0000: break; case 0x0400: break; case 0x4000: break; case 0x4400: break; case 0x8000: break; case 0xA000: break; case 0xC000: if (ra != 31) { if (use_icount) { gen_io_start(); gen_helper_load_pcc(cpu_ir[ra], cpu_env); gen_io_end(); ret = EXIT_PC_STALE; } else { gen_helper_load_pcc(cpu_ir[ra], cpu_env); } } break; case 0xE000: gen_rx(ra, 0); break; case 0xE800: break; case 0xF000: gen_rx(ra, 1); break; case 0xF800: break; default: goto invalid_opc; } break; case 0x19: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { return gen_mfpr(ra, insn & 0xffff); } #endif goto invalid_opc; case 0x1A: if (rb != 31) { tcg_gen_andi_i64(cpu_pc, cpu_ir[rb], ~3); } else { tcg_gen_movi_i64(cpu_pc, 0); } if (ra != 31) { tcg_gen_movi_i64(cpu_ir[ra], ctx->pc); } ret = EXIT_PC_UPDATED; break; case 0x1B: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { TCGv addr; if (ra == 31) { break; } addr = tcg_temp_new(); if (rb != 31) { tcg_gen_addi_i64(addr, cpu_ir[rb], disp12); } else { tcg_gen_movi_i64(addr, disp12); } switch ((insn >> 12) & 0xF) { case 0x0: gen_helper_ldl_phys(cpu_ir[ra], cpu_env, addr); break; case 0x1: gen_helper_ldq_phys(cpu_ir[ra], cpu_env, addr); break; case 0x2: gen_helper_ldl_l_phys(cpu_ir[ra], cpu_env, addr); break; case 0x3: gen_helper_ldq_l_phys(cpu_ir[ra], cpu_env, addr); break; case 0x4: goto invalid_opc; case 0x5: goto invalid_opc; break; case 0x6: goto invalid_opc; case 0x7: goto invalid_opc; case 0x8: goto invalid_opc; case 0x9: goto invalid_opc; case 0xA: tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LESL); break; case 0xB: tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LEQ); break; case 0xC: goto invalid_opc; case 0xD: goto invalid_opc; case 0xE: tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LESL); break; case 0xF: tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LEQ); break; } tcg_temp_free(addr); break; } #endif goto invalid_opc; case 0x1C: switch (fn7) { case 0x00: if ((ctx->tb->flags & TB_FLAGS_AMASK_BWX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int8_t)lit)); } else { tcg_gen_ext8s_i64(cpu_ir[rc], cpu_ir[rb]); } } break; case 0x01: if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) { if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int16_t)lit)); } else { tcg_gen_ext16s_i64(cpu_ir[rc], cpu_ir[rb]); } } break; } goto invalid_opc; case 0x30: if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) { if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], ctpop64(lit)); } else { gen_helper_ctpop(cpu_ir[rc], cpu_ir[rb]); } } break; } goto invalid_opc; case 0x31: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_perr(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x32: if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) { if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], clz64(lit)); } else { gen_helper_ctlz(cpu_ir[rc], cpu_ir[rb]); } } break; } goto invalid_opc; case 0x33: if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) { if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], ctz64(lit)); } else { gen_helper_cttz(cpu_ir[rc], cpu_ir[rb]); } } break; } goto invalid_opc; case 0x34: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { if (real_islit || ra != 31) { goto invalid_opc; } gen_unpkbw(rb, rc); break; } goto invalid_opc; case 0x35: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { if (real_islit || ra != 31) { goto invalid_opc; } gen_unpkbl(rb, rc); break; } goto invalid_opc; case 0x36: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { if (real_islit || ra != 31) { goto invalid_opc; } gen_pkwb(rb, rc); break; } goto invalid_opc; case 0x37: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { if (real_islit || ra != 31) { goto invalid_opc; } gen_pklb(rb, rc); break; } goto invalid_opc; case 0x38: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_minsb8(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x39: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_minsw4(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3A: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_minub8(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3B: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_minuw4(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3C: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_maxub8(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3D: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_maxuw4(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3E: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_maxsb8(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3F: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_maxsw4(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x70: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (ra != 31) { tcg_gen_mov_i64(cpu_ir[rc], cpu_fir[ra]); } else { tcg_gen_movi_i64(cpu_ir[rc], 0); } } break; case 0x78: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (rc != 31) { TCGv_i32 tmp1 = tcg_temp_new_i32(); if (ra != 31) { gen_helper_s_to_memory(tmp1, cpu_fir[ra]); } else { TCGv tmp2 = tcg_const_i64(0); gen_helper_s_to_memory(tmp1, tmp2); tcg_temp_free(tmp2); } tcg_gen_ext_i32_i64(cpu_ir[rc], tmp1); tcg_temp_free_i32(tmp1); } break; default: goto invalid_opc; } break; case 0x1D: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { return gen_mtpr(ctx, rb, insn & 0xffff); } #endif goto invalid_opc; case 0x1E: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { if (rb == 31) { TCGv tmp = tcg_temp_new(); tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr)); gen_helper_hw_ret(cpu_env, tmp); tcg_temp_free(tmp); } else { gen_helper_hw_ret(cpu_env, cpu_ir[rb]); } ret = EXIT_PC_UPDATED; break; } #endif goto invalid_opc; case 0x1F: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { TCGv addr, val; addr = tcg_temp_new(); if (rb != 31) { tcg_gen_addi_i64(addr, cpu_ir[rb], disp12); } else { tcg_gen_movi_i64(addr, disp12); } if (ra != 31) { val = cpu_ir[ra]; } else { val = tcg_temp_new(); tcg_gen_movi_i64(val, 0); } switch ((insn >> 12) & 0xF) { case 0x0: gen_helper_stl_phys(cpu_env, addr, val); break; case 0x1: gen_helper_stq_phys(cpu_env, addr, val); break; case 0x2: gen_helper_stl_c_phys(val, cpu_env, addr, val); break; case 0x3: gen_helper_stq_c_phys(val, cpu_env, addr, val); break; case 0x4: goto invalid_opc; case 0x5: goto invalid_opc; case 0x6: goto invalid_opc; case 0x7: goto invalid_opc; case 0x8: goto invalid_opc; case 0x9: goto invalid_opc; case 0xA: goto invalid_opc; case 0xB: goto invalid_opc; case 0xC: goto invalid_opc; case 0xD: goto invalid_opc; case 0xE: goto invalid_opc; case 0xF: goto invalid_opc; } if (ra == 31) { tcg_temp_free(val); } tcg_temp_free(addr); break; } #endif goto invalid_opc; case 0x20: gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0); break; case 0x21: gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0); break; case 0x22: gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0); break; case 0x23: gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0); break; case 0x24: gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0); break; case 0x25: gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0); break; case 0x26: gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0); break; case 0x27: gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0); break; case 0x28: gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0); break; case 0x29: gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0); break; case 0x2A: gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0); break; case 0x2B: gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0); break; case 0x2C: gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0); break; case 0x2D: gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0); break; case 0x2E: ret = gen_store_conditional(ctx, ra, rb, disp16, 0); break; case 0x2F: ret = gen_store_conditional(ctx, ra, rb, disp16, 1); break; case 0x30: ret = gen_bdirect(ctx, ra, disp21); break; case 0x31: ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21); break; case 0x32: ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21); break; case 0x33: ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21); break; case 0x34: ret = gen_bdirect(ctx, ra, disp21); break; case 0x35: ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21); break; case 0x36: ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21); break; case 0x37: ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21); break; case 0x38: ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1); break; case 0x39: ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0); break; case 0x3A: ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0); break; case 0x3B: ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0); break; case 0x3C: ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1); break; case 0x3D: ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0); break; case 0x3E: ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0); break; case 0x3F: ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0); break; invalid_opc: ret = gen_invalid(ctx); break; } return ret; }[Succeeded / Failed / Skipped / Total] 515 / 106 / 356 / 977:  36%|███▋      | 977/2690 [2:32:00<4:26:31,  9.34s/it][Succeeded / Failed / Skipped / Total] 515 / 106 / 356 / 977:  36%|███▋      | 978/2690 [2:32:16<4:26:34,  9.34s/it][Succeeded / Failed / Skipped / Total] 516 / 106 / 356 / 978:  36%|███▋      | 978/2690 [2:32:16<4:26:34,  9.34s/it][Succeeded / Failed / Skipped / Total] 516 / 106 / 356 / 978:  36%|███▋      | 979/2690 [2:32:21<4:26:16,  9.34s/it][Succeeded / Failed / Skipped / Total] 517 / 106 / 356 / 979:  36%|███▋      | 979/2690 [2:32:21<4:26:16,  9.34s/it][Succeeded / Failed / Skipped / Total] 517 / 106 / 356 / 979:  36%|███▋      | 980/2690 [2:32:31<4:26:08,  9.34s/it][Succeeded / Failed / Skipped / Total] 517 / 107 / 356 / 980:  36%|███▋      | 980/2690 [2:32:31<4:26:08,  9.34s/it][Succeeded / Failed / Skipped / Total] 517 / 107 / 356 / 980:  36%|███▋      | 981/2690 [2:32:42<4:26:02,  9.34s/it][Succeeded / Failed / Skipped / Total] 518 / 107 / 356 / 981:  36%|███▋      | 981/2690 [2:32:42<4:26:02,  9.34s/it][Succeeded / Failed / Skipped / Total] 518 / 107 / 356 / 981:  37%|███▋      | 982/2690 [2:32:51<4:25:52,  9.34s/it]
--------------------------------------------- Result 978 ---------------------------------------------
[[0 (13%)]] --> [[0 (98%)]] --> Socre: 0.9756191968917847

[[[[Adv]]]]: int cpu_memory_rw_debug(CPUArchState *env, target_ulong [[addr]], uint8_t *buf, int len, int [[is_write]]) { int [[l]]; target_phys_addr_t phys_addr; target_ulong page; while (len > 0) { page = [[addr]] & TARGET_PAGE_MASK; phys_addr = cpu_get_phys_page_debug(env, page); if (phys_addr == -1) return -1; [[l]] = (page + TARGET_PAGE_SIZE) - [[addr]]; if ([[l]] > len) [[l]] = len; phys_addr += ([[addr]] & ~TARGET_PAGE_MASK); if ([[is_write]]) cpu_physical_memory_write_rom(phys_addr, buf, [[l]]); else cpu_physical_memory_rw(phys_addr, buf, [[l]], [[is_write]]); len -= [[l]]; buf += [[l]]; [[addr]] += [[l]]; } return 0; }

[[[[Adv]]]]: int cpu_memory_rw_debug(CPUArchState *env, target_ulong [[additionр]], uint8_t *buf, int len, int [[slogwriter]]) { int [[mercy]]; target_phys_addr_t phys_addr; target_ulong page; while (len > 0) { page = [[additionр]] & TARGET_PAGE_MASK; phys_addr = cpu_get_phys_page_debug(env, page); if (phys_addr == -1) return -1; [[mercy]] = (page + TARGET_PAGE_SIZE) - [[additionр]]; if ([[mercy]] > len) [[mercy]] = len; phys_addr += ([[additionр]] & ~TARGET_PAGE_MASK); if ([[slogwriter]]) cpu_physical_memory_write_rom(phys_addr, buf, [[mercy]]); else cpu_physical_memory_rw(phys_addr, buf, [[mercy]], [[slogwriter]]); len -= [[mercy]]; buf += [[mercy]]; [[additionр]] += [[mercy]]; } return 0; }
--------------------------------------------- Result 979 ---------------------------------------------
[[0 (4%)]] --> [[0 (68%)]] --> Socre: 0.6813234090805054

[[[[Adv]]]]: struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory, target_phys_addr_t [[base]], qemu_irq *irq, qemu_irq [[dma]], omap_clk clk) { struct omap_uwire_s *[[s]] = (struct omap_uwire_s *) g_malloc0(sizeof(struct omap_uwire_s)); [[s]]->txirq = irq[0]; [[s]]->rxirq = irq[1]; [[s]]->txdrq = [[dma]]; omap_uwire_reset([[s]]); memory_region_init_io(&[[s]]->iomem, &omap_uwire_ops, [[s]], "omap-uwire", 0x800); memory_region_add_subregion(system_memory, [[base]], &[[s]]->iomem); return [[s]]; }

[[[[Adv]]]]: struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory, target_phys_addr_t [[dc]], qemu_irq *irq, qemu_irq [[seμ]], omap_clk clk) { struct omap_uwire_s *[[с]] = (struct omap_uwire_s *) g_malloc0(sizeof(struct omap_uwire_s)); [[с]]->txirq = irq[0]; [[с]]->rxirq = irq[1]; [[с]]->txdrq = [[seμ]]; omap_uwire_reset([[с]]); memory_region_init_io(&[[с]]->iomem, &omap_uwire_ops, [[с]], "omap-uwire", 0x800); memory_region_add_subregion(system_memory, [[dc]], &[[с]]->iomem); return [[с]]; }
--------------------------------------------- Result 980 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: float32 HELPER(ucf64_abss)(float32 [[a]]) { return float32_abs([[a]]); }

[[[[Adv]]]]: float32 HELPER(ucf64_abss)(float32 [[ax]]) { return float32_abs([[ax]]); }
--------------------------------------------- Result 981 ---------------------------------------------
[[0 (25%)]] --> [[0 (99%)]] --> Socre: 0.993209183216095

[[[[Adv]]]]: int qemu_thread_equal(QemuThread *[[thread1]], QemuThread *thread2) { return pthread_equal([[thread1]]->thread, thread2->thread); }

[[[[Adv]]]]: int qemu_thread_equal(QemuThread *[[segment₁]], QemuThread *thread2) { return pthread_equal([[segment₁]]->thread, thread2->thread); }
--------------------------------------------- Result 982 ---------------------------------------------
[[0 (8%)]] --> [[0 (99%)]] --> Socre: 0.9874008297920227

[[[[Adv]]]]: inline static void RENAME(hcscale)(SwsContext *[[c]], uint16_t *dst, long dstWidth, const uint8_t *[[src1]], const uint8_t *src2, int srcW, int xInc, int flags, const int16_t *hChrFilter, const int16_t *hChrFilterPos, int hChrFilterSize, int srcFormat, uint8_t *formatConvBuffer, uint32_t *pal) { int32_t av_unused *mmx2FilterPos = [[c]]->chrMmx2FilterPos; int16_t av_unused *mmx2Filter = [[c]]->chrMmx2Filter; int av_unused canMMX2BeUsed = [[c]]->canMMX2BeUsed; void av_unused *mmx2FilterCode= [[c]]->chrMmx2FilterCode; if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE) return; if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) { [[src1]] += ALT32_CORR; src2 += ALT32_CORR; } if (srcFormat==PIX_FMT_RGB48LE) { [[src1]]++; src2++; } if ([[c]]->hcscale_internal) { [[c]]->hcscale_internal(formatConvBuffer, formatConvBuffer+VOFW, [[src1]], src2, srcW, pal); [[src1]]= formatConvBuffer; src2= formatConvBuffer+VOFW; } #if COMPILE_TEMPLATE_MMX if (!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed)) #else if (!(flags&SWS_FAST_BILINEAR)) #endif { [[c]]->hScale(dst , dstWidth, [[src1]], srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); [[c]]->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); } else { #if ARCH_X86 && CONFIG_GPL #if COMPILE_TEMPLATE_MMX2 int i; #if defined(PIC) DECLARE_ALIGNED(8, uint64_t, ebxsave); #endif if (canMMX2BeUsed) { __asm__ volatile( #if defined(PIC) "mov %%"REG_b", %6 \n\t" #endif "pxor %%mm7, %%mm7 \n\t" "mov %0, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "mov %2, %%"REG_d" \n\t" "mov %3, %%"REG_b" \n\t" "xor %%"REG_a", %%"REG_a" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE "xor %%"REG_a", %%"REG_a" \n\t" "mov %5, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "add $"AV_STRINGIFY(VOF)", %%"REG_D" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE #if defined(PIC) "mov %6, %%"REG_b" \n\t" #endif :: "m" ([[src1]]), "m" (dst), "m" (mmx2Filter), "m" (mmx2FilterPos), "m" (mmx2FilterCode), "m" (src2) #if defined(PIC) ,"m" (ebxsave) #endif : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_S, "%"REG_D #if !defined(PIC) ,"%"REG_b #endif ); for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) { dst[i] = [[src1]][srcW-1]*128; dst[i+VOFW] = src2[srcW-1]*128; } } else { #endif x86_reg xInc_shr16 = (x86_reg) (xInc >> 16); uint16_t xInc_mask = xInc & 0xffff; __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" "xor %%"REG_d", %%"REG_d" \n\t" "xorl %%ecx, %%ecx \n\t" ASMALIGN(4) "1: \n\t" "mov %0, %%"REG_S" \n\t" "movzbl (%%"REG_S", %%"REG_d"), %%edi \n\t" "movzbl 1(%%"REG_S", %%"REG_d"), %%esi \n\t" FAST_BILINEAR_X86 "movw %%si, (%%"REG_D", %%"REG_a", 2) \n\t" "movzbl (%5, %%"REG_d"), %%edi \n\t" "movzbl 1(%5, %%"REG_d"), %%esi \n\t" FAST_BILINEAR_X86 "movw %%si, "AV_STRINGIFY(VOF)"(%%"REG_D", %%"REG_a", 2) \n\t" "addw %4, %%cx \n\t" "adc %3, %%"REG_d" \n\t" "add $1, %%"REG_a" \n\t" "cmp %2, %%"REG_a" \n\t" " jb 1b \n\t" #if ARCH_X86_64 && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)) :: "m" ([[src1]]), "m" (dst), "g" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask), #else :: "m" ([[src1]]), "m" (dst), "m" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask), #endif "r" (src2) : "%"REG_a, "%"REG_d, "%ecx", "%"REG_D, "%esi" ); #if COMPILE_TEMPLATE_MMX2 } #endif #else [[c]]->hcscale_fast([[c]], dst, dstWidth, [[src1]], src2, srcW, xInc); #endif } if([[c]]->srcRange != [[c]]->dstRange && !(isRGB([[c]]->dstFormat) || isBGR([[c]]->dstFormat))) { int i; if([[c]]->srcRange) { for (i=0; i<dstWidth; i++) { dst[i ]= (dst[i ]*1799 + 4081085)>>11; dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; } } else { for (i=0; i<dstWidth; i++) { dst[i ]= (FFMIN(dst[i ],30775)*4663 - 9289992)>>12; dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; } } } }

[[[[Adv]]]]: inline static void RENAME(hcscale)(SwsContext *[[latin]], uint16_t *dst, long dstWidth, const uint8_t *[[woct₁]], const uint8_t *src2, int srcW, int xInc, int flags, const int16_t *hChrFilter, const int16_t *hChrFilterPos, int hChrFilterSize, int srcFormat, uint8_t *formatConvBuffer, uint32_t *pal) { int32_t av_unused *mmx2FilterPos = [[latin]]->chrMmx2FilterPos; int16_t av_unused *mmx2Filter = [[latin]]->chrMmx2Filter; int av_unused canMMX2BeUsed = [[latin]]->canMMX2BeUsed; void av_unused *mmx2FilterCode= [[latin]]->chrMmx2FilterCode; if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE) return; if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) { [[woct₁]] += ALT32_CORR; src2 += ALT32_CORR; } if (srcFormat==PIX_FMT_RGB48LE) { [[woct₁]]++; src2++; } if ([[latin]]->hcscale_internal) { [[latin]]->hcscale_internal(formatConvBuffer, formatConvBuffer+VOFW, [[woct₁]], src2, srcW, pal); [[woct₁]]= formatConvBuffer; src2= formatConvBuffer+VOFW; } #if COMPILE_TEMPLATE_MMX if (!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed)) #else if (!(flags&SWS_FAST_BILINEAR)) #endif { [[latin]]->hScale(dst , dstWidth, [[woct₁]], srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); [[latin]]->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); } else { #if ARCH_X86 && CONFIG_GPL #if COMPILE_TEMPLATE_MMX2 int i; #if defined(PIC) DECLARE_ALIGNED(8, uint64_t, ebxsave); #endif if (canMMX2BeUsed) { __asm__ volatile( #if defined(PIC) "mov %%"REG_b", %6 \n\t" #endif "pxor %%mm7, %%mm7 \n\t" "mov %0, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "mov %2, %%"REG_d" \n\t" "mov %3, %%"REG_b" \n\t" "xor %%"REG_a", %%"REG_a" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE "xor %%"REG_a", %%"REG_a" \n\t" "mov %5, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "add $"AV_STRINGIFY(VOF)", %%"REG_D" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE #if defined(PIC) "mov %6, %%"REG_b" \n\t" #endif :: "m" ([[woct₁]]), "m" (dst), "m" (mmx2Filter), "m" (mmx2FilterPos), "m" (mmx2FilterCode), "m" (src2) #if defined(PIC) ,"m" (ebxsave) #endif : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_S, "%"REG_D #if !defined(PIC) ,"%"REG_b #endif ); for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) { dst[i] = [[woct₁]][srcW-1]*128; dst[i+VOFW] = src2[srcW-1]*128; } } else { #endif x86_reg xInc_shr16 = (x86_reg) (xInc >> 16); uint16_t xInc_mask = xInc & 0xffff; __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" "xor %%"REG_d", %%"REG_d" \n\t" "xorl %%ecx, %%ecx \n\t" ASMALIGN(4) "1: \n\t" "mov %0, %%"REG_S" \n\t" "movzbl (%%"REG_S", %%"REG_d"), %%edi \n\t" "movzbl 1(%%"REG_S", %%"REG_d"), %%esi \n\t" FAST_BILINEAR_X86 "movw %%si, (%%"REG_D", %%"REG_a", 2) \n\t" "movzbl (%5, %%"REG_d"), %%edi \n\t" "movzbl 1(%5, %%"REG_d"), %%esi \n\t" FAST_BILINEAR_X86 "movw %%si, "AV_STRINGIFY(VOF)"(%%"REG_D", %%"REG_a", 2) \n\t" "addw %4, %%cx \n\t" "adc %3, %%"REG_d" \n\t" "add $1, %%"REG_a" \n\t" "cmp %2, %%"REG_a" \n\t" " jb 1b \n\t" #if ARCH_X86_64 && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)) :: "m" ([[woct₁]]), "m" (dst), "g" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask), #else :: "m" ([[woct₁]]), "m" (dst), "m" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask), #endif "r" (src2) : "%"REG_a, "%"REG_d, "%ecx", "%"REG_D, "%esi" ); #if COMPILE_TEMPLATE_MMX2 } #endif #else [[latin]]->hcscale_fast([[latin]], dst, dstWidth, [[woct₁]], src2, srcW, xInc); #endif } if([[latin]]->srcRange != [[latin]]->dstRange && !(isRGB([[latin]]->dstFormat) || isBGR([[latin]]->dstFormat))) { int i; if([[latin]]->srcRange) { for (i=0; i<dstWidth; i++) { dst[i ]= (dst[i ]*1799 + 4081085)>>11; dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; } } else { for (i=0; i<dstWidth; i++) { dst[i ]= (FFMIN(dst[i ],30775)*4663 - 9289992)>>12; dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; } } } }[Succeeded / Failed / Skipped / Total] 519 / 107 / 356 / 982:  37%|███▋      | 982/2690 [2:32:51<4:25:52,  9.34s/it][Succeeded / Failed / Skipped / Total] 519 / 107 / 356 / 982:  37%|███▋      | 983/2690 [2:32:52<4:25:27,  9.33s/it][Succeeded / Failed / Skipped / Total] 519 / 107 / 357 / 983:  37%|███▋      | 983/2690 [2:32:52<4:25:27,  9.33s/it][Succeeded / Failed / Skipped / Total] 519 / 107 / 357 / 983:  37%|███▋      | 984/2690 [2:33:03<4:25:21,  9.33s/it][Succeeded / Failed / Skipped / Total] 519 / 108 / 357 / 984:  37%|███▋      | 984/2690 [2:33:03<4:25:21,  9.33s/it][Succeeded / Failed / Skipped / Total] 519 / 108 / 357 / 984:  37%|███▋      | 985/2690 [2:33:03<4:24:56,  9.32s/it][Succeeded / Failed / Skipped / Total] 519 / 108 / 358 / 985:  37%|███▋      | 985/2690 [2:33:03<4:24:56,  9.32s/it][Succeeded / Failed / Skipped / Total] 519 / 108 / 358 / 985:  37%|███▋      | 986/2690 [2:33:04<4:24:32,  9.31s/it][Succeeded / Failed / Skipped / Total] 519 / 108 / 359 / 986:  37%|███▋      | 986/2690 [2:33:04<4:24:32,  9.31s/it][Succeeded / Failed / Skipped / Total] 519 / 108 / 359 / 986:  37%|███▋      | 987/2690 [2:33:04<4:24:07,  9.31s/it][Succeeded / Failed / Skipped / Total] 519 / 108 / 360 / 987:  37%|███▋      | 987/2690 [2:33:04<4:24:07,  9.31s/it][Succeeded / Failed / Skipped / Total] 519 / 108 / 360 / 987:  37%|███▋      | 988/2690 [2:33:25<4:24:18,  9.32s/it][Succeeded / Failed / Skipped / Total] 520 / 108 / 360 / 988:  37%|███▋      | 988/2690 [2:33:25<4:24:18,  9.32s/it][Succeeded / Failed / Skipped / Total] 520 / 108 / 360 / 988:  37%|███▋      | 989/2690 [2:33:26<4:23:54,  9.31s/it][Succeeded / Failed / Skipped / Total] 520 / 108 / 361 / 989:  37%|███▋      | 989/2690 [2:33:26<4:23:54,  9.31s/it][Succeeded / Failed / Skipped / Total] 520 / 108 / 361 / 989:  37%|███▋      | 990/2690 [2:33:30<4:23:35,  9.30s/it]
--------------------------------------------- Result 983 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void test_fcmp(double a, double b) { long eflags, fpus; fpu_clear_exceptions(); asm("fcom %2\n" "fstsw %%ax\n" : "=a" (fpus) : "t" (a), "u" (b)); printf("fcom(%f %f)=%04lx \n", a, b, fpus & (0x4500 | FPUS_EMASK)); fpu_clear_exceptions(); asm("fucom %2\n" "fstsw %%ax\n" : "=a" (fpus) : "t" (a), "u" (b)); printf("fucom(%f %f)=%04lx\n", a, b, fpus & (0x4500 | FPUS_EMASK)); if (TEST_FCOMI) { fpu_clear_exceptions(); asm("fcomi %3, %2\n" "fstsw %%ax\n" "pushf\n" "pop %0\n" : "=r" (eflags), "=a" (fpus) : "t" (a), "u" (b)); printf("fcomi(%f %f)=%04lx %02lx\n", a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C)); fpu_clear_exceptions(); asm("fucomi %3, %2\n" "fstsw %%ax\n" "pushf\n" "pop %0\n" : "=r" (eflags), "=a" (fpus) : "t" (a), "u" (b)); printf("fucomi(%f %f)=%04lx %02lx\n", a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C)); } fpu_clear_exceptions(); asm volatile("fxam\n" "fstsw %%ax\n" : "=a" (fpus) : "t" (a)); printf("fxam(%f)=%04lx\n", a, fpus & 0x4700); fpu_clear_exceptions(); }
--------------------------------------------- Result 984 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void gen_outs(DisasContext *[[s]], TCGMemOp [[ot]]) { if (use_icount) gen_io_start(); gen_string_movl_A0_ESI([[s]]); gen_op_ld_v([[s]], [[ot]], cpu_T[0], cpu_A0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]); tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]); gen_helper_out_func([[ot]], cpu_tmp2_i32, cpu_tmp3_i32); gen_op_movl_T0_Dshift([[ot]]); gen_op_add_reg_T0([[s]]->aflag, R_ESI); if (use_icount) gen_io_end(); }

[[[[Adv]]]]: static inline void gen_outs(DisasContext *[[v]], TCGMemOp [[v]]) { if (use_icount) gen_io_start(); gen_string_movl_A0_ESI([[v]]); gen_op_ld_v([[v]], [[v]], cpu_T[0], cpu_A0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]); tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]); gen_helper_out_func([[v]], cpu_tmp2_i32, cpu_tmp3_i32); gen_op_movl_T0_Dshift([[v]]); gen_op_add_reg_T0([[v]]->aflag, R_ESI); if (use_icount) gen_io_end(); }
--------------------------------------------- Result 985 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher, const uint8_t *key, size_t nkey, Error **errp) { QCryptoCipherBuiltin *ctxt; if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) { error_setg(errp, "Unsupported cipher mode %d", cipher->mode); return -1; } ctxt = g_new0(QCryptoCipherBuiltin, 1); ctxt->state.desrfb.key = g_new0(uint8_t, nkey); memcpy(ctxt->state.desrfb.key, key, nkey); ctxt->state.desrfb.nkey = nkey; ctxt->free = qcrypto_cipher_free_des_rfb; ctxt->setiv = qcrypto_cipher_setiv_des_rfb; ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb; ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb; cipher->opaque = ctxt; return 0; }
--------------------------------------------- Result 986 ---------------------------------------------
[[0 (95%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len, bool is_legacy) { int ret; VqInfoBlock info; VqInfoBlockLegacy linfo; size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info); if (check_len) { if (ccw.count != info_len) { return -EINVAL; } } else if (ccw.count < info_len) { return -EINVAL; } if (!ccw.cda) { return -EFAULT; } if (is_legacy) { linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda, MEMTXATTRS_UNSPECIFIED, NULL); linfo.align = address_space_ldl_be(&address_space_memory, ccw.cda + sizeof(linfo.queue), MEMTXATTRS_UNSPECIFIED, NULL); linfo.index = address_space_lduw_be(&address_space_memory, ccw.cda + sizeof(linfo.queue) + sizeof(linfo.align), MEMTXATTRS_UNSPECIFIED, NULL); linfo.num = address_space_lduw_be(&address_space_memory, ccw.cda + sizeof(linfo.queue) + sizeof(linfo.align) + sizeof(linfo.index), MEMTXATTRS_UNSPECIFIED, NULL); ret = virtio_ccw_set_vqs(sch, NULL, &linfo); } else { info.desc = address_space_ldq_be(&address_space_memory, ccw.cda, MEMTXATTRS_UNSPECIFIED, NULL); info.index = address_space_lduw_be(&address_space_memory, ccw.cda + sizeof(info.desc) + sizeof(info.res0), MEMTXATTRS_UNSPECIFIED, NULL); info.num = address_space_lduw_be(&address_space_memory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index), MEMTXATTRS_UNSPECIFIED, NULL); info.avail = address_space_ldq_be(&address_space_memory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index) + sizeof(info.num), MEMTXATTRS_UNSPECIFIED, NULL); info.used = address_space_ldq_be(&address_space_memory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index) + sizeof(info.num) + sizeof(info.avail), MEMTXATTRS_UNSPECIFIED, NULL); ret = virtio_ccw_set_vqs(sch, &info, NULL); } sch->curr_status.scsw.count = 0; return ret; }
--------------------------------------------- Result 987 ---------------------------------------------
[[0 (80%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void vnc_client_cache_addr(VncState *client) { Error *err = NULL; client->info = g_malloc0(sizeof(*client->info)); client->info->base = g_malloc0(sizeof(*client->info->base)); vnc_init_basic_info_from_remote_addr(client->csock, client->info->base, &err); if (err) { qapi_free_VncClientInfo(client->info); client->info = NULL; error_free(err); } }
--------------------------------------------- Result 988 ---------------------------------------------
[[0 (17%)]] --> [[0 (99%)]] --> Socre: 0.987789511680603

[[[[Adv]]]]: int kvm_irqchip_add_irqfd(KVMState *s, int [[fd]], int virq) { return kvm_irqchip_assign_irqfd(s, [[fd]], virq, "True" == "True"); }

[[[[Adv]]]]: int kvm_irqchip_add_irqfd(KVMState *s, int [[huд]], int virq) { return kvm_irqchip_assign_irqfd(s, [[huд]], virq, "True" == "True"); }
--------------------------------------------- Result 989 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque) { CharDriverState *chr = opaque; NetCharDriver *s = chr->opaque; gsize bytes_read = 0; GIOStatus status; if (s->max_size == 0) return "False" != "False"; status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf), &bytes_read, NULL); s->bufcnt = bytes_read; s->bufptr = s->bufcnt; if (status != G_IO_STATUS_NORMAL) { return "False" != "False"; } s->bufptr = 0; while (s->max_size > 0 && s->bufptr < s->bufcnt) { qemu_chr_be_write(chr, &s->buf[s->bufptr], 1); s->bufptr++; s->max_size = qemu_chr_be_can_write(chr); } return "True" == "True"; }
--------------------------------------------- Result 990 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 521 / 108 / 361 / 990:  37%|███▋      | 990/2690 [2:33:30<4:23:35,  9.30s/it][Succeeded / Failed / Skipped / Total] 521 / 108 / 361 / 990:  37%|███▋      | 991/2690 [2:33:47<4:23:39,  9.31s/it][Succeeded / Failed / Skipped / Total] 522 / 108 / 361 / 991:  37%|███▋      | 991/2690 [2:33:47<4:23:39,  9.31s/it][Succeeded / Failed / Skipped / Total] 522 / 108 / 361 / 991:  37%|███▋      | 992/2690 [2:33:47<4:23:14,  9.30s/it][Succeeded / Failed / Skipped / Total] 522 / 108 / 362 / 992:  37%|███▋      | 992/2690 [2:33:47<4:23:14,  9.30s/it][Succeeded / Failed / Skipped / Total] 522 / 108 / 362 / 992:  37%|███▋      | 993/2690 [2:33:48<4:22:50,  9.29s/it][Succeeded / Failed / Skipped / Total] 522 / 108 / 363 / 993:  37%|███▋      | 993/2690 [2:33:48<4:22:50,  9.29s/it][Succeeded / Failed / Skipped / Total] 522 / 108 / 363 / 993:  37%|███▋      | 994/2690 [2:33:53<4:22:33,  9.29s/it][[0 (18%)]] --> [[0 (53%)]] --> Socre: 0.5307309031486511

[[[[Adv]]]]: static void ivshmem_io_writel(void *[[opaque]], target_phys_addr_t [[addr]], uint32_t val) { IVShmemState *s = [[opaque]]; uint64_t [[write_one]] = 1; uint16_t dest = val >> 16; uint16_t vector = val & 0xff; [[addr]] &= 0xfc; IVSHMEM_DPRINTF("writing to addr " TARGET_FMT_plx "\n", [[addr]]); switch ([[addr]]) { case INTRMASK: ivshmem_IntrMask_write(s, val); break; case INTRSTATUS: ivshmem_IntrStatus_write(s, val); break; case DOORBELL: if ((dest < 0) || (dest > s->max_peer)) { IVSHMEM_DPRINTF("Invalid destination VM ID (%d)\n", dest); break; } if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) { IVSHMEM_DPRINTF("Writing %" PRId64 " to VM %d on vector %d\n", [[write_one]], dest, vector); if (write(s->peers[dest].eventfds[vector], &([[write_one]]), 8) != 8) { IVSHMEM_DPRINTF("error writing to eventfd\n"); } } break; default: IVSHMEM_DPRINTF("Invalid VM Doorbell VM %d\n", dest); } }

[[[[Adv]]]]: static void ivshmem_io_writel(void *[[dashboard]], target_phys_addr_t [[appر]], uint32_t val) { IVShmemState *s = [[dashboard]]; uint64_t [[readsryanother]] = 1; uint16_t dest = val >> 16; uint16_t vector = val & 0xff; [[appر]] &= 0xfc; IVSHMEM_DPRINTF("writing to addr " TARGET_FMT_plx "\n", [[appر]]); switch ([[appر]]) { case INTRMASK: ivshmem_IntrMask_write(s, val); break; case INTRSTATUS: ivshmem_IntrStatus_write(s, val); break; case DOORBELL: if ((dest < 0) || (dest > s->max_peer)) { IVSHMEM_DPRINTF("Invalid destination VM ID (%d)\n", dest); break; } if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) { IVSHMEM_DPRINTF("Writing %" PRId64 " to VM %d on vector %d\n", [[readsryanother]], dest, vector); if (write(s->peers[dest].eventfds[vector], &([[readsryanother]]), 8) != 8) { IVSHMEM_DPRINTF("error writing to eventfd\n"); } } break; default: IVSHMEM_DPRINTF("Invalid VM Doorbell VM %d\n", dest); } }
--------------------------------------------- Result 991 ---------------------------------------------
[[0 (73%)]] --> [[0 (32%)]] --> Socre: 0.6824133396148682

[[[[Adv]]]]: PCIBus *pci_prep_init(qemu_irq *pic) { PREPPCIState *s; PCIDevice *[[d]]; int PPC_io_memory; s = qemu_mallocz(sizeof(PREPPCIState)); s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2); register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s); register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s); register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s); register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s); register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s); register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s); register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s); register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s); PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, s); cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory); [[d]] = pci_register_device(s->bus, "PREP Host Bridge - Motorola Raven", sizeof(PCIDevice), 0, NULL, NULL); [[d]]->config[0x00] = 0x57; [[d]]->config[0x01] = 0x10; [[d]]->config[0x02] = 0x01; [[d]]->config[0x03] = 0x48; [[d]]->config[0x08] = 0x00; [[d]]->config[0x0A] = 0x00; [[d]]->config[0x0B] = 0x06; [[d]]->config[0x0C] = 0x08; [[d]]->config[0x0D] = 0x10; [[d]]->config[0x0E] = 0x00; [[d]]->config[0x34] = 0x00; return s->bus; }

[[[[Adv]]]]: PCIBus *pci_prep_init(qemu_irq *pic) { PREPPCIState *s; PCIDevice *[[motion]]; int PPC_io_memory; s = qemu_mallocz(sizeof(PREPPCIState)); s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2); register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s); register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s); register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s); register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s); register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s); register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s); register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s); register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s); PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, s); cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory); [[motion]] = pci_register_device(s->bus, "PREP Host Bridge - Motorola Raven", sizeof(PCIDevice), 0, NULL, NULL); [[motion]]->config[0x00] = 0x57; [[motion]]->config[0x01] = 0x10; [[motion]]->config[0x02] = 0x01; [[motion]]->config[0x03] = 0x48; [[motion]]->config[0x08] = 0x00; [[motion]]->config[0x0A] = 0x00; [[motion]]->config[0x0B] = 0x06; [[motion]]->config[0x0C] = 0x08; [[motion]]->config[0x0D] = 0x10; [[motion]]->config[0x0E] = 0x00; [[motion]]->config[0x34] = 0x00; return s->bus; }
--------------------------------------------- Result 992 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb) { v->res_rtm_flag = 1; v->level = get_bits(gb, 3); if(v->level >= 5) { av_log(v->s.avctx, AV_LOG_ERROR, "Reserved LEVEL %i\n",v->level); } v->chromaformat = get_bits(gb, 2); if (v->chromaformat != 1) { av_log(v->s.avctx, AV_LOG_ERROR, "Only 4:2:0 chroma format supported\n"); return -1; } v->frmrtq_postproc = get_bits(gb, 3); v->bitrtq_postproc = get_bits(gb, 5); v->postprocflag = get_bits(gb, 1); v->s.avctx->coded_width = (get_bits(gb, 12) + 1) << 1; v->s.avctx->coded_height = (get_bits(gb, 12) + 1) << 1; v->broadcast = get_bits1(gb); v->interlace = get_bits1(gb); if(v->interlace){ av_log(v->s.avctx, AV_LOG_ERROR, "Interlaced mode not supported (yet)\n"); return -1; } v->tfcntrflag = get_bits1(gb); v->finterpflag = get_bits1(gb); get_bits1(gb); v->psf = get_bits1(gb); if(v->psf) { av_log(v->s.avctx, AV_LOG_ERROR, "Progressive Segmented Frame mode: not supported (yet)\n"); return -1; } if(get_bits1(gb)) { int w, h, ar = 0; av_log(v->s.avctx, AV_LOG_INFO, "Display extended info:\n"); w = get_bits(gb, 14); h = get_bits(gb, 14); av_log(v->s.avctx, AV_LOG_INFO, "Display dimensions: %ix%i\n", w, h); if(get_bits1(gb)) ar = get_bits(gb, 4); if(ar == 15) { w = get_bits(gb, 8); h = get_bits(gb, 8); } if(get_bits1(gb)){ if(get_bits1(gb)) { get_bits(gb, 16); } else { get_bits(gb, 8); get_bits(gb, 4); } } if(get_bits1(gb)){ v->color_prim = get_bits(gb, 8); v->transfer_char = get_bits(gb, 8); v->matrix_coef = get_bits(gb, 8); } } v->hrd_param_flag = get_bits1(gb); if(v->hrd_param_flag) { int i; v->hrd_num_leaky_buckets = get_bits(gb, 5); get_bits(gb, 4); get_bits(gb, 4); for(i = 0; i < v->hrd_num_leaky_buckets; i++) { get_bits(gb, 16); get_bits(gb, 16); } } return 0; }
--------------------------------------------- Result 993 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int page_unprotect(target_ulong address, uintptr_t pc, void *puc) { unsigned int prot; PageDesc *p; target_ulong host_start, host_end, addr; mmap_lock(); p = page_find(address >> TARGET_PAGE_BITS); if (!p) { mmap_unlock(); return 0; } if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) { host_start = address & qemu_host_page_mask; host_end = host_start + qemu_host_page_size; prot = 0; for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) { p = page_find(addr >> TARGET_PAGE_BITS); p->flags |= PAGE_WRITE; prot |= p->flags; tb_invalidate_phys_page(addr, pc, puc); #ifdef DEBUG_TB_CHECK tb_invalidate_check(addr); #endif } mprotect((void *)g2h(host_start), qemu_host_page_size, prot & PAGE_BITS); mmap_unlock(); return 1; } mmap_unlock(); return 0; }
--------------------------------------------- Result 994 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 522 / 109 / 363 / 994:  37%|███▋      | 994/2690 [2:33:53<4:22:33,  9.29s/it][Succeeded / Failed / Skipped / Total] 522 / 109 / 363 / 994:  37%|███▋      | 995/2690 [2:34:08<4:22:35,  9.30s/it][Succeeded / Failed / Skipped / Total] 522 / 110 / 363 / 995:  37%|███▋      | 995/2690 [2:34:08<4:22:35,  9.30s/it][Succeeded / Failed / Skipped / Total] 522 / 110 / 363 / 995:  37%|███▋      | 996/2690 [2:34:15<4:22:21,  9.29s/it][Succeeded / Failed / Skipped / Total] 523 / 110 / 363 / 996:  37%|███▋      | 996/2690 [2:34:15<4:22:21,  9.29s/it][Succeeded / Failed / Skipped / Total] 523 / 110 / 363 / 996:  37%|███▋      | 997/2690 [2:34:35<4:22:30,  9.30s/it][Succeeded / Failed / Skipped / Total] 523 / 111 / 363 / 997:  37%|███▋      | 997/2690 [2:34:35<4:22:30,  9.30s/it][Succeeded / Failed / Skipped / Total] 523 / 111 / 363 / 997:  37%|███▋      | 998/2690 [2:34:37<4:22:09,  9.30s/it][Succeeded / Failed / Skipped / Total] 524 / 111 / 363 / 998:  37%|███▋      | 998/2690 [2:34:37<4:22:09,  9.30s/it][Succeeded / Failed / Skipped / Total] 524 / 111 / 363 / 998:  37%|███▋      | 999/2690 [2:35:00<4:22:22,  9.31s/it][Succeeded / Failed / Skipped / Total] 525 / 111 / 363 / 999:  37%|███▋      | 999/2690 [2:35:00<4:22:22,  9.31s/it][Succeeded / Failed / Skipped / Total] 525 / 111 / 363 / 999:  37%|███▋      | 1000/2690 [2:35:19<4:22:30,  9.32s/it][[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int raw_init_encoder(AVCodecContext *[[avctx]]) { [[avctx]]->coded_frame = (AVFrame *)[[avctx]]->priv_data; [[avctx]]->coded_frame->pict_type = FF_I_TYPE; [[avctx]]->coded_frame->key_frame = 1; [[avctx]]->codec_tag = findFourCC([[avctx]]->pix_fmt); return 0; }

[[[[Adv]]]]: static int raw_init_encoder(AVCodecContext *[[vanpix]]) { [[vanpix]]->coded_frame = (AVFrame *)[[vanpix]]->priv_data; [[vanpix]]->coded_frame->pict_type = FF_I_TYPE; [[vanpix]]->coded_frame->key_frame = 1; [[vanpix]]->codec_tag = findFourCC([[vanpix]]->pix_fmt); return 0; }
--------------------------------------------- Result 995 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int film_probe(AVProbeData *[[p]]) { if ([[p]]->buf_size < 4) return 0; if (AV_RB32(&[[p]]->buf[0]) != FILM_TAG) return 0; return AVPROBE_SCORE_MAX; }

[[[[Adv]]]]: static int film_probe(AVProbeData *[[ip]]) { if ([[ip]]->buf_size < 4) return 0; if (AV_RB32(&[[ip]]->buf[0]) != FILM_TAG) return 0; return AVPROBE_SCORE_MAX; }
--------------------------------------------- Result 996 ---------------------------------------------
[[0 (1%)]] --> [[0 (57%)]] --> Socre: 0.5692338347434998

[[[[Adv]]]]: void ff_put_h264_qpel8_mc23_msa(uint8_t *[[dst]], const uint8_t *src, ptrdiff_t [[stride]]) { avc_luma_midv_qrt_8w_msa(src - (2 * [[stride]]) - 2, [[stride]], [[dst]], [[stride]], 8, 1); }

[[[[Adv]]]]: void ff_put_h264_qpel8_mc23_msa(uint8_t *[[ftт]], const uint8_t *src, ptrdiff_t [[max]]) { avc_luma_midv_qrt_8w_msa(src - (2 * [[max]]) - 2, [[max]], [[ftт]], [[max]], 8, 1); }
--------------------------------------------- Result 997 ---------------------------------------------
[[0 (93%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void tlb_set_page_with_attrs(CPUState *[[cpu]], target_ulong vaddr, hwaddr paddr, MemTxAttrs attrs, int prot, int mmu_idx, target_ulong size) { CPUArchState *[[env]] = [[cpu]]->env_ptr; MemoryRegionSection *section; unsigned int index; target_ulong [[address]]; target_ulong code_address; uintptr_t [[addend]]; CPUTLBEntry *[[te]]; hwaddr iotlb, xlat, sz; unsigned vidx = [[env]]->vtlb_index++ % CPU_VTLB_SIZE; int asidx = cpu_asidx_from_attrs([[cpu]], attrs); assert_cpu_is_self([[cpu]]); assert(size >= TARGET_PAGE_SIZE); if (size != TARGET_PAGE_SIZE) { tlb_add_large_page([[env]], vaddr, size); } sz = size; section = address_space_translate_for_iotlb([[cpu]], asidx, paddr, &xlat, &sz); assert(sz >= TARGET_PAGE_SIZE); tlb_debug("vaddr=" TARGET_FMT_lx " paddr=0x" TARGET_FMT_plx " prot=%x idx=%d\n", vaddr, paddr, prot, mmu_idx); [[address]] = vaddr; if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) { [[address]] |= TLB_MMIO; [[addend]] = 0; } else { [[addend]] = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat; } code_address = [[address]]; iotlb = memory_region_section_get_iotlb([[cpu]], section, vaddr, paddr, xlat, prot, &[[address]]); index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1); [[te]] = &[[env]]->tlb_table[mmu_idx][index]; [[env]]->tlb_v_table[mmu_idx][vidx] = *[[te]]; [[env]]->iotlb_v[mmu_idx][vidx] = [[env]]->iotlb[mmu_idx][index]; [[env]]->iotlb[mmu_idx][index].addr = iotlb - vaddr; [[env]]->iotlb[mmu_idx][index].attrs = attrs; [[te]]->addend = [[addend]] - vaddr; if (prot & PAGE_READ) { [[te]]->addr_read = [[address]]; } else { [[te]]->addr_read = -1; } if (prot & PAGE_EXEC) { [[te]]->addr_code = code_address; } else { [[te]]->addr_code = -1; } if (prot & PAGE_WRITE) { if ((memory_region_is_ram(section->mr) && section->readonly) || memory_region_is_romd(section->mr)) { [[te]]->addr_write = [[address]] | TLB_MMIO; } else if (memory_region_is_ram(section->mr) && cpu_physical_memory_is_clean( memory_region_get_ram_addr(section->mr) + xlat)) { [[te]]->addr_write = [[address]] | TLB_NOTDIRTY; } else { [[te]]->addr_write = [[address]]; } } else { [[te]]->addr_write = -1; } }

[[[[Adv]]]]: void tlb_set_page_with_attrs(CPUState *[[power]], target_ulong vaddr, hwaddr paddr, MemTxAttrs attrs, int prot, int mmu_idx, target_ulong size) { CPUArchState *[[anvi]] = [[power]]->env_ptr; MemoryRegionSection *section; unsigned int index; target_ulong [[style]]; target_ulong code_address; uintptr_t [[infoear]]; CPUTLBEntry *[[design]]; hwaddr iotlb, xlat, sz; unsigned vidx = [[anvi]]->vtlb_index++ % CPU_VTLB_SIZE; int asidx = cpu_asidx_from_attrs([[power]], attrs); assert_cpu_is_self([[power]]); assert(size >= TARGET_PAGE_SIZE); if (size != TARGET_PAGE_SIZE) { tlb_add_large_page([[anvi]], vaddr, size); } sz = size; section = address_space_translate_for_iotlb([[power]], asidx, paddr, &xlat, &sz); assert(sz >= TARGET_PAGE_SIZE); tlb_debug("vaddr=" TARGET_FMT_lx " paddr=0x" TARGET_FMT_plx " prot=%x idx=%d\n", vaddr, paddr, prot, mmu_idx); [[style]] = vaddr; if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) { [[style]] |= TLB_MMIO; [[infoear]] = 0; } else { [[infoear]] = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat; } code_address = [[style]]; iotlb = memory_region_section_get_iotlb([[power]], section, vaddr, paddr, xlat, prot, &[[style]]); index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1); [[design]] = &[[anvi]]->tlb_table[mmu_idx][index]; [[anvi]]->tlb_v_table[mmu_idx][vidx] = *[[design]]; [[anvi]]->iotlb_v[mmu_idx][vidx] = [[anvi]]->iotlb[mmu_idx][index]; [[anvi]]->iotlb[mmu_idx][index].addr = iotlb - vaddr; [[anvi]]->iotlb[mmu_idx][index].attrs = attrs; [[design]]->addend = [[infoear]] - vaddr; if (prot & PAGE_READ) { [[design]]->addr_read = [[style]]; } else { [[design]]->addr_read = -1; } if (prot & PAGE_EXEC) { [[design]]->addr_code = code_address; } else { [[design]]->addr_code = -1; } if (prot & PAGE_WRITE) { if ((memory_region_is_ram(section->mr) && section->readonly) || memory_region_is_romd(section->mr)) { [[design]]->addr_write = [[style]] | TLB_MMIO; } else if (memory_region_is_ram(section->mr) && cpu_physical_memory_is_clean( memory_region_get_ram_addr(section->mr) + xlat)) { [[design]]->addr_write = [[style]] | TLB_NOTDIRTY; } else { [[design]]->addr_write = [[style]]; } } else { [[design]]->addr_write = -1; } }
--------------------------------------------- Result 998 ---------------------------------------------
[[0 (5%)]] --> [[0 (98%)]] --> Socre: 0.9845499992370605

[[[[Adv]]]]: static void ide_trim_bh_cb(void *opaque) { TrimAIOCB *[[iocb]] = opaque; [[iocb]]->common.cb([[iocb]]->common.opaque, [[iocb]]->ret); qemu_bh_delete([[iocb]]->bh); [[iocb]]->bh = NULL; qemu_aio_unref([[iocb]]); }

[[[[Adv]]]]: static void ide_trim_bh_cb(void *opaque) { TrimAIOCB *[[pugetب]] = opaque; [[pugetب]]->common.cb([[pugetب]]->common.opaque, [[pugetب]]->ret); qemu_bh_delete([[pugetب]]->bh); [[pugetب]]->bh = NULL; qemu_aio_unref([[pugetب]]); }
--------------------------------------------- Result 999 ---------------------------------------------
[[0 (19%)]] --> [[0 (51%)]] --> Socre: 0.5118420124053955

[[[[Adv]]]]: static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame) { InputStream *[[ist]] = s->opaque; DXVA2Context *ctx = [[ist]]->hwaccel_ctx; int ret; ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0); if (ret < 0) return ret; ret = av_frame_copy_props(ctx->tmp_frame, frame); if (ret < 0) { av_frame_unref(ctx->tmp_frame); return ret; } av_frame_unref(frame); av_frame_move_ref(frame, ctx->tmp_frame); return 0; }

[[[[Adv]]]]: static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame) { InputStream *[[film]] = s->opaque; DXVA2Context *ctx = [[film]]->hwaccel_ctx; int ret; ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0); if (ret < 0) return ret; ret = av_frame_copy_props(ctx->tmp_frame, frame); if (ret < 0) { av_frame_unref(ctx->tmp_frame); return ret; } av_frame_unref(frame); av_frame_move_ref(frame, ctx->tmp_frame); return 0; }
--------------------------------------------- Result 1000 ---------------------------------------------
[[0 (20%)]] --> [[0 (61%)]] --> Socre: 0.610527515411377

[[[[Adv]]]]: static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd, abi_long cmd, abi_long arg) { void *[[argptr]]; struct dm_ioctl *host_dm; abi_long guest_data; uint32_t guest_data_size; int target_size; const argtype *arg_type = ie->arg_type; abi_long ret; void *big_buf = NULL; char *host_data; arg_type++; target_size = thunk_type_size(arg_type, 0); [[argptr]] = lock_user(VERIFY_READ, arg, target_size, 1); if (![[argptr]]) { ret = -TARGET_EFAULT; goto out; } thunk_convert(buf_temp, [[argptr]], arg_type, THUNK_HOST); unlock_user([[argptr]], arg, 0); big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2); memcpy(big_buf, buf_temp, target_size); buf_temp = big_buf; host_dm = big_buf; guest_data = arg + host_dm->data_start; if ((guest_data - arg) < 0) { ret = -EINVAL; goto out; } guest_data_size = host_dm->data_size - host_dm->data_start; host_data = (char*)host_dm + host_dm->data_start; [[argptr]] = lock_user(VERIFY_READ, guest_data, guest_data_size, 1); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_LIST_DEVICES: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_DEV_WAIT: case DM_TABLE_STATUS: case DM_TABLE_CLEAR: case DM_TABLE_DEPS: case DM_LIST_VERSIONS: break; case DM_DEV_RENAME: case DM_DEV_SET_GEOMETRY: memcpy(host_data, [[argptr]], guest_data_size); break; case DM_TARGET_MSG: memcpy(host_data, [[argptr]], guest_data_size); *(uint64_t*)host_data = tswap64(*(uint64_t*)[[argptr]]); break; case DM_TABLE_LOAD: { void *gspec = [[argptr]]; void *cur_data = host_data; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { struct dm_target_spec *spec = cur_data; uint32_t next; int slen; thunk_convert(spec, gspec, arg_type, THUNK_HOST); slen = strlen((char*)gspec + spec_size) + 1; next = spec->next; spec->next = sizeof(*spec) + slen; strcpy((char*)&spec[1], gspec + spec_size); gspec += next; cur_data += spec->next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user([[argptr]], guest_data, 0); ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp)); if (!is_error(ret)) { guest_data = arg + host_dm->data_start; guest_data_size = host_dm->data_size - host_dm->data_start; [[argptr]] = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_RENAME: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_TABLE_LOAD: case DM_TABLE_CLEAR: case DM_TARGET_MSG: case DM_DEV_SET_GEOMETRY: break; case DM_LIST_DEVICES: { struct dm_name_list *nl = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = guest_data_size; void *cur_data = [[argptr]]; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) }; int nl_size = 12; while (1) { uint32_t next = nl->next; if (next) { nl->next = nl_size + (strlen(nl->name) + 1); } if (remaining_data < nl->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, nl, arg_type, THUNK_TARGET); strcpy(cur_data + nl_size, nl->name); cur_data += nl->next; remaining_data -= nl->next; if (!next) { break; } nl = (void*)nl + next; } break; } case DM_DEV_WAIT: case DM_TABLE_STATUS: { struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start; void *cur_data = [[argptr]]; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { uint32_t next = spec->next; int slen = strlen((char*)&spec[1]) + 1; spec->next = (cur_data - [[argptr]]) + spec_size + slen; if (guest_data_size < spec->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, spec, arg_type, THUNK_TARGET); strcpy(cur_data + spec_size, (char*)&spec[1]); cur_data = [[argptr]] + spec->next; spec = (void*)host_dm + host_dm->data_start + next; } break; } case DM_TABLE_DEPS: { void *hdata = (void*)host_dm + host_dm->data_start; int count = *(uint32_t*)hdata; uint64_t *hdev = hdata + 8; uint64_t *gdev = [[argptr]] + 8; int i; *(uint32_t*)[[argptr]] = tswap32(count); for (i = 0; i < count; i++) { *gdev = tswap64(*hdev); gdev++; hdev++; } break; } case DM_LIST_VERSIONS: { struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = guest_data_size; void *cur_data = [[argptr]]; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) }; int vers_size = thunk_type_size(arg_type, 0); while (1) { uint32_t next = vers->next; if (next) { vers->next = vers_size + (strlen(vers->name) + 1); } if (remaining_data < vers->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, vers, arg_type, THUNK_TARGET); strcpy(cur_data + vers_size, vers->name); cur_data += vers->next; remaining_data -= vers->next; if (!next) { break; } vers = (void*)vers + next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user([[argptr]], guest_data, guest_data_size); [[argptr]] = lock_user(VERIFY_WRITE, arg, target_size, 0); if (![[argptr]]) { ret = -TARGET_EFAULT; goto out; } thunk_convert([[argptr]], buf_temp, arg_type, THUNK_TARGET); unlock_user([[argptr]], arg, target_size); } out: if (big_buf) { free(big_buf); } return ret; }

[[[[Adv]]]]: static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd, abi_long cmd, abi_long arg) { void *[[vigratry]]; struct dm_ioctl *host_dm; abi_long guest_data; uint32_t guest_data_size; int target_size; const argtype *arg_type = ie->arg_type; abi_long ret; void *big_buf = NULL; char *host_data; arg_type++; target_size = thunk_type_size(arg_type, 0); [[vigratry]] = lock_user(VERIFY_READ, arg, target_size, 1); if (![[vigratry]]) { ret = -TARGET_EFAULT; goto out; } thunk_convert(buf_temp, [[vigratry]], arg_type, THUNK_HOST); unlock_user([[vigratry]], arg, 0); big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2); memcpy(big_buf, buf_temp, target_size); buf_temp = big_buf; host_dm = big_buf; guest_data = arg + host_dm->data_start; if ((guest_data - arg) < 0) { ret = -EINVAL; goto out; } guest_data_size = host_dm->data_size - host_dm->data_start; host_data = (char*)host_dm + host_dm->data_start; [[vigratry]] = lock_user(VERIFY_READ, guest_data, guest_data_size, 1); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_LIST_DEVICES: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_DEV_WAIT: case DM_TABLE_STATUS: case DM_TABLE_CLEAR: case DM_TABLE_DEPS: case DM_LIST_VERSIONS: break; case DM_DEV_RENAME: case DM_DEV_SET_GEOMETRY: memcpy(host_data, [[vigratry]], guest_data_size); break; case DM_TARGET_MSG: memcpy(host_data, [[vigratry]], guest_data_size); *(uint64_t*)host_data = tswap64(*(uint64_t*)[[vigratry]]); break; case DM_TABLE_LOAD: { void *gspec = [[vigratry]]; void *cur_data = host_data; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { struct dm_target_spec *spec = cur_data; uint32_t next; int slen; thunk_convert(spec, gspec, arg_type, THUNK_HOST); slen = strlen((char*)gspec + spec_size) + 1; next = spec->next; spec->next = sizeof(*spec) + slen; strcpy((char*)&spec[1], gspec + spec_size); gspec += next; cur_data += spec->next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user([[vigratry]], guest_data, 0); ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp)); if (!is_error(ret)) { guest_data = arg + host_dm->data_start; guest_data_size = host_dm->data_size - host_dm->data_start; [[vigratry]] = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_RENAME: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_TABLE_LOAD: case DM_TABLE_CLEAR: case DM_TARGET_MSG: case DM_DEV_SET_GEOMETRY: break; case DM_LIST_DEVICES: { struct dm_name_list *nl = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = guest_data_size; void *cur_data = [[vigratry]]; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) }; int nl_size = 12; while (1) { uint32_t next = nl->next; if (next) { nl->next = nl_size + (strlen(nl->name) + 1); } if (remaining_data < nl->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, nl, arg_type, THUNK_TARGET); strcpy(cur_data + nl_size, nl->name); cur_data += nl->next; remaining_data -= nl->next; if (!next) { break; } nl = (void*)nl + next; } break; } case DM_DEV_WAIT: case DM_TABLE_STATUS: { struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start; void *cur_data = [[vigratry]]; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { uint32_t next = spec->next; int slen = strlen((char*)&spec[1]) + 1; spec->next = (cur_data - [[vigratry]]) + spec_size + slen; if (guest_data_size < spec->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, spec, arg_type, THUNK_TARGET); strcpy(cur_data + spec_size, (char*)&spec[1]); cur_data = [[vigratry]] + spec->next; spec = (void*)host_dm + host_dm->data_start + next; } break; } case DM_TABLE_DEPS: { void *hdata = (void*)host_dm + host_dm->data_start; int count = *(uint32_t*)hdata; uint64_t *hdev = hdata + 8; uint64_t *gdev = [[vigratry]] + 8; int i; *(uint32_t*)[[vigratry]] = tswap32(count); for (i = 0; i < count; i++) { *gdev = tswap64(*hdev); gdev++; hdev++; } break; } case DM_LIST_VERSIONS: { struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = guest_data_size; void *cur_data = [[vigratry]]; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) }; int vers_size = thunk_type_size(arg_type, 0); while (1) { uint32_t next = vers->next; if (next) { vers->next = vers_size + (strlen(vers->name) + 1); } if (remaining_data < vers->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, vers, arg_type, THUNK_TARGET); strcpy(cur_data + vers_size, vers->name); cur_data += vers->next; remaining_data -= vers->next; if (!next) { break; } vers = (void*)vers + next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user([[vigratry]], guest_data, guest_data_size); [[vigratry]] = lock_user(VERIFY_WRITE, arg, target_size, 0); if (![[vigratry]]) { ret = -TARGET_EFAULT; goto out; } thunk_convert([[vigratry]], buf_temp, arg_type, THUNK_TARGET); unlock_user([[vigratry]], arg, target_size); } out: if (big_buf) { free(big_buf); } return ret; }[Succeeded / Failed / Skipped / Total] 526 / 111 / 363 / 1000:  37%|███▋      | 1000/2690 [2:35:19<4:22:30,  9.32s/it][Succeeded / Failed / Skipped / Total] 526 / 111 / 363 / 1000:  37%|███▋      | 1001/2690 [2:35:34<4:22:30,  9.33s/it][Succeeded / Failed / Skipped / Total] 527 / 111 / 363 / 1001:  37%|███▋      | 1001/2690 [2:35:34<4:22:30,  9.33s/it][Succeeded / Failed / Skipped / Total] 527 / 111 / 363 / 1001:  37%|███▋      | 1002/2690 [2:35:34<4:22:05,  9.32s/it][Succeeded / Failed / Skipped / Total] 528 / 111 / 363 / 1002:  37%|███▋      | 1002/2690 [2:35:34<4:22:05,  9.32s/it][Succeeded / Failed / Skipped / Total] 528 / 111 / 363 / 1002:  37%|███▋      | 1003/2690 [2:35:57<4:22:19,  9.33s/it]
--------------------------------------------- Result 1001 ---------------------------------------------
[[0 (2%)]] --> [[0 (63%)]] --> Socre: 0.6261849403381348

[[[[Adv]]]]: static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val, unsigned int size, int [[mem_index]]) { int [[l1]] = gen_new_label(); TCGv [[taddr]] = tcg_temp_local_new(); TCGv [[tval]] = tcg_temp_local_new(); TCGv t1 = tcg_temp_local_new(); dc->postinc = 0; cris_evaluate_flags(dc); tcg_gen_mov_tl([[taddr]], addr); tcg_gen_mov_tl([[tval]], val); tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, [[l1]]); if (size == 1) { tcg_gen_qemu_st8([[tval]], [[taddr]], [[mem_index]]); } else if (size == 2) { tcg_gen_qemu_st16([[tval]], [[taddr]], [[mem_index]]); } else { tcg_gen_qemu_st32([[tval]], [[taddr]], [[mem_index]]); } gen_set_label([[l1]]); tcg_gen_shri_tl(t1, t1, 1); tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); tcg_temp_free(t1); tcg_temp_free([[tval]]); tcg_temp_free([[taddr]]); }

[[[[Adv]]]]: static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val, unsigned int size, int [[misminousalias]]) { int [[ɫs]] = gen_new_label(); TCGv [[yadra]] = tcg_temp_local_new(); TCGv [[vsally]] = tcg_temp_local_new(); TCGv t1 = tcg_temp_local_new(); dc->postinc = 0; cris_evaluate_flags(dc); tcg_gen_mov_tl([[yadra]], addr); tcg_gen_mov_tl([[vsally]], val); tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, [[ɫs]]); if (size == 1) { tcg_gen_qemu_st8([[vsally]], [[yadra]], [[misminousalias]]); } else if (size == 2) { tcg_gen_qemu_st16([[vsally]], [[yadra]], [[misminousalias]]); } else { tcg_gen_qemu_st32([[vsally]], [[yadra]], [[misminousalias]]); } gen_set_label([[ɫs]]); tcg_gen_shri_tl(t1, t1, 1); tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); tcg_temp_free(t1); tcg_temp_free([[vsally]]); tcg_temp_free([[yadra]]); }
--------------------------------------------- Result 1002 ---------------------------------------------
[[0 (99%)]] --> [[0 (47%)]] --> Socre: 0.533962070941925

[[[[Adv]]]]: void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int [[mb_y]], uint8_t *segment, uint8_t *ref, int [[layout]]) { VP56RangeCoder *c = &s->c; if (s->segmentation.update_map) *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid); else if (s->segmentation.enabled) *segment = ref ? *ref : *segment; mb->segment = *segment; mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0; if (s->keyframe) { mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra, vp8_pred16x16_prob_intra); if (mb->mode == MODE_I4x4) { decode_intra4x4_modes(s, c, mb, mb_x, 1, [[layout]]); } else { const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u; if (s->mb_layout == 1) AV_WN32A(mb->intra4x4_pred_mode_top, modes); else AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes); AV_WN32A(s->intra4x4_pred_mode_left, modes); } mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, vp8_pred8x8c_prob_intra); mb->ref_frame = VP56_FRAME_CURRENT; } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) { if (vp56_rac_get_prob_branchy(c, s->prob->last)) mb->ref_frame = vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 : VP56_FRAME_GOLDEN; else mb->ref_frame = VP56_FRAME_PREVIOUS; s->ref_count[mb->ref_frame - 1]++; decode_mvs(s, mb, mb_x, [[mb_y]], [[layout]]); } else { mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16); if (mb->mode == MODE_I4x4) decode_intra4x4_modes(s, c, mb, mb_x, 0, [[layout]]); mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, s->prob->pred8x8c); mb->ref_frame = VP56_FRAME_CURRENT; mb->partitioning = VP8_SPLITMVMODE_NONE; AV_ZERO32(&mb->bmv[0]); } }

[[[[Adv]]]]: void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int [[bi160]], uint8_t *segment, uint8_t *ref, int [[park]]) { VP56RangeCoder *c = &s->c; if (s->segmentation.update_map) *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid); else if (s->segmentation.enabled) *segment = ref ? *ref : *segment; mb->segment = *segment; mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0; if (s->keyframe) { mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra, vp8_pred16x16_prob_intra); if (mb->mode == MODE_I4x4) { decode_intra4x4_modes(s, c, mb, mb_x, 1, [[park]]); } else { const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u; if (s->mb_layout == 1) AV_WN32A(mb->intra4x4_pred_mode_top, modes); else AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes); AV_WN32A(s->intra4x4_pred_mode_left, modes); } mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, vp8_pred8x8c_prob_intra); mb->ref_frame = VP56_FRAME_CURRENT; } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) { if (vp56_rac_get_prob_branchy(c, s->prob->last)) mb->ref_frame = vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 : VP56_FRAME_GOLDEN; else mb->ref_frame = VP56_FRAME_PREVIOUS; s->ref_count[mb->ref_frame - 1]++; decode_mvs(s, mb, mb_x, [[bi160]], [[park]]); } else { mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16); if (mb->mode == MODE_I4x4) decode_intra4x4_modes(s, c, mb, mb_x, 0, [[park]]); mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, s->prob->pred8x8c); mb->ref_frame = VP56_FRAME_CURRENT; mb->partitioning = VP8_SPLITMVMODE_NONE; AV_ZERO32(&mb->bmv[0]); } }
--------------------------------------------- Result 1003 ---------------------------------------------
[[0 (72%)]] --> [[0 (30%)]] --> Socre: 0.696953535079956

[[[[Adv]]]]: static int decode_micromips_opc (CPUMIPSState *[[env]], DisasContext *ctx, int *is_branch) { uint32_t op; if (ctx->pc & 0x1) { [[env]]->CP0_BadVAddr = ctx->pc; generate_exception(ctx, EXCP_AdEL); ctx->bstate = BS_STOP; return 2; } op = (ctx->opcode >> 10) & 0x3f; if (ctx->hflags & MIPS_HFLAG_BMASK) { int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT; switch (op) { case POOL32A: case POOL32B: case POOL32I: case POOL32C: case ADDI32: case ADDIU32: case ORI32: case XORI32: case SLTI32: case SLTIU32: case ANDI32: case JALX32: case LBU32: case LHU32: case POOL32F: case JALS32: case BEQ32: case BNE32: case J32: case JAL32: case SB32: case SH32: case POOL32S: case ADDIUPC: case SWC132: case SDC132: case SD32: case SW32: case LB32: case LH32: case DADDIU32: case LWC132: case LDC132: case LD32: case LW32: if (bits & MIPS_HFLAG_BDS16) { generate_exception(ctx, EXCP_RI); ctx->bstate = BS_STOP; return 2; } break; case POOL16A: case POOL16B: case POOL16C: case LWGP16: case POOL16F: case LBU16: case LHU16: case LWSP16: case LW16: case SB16: case SH16: case SWSP16: case SW16: case MOVE16: case ANDI16: case POOL16D: case POOL16E: case BEQZ16: case BNEZ16: case B16: case LI16: if (bits & MIPS_HFLAG_BDS32) { generate_exception(ctx, EXCP_RI); ctx->bstate = BS_STOP; return 2; } break; default: break; } } switch (op) { case POOL16A: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rs1 = mmreg(uMIPS_RS1(ctx->opcode)); int rs2 = mmreg(uMIPS_RS2(ctx->opcode)); uint32_t opc = 0; switch (ctx->opcode & 0x1) { case ADDU16: opc = OPC_ADDU; break; case SUBU16: opc = OPC_SUBU; break; } gen_arith(ctx, opc, rd, rs1, rs2); } break; case POOL16B: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rs = mmreg(uMIPS_RS(ctx->opcode)); int amount = (ctx->opcode >> 1) & 0x7; uint32_t opc = 0; amount = amount == 0 ? 8 : amount; switch (ctx->opcode & 0x1) { case SLL16: opc = OPC_SLL; break; case SRL16: opc = OPC_SRL; break; } gen_shift_imm(ctx, opc, rd, rs, amount); } break; case POOL16C: gen_pool16c_insn(ctx, is_branch); break; case LWGP16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = 28; int16_t offset = SIMM(ctx->opcode, 0, 7) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case POOL16F: if (ctx->opcode & 1) { generate_exception(ctx, EXCP_RI); } else { int enc_dest = uMIPS_RD(ctx->opcode); int enc_rt = uMIPS_RS2(ctx->opcode); int enc_rs = uMIPS_RS1(ctx->opcode); int rd, rs, re, rt; static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 }; static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 }; static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 }; rd = rd_enc[enc_dest]; re = re_enc[enc_dest]; rs = rs_rt_enc[enc_rs]; rt = rs_rt_enc[enc_rt]; gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0); gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0); } break; case LBU16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4); offset = (offset == 0xf ? -1 : offset); gen_ld(ctx, OPC_LBU, rd, rb, offset); } break; case LHU16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1; gen_ld(ctx, OPC_LHU, rd, rb, offset); } break; case LWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case LW16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case SB16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4); gen_st(ctx, OPC_SB, rd, rb, offset); } break; case SH16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1; gen_st(ctx, OPC_SH, rd, rb, offset); } break; case SWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2; gen_st(ctx, OPC_SW, rd, rb, offset); } break; case SW16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2; gen_st(ctx, OPC_SW, rd, rb, offset); } break; case MOVE16: { int rd = uMIPS_RD5(ctx->opcode); int rs = uMIPS_RS5(ctx->opcode); gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0); } break; case ANDI16: gen_andi16(ctx); break; case POOL16D: switch (ctx->opcode & 0x1) { case ADDIUS5: gen_addius5(ctx); break; case ADDIUSP: gen_addiusp(ctx); break; } break; case POOL16E: switch (ctx->opcode & 0x1) { case ADDIUR2: gen_addiur2(ctx); break; case ADDIUR1SP: gen_addiur1sp(ctx); break; } break; case B16: gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0, SIMM(ctx->opcode, 0, 10) << 1); *is_branch = 1; break; case BNEZ16: case BEQZ16: gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2, mmreg(uMIPS_RD(ctx->opcode)), 0, SIMM(ctx->opcode, 0, 7) << 1); *is_branch = 1; break; case LI16: { int reg = mmreg(uMIPS_RD(ctx->opcode)); int imm = ZIMM(ctx->opcode, 0, 7); imm = (imm == 0x7f ? -1 : imm); tcg_gen_movi_tl(cpu_gpr[reg], imm); } break; case RES_20: case RES_28: case RES_29: case RES_30: case RES_31: case RES_38: case RES_39: generate_exception(ctx, EXCP_RI); break; default: decode_micromips32_opc ([[env]], ctx, op, is_branch); return 4; } return 2; }

[[[[Adv]]]]: static int decode_micromips_opc (CPUMIPSState *[[kinz]], DisasContext *ctx, int *is_branch) { uint32_t op; if (ctx->pc & 0x1) { [[kinz]]->CP0_BadVAddr = ctx->pc; generate_exception(ctx, EXCP_AdEL); ctx->bstate = BS_STOP; return 2; } op = (ctx->opcode >> 10) & 0x3f; if (ctx->hflags & MIPS_HFLAG_BMASK) { int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT; switch (op) { case POOL32A: case POOL32B: case POOL32I: case POOL32C: case ADDI32: case ADDIU32: case ORI32: case XORI32: case SLTI32: case SLTIU32: case ANDI32: case JALX32: case LBU32: case LHU32: case POOL32F: case JALS32: case BEQ32: case BNE32: case J32: case JAL32: case SB32: case SH32: case POOL32S: case ADDIUPC: case SWC132: case SDC132: case SD32: case SW32: case LB32: case LH32: case DADDIU32: case LWC132: case LDC132: case LD32: case LW32: if (bits & MIPS_HFLAG_BDS16) { generate_exception(ctx, EXCP_RI); ctx->bstate = BS_STOP; return 2; } break; case POOL16A: case POOL16B: case POOL16C: case LWGP16: case POOL16F: case LBU16: case LHU16: case LWSP16: case LW16: case SB16: case SH16: case SWSP16: case SW16: case MOVE16: case ANDI16: case POOL16D: case POOL16E: case BEQZ16: case BNEZ16: case B16: case LI16: if (bits & MIPS_HFLAG_BDS32) { generate_exception(ctx, EXCP_RI); ctx->bstate = BS_STOP; return 2; } break; default: break; } } switch (op) { case POOL16A: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rs1 = mmreg(uMIPS_RS1(ctx->opcode)); int rs2 = mmreg(uMIPS_RS2(ctx->opcode)); uint32_t opc = 0; switch (ctx->opcode & 0x1) { case ADDU16: opc = OPC_ADDU; break; case SUBU16: opc = OPC_SUBU; break; } gen_arith(ctx, opc, rd, rs1, rs2); } break; case POOL16B: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rs = mmreg(uMIPS_RS(ctx->opcode)); int amount = (ctx->opcode >> 1) & 0x7; uint32_t opc = 0; amount = amount == 0 ? 8 : amount; switch (ctx->opcode & 0x1) { case SLL16: opc = OPC_SLL; break; case SRL16: opc = OPC_SRL; break; } gen_shift_imm(ctx, opc, rd, rs, amount); } break; case POOL16C: gen_pool16c_insn(ctx, is_branch); break; case LWGP16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = 28; int16_t offset = SIMM(ctx->opcode, 0, 7) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case POOL16F: if (ctx->opcode & 1) { generate_exception(ctx, EXCP_RI); } else { int enc_dest = uMIPS_RD(ctx->opcode); int enc_rt = uMIPS_RS2(ctx->opcode); int enc_rs = uMIPS_RS1(ctx->opcode); int rd, rs, re, rt; static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 }; static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 }; static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 }; rd = rd_enc[enc_dest]; re = re_enc[enc_dest]; rs = rs_rt_enc[enc_rs]; rt = rs_rt_enc[enc_rt]; gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0); gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0); } break; case LBU16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4); offset = (offset == 0xf ? -1 : offset); gen_ld(ctx, OPC_LBU, rd, rb, offset); } break; case LHU16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1; gen_ld(ctx, OPC_LHU, rd, rb, offset); } break; case LWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case LW16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case SB16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4); gen_st(ctx, OPC_SB, rd, rb, offset); } break; case SH16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1; gen_st(ctx, OPC_SH, rd, rb, offset); } break; case SWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2; gen_st(ctx, OPC_SW, rd, rb, offset); } break; case SW16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2; gen_st(ctx, OPC_SW, rd, rb, offset); } break; case MOVE16: { int rd = uMIPS_RD5(ctx->opcode); int rs = uMIPS_RS5(ctx->opcode); gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0); } break; case ANDI16: gen_andi16(ctx); break; case POOL16D: switch (ctx->opcode & 0x1) { case ADDIUS5: gen_addius5(ctx); break; case ADDIUSP: gen_addiusp(ctx); break; } break; case POOL16E: switch (ctx->opcode & 0x1) { case ADDIUR2: gen_addiur2(ctx); break; case ADDIUR1SP: gen_addiur1sp(ctx); break; } break; case B16: gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0, SIMM(ctx->opcode, 0, 10) << 1); *is_branch = 1; break; case BNEZ16: case BEQZ16: gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2, mmreg(uMIPS_RD(ctx->opcode)), 0, SIMM(ctx->opcode, 0, 7) << 1); *is_branch = 1; break; case LI16: { int reg = mmreg(uMIPS_RD(ctx->opcode)); int imm = ZIMM(ctx->opcode, 0, 7); imm = (imm == 0x7f ? -1 : imm); tcg_gen_movi_tl(cpu_gpr[reg], imm); } break; case RES_20: case RES_28: case RES_29: case RES_30: case RES_31: case RES_38: case RES_39: generate_exception(ctx, EXCP_RI); break; default: decode_micromips32_opc ([[kinz]], ctx, op, is_branch); return 4; } return 2; }[Succeeded / Failed / Skipped / Total] 529 / 111 / 363 / 1003:  37%|███▋      | 1003/2690 [2:35:57<4:22:19,  9.33s/it][Succeeded / Failed / Skipped / Total] 529 / 111 / 363 / 1003:  37%|███▋      | 1004/2690 [2:36:18<4:22:29,  9.34s/it][Succeeded / Failed / Skipped / Total] 530 / 111 / 363 / 1004:  37%|███▋      | 1004/2690 [2:36:18<4:22:29,  9.34s/it][Succeeded / Failed / Skipped / Total] 530 / 111 / 363 / 1004:  37%|███▋      | 1005/2690 [2:36:24<4:22:14,  9.34s/it][Succeeded / Failed / Skipped / Total] 531 / 111 / 363 / 1005:  37%|███▋      | 1005/2690 [2:36:24<4:22:14,  9.34s/it][Succeeded / Failed / Skipped / Total] 531 / 111 / 363 / 1005:  37%|███▋      | 1006/2690 [2:36:34<4:22:05,  9.34s/it][Succeeded / Failed / Skipped / Total] 532 / 111 / 363 / 1006:  37%|███▋      | 1006/2690 [2:36:34<4:22:05,  9.34s/it][Succeeded / Failed / Skipped / Total] 532 / 111 / 363 / 1006:  37%|███▋      | 1007/2690 [2:36:47<4:22:02,  9.34s/it][Succeeded / Failed / Skipped / Total] 533 / 111 / 363 / 1007:  37%|███▋      | 1007/2690 [2:36:47<4:22:02,  9.34s/it][Succeeded / Failed / Skipped / Total] 533 / 111 / 363 / 1007:  37%|███▋      | 1008/2690 [2:36:57<4:21:53,  9.34s/it][Succeeded / Failed / Skipped / Total] 533 / 112 / 363 / 1008:  37%|███▋      | 1008/2690 [2:36:57<4:21:53,  9.34s/it][Succeeded / Failed / Skipped / Total] 533 / 112 / 363 / 1008:  38%|███▊      | 1009/2690 [2:37:12<4:21:54,  9.35s/it]
--------------------------------------------- Result 1004 ---------------------------------------------
[[0 (31%)]] --> [[0 (98%)]] --> Socre: 0.9818738698959351

[[[[Adv]]]]: static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab) { int i; int [[vlc]] = get_bits1(&q->gb); int start = cplband[p->js_subband_start]; int end = cplband[p->subbands - 1]; int [[length]] = end - start + 1; if (start > end) return; if ([[vlc]]) for (i = 0; i < [[length]]; i++) decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2); else for (i = 0; i < [[length]]; i++) decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits); }

[[[[Adv]]]]: static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab) { int i; int [[вlver]] = get_bits1(&q->gb); int start = cplband[p->js_subband_start]; int end = cplband[p->subbands - 1]; int [[writer]] = end - start + 1; if (start > end) return; if ([[вlver]]) for (i = 0; i < [[writer]]; i++) decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2); else for (i = 0; i < [[writer]]; i++) decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits); }
--------------------------------------------- Result 1005 ---------------------------------------------
[[0 (47%)]] --> [[0 (94%)]] --> Socre: 0.9382821321487427

[[[[Adv]]]]: static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){ int i,j,k,m; double l2tab[256]; for(i=1; i<256; i++) l2tab[i]= log2(i/256.0); for(i=0; i<256; i++){ double best_len[256]; double p= i/256.0; for(j=0; j<256; j++) best_len[j]= 1<<30; for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){ double [[occ]][256]={0}; double len=0; [[occ]][j]=1.0; for(k=0; k<256; k++){ double newocc[256]={0}; for(m=0; m<256; m++){ if([[occ]][m]){ len -=[[occ]][m]*( p *l2tab[ m] + (1-p)*l2tab[256-m]); } } if(len < best_len[k]){ best_len[k]= len; best_state[i][k]= j; } for(m=0; m<256; m++){ if([[occ]][m]){ newocc[ one_state[ m]] += [[occ]][m]* p ; newocc[256-one_state[256-m]] += [[occ]][m]*(1-p); } } memcpy([[occ]], newocc, sizeof([[occ]])); } } } }

[[[[Adv]]]]: static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){ int i,j,k,m; double l2tab[256]; for(i=1; i<256; i++) l2tab[i]= log2(i/256.0); for(i=0; i<256; i++){ double best_len[256]; double p= i/256.0; for(j=0; j<256; j++) best_len[j]= 1<<30; for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){ double [[оrc]][256]={0}; double len=0; [[оrc]][j]=1.0; for(k=0; k<256; k++){ double newocc[256]={0}; for(m=0; m<256; m++){ if([[оrc]][m]){ len -=[[оrc]][m]*( p *l2tab[ m] + (1-p)*l2tab[256-m]); } } if(len < best_len[k]){ best_len[k]= len; best_state[i][k]= j; } for(m=0; m<256; m++){ if([[оrc]][m]){ newocc[ one_state[ m]] += [[оrc]][m]* p ; newocc[256-one_state[256-m]] += [[оrc]][m]*(1-p); } } memcpy([[оrc]], newocc, sizeof([[оrc]])); } } } }
--------------------------------------------- Result 1006 ---------------------------------------------
[[0 (37%)]] --> [[0 (81%)]] --> Socre: 0.8107064962387085

[[[[Adv]]]]: static int get_pcm(HEVCContext *s, int x, int y) { int log2_min_pu_size = s->sps->log2_min_pu_size; int x_pu = x >> log2_min_pu_size; int [[y_pu]] = y >> log2_min_pu_size; if (x < 0 || x_pu >= s->sps->min_pu_width || y < 0 || [[y_pu]] >= s->sps->min_pu_height) return 2; return s->is_pcm[[[y_pu]] * s->sps->min_pu_width + x_pu]; }

[[[[Adv]]]]: static int get_pcm(HEVCContext *s, int x, int y) { int log2_min_pu_size = s->sps->log2_min_pu_size; int x_pu = x >> log2_min_pu_size; int [[cycapitalso]] = y >> log2_min_pu_size; if (x < 0 || x_pu >= s->sps->min_pu_width || y < 0 || [[cycapitalso]] >= s->sps->min_pu_height) return 2; return s->is_pcm[[[cycapitalso]] * s->sps->min_pu_width + x_pu]; }
--------------------------------------------- Result 1007 ---------------------------------------------
[[0 (34%)]] --> [[0 (51%)]] --> Socre: 0.505550742149353

[[[[Adv]]]]: static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t [[b1]], uint8_t bin) { if (bin < 7) { if ((b0 + 256) == [[b1]]) a = 384; else if (b0 > [[b1]]) a = FFMAX(0, a - 64); } else if (bin < 20) { if ((b0 + 256) == [[b1]]) a = 320; else if (b0 > [[b1]]) a = FFMAX(0, a - 64); } else { a = FFMAX(0, a - 128); } return a; }

[[[[Adv]]]]: static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t [[ab]], uint8_t bin) { if (bin < 7) { if ((b0 + 256) == [[ab]]) a = 384; else if (b0 > [[ab]]) a = FFMAX(0, a - 64); } else if (bin < 20) { if ((b0 + 256) == [[ab]]) a = 320; else if (b0 > [[ab]]) a = FFMAX(0, a - 64); } else { a = FFMAX(0, a - 128); } return a; }
--------------------------------------------- Result 1008 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int prepare_packet(AVPacket *[[pkt]],const FailingMuxerPacketData *pkt_data, int64_t pts) { int [[ret]]; FailingMuxerPacketData *[[data]] = av_malloc(sizeof(*[[data]])); memcpy([[data]], pkt_data, sizeof(FailingMuxerPacketData)); [[ret]] = av_packet_from_data([[pkt]], (uint8_t*) [[data]], sizeof(*[[data]])); [[pkt]]->pts = [[pkt]]->dts = pts; [[pkt]]->duration = 1; return [[ret]];

[[[[Adv]]]]: static int prepare_packet(AVPacket *[[jmp]],const FailingMuxerPacketData *pkt_data, int64_t pts) { int [[varт]]; FailingMuxerPacketData *[[figure]] = av_malloc(sizeof(*[[figure]])); memcpy([[figure]], pkt_data, sizeof(FailingMuxerPacketData)); [[varт]] = av_packet_from_data([[jmp]], (uint8_t*) [[figure]], sizeof(*[[figure]])); [[jmp]]->pts = [[jmp]]->dts = pts; [[jmp]]->duration = 1; return [[varт]];
--------------------------------------------- Result 1009 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 534 / 112 / 363 / 1009:  38%|███▊      | 1009/2690 [2:37:12<4:21:54,  9.35s/it][Succeeded / Failed / Skipped / Total] 534 / 112 / 363 / 1009:  38%|███▊      | 1010/2690 [2:37:13<4:21:30,  9.34s/it][[0 (15%)]] --> [[0 (93%)]] --> Socre: 0.9254457950592041

[[[[Adv]]]]: static int h264_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = data; int buf_index = 0; int ret; const uint8_t *new_extradata; int [[new_extradata_size]]; h->flags = avctx->flags; h->setup_finished = 0; out: if (buf_size == 0) { H264Picture *[[out]]; int [[i]], out_idx; h->cur_pic_ptr = NULL; [[out]] = h->delayed_pic[0]; out_idx = 0; for ([[i]] = 1; h->delayed_pic[[[i]]] && !h->delayed_pic[[[i]]]->f->key_frame && !h->delayed_pic[[[i]]]->mmco_reset; [[i]]++) if (h->delayed_pic[[[i]]]->poc < [[out]]->poc) { [[out]] = h->delayed_pic[[[i]]]; out_idx = [[i]]; } for ([[i]] = out_idx; h->delayed_pic[[[i]]]; [[i]]++) h->delayed_pic[[[i]]] = h->delayed_pic[[[i]] + 1]; if ([[out]]) { ret = output_frame(h, pict, [[out]]->f); if (ret < 0) return ret; *got_frame = 1; } return buf_index; } [[new_extradata_size]] = 0; new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &[[new_extradata_size]]); if ([[new_extradata_size]] > 0 && new_extradata) { ret = ff_h264_decode_extradata(new_extradata, [[new_extradata_size]], &h->ps, &h->is_avc, &h->nal_length_size, avctx->err_recognition, avctx); if (ret < 0) return ret; } buf_index = decode_nal_units(h, buf, buf_size); if (buf_index < 0) return AVERROR_INVALIDDATA; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { buf_size = 0; goto out; } if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF) return 0; av_log(avctx, AV_LOG_ERROR, "no frame!\n"); return AVERROR_INVALIDDATA; } if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); ff_h264_field_end(h, &h->slice_ctx[0], 0); *got_frame = 0; if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) || h->next_output_pic->recovered)) { if (!h->next_output_pic->recovered) h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT; ret = output_frame(h, pict, h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; } } assert(pict->buf[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }

[[[[Adv]]]]: static int h264_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = data; int buf_index = 0; int ret; const uint8_t *new_extradata; int [[freshandorndatad²area]]; h->flags = avctx->flags; h->setup_finished = 0; out: if (buf_size == 0) { H264Picture *[[it]]; int [[1st]], out_idx; h->cur_pic_ptr = NULL; [[it]] = h->delayed_pic[0]; out_idx = 0; for ([[1st]] = 1; h->delayed_pic[[[1st]]] && !h->delayed_pic[[[1st]]]->f->key_frame && !h->delayed_pic[[[1st]]]->mmco_reset; [[1st]]++) if (h->delayed_pic[[[1st]]]->poc < [[it]]->poc) { [[it]] = h->delayed_pic[[[1st]]]; out_idx = [[1st]]; } for ([[1st]] = out_idx; h->delayed_pic[[[1st]]]; [[1st]]++) h->delayed_pic[[[1st]]] = h->delayed_pic[[[1st]] + 1]; if ([[it]]) { ret = output_frame(h, pict, [[it]]->f); if (ret < 0) return ret; *got_frame = 1; } return buf_index; } [[freshandorndatad²area]] = 0; new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &[[freshandorndatad²area]]); if ([[freshandorndatad²area]] > 0 && new_extradata) { ret = ff_h264_decode_extradata(new_extradata, [[freshandorndatad²area]], &h->ps, &h->is_avc, &h->nal_length_size, avctx->err_recognition, avctx); if (ret < 0) return ret; } buf_index = decode_nal_units(h, buf, buf_size); if (buf_index < 0) return AVERROR_INVALIDDATA; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { buf_size = 0; goto out; } if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF) return 0; av_log(avctx, AV_LOG_ERROR, "no frame!\n"); return AVERROR_INVALIDDATA; } if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); ff_h264_field_end(h, &h->slice_ctx[0], 0); *got_frame = 0; if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) || h->next_output_pic->recovered)) { if (!h->next_output_pic->recovered) h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT; ret = output_frame(h, pict, h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; } } assert(pict->buf[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }
--------------------------------------------- Result 1010 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 534 / 112 / 364 / 1010:  38%|███▊      | 1010/2690 [2:37:13<4:21:30,  9.34s/it][Succeeded / Failed / Skipped / Total] 534 / 112 / 364 / 1010:  38%|███▊      | 1011/2690 [2:37:26<4:21:28,  9.34s/it][Succeeded / Failed / Skipped / Total] 535 / 112 / 364 / 1011:  38%|███▊      | 1011/2690 [2:37:26<4:21:28,  9.34s/it][Succeeded / Failed / Skipped / Total] 535 / 112 / 364 / 1011:  38%|███▊      | 1012/2690 [2:37:26<4:21:04,  9.33s/it][[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ppce500_init(MachineState *machine, PPCE500Params *params) { MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); PCIBus *pci_bus; CPUPPCState *env = NULL; uint64_t loadaddr; hwaddr kernel_base = -1LL; int kernel_size = 0; hwaddr dt_base = 0; hwaddr initrd_base = 0; int initrd_size = 0; hwaddr cur_base = 0; char *filename; hwaddr bios_entry = 0; target_long bios_size; struct boot_info *boot_info; int dt_size; int i; unsigned int pci_irq_nrs[PCI_NUM_PINS] = {1, 2, 3, 4}; qemu_irq **irqs, *mpic; DeviceState *dev; CPUPPCState *firstenv = NULL; MemoryRegion *ccsr_addr_space; SysBusDevice *s; PPCE500CCSRState *ccsr; if (machine->cpu_model == NULL) { machine->cpu_model = "e500v2_v30"; } irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *)); irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB); for (i = 0; i < smp_cpus; i++) { PowerPCCPU *cpu; CPUState *cs; qemu_irq *input; cpu = cpu_ppc_init(machine->cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } env = &cpu->env; cs = CPU(cpu); if (!firstenv) { firstenv = env; } irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB); input = (qemu_irq *)env->irq_inputs; irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT]; irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT]; env->spr_cb[SPR_BOOKE_PIR].default_value = cs->cpu_index = i; env->mpic_iack = params->ccsrbar_base + MPC8544_MPIC_REGS_OFFSET + 0xa0; ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500); if (!i) { struct boot_info *boot_info; boot_info = g_malloc0(sizeof(struct boot_info)); qemu_register_reset(ppce500_cpu_reset, cpu); env->load_info = boot_info; } else { qemu_register_reset(ppce500_cpu_reset_sec, cpu); } } env = firstenv; ram_size &= ~(RAM_SIZES_ALIGN - 1); machine->ram_size = ram_size; memory_region_allocate_system_memory(ram, NULL, "mpc8544ds.ram", ram_size); memory_region_add_subregion(address_space_mem, 0, ram); dev = qdev_create(NULL, "e500-ccsr"); object_property_add_child(qdev_get_machine(), "e500-ccsr", OBJECT(dev), NULL); qdev_init_nofail(dev); ccsr = CCSR(dev); ccsr_addr_space = &ccsr->ccsr_space; memory_region_add_subregion(address_space_mem, params->ccsrbar_base, ccsr_addr_space); mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs); if (serial_hds[0]) { serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET, 0, mpic[42], 399193, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1]) { serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET, 0, mpic[42], 399193, serial_hds[1], DEVICE_BIG_ENDIAN); } dev = qdev_create(NULL, "mpc8544-guts"); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET, sysbus_mmio_get_region(s, 0)); dev = qdev_create(NULL, "e500-pcihost"); qdev_prop_set_uint32(dev, "first_slot", params->pci_first_slot); qdev_prop_set_uint32(dev, "first_pin_irq", pci_irq_nrs[0]); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); for (i = 0; i < PCI_NUM_PINS; i++) { sysbus_connect_irq(s, i, mpic[pci_irq_nrs[i]]); } memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET, sysbus_mmio_get_region(s, 0)); pci_bus = (PCIBus *)qdev_get_child_bus(dev, "pci.0"); if (!pci_bus) printf("couldn't create PCI controller!\n"); if (pci_bus) { for (i = 0; i < nb_nics; i++) { pci_nic_init_nofail(&nd_table[i], pci_bus, "virtio", NULL); } } sysbus_create_simple("e500-spin", params->spin_base, NULL); if (cur_base < (32 * 1024 * 1024)) { cur_base = (32 * 1024 * 1024); } if (params->has_mpc8xxx_gpio) { qemu_irq poweroff_irq; dev = qdev_create(NULL, "mpc8xxx_gpio"); s = SYS_BUS_DEVICE(dev); qdev_init_nofail(dev); sysbus_connect_irq(s, 0, mpic[MPC8XXX_GPIO_IRQ]); memory_region_add_subregion(ccsr_addr_space, MPC8XXX_GPIO_OFFSET, sysbus_mmio_get_region(s, 0)); poweroff_irq = qemu_allocate_irq(ppce500_power_off, NULL, 0); qdev_connect_gpio_out(dev, 0, poweroff_irq); } if (params->has_platform_bus) { dev = qdev_create(NULL, TYPE_PLATFORM_BUS_DEVICE); dev->id = TYPE_PLATFORM_BUS_DEVICE; qdev_prop_set_uint32(dev, "num_irqs", params->platform_bus_num_irqs); qdev_prop_set_uint32(dev, "mmio_size", params->platform_bus_size); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); for (i = 0; i < params->platform_bus_num_irqs; i++) { int irqn = params->platform_bus_first_irq + i; sysbus_connect_irq(s, i, mpic[irqn]); } memory_region_add_subregion(address_space_mem, params->platform_bus_base, sysbus_mmio_get_region(s, 0)); } if (machine->kernel_filename) { kernel_base = cur_base; kernel_size = load_image_targphys(machine->kernel_filename, cur_base, ram_size - cur_base); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", machine->kernel_filename); exit(1); } cur_base += kernel_size; } if (machine->initrd_filename) { initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK; initrd_size = load_image_targphys(machine->initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", machine->initrd_filename); exit(1); } cur_base = initrd_base + initrd_size; } if (bios_name == NULL) { if (machine->kernel_filename) { bios_name = machine->kernel_filename; } else { bios_name = "u-boot.e500"; } } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); bios_size = load_elf(filename, NULL, NULL, &bios_entry, &loadaddr, NULL, 1, ELF_MACHINE, 0); if (bios_size < 0) { kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL, NULL, NULL); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load firmware '%s'\n", filename); exit(1); } } dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK; dt_size = ppce500_prep_device_tree(machine, params, dt_base, initrd_base, initrd_size, kernel_base, kernel_size); if (dt_size < 0) { fprintf(stderr, "couldn't load device tree\n"); exit(1); } assert(dt_size < DTB_MAX_SIZE); boot_info = env->load_info; boot_info->entry = bios_entry; boot_info->dt_base = dt_base; boot_info->dt_size = dt_size; if (kvm_enabled()) { kvmppc_init(); } }
--------------------------------------------- Result 1011 ---------------------------------------------
[[0 (58%)]] --> [[0 (49%)]] --> Socre: 0.5057022273540497

[[[[Adv]]]]: static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int [[rc_rice_param]]) { int prefix = 0; int suffix = 0; int last_coeff_abs_level_remaining; int i; while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc)) prefix++; if (prefix < 3) { for (i = 0; i < [[rc_rice_param]]; i++) suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc); last_coeff_abs_level_remaining = (prefix << [[rc_rice_param]]) + suffix; } else { int prefix_minus3 = prefix - 3; if (prefix == CABAC_MAX_BIN) { av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix); return 0; } for (i = 0; i < prefix_minus3 + [[rc_rice_param]]; i++) suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc); last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1) << [[rc_rice_param]]) + suffix; } return last_coeff_abs_level_remaining; }

[[[[Adv]]]]: static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int [[regedhayzdarmat]]) { int prefix = 0; int suffix = 0; int last_coeff_abs_level_remaining; int i; while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc)) prefix++; if (prefix < 3) { for (i = 0; i < [[regedhayzdarmat]]; i++) suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc); last_coeff_abs_level_remaining = (prefix << [[regedhayzdarmat]]) + suffix; } else { int prefix_minus3 = prefix - 3; if (prefix == CABAC_MAX_BIN) { av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix); return 0; } for (i = 0; i < prefix_minus3 + [[regedhayzdarmat]]; i++) suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc); last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1) << [[regedhayzdarmat]]) + suffix; } return last_coeff_abs_level_remaining; }
--------------------------------------------- Result 1012 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 535 / 112 / 365 / 1012:  38%|███▊      | 1012/2690 [2:37:26<4:21:04,  9.33s/it][Succeeded / Failed / Skipped / Total] 535 / 112 / 365 / 1012:  38%|███▊      | 1013/2690 [2:37:46<4:21:11,  9.34s/it][Succeeded / Failed / Skipped / Total] 536 / 112 / 365 / 1013:  38%|███▊      | 1013/2690 [2:37:46<4:21:11,  9.34s/it][Succeeded / Failed / Skipped / Total] 536 / 112 / 365 / 1013:  38%|███▊      | 1014/2690 [2:38:20<4:21:43,  9.37s/it][Succeeded / Failed / Skipped / Total] 537 / 112 / 365 / 1014:  38%|███▊      | 1014/2690 [2:38:20<4:21:43,  9.37s/it][Succeeded / Failed / Skipped / Total] 537 / 112 / 365 / 1014:  38%|███▊      | 1015/2690 [2:38:24<4:21:24,  9.36s/it][Succeeded / Failed / Skipped / Total] 537 / 113 / 365 / 1015:  38%|███▊      | 1015/2690 [2:38:24<4:21:24,  9.36s/it][Succeeded / Failed / Skipped / Total] 537 / 113 / 365 / 1015:  38%|███▊      | 1016/2690 [2:38:30<4:21:10,  9.36s/it][Succeeded / Failed / Skipped / Total] 538 / 113 / 365 / 1016:  38%|███▊      | 1016/2690 [2:38:30<4:21:10,  9.36s/it][Succeeded / Failed / Skipped / Total] 538 / 113 / 365 / 1016:  38%|███▊      | 1017/2690 [2:38:51<4:21:19,  9.37s/it][[0 (98%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int segment_hls_window(AVFormatContext *s, int last) { SegmentContext *seg = s->priv_data; int i, ret = 0; char buf[1024]; if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) goto fail; avio_printf(seg->pb, "#EXTM3U\n"); avio_printf(seg->pb, "#EXT-X-VERSION:3\n"); avio_printf(seg->pb, "#EXT-X-TARGETDURATION:%d\n", (int)seg->time); avio_printf(seg->pb, "#EXT-X-MEDIA-SEQUENCE:%d\n", FFMAX(0, seg->number - seg->size)); av_log(s, AV_LOG_VERBOSE, "EXT-X-MEDIA-SEQUENCE:%d\n", FFMAX(0, seg->number - seg->size)); for (i = FFMAX(0, seg->number - seg->size); i < seg->number; i++) { avio_printf(seg->pb, "#EXTINF:%d,\n", (int)seg->time); if (seg->entry_prefix) { avio_printf(seg->pb, "%s", seg->entry_prefix); } ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i); if (ret < 0) { ret = AVERROR(EINVAL); goto fail; } avio_printf(seg->pb, "%s\n", buf); } if (last) avio_printf(seg->pb, "#EXT-X-ENDLIST\n"); fail: avio_closep(&seg->pb); return ret; }
--------------------------------------------- Result 1013 ---------------------------------------------
[[0 (89%)]] --> [[0 (17%)]] --> Socre: 0.8304346203804016

[[[[Adv]]]]: static inline int cris_addc_pi_m(int [[a]], int **b) { asm volatile ("addc [%1+], %0\n" : "+r" ([[a]]), "+b" (*b)); return [[a]]; }

[[[[Adv]]]]: static inline int cris_addc_pi_m(int [[any]], int **b) { asm volatile ("addc [%1+], %0\n" : "+r" ([[any]]), "+b" (*b)); return [[any]]; }
--------------------------------------------- Result 1014 ---------------------------------------------
[[0 (87%)]] --> [[0 (47%)]] --> Socre: 0.5309874713420868

[[[[Adv]]]]: static void vmgenid_query_monitor_test(void) { QemuUUID [[expected]], measured; gchar *[[cmd]]; g_assert(qemu_uuid_parse(VGID_GUID, &[[expected]]) == 0); [[cmd]] = g_strdup_printf("-machine accel=tcg -device vmgenid,id=testvgid," "guid=%s", VGID_GUID); qtest_start([[cmd]]); read_guid_from_monitor(&measured); g_assert(memcmp(measured.data, [[expected]].data, sizeof(measured.data)) == 0); qtest_quit(global_qtest); g_free([[cmd]]); }

[[[[Adv]]]]: static void vmgenid_query_monitor_test(void) { QemuUUID [[measured]], measured; gchar *[[pronef]]; g_assert(qemu_uuid_parse(VGID_GUID, &[[measured]]) == 0); [[pronef]] = g_strdup_printf("-machine accel=tcg -device vmgenid,id=testvgid," "guid=%s", VGID_GUID); qtest_start([[pronef]]); read_guid_from_monitor(&measured); g_assert(memcmp(measured.data, [[measured]].data, sizeof(measured.data)) == 0); qtest_quit(global_qtest); g_free([[pronef]]); }
--------------------------------------------- Result 1015 ---------------------------------------------
[[0 (9%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst, long [[width]], long [[height]], long [[lumStride]], long [[chromStride]], long srcStride) { long [[y]]; const x86_reg chromWidth= [[width]]>>1; for ([[y]]=0; [[y]]<[[height]]; [[y]]+=2) { #if COMPILE_TEMPLATE_MMX __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" "pcmpeqw %%mm7, %%mm7 \n\t" "psrlw $8, %%mm7 \n\t" ".p2align 4 \n\t" "1: \n\t" PREFETCH" 64(%0, %%"REG_a", 4) \n\t" "movq (%0, %%"REG_a", 4), %%mm0 \n\t" "movq 8(%0, %%"REG_a", 4), %%mm1 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm2, (%1, %%"REG_a", 2) \n\t" "movq 16(%0, %%"REG_a", 4), %%mm1 \n\t" "movq 24(%0, %%"REG_a", 4), %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "movq %%mm2, %%mm4 \n\t" "psrlw $8, %%mm1 \n\t" "psrlw $8, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "pand %%mm7, %%mm4 \n\t" "packuswb %%mm2, %%mm1 \n\t" "packuswb %%mm4, %%mm3 \n\t" MOVNTQ" %%mm3, 8(%1, %%"REG_a", 2) \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm0, (%3, %%"REG_a") \n\t" MOVNTQ" %%mm2, (%2, %%"REG_a") \n\t" "add $8, %%"REG_a" \n\t" "cmp %4, %%"REG_a" \n\t" " jb 1b \n\t" ::"r"(src), "r"(ydst), "r"(udst), "r"(vdst), "g" (chromWidth) : "memory", "%"REG_a ); ydst += [[lumStride]]; src += srcStride; __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" ".p2align 4 \n\t" "1: \n\t" PREFETCH" 64(%0, %%"REG_a", 4) \n\t" "movq (%0, %%"REG_a", 4), %%mm0 \n\t" "movq 8(%0, %%"REG_a", 4), %%mm1 \n\t" "movq 16(%0, %%"REG_a", 4), %%mm2 \n\t" "movq 24(%0, %%"REG_a", 4), %%mm3 \n\t" "pand %%mm7, %%mm0 \n\t" "pand %%mm7, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm0, (%1, %%"REG_a", 2) \n\t" MOVNTQ" %%mm2, 8(%1, %%"REG_a", 2) \n\t" "add $8, %%"REG_a" \n\t" "cmp %4, %%"REG_a" \n\t" " jb 1b \n\t" ::"r"(src), "r"(ydst), "r"(udst), "r"(vdst), "g" (chromWidth) : "memory", "%"REG_a ); #else long i; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += [[lumStride]]; src += srcStride; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; ydst[2*i+1] = src[4*i+2]; } #endif udst += [[chromStride]]; vdst += [[chromStride]]; ydst += [[lumStride]]; src += srcStride; } #if COMPILE_TEMPLATE_MMX __asm__ volatile(EMMS" \n\t" SFENCE" \n\t" :::"memory"); #endif }

[[[[Adv]]]]: static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst, long [[slit]], long [[crack]], long [[balmtreve]], long [[sprayustrant]], long srcStride) { long [[glass]]; const x86_reg chromWidth= [[slit]]>>1; for ([[glass]]=0; [[glass]]<[[crack]]; [[glass]]+=2) { #if COMPILE_TEMPLATE_MMX __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" "pcmpeqw %%mm7, %%mm7 \n\t" "psrlw $8, %%mm7 \n\t" ".p2align 4 \n\t" "1: \n\t" PREFETCH" 64(%0, %%"REG_a", 4) \n\t" "movq (%0, %%"REG_a", 4), %%mm0 \n\t" "movq 8(%0, %%"REG_a", 4), %%mm1 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm2, (%1, %%"REG_a", 2) \n\t" "movq 16(%0, %%"REG_a", 4), %%mm1 \n\t" "movq 24(%0, %%"REG_a", 4), %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "movq %%mm2, %%mm4 \n\t" "psrlw $8, %%mm1 \n\t" "psrlw $8, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "pand %%mm7, %%mm4 \n\t" "packuswb %%mm2, %%mm1 \n\t" "packuswb %%mm4, %%mm3 \n\t" MOVNTQ" %%mm3, 8(%1, %%"REG_a", 2) \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm0, (%3, %%"REG_a") \n\t" MOVNTQ" %%mm2, (%2, %%"REG_a") \n\t" "add $8, %%"REG_a" \n\t" "cmp %4, %%"REG_a" \n\t" " jb 1b \n\t" ::"r"(src), "r"(ydst), "r"(udst), "r"(vdst), "g" (chromWidth) : "memory", "%"REG_a ); ydst += [[balmtreve]]; src += srcStride; __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" ".p2align 4 \n\t" "1: \n\t" PREFETCH" 64(%0, %%"REG_a", 4) \n\t" "movq (%0, %%"REG_a", 4), %%mm0 \n\t" "movq 8(%0, %%"REG_a", 4), %%mm1 \n\t" "movq 16(%0, %%"REG_a", 4), %%mm2 \n\t" "movq 24(%0, %%"REG_a", 4), %%mm3 \n\t" "pand %%mm7, %%mm0 \n\t" "pand %%mm7, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm0, (%1, %%"REG_a", 2) \n\t" MOVNTQ" %%mm2, 8(%1, %%"REG_a", 2) \n\t" "add $8, %%"REG_a" \n\t" "cmp %4, %%"REG_a" \n\t" " jb 1b \n\t" ::"r"(src), "r"(ydst), "r"(udst), "r"(vdst), "g" (chromWidth) : "memory", "%"REG_a ); #else long i; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += [[balmtreve]]; src += srcStride; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; ydst[2*i+1] = src[4*i+2]; } #endif udst += [[sprayustrant]]; vdst += [[sprayustrant]]; ydst += [[balmtreve]]; src += srcStride; } #if COMPILE_TEMPLATE_MMX __asm__ volatile(EMMS" \n\t" SFENCE" \n\t" :::"memory"); #endif }
--------------------------------------------- Result 1016 ---------------------------------------------
[[0 (8%)]] --> [[0 (52%)]] --> Socre: 0.5151903033256531

[[[[Adv]]]]: static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *[[node]], const char *[[name]], BlockDriverState **pbs, AioContext **[[paio]], Error **errp) { BlockDriverState *bs; BdrvDirtyBitmap *[[bitmap]]; AioContext *aio_context; if (![[node]]) { error_setg(errp, "Node cannot be NULL"); return NULL; } if (![[name]]) { error_setg(errp, "Bitmap name cannot be NULL"); return NULL; } bs = bdrv_lookup_bs([[node]], [[node]], NULL); if (!bs) { error_setg(errp, "Node '%s' not found", [[node]]); return NULL; } aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); [[bitmap]] = bdrv_find_dirty_bitmap(bs, [[name]]); if (![[bitmap]]) { error_setg(errp, "Dirty bitmap '%s' not found", [[name]]); goto fail; } if (pbs) { *pbs = bs; } if ([[paio]]) { *[[paio]] = aio_context; } else { aio_context_release(aio_context); } return [[bitmap]]; fail: aio_context_release(aio_context); return NULL; }

[[[[Adv]]]]: static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *[[vine]], const char *[[memory]], BlockDriverState **pbs, AioContext **[[vayo]], Error **errp) { BlockDriverState *bs; BdrvDirtyBitmap *[[bitمpie]]; AioContext *aio_context; if (![[vine]]) { error_setg(errp, "Node cannot be NULL"); return NULL; } if (![[memory]]) { error_setg(errp, "Bitmap name cannot be NULL"); return NULL; } bs = bdrv_lookup_bs([[vine]], [[vine]], NULL); if (!bs) { error_setg(errp, "Node '%s' not found", [[vine]]); return NULL; } aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); [[bitمpie]] = bdrv_find_dirty_bitmap(bs, [[memory]]); if (![[bitمpie]]) { error_setg(errp, "Dirty bitmap '%s' not found", [[memory]]); goto fail; } if (pbs) { *pbs = bs; } if ([[vayo]]) { *[[vayo]] = aio_context; } else { aio_context_release(aio_context); } return [[bitمpie]]; fail: aio_context_release(aio_context); return NULL; }
--------------------------------------------- Result 1017 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 539 / 113 / 365 / 1017:  38%|███▊      | 1017/2690 [2:38:51<4:21:19,  9.37s/it][Succeeded / Failed / Skipped / Total] 539 / 113 / 365 / 1017:  38%|███▊      | 1018/2690 [2:39:18<4:21:38,  9.39s/it][Succeeded / Failed / Skipped / Total] 539 / 114 / 365 / 1018:  38%|███▊      | 1018/2690 [2:39:18<4:21:38,  9.39s/it][Succeeded / Failed / Skipped / Total] 539 / 114 / 365 / 1018:  38%|███▊      | 1019/2690 [2:39:22<4:21:21,  9.38s/it][[0 (52%)]] --> [[0 (48%)]] --> Socre: 0.5177292823791504

[[[[Adv]]]]: static int decode_frame_byterun1(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { IffContext *[[s]] = avctx->priv_data; const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL; const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0; const uint8_t *buf_end = buf+buf_size; int y, plane, res; if ((res = extract_header(avctx, avpkt)) < 0) return res; if ([[s]]->init) { if ((res = avctx->reget_buffer(avctx, &[[s]]->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n"); return res; } } else if ((res = avctx->get_buffer(avctx, &[[s]]->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return res; } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) { if ((res = ff_cmap_read_palette(avctx, (uint32_t*)[[s]]->frame.data[1])) < 0) return res; } [[s]]->init = 1; if (avctx->codec_tag == MKTAG('I','L','B','M')) { if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { for(y = 0; y < avctx->height ; y++ ) { uint8_t *row = &[[s]]->frame.data[0][ y*[[s]]->frame.linesize[0] ]; memset(row, 0, avctx->width); for (plane = 0; plane < [[s]]->bpp; plane++) { buf += decode_byterun([[s]]->planebuf, [[s]]->planesize, buf, buf_end); decodeplane8(row, [[s]]->planebuf, [[s]]->planesize, plane); } } } else if ([[s]]->ham) { for (y = 0; y < avctx->height ; y++) { uint8_t *row = &[[s]]->frame.data[0][y*[[s]]->frame.linesize[0]]; memset([[s]]->ham_buf, 0, avctx->width); for (plane = 0; plane < [[s]]->bpp; plane++) { buf += decode_byterun([[s]]->planebuf, [[s]]->planesize, buf, buf_end); decodeplane8([[s]]->ham_buf, [[s]]->planebuf, [[s]]->planesize, plane); } decode_ham_plane32((uint32_t *) row, [[s]]->ham_buf, [[s]]->ham_palbuf, [[s]]->planesize); } } else { for(y = 0; y < avctx->height ; y++ ) { uint8_t *row = &[[s]]->frame.data[0][y*[[s]]->frame.linesize[0]]; memset(row, 0, avctx->width << 2); for (plane = 0; plane < [[s]]->bpp; plane++) { buf += decode_byterun([[s]]->planebuf, [[s]]->planesize, buf, buf_end); decodeplane32((uint32_t *) row, [[s]]->planebuf, [[s]]->planesize, plane); } } } } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { for(y = 0; y < avctx->height ; y++ ) { uint8_t *row = &[[s]]->frame.data[0][y*[[s]]->frame.linesize[0]]; buf += decode_byterun(row, avctx->width, buf, buf_end); } } else { for (y = 0; y < avctx->height ; y++) { uint8_t *row = &[[s]]->frame.data[0][y*[[s]]->frame.linesize[0]]; buf += decode_byterun([[s]]->ham_buf, avctx->width, buf, buf_end); decode_ham_plane32((uint32_t *) row, [[s]]->ham_buf, [[s]]->ham_palbuf, avctx->width); } } *data_size = sizeof(AVFrame); *(AVFrame*)data = [[s]]->frame; return buf_size; }

[[[[Adv]]]]: static int decode_frame_byterun1(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { IffContext *[[data]] = avctx->priv_data; const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL; const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0; const uint8_t *buf_end = buf+buf_size; int y, plane, res; if ((res = extract_header(avctx, avpkt)) < 0) return res; if ([[data]]->init) { if ((res = avctx->reget_buffer(avctx, &[[data]]->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n"); return res; } } else if ((res = avctx->get_buffer(avctx, &[[data]]->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return res; } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) { if ((res = ff_cmap_read_palette(avctx, (uint32_t*)[[data]]->frame.data[1])) < 0) return res; } [[data]]->init = 1; if (avctx->codec_tag == MKTAG('I','L','B','M')) { if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { for(y = 0; y < avctx->height ; y++ ) { uint8_t *row = &[[data]]->frame.data[0][ y*[[data]]->frame.linesize[0] ]; memset(row, 0, avctx->width); for (plane = 0; plane < [[data]]->bpp; plane++) { buf += decode_byterun([[data]]->planebuf, [[data]]->planesize, buf, buf_end); decodeplane8(row, [[data]]->planebuf, [[data]]->planesize, plane); } } } else if ([[data]]->ham) { for (y = 0; y < avctx->height ; y++) { uint8_t *row = &[[data]]->frame.data[0][y*[[data]]->frame.linesize[0]]; memset([[data]]->ham_buf, 0, avctx->width); for (plane = 0; plane < [[data]]->bpp; plane++) { buf += decode_byterun([[data]]->planebuf, [[data]]->planesize, buf, buf_end); decodeplane8([[data]]->ham_buf, [[data]]->planebuf, [[data]]->planesize, plane); } decode_ham_plane32((uint32_t *) row, [[data]]->ham_buf, [[data]]->ham_palbuf, [[data]]->planesize); } } else { for(y = 0; y < avctx->height ; y++ ) { uint8_t *row = &[[data]]->frame.data[0][y*[[data]]->frame.linesize[0]]; memset(row, 0, avctx->width << 2); for (plane = 0; plane < [[data]]->bpp; plane++) { buf += decode_byterun([[data]]->planebuf, [[data]]->planesize, buf, buf_end); decodeplane32((uint32_t *) row, [[data]]->planebuf, [[data]]->planesize, plane); } } } } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { for(y = 0; y < avctx->height ; y++ ) { uint8_t *row = &[[data]]->frame.data[0][y*[[data]]->frame.linesize[0]]; buf += decode_byterun(row, avctx->width, buf, buf_end); } } else { for (y = 0; y < avctx->height ; y++) { uint8_t *row = &[[data]]->frame.data[0][y*[[data]]->frame.linesize[0]]; buf += decode_byterun([[data]]->ham_buf, avctx->width, buf, buf_end); decode_ham_plane32((uint32_t *) row, [[data]]->ham_buf, [[data]]->ham_palbuf, avctx->width); } } *data_size = sizeof(AVFrame); *(AVFrame*)data = [[data]]->frame; return buf_size; }
--------------------------------------------- Result 1018 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int decode_pic_hdr(IVI5DecContext *[[ctx]], AVCodecContext *[[avctx]]) { if (get_bits(&[[ctx]]->gb, 5) != 0x1F) { av_log([[avctx]], AV_LOG_ERROR, "Invalid picture start code!\n"); return -1; [[ctx]]->prev_frame_type = [[ctx]]->frame_type; [[ctx]]->frame_type = get_bits(&[[ctx]]->gb, 3); if ([[ctx]]->frame_type >= 5) { av_log([[avctx]], AV_LOG_ERROR, "Invalid frame type: %d \n", [[ctx]]->frame_type); return -1; [[ctx]]->frame_num = get_bits(&[[ctx]]->gb, 8); if ([[ctx]]->frame_type == FRAMETYPE_INTRA) { [[ctx]]->gop_invalid = 1; if (decode_gop_header([[ctx]], [[avctx]])) return -1; [[ctx]]->gop_invalid = 0; if ([[ctx]]->frame_type != FRAMETYPE_NULL) { [[ctx]]->frame_flags = get_bits(&[[ctx]]->gb, 8); [[ctx]]->pic_hdr_size = ([[ctx]]->frame_flags & 1) ? get_bits_long(&[[ctx]]->gb, 24) : 0; [[ctx]]->checksum = ([[ctx]]->frame_flags & 0x10) ? get_bits(&[[ctx]]->gb, 16) : 0; if ([[ctx]]->frame_flags & 0x20) skip_hdr_extension(&[[ctx]]->gb); if (ff_ivi_dec_huff_desc(&[[ctx]]->gb, [[ctx]]->frame_flags & 0x40, IVI_MB_HUFF, &[[ctx]]->mb_vlc, [[avctx]])) return -1; skip_bits(&[[ctx]]->gb, 3); align_get_bits(&[[ctx]]->gb); return 0;

[[[[Adv]]]]: static int decode_pic_hdr(IVI5DecContext *[[brxa]], AVCodecContext *[[fateξ]]) { if (get_bits(&[[brxa]]->gb, 5) != 0x1F) { av_log([[fateξ]], AV_LOG_ERROR, "Invalid picture start code!\n"); return -1; [[brxa]]->prev_frame_type = [[brxa]]->frame_type; [[brxa]]->frame_type = get_bits(&[[brxa]]->gb, 3); if ([[brxa]]->frame_type >= 5) { av_log([[fateξ]], AV_LOG_ERROR, "Invalid frame type: %d \n", [[brxa]]->frame_type); return -1; [[brxa]]->frame_num = get_bits(&[[brxa]]->gb, 8); if ([[brxa]]->frame_type == FRAMETYPE_INTRA) { [[brxa]]->gop_invalid = 1; if (decode_gop_header([[brxa]], [[fateξ]])) return -1; [[brxa]]->gop_invalid = 0; if ([[brxa]]->frame_type != FRAMETYPE_NULL) { [[brxa]]->frame_flags = get_bits(&[[brxa]]->gb, 8); [[brxa]]->pic_hdr_size = ([[brxa]]->frame_flags & 1) ? get_bits_long(&[[brxa]]->gb, 24) : 0; [[brxa]]->checksum = ([[brxa]]->frame_flags & 0x10) ? get_bits(&[[brxa]]->gb, 16) : 0; if ([[brxa]]->frame_flags & 0x20) skip_hdr_extension(&[[brxa]]->gb); if (ff_ivi_dec_huff_desc(&[[brxa]]->gb, [[brxa]]->frame_flags & 0x40, IVI_MB_HUFF, &[[brxa]]->mb_vlc, [[fateξ]])) return -1; skip_bits(&[[brxa]]->gb, 3); align_get_bits(&[[brxa]]->gb); return 0;
--------------------------------------------- Result 1019 ---------------------------------------------
[[0 (51%)]] --> [[0 (37%)]] --> Socre: 0.6343028545379639

[[[[Adv]]]]: static int mpegts_write_header(AVFormatContext *s) { MpegTSWrite *[[ts]] = s->priv_data; MpegTSWriteStream *ts_st; MpegTSService *service; AVStream *st, *pcr_st = NULL; AVDictionaryEntry *title, *provider; int i, j; const char *service_name; const char *provider_name; int *pids; int ret; if (s->max_delay < 0) s->max_delay = 0; [[ts]]->pes_payload_size = ([[ts]]->pes_payload_size + 14 + 183) / 184 * 184 - 14; [[ts]]->tsid = [[ts]]->transport_stream_id; [[ts]]->onid = [[ts]]->original_network_id; title = av_dict_get(s->metadata, "service_name", NULL, 0); if (!title) title = av_dict_get(s->metadata, "title", NULL, 0); service_name = title ? title->value : DEFAULT_SERVICE_NAME; provider = av_dict_get(s->metadata, "service_provider", NULL, 0); provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME; service = mpegts_add_service([[ts]], [[ts]]->service_id, provider_name, service_name); if (!service) return AVERROR(ENOMEM); service->pmt.write_packet = section_write_packet; service->pmt.opaque = s; service->pmt.cc = 15; [[ts]]->pat.pid = PAT_PID; [[ts]]->pat.cc = 15; [[ts]]->pat.write_packet = section_write_packet; [[ts]]->pat.opaque = s; [[ts]]->sdt.pid = SDT_PID; [[ts]]->sdt.cc = 15; [[ts]]->sdt.write_packet = section_write_packet; [[ts]]->sdt.opaque = s; pids = av_malloc_array(s->nb_streams, sizeof(*pids)); if (!pids) { ret = AVERROR(ENOMEM); goto fail; } for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; ts_st = av_mallocz(sizeof(MpegTSWriteStream)); if (!ts_st) { ret = AVERROR(ENOMEM); goto fail; } st->priv_data = ts_st; ts_st->user_tb = st->time_base; avpriv_set_pts_info(st, 33, 1, 90000); ts_st->payload = av_mallocz([[ts]]->pes_payload_size); if (!ts_st->payload) { ret = AVERROR(ENOMEM); goto fail; } ts_st->service = service; if (st->id < 16) { ts_st->pid = [[ts]]->start_pid + i; } else if (st->id < 0x1FFF) { ts_st->pid = st->id; } else { av_log(s, AV_LOG_ERROR, "Invalid stream id %d, must be less than 8191\n", st->id); ret = AVERROR(EINVAL); goto fail; } if (ts_st->pid == service->pmt.pid) { av_log(s, AV_LOG_ERROR, "Duplicate stream id %d\n", ts_st->pid); ret = AVERROR(EINVAL); goto fail; } for (j = 0; j < i; j++) { if (pids[j] == ts_st->pid) { av_log(s, AV_LOG_ERROR, "Duplicate stream id %d\n", ts_st->pid); ret = AVERROR(EINVAL); goto fail; } } pids[i] = ts_st->pid; ts_st->payload_pts = AV_NOPTS_VALUE; ts_st->payload_dts = AV_NOPTS_VALUE; ts_st->first_pts_check = 1; ts_st->cc = 15; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && service->pcr_pid == 0x1fff) { service->pcr_pid = ts_st->pid; pcr_st = st; } if (st->codec->codec_id == AV_CODEC_ID_AAC && st->codec->extradata_size > 0) { AVStream *ast; ts_st->amux = avformat_alloc_context(); if (!ts_st->amux) { ret = AVERROR(ENOMEM); goto fail; } ts_st->amux->oformat = av_guess_format(([[ts]]->flags & MPEGTS_FLAG_AAC_LATM) ? "latm" : "adts", NULL, NULL); if (!ts_st->amux->oformat) { ret = AVERROR(EINVAL); goto fail; } if (!(ast = avformat_new_stream(ts_st->amux, NULL))) { ret = AVERROR(ENOMEM); goto fail; } ret = avcodec_copy_context(ast->codec, st->codec); if (ret != 0) goto fail; ast->time_base = st->time_base; ret = avformat_write_header(ts_st->amux, NULL); if (ret < 0) goto fail; } if (st->codec->codec_id == AV_CODEC_ID_OPUS) { ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate; } } av_freep(&pids); if (service->pcr_pid == 0x1fff && s->nb_streams > 0) { pcr_st = s->streams[0]; ts_st = pcr_st->priv_data; service->pcr_pid = ts_st->pid; } else ts_st = pcr_st->priv_data; if ([[ts]]->mux_rate > 1) { service->pcr_packet_period = ([[ts]]->mux_rate * [[ts]]->pcr_period) / (TS_PACKET_SIZE * 8 * 1000); [[ts]]->sdt_packet_period = ([[ts]]->mux_rate * SDT_RETRANS_TIME) / (TS_PACKET_SIZE * 8 * 1000); [[ts]]->pat_packet_period = ([[ts]]->mux_rate * PAT_RETRANS_TIME) / (TS_PACKET_SIZE * 8 * 1000); if ([[ts]]->copyts < 1) [[ts]]->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE); } else { [[ts]]->sdt_packet_period = 200; [[ts]]->pat_packet_period = 40; if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (!pcr_st->codec->frame_size) { av_log(s, AV_LOG_WARNING, "frame size not set\n"); service->pcr_packet_period = pcr_st->codec->sample_rate / (10 * 512); } else { service->pcr_packet_period = pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size); } } else { service->pcr_packet_period = ts_st->user_tb.den / (10 * ts_st->user_tb.num); } if (!service->pcr_packet_period) service->pcr_packet_period = 1; } [[ts]]->last_pat_ts = AV_NOPTS_VALUE; [[ts]]->last_sdt_ts = AV_NOPTS_VALUE; if ([[ts]]->pat_period < INT_MAX/2) { [[ts]]->pat_packet_period = INT_MAX; } if ([[ts]]->sdt_period < INT_MAX/2) { [[ts]]->sdt_packet_period = INT_MAX; } service->pcr_packet_count = service->pcr_packet_period; [[ts]]->pat_packet_count = [[ts]]->pat_packet_period - 1; [[ts]]->sdt_packet_count = [[ts]]->sdt_packet_period - 1; if ([[ts]]->mux_rate == 1) av_log(s, AV_LOG_VERBOSE, "muxrate VBR, "); else av_log(s, AV_LOG_VERBOSE, "muxrate %d, ", [[ts]]->mux_rate); av_log(s, AV_LOG_VERBOSE, "pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\n", service->pcr_packet_period, [[ts]]->sdt_packet_period, [[ts]]->pat_packet_period); if ([[ts]]->m2ts_mode == -1) { if (av_match_ext(s->filename, "m2ts")) { [[ts]]->m2ts_mode = 1; } else { [[ts]]->m2ts_mode = 0; } } return 0; fail: av_freep(&pids); for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; ts_st = st->priv_data; if (ts_st) { av_freep(&ts_st->payload); if (ts_st->amux) { avformat_free_context(ts_st->amux); ts_st->amux = NULL; } } av_freep(&st->priv_data); } for (i = 0; i < [[ts]]->nb_services; i++) { service = [[ts]]->services[i]; av_freep(&service->provider_name); av_freep(&service->name); av_freep(&service); } av_freep(&[[ts]]->services); return ret; }

[[[[Adv]]]]: static int mpegts_write_header(AVFormatContext *s) { MpegTSWrite *[[lynx]] = s->priv_data; MpegTSWriteStream *ts_st; MpegTSService *service; AVStream *st, *pcr_st = NULL; AVDictionaryEntry *title, *provider; int i, j; const char *service_name; const char *provider_name; int *pids; int ret; if (s->max_delay < 0) s->max_delay = 0; [[lynx]]->pes_payload_size = ([[lynx]]->pes_payload_size + 14 + 183) / 184 * 184 - 14; [[lynx]]->tsid = [[lynx]]->transport_stream_id; [[lynx]]->onid = [[lynx]]->original_network_id; title = av_dict_get(s->metadata, "service_name", NULL, 0); if (!title) title = av_dict_get(s->metadata, "title", NULL, 0); service_name = title ? title->value : DEFAULT_SERVICE_NAME; provider = av_dict_get(s->metadata, "service_provider", NULL, 0); provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME; service = mpegts_add_service([[lynx]], [[lynx]]->service_id, provider_name, service_name); if (!service) return AVERROR(ENOMEM); service->pmt.write_packet = section_write_packet; service->pmt.opaque = s; service->pmt.cc = 15; [[lynx]]->pat.pid = PAT_PID; [[lynx]]->pat.cc = 15; [[lynx]]->pat.write_packet = section_write_packet; [[lynx]]->pat.opaque = s; [[lynx]]->sdt.pid = SDT_PID; [[lynx]]->sdt.cc = 15; [[lynx]]->sdt.write_packet = section_write_packet; [[lynx]]->sdt.opaque = s; pids = av_malloc_array(s->nb_streams, sizeof(*pids)); if (!pids) { ret = AVERROR(ENOMEM); goto fail; } for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; ts_st = av_mallocz(sizeof(MpegTSWriteStream)); if (!ts_st) { ret = AVERROR(ENOMEM); goto fail; } st->priv_data = ts_st; ts_st->user_tb = st->time_base; avpriv_set_pts_info(st, 33, 1, 90000); ts_st->payload = av_mallocz([[lynx]]->pes_payload_size); if (!ts_st->payload) { ret = AVERROR(ENOMEM); goto fail; } ts_st->service = service; if (st->id < 16) { ts_st->pid = [[lynx]]->start_pid + i; } else if (st->id < 0x1FFF) { ts_st->pid = st->id; } else { av_log(s, AV_LOG_ERROR, "Invalid stream id %d, must be less than 8191\n", st->id); ret = AVERROR(EINVAL); goto fail; } if (ts_st->pid == service->pmt.pid) { av_log(s, AV_LOG_ERROR, "Duplicate stream id %d\n", ts_st->pid); ret = AVERROR(EINVAL); goto fail; } for (j = 0; j < i; j++) { if (pids[j] == ts_st->pid) { av_log(s, AV_LOG_ERROR, "Duplicate stream id %d\n", ts_st->pid); ret = AVERROR(EINVAL); goto fail; } } pids[i] = ts_st->pid; ts_st->payload_pts = AV_NOPTS_VALUE; ts_st->payload_dts = AV_NOPTS_VALUE; ts_st->first_pts_check = 1; ts_st->cc = 15; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && service->pcr_pid == 0x1fff) { service->pcr_pid = ts_st->pid; pcr_st = st; } if (st->codec->codec_id == AV_CODEC_ID_AAC && st->codec->extradata_size > 0) { AVStream *ast; ts_st->amux = avformat_alloc_context(); if (!ts_st->amux) { ret = AVERROR(ENOMEM); goto fail; } ts_st->amux->oformat = av_guess_format(([[lynx]]->flags & MPEGTS_FLAG_AAC_LATM) ? "latm" : "adts", NULL, NULL); if (!ts_st->amux->oformat) { ret = AVERROR(EINVAL); goto fail; } if (!(ast = avformat_new_stream(ts_st->amux, NULL))) { ret = AVERROR(ENOMEM); goto fail; } ret = avcodec_copy_context(ast->codec, st->codec); if (ret != 0) goto fail; ast->time_base = st->time_base; ret = avformat_write_header(ts_st->amux, NULL); if (ret < 0) goto fail; } if (st->codec->codec_id == AV_CODEC_ID_OPUS) { ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate; } } av_freep(&pids); if (service->pcr_pid == 0x1fff && s->nb_streams > 0) { pcr_st = s->streams[0]; ts_st = pcr_st->priv_data; service->pcr_pid = ts_st->pid; } else ts_st = pcr_st->priv_data; if ([[lynx]]->mux_rate > 1) { service->pcr_packet_period = ([[lynx]]->mux_rate * [[lynx]]->pcr_period) / (TS_PACKET_SIZE * 8 * 1000); [[lynx]]->sdt_packet_period = ([[lynx]]->mux_rate * SDT_RETRANS_TIME) / (TS_PACKET_SIZE * 8 * 1000); [[lynx]]->pat_packet_period = ([[lynx]]->mux_rate * PAT_RETRANS_TIME) / (TS_PACKET_SIZE * 8 * 1000); if ([[lynx]]->copyts < 1) [[lynx]]->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE); } else { [[lynx]]->sdt_packet_period = 200; [[lynx]]->pat_packet_period = 40; if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (!pcr_st->codec->frame_size) { av_log(s, AV_LOG_WARNING, "frame size not set\n"); service->pcr_packet_period = pcr_st->codec->sample_rate / (10 * 512); } else { service->pcr_packet_period = pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size); } } else { service->pcr_packet_period = ts_st->user_tb.den / (10 * ts_st->user_tb.num); } if (!service->pcr_packet_period) service->pcr_packet_period = 1; } [[lynx]]->last_pat_ts = AV_NOPTS_VALUE; [[lynx]]->last_sdt_ts = AV_NOPTS_VALUE; if ([[lynx]]->pat_period < INT_MAX/2) { [[lynx]]->pat_packet_period = INT_MAX; } if ([[lynx]]->sdt_period < INT_MAX/2) { [[lynx]]->sdt_packet_period = INT_MAX; } service->pcr_packet_count = service->pcr_packet_period; [[lynx]]->pat_packet_count = [[lynx]]->pat_packet_period - 1; [[lynx]]->sdt_packet_count = [[lynx]]->sdt_packet_period - 1; if ([[lynx]]->mux_rate == 1) av_log(s, AV_LOG_VERBOSE, "muxrate VBR, "); else av_log(s, AV_LOG_VERBOSE, "muxrate %d, ", [[lynx]]->mux_rate); av_log(s, AV_LOG_VERBOSE, "pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\n", service->pcr_packet_period, [[lynx]]->sdt_packet_period, [[lynx]]->pat_packet_period); if ([[lynx]]->m2ts_mode == -1) { if (av_match_ext(s->filename, "m2ts")) { [[lynx]]->m2ts_mode = 1; } else { [[lynx]]->m2ts_mode = 0; } } return 0; fail: av_freep(&pids); for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; ts_st = st->priv_data; if (ts_st) { av_freep(&ts_st->payload); if (ts_st->amux) { avformat_free_context(ts_st->amux); ts_st->amux = NULL; } } av_freep(&st->priv_data); } for (i = 0; i < [[lynx]]->nb_services; i++) { service = [[lynx]]->services[i]; av_freep(&service->provider_name); av_freep(&service->name); av_freep(&service); } av_freep(&[[lynx]]->services); return ret; }[Succeeded / Failed / Skipped / Total] 540 / 114 / 365 / 1019:  38%|███▊      | 1019/2690 [2:39:22<4:21:21,  9.38s/it][Succeeded / Failed / Skipped / Total] 540 / 114 / 365 / 1019:  38%|███▊      | 1020/2690 [2:39:35<4:21:18,  9.39s/it][Succeeded / Failed / Skipped / Total] 541 / 114 / 365 / 1020:  38%|███▊      | 1020/2690 [2:39:35<4:21:18,  9.39s/it][Succeeded / Failed / Skipped / Total] 541 / 114 / 365 / 1020:  38%|███▊      | 1021/2690 [2:39:37<4:20:56,  9.38s/it][Succeeded / Failed / Skipped / Total] 542 / 114 / 365 / 1021:  38%|███▊      | 1021/2690 [2:39:37<4:20:56,  9.38s/it][Succeeded / Failed / Skipped / Total] 542 / 114 / 365 / 1021:  38%|███▊      | 1022/2690 [2:39:47<4:20:47,  9.38s/it]
--------------------------------------------- Result 1020 ---------------------------------------------
[[0 (1%)]] --> [[0 (99%)]] --> Socre: 0.990575909614563

[[[[Adv]]]]: static inline void gen_op_movl_seg_T0_vm(int [[seg_reg]]) { tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff); tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[[[seg_reg]]].selector)); tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4); tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[[[seg_reg]]].base)); }

[[[[Adv]]]]: static inline void gen_op_movl_seg_T0_vm(int [[teг16over]]) { tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff); tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[[[teг16over]]].selector)); tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4); tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[[[teг16over]]].base)); }
--------------------------------------------- Result 1021 ---------------------------------------------
[[0 (94%)]] --> [[0 (15%)]] --> Socre: 0.8524368852376938

[[[[Adv]]]]: void dct32(INTFLOAT *[[out]], const INTFLOAT *tab) { INTFLOAT tmp0, tmp1; INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 , val8 , val9 , val10, val11, val12, val13, val14, val15, val16, val17, val18, val19, val20, val21, val22, val23, val24, val25, val26, val27, val28, val29, val30, val31; BF0( 0, 31, COS0_0 , 1); BF0(15, 16, COS0_15, 5); BF( 0, 15, COS1_0 , 1); BF(16, 31,-COS1_0 , 1); BF0( 7, 24, COS0_7 , 1); BF0( 8, 23, COS0_8 , 1); BF( 7, 8, COS1_7 , 4); BF(23, 24,-COS1_7 , 4); BF( 0, 7, COS2_0 , 1); BF( 8, 15,-COS2_0 , 1); BF(16, 23, COS2_0 , 1); BF(24, 31,-COS2_0 , 1); BF0( 3, 28, COS0_3 , 1); BF0(12, 19, COS0_12, 2); BF( 3, 12, COS1_3 , 1); BF(19, 28,-COS1_3 , 1); BF0( 4, 27, COS0_4 , 1); BF0(11, 20, COS0_11, 2); BF( 4, 11, COS1_4 , 1); BF(20, 27,-COS1_4 , 1); BF( 3, 4, COS2_3 , 3); BF(11, 12,-COS2_3 , 3); BF(19, 20, COS2_3 , 3); BF(27, 28,-COS2_3 , 3); BF( 0, 3, COS3_0 , 1); BF( 4, 7,-COS3_0 , 1); BF( 8, 11, COS3_0 , 1); BF(12, 15,-COS3_0 , 1); BF(16, 19, COS3_0 , 1); BF(20, 23,-COS3_0 , 1); BF(24, 27, COS3_0 , 1); BF(28, 31,-COS3_0 , 1); BF0( 1, 30, COS0_1 , 1); BF0(14, 17, COS0_14, 3); BF( 1, 14, COS1_1 , 1); BF(17, 30,-COS1_1 , 1); BF0( 6, 25, COS0_6 , 1); BF0( 9, 22, COS0_9 , 1); BF( 6, 9, COS1_6 , 2); BF(22, 25,-COS1_6 , 2); BF( 1, 6, COS2_1 , 1); BF( 9, 14,-COS2_1 , 1); BF(17, 22, COS2_1 , 1); BF(25, 30,-COS2_1 , 1); BF0( 2, 29, COS0_2 , 1); BF0(13, 18, COS0_13, 3); BF( 2, 13, COS1_2 , 1); BF(18, 29,-COS1_2 , 1); BF0( 5, 26, COS0_5 , 1); BF0(10, 21, COS0_10, 1); BF( 5, 10, COS1_5 , 2); BF(21, 26,-COS1_5 , 2); BF( 2, 5, COS2_2 , 1); BF(10, 13,-COS2_2 , 1); BF(18, 21, COS2_2 , 1); BF(26, 29,-COS2_2 , 1); BF( 1, 2, COS3_1 , 2); BF( 5, 6,-COS3_1 , 2); BF( 9, 10, COS3_1 , 2); BF(13, 14,-COS3_1 , 2); BF(17, 18, COS3_1 , 2); BF(21, 22,-COS3_1 , 2); BF(25, 26, COS3_1 , 2); BF(29, 30,-COS3_1 , 2); BF1( 0, 1, 2, 3); BF2( 4, 5, 6, 7); BF1( 8, 9, 10, 11); BF2(12, 13, 14, 15); BF1(16, 17, 18, 19); BF2(20, 21, 22, 23); BF1(24, 25, 26, 27); BF2(28, 29, 30, 31); ADD( 8, 12); ADD(12, 10); ADD(10, 14); ADD(14, 9); ADD( 9, 13); ADD(13, 11); ADD(11, 15); [[out]][ 0] = val0; [[out]][16] = val1; [[out]][ 8] = val2; [[out]][24] = val3; [[out]][ 4] = val4; [[out]][20] = val5; [[out]][12] = val6; [[out]][28] = val7; [[out]][ 2] = val8; [[out]][18] = val9; [[out]][10] = val10; [[out]][26] = val11; [[out]][ 6] = val12; [[out]][22] = val13; [[out]][14] = val14; [[out]][30] = val15; ADD(24, 28); ADD(28, 26); ADD(26, 30); ADD(30, 25); ADD(25, 29); ADD(29, 27); ADD(27, 31); [[out]][ 1] = val16 + val24; [[out]][17] = val17 + val25; [[out]][ 9] = val18 + val26; [[out]][25] = val19 + val27; [[out]][ 5] = val20 + val28; [[out]][21] = val21 + val29; [[out]][13] = val22 + val30; [[out]][29] = val23 + val31; [[out]][ 3] = val24 + val20; [[out]][19] = val25 + val21; [[out]][11] = val26 + val22; [[out]][27] = val27 + val23; [[out]][ 7] = val28 + val18; [[out]][23] = val29 + val19; [[out]][15] = val30 + val17; [[out]][31] = val31; }

[[[[Adv]]]]: void dct32(INTFLOAT *[[ai]], const INTFLOAT *tab) { INTFLOAT tmp0, tmp1; INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 , val8 , val9 , val10, val11, val12, val13, val14, val15, val16, val17, val18, val19, val20, val21, val22, val23, val24, val25, val26, val27, val28, val29, val30, val31; BF0( 0, 31, COS0_0 , 1); BF0(15, 16, COS0_15, 5); BF( 0, 15, COS1_0 , 1); BF(16, 31,-COS1_0 , 1); BF0( 7, 24, COS0_7 , 1); BF0( 8, 23, COS0_8 , 1); BF( 7, 8, COS1_7 , 4); BF(23, 24,-COS1_7 , 4); BF( 0, 7, COS2_0 , 1); BF( 8, 15,-COS2_0 , 1); BF(16, 23, COS2_0 , 1); BF(24, 31,-COS2_0 , 1); BF0( 3, 28, COS0_3 , 1); BF0(12, 19, COS0_12, 2); BF( 3, 12, COS1_3 , 1); BF(19, 28,-COS1_3 , 1); BF0( 4, 27, COS0_4 , 1); BF0(11, 20, COS0_11, 2); BF( 4, 11, COS1_4 , 1); BF(20, 27,-COS1_4 , 1); BF( 3, 4, COS2_3 , 3); BF(11, 12,-COS2_3 , 3); BF(19, 20, COS2_3 , 3); BF(27, 28,-COS2_3 , 3); BF( 0, 3, COS3_0 , 1); BF( 4, 7,-COS3_0 , 1); BF( 8, 11, COS3_0 , 1); BF(12, 15,-COS3_0 , 1); BF(16, 19, COS3_0 , 1); BF(20, 23,-COS3_0 , 1); BF(24, 27, COS3_0 , 1); BF(28, 31,-COS3_0 , 1); BF0( 1, 30, COS0_1 , 1); BF0(14, 17, COS0_14, 3); BF( 1, 14, COS1_1 , 1); BF(17, 30,-COS1_1 , 1); BF0( 6, 25, COS0_6 , 1); BF0( 9, 22, COS0_9 , 1); BF( 6, 9, COS1_6 , 2); BF(22, 25,-COS1_6 , 2); BF( 1, 6, COS2_1 , 1); BF( 9, 14,-COS2_1 , 1); BF(17, 22, COS2_1 , 1); BF(25, 30,-COS2_1 , 1); BF0( 2, 29, COS0_2 , 1); BF0(13, 18, COS0_13, 3); BF( 2, 13, COS1_2 , 1); BF(18, 29,-COS1_2 , 1); BF0( 5, 26, COS0_5 , 1); BF0(10, 21, COS0_10, 1); BF( 5, 10, COS1_5 , 2); BF(21, 26,-COS1_5 , 2); BF( 2, 5, COS2_2 , 1); BF(10, 13,-COS2_2 , 1); BF(18, 21, COS2_2 , 1); BF(26, 29,-COS2_2 , 1); BF( 1, 2, COS3_1 , 2); BF( 5, 6,-COS3_1 , 2); BF( 9, 10, COS3_1 , 2); BF(13, 14,-COS3_1 , 2); BF(17, 18, COS3_1 , 2); BF(21, 22,-COS3_1 , 2); BF(25, 26, COS3_1 , 2); BF(29, 30,-COS3_1 , 2); BF1( 0, 1, 2, 3); BF2( 4, 5, 6, 7); BF1( 8, 9, 10, 11); BF2(12, 13, 14, 15); BF1(16, 17, 18, 19); BF2(20, 21, 22, 23); BF1(24, 25, 26, 27); BF2(28, 29, 30, 31); ADD( 8, 12); ADD(12, 10); ADD(10, 14); ADD(14, 9); ADD( 9, 13); ADD(13, 11); ADD(11, 15); [[ai]][ 0] = val0; [[ai]][16] = val1; [[ai]][ 8] = val2; [[ai]][24] = val3; [[ai]][ 4] = val4; [[ai]][20] = val5; [[ai]][12] = val6; [[ai]][28] = val7; [[ai]][ 2] = val8; [[ai]][18] = val9; [[ai]][10] = val10; [[ai]][26] = val11; [[ai]][ 6] = val12; [[ai]][22] = val13; [[ai]][14] = val14; [[ai]][30] = val15; ADD(24, 28); ADD(28, 26); ADD(26, 30); ADD(30, 25); ADD(25, 29); ADD(29, 27); ADD(27, 31); [[ai]][ 1] = val16 + val24; [[ai]][17] = val17 + val25; [[ai]][ 9] = val18 + val26; [[ai]][25] = val19 + val27; [[ai]][ 5] = val20 + val28; [[ai]][21] = val21 + val29; [[ai]][13] = val22 + val30; [[ai]][29] = val23 + val31; [[ai]][ 3] = val24 + val20; [[ai]][19] = val25 + val21; [[ai]][11] = val26 + val22; [[ai]][27] = val27 + val23; [[ai]][ 7] = val28 + val18; [[ai]][23] = val29 + val19; [[ai]][15] = val30 + val17; [[ai]][31] = val31; }
--------------------------------------------- Result 1022 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 542 / 115 / 365 / 1022:  38%|███▊      | 1022/2690 [2:39:47<4:20:47,  9.38s/it][Succeeded / Failed / Skipped / Total] 542 / 115 / 365 / 1022:  38%|███▊      | 1023/2690 [2:39:47<4:20:23,  9.37s/it][Succeeded / Failed / Skipped / Total] 542 / 115 / 366 / 1023:  38%|███▊      | 1023/2690 [2:39:47<4:20:23,  9.37s/it][Succeeded / Failed / Skipped / Total] 542 / 115 / 366 / 1023:  38%|███▊      | 1024/2690 [2:39:48<4:19:59,  9.36s/it][Succeeded / Failed / Skipped / Total] 542 / 115 / 367 / 1024:  38%|███▊      | 1024/2690 [2:39:48<4:19:59,  9.36s/it][Succeeded / Failed / Skipped / Total] 542 / 115 / 367 / 1024:  38%|███▊      | 1025/2690 [2:39:48<4:19:35,  9.35s/it][[0 (82%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int alloc_picture(MpegEncContext *[[s]], Picture *[[pic]], int shared){ const int big_mb_num= [[s]]->mb_stride*([[s]]->mb_height+1) + 1; const int [[mb_array_size]]= [[s]]->mb_stride*[[s]]->mb_height; const int [[b8_array_size]]= [[s]]->b8_stride*[[s]]->mb_height*2; const int b4_array_size= [[s]]->b4_stride*[[s]]->mb_height*4; int i; if(shared){ assert([[pic]]->data[0]); assert([[pic]]->type == 0 || [[pic]]->type == FF_BUFFER_TYPE_SHARED); [[pic]]->type= FF_BUFFER_TYPE_SHARED; }else{ int [[r]]; assert(![[pic]]->data[0]); [[r]]= [[s]]->avctx->get_buffer([[s]]->avctx, (AVFrame*)[[pic]]); if([[r]]<0 || ![[pic]]->age || ![[pic]]->type || ![[pic]]->data[0]){ av_log([[s]]->avctx, AV_LOG_ERROR, "get_buffer() failed (%d %d %d %p)\n", [[r]], [[pic]]->age, [[pic]]->type, [[pic]]->data[0]); return -1; } if([[s]]->linesize && ([[s]]->linesize != [[pic]]->linesize[0] || [[s]]->uvlinesize != [[pic]]->linesize[1])){ av_log([[s]]->avctx, AV_LOG_ERROR, "get_buffer() failed (stride changed)\n"); return -1; } if([[pic]]->linesize[1] != [[pic]]->linesize[2]){ av_log([[s]]->avctx, AV_LOG_ERROR, "get_buffer() failed (uv stride mismatch)\n"); return -1; } [[s]]->linesize = [[pic]]->linesize[0]; [[s]]->uvlinesize= [[pic]]->linesize[1]; } if([[pic]]->qscale_table==NULL){ if ([[s]]->encoding) { CHECKED_ALLOCZ([[pic]]->mb_var , [[mb_array_size]] * sizeof(int16_t)) CHECKED_ALLOCZ([[pic]]->mc_mb_var, [[mb_array_size]] * sizeof(int16_t)) CHECKED_ALLOCZ([[pic]]->mb_mean , [[mb_array_size]] * sizeof(int8_t)) } CHECKED_ALLOCZ([[pic]]->mbskip_table , [[mb_array_size]] * sizeof(uint8_t)+2) CHECKED_ALLOCZ([[pic]]->qscale_table , [[mb_array_size]] * sizeof(uint8_t)) CHECKED_ALLOCZ([[pic]]->mb_type_base , big_mb_num * sizeof(uint32_t)) [[pic]]->mb_type= [[pic]]->mb_type_base + [[s]]->mb_stride+1; if([[s]]->out_format == FMT_H264){ for(i=0; i<2; i++){ CHECKED_ALLOCZ([[pic]]->motion_val_base[i], 2 * (b4_array_size+4) * sizeof(int16_t)) [[pic]]->motion_val[i]= [[pic]]->motion_val_base[i]+4; CHECKED_ALLOCZ([[pic]]->ref_index[i], [[b8_array_size]] * sizeof(uint8_t)) } [[pic]]->motion_subsample_log2= 2; }else if([[s]]->out_format == FMT_H263 || [[s]]->encoding || ([[s]]->avctx->debug&FF_DEBUG_MV) || ([[s]]->avctx->debug_mv)){ for(i=0; i<2; i++){ CHECKED_ALLOCZ([[pic]]->motion_val_base[i], 2 * ([[b8_array_size]]+4) * sizeof(int16_t)) [[pic]]->motion_val[i]= [[pic]]->motion_val_base[i]+4; CHECKED_ALLOCZ([[pic]]->ref_index[i], [[b8_array_size]] * sizeof(uint8_t)) } [[pic]]->motion_subsample_log2= 3; } if([[s]]->avctx->debug&FF_DEBUG_DCT_COEFF) { CHECKED_ALLOCZ([[pic]]->dct_coeff, 64 * [[mb_array_size]] * sizeof(DCTELEM)*6) } [[pic]]->qstride= [[s]]->mb_stride; CHECKED_ALLOCZ([[pic]]->pan_scan , 1 * sizeof(AVPanScan)) } memmove([[s]]->prev_pict_types+1, [[s]]->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1); [[s]]->prev_pict_types[0]= [[s]]->pict_type; if([[pic]]->age < PREV_PICT_TYPES_BUFFER_SIZE && [[s]]->prev_pict_types[[[pic]]->age] == B_TYPE) [[pic]]->age= INT_MAX; return 0; fail: return -1; }

[[[[Adv]]]]: int alloc_picture(MpegEncContext *[[no]], Picture *[[photo]], int shared){ const int big_mb_num= [[no]]->mb_stride*([[no]]->mb_height+1) + 1; const int [[countvyexpressfactorvolume]]= [[no]]->mb_stride*[[no]]->mb_height; const int [[clonactivemountifcolour]]= [[no]]->b8_stride*[[no]]->mb_height*2; const int b4_array_size= [[no]]->b4_stride*[[no]]->mb_height*4; int i; if(shared){ assert([[photo]]->data[0]); assert([[photo]]->type == 0 || [[photo]]->type == FF_BUFFER_TYPE_SHARED); [[photo]]->type= FF_BUFFER_TYPE_SHARED; }else{ int [[e]]; assert(![[photo]]->data[0]); [[e]]= [[no]]->avctx->get_buffer([[no]]->avctx, (AVFrame*)[[photo]]); if([[e]]<0 || ![[photo]]->age || ![[photo]]->type || ![[photo]]->data[0]){ av_log([[no]]->avctx, AV_LOG_ERROR, "get_buffer() failed (%d %d %d %p)\n", [[e]], [[photo]]->age, [[photo]]->type, [[photo]]->data[0]); return -1; } if([[no]]->linesize && ([[no]]->linesize != [[photo]]->linesize[0] || [[no]]->uvlinesize != [[photo]]->linesize[1])){ av_log([[no]]->avctx, AV_LOG_ERROR, "get_buffer() failed (stride changed)\n"); return -1; } if([[photo]]->linesize[1] != [[photo]]->linesize[2]){ av_log([[no]]->avctx, AV_LOG_ERROR, "get_buffer() failed (uv stride mismatch)\n"); return -1; } [[no]]->linesize = [[photo]]->linesize[0]; [[no]]->uvlinesize= [[photo]]->linesize[1]; } if([[photo]]->qscale_table==NULL){ if ([[no]]->encoding) { CHECKED_ALLOCZ([[photo]]->mb_var , [[countvyexpressfactorvolume]] * sizeof(int16_t)) CHECKED_ALLOCZ([[photo]]->mc_mb_var, [[countvyexpressfactorvolume]] * sizeof(int16_t)) CHECKED_ALLOCZ([[photo]]->mb_mean , [[countvyexpressfactorvolume]] * sizeof(int8_t)) } CHECKED_ALLOCZ([[photo]]->mbskip_table , [[countvyexpressfactorvolume]] * sizeof(uint8_t)+2) CHECKED_ALLOCZ([[photo]]->qscale_table , [[countvyexpressfactorvolume]] * sizeof(uint8_t)) CHECKED_ALLOCZ([[photo]]->mb_type_base , big_mb_num * sizeof(uint32_t)) [[photo]]->mb_type= [[photo]]->mb_type_base + [[no]]->mb_stride+1; if([[no]]->out_format == FMT_H264){ for(i=0; i<2; i++){ CHECKED_ALLOCZ([[photo]]->motion_val_base[i], 2 * (b4_array_size+4) * sizeof(int16_t)) [[photo]]->motion_val[i]= [[photo]]->motion_val_base[i]+4; CHECKED_ALLOCZ([[photo]]->ref_index[i], [[clonactivemountifcolour]] * sizeof(uint8_t)) } [[photo]]->motion_subsample_log2= 2; }else if([[no]]->out_format == FMT_H263 || [[no]]->encoding || ([[no]]->avctx->debug&FF_DEBUG_MV) || ([[no]]->avctx->debug_mv)){ for(i=0; i<2; i++){ CHECKED_ALLOCZ([[photo]]->motion_val_base[i], 2 * ([[clonactivemountifcolour]]+4) * sizeof(int16_t)) [[photo]]->motion_val[i]= [[photo]]->motion_val_base[i]+4; CHECKED_ALLOCZ([[photo]]->ref_index[i], [[clonactivemountifcolour]] * sizeof(uint8_t)) } [[photo]]->motion_subsample_log2= 3; } if([[no]]->avctx->debug&FF_DEBUG_DCT_COEFF) { CHECKED_ALLOCZ([[photo]]->dct_coeff, 64 * [[countvyexpressfactorvolume]] * sizeof(DCTELEM)*6) } [[photo]]->qstride= [[no]]->mb_stride; CHECKED_ALLOCZ([[photo]]->pan_scan , 1 * sizeof(AVPanScan)) } memmove([[no]]->prev_pict_types+1, [[no]]->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1); [[no]]->prev_pict_types[0]= [[no]]->pict_type; if([[photo]]->age < PREV_PICT_TYPES_BUFFER_SIZE && [[no]]->prev_pict_types[[[photo]]->age] == B_TYPE) [[photo]]->age= INT_MAX; return 0; fail: return -1; }
--------------------------------------------- Result 1023 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_rdhwr(DisasContext *ctx, int rt, int rd) { TCGv t0; #if !defined(CONFIG_USER_ONLY) check_insn(ctx, ISA_MIPS32R2); #endif t0 = tcg_temp_new(); switch (rd) { case 0: save_cpu_state(ctx, 1); gen_helper_rdhwr_cpunum(t0, cpu_env); gen_store_gpr(t0, rt); break; case 1: save_cpu_state(ctx, 1); gen_helper_rdhwr_synci_step(t0, cpu_env); gen_store_gpr(t0, rt); break; case 2: save_cpu_state(ctx, 1); gen_helper_rdhwr_cc(t0, cpu_env); gen_store_gpr(t0, rt); break; case 3: save_cpu_state(ctx, 1); gen_helper_rdhwr_ccres(t0, cpu_env); gen_store_gpr(t0, rt); break; case 29: #if defined(CONFIG_USER_ONLY) tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value)); gen_store_gpr(t0, rt); break; #else #endif default: MIPS_INVAL("rdhwr"); generate_exception(ctx, EXCP_RI); break; } tcg_temp_free(t0); }
--------------------------------------------- Result 1024 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void usb_msd_realize_bot(USBDevice *dev, Error **errp) { MSDState *s = DO_UPCAST(MSDState, dev, dev); usb_desc_create_serial(dev); usb_desc_init(dev); scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev), &usb_msd_scsi_info_bot, NULL); s->bus.qbus.allow_hotplug = 0; usb_msd_handle_reset(dev); }
--------------------------------------------- Result 1025 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 542 / 115 / 368 / 1025:  38%|███▊      | 1025/2690 [2:39:48<4:19:35,  9.35s/it][Succeeded / Failed / Skipped / Total] 542 / 115 / 368 / 1025:  38%|███▊      | 1026/2690 [2:39:49<4:19:11,  9.35s/it][Succeeded / Failed / Skipped / Total] 542 / 115 / 369 / 1026:  38%|███▊      | 1026/2690 [2:39:49<4:19:11,  9.35s/it][Succeeded / Failed / Skipped / Total] 542 / 115 / 369 / 1026:  38%|███▊      | 1027/2690 [2:40:04<4:19:13,  9.35s/it][Succeeded / Failed / Skipped / Total] 542 / 116 / 369 / 1027:  38%|███▊      | 1027/2690 [2:40:04<4:19:13,  9.35s/it][Succeeded / Failed / Skipped / Total] 542 / 116 / 369 / 1027:  38%|███▊      | 1028/2690 [2:40:05<4:18:49,  9.34s/it][Succeeded / Failed / Skipped / Total] 542 / 116 / 370 / 1028:  38%|███▊      | 1028/2690 [2:40:05<4:18:49,  9.34s/it][Succeeded / Failed / Skipped / Total] 542 / 116 / 370 / 1028:  38%|███▊      | 1029/2690 [2:40:06<4:18:26,  9.34s/it][[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_slice_header(FFV1Context *f, FFV1Context *fs) { RangeCoder *c = &fs->c; uint8_t state[CONTEXT_SIZE]; unsigned ps, i, context_count; memset(state, 128, sizeof(state)); if (fs->ac > 1) { for (i = 1; i < 256; i++) { fs->c.one_state[i] = f->state_transition[i]; fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i]; } } fs->slice_x = get_symbol(c, state, 0) * f->width; fs->slice_y = get_symbol(c, state, 0) * f->height; fs->slice_width = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x; fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y; fs->slice_x /= f->num_h_slices; fs->slice_y /= f->num_v_slices; fs->slice_width = fs->slice_width / f->num_h_slices - fs->slice_x; fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y; if ((unsigned)fs->slice_width > f->width || (unsigned)fs->slice_height > f->height) return AVERROR_INVALIDDATA; if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width > f->width || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height) return AVERROR_INVALIDDATA; for (i = 0; i < f->plane_count; i++) { PlaneContext *const p = &fs->plane[i]; int idx = get_symbol(c, state, 0); if (idx > (unsigned)f->quant_table_count) { av_log(f->avctx, AV_LOG_ERROR, "quant_table_index out of range\n"); return AVERROR_INVALIDDATA; } p->quant_table_index = idx; memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table)); context_count = f->context_count[idx]; if (p->context_count < context_count) { av_freep(&p->state); av_freep(&p->vlc_state); } p->context_count = context_count; } ps = get_symbol(c, state, 0); if (ps == 1) { f->cur->interlaced_frame = 1; f->cur->top_field_first = 1; } else if (ps == 2) { f->cur->interlaced_frame = 1; f->cur->top_field_first = 0; } else if (ps == 3) { f->cur->interlaced_frame = 0; } f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0); f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0); if (av_image_check_sar(f->width, f->height, f->cur->sample_aspect_ratio) < 0) { av_log(f->avctx, AV_LOG_WARNING, "ignoring invalid SAR: %u/%u\n", f->cur->sample_aspect_ratio.num, f->cur->sample_aspect_ratio.den); f->cur->sample_aspect_ratio = (AVRational){ 0, 1 }; } return 0; }
--------------------------------------------- Result 1026 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp) { if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn, sizeof(diag_501), 0) || cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501, sizeof(diag_501), 1)) { return -EINVAL; } return 0; }
--------------------------------------------- Result 1027 ---------------------------------------------
[[0 (87%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline uint8_t *ram_chunk_start(const RDMALocalBlock *[[rdma_ram_block]], uint64_t [[i]]) { return (uint8_t *) (((uintptr_t) [[rdma_ram_block]]->local_host_addr) + ([[i]] << RDMA_REG_CHUNK_SHIFT)); }

[[[[Adv]]]]: static inline uint8_t *ram_chunk_start(const RDMALocalBlock *[[srragdwheelofmove]], uint64_t [[vi]]) { return (uint8_t *) (((uintptr_t) [[srragdwheelofmove]]->local_host_addr) + ([[vi]] << RDMA_REG_CHUNK_SHIFT)); }
--------------------------------------------- Result 1028 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_element(AVCodecContext *avctx, void *data, int ch_index, int channels) { ALACContext *alac = avctx->priv_data; int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret; uint32_t output_samples; int i, ch; skip_bits(&alac->gb, 4); skip_bits(&alac->gb, 12); has_size = get_bits1(&alac->gb); alac->extra_bits = get_bits(&alac->gb, 2) << 3; bps = alac->sample_size - alac->extra_bits + channels - 1; if (bps > 32) { av_log(avctx, AV_LOG_ERROR, "bps is unsupported: %d\n", bps); return AVERROR_PATCHWELCOME; } is_compressed = !get_bits1(&alac->gb); if (has_size) output_samples = get_bits_long(&alac->gb, 32); else output_samples = alac->max_samples_per_frame; if (!output_samples || output_samples > alac->max_samples_per_frame) { av_log(avctx, AV_LOG_ERROR, "invalid samples per frame: %d\n", output_samples); return AVERROR_INVALIDDATA; } if (!alac->nb_samples) { alac->frame.nb_samples = output_samples; if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } } else if (output_samples != alac->nb_samples) { av_log(avctx, AV_LOG_ERROR, "sample count mismatch: %u != %d\n", output_samples, alac->nb_samples); return AVERROR_INVALIDDATA; } alac->nb_samples = output_samples; if (alac->direct_output) { for (ch = 0; ch < channels; ch++) alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch]; } if (is_compressed) { int16_t lpc_coefs[2][32]; int lpc_order[2]; int prediction_type[2]; int lpc_quant[2]; int rice_history_mult[2]; decorr_shift = get_bits(&alac->gb, 8); decorr_left_weight = get_bits(&alac->gb, 8); for (ch = 0; ch < channels; ch++) { prediction_type[ch] = get_bits(&alac->gb, 4); lpc_quant[ch] = get_bits(&alac->gb, 4); rice_history_mult[ch] = get_bits(&alac->gb, 3); lpc_order[ch] = get_bits(&alac->gb, 5); for (i = lpc_order[ch] - 1; i >= 0; i--) lpc_coefs[ch][i] = get_sbits(&alac->gb, 16); } if (alac->extra_bits) { for (i = 0; i < alac->nb_samples; i++) { if(get_bits_left(&alac->gb) <= 0) return -1; for (ch = 0; ch < channels; ch++) alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits); } } for (ch = 0; ch < channels; ch++) { int ret=rice_decompress(alac, alac->predict_error_buffer[ch], alac->nb_samples, bps, rice_history_mult[ch] * alac->rice_history_mult / 4); if(ret<0) return ret; if (prediction_type[ch] == 15) { lpc_prediction(alac->predict_error_buffer[ch], alac->predict_error_buffer[ch], alac->nb_samples, bps, NULL, 31, 0); } else if (prediction_type[ch] > 0) { av_log(avctx, AV_LOG_WARNING, "unknown prediction type: %i\n", prediction_type[ch]); } lpc_prediction(alac->predict_error_buffer[ch], alac->output_samples_buffer[ch], alac->nb_samples, bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]); } } else { for (i = 0; i < alac->nb_samples; i++) { if(get_bits_left(&alac->gb) <= 0) return -1; for (ch = 0; ch < channels; ch++) { alac->output_samples_buffer[ch][i] = get_sbits_long(&alac->gb, alac->sample_size); } } alac->extra_bits = 0; decorr_shift = 0; decorr_left_weight = 0; } if (channels == 2 && decorr_left_weight) { decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples, decorr_shift, decorr_left_weight); } if (alac->extra_bits) { append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer, alac->extra_bits, channels, alac->nb_samples); } if(av_sample_fmt_is_planar(avctx->sample_fmt)) { switch(alac->sample_size) { case 16: { for (ch = 0; ch < channels; ch++) { int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch]; for (i = 0; i < alac->nb_samples; i++) *outbuffer++ = alac->output_samples_buffer[ch][i]; }} break; case 24: { for (ch = 0; ch < channels; ch++) { for (i = 0; i < alac->nb_samples; i++) alac->output_samples_buffer[ch][i] <<= 8; }} break; } }else{ switch(alac->sample_size) { case 16: { int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index; for (i = 0; i < alac->nb_samples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->output_samples_buffer[ch][i]; outbuffer += alac->channels - channels; } } break; case 24: { int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index; for (i = 0; i < alac->nb_samples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->output_samples_buffer[ch][i] << 8; outbuffer += alac->channels - channels; } } break; case 32: { int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index; for (i = 0; i < alac->nb_samples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->output_samples_buffer[ch][i]; outbuffer += alac->channels - channels; } } break; } } return 0; }
--------------------------------------------- Result 1029 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 542 / 116 / 371 / 1029:  38%|███▊      | 1029/2690 [2:40:06<4:18:26,  9.34s/it][Succeeded / Failed / Skipped / Total] 542 / 116 / 371 / 1029:  38%|███▊      | 1030/2690 [2:40:16<4:18:18,  9.34s/it][Succeeded / Failed / Skipped / Total] 543 / 116 / 371 / 1030:  38%|███▊      | 1030/2690 [2:40:16<4:18:18,  9.34s/it][Succeeded / Failed / Skipped / Total] 543 / 116 / 371 / 1030:  38%|███▊      | 1031/2690 [2:40:16<4:17:54,  9.33s/it][Succeeded / Failed / Skipped / Total] 543 / 116 / 372 / 1031:  38%|███▊      | 1031/2690 [2:40:16<4:17:54,  9.33s/it][Succeeded / Failed / Skipped / Total] 543 / 116 / 372 / 1031:  38%|███▊      | 1032/2690 [2:40:17<4:17:31,  9.32s/it][Succeeded / Failed / Skipped / Total] 543 / 116 / 373 / 1032:  38%|███▊      | 1032/2690 [2:40:17<4:17:31,  9.32s/it][Succeeded / Failed / Skipped / Total] 543 / 116 / 373 / 1032:  38%|███▊      | 1033/2690 [2:40:36<4:17:37,  9.33s/it][[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline float quantize_and_encode_band_cost_template( struct AACEncContext *s, PutBitContext *pb, const float *in, const float *scaled, int size, int scale_idx, int cb, const float lambda, const float uplim, int *bits, int BT_ZERO, int BT_UNSIGNED, int BT_PAIR, int BT_ESC) { const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; const float Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float CLIPPED_ESCAPE = 165140.0f*IQ; int i, j, k; float cost = 0; const int dim = BT_PAIR ? 2 : 4; int resbits = 0; const float Q34 = sqrtf(Q * sqrtf(Q)); const int range = aac_cb_range[cb]; const int maxval = aac_cb_maxval[cb]; int off; if (BT_ZERO) { for (i = 0; i < size; i++) cost += in[i]*in[i]; if (bits) *bits = 0; return cost * lambda; } if (!scaled) { abs_pow34_v(s->scoefs, in, size); scaled = s->scoefs; } quantize_bands(s->qcoefs, in, scaled, size, Q34, !BT_UNSIGNED, maxval); if (BT_UNSIGNED) { off = 0; } else { off = maxval; } for (i = 0; i < size; i += dim) { const float *vec; int *quants = s->qcoefs + i; int curidx = 0; int curbits; float rd = 0.0f; for (j = 0; j < dim; j++) { curidx *= range; curidx += quants[j] + off; } curbits = ff_aac_spectral_bits[cb-1][curidx]; vec = &ff_aac_codebook_vectors[cb-1][curidx*dim]; if (BT_UNSIGNED) { for (k = 0; k < dim; k++) { float t = fabsf(in[i+k]); float di; if (BT_ESC && vec[k] == 64.0f) { if (t >= CLIPPED_ESCAPE) { di = t - CLIPPED_ESCAPE; curbits += 21; } else { int c = av_clip(quant(t, Q), 0, 8191); di = t - c*cbrtf(c)*IQ; curbits += av_log2(c)*2 - 4 + 1; } } else { di = t - vec[k]*IQ; } if (vec[k] != 0.0f) curbits++; rd += di*di; } } else { for (k = 0; k < dim; k++) { float di = in[i+k] - vec[k]*IQ; rd += di*di; } } cost += rd * lambda + curbits; resbits += curbits; if (cost >= uplim) return uplim; if (pb) { put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]); if (BT_UNSIGNED) for (j = 0; j < dim; j++) if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f) put_bits(pb, 1, in[i+j] < 0.0f); if (BT_ESC) { for (j = 0; j < 2; j++) { if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) { int coef = av_clip(quant(fabsf(in[i+j]), Q), 0, 8191); int len = av_log2(coef); put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2); put_bits(pb, len, coef & ((1 << len) - 1)); } } } } } if (bits) *bits = resbits; return cost; }
--------------------------------------------- Result 1030 ---------------------------------------------
[[0 (85%)]] --> [[0 (15%)]] --> Socre: 0.8487225025892258

[[[[Adv]]]]: static void vc1_v_overlap_c(uint8_t* [[src]], int [[stride]]) { int i; int a, b, c, d; int d1, d2; int rnd = 1; for(i = 0; i < 8; i++) { a = [[src]][-2*[[stride]]]; b = [[src]][-[[stride]]]; c = [[src]][0]; d = [[src]][[[stride]]]; d1 = (a - d + 3 + rnd) >> 3; d2 = (a - d + b - c + 4 - rnd) >> 3; [[src]][-2*[[stride]]] = a - d1; [[src]][-[[stride]]] = b - d2; [[src]][0] = c + d2; [[src]][[[stride]]] = d + d1; [[src]]++; rnd = !rnd; } }

[[[[Adv]]]]: static void vc1_v_overlap_c(uint8_t* [[prcs]], int [[park]]) { int i; int a, b, c, d; int d1, d2; int rnd = 1; for(i = 0; i < 8; i++) { a = [[prcs]][-2*[[park]]]; b = [[prcs]][-[[park]]]; c = [[prcs]][0]; d = [[prcs]][[[park]]]; d1 = (a - d + 3 + rnd) >> 3; d2 = (a - d + b - c + 4 - rnd) >> 3; [[prcs]][-2*[[park]]] = a - d1; [[prcs]][-[[park]]] = b - d2; [[prcs]][0] = c + d2; [[prcs]][[[park]]] = d + d1; [[prcs]]++; rnd = !rnd; } }
--------------------------------------------- Result 1031 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sox_read_packet(AVFormatContext *s, AVPacket *pkt) { int ret, size; if (url_feof(s->pb)) return AVERROR_EOF; size = SOX_SAMPLES*s->streams[0]->codec->block_align; ret = av_get_packet(s->pb, pkt, size); if (ret < 0) return AVERROR(EIO); pkt->stream_index = 0; pkt->size = ret; return 0; }
--------------------------------------------- Result 1032 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int svq1_encode_init(AVCodecContext *avctx) { SVQ1Context * const s = avctx->priv_data; dsputil_init(&s->dsp, avctx); avctx->coded_frame= (AVFrame*)&s->picture; s->frame_width = avctx->width; s->frame_height = avctx->height; s->y_block_width = (s->frame_width + 15) / 16; s->y_block_height = (s->frame_height + 15) / 16; s->c_block_width = (s->frame_width / 4 + 15) / 16; s->c_block_height = (s->frame_height / 4 + 15) / 16; s->avctx= avctx; s->m.avctx= avctx; s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t)); s->m.me.map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t)); s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t)); s->mb_type = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t)); s->dummy = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t)); h263_encode_init(&s->m); return 0; }
--------------------------------------------- Result 1033 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 544 / 116 / 373 / 1033:  38%|███▊      | 1033/2690 [2:40:36<4:17:37,  9.33s/it][Succeeded / Failed / Skipped / Total] 544 / 116 / 373 / 1033:  38%|███▊      | 1034/2690 [2:40:38<4:17:16,  9.32s/it][[0 (42%)]] --> [[0 (94%)]] --> Socre: 0.9372520446777344

[[[[Adv]]]]: static void event_loop(VideoState *cur_stream) { SDL_Event event; double [[incr]], pos, frac; for(;;) { double x; SDL_WaitEvent(&event); switch(event.type) { case SDL_KEYDOWN: if (exit_on_keydown) { do_exit(cur_stream); break; } switch(event.key.keysym.sym) { case SDLK_ESCAPE: case SDLK_q: do_exit(cur_stream); break; case SDLK_f: toggle_full_screen(cur_stream); break; case SDLK_p: case SDLK_SPACE: if (cur_stream) toggle_pause(cur_stream); break; case SDLK_s: if (cur_stream) step_to_next_frame(cur_stream); break; case SDLK_a: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO); break; case SDLK_v: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO); break; case SDLK_t: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE); break; case SDLK_w: if (cur_stream) toggle_audio_display(cur_stream); break; case SDLK_LEFT: [[incr]] = -10.0; goto do_seek; case SDLK_RIGHT: [[incr]] = 10.0; goto do_seek; case SDLK_UP: [[incr]] = 60.0; goto do_seek; case SDLK_DOWN: [[incr]] = -60.0; do_seek: if (cur_stream) { if (seek_by_bytes) { if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){ pos= cur_stream->video_current_pos; }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){ pos= cur_stream->audio_pkt.pos; }else pos = avio_tell(cur_stream->ic->pb); if (cur_stream->ic->bit_rate) [[incr]] *= cur_stream->ic->bit_rate / 8.0; else [[incr]] *= 180000.0; pos += [[incr]]; stream_seek(cur_stream, pos, [[incr]], 1); } else { pos = get_master_clock(cur_stream); pos += [[incr]]; stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)([[incr]] * AV_TIME_BASE), 0); } } break; default: break; } break; case SDL_MOUSEBUTTONDOWN: if (exit_on_mousedown) { do_exit(cur_stream); break; } case SDL_MOUSEMOTION: if(event.type ==SDL_MOUSEBUTTONDOWN){ x= event.button.x; }else{ if(event.motion.state != SDL_PRESSED) break; x= event.motion.x; } if (cur_stream) { if(seek_by_bytes || cur_stream->ic->duration<=0){ uint64_t size= avio_size(cur_stream->ic->pb); stream_seek(cur_stream, size*x/cur_stream->width, 0, 1); }else{ int64_t ts; int ns, hh, mm, ss; int tns, thh, tmm, tss; tns = cur_stream->ic->duration/1000000LL; thh = tns/3600; tmm = (tns%3600)/60; tss = (tns%60); frac = x/cur_stream->width; ns = frac*tns; hh = ns/3600; mm = (ns%3600)/60; ss = (ns%60); fprintf(stderr, "Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d) \n", frac*100, hh, mm, ss, thh, tmm, tss); ts = frac*cur_stream->ic->duration; if (cur_stream->ic->start_time != AV_NOPTS_VALUE) ts += cur_stream->ic->start_time; stream_seek(cur_stream, ts, 0, 0); } } break; case SDL_VIDEORESIZE: if (cur_stream) { screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0, SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL); screen_width = cur_stream->width = event.resize.w; screen_height= cur_stream->height= event.resize.h; } break; case SDL_QUIT: case FF_QUIT_EVENT: do_exit(cur_stream); break; case FF_ALLOC_EVENT: video_open(event.user.data1); alloc_picture(event.user.data1); break; case FF_REFRESH_EVENT: video_refresh(event.user.data1); cur_stream->refresh=0; break; default: break; } } }

[[[[Adv]]]]: static void event_loop(VideoState *cur_stream) { SDL_Event event; double [[llcrp]], pos, frac; for(;;) { double x; SDL_WaitEvent(&event); switch(event.type) { case SDL_KEYDOWN: if (exit_on_keydown) { do_exit(cur_stream); break; } switch(event.key.keysym.sym) { case SDLK_ESCAPE: case SDLK_q: do_exit(cur_stream); break; case SDLK_f: toggle_full_screen(cur_stream); break; case SDLK_p: case SDLK_SPACE: if (cur_stream) toggle_pause(cur_stream); break; case SDLK_s: if (cur_stream) step_to_next_frame(cur_stream); break; case SDLK_a: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO); break; case SDLK_v: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO); break; case SDLK_t: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE); break; case SDLK_w: if (cur_stream) toggle_audio_display(cur_stream); break; case SDLK_LEFT: [[llcrp]] = -10.0; goto do_seek; case SDLK_RIGHT: [[llcrp]] = 10.0; goto do_seek; case SDLK_UP: [[llcrp]] = 60.0; goto do_seek; case SDLK_DOWN: [[llcrp]] = -60.0; do_seek: if (cur_stream) { if (seek_by_bytes) { if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){ pos= cur_stream->video_current_pos; }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){ pos= cur_stream->audio_pkt.pos; }else pos = avio_tell(cur_stream->ic->pb); if (cur_stream->ic->bit_rate) [[llcrp]] *= cur_stream->ic->bit_rate / 8.0; else [[llcrp]] *= 180000.0; pos += [[llcrp]]; stream_seek(cur_stream, pos, [[llcrp]], 1); } else { pos = get_master_clock(cur_stream); pos += [[llcrp]]; stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)([[llcrp]] * AV_TIME_BASE), 0); } } break; default: break; } break; case SDL_MOUSEBUTTONDOWN: if (exit_on_mousedown) { do_exit(cur_stream); break; } case SDL_MOUSEMOTION: if(event.type ==SDL_MOUSEBUTTONDOWN){ x= event.button.x; }else{ if(event.motion.state != SDL_PRESSED) break; x= event.motion.x; } if (cur_stream) { if(seek_by_bytes || cur_stream->ic->duration<=0){ uint64_t size= avio_size(cur_stream->ic->pb); stream_seek(cur_stream, size*x/cur_stream->width, 0, 1); }else{ int64_t ts; int ns, hh, mm, ss; int tns, thh, tmm, tss; tns = cur_stream->ic->duration/1000000LL; thh = tns/3600; tmm = (tns%3600)/60; tss = (tns%60); frac = x/cur_stream->width; ns = frac*tns; hh = ns/3600; mm = (ns%3600)/60; ss = (ns%60); fprintf(stderr, "Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d) \n", frac*100, hh, mm, ss, thh, tmm, tss); ts = frac*cur_stream->ic->duration; if (cur_stream->ic->start_time != AV_NOPTS_VALUE) ts += cur_stream->ic->start_time; stream_seek(cur_stream, ts, 0, 0); } } break; case SDL_VIDEORESIZE: if (cur_stream) { screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0, SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL); screen_width = cur_stream->width = event.resize.w; screen_height= cur_stream->height= event.resize.h; } break; case SDL_QUIT: case FF_QUIT_EVENT: do_exit(cur_stream); break; case FF_ALLOC_EVENT: video_open(event.user.data1); alloc_picture(event.user.data1); break; case FF_REFRESH_EVENT: video_refresh(event.user.data1); cur_stream->refresh=0; break; default: break; } } }
--------------------------------------------- Result 1034 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 545 / 116 / 373 / 1034:  38%|███▊      | 1034/2690 [2:40:38<4:17:16,  9.32s/it][Succeeded / Failed / Skipped / Total] 545 / 116 / 373 / 1034:  38%|███▊      | 1035/2690 [2:40:58<4:17:23,  9.33s/it][Succeeded / Failed / Skipped / Total] 546 / 116 / 373 / 1035:  38%|███▊      | 1035/2690 [2:40:58<4:17:23,  9.33s/it][Succeeded / Failed / Skipped / Total] 546 / 116 / 373 / 1035:  39%|███▊      | 1036/2690 [2:40:58<4:17:00,  9.32s/it][Succeeded / Failed / Skipped / Total] 546 / 116 / 374 / 1036:  39%|███▊      | 1036/2690 [2:40:58<4:17:00,  9.32s/it][Succeeded / Failed / Skipped / Total] 546 / 116 / 374 / 1036:  39%|███▊      | 1037/2690 [2:41:06<4:16:48,  9.32s/it][[0 (85%)]] --> [[0 (46%)]] --> Socre: 0.5446284413337708

[[[[Adv]]]]: void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d, QGuestAllocator *[[alloc]], uint16_t entry) { uint16_t [[vector]]; uint32_t control; void *[[addr]]; g_assert(d->pdev->msix_enabled); [[addr]] = d->pdev->msix_table + (entry * 16); g_assert_cmpint(entry, >=, 0); g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev)); d->config_msix_entry = entry; d->config_msix_data = 0x12345678; d->config_msix_addr = guest_alloc([[alloc]], 4); qpci_io_writel(d->pdev, [[addr]] + PCI_MSIX_ENTRY_LOWER_ADDR, d->config_msix_addr & ~0UL); qpci_io_writel(d->pdev, [[addr]] + PCI_MSIX_ENTRY_UPPER_ADDR, (d->config_msix_addr >> 32) & ~0UL); qpci_io_writel(d->pdev, [[addr]] + PCI_MSIX_ENTRY_DATA, d->config_msix_data); control = qpci_io_readl(d->pdev, [[addr]] + PCI_MSIX_ENTRY_VECTOR_CTRL); qpci_io_writel(d->pdev, [[addr]] + PCI_MSIX_ENTRY_VECTOR_CTRL, control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT); qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry); [[vector]] = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR); g_assert_cmphex([[vector]], !=, VIRTIO_MSI_NO_VECTOR); }

[[[[Adv]]]]: void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d, QGuestAllocator *[[armget]], uint16_t entry) { uint16_t [[disk]]; uint32_t control; void *[[contributeer]]; g_assert(d->pdev->msix_enabled); [[contributeer]] = d->pdev->msix_table + (entry * 16); g_assert_cmpint(entry, >=, 0); g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev)); d->config_msix_entry = entry; d->config_msix_data = 0x12345678; d->config_msix_addr = guest_alloc([[armget]], 4); qpci_io_writel(d->pdev, [[contributeer]] + PCI_MSIX_ENTRY_LOWER_ADDR, d->config_msix_addr & ~0UL); qpci_io_writel(d->pdev, [[contributeer]] + PCI_MSIX_ENTRY_UPPER_ADDR, (d->config_msix_addr >> 32) & ~0UL); qpci_io_writel(d->pdev, [[contributeer]] + PCI_MSIX_ENTRY_DATA, d->config_msix_data); control = qpci_io_readl(d->pdev, [[contributeer]] + PCI_MSIX_ENTRY_VECTOR_CTRL); qpci_io_writel(d->pdev, [[contributeer]] + PCI_MSIX_ENTRY_VECTOR_CTRL, control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT); qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry); [[disk]] = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR); g_assert_cmphex([[disk]], !=, VIRTIO_MSI_NO_VECTOR); }
--------------------------------------------- Result 1035 ---------------------------------------------
[[0 (96%)]] --> [[0 (45%)]] --> Socre: 0.5546429753303528

[[[[Adv]]]]: static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset) { AHCICmdHdr *cmd = ad->cur_cmd; uint32_t opts = le32_to_cpu(cmd->opts); uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80; int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN; dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG)); dma_addr_t [[real_prdt_len]] = prdt_len; uint8_t *prdt; int i; int r = 0; int sum = 0; int off_idx = -1; int off_pos = -1; int tbl_entry_size; IDEBus *bus = &ad->port; BusState *[[qbus]] = BUS(bus); if (!sglist_alloc_hint) { DPRINTF(ad->port_no, "no sg list given by guest: 0x%08x\n", opts); return -1; } if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len, DMA_DIRECTION_TO_DEVICE))){ DPRINTF(ad->port_no, "map failed\n"); return -1; } if (prdt_len < [[real_prdt_len]]) { DPRINTF(ad->port_no, "mapped less than expected\n"); r = -1; goto out; } if (sglist_alloc_hint > 0) { AHCI_SG *tbl = (AHCI_SG *)prdt; sum = 0; for (i = 0; i < sglist_alloc_hint; i++) { tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1); if (offset <= (sum + tbl_entry_size)) { off_idx = i; off_pos = offset - sum; break; } sum += tbl_entry_size; } if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) { DPRINTF(ad->port_no, "%s: Incorrect offset! " "off_idx: %d, off_pos: %d\n", __func__, off_idx, off_pos); r = -1; goto out; } qemu_sglist_init(sglist, [[qbus]]->parent, (sglist_alloc_hint - off_idx), ad->hba->as); qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos), le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos); for (i = off_idx + 1; i < sglist_alloc_hint; i++) { qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr), le32_to_cpu(tbl[i].flags_size) + 1); } } out: dma_memory_unmap(ad->hba->as, prdt, prdt_len, DMA_DIRECTION_TO_DEVICE, prdt_len); return r; }

[[[[Adv]]]]: static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset) { AHCICmdHdr *cmd = ad->cur_cmd; uint32_t opts = le32_to_cpu(cmd->opts); uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80; int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN; dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG)); dma_addr_t [[wholeousbrrnes]] = prdt_len; uint8_t *prdt; int i; int r = 0; int sum = 0; int off_idx = -1; int off_pos = -1; int tbl_entry_size; IDEBus *bus = &ad->port; BusState *[[fres]] = BUS(bus); if (!sglist_alloc_hint) { DPRINTF(ad->port_no, "no sg list given by guest: 0x%08x\n", opts); return -1; } if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len, DMA_DIRECTION_TO_DEVICE))){ DPRINTF(ad->port_no, "map failed\n"); return -1; } if (prdt_len < [[wholeousbrrnes]]) { DPRINTF(ad->port_no, "mapped less than expected\n"); r = -1; goto out; } if (sglist_alloc_hint > 0) { AHCI_SG *tbl = (AHCI_SG *)prdt; sum = 0; for (i = 0; i < sglist_alloc_hint; i++) { tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1); if (offset <= (sum + tbl_entry_size)) { off_idx = i; off_pos = offset - sum; break; } sum += tbl_entry_size; } if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) { DPRINTF(ad->port_no, "%s: Incorrect offset! " "off_idx: %d, off_pos: %d\n", __func__, off_idx, off_pos); r = -1; goto out; } qemu_sglist_init(sglist, [[fres]]->parent, (sglist_alloc_hint - off_idx), ad->hba->as); qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos), le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos); for (i = off_idx + 1; i < sglist_alloc_hint; i++) { qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr), le32_to_cpu(tbl[i].flags_size) + 1); } } out: dma_memory_unmap(ad->hba->as, prdt, prdt_len, DMA_DIRECTION_TO_DEVICE, prdt_len); return r; }
--------------------------------------------- Result 1036 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void csrhci_reset(struct csrhci_s *s) { s->out_len = 0; s->out_size = FIFO_LEN; s->in_len = 0; s->baud_delay = NANOSECONDS_PER_SECOND; s->enable = 0; s->in_hdr = INT_MAX; s->in_data = INT_MAX; s->modem_state = 0; s->modem_state |= CHR_TIOCM_CTS; memset(&s->bd_addr, 0, sizeof(bdaddr_t)); }
--------------------------------------------- Result 1037 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 547 / 116 / 374 / 1037:  39%|███▊      | 1037/2690 [2:41:06<4:16:48,  9.32s/it][Succeeded / Failed / Skipped / Total] 547 / 116 / 374 / 1037:  39%|███▊      | 1038/2690 [2:41:06<4:16:25,  9.31s/it][Succeeded / Failed / Skipped / Total] 547 / 116 / 375 / 1038:  39%|███▊      | 1038/2690 [2:41:06<4:16:25,  9.31s/it][Succeeded / Failed / Skipped / Total] 547 / 116 / 375 / 1038:  39%|███▊      | 1039/2690 [2:41:07<4:16:01,  9.30s/it][[0 (55%)]] --> [[0 (49%)]] --> Socre: 0.5118135213851929

[[[[Adv]]]]: static av_always_inline void mpeg_motion_lowres(MpegEncContext *[[s]], uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, int field_based, int bottom_field, int field_select, uint8_t **ref_picture, h264_chroma_mc_func *pix_op, int motion_x, int motion_y, int h, int mb_y) { uint8_t *ptr_y, *ptr_cb, *ptr_cr; int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy, uvsx, uvsy; const int lowres = [[s]]->avctx->lowres; const int op_index = FFMIN(lowres, 2); const int block_s = 8>>lowres; const int s_mask = (2 << lowres) - 1; const int h_edge_pos = [[s]]->h_edge_pos >> lowres; const int v_edge_pos = [[s]]->v_edge_pos >> lowres; linesize = [[s]]->current_picture.f.linesize[0] << field_based; uvlinesize = [[s]]->current_picture.f.linesize[1] << field_based; if ([[s]]->quarter_sample) { motion_x /= 2; motion_y /= 2; } if (field_based) { motion_y += (bottom_field - field_select) * (1 << lowres - 1); } sx = motion_x & s_mask; sy = motion_y & s_mask; src_x = [[s]]->mb_x * 2 * block_s + (motion_x >> lowres + 1); src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1); if ([[s]]->out_format == FMT_H263) { uvsx = ((motion_x >> 1) & s_mask) | (sx & 1); uvsy = ((motion_y >> 1) & s_mask) | (sy & 1); uvsrc_x = src_x >> 1; uvsrc_y = src_y >> 1; } else if ([[s]]->out_format == FMT_H261) { mx = motion_x / 4; my = motion_y / 4; uvsx = (2 * mx) & s_mask; uvsy = (2 * my) & s_mask; uvsrc_x = [[s]]->mb_x * block_s + (mx >> lowres); uvsrc_y = mb_y * block_s + (my >> lowres); } else { mx = motion_x / 2; my = motion_y / 2; uvsx = mx & s_mask; uvsy = my & s_mask; uvsrc_x = [[s]]->mb_x * block_s + (mx >> lowres + 1); uvsrc_y = (mb_y * block_s >> field_based) + (my >> lowres + 1); } ptr_y = ref_picture[0] + src_y * linesize + src_x; ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x; ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x; if ((unsigned) src_x > h_edge_pos - (!!sx) - 2 * block_s || (unsigned) src_y > (v_edge_pos >> field_based) - (!!sy) - h) { [[s]]->dsp.emulated_edge_mc([[s]]->edge_emu_buffer, ptr_y, [[s]]->linesize, 17, 17 + field_based, src_x, src_y << field_based, h_edge_pos, v_edge_pos); ptr_y = [[s]]->edge_emu_buffer; if (!CONFIG_GRAY || !([[s]]->flags & CODEC_FLAG_GRAY)) { uint8_t *uvbuf = [[s]]->edge_emu_buffer + 18 * [[s]]->linesize; [[s]]->dsp.emulated_edge_mc(uvbuf , ptr_cb, [[s]]->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, h_edge_pos >> 1, v_edge_pos >> 1); [[s]]->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, [[s]]->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, h_edge_pos >> 1, v_edge_pos >> 1); ptr_cb = uvbuf; ptr_cr = uvbuf + 16; } } if (bottom_field) { dest_y += [[s]]->linesize; dest_cb += [[s]]->uvlinesize; dest_cr += [[s]]->uvlinesize; } if (field_select) { ptr_y += [[s]]->linesize; ptr_cb += [[s]]->uvlinesize; ptr_cr += [[s]]->uvlinesize; } sx = (sx << 2) >> lowres; sy = (sy << 2) >> lowres; pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy); if (!CONFIG_GRAY || !([[s]]->flags & CODEC_FLAG_GRAY)) { uvsx = (uvsx << 2) >> lowres; uvsy = (uvsy << 2) >> lowres; pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> [[s]]->chroma_y_shift, uvsx, uvsy); pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> [[s]]->chroma_y_shift, uvsx, uvsy); } }

[[[[Adv]]]]: static av_always_inline void mpeg_motion_lowres(MpegEncContext *[[sic]], uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, int field_based, int bottom_field, int field_select, uint8_t **ref_picture, h264_chroma_mc_func *pix_op, int motion_x, int motion_y, int h, int mb_y) { uint8_t *ptr_y, *ptr_cb, *ptr_cr; int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy, uvsx, uvsy; const int lowres = [[sic]]->avctx->lowres; const int op_index = FFMIN(lowres, 2); const int block_s = 8>>lowres; const int s_mask = (2 << lowres) - 1; const int h_edge_pos = [[sic]]->h_edge_pos >> lowres; const int v_edge_pos = [[sic]]->v_edge_pos >> lowres; linesize = [[sic]]->current_picture.f.linesize[0] << field_based; uvlinesize = [[sic]]->current_picture.f.linesize[1] << field_based; if ([[sic]]->quarter_sample) { motion_x /= 2; motion_y /= 2; } if (field_based) { motion_y += (bottom_field - field_select) * (1 << lowres - 1); } sx = motion_x & s_mask; sy = motion_y & s_mask; src_x = [[sic]]->mb_x * 2 * block_s + (motion_x >> lowres + 1); src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1); if ([[sic]]->out_format == FMT_H263) { uvsx = ((motion_x >> 1) & s_mask) | (sx & 1); uvsy = ((motion_y >> 1) & s_mask) | (sy & 1); uvsrc_x = src_x >> 1; uvsrc_y = src_y >> 1; } else if ([[sic]]->out_format == FMT_H261) { mx = motion_x / 4; my = motion_y / 4; uvsx = (2 * mx) & s_mask; uvsy = (2 * my) & s_mask; uvsrc_x = [[sic]]->mb_x * block_s + (mx >> lowres); uvsrc_y = mb_y * block_s + (my >> lowres); } else { mx = motion_x / 2; my = motion_y / 2; uvsx = mx & s_mask; uvsy = my & s_mask; uvsrc_x = [[sic]]->mb_x * block_s + (mx >> lowres + 1); uvsrc_y = (mb_y * block_s >> field_based) + (my >> lowres + 1); } ptr_y = ref_picture[0] + src_y * linesize + src_x; ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x; ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x; if ((unsigned) src_x > h_edge_pos - (!!sx) - 2 * block_s || (unsigned) src_y > (v_edge_pos >> field_based) - (!!sy) - h) { [[sic]]->dsp.emulated_edge_mc([[sic]]->edge_emu_buffer, ptr_y, [[sic]]->linesize, 17, 17 + field_based, src_x, src_y << field_based, h_edge_pos, v_edge_pos); ptr_y = [[sic]]->edge_emu_buffer; if (!CONFIG_GRAY || !([[sic]]->flags & CODEC_FLAG_GRAY)) { uint8_t *uvbuf = [[sic]]->edge_emu_buffer + 18 * [[sic]]->linesize; [[sic]]->dsp.emulated_edge_mc(uvbuf , ptr_cb, [[sic]]->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, h_edge_pos >> 1, v_edge_pos >> 1); [[sic]]->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, [[sic]]->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, h_edge_pos >> 1, v_edge_pos >> 1); ptr_cb = uvbuf; ptr_cr = uvbuf + 16; } } if (bottom_field) { dest_y += [[sic]]->linesize; dest_cb += [[sic]]->uvlinesize; dest_cr += [[sic]]->uvlinesize; } if (field_select) { ptr_y += [[sic]]->linesize; ptr_cb += [[sic]]->uvlinesize; ptr_cr += [[sic]]->uvlinesize; } sx = (sx << 2) >> lowres; sy = (sy << 2) >> lowres; pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy); if (!CONFIG_GRAY || !([[sic]]->flags & CODEC_FLAG_GRAY)) { uvsx = (uvsx << 2) >> lowres; uvsy = (uvsy << 2) >> lowres; pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> [[sic]]->chroma_y_shift, uvsx, uvsy); pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> [[sic]]->chroma_y_shift, uvsx, uvsy); } }
--------------------------------------------- Result 1038 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int net_init_vhost_user(const Netdev *netdev, const char *name, NetClientState *peer, Error **errp) { int queues; const NetdevVhostUserOptions *vhost_user_opts; CharDriverState *chr; assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER); vhost_user_opts = &netdev->u.vhost_user; chr = net_vhost_parse_chardev(vhost_user_opts, errp); if (!chr) { return -1; } if (qemu_opts_foreach(qemu_find_opts("device"), net_vhost_check_net, (char *)name, errp)) { return -1; } queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1; if (queues < 1 || queues > MAX_QUEUE_NUM) { error_setg(errp, "vhost-user number of queues must be in range [1, %d]", MAX_QUEUE_NUM); return -1; } return net_vhost_user_init(peer, "vhost_user", name, chr, queues); }
--------------------------------------------- Result 1039 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 547 / 116 / 376 / 1039:  39%|███▊      | 1039/2690 [2:41:07<4:16:01,  9.30s/it][Succeeded / Failed / Skipped / Total] 547 / 116 / 376 / 1039:  39%|███▊      | 1040/2690 [2:41:07<4:15:38,  9.30s/it][Succeeded / Failed / Skipped / Total] 547 / 116 / 377 / 1040:  39%|███▊      | 1040/2690 [2:41:07<4:15:38,  9.30s/it][Succeeded / Failed / Skipped / Total] 547 / 116 / 377 / 1040:  39%|███▊      | 1041/2690 [2:41:33<4:15:55,  9.31s/it][Succeeded / Failed / Skipped / Total] 548 / 116 / 377 / 1041:  39%|███▊      | 1041/2690 [2:41:33<4:15:55,  9.31s/it][Succeeded / Failed / Skipped / Total] 548 / 116 / 377 / 1041:  39%|███▊      | 1042/2690 [2:41:49<4:15:55,  9.32s/it][Succeeded / Failed / Skipped / Total] 549 / 116 / 377 / 1042:  39%|███▊      | 1042/2690 [2:41:49<4:15:55,  9.32s/it][Succeeded / Failed / Skipped / Total] 549 / 116 / 377 / 1042:  39%|███▉      | 1043/2690 [2:41:49<4:15:32,  9.31s/it][Succeeded / Failed / Skipped / Total] 549 / 116 / 378 / 1043:  39%|███▉      | 1043/2690 [2:41:49<4:15:32,  9.31s/it][Succeeded / Failed / Skipped / Total] 549 / 116 / 378 / 1043:  39%|███▉      | 1044/2690 [2:42:03<4:15:30,  9.31s/it][[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int lag_decode_prob(GetBitContext *gb, uint32_t *value) { static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 }; int i; int bit = 0; int bits = 0; int prevbit = 0; unsigned val; for (i = 0; i < 7; i++) { if (prevbit && bit) break; prevbit = bit; bit = get_bits1(gb); if (bit && !prevbit) bits += series[i]; } bits--; if (bits < 0 || bits > 31) { *value = 0; return -1; } else if (bits == 0) { *value = 0; return 0; } val = get_bits_long(gb, bits); val |= 1 << bits; *value = val - 1; return 0; }
--------------------------------------------- Result 1040 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void check_add_res(HEVCDSPContext h, int bit_depth) { int i; LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]); LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]); LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]); LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]); for (i = 2; i <= 5; i++) { int block_size = 1 << i; int size = block_size * block_size; ptrdiff_t stride = block_size << (bit_depth > 8); declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride); randomize_buffers(res0, size); randomize_buffers2(dst0, size); memcpy(res1, res0, sizeof(*res0) * size); memcpy(dst1, dst0, size); if (check_func(h.add_residual[i - 2], "add_res_%dx%d_%d", block_size, block_size, bit_depth)) { call_ref(dst0, res0, stride); call_new(dst1, res1, stride); if (memcmp(dst0, dst1, size)) fail(); bench_new(dst1, res1, stride); } } }
--------------------------------------------- Result 1041 ---------------------------------------------
[[0 (96%)]] --> [[0 (35%)]] --> Socre: 0.6500091254711151

[[[[Adv]]]]: void rgb15tobgr15(const uint8_t *src, uint8_t *[[dst]], unsigned int [[src_size]]) { unsigned i; unsigned num_pixels = [[src_size]] >> 1; for(i=0; i<num_pixels; i++) { unsigned b,g,r; register uint16_t rgb; rgb = src[2*i]; r = rgb&0x1F; g = (rgb&0x3E0)>>5; b = (rgb&0x7C00)>>10; [[dst]][2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10); } }

[[[[Adv]]]]: void rgb15tobgr15(const uint8_t *src, uint8_t *[[dua]], unsigned int [[rscanfactorlarger]]) { unsigned i; unsigned num_pixels = [[rscanfactorlarger]] >> 1; for(i=0; i<num_pixels; i++) { unsigned b,g,r; register uint16_t rgb; rgb = src[2*i]; r = rgb&0x1F; g = (rgb&0x3E0)>>5; b = (rgb&0x7C00)>>10; [[dua]][2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10); } }
--------------------------------------------- Result 1042 ---------------------------------------------
[[0 (18%)]] --> [[0 (95%)]] --> Socre: 0.9470797181129456

[[[[Adv]]]]: static void test_validate_fail_union_flat(TestInputVisitorData *data, const void *[[unused]]) { UserDefFlatUnion *tmp = NULL; Error *errp = NULL; Visitor *[[v]]; [[v]] = validate_test_init(data, "{ 'string': 'c', 'integer': 41, 'boolean': true }"); visit_type_UserDefFlatUnion([[v]], &tmp, NULL, &errp); g_assert(error_is_set(&errp)); qapi_free_UserDefFlatUnion(tmp); }

[[[[Adv]]]]: static void test_validate_fail_union_flat(TestInputVisitorData *data, const void *[[r]]) { UserDefFlatUnion *tmp = NULL; Error *errp = NULL; Visitor *[[в]]; [[в]] = validate_test_init(data, "{ 'string': 'c', 'integer': 41, 'boolean': true }"); visit_type_UserDefFlatUnion([[в]], &tmp, NULL, &errp); g_assert(error_is_set(&errp)); qapi_free_UserDefFlatUnion(tmp); }
--------------------------------------------- Result 1043 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int drive_init(struct drive_opt *arg, int snapshot, void *opaque) { char buf[128]; char file[1024]; char devname[128]; char serial[21]; const char *mediastr = ""; BlockInterfaceType type; enum { MEDIA_DISK, MEDIA_CDROM } media; int bus_id, unit_id; int cyls, heads, secs, translation; BlockDriverState *bdrv; BlockDriver *drv = NULL; QEMUMachine *machine = opaque; int max_devs; int index; int cache; int bdrv_flags, onerror; int drives_table_idx; char *str = arg->opt; static const char * const params[] = { "bus", "unit", "if", "index", "cyls", "heads", "secs", "trans", "media", "snapshot", "file", "cache", "format", "serial", "werror", NULL }; if (check_params(buf, sizeof(buf), params, str) < 0) { fprintf(stderr, "qemu: unknown parameter '%s' in '%s'\n", buf, str); return -1; } file[0] = 0; cyls = heads = secs = 0; bus_id = 0; unit_id = -1; translation = BIOS_ATA_TRANSLATION_AUTO; index = -1; cache = 3; if (machine->use_scsi) { type = IF_SCSI; max_devs = MAX_SCSI_DEVS; pstrcpy(devname, sizeof(devname), "scsi"); } else { type = IF_IDE; max_devs = MAX_IDE_DEVS; pstrcpy(devname, sizeof(devname), "ide"); } media = MEDIA_DISK; if (get_param_value(buf, sizeof(buf), "bus", str)) { bus_id = strtol(buf, NULL, 0); if (bus_id < 0) { fprintf(stderr, "qemu: '%s' invalid bus id\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "unit", str)) { unit_id = strtol(buf, NULL, 0); if (unit_id < 0) { fprintf(stderr, "qemu: '%s' invalid unit id\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "if", str)) { pstrcpy(devname, sizeof(devname), buf); if (!strcmp(buf, "ide")) { type = IF_IDE; max_devs = MAX_IDE_DEVS; } else if (!strcmp(buf, "scsi")) { type = IF_SCSI; max_devs = MAX_SCSI_DEVS; } else if (!strcmp(buf, "floppy")) { type = IF_FLOPPY; max_devs = 0; } else if (!strcmp(buf, "pflash")) { type = IF_PFLASH; max_devs = 0; } else if (!strcmp(buf, "mtd")) { type = IF_MTD; max_devs = 0; } else if (!strcmp(buf, "sd")) { type = IF_SD; max_devs = 0; } else if (!strcmp(buf, "virtio")) { type = IF_VIRTIO; max_devs = 0; } else if (!strcmp(buf, "xen")) { type = IF_XEN; max_devs = 0; } else { fprintf(stderr, "qemu: '%s' unsupported bus type '%s'\n", str, buf); return -1; } } if (get_param_value(buf, sizeof(buf), "index", str)) { index = strtol(buf, NULL, 0); if (index < 0) { fprintf(stderr, "qemu: '%s' invalid index\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "cyls", str)) { cyls = strtol(buf, NULL, 0); } if (get_param_value(buf, sizeof(buf), "heads", str)) { heads = strtol(buf, NULL, 0); } if (get_param_value(buf, sizeof(buf), "secs", str)) { secs = strtol(buf, NULL, 0); } if (cyls || heads || secs) { if (cyls < 1 || cyls > 16383) { fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", str); return -1; } if (heads < 1 || heads > 16) { fprintf(stderr, "qemu: '%s' invalid physical heads number\n", str); return -1; } if (secs < 1 || secs > 63) { fprintf(stderr, "qemu: '%s' invalid physical secs number\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "trans", str)) { if (!cyls) { fprintf(stderr, "qemu: '%s' trans must be used with cyls,heads and secs\n", str); return -1; } if (!strcmp(buf, "none")) translation = BIOS_ATA_TRANSLATION_NONE; else if (!strcmp(buf, "lba")) translation = BIOS_ATA_TRANSLATION_LBA; else if (!strcmp(buf, "auto")) translation = BIOS_ATA_TRANSLATION_AUTO; else { fprintf(stderr, "qemu: '%s' invalid translation type\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "media", str)) { if (!strcmp(buf, "disk")) { media = MEDIA_DISK; } else if (!strcmp(buf, "cdrom")) { if (cyls || secs || heads) { fprintf(stderr, "qemu: '%s' invalid physical CHS format\n", str); return -1; } media = MEDIA_CDROM; } else { fprintf(stderr, "qemu: '%s' invalid media\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "snapshot", str)) { if (!strcmp(buf, "on")) snapshot = 1; else if (!strcmp(buf, "off")) snapshot = 0; else { fprintf(stderr, "qemu: '%s' invalid snapshot option\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "cache", str)) { if (!strcmp(buf, "off") || !strcmp(buf, "none")) cache = 0; else if (!strcmp(buf, "writethrough")) cache = 1; else if (!strcmp(buf, "writeback")) cache = 2; else { fprintf(stderr, "qemu: invalid cache option\n"); return -1; } } if (get_param_value(buf, sizeof(buf), "format", str)) { if (strcmp(buf, "?") == 0) { fprintf(stderr, "qemu: Supported formats:"); bdrv_iterate_format(bdrv_format_print, NULL); fprintf(stderr, "\n"); return -1; } drv = bdrv_find_format(buf); if (!drv) { fprintf(stderr, "qemu: '%s' invalid format\n", buf); return -1; } } if (arg->file == NULL) get_param_value(file, sizeof(file), "file", str); else pstrcpy(file, sizeof(file), arg->file); if (!get_param_value(serial, sizeof(serial), "serial", str)) memset(serial, 0, sizeof(serial)); onerror = BLOCK_ERR_STOP_ENOSPC; if (get_param_value(buf, sizeof(serial), "werror", str)) { if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) { fprintf(stderr, "werror is no supported by this format\n"); return -1; } if (!strcmp(buf, "ignore")) onerror = BLOCK_ERR_IGNORE; else if (!strcmp(buf, "enospc")) onerror = BLOCK_ERR_STOP_ENOSPC; else if (!strcmp(buf, "stop")) onerror = BLOCK_ERR_STOP_ANY; else if (!strcmp(buf, "report")) onerror = BLOCK_ERR_REPORT; else { fprintf(stderr, "qemu: '%s' invalid write error action\n", buf); return -1; } } if (index != -1) { if (bus_id != 0 || unit_id != -1) { fprintf(stderr, "qemu: '%s' index cannot be used with bus and unit\n", str); return -1; } if (max_devs == 0) { unit_id = index; bus_id = 0; } else { unit_id = index % max_devs; bus_id = index / max_devs; } } if (unit_id == -1) { unit_id = 0; while (drive_get_index(type, bus_id, unit_id) != -1) { unit_id++; if (max_devs && unit_id >= max_devs) { unit_id -= max_devs; bus_id++; } } } if (max_devs && unit_id >= max_devs) { fprintf(stderr, "qemu: '%s' unit %d too big (max is %d)\n", str, unit_id, max_devs - 1); return -1; } if (drive_get_index(type, bus_id, unit_id) != -1) return -2; if (type == IF_IDE || type == IF_SCSI) mediastr = (media == MEDIA_CDROM) ? "-cd" : "-hd"; if (max_devs) snprintf(buf, sizeof(buf), "%s%i%s%i", devname, bus_id, mediastr, unit_id); else snprintf(buf, sizeof(buf), "%s%s%i", devname, mediastr, unit_id); bdrv = bdrv_new(buf); drives_table_idx = drive_get_free_idx(); drives_table[drives_table_idx].bdrv = bdrv; drives_table[drives_table_idx].type = type; drives_table[drives_table_idx].bus = bus_id; drives_table[drives_table_idx].unit = unit_id; drives_table[drives_table_idx].onerror = onerror; drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt; strncpy(drives_table[nb_drives].serial, serial, sizeof(serial)); nb_drives++; switch(type) { case IF_IDE: case IF_SCSI: case IF_XEN: switch(media) { case MEDIA_DISK: if (cyls != 0) { bdrv_set_geometry_hint(bdrv, cyls, heads, secs); bdrv_set_translation_hint(bdrv, translation); } break; case MEDIA_CDROM: bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM); break; } break; case IF_SD: case IF_FLOPPY: bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY); break; case IF_PFLASH: case IF_MTD: case IF_VIRTIO: break; } if (!file[0]) return -2; bdrv_flags = 0; if (snapshot) { bdrv_flags |= BDRV_O_SNAPSHOT; cache = 2; } if (cache == 0) bdrv_flags |= BDRV_O_NOCACHE; else if (cache == 2) bdrv_flags |= BDRV_O_CACHE_WB; else if (cache == 3) bdrv_flags |= BDRV_O_CACHE_DEF; if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) { fprintf(stderr, "qemu: could not open disk image %s\n", file); return -1; } if (bdrv_key_required(bdrv)) autostart = 0; return drives_table_idx; }
--------------------------------------------- Result 1044 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 549 / 117 / 378 / 1044:  39%|███▉      | 1044/2690 [2:42:03<4:15:30,  9.31s/it][Succeeded / Failed / Skipped / Total] 549 / 117 / 378 / 1044:  39%|███▉      | 1045/2690 [2:42:13<4:15:22,  9.31s/it][Succeeded / Failed / Skipped / Total] 550 / 117 / 378 / 1045:  39%|███▉      | 1045/2690 [2:42:13<4:15:22,  9.31s/it][Succeeded / Failed / Skipped / Total] 550 / 117 / 378 / 1045:  39%|███▉      | 1046/2690 [2:42:19<4:15:07,  9.31s/it][[0 (5%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void cpu_x86_update_cr4(CPUX86State *[[env]], uint32_t [[new_cr4]]) { #if defined(DEBUG_MMU) printf("CR4 update: CR4=%08x\n", (uint32_t)[[env]]->cr[4]); #endif if (([[new_cr4]] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) != ([[env]]->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) { tlb_flush([[env]], 1); } if (!([[env]]->cpuid_features & CPUID_SSE)) [[new_cr4]] &= ~CR4_OSFXSR_MASK; if ([[new_cr4]] & CR4_OSFXSR_MASK) [[env]]->hflags |= HF_OSFXSR_MASK; else [[env]]->hflags &= ~HF_OSFXSR_MASK; [[env]]->cr[4] = [[new_cr4]]; }

[[[[Adv]]]]: void cpu_x86_update_cr4(CPUX86State *[[genվ]], uint32_t [[mcycre]]) { #if defined(DEBUG_MMU) printf("CR4 update: CR4=%08x\n", (uint32_t)[[genվ]]->cr[4]); #endif if (([[mcycre]] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) != ([[genվ]]->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) { tlb_flush([[genվ]], 1); } if (!([[genվ]]->cpuid_features & CPUID_SSE)) [[mcycre]] &= ~CR4_OSFXSR_MASK; if ([[mcycre]] & CR4_OSFXSR_MASK) [[genվ]]->hflags |= HF_OSFXSR_MASK; else [[genվ]]->hflags &= ~HF_OSFXSR_MASK; [[genվ]]->cr[4] = [[mcycre]]; }
--------------------------------------------- Result 1045 ---------------------------------------------
[[0 (64%)]] --> [[0 (33%)]] --> Socre: 0.6698418855667114

[[[[Adv]]]]: static void unix_wait_for_connect(int fd, Error *[[err]], void *opaque) { MigrationState *s = opaque; if (fd < 0) { DPRINTF("migrate connect error: %s\n", error_get_pretty([[err]])); s->file = NULL; migrate_fd_error(s); } else { DPRINTF("migrate connect success\n"); s->file = qemu_fopen_socket(fd, "wb"); migrate_fd_connect(s); } }

[[[[Adv]]]]: static void unix_wait_for_connect(int fd, Error *[[autore]], void *opaque) { MigrationState *s = opaque; if (fd < 0) { DPRINTF("migrate connect error: %s\n", error_get_pretty([[autore]])); s->file = NULL; migrate_fd_error(s); } else { DPRINTF("migrate connect success\n"); s->file = qemu_fopen_socket(fd, "wb"); migrate_fd_connect(s); } }
--------------------------------------------- Result 1046 ---------------------------------------------
[[0 (71%)]] --> [[0 (40%)]] --> Socre: 0.6027450859546661

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; unsigned int buf_size = avpkt->size; const uint8_t *buf_end = buf + buf_size; const AVPixFmtDescriptor *[[desc]]; EXRContext *const [[s]] = avctx->priv_data; AVFrame *[[picture]] = data; AVFrame *const p = &[[s]]->picture; uint8_t *ptr; int i, x, y, stride, magic_number, version, flags, ret; int w = 0; int h = 0; unsigned int xmin = ~0; unsigned int xmax = ~0; unsigned int ymin = ~0; unsigned int ymax = ~0; unsigned int xdelta = ~0; int out_line_size; int bxmin, axmax; int scan_lines_per_block; unsigned long scan_line_size; unsigned long uncompressed_size; unsigned int current_channel_offset = 0; [[s]]->channel_offsets[0] = -1; [[s]]->channel_offsets[1] = -1; [[s]]->channel_offsets[2] = -1; [[s]]->channel_offsets[3] = -1; [[s]]->bits_per_color_id = -1; [[s]]->compr = -1; if (buf_size < 10) { av_log(avctx, AV_LOG_ERROR, "Too short header to parse\n"); return AVERROR_INVALIDDATA; } magic_number = bytestream_get_le32(&buf); if (magic_number != 20000630) { av_log(avctx, AV_LOG_ERROR, "Wrong magic number %d\n", magic_number); return AVERROR_INVALIDDATA; } version = bytestream_get_byte(&buf); if (version != 2) { av_log(avctx, AV_LOG_ERROR, "Unsupported version %d\n", version); return AVERROR_PATCHWELCOME; } flags = bytestream_get_le24(&buf); if (flags & 0x2) { av_log(avctx, AV_LOG_ERROR, "Tile based images are not supported\n"); return AVERROR_PATCHWELCOME; } while (buf < buf_end && buf[0]) { unsigned int variable_buffer_data_size; if (check_header_variable(avctx, &buf, buf_end, "channels", "chlist", 38, &variable_buffer_data_size) >= 0) { const uint8_t *channel_list_end; if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; channel_list_end = buf + variable_buffer_data_size; while (channel_list_end - buf >= 19) { int current_bits_per_color_id = -1; int channel_index = -1; if (!strcmp(buf, "R")) channel_index = 0; else if (!strcmp(buf, "G")) channel_index = 1; else if (!strcmp(buf, "B")) channel_index = 2; else if (!strcmp(buf, "A")) channel_index = 3; else av_log(avctx, AV_LOG_WARNING, "Unsupported channel %.256s\n", buf); while (bytestream_get_byte(&buf) && buf < channel_list_end) continue; if (channel_list_end - * &buf < 4) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } current_bits_per_color_id = bytestream_get_le32(&buf); if (current_bits_per_color_id > 2) { av_log(avctx, AV_LOG_ERROR, "Unknown color format\n"); return AVERROR_INVALIDDATA; } if (channel_index >= 0) { if ([[s]]->bits_per_color_id != -1 && [[s]]->bits_per_color_id != current_bits_per_color_id) { av_log(avctx, AV_LOG_ERROR, "RGB channels not of the same depth\n"); return AVERROR_INVALIDDATA; } [[s]]->bits_per_color_id = current_bits_per_color_id; [[s]]->channel_offsets[channel_index] = current_channel_offset; } current_channel_offset += 1 << current_bits_per_color_id; buf += 12; } if (FFMIN3([[s]]->channel_offsets[0], [[s]]->channel_offsets[1], [[s]]->channel_offsets[2]) < 0) { if ([[s]]->channel_offsets[0] < 0) av_log(avctx, AV_LOG_ERROR, "Missing red channel\n"); if ([[s]]->channel_offsets[1] < 0) av_log(avctx, AV_LOG_ERROR, "Missing green channel\n"); if ([[s]]->channel_offsets[2] < 0) av_log(avctx, AV_LOG_ERROR, "Missing blue channel\n"); return AVERROR_INVALIDDATA; } buf = channel_list_end; continue; } else if (check_header_variable(avctx, &buf, buf_end, "dataWindow", "box2i", 31, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; xmin = AV_RL32(buf); ymin = AV_RL32(buf + 4); xmax = AV_RL32(buf + 8); ymax = AV_RL32(buf + 12); xdelta = (xmax-xmin) + 1; buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "displayWindow", "box2i", 34, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; w = AV_RL32(buf + 8) + 1; h = AV_RL32(buf + 12) + 1; buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "lineOrder", "lineOrder", 25, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; if (*buf) { av_log(avctx, AV_LOG_ERROR, "Doesn't support this line order : %d\n", *buf); return AVERROR_PATCHWELCOME; } buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "pixelAspectRatio", "float", 31, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; avctx->sample_aspect_ratio = av_d2q(av_int2float(AV_RL32(buf)), 255); buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "compression", "compression", 29, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; if ([[s]]->compr == -1) [[s]]->compr = *buf; else av_log(avctx, AV_LOG_WARNING, "Found more than one compression attribute\n"); buf += variable_buffer_data_size; continue; } if (buf_end - buf <= 9) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } for (i = 0; i < 2; i++) { while (++buf < buf_end) if (buf[0] == 0x0) break; } buf++; if (buf_end - buf >= 5) { variable_buffer_data_size = get_header_variable_length(&buf, buf_end); if (!variable_buffer_data_size) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } buf += variable_buffer_data_size; } } if ([[s]]->compr == -1) { av_log(avctx, AV_LOG_ERROR, "Missing compression attribute\n"); return AVERROR_INVALIDDATA; } if (buf >= buf_end) { av_log(avctx, AV_LOG_ERROR, "Incomplete frame\n"); return AVERROR_INVALIDDATA; } buf++; switch ([[s]]->bits_per_color_id) { case 2: case 1: if ([[s]]->channel_offsets[3] >= 0) avctx->pix_fmt = AV_PIX_FMT_RGBA64; else avctx->pix_fmt = AV_PIX_FMT_RGB48; break; case 0: av_log_missing_feature(avctx, "8-bit OpenEXR", 1); return AVERROR_PATCHWELCOME; default: av_log(avctx, AV_LOG_ERROR, "Unknown color format : %d\n", [[s]]->bits_per_color_id); return AVERROR_INVALIDDATA; } switch ([[s]]->compr) { case EXR_RAW: case EXR_RLE: case EXR_ZIP1: scan_lines_per_block = 1; break; case EXR_ZIP16: scan_lines_per_block = 16; break; default: av_log(avctx, AV_LOG_ERROR, "Compression type %d is not supported\n", [[s]]->compr); return AVERROR_PATCHWELCOME; } if ([[s]]->picture.data[0]) ff_thread_release_buffer(avctx, &[[s]]->picture); if (av_image_check_size(w, h, 0, avctx)) return AVERROR_INVALIDDATA; if (xmin > xmax || ymin > ymax || xdelta != xmax - xmin + 1 || xmax >= w || ymax >= h) { av_log(avctx, AV_LOG_ERROR, "Wrong sizing or missing size information\n"); return AVERROR_INVALIDDATA; } if (w != avctx->width || h != avctx->height) { avcodec_set_dimensions(avctx, w, h); } [[desc]] = av_pix_fmt_desc_get(avctx->pix_fmt); bxmin = xmin * 2 * [[desc]]->nb_components; axmax = (avctx->width - (xmax + 1)) * 2 * [[desc]]->nb_components; out_line_size = avctx->width * 2 * [[desc]]->nb_components; scan_line_size = xdelta * current_channel_offset; uncompressed_size = scan_line_size * scan_lines_per_block; if ([[s]]->compr != EXR_RAW) { av_fast_padded_malloc(&[[s]]->uncompressed_data, &[[s]]->uncompressed_size, uncompressed_size); av_fast_padded_malloc(&[[s]]->tmp, &[[s]]->tmp_size, uncompressed_size); if (![[s]]->uncompressed_data || ![[s]]->tmp) return AVERROR(ENOMEM); } if ((ret = ff_thread_get_buffer(avctx, p)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } ptr = p->data[0]; stride = p->linesize[0]; for (y = 0; y < ymin; y++) { memset(ptr, 0, out_line_size); ptr += stride; } for (y = ymin; y <= ymax; y += scan_lines_per_block) { uint16_t *ptr_x = (uint16_t *)ptr; if (buf_end - buf > 8) { const uint64_t line_offset = bytestream_get_le64(&buf) + 8; int32_t data_size; if ((line_offset > buf_size) || ([[s]]->compr == EXR_RAW && line_offset > avpkt->size - xdelta * current_channel_offset) || ([[s]]->compr != EXR_RAW && line_offset > buf_size - (data_size = AV_RL32(avpkt->data + line_offset - 4)))) { av_log(avctx, AV_LOG_WARNING, "Line offset for line %d is out of reach setting it to black\n", y); for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) { ptr_x = (uint16_t *)ptr; memset(ptr_x, 0, out_line_size); } } else { const uint8_t *red_channel_buffer, *green_channel_buffer, *blue_channel_buffer, *alpha_channel_buffer = 0; if (scan_lines_per_block > 1) uncompressed_size = scan_line_size * FFMIN(scan_lines_per_block, ymax - y + 1); if (([[s]]->compr == EXR_ZIP1 || [[s]]->compr == EXR_ZIP16) && data_size < uncompressed_size) { unsigned long dest_len = uncompressed_size; if (uncompress([[s]]->tmp, &dest_len, avpkt->data + line_offset, data_size) != Z_OK || dest_len != uncompressed_size) { av_log(avctx, AV_LOG_ERROR, "error during zlib decompression\n"); return AVERROR(EINVAL); } } else if ([[s]]->compr == EXR_RLE && data_size < uncompressed_size) { if (rle_uncompress(avpkt->data + line_offset, data_size, [[s]]->tmp, uncompressed_size)) { av_log(avctx, AV_LOG_ERROR, "error during rle decompression\n"); return AVERROR(EINVAL); } } if ([[s]]->compr != EXR_RAW && data_size < uncompressed_size) { predictor([[s]]->tmp, uncompressed_size); reorder_pixels([[s]]->tmp, [[s]]->uncompressed_data, uncompressed_size); red_channel_buffer = [[s]]->uncompressed_data + xdelta * [[s]]->channel_offsets[0]; green_channel_buffer = [[s]]->uncompressed_data + xdelta * [[s]]->channel_offsets[1]; blue_channel_buffer = [[s]]->uncompressed_data + xdelta * [[s]]->channel_offsets[2]; if ([[s]]->channel_offsets[3] >= 0) alpha_channel_buffer = [[s]]->uncompressed_data + xdelta * [[s]]->channel_offsets[3]; } else { red_channel_buffer = avpkt->data + line_offset + xdelta * [[s]]->channel_offsets[0]; green_channel_buffer = avpkt->data + line_offset + xdelta * [[s]]->channel_offsets[1]; blue_channel_buffer = avpkt->data + line_offset + xdelta * [[s]]->channel_offsets[2]; if ([[s]]->channel_offsets[3] >= 0) alpha_channel_buffer = avpkt->data + line_offset + xdelta * [[s]]->channel_offsets[3]; } for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) { const uint8_t *r, *g, *b, *a; r = red_channel_buffer; g = green_channel_buffer; b = blue_channel_buffer; if (alpha_channel_buffer) a = alpha_channel_buffer; ptr_x = (uint16_t *)ptr; memset(ptr_x, 0, bxmin); ptr_x += xmin * [[desc]]->nb_components; if ([[s]]->bits_per_color_id == 2) { for (x = 0; x < xdelta; x++) { *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r)); *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g)); *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b)); if (alpha_channel_buffer) *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a)); } } else { for (x = 0; x < xdelta; x++) { *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r)); *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g)); *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b)); if (alpha_channel_buffer) *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a)); } } memset(ptr_x, 0, axmax); red_channel_buffer += scan_line_size; green_channel_buffer += scan_line_size; blue_channel_buffer += scan_line_size; if (alpha_channel_buffer) alpha_channel_buffer += scan_line_size; } } } } for (y = ymax + 1; y < avctx->height; y++) { memset(ptr, 0, out_line_size); ptr += stride; } *[[picture]] = [[s]]->picture; *got_frame = 1; return buf_size; }

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; unsigned int buf_size = avpkt->size; const uint8_t *buf_end = buf + buf_size; const AVPixFmtDescriptor *[[devl]]; EXRContext *const [[performance]] = avctx->priv_data; AVFrame *[[q]] = data; AVFrame *const p = &[[performance]]->picture; uint8_t *ptr; int i, x, y, stride, magic_number, version, flags, ret; int w = 0; int h = 0; unsigned int xmin = ~0; unsigned int xmax = ~0; unsigned int ymin = ~0; unsigned int ymax = ~0; unsigned int xdelta = ~0; int out_line_size; int bxmin, axmax; int scan_lines_per_block; unsigned long scan_line_size; unsigned long uncompressed_size; unsigned int current_channel_offset = 0; [[performance]]->channel_offsets[0] = -1; [[performance]]->channel_offsets[1] = -1; [[performance]]->channel_offsets[2] = -1; [[performance]]->channel_offsets[3] = -1; [[performance]]->bits_per_color_id = -1; [[performance]]->compr = -1; if (buf_size < 10) { av_log(avctx, AV_LOG_ERROR, "Too short header to parse\n"); return AVERROR_INVALIDDATA; } magic_number = bytestream_get_le32(&buf); if (magic_number != 20000630) { av_log(avctx, AV_LOG_ERROR, "Wrong magic number %d\n", magic_number); return AVERROR_INVALIDDATA; } version = bytestream_get_byte(&buf); if (version != 2) { av_log(avctx, AV_LOG_ERROR, "Unsupported version %d\n", version); return AVERROR_PATCHWELCOME; } flags = bytestream_get_le24(&buf); if (flags & 0x2) { av_log(avctx, AV_LOG_ERROR, "Tile based images are not supported\n"); return AVERROR_PATCHWELCOME; } while (buf < buf_end && buf[0]) { unsigned int variable_buffer_data_size; if (check_header_variable(avctx, &buf, buf_end, "channels", "chlist", 38, &variable_buffer_data_size) >= 0) { const uint8_t *channel_list_end; if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; channel_list_end = buf + variable_buffer_data_size; while (channel_list_end - buf >= 19) { int current_bits_per_color_id = -1; int channel_index = -1; if (!strcmp(buf, "R")) channel_index = 0; else if (!strcmp(buf, "G")) channel_index = 1; else if (!strcmp(buf, "B")) channel_index = 2; else if (!strcmp(buf, "A")) channel_index = 3; else av_log(avctx, AV_LOG_WARNING, "Unsupported channel %.256s\n", buf); while (bytestream_get_byte(&buf) && buf < channel_list_end) continue; if (channel_list_end - * &buf < 4) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } current_bits_per_color_id = bytestream_get_le32(&buf); if (current_bits_per_color_id > 2) { av_log(avctx, AV_LOG_ERROR, "Unknown color format\n"); return AVERROR_INVALIDDATA; } if (channel_index >= 0) { if ([[performance]]->bits_per_color_id != -1 && [[performance]]->bits_per_color_id != current_bits_per_color_id) { av_log(avctx, AV_LOG_ERROR, "RGB channels not of the same depth\n"); return AVERROR_INVALIDDATA; } [[performance]]->bits_per_color_id = current_bits_per_color_id; [[performance]]->channel_offsets[channel_index] = current_channel_offset; } current_channel_offset += 1 << current_bits_per_color_id; buf += 12; } if (FFMIN3([[performance]]->channel_offsets[0], [[performance]]->channel_offsets[1], [[performance]]->channel_offsets[2]) < 0) { if ([[performance]]->channel_offsets[0] < 0) av_log(avctx, AV_LOG_ERROR, "Missing red channel\n"); if ([[performance]]->channel_offsets[1] < 0) av_log(avctx, AV_LOG_ERROR, "Missing green channel\n"); if ([[performance]]->channel_offsets[2] < 0) av_log(avctx, AV_LOG_ERROR, "Missing blue channel\n"); return AVERROR_INVALIDDATA; } buf = channel_list_end; continue; } else if (check_header_variable(avctx, &buf, buf_end, "dataWindow", "box2i", 31, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; xmin = AV_RL32(buf); ymin = AV_RL32(buf + 4); xmax = AV_RL32(buf + 8); ymax = AV_RL32(buf + 12); xdelta = (xmax-xmin) + 1; buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "displayWindow", "box2i", 34, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; w = AV_RL32(buf + 8) + 1; h = AV_RL32(buf + 12) + 1; buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "lineOrder", "lineOrder", 25, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; if (*buf) { av_log(avctx, AV_LOG_ERROR, "Doesn't support this line order : %d\n", *buf); return AVERROR_PATCHWELCOME; } buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "pixelAspectRatio", "float", 31, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; avctx->sample_aspect_ratio = av_d2q(av_int2float(AV_RL32(buf)), 255); buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "compression", "compression", 29, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; if ([[performance]]->compr == -1) [[performance]]->compr = *buf; else av_log(avctx, AV_LOG_WARNING, "Found more than one compression attribute\n"); buf += variable_buffer_data_size; continue; } if (buf_end - buf <= 9) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } for (i = 0; i < 2; i++) { while (++buf < buf_end) if (buf[0] == 0x0) break; } buf++; if (buf_end - buf >= 5) { variable_buffer_data_size = get_header_variable_length(&buf, buf_end); if (!variable_buffer_data_size) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } buf += variable_buffer_data_size; } } if ([[performance]]->compr == -1) { av_log(avctx, AV_LOG_ERROR, "Missing compression attribute\n"); return AVERROR_INVALIDDATA; } if (buf >= buf_end) { av_log(avctx, AV_LOG_ERROR, "Incomplete frame\n"); return AVERROR_INVALIDDATA; } buf++; switch ([[performance]]->bits_per_color_id) { case 2: case 1: if ([[performance]]->channel_offsets[3] >= 0) avctx->pix_fmt = AV_PIX_FMT_RGBA64; else avctx->pix_fmt = AV_PIX_FMT_RGB48; break; case 0: av_log_missing_feature(avctx, "8-bit OpenEXR", 1); return AVERROR_PATCHWELCOME; default: av_log(avctx, AV_LOG_ERROR, "Unknown color format : %d\n", [[performance]]->bits_per_color_id); return AVERROR_INVALIDDATA; } switch ([[performance]]->compr) { case EXR_RAW: case EXR_RLE: case EXR_ZIP1: scan_lines_per_block = 1; break; case EXR_ZIP16: scan_lines_per_block = 16; break; default: av_log(avctx, AV_LOG_ERROR, "Compression type %d is not supported\n", [[performance]]->compr); return AVERROR_PATCHWELCOME; } if ([[performance]]->picture.data[0]) ff_thread_release_buffer(avctx, &[[performance]]->picture); if (av_image_check_size(w, h, 0, avctx)) return AVERROR_INVALIDDATA; if (xmin > xmax || ymin > ymax || xdelta != xmax - xmin + 1 || xmax >= w || ymax >= h) { av_log(avctx, AV_LOG_ERROR, "Wrong sizing or missing size information\n"); return AVERROR_INVALIDDATA; } if (w != avctx->width || h != avctx->height) { avcodec_set_dimensions(avctx, w, h); } [[devl]] = av_pix_fmt_desc_get(avctx->pix_fmt); bxmin = xmin * 2 * [[devl]]->nb_components; axmax = (avctx->width - (xmax + 1)) * 2 * [[devl]]->nb_components; out_line_size = avctx->width * 2 * [[devl]]->nb_components; scan_line_size = xdelta * current_channel_offset; uncompressed_size = scan_line_size * scan_lines_per_block; if ([[performance]]->compr != EXR_RAW) { av_fast_padded_malloc(&[[performance]]->uncompressed_data, &[[performance]]->uncompressed_size, uncompressed_size); av_fast_padded_malloc(&[[performance]]->tmp, &[[performance]]->tmp_size, uncompressed_size); if (![[performance]]->uncompressed_data || ![[performance]]->tmp) return AVERROR(ENOMEM); } if ((ret = ff_thread_get_buffer(avctx, p)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } ptr = p->data[0]; stride = p->linesize[0]; for (y = 0; y < ymin; y++) { memset(ptr, 0, out_line_size); ptr += stride; } for (y = ymin; y <= ymax; y += scan_lines_per_block) { uint16_t *ptr_x = (uint16_t *)ptr; if (buf_end - buf > 8) { const uint64_t line_offset = bytestream_get_le64(&buf) + 8; int32_t data_size; if ((line_offset > buf_size) || ([[performance]]->compr == EXR_RAW && line_offset > avpkt->size - xdelta * current_channel_offset) || ([[performance]]->compr != EXR_RAW && line_offset > buf_size - (data_size = AV_RL32(avpkt->data + line_offset - 4)))) { av_log(avctx, AV_LOG_WARNING, "Line offset for line %d is out of reach setting it to black\n", y); for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) { ptr_x = (uint16_t *)ptr; memset(ptr_x, 0, out_line_size); } } else { const uint8_t *red_channel_buffer, *green_channel_buffer, *blue_channel_buffer, *alpha_channel_buffer = 0; if (scan_lines_per_block > 1) uncompressed_size = scan_line_size * FFMIN(scan_lines_per_block, ymax - y + 1); if (([[performance]]->compr == EXR_ZIP1 || [[performance]]->compr == EXR_ZIP16) && data_size < uncompressed_size) { unsigned long dest_len = uncompressed_size; if (uncompress([[performance]]->tmp, &dest_len, avpkt->data + line_offset, data_size) != Z_OK || dest_len != uncompressed_size) { av_log(avctx, AV_LOG_ERROR, "error during zlib decompression\n"); return AVERROR(EINVAL); } } else if ([[performance]]->compr == EXR_RLE && data_size < uncompressed_size) { if (rle_uncompress(avpkt->data + line_offset, data_size, [[performance]]->tmp, uncompressed_size)) { av_log(avctx, AV_LOG_ERROR, "error during rle decompression\n"); return AVERROR(EINVAL); } } if ([[performance]]->compr != EXR_RAW && data_size < uncompressed_size) { predictor([[performance]]->tmp, uncompressed_size); reorder_pixels([[performance]]->tmp, [[performance]]->uncompressed_data, uncompressed_size); red_channel_buffer = [[performance]]->uncompressed_data + xdelta * [[performance]]->channel_offsets[0]; green_channel_buffer = [[performance]]->uncompressed_data + xdelta * [[performance]]->channel_offsets[1]; blue_channel_buffer = [[performance]]->uncompressed_data + xdelta * [[performance]]->channel_offsets[2]; if ([[performance]]->channel_offsets[3] >= 0) alpha_channel_buffer = [[performance]]->uncompressed_data + xdelta * [[performance]]->channel_offsets[3]; } else { red_channel_buffer = avpkt->data + line_offset + xdelta * [[performance]]->channel_offsets[0]; green_channel_buffer = avpkt->data + line_offset + xdelta * [[performance]]->channel_offsets[1]; blue_channel_buffer = avpkt->data + line_offset + xdelta * [[performance]]->channel_offsets[2]; if ([[performance]]->channel_offsets[3] >= 0) alpha_channel_buffer = avpkt->data + line_offset + xdelta * [[performance]]->channel_offsets[3]; } for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) { const uint8_t *r, *g, *b, *a; r = red_channel_buffer; g = green_channel_buffer; b = blue_channel_buffer; if (alpha_channel_buffer) a = alpha_channel_buffer; ptr_x = (uint16_t *)ptr; memset(ptr_x, 0, bxmin); ptr_x += xmin * [[devl]]->nb_components; if ([[performance]]->bits_per_color_id == 2) { for (x = 0; x < xdelta; x++) { *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r)); *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g)); *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b)); if (alpha_channel_buffer) *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a)); } } else { for (x = 0; x < xdelta; x++) { *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r)); *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g)); *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b)); if (alpha_channel_buffer) *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a)); } } memset(ptr_x, 0, axmax); red_channel_buffer += scan_line_size; green_channel_buffer += scan_line_size; blue_channel_buffer += scan_line_size; if (alpha_channel_buffer) alpha_channel_buffer += scan_line_size; } } } } for (y = ymax + 1; y < avctx->height; y++) { memset(ptr, 0, out_line_size); ptr += stride; } *[[q]] = [[performance]]->picture; *got_frame = 1; return buf_size; }[Succeeded / Failed / Skipped / Total] 551 / 117 / 378 / 1046:  39%|███▉      | 1046/2690 [2:42:19<4:15:07,  9.31s/it][Succeeded / Failed / Skipped / Total] 551 / 117 / 378 / 1046:  39%|███▉      | 1047/2690 [2:42:28<4:14:57,  9.31s/it][Succeeded / Failed / Skipped / Total] 552 / 117 / 378 / 1047:  39%|███▉      | 1047/2690 [2:42:28<4:14:57,  9.31s/it][Succeeded / Failed / Skipped / Total] 552 / 117 / 378 / 1047:  39%|███▉      | 1048/2690 [2:42:28<4:14:34,  9.30s/it][Succeeded / Failed / Skipped / Total] 552 / 117 / 379 / 1048:  39%|███▉      | 1048/2690 [2:42:28<4:14:34,  9.30s/it][Succeeded / Failed / Skipped / Total] 552 / 117 / 379 / 1048:  39%|███▉      | 1049/2690 [2:42:29<4:14:11,  9.29s/it][Succeeded / Failed / Skipped / Total] 552 / 117 / 380 / 1049:  39%|███▉      | 1049/2690 [2:42:29<4:14:11,  9.29s/it][Succeeded / Failed / Skipped / Total] 552 / 117 / 380 / 1049:  39%|███▉      | 1050/2690 [2:42:47<4:14:15,  9.30s/it]
--------------------------------------------- Result 1047 ---------------------------------------------
[[0 (13%)]] --> [[0 (75%)]] --> Socre: 0.745934247970581

[[[[Adv]]]]: static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { LJpegEncContext *s = avctx->priv_data; PutBitContext [[pb]]; const int width = avctx->width; const int height = avctx->height; const int mb_width = (width + s->hsample[0] - 1) / s->hsample[0]; const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0]; int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE; int ret, header_bits; if (avctx->pix_fmt == AV_PIX_FMT_BGR24) max_pkt_size += width * height * 3 * 3; else { max_pkt_size += mb_width * mb_height * 3 * 4 * s->hsample[0] * s->vsample[0]; } if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet of size %d.\n", max_pkt_size); return ret; } init_put_bits(&[[pb]], pkt->data, pkt->size); ff_mjpeg_encode_picture_header(avctx, &[[pb]], &s->scantable, s->matrix); header_bits = put_bits_count(&[[pb]]); if (avctx->pix_fmt == AV_PIX_FMT_BGR24) ret = ljpeg_encode_bgr(avctx, &[[pb]], pict); else ret = ljpeg_encode_yuv(avctx, &[[pb]], pict); if (ret < 0) return ret; emms_c(); ff_mjpeg_encode_picture_trailer(&[[pb]], header_bits); flush_put_bits(&[[pb]]); pkt->size = put_bits_ptr(&[[pb]]) - [[pb]].buf; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; return 0; }

[[[[Adv]]]]: static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { LJpegEncContext *s = avctx->priv_data; PutBitContext [[pcب]]; const int width = avctx->width; const int height = avctx->height; const int mb_width = (width + s->hsample[0] - 1) / s->hsample[0]; const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0]; int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE; int ret, header_bits; if (avctx->pix_fmt == AV_PIX_FMT_BGR24) max_pkt_size += width * height * 3 * 3; else { max_pkt_size += mb_width * mb_height * 3 * 4 * s->hsample[0] * s->vsample[0]; } if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet of size %d.\n", max_pkt_size); return ret; } init_put_bits(&[[pcب]], pkt->data, pkt->size); ff_mjpeg_encode_picture_header(avctx, &[[pcب]], &s->scantable, s->matrix); header_bits = put_bits_count(&[[pcب]]); if (avctx->pix_fmt == AV_PIX_FMT_BGR24) ret = ljpeg_encode_bgr(avctx, &[[pcب]], pict); else ret = ljpeg_encode_yuv(avctx, &[[pcب]], pict); if (ret < 0) return ret; emms_c(); ff_mjpeg_encode_picture_trailer(&[[pcب]], header_bits); flush_put_bits(&[[pcب]]); pkt->size = put_bits_ptr(&[[pcب]]) - [[pcب]].buf; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; return 0; }
--------------------------------------------- Result 1048 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay) { trace_qxl_spice_monitors_config(qxl->id); if (replay) { spice_qxl_monitors_config_async(&qxl->ssd.qxl, qxl->guest_monitors_config, MEMSLOT_GROUP_GUEST, (uintptr_t)qxl_cookie_new( QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG, 0)); } else { #if SPICE_SERVER_VERSION >= 0x000c06 if (qxl->max_outputs) { spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl, qxl->max_outputs); } #endif qxl->guest_monitors_config = qxl->ram->monitors_config; spice_qxl_monitors_config_async(&qxl->ssd.qxl, qxl->ram->monitors_config, MEMSLOT_GROUP_GUEST, (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO, QXL_IO_MONITORS_CONFIG_ASYNC)); } }
--------------------------------------------- Result 1049 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_net_vhost_status(VirtIONet *n, uint8_t status) { VirtIODevice *vdev = VIRTIO_DEVICE(n); NetClientState *nc = qemu_get_queue(n->nic); int queues = n->multiqueue ? n->max_queues : 1; if (!get_vhost_net(nc->peer)) { return; } if (!!n->vhost_started == (virtio_net_started(n, status) && !nc->peer->link_down)) { return; } if (!n->vhost_started) { int r; if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) { return; } n->vhost_started = 1; r = vhost_net_start(vdev, n->nic->ncs, queues); if (r < 0) { error_report("unable to start vhost net: %d: " "falling back on userspace virtio", -r); n->vhost_started = 0; } } else { vhost_net_stop(vdev, n->nic->ncs, queues); n->vhost_started = 0; } }
--------------------------------------------- Result 1050 ---------------------------------------------
[[0 (100%)]] --> [[0 (22%)]] --> Socre: 0.7821771204471588

[[[[Adv]]]]: int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx, H264ParamSets *[[ps]], int bit_length) { AVBufferRef *pps_buf; const SPS *sps; unsigned int pps_id = get_ue_golomb(gb); PPS *pps; int qp_bd_offset; int bits_left; int ret; if (pps_id >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id); return AVERROR_INVALIDDATA; pps_buf = av_buffer_allocz(sizeof(*pps)); if (!pps_buf) return AVERROR(ENOMEM); pps = (PPS*)pps_buf->data; pps->data_size = gb->buffer_end - gb->buffer; if (pps->data_size > sizeof(pps->data)) { av_log(avctx, AV_LOG_WARNING, "Truncating likely oversized PPS " "(%"SIZE_SPECIFIER" > %"SIZE_SPECIFIER")\n", pps->data_size, sizeof(pps->data)); pps->data_size = sizeof(pps->data); memcpy(pps->data, gb->buffer, pps->data_size); pps->sps_id = get_ue_golomb_31(gb); if ((unsigned)pps->sps_id >= MAX_SPS_COUNT || ![[ps]]->sps_list[pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, "sps_id %u out of range\n", pps->sps_id); sps = (const SPS*)[[ps]]->sps_list[pps->sps_id]->data; if (sps->bit_depth_luma > 14) { av_log(avctx, AV_LOG_ERROR, "Invalid luma bit depth=%d\n", sps->bit_depth_luma); } else if (sps->bit_depth_luma == 11 || sps->bit_depth_luma == 13) { av_log(avctx, AV_LOG_ERROR, "Unimplemented luma bit depth=%d\n", sps->bit_depth_luma); ret = AVERROR_PATCHWELCOME; pps->cabac = get_bits1(gb); pps->pic_order_present = get_bits1(gb); pps->slice_group_count = get_ue_golomb(gb) + 1; if (pps->slice_group_count > 1) { pps->mb_slice_group_map_type = get_ue_golomb(gb); av_log(avctx, AV_LOG_ERROR, "FMO not supported\n"); switch (pps->mb_slice_group_map_type) { case 0: #if 0 | for (i = 0; i <= num_slice_groups_minus1; i++) | | | | run_length[i] |1 |ue(v) | #endif break; case 2: #if 0 | for (i = 0; i < num_slice_groups_minus1; i++) { | | | | top_left_mb[i] |1 |ue(v) | | bottom_right_mb[i] |1 |ue(v) | | } | | | #endif break; case 3: case 4: case 5: #if 0 | slice_group_change_direction_flag |1 |u(1) | | slice_group_change_rate_minus1 |1 |ue(v) | #endif break; case 6: #if 0 | slice_group_id_cnt_minus1 |1 |ue(v) | | for (i = 0; i <= slice_group_id_cnt_minus1; i++)| | | | slice_group_id[i] |1 |u(v) | #endif break; pps->ref_count[0] = get_ue_golomb(gb) + 1; pps->ref_count[1] = get_ue_golomb(gb) + 1; if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) { av_log(avctx, AV_LOG_ERROR, "reference overflow (pps)\n"); qp_bd_offset = 6 * (sps->bit_depth_luma - 8); pps->weighted_pred = get_bits1(gb); pps->weighted_bipred_idc = get_bits(gb, 2); pps->init_qp = get_se_golomb(gb) + 26 + qp_bd_offset; pps->init_qs = get_se_golomb(gb) + 26 + qp_bd_offset; pps->chroma_qp_index_offset[0] = get_se_golomb(gb); pps->deblocking_filter_parameters_present = get_bits1(gb); pps->constrained_intra_pred = get_bits1(gb); pps->redundant_pic_cnt_present = get_bits1(gb); pps->transform_8x8_mode = 0; memcpy(pps->scaling_matrix4, sps->scaling_matrix4, sizeof(pps->scaling_matrix4)); memcpy(pps->scaling_matrix8, sps->scaling_matrix8, sizeof(pps->scaling_matrix8)); bits_left = bit_length - get_bits_count(gb); if (bits_left > 0 && more_rbsp_data_in_pps(sps, avctx)) { pps->transform_8x8_mode = get_bits1(gb); decode_scaling_matrices(gb, sps, pps, 0, pps->scaling_matrix4, pps->scaling_matrix8); pps->chroma_qp_index_offset[1] = get_se_golomb(gb); if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) { } else { pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0]; build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], sps->bit_depth_luma); build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], sps->bit_depth_luma); init_dequant_tables(pps, sps); if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1]) pps->chroma_qp_diff = 1; if (avctx->debug & FF_DEBUG_PICT_INFO) { av_log(avctx, AV_LOG_DEBUG, "pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\n", pps_id, pps->sps_id, pps->cabac ? "CABAC" : "CAVLC", pps->slice_group_count, pps->ref_count[0], pps->ref_count[1], pps->weighted_pred ? "weighted" : "", pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1], pps->deblocking_filter_parameters_present ? "LPAR" : "", pps->constrained_intra_pred ? "CONSTR" : "", pps->redundant_pic_cnt_present ? "REDU" : "", pps->transform_8x8_mode ? "8x8DCT" : ""); remove_pps([[ps]], pps_id); [[ps]]->pps_list[pps_id] = pps_buf; return 0; fail: av_buffer_unref(&pps_buf); return ret;

[[[[Adv]]]]: int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx, H264ParamSets *[[ψ]], int bit_length) { AVBufferRef *pps_buf; const SPS *sps; unsigned int pps_id = get_ue_golomb(gb); PPS *pps; int qp_bd_offset; int bits_left; int ret; if (pps_id >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id); return AVERROR_INVALIDDATA; pps_buf = av_buffer_allocz(sizeof(*pps)); if (!pps_buf) return AVERROR(ENOMEM); pps = (PPS*)pps_buf->data; pps->data_size = gb->buffer_end - gb->buffer; if (pps->data_size > sizeof(pps->data)) { av_log(avctx, AV_LOG_WARNING, "Truncating likely oversized PPS " "(%"SIZE_SPECIFIER" > %"SIZE_SPECIFIER")\n", pps->data_size, sizeof(pps->data)); pps->data_size = sizeof(pps->data); memcpy(pps->data, gb->buffer, pps->data_size); pps->sps_id = get_ue_golomb_31(gb); if ((unsigned)pps->sps_id >= MAX_SPS_COUNT || ![[ψ]]->sps_list[pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, "sps_id %u out of range\n", pps->sps_id); sps = (const SPS*)[[ψ]]->sps_list[pps->sps_id]->data; if (sps->bit_depth_luma > 14) { av_log(avctx, AV_LOG_ERROR, "Invalid luma bit depth=%d\n", sps->bit_depth_luma); } else if (sps->bit_depth_luma == 11 || sps->bit_depth_luma == 13) { av_log(avctx, AV_LOG_ERROR, "Unimplemented luma bit depth=%d\n", sps->bit_depth_luma); ret = AVERROR_PATCHWELCOME; pps->cabac = get_bits1(gb); pps->pic_order_present = get_bits1(gb); pps->slice_group_count = get_ue_golomb(gb) + 1; if (pps->slice_group_count > 1) { pps->mb_slice_group_map_type = get_ue_golomb(gb); av_log(avctx, AV_LOG_ERROR, "FMO not supported\n"); switch (pps->mb_slice_group_map_type) { case 0: #if 0 | for (i = 0; i <= num_slice_groups_minus1; i++) | | | | run_length[i] |1 |ue(v) | #endif break; case 2: #if 0 | for (i = 0; i < num_slice_groups_minus1; i++) { | | | | top_left_mb[i] |1 |ue(v) | | bottom_right_mb[i] |1 |ue(v) | | } | | | #endif break; case 3: case 4: case 5: #if 0 | slice_group_change_direction_flag |1 |u(1) | | slice_group_change_rate_minus1 |1 |ue(v) | #endif break; case 6: #if 0 | slice_group_id_cnt_minus1 |1 |ue(v) | | for (i = 0; i <= slice_group_id_cnt_minus1; i++)| | | | slice_group_id[i] |1 |u(v) | #endif break; pps->ref_count[0] = get_ue_golomb(gb) + 1; pps->ref_count[1] = get_ue_golomb(gb) + 1; if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) { av_log(avctx, AV_LOG_ERROR, "reference overflow (pps)\n"); qp_bd_offset = 6 * (sps->bit_depth_luma - 8); pps->weighted_pred = get_bits1(gb); pps->weighted_bipred_idc = get_bits(gb, 2); pps->init_qp = get_se_golomb(gb) + 26 + qp_bd_offset; pps->init_qs = get_se_golomb(gb) + 26 + qp_bd_offset; pps->chroma_qp_index_offset[0] = get_se_golomb(gb); pps->deblocking_filter_parameters_present = get_bits1(gb); pps->constrained_intra_pred = get_bits1(gb); pps->redundant_pic_cnt_present = get_bits1(gb); pps->transform_8x8_mode = 0; memcpy(pps->scaling_matrix4, sps->scaling_matrix4, sizeof(pps->scaling_matrix4)); memcpy(pps->scaling_matrix8, sps->scaling_matrix8, sizeof(pps->scaling_matrix8)); bits_left = bit_length - get_bits_count(gb); if (bits_left > 0 && more_rbsp_data_in_pps(sps, avctx)) { pps->transform_8x8_mode = get_bits1(gb); decode_scaling_matrices(gb, sps, pps, 0, pps->scaling_matrix4, pps->scaling_matrix8); pps->chroma_qp_index_offset[1] = get_se_golomb(gb); if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) { } else { pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0]; build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], sps->bit_depth_luma); build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], sps->bit_depth_luma); init_dequant_tables(pps, sps); if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1]) pps->chroma_qp_diff = 1; if (avctx->debug & FF_DEBUG_PICT_INFO) { av_log(avctx, AV_LOG_DEBUG, "pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\n", pps_id, pps->sps_id, pps->cabac ? "CABAC" : "CAVLC", pps->slice_group_count, pps->ref_count[0], pps->ref_count[1], pps->weighted_pred ? "weighted" : "", pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1], pps->deblocking_filter_parameters_present ? "LPAR" : "", pps->constrained_intra_pred ? "CONSTR" : "", pps->redundant_pic_cnt_present ? "REDU" : "", pps->transform_8x8_mode ? "8x8DCT" : ""); remove_pps([[ψ]], pps_id); [[ψ]]->pps_list[pps_id] = pps_buf; return 0; fail: av_buffer_unref(&pps_buf); return ret;[Succeeded / Failed / Skipped / Total] 553 / 117 / 380 / 1050:  39%|███▉      | 1050/2690 [2:42:47<4:14:15,  9.30s/it][Succeeded / Failed / Skipped / Total] 553 / 117 / 380 / 1050:  39%|███▉      | 1051/2690 [2:43:06<4:14:21,  9.31s/it]
--------------------------------------------- Result 1051 ---------------------------------------------
[[0 (32%)]] --> [[0 (59%)]] --> Socre: 0.5949288010597229

[[[[Adv]]]]: static void init_block_mapping(Vp3DecodeContext *s) { int i, j; signed int [[hilbert_walk_y]][16]; signed int hilbert_walk_c[16]; signed int hilbert_walk_mb[4]; int current_fragment = 0; int current_width = 0; int current_height = 0; int right_edge = 0; int bottom_edge = 0; int superblock_row_inc = 0; int *hilbert = NULL; int mapping_index = 0; int current_macroblock; int c_fragment; signed char travel_width[16] = { 1, 1, 0, -1, 0, 0, 1, 0, 1, 0, 1, 0, 0, -1, 0, 1 }; signed char travel_height[16] = { 0, 0, 1, 0, 1, 1, 0, -1, 0, 1, 0, -1, -1, 0, -1, 0 }; signed char travel_width_mb[4] = { 1, 0, 1, 0 }; signed char travel_height_mb[4] = { 0, 1, 0, -1 }; debug_vp3(" vp3: initialize block mapping tables\n"); [[hilbert_walk_y]][0] = 1; [[hilbert_walk_y]][1] = 1; [[hilbert_walk_y]][2] = s->fragment_width; [[hilbert_walk_y]][3] = -1; [[hilbert_walk_y]][4] = s->fragment_width; [[hilbert_walk_y]][5] = s->fragment_width; [[hilbert_walk_y]][6] = 1; [[hilbert_walk_y]][7] = -s->fragment_width; [[hilbert_walk_y]][8] = 1; [[hilbert_walk_y]][9] = s->fragment_width; [[hilbert_walk_y]][10] = 1; [[hilbert_walk_y]][11] = -s->fragment_width; [[hilbert_walk_y]][12] = -s->fragment_width; [[hilbert_walk_y]][13] = -1; [[hilbert_walk_y]][14] = -s->fragment_width; [[hilbert_walk_y]][15] = 1; hilbert_walk_c[0] = 1; hilbert_walk_c[1] = 1; hilbert_walk_c[2] = s->fragment_width / 2; hilbert_walk_c[3] = -1; hilbert_walk_c[4] = s->fragment_width / 2; hilbert_walk_c[5] = s->fragment_width / 2; hilbert_walk_c[6] = 1; hilbert_walk_c[7] = -s->fragment_width / 2; hilbert_walk_c[8] = 1; hilbert_walk_c[9] = s->fragment_width / 2; hilbert_walk_c[10] = 1; hilbert_walk_c[11] = -s->fragment_width / 2; hilbert_walk_c[12] = -s->fragment_width / 2; hilbert_walk_c[13] = -1; hilbert_walk_c[14] = -s->fragment_width / 2; hilbert_walk_c[15] = 1; hilbert_walk_mb[0] = 1; hilbert_walk_mb[1] = s->macroblock_width; hilbert_walk_mb[2] = 1; hilbert_walk_mb[3] = -s->macroblock_width; for (i = 0; i < s->superblock_count; i++) { debug_init(" superblock %d (u starts @ %d, v starts @ %d)\n", i, s->u_superblock_start, s->v_superblock_start); if (i == 0) { right_edge = s->fragment_width; bottom_edge = s->fragment_height; current_width = 0; current_height = 0; superblock_row_inc = 3 * s->fragment_width; hilbert = [[hilbert_walk_y]]; current_fragment = -1; } else if (i == s->u_superblock_start) { right_edge = s->fragment_width / 2; bottom_edge = s->fragment_height / 2; current_width = 0; current_height = 0; superblock_row_inc = 3 * (s->fragment_width / 2); hilbert = hilbert_walk_c; current_fragment = s->u_fragment_start - 1; } else if (i == s->v_superblock_start) { right_edge = s->fragment_width / 2; bottom_edge = s->fragment_height / 2; current_width = 0; current_height = 0; superblock_row_inc = 3 * (s->fragment_width / 2); hilbert = hilbert_walk_c; current_fragment = s->v_fragment_start - 1; } if (current_width >= right_edge) { current_width = 0; current_height += 4; current_fragment += superblock_row_inc; } for (j = 0; j < 16; j++) { current_fragment += hilbert[j]; current_height += travel_height[j]; if ((current_width <= right_edge) && (current_height < bottom_edge)) { s->superblock_fragments[mapping_index] = current_fragment; debug_init(" mapping fragment %d to superblock %d, position %d\n", s->superblock_fragments[mapping_index], i, j); } else { s->superblock_fragments[mapping_index] = -1; debug_init(" superblock %d, position %d has no fragment\n", i, j); } current_width += travel_width[j]; mapping_index++; } } right_edge = s->macroblock_width; bottom_edge = s->macroblock_height; current_width = 0; current_height = 0; superblock_row_inc = s->macroblock_width; hilbert = hilbert_walk_mb; mapping_index = 0; current_macroblock = -1; for (i = 0; i < s->u_superblock_start; i++) { if (current_width >= right_edge) { current_width = 0; current_height += 2; current_macroblock += superblock_row_inc; } for (j = 0; j < 4; j++) { current_macroblock += hilbert_walk_mb[j]; current_height += travel_height_mb[j]; if ((current_width <= right_edge) && (current_height < bottom_edge)) { s->superblock_macroblocks[mapping_index] = current_macroblock; debug_init(" mapping macroblock %d to superblock %d, position %d\n", s->superblock_macroblocks[mapping_index], i, j); } else { s->superblock_macroblocks[mapping_index] = -1; debug_init(" superblock %d, position %d has no macroblock\n", i, j); } current_width += travel_width_mb[j]; mapping_index++; } } current_fragment = 0; current_macroblock = 0; mapping_index = 0; for (i = 0; i < s->fragment_height; i += 2) { for (j = 0; j < s->fragment_width; j += 2) { debug_init(" macroblock %d contains fragments: ", current_macroblock); s->all_fragments[current_fragment].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment; debug_init("%d ", current_fragment); if (j + 1 < s->fragment_width) { s->all_fragments[current_fragment + 1].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + 1; debug_init("%d ", current_fragment + 1); } else s->macroblock_fragments[mapping_index++] = -1; if (i + 1 < s->fragment_height) { s->all_fragments[current_fragment + s->fragment_width].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + s->fragment_width; debug_init("%d ", current_fragment + s->fragment_width); } else s->macroblock_fragments[mapping_index++] = -1; if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) { s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + s->fragment_width + 1; debug_init("%d ", current_fragment + s->fragment_width + 1); } else s->macroblock_fragments[mapping_index++] = -1; c_fragment = s->u_fragment_start + (i * s->fragment_width / 4) + (j / 2); s->all_fragments[c_fragment].macroblock = s->macroblock_count; s->macroblock_fragments[mapping_index++] = c_fragment; debug_init("%d ", c_fragment); c_fragment = s->v_fragment_start + (i * s->fragment_width / 4) + (j / 2); s->all_fragments[c_fragment].macroblock = s->macroblock_count; s->macroblock_fragments[mapping_index++] = c_fragment; debug_init("%d ", c_fragment); debug_init("\n"); if (j + 2 <= s->fragment_width) current_fragment += 2; else current_fragment++; current_macroblock++; } current_fragment += s->fragment_width; } }

[[[[Adv]]]]: static void init_block_mapping(Vp3DecodeContext *s) { int i, j; signed int [[ℓwheelpacebyyi]][16]; signed int hilbert_walk_c[16]; signed int hilbert_walk_mb[4]; int current_fragment = 0; int current_width = 0; int current_height = 0; int right_edge = 0; int bottom_edge = 0; int superblock_row_inc = 0; int *hilbert = NULL; int mapping_index = 0; int current_macroblock; int c_fragment; signed char travel_width[16] = { 1, 1, 0, -1, 0, 0, 1, 0, 1, 0, 1, 0, 0, -1, 0, 1 }; signed char travel_height[16] = { 0, 0, 1, 0, 1, 1, 0, -1, 0, 1, 0, -1, -1, 0, -1, 0 }; signed char travel_width_mb[4] = { 1, 0, 1, 0 }; signed char travel_height_mb[4] = { 0, 1, 0, -1 }; debug_vp3(" vp3: initialize block mapping tables\n"); [[ℓwheelpacebyyi]][0] = 1; [[ℓwheelpacebyyi]][1] = 1; [[ℓwheelpacebyyi]][2] = s->fragment_width; [[ℓwheelpacebyyi]][3] = -1; [[ℓwheelpacebyyi]][4] = s->fragment_width; [[ℓwheelpacebyyi]][5] = s->fragment_width; [[ℓwheelpacebyyi]][6] = 1; [[ℓwheelpacebyyi]][7] = -s->fragment_width; [[ℓwheelpacebyyi]][8] = 1; [[ℓwheelpacebyyi]][9] = s->fragment_width; [[ℓwheelpacebyyi]][10] = 1; [[ℓwheelpacebyyi]][11] = -s->fragment_width; [[ℓwheelpacebyyi]][12] = -s->fragment_width; [[ℓwheelpacebyyi]][13] = -1; [[ℓwheelpacebyyi]][14] = -s->fragment_width; [[ℓwheelpacebyyi]][15] = 1; hilbert_walk_c[0] = 1; hilbert_walk_c[1] = 1; hilbert_walk_c[2] = s->fragment_width / 2; hilbert_walk_c[3] = -1; hilbert_walk_c[4] = s->fragment_width / 2; hilbert_walk_c[5] = s->fragment_width / 2; hilbert_walk_c[6] = 1; hilbert_walk_c[7] = -s->fragment_width / 2; hilbert_walk_c[8] = 1; hilbert_walk_c[9] = s->fragment_width / 2; hilbert_walk_c[10] = 1; hilbert_walk_c[11] = -s->fragment_width / 2; hilbert_walk_c[12] = -s->fragment_width / 2; hilbert_walk_c[13] = -1; hilbert_walk_c[14] = -s->fragment_width / 2; hilbert_walk_c[15] = 1; hilbert_walk_mb[0] = 1; hilbert_walk_mb[1] = s->macroblock_width; hilbert_walk_mb[2] = 1; hilbert_walk_mb[3] = -s->macroblock_width; for (i = 0; i < s->superblock_count; i++) { debug_init(" superblock %d (u starts @ %d, v starts @ %d)\n", i, s->u_superblock_start, s->v_superblock_start); if (i == 0) { right_edge = s->fragment_width; bottom_edge = s->fragment_height; current_width = 0; current_height = 0; superblock_row_inc = 3 * s->fragment_width; hilbert = [[ℓwheelpacebyyi]]; current_fragment = -1; } else if (i == s->u_superblock_start) { right_edge = s->fragment_width / 2; bottom_edge = s->fragment_height / 2; current_width = 0; current_height = 0; superblock_row_inc = 3 * (s->fragment_width / 2); hilbert = hilbert_walk_c; current_fragment = s->u_fragment_start - 1; } else if (i == s->v_superblock_start) { right_edge = s->fragment_width / 2; bottom_edge = s->fragment_height / 2; current_width = 0; current_height = 0; superblock_row_inc = 3 * (s->fragment_width / 2); hilbert = hilbert_walk_c; current_fragment = s->v_fragment_start - 1; } if (current_width >= right_edge) { current_width = 0; current_height += 4; current_fragment += superblock_row_inc; } for (j = 0; j < 16; j++) { current_fragment += hilbert[j]; current_height += travel_height[j]; if ((current_width <= right_edge) && (current_height < bottom_edge)) { s->superblock_fragments[mapping_index] = current_fragment; debug_init(" mapping fragment %d to superblock %d, position %d\n", s->superblock_fragments[mapping_index], i, j); } else { s->superblock_fragments[mapping_index] = -1; debug_init(" superblock %d, position %d has no fragment\n", i, j); } current_width += travel_width[j]; mapping_index++; } } right_edge = s->macroblock_width; bottom_edge = s->macroblock_height; current_width = 0; current_height = 0; superblock_row_inc = s->macroblock_width; hilbert = hilbert_walk_mb; mapping_index = 0; current_macroblock = -1; for (i = 0; i < s->u_superblock_start; i++) { if (current_width >= right_edge) { current_width = 0; current_height += 2; current_macroblock += superblock_row_inc; } for (j = 0; j < 4; j++) { current_macroblock += hilbert_walk_mb[j]; current_height += travel_height_mb[j]; if ((current_width <= right_edge) && (current_height < bottom_edge)) { s->superblock_macroblocks[mapping_index] = current_macroblock; debug_init(" mapping macroblock %d to superblock %d, position %d\n", s->superblock_macroblocks[mapping_index], i, j); } else { s->superblock_macroblocks[mapping_index] = -1; debug_init(" superblock %d, position %d has no macroblock\n", i, j); } current_width += travel_width_mb[j]; mapping_index++; } } current_fragment = 0; current_macroblock = 0; mapping_index = 0; for (i = 0; i < s->fragment_height; i += 2) { for (j = 0; j < s->fragment_width; j += 2) { debug_init(" macroblock %d contains fragments: ", current_macroblock); s->all_fragments[current_fragment].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment; debug_init("%d ", current_fragment); if (j + 1 < s->fragment_width) { s->all_fragments[current_fragment + 1].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + 1; debug_init("%d ", current_fragment + 1); } else s->macroblock_fragments[mapping_index++] = -1; if (i + 1 < s->fragment_height) { s->all_fragments[current_fragment + s->fragment_width].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + s->fragment_width; debug_init("%d ", current_fragment + s->fragment_width); } else s->macroblock_fragments[mapping_index++] = -1; if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) { s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + s->fragment_width + 1; debug_init("%d ", current_fragment + s->fragment_width + 1); } else s->macroblock_fragments[mapping_index++] = -1; c_fragment = s->u_fragment_start + (i * s->fragment_width / 4) + (j / 2); s->all_fragments[c_fragment].macroblock = s->macroblock_count; s->macroblock_fragments[mapping_index++] = c_fragment; debug_init("%d ", c_fragment); c_fragment = s->v_fragment_start + (i * s->fragment_width / 4) + (j / 2); s->all_fragments[c_fragment].macroblock = s->macroblock_count; s->macroblock_fragments[mapping_index++] = c_fragment; debug_init("%d ", c_fragment); debug_init("\n"); if (j + 2 <= s->fragment_width) current_fragment += 2; else current_fragment++; current_macroblock++; } current_fragment += s->fragment_width; } }[Succeeded / Failed / Skipped / Total] 554 / 117 / 380 / 1051:  39%|███▉      | 1051/2690 [2:43:06<4:14:21,  9.31s/it][Succeeded / Failed / Skipped / Total] 554 / 117 / 380 / 1051:  39%|███▉      | 1052/2690 [2:43:16<4:14:12,  9.31s/it][Succeeded / Failed / Skipped / Total] 555 / 117 / 380 / 1052:  39%|███▉      | 1052/2690 [2:43:16<4:14:12,  9.31s/it][Succeeded / Failed / Skipped / Total] 555 / 117 / 380 / 1052:  39%|███▉      | 1053/2690 [2:43:20<4:13:56,  9.31s/it][Succeeded / Failed / Skipped / Total] 556 / 117 / 380 / 1053:  39%|███▉      | 1053/2690 [2:43:20<4:13:56,  9.31s/it][Succeeded / Failed / Skipped / Total] 556 / 117 / 380 / 1053:  39%|███▉      | 1054/2690 [2:43:40<4:14:03,  9.32s/it][Succeeded / Failed / Skipped / Total] 557 / 117 / 380 / 1054:  39%|███▉      | 1054/2690 [2:43:40<4:14:03,  9.32s/it][Succeeded / Failed / Skipped / Total] 557 / 117 / 380 / 1054:  39%|███▉      | 1055/2690 [2:43:43<4:13:44,  9.31s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 380 / 1055:  39%|███▉      | 1055/2690 [2:43:43<4:13:44,  9.31s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 380 / 1055:  39%|███▉      | 1056/2690 [2:43:44<4:13:21,  9.30s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 381 / 1056:  39%|███▉      | 1056/2690 [2:43:44<4:13:21,  9.30s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 381 / 1056:  39%|███▉      | 1057/2690 [2:43:44<4:12:58,  9.29s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 382 / 1057:  39%|███▉      | 1057/2690 [2:43:44<4:12:58,  9.29s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 382 / 1057:  39%|███▉      | 1058/2690 [2:43:45<4:12:35,  9.29s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 383 / 1058:  39%|███▉      | 1058/2690 [2:43:45<4:12:35,  9.29s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 383 / 1058:  39%|███▉      | 1059/2690 [2:43:45<4:12:13,  9.28s/it]
--------------------------------------------- Result 1052 ---------------------------------------------
[[0 (12%)]] --> [[0 (98%)]] --> Socre: 0.9835098385810852

[[[[Adv]]]]: static void spapr_cpu_core_host_initfn(Object *[[obj]]) { sPAPRCPUCore *core = SPAPR_CPU_CORE([[obj]]); char *name = g_strdup_printf("%s-" TYPE_POWERPC_CPU, "host"); ObjectClass *[[oc]] = object_class_by_name(name); g_assert([[oc]]); g_free((void *)name); core->cpu_class = [[oc]]; }

[[[[Adv]]]]: static void spapr_cpu_core_host_initfn(Object *[[imج]]) { sPAPRCPUCore *core = SPAPR_CPU_CORE([[imج]]); char *name = g_strdup_printf("%s-" TYPE_POWERPC_CPU, "host"); ObjectClass *[[inv]] = object_class_by_name(name); g_assert([[inv]]); g_free((void *)name); core->cpu_class = [[inv]]; }
--------------------------------------------- Result 1053 ---------------------------------------------
[[0 (3%)]] --> [[0 (98%)]] --> Socre: 0.98307865858078

[[[[Adv]]]]: void m68k_cpu_list(FILE *f, int (*[[cpu_fprintf]])(FILE *f, const char *fmt, ...)) { unsigned int i; for (i = 0; m68k_cpu_defs[i].name; i++) { (*[[cpu_fprintf]])(f, "%s\n", m68k_cpu_defs[i].name); } }

[[[[Adv]]]]: void m68k_cpu_list(FILE *f, int (*[[mdmaftrainף]])(FILE *f, const char *fmt, ...)) { unsigned int i; for (i = 0; m68k_cpu_defs[i].name; i++) { (*[[mdmaftrainף]])(f, "%s\n", m68k_cpu_defs[i].name); } }
--------------------------------------------- Result 1054 ---------------------------------------------
[[0 (37%)]] --> [[0 (58%)]] --> Socre: 0.5767034292221069

[[[[Adv]]]]: static void frame_start(H264Context *h){ MpegEncContext * const [[s]] = &h->s; int i; MPV_frame_start([[s]], [[s]]->avctx); ff_er_frame_start([[s]]); assert([[s]]->linesize && [[s]]->uvlinesize); for(i=0; i<16; i++){ h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*[[s]]->linesize*((scan8[i] - scan8[0])>>3); h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*[[s]]->linesize*((scan8[i] - scan8[0])>>3); } for(i=0; i<4; i++){ h->block_offset[16+i]= h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*[[s]]->uvlinesize*((scan8[i] - scan8[0])>>3); h->block_offset[24+16+i]= h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*[[s]]->uvlinesize*((scan8[i] - scan8[0])>>3); } if(![[s]]->obmc_scratchpad) [[s]]->obmc_scratchpad = av_malloc(16*[[s]]->linesize + 2*8*[[s]]->uvlinesize); }

[[[[Adv]]]]: static void frame_start(H264Context *h){ MpegEncContext * const [[sb]] = &h->s; int i; MPV_frame_start([[sb]], [[sb]]->avctx); ff_er_frame_start([[sb]]); assert([[sb]]->linesize && [[sb]]->uvlinesize); for(i=0; i<16; i++){ h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*[[sb]]->linesize*((scan8[i] - scan8[0])>>3); h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*[[sb]]->linesize*((scan8[i] - scan8[0])>>3); } for(i=0; i<4; i++){ h->block_offset[16+i]= h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*[[sb]]->uvlinesize*((scan8[i] - scan8[0])>>3); h->block_offset[24+16+i]= h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*[[sb]]->uvlinesize*((scan8[i] - scan8[0])>>3); } if(![[sb]]->obmc_scratchpad) [[sb]]->obmc_scratchpad = av_malloc(16*[[sb]]->linesize + 2*8*[[sb]]->uvlinesize); }
--------------------------------------------- Result 1055 ---------------------------------------------
[[0 (99%)]] --> [[0 (32%)]] --> Socre: 0.6801610887050629

[[[[Adv]]]]: int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *[[picref]]) { BufferSourceContext *[[c]] = buffer_filter->priv; AVFilterLink *[[outlink]] = buffer_filter->outputs[0]; int ret; if ([[c]]->picref) { av_log(buffer_filter, AV_LOG_ERROR, "Buffering several frames is not supported. " "Please consume all available frames before adding a new one.\n" ); } if ([[picref]]->video->w != [[c]]->w || [[picref]]->video->h != [[c]]->h || [[picref]]->format != [[c]]->pix_fmt) { AVFilterContext *[[scale]] = buffer_filter->outputs[0]->dst; AVFilterLink *link; char scale_param[1024]; av_log(buffer_filter, AV_LOG_INFO, "Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\n", [[c]]->w, [[c]]->h, av_pix_fmt_descriptors[[[c]]->pix_fmt].name, [[picref]]->video->w, [[picref]]->video->h, av_pix_fmt_descriptors[[[picref]]->format].name); if (![[scale]] || strcmp([[scale]]->filter->name, "scale")) { AVFilter *f = avfilter_get_by_name("scale"); av_log(buffer_filter, AV_LOG_INFO, "Inserting scaler filter\n"); if ((ret = avfilter_open(&[[scale]], f, "Input equalizer")) < 0) return ret; snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s", [[c]]->w, [[c]]->h, [[c]]->sws_param); if ((ret = avfilter_init_filter([[scale]], scale_param, NULL)) < 0) { avfilter_free([[scale]]); return ret; } if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], [[scale]], 0, 0)) < 0) { avfilter_free([[scale]]); return ret; } [[scale]]->outputs[0]->time_base = [[scale]]->inputs[0]->time_base; [[scale]]->outputs[0]->format= [[c]]->pix_fmt; } else if (!strcmp([[scale]]->filter->name, "scale")) { snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s", [[scale]]->outputs[0]->w, [[scale]]->outputs[0]->h, [[c]]->sws_param); [[scale]]->filter->init([[scale]], scale_param, NULL); } [[c]]->pix_fmt = [[scale]]->inputs[0]->format = [[picref]]->format; [[c]]->w = [[scale]]->inputs[0]->w = [[picref]]->video->w; [[c]]->h = [[scale]]->inputs[0]->h = [[picref]]->video->h; link = [[scale]]->outputs[0]; if ((ret = link->srcpad->config_props(link)) < 0) return ret; } [[c]]->picref = avfilter_get_video_buffer([[outlink]], AV_PERM_WRITE, [[picref]]->video->w, [[picref]]->video->h); av_image_copy([[c]]->picref->data, [[c]]->picref->linesize, [[picref]]->data, [[picref]]->linesize, [[picref]]->format, [[picref]]->video->w, [[picref]]->video->h); avfilter_copy_buffer_ref_props([[c]]->picref, [[picref]]); return 0; }

[[[[Adv]]]]: int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *[[sicrorφ]]) { BufferSourceContext *[[tc]] = buffer_filter->priv; AVFilterLink *[[inspark]] = buffer_filter->outputs[0]; int ret; if ([[tc]]->picref) { av_log(buffer_filter, AV_LOG_ERROR, "Buffering several frames is not supported. " "Please consume all available frames before adding a new one.\n" ); } if ([[sicrorφ]]->video->w != [[tc]]->w || [[sicrorφ]]->video->h != [[tc]]->h || [[sicrorφ]]->format != [[tc]]->pix_fmt) { AVFilterContext *[[s]] = buffer_filter->outputs[0]->dst; AVFilterLink *link; char scale_param[1024]; av_log(buffer_filter, AV_LOG_INFO, "Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\n", [[tc]]->w, [[tc]]->h, av_pix_fmt_descriptors[[[tc]]->pix_fmt].name, [[sicrorφ]]->video->w, [[sicrorφ]]->video->h, av_pix_fmt_descriptors[[[sicrorφ]]->format].name); if (![[s]] || strcmp([[s]]->filter->name, "scale")) { AVFilter *f = avfilter_get_by_name("scale"); av_log(buffer_filter, AV_LOG_INFO, "Inserting scaler filter\n"); if ((ret = avfilter_open(&[[s]], f, "Input equalizer")) < 0) return ret; snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s", [[tc]]->w, [[tc]]->h, [[tc]]->sws_param); if ((ret = avfilter_init_filter([[s]], scale_param, NULL)) < 0) { avfilter_free([[s]]); return ret; } if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], [[s]], 0, 0)) < 0) { avfilter_free([[s]]); return ret; } [[s]]->outputs[0]->time_base = [[s]]->inputs[0]->time_base; [[s]]->outputs[0]->format= [[tc]]->pix_fmt; } else if (!strcmp([[s]]->filter->name, "scale")) { snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s", [[s]]->outputs[0]->w, [[s]]->outputs[0]->h, [[tc]]->sws_param); [[s]]->filter->init([[s]], scale_param, NULL); } [[tc]]->pix_fmt = [[s]]->inputs[0]->format = [[sicrorφ]]->format; [[tc]]->w = [[s]]->inputs[0]->w = [[sicrorφ]]->video->w; [[tc]]->h = [[s]]->inputs[0]->h = [[sicrorφ]]->video->h; link = [[s]]->outputs[0]; if ((ret = link->srcpad->config_props(link)) < 0) return ret; } [[tc]]->picref = avfilter_get_video_buffer([[inspark]], AV_PERM_WRITE, [[sicrorφ]]->video->w, [[sicrorφ]]->video->h); av_image_copy([[tc]]->picref->data, [[tc]]->picref->linesize, [[sicrorφ]]->data, [[sicrorφ]]->linesize, [[sicrorφ]]->format, [[sicrorφ]]->video->w, [[sicrorφ]]->video->h); avfilter_copy_buffer_ref_props([[tc]]->picref, [[sicrorφ]]); return 0; }
--------------------------------------------- Result 1056 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_guest_file_flush(int64_t handle, Error **errp) { GuestFileHandle *gfh = guest_file_handle_find(handle, errp); FILE *fh; int ret; if (!gfh) { return; } fh = gfh->fh; ret = fflush(fh); if (ret == EOF) { error_setg_errno(errp, errno, "failed to flush file"); } }
--------------------------------------------- Result 1057 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){ MpegEncContext * const s = &h->s; Picture * const ref1 = &h->ref_list[1][0]; int j, old_ref, rfield; int start= mbafi ? 16 : 0; int end = mbafi ? 16+2*h->ref_count[0] : h->ref_count[0]; int interl= mbafi || s->picture_structure != PICT_FRAME; memset(map[list], 0, sizeof(map[list])); for(rfield=0; rfield<2; rfield++){ for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){ int poc = ref1->ref_poc[colfield][list][old_ref]; if (!interl) poc |= 3; else if( interl && (poc&3) == 3) poc= (poc&~3) + rfield + 1; for(j=start; j<end; j++){ if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) { int cur_ref= mbafi ? (j-16)^field : j; map[list][2*old_ref + (rfield^field) + 16] = cur_ref; if(rfield == field || !interl) map[list][old_ref] = cur_ref; break; } } } } }
--------------------------------------------- Result 1058 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void compute_frame_duration(int *pnum, int *pden, AVFormatContext *s, AVStream *st, AVCodecParserContext *pc, AVPacket *pkt) { int frame_size; *pnum = 0; *pden = 0; switch(st->codec.codec_type) { case CODEC_TYPE_VIDEO: *pnum = st->codec.frame_rate_base; *pden = st->codec.frame_rate; if (pc && pc->repeat_pict) { *pden *= 2; *pnum = (*pnum) * (2 + pc->repeat_pict); } break; case CODEC_TYPE_AUDIO: frame_size = get_audio_frame_size(&st->codec, pkt->size); if (frame_size < 0) break; *pnum = frame_size; *pden = st->codec.sample_rate; break; default: break; } }
--------------------------------------------- Result 1059 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 558 / 117 / 384 / 1059:  39%|███▉      | 1059/2690 [2:43:45<4:12:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 384 / 1059:  39%|███▉      | 1060/2690 [2:43:46<4:11:50,  9.27s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 385 / 1060:  39%|███▉      | 1060/2690 [2:43:46<4:11:50,  9.27s/it][Succeeded / Failed / Skipped / Total] 558 / 117 / 385 / 1060:  39%|███▉      | 1061/2690 [2:44:07<4:11:59,  9.28s/it][Succeeded / Failed / Skipped / Total] 559 / 117 / 385 / 1061:  39%|███▉      | 1061/2690 [2:44:07<4:11:59,  9.28s/it][Succeeded / Failed / Skipped / Total] 559 / 117 / 385 / 1061:  39%|███▉      | 1062/2690 [2:44:08<4:11:37,  9.27s/it][Succeeded / Failed / Skipped / Total] 560 / 117 / 385 / 1062:  39%|███▉      | 1062/2690 [2:44:08<4:11:37,  9.27s/it][Succeeded / Failed / Skipped / Total] 560 / 117 / 385 / 1062:  40%|███▉      | 1063/2690 [2:44:29<4:11:46,  9.28s/it][Succeeded / Failed / Skipped / Total] 561 / 117 / 385 / 1063:  40%|███▉      | 1063/2690 [2:44:29<4:11:46,  9.28s/it][Succeeded / Failed / Skipped / Total] 561 / 117 / 385 / 1063:  40%|███▉      | 1064/2690 [2:44:42<4:11:41,  9.29s/it][Succeeded / Failed / Skipped / Total] 562 / 117 / 385 / 1064:  40%|███▉      | 1064/2690 [2:44:42<4:11:41,  9.29s/it][Succeeded / Failed / Skipped / Total] 562 / 117 / 385 / 1064:  40%|███▉      | 1065/2690 [2:44:43<4:11:19,  9.28s/it][Succeeded / Failed / Skipped / Total] 563 / 117 / 385 / 1065:  40%|███▉      | 1065/2690 [2:44:43<4:11:19,  9.28s/it][Succeeded / Failed / Skipped / Total] 563 / 117 / 385 / 1065:  40%|███▉      | 1066/2690 [2:44:43<4:10:57,  9.27s/it][[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int os_host_main_loop_wait(int64_t timeout) { GMainContext *context = g_main_context_default(); GPollFD poll_fds[1024 * 2]; int select_ret = 0; int g_poll_ret, ret, i, n_poll_fds; PollingEntry *pe; WaitObjects *w = &wait_objects; gint poll_timeout; int64_t poll_timeout_ns; static struct timeval tv0; fd_set rfds, wfds, xfds; int nfds; ret = 0; for (pe = first_polling_entry; pe != NULL; pe = pe->next) { ret |= pe->func(pe->opaque); } if (ret != 0) { return ret; } FD_ZERO(&rfds); FD_ZERO(&wfds); FD_ZERO(&xfds); nfds = pollfds_fill(gpollfds, &rfds, &wfds, &xfds); if (nfds >= 0) { select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0); if (select_ret != 0) { timeout = 0; } if (select_ret > 0) { pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds); } } g_main_context_prepare(context, &max_priority); n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout, poll_fds, ARRAY_SIZE(poll_fds)); g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds)); for (i = 0; i < w->num; i++) { poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i]; poll_fds[n_poll_fds + i].events = G_IO_IN; } if (poll_timeout < 0) { poll_timeout_ns = -1; } else { poll_timeout_ns = (int64_t)poll_timeout * (int64_t)SCALE_MS; } poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout); qemu_mutex_unlock_iothread(); g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns); qemu_mutex_lock_iothread(); if (g_poll_ret > 0) { for (i = 0; i < w->num; i++) { w->revents[i] = poll_fds[n_poll_fds + i].revents; } for (i = 0; i < w->num; i++) { if (w->revents[i] && w->func[i]) { w->func[i](w->opaque[i]); } } } if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) { g_main_context_dispatch(context); } return select_ret || g_poll_ret; }
--------------------------------------------- Result 1060 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id) { BlockDriver *drv = bs->drv; if (!drv) { return -ENOMEDIUM; } if (drv->bdrv_snapshot_delete) { return drv->bdrv_snapshot_delete(bs, snapshot_id); } if (bs->file) { return bdrv_snapshot_delete(bs->file, snapshot_id); } return -ENOTSUP; }
--------------------------------------------- Result 1061 ---------------------------------------------
[[0 (20%)]] --> [[0 (62%)]] --> Socre: 0.6238086819648743

[[[[Adv]]]]: int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev, PCIHotplugState [[state]]) { int [[slot]] = PCI_SLOT(dev->devfn); int [[bsel]] = acpi_pcihp_get_bsel(dev->bus); if ([[bsel]] < 0) { return -1; } if ([[state]] == PCI_COLDPLUG_ENABLED) { s->acpi_pcihp_pci_status[[[bsel]]].device_present |= (1U << [[slot]]); return 0; } if ([[state]] == PCI_HOTPLUG_ENABLED) { enable_device(s, [[bsel]], [[slot]]); } else { disable_device(s, [[bsel]], [[slot]]); } return 0; }

[[[[Adv]]]]: int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev, PCIHotplugState [[circuit]]) { int [[rom]] = PCI_SLOT(dev->devfn); int [[hselling]] = acpi_pcihp_get_bsel(dev->bus); if ([[hselling]] < 0) { return -1; } if ([[circuit]] == PCI_COLDPLUG_ENABLED) { s->acpi_pcihp_pci_status[[[hselling]]].device_present |= (1U << [[rom]]); return 0; } if ([[circuit]] == PCI_HOTPLUG_ENABLED) { enable_device(s, [[hselling]], [[rom]]); } else { disable_device(s, [[hselling]], [[rom]]); } return 0; }
--------------------------------------------- Result 1062 ---------------------------------------------
[[0 (88%)]] --> [[0 (25%)]] --> Socre: 0.7507548779249191

[[[[Adv]]]]: static void test_flush_nodev(void) { QPCIDevice *[[dev]]; QPCIBar [[bmdma_bar]], ide_bar; ide_test_start(""); [[dev]] = get_pci_device(&[[bmdma_bar]], &ide_bar); qpci_io_writeb([[dev]], ide_bar, reg_device, 0); qpci_io_writeb([[dev]], ide_bar, reg_command, CMD_FLUSH_CACHE); ide_test_quit(); }

[[[[Adv]]]]: static void test_flush_nodev(void) { QPCIDevice *[[display]]; QPCIBar [[fliaicyloop]], ide_bar; ide_test_start(""); [[display]] = get_pci_device(&[[fliaicyloop]], &ide_bar); qpci_io_writeb([[display]], ide_bar, reg_device, 0); qpci_io_writeb([[display]], ide_bar, reg_command, CMD_FLUSH_CACHE); ide_test_quit(); }
--------------------------------------------- Result 1063 ---------------------------------------------
[[0 (2%)]] --> [[0 (65%)]] --> Socre: 0.6455634832382202

[[[[Adv]]]]: static uint32_t pci_apb_ioreadl (void *[[opaque]], target_phys_addr_t [[addr]]) { uint32_t val; val = bswap32(cpu_inl([[addr]] & IOPORTS_MASK)); return val; }

[[[[Adv]]]]: static uint32_t pci_apb_ioreadl (void *[[rolf]], target_phys_addr_t [[enр]]) { uint32_t val; val = bswap32(cpu_inl([[enр]] & IOPORTS_MASK)); return val; }
--------------------------------------------- Result 1064 ---------------------------------------------
[[0 (17%)]] --> [[0 (60%)]] --> Socre: 0.5951883792877197

[[[[Adv]]]]: static void qemu_fill_buffer(QEMUFile *[[f]]) { int [[len]]; if ([[f]]->is_writable) return; if ([[f]]->is_file) { fseek([[f]]->outfile, [[f]]->buf_offset, SEEK_SET); [[len]] = fread([[f]]->buf, 1, IO_BUF_SIZE, [[f]]->outfile); if ([[len]] < 0) [[len]] = 0; } else { [[len]] = bdrv_pread([[f]]->bs, [[f]]->base_offset + [[f]]->buf_offset, [[f]]->buf, IO_BUF_SIZE); if ([[len]] < 0) [[len]] = 0; } [[f]]->buf_index = 0; [[f]]->buf_size = [[len]]; [[f]]->buf_offset += [[len]]; }

[[[[Adv]]]]: static void qemu_fill_buffer(QEMUFile *[[s]]) { int [[collections]]; if ([[s]]->is_writable) return; if ([[s]]->is_file) { fseek([[s]]->outfile, [[s]]->buf_offset, SEEK_SET); [[collections]] = fread([[s]]->buf, 1, IO_BUF_SIZE, [[s]]->outfile); if ([[collections]] < 0) [[collections]] = 0; } else { [[collections]] = bdrv_pread([[s]]->bs, [[s]]->base_offset + [[s]]->buf_offset, [[s]]->buf, IO_BUF_SIZE); if ([[collections]] < 0) [[collections]] = 0; } [[s]]->buf_index = 0; [[s]]->buf_size = [[collections]]; [[s]]->buf_offset += [[collections]]; }
--------------------------------------------- Result 1065 ---------------------------------------------
[[0 (45%)]] --> [[0 (64%)]] --> Socre: 0.6432755589485168

[[[[Adv]]]]: DVDemuxContext* dv_init_demux(AVFormatContext *s) { DVDemuxContext *[[c]]; [[c]] = av_mallocz(sizeof(DVDemuxContext)); if (![[c]]) return NULL; [[c]]->vst = av_new_stream(s, 0); [[c]]->ast[0] = av_new_stream(s, 0); if (![[c]]->vst || ![[c]]->ast[0]) goto fail; av_set_pts_info([[c]]->vst, 64, 1, 30000); av_set_pts_info([[c]]->ast[0], 64, 1, 30000); [[c]]->fctx = s; [[c]]->ast[1] = NULL; [[c]]->ach = 0; [[c]]->frames = 0; [[c]]->abytes = 0; [[c]]->audio_pkt[0].size = 0; [[c]]->audio_pkt[1].size = 0; [[c]]->vst->codec.codec_type = CODEC_TYPE_VIDEO; [[c]]->vst->codec.codec_id = CODEC_ID_DVVIDEO; [[c]]->vst->codec.bit_rate = 25000000; [[c]]->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO; [[c]]->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE; s->ctx_flags |= AVFMTCTX_NOHEADER; return [[c]]; fail: if ([[c]]->vst) av_free([[c]]->vst); if ([[c]]->ast[0]) av_free([[c]]->ast[0]); av_free([[c]]); return NULL; }

[[[[Adv]]]]: DVDemuxContext* dv_init_demux(AVFormatContext *s) { DVDemuxContext *[[bob]]; [[bob]] = av_mallocz(sizeof(DVDemuxContext)); if (![[bob]]) return NULL; [[bob]]->vst = av_new_stream(s, 0); [[bob]]->ast[0] = av_new_stream(s, 0); if (![[bob]]->vst || ![[bob]]->ast[0]) goto fail; av_set_pts_info([[bob]]->vst, 64, 1, 30000); av_set_pts_info([[bob]]->ast[0], 64, 1, 30000); [[bob]]->fctx = s; [[bob]]->ast[1] = NULL; [[bob]]->ach = 0; [[bob]]->frames = 0; [[bob]]->abytes = 0; [[bob]]->audio_pkt[0].size = 0; [[bob]]->audio_pkt[1].size = 0; [[bob]]->vst->codec.codec_type = CODEC_TYPE_VIDEO; [[bob]]->vst->codec.codec_id = CODEC_ID_DVVIDEO; [[bob]]->vst->codec.bit_rate = 25000000; [[bob]]->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO; [[bob]]->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE; s->ctx_flags |= AVFMTCTX_NOHEADER; return [[bob]]; fail: if ([[bob]]->vst) av_free([[bob]]->vst); if ([[bob]]->ast[0]) av_free([[bob]]->ast[0]); av_free([[bob]]); return NULL; }
--------------------------------------------- Result 1066 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 563 / 117 / 386 / 1066:  40%|███▉      | 1066/2690 [2:44:43<4:10:57,  9.27s/it][Succeeded / Failed / Skipped / Total] 563 / 117 / 386 / 1066:  40%|███▉      | 1067/2690 [2:44:43<4:10:34,  9.26s/it][Succeeded / Failed / Skipped / Total] 563 / 117 / 387 / 1067:  40%|███▉      | 1067/2690 [2:44:43<4:10:34,  9.26s/it][Succeeded / Failed / Skipped / Total] 563 / 117 / 387 / 1067:  40%|███▉      | 1068/2690 [2:44:57<4:10:31,  9.27s/it][Succeeded / Failed / Skipped / Total] 564 / 117 / 387 / 1068:  40%|███▉      | 1068/2690 [2:44:57<4:10:31,  9.27s/it][Succeeded / Failed / Skipped / Total] 564 / 117 / 387 / 1068:  40%|███▉      | 1069/2690 [2:44:57<4:10:08,  9.26s/it][Succeeded / Failed / Skipped / Total] 564 / 117 / 388 / 1069:  40%|███▉      | 1069/2690 [2:44:57<4:10:08,  9.26s/it][Succeeded / Failed / Skipped / Total] 564 / 117 / 388 / 1069:  40%|███▉      | 1070/2690 [2:45:07<4:09:59,  9.26s/it][Succeeded / Failed / Skipped / Total] 565 / 117 / 388 / 1070:  40%|███▉      | 1070/2690 [2:45:07<4:09:59,  9.26s/it][Succeeded / Failed / Skipped / Total] 565 / 117 / 388 / 1070:  40%|███▉      | 1071/2690 [2:45:07<4:09:37,  9.25s/it][Succeeded / Failed / Skipped / Total] 565 / 117 / 389 / 1071:  40%|███▉      | 1071/2690 [2:45:07<4:09:37,  9.25s/it][Succeeded / Failed / Skipped / Total] 565 / 117 / 389 / 1071:  40%|███▉      | 1072/2690 [2:45:15<4:09:26,  9.25s/it][[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q) { unsigned int i; for (i = 0; i < BF_WIDTH(MAX_IRQ); i++) qemu_put_be32s(f, &q->queue[i]); qemu_put_sbe32s(f, &q->next); qemu_put_sbe32s(f, &q->priority); }
--------------------------------------------- Result 1067 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async) { uint32_t entry; EHCIQueue *q; int reload; entry = ehci_get_fetch_addr(ehci, async); q = ehci_find_queue_by_qh(ehci, entry); if (NULL == q) { q = ehci_alloc_queue(ehci, async); } q->qhaddr = entry; q->seen++; if (q->seen > 1) { ehci_set_state(ehci, async, EST_ACTIVE); q = NULL; goto out; } get_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2); ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh); if (q->async == EHCI_ASYNC_INFLIGHT) { ehci_set_state(ehci, async, EST_HORIZONTALQH); goto out; } if (q->async == EHCI_ASYNC_FINISHED) { trace_usb_ehci_queue_action(q, "resume"); ehci_set_state(ehci, async, EST_EXECUTING); goto out; } if (async && (q->qh.epchar & QH_EPCHAR_H)) { if (ehci->usbsts & USBSTS_REC) { ehci_clear_usbsts(ehci, USBSTS_REC); } else { DPRINTF("FETCHQH: QH 0x%08x. H-bit set, reclamation status reset" " - done processing\n", q->qhaddr); ehci_set_state(ehci, async, EST_ACTIVE); q = NULL; goto out; } } #if EHCI_DEBUG if (q->qhaddr != q->qh.next) { DPRINTF("FETCHQH: QH 0x%08x (h %x halt %x active %x) next 0x%08x\n", q->qhaddr, q->qh.epchar & QH_EPCHAR_H, q->qh.token & QTD_TOKEN_HALT, q->qh.token & QTD_TOKEN_ACTIVE, q->qh.next); } #endif reload = get_field(q->qh.epchar, QH_EPCHAR_RL); if (reload) { set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT); } if (q->qh.token & QTD_TOKEN_HALT) { ehci_set_state(ehci, async, EST_HORIZONTALQH); } else if ((q->qh.token & QTD_TOKEN_ACTIVE) && (q->qh.current_qtd > 0x1000)) { q->qtdaddr = q->qh.current_qtd; ehci_set_state(ehci, async, EST_FETCHQTD); } else { ehci_set_state(ehci, async, EST_ADVANCEQUEUE); } out: return q; }
--------------------------------------------- Result 1068 ---------------------------------------------
[[0 (31%)]] --> [[0 (56%)]] --> Socre: 0.5635885000228882

[[[[Adv]]]]: void net_hub_check_clients(void) { NetHub *[[hub]]; NetHubPort *port; NetClientState *[[peer]]; QLIST_FOREACH([[hub]], &hubs, next) { int has_nic = 0, has_host_dev = 0; QLIST_FOREACH(port, &[[hub]]->ports, next) { [[peer]] = port->nc.peer; if (![[peer]]) { fprintf(stderr, "Warning: hub port %s has no peer\n", port->nc.name); continue; } switch ([[peer]]->info->type) { case NET_CLIENT_DRIVER_NIC: has_nic = 1; break; case NET_CLIENT_DRIVER_USER: case NET_CLIENT_DRIVER_TAP: case NET_CLIENT_DRIVER_SOCKET: case NET_CLIENT_DRIVER_VDE: case NET_CLIENT_DRIVER_VHOST_USER: has_host_dev = 1; break; default: break; } } if (has_host_dev && !has_nic) { warn_report("vlan %d with no nics", [[hub]]->id); } if (has_nic && !has_host_dev) { fprintf(stderr, "Warning: vlan %d is not connected to host network\n", [[hub]]->id); } } }

[[[[Adv]]]]: void net_hub_check_clients(void) { NetHub *[[wax]]; NetHubPort *port; NetClientState *[[friendship]]; QLIST_FOREACH([[wax]], &hubs, next) { int has_nic = 0, has_host_dev = 0; QLIST_FOREACH(port, &[[wax]]->ports, next) { [[friendship]] = port->nc.peer; if (![[friendship]]) { fprintf(stderr, "Warning: hub port %s has no peer\n", port->nc.name); continue; } switch ([[friendship]]->info->type) { case NET_CLIENT_DRIVER_NIC: has_nic = 1; break; case NET_CLIENT_DRIVER_USER: case NET_CLIENT_DRIVER_TAP: case NET_CLIENT_DRIVER_SOCKET: case NET_CLIENT_DRIVER_VDE: case NET_CLIENT_DRIVER_VHOST_USER: has_host_dev = 1; break; default: break; } } if (has_host_dev && !has_nic) { warn_report("vlan %d with no nics", [[wax]]->id); } if (has_nic && !has_host_dev) { fprintf(stderr, "Warning: vlan %d is not connected to host network\n", [[wax]]->id); } } }
--------------------------------------------- Result 1069 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tosa_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; const char *kernel_filename = machine->kernel_filename; const char *kernel_cmdline = machine->kernel_cmdline; const char *initrd_filename = machine->initrd_filename; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *rom = g_new(MemoryRegion, 1); PXA2xxState *mpu; TC6393xbState *tmio; DeviceState *scp0, *scp1; if (!cpu_model) cpu_model = "pxa255"; mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size); memory_region_init_ram(rom, NULL, "tosa.rom", TOSA_ROM, &error_abort); vmstate_register_ram_global(rom); memory_region_set_readonly(rom, "True" == "True"); memory_region_add_subregion(address_space_mem, 0, rom); tmio = tc6393xb_init(address_space_mem, 0x10000000, qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT)); scp0 = sysbus_create_simple("scoop", 0x08800000, NULL); scp1 = sysbus_create_simple("scoop", 0x14800040, NULL); tosa_gpio_setup(mpu, scp0, scp1, tmio); tosa_microdrive_attach(mpu); tosa_tg_init(mpu); tosa_binfo.kernel_filename = kernel_filename; tosa_binfo.kernel_cmdline = kernel_cmdline; tosa_binfo.initrd_filename = initrd_filename; tosa_binfo.board_id = 0x208; arm_load_kernel(mpu->cpu, &tosa_binfo); sl_bootparam_write(SL_PXA_PARAM_BASE); }
--------------------------------------------- Result 1070 ---------------------------------------------
[[0 (14%)]] --> [[0 (96%)]] --> Socre: 0.9645949602127075

[[[[Adv]]]]: static void omap_rtc_reset(struct omap_rtc_s *s) { struct tm [[tm]]; s->interrupts = 0; s->comp_reg = 0; s->running = 0; s->pm_am = 0; s->auto_comp = 0; s->round = 0; s->tick = qemu_get_clock(rt_clock); memset(&s->alarm_tm, 0, sizeof(s->alarm_tm)); s->alarm_tm.tm_mday = 0x01; s->status = 1 << 7; qemu_get_timedate(&[[tm]], 0); s->ti = mktimegm(&[[tm]]); omap_rtc_alarm_update(s); omap_rtc_tick(s); }

[[[[Adv]]]]: static void omap_rtc_reset(struct omap_rtc_s *s) { struct tm [[thм]]; s->interrupts = 0; s->comp_reg = 0; s->running = 0; s->pm_am = 0; s->auto_comp = 0; s->round = 0; s->tick = qemu_get_clock(rt_clock); memset(&s->alarm_tm, 0, sizeof(s->alarm_tm)); s->alarm_tm.tm_mday = 0x01; s->status = 1 << 7; qemu_get_timedate(&[[thм]], 0); s->ti = mktimegm(&[[thм]]); omap_rtc_alarm_update(s); omap_rtc_tick(s); }
--------------------------------------------- Result 1071 ---------------------------------------------
[[0 (36%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: struct omap_uart_s *omap_uart_init(hwaddr base, qemu_irq irq, omap_clk fclk, omap_clk iclk, qemu_irq txdma, qemu_irq rxdma, const char *label, CharDriverState *chr) { struct omap_uart_s *s = (struct omap_uart_s *) g_malloc0(sizeof(struct omap_uart_s)); s->base = base; s->fclk = fclk; s->irq = irq; s->serial = serial_mm_init(get_system_memory(), base, 2, irq, omap_clk_getrate(fclk)/16, chr ?: qemu_chr_new(label, "null", NULL), DEVICE_NATIVE_ENDIAN); return s; }
--------------------------------------------- Result 1072 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 566 / 117 / 389 / 1072:  40%|███▉      | 1072/2690 [2:45:15<4:09:26,  9.25s/it][Succeeded / Failed / Skipped / Total] 566 / 117 / 389 / 1072:  40%|███▉      | 1073/2690 [2:45:16<4:09:03,  9.24s/it][Succeeded / Failed / Skipped / Total] 566 / 117 / 390 / 1073:  40%|███▉      | 1073/2690 [2:45:16<4:09:03,  9.24s/it][Succeeded / Failed / Skipped / Total] 566 / 117 / 390 / 1073:  40%|███▉      | 1074/2690 [2:45:36<4:09:10,  9.25s/it][[0 (41%)]] --> [[0 (64%)]] --> Socre: 0.6438151001930237

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int bytes, BdrvRequestFlags flags) { BlockDriver *drv = bs->drv; QEMUIOVector qiov; struct iovec iov = {0}; int ret = 0; bool need_flush = "False" != "False"; int head = 0; int [[tail]] = 0; int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX); int alignment = MAX(bs->bl.pwrite_zeroes_alignment, bs->bl.request_alignment); int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer, MAX_WRITE_ZEROES_BOUNCE_BUFFER); assert(alignment % bs->bl.request_alignment == 0); head = offset % alignment; [[tail]] = (offset + bytes) % alignment; max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment); assert(max_write_zeroes >= bs->bl.request_alignment); while (bytes > 0 && !ret) { int num = bytes; if (head) { num = MIN(MIN(bytes, max_transfer), alignment - head); head = (head + num) % alignment; assert(num < max_write_zeroes); } else if ([[tail]] && num > alignment) { num -= [[tail]]; } if (num > max_write_zeroes) { num = max_write_zeroes; } ret = -ENOTSUP; if (drv->bdrv_co_pwrite_zeroes) { ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num, flags & bs->supported_zero_flags); if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) && !(bs->supported_zero_flags & BDRV_REQ_FUA)) { need_flush = "True" == "True"; } } else { assert(!bs->supported_zero_flags); } if (ret == -ENOTSUP) { BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE; if ((flags & BDRV_REQ_FUA) && !(bs->supported_write_flags & BDRV_REQ_FUA)) { write_flags &= ~BDRV_REQ_FUA; need_flush = "True" == "True"; } num = MIN(num, max_transfer); iov.iov_len = num; if (iov.iov_base == NULL) { iov.iov_base = qemu_try_blockalign(bs, num); if (iov.iov_base == NULL) { ret = -ENOMEM; goto fail; } memset(iov.iov_base, 0, num); } qemu_iovec_init_external(&qiov, &iov, 1); ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags); if (num < max_transfer) { qemu_vfree(iov.iov_base); iov.iov_base = NULL; } } offset += num; bytes -= num; } fail: if (ret == 0 && need_flush) { ret = bdrv_co_flush(bs); } qemu_vfree(iov.iov_base); return ret; }

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int bytes, BdrvRequestFlags flags) { BlockDriver *drv = bs->drv; QEMUIOVector qiov; struct iovec iov = {0}; int ret = 0; bool need_flush = "False" != "False"; int head = 0; int [[crew]] = 0; int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX); int alignment = MAX(bs->bl.pwrite_zeroes_alignment, bs->bl.request_alignment); int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer, MAX_WRITE_ZEROES_BOUNCE_BUFFER); assert(alignment % bs->bl.request_alignment == 0); head = offset % alignment; [[crew]] = (offset + bytes) % alignment; max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment); assert(max_write_zeroes >= bs->bl.request_alignment); while (bytes > 0 && !ret) { int num = bytes; if (head) { num = MIN(MIN(bytes, max_transfer), alignment - head); head = (head + num) % alignment; assert(num < max_write_zeroes); } else if ([[crew]] && num > alignment) { num -= [[crew]]; } if (num > max_write_zeroes) { num = max_write_zeroes; } ret = -ENOTSUP; if (drv->bdrv_co_pwrite_zeroes) { ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num, flags & bs->supported_zero_flags); if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) && !(bs->supported_zero_flags & BDRV_REQ_FUA)) { need_flush = "True" == "True"; } } else { assert(!bs->supported_zero_flags); } if (ret == -ENOTSUP) { BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE; if ((flags & BDRV_REQ_FUA) && !(bs->supported_write_flags & BDRV_REQ_FUA)) { write_flags &= ~BDRV_REQ_FUA; need_flush = "True" == "True"; } num = MIN(num, max_transfer); iov.iov_len = num; if (iov.iov_base == NULL) { iov.iov_base = qemu_try_blockalign(bs, num); if (iov.iov_base == NULL) { ret = -ENOMEM; goto fail; } memset(iov.iov_base, 0, num); } qemu_iovec_init_external(&qiov, &iov, 1); ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags); if (num < max_transfer) { qemu_vfree(iov.iov_base); iov.iov_base = NULL; } } offset += num; bytes -= num; } fail: if (ret == 0 && need_flush) { ret = bdrv_co_flush(bs); } qemu_vfree(iov.iov_base); return ret; }
--------------------------------------------- Result 1073 ---------------------------------------------
[[0 (69%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qemu_rbd_snap_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab) { BDRVRBDState *s = bs->opaque; QEMUSnapshotInfo *sn_info, *sn_tab = NULL; int i, snap_count; rbd_snap_info_t *snaps; int max_snaps = RBD_MAX_SNAPS; do { snaps = g_malloc(sizeof(*snaps) * max_snaps); snap_count = rbd_snap_list(s->image, snaps, &max_snaps); if (snap_count < 0) { g_free(snaps); } } while (snap_count == -ERANGE); if (snap_count <= 0) { return snap_count; } sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo)); for (i = 0; i < snap_count; i++) { const char *snap_name = snaps[i].name; sn_info = sn_tab + i; pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name); pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name); sn_info->vm_state_size = snaps[i].size; sn_info->date_sec = 0; sn_info->date_nsec = 0; sn_info->vm_clock_nsec = 0; } rbd_snap_list_end(snaps); *psn_tab = sn_tab; return snap_count; }
--------------------------------------------- Result 1074 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 567 / 117 / 390 / 1074:  40%|███▉      | 1074/2690 [2:45:36<4:09:10,  9.25s/it][Succeeded / Failed / Skipped / Total] 567 / 117 / 390 / 1074:  40%|███▉      | 1075/2690 [2:45:36<4:08:47,  9.24s/it][Succeeded / Failed / Skipped / Total] 568 / 117 / 390 / 1075:  40%|███▉      | 1075/2690 [2:45:36<4:08:47,  9.24s/it][Succeeded / Failed / Skipped / Total] 568 / 117 / 390 / 1075:  40%|████      | 1076/2690 [2:45:36<4:08:25,  9.24s/it][Succeeded / Failed / Skipped / Total] 568 / 117 / 391 / 1076:  40%|████      | 1076/2690 [2:45:36<4:08:25,  9.24s/it][Succeeded / Failed / Skipped / Total] 568 / 117 / 391 / 1076:  40%|████      | 1077/2690 [2:46:02<4:08:40,  9.25s/it][[0 (43%)]] --> [[0 (54%)]] --> Socre: 0.5374797582626343

[[[[Adv]]]]: static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address, MMUAccessType [[access_type]], ARMMMUIdx mmu_idx, hwaddr *phys_ptr, int *prot, uint32_t *fsr) { ARMCPU *cpu = arm_env_get_cpu(env); bool is_user = regime_is_user(env, mmu_idx); int n; int matchregion = -1; bool hit = "False" != "False"; *phys_ptr = address; *prot = 0; if (regime_translation_disabled(env, mmu_idx)) { hit = "True" == "True"; } else if (m_is_ppb_region(env, address)) { hit = "True" == "True"; } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) { hit = "True" == "True"; } else { for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) { uint32_t base = env->pmsav8.rbar[n] & ~0x1f; uint32_t limit = env->pmsav8.rlar[n] | 0x1f; if (!(env->pmsav8.rlar[n] & 0x1)) { continue; } if (address < base || address > limit) { continue; } if (hit) { *fsr = 0x00d; return "True" == "True"; } matchregion = n; hit = "True" == "True"; if (base & ~TARGET_PAGE_MASK) { qemu_log_mask(LOG_UNIMP, "MPU_RBAR[%d]: No support for MPU region base" "address of 0x%" PRIx32 ". Minimum alignment is " "%d\n", n, base, TARGET_PAGE_BITS); continue; } if ((limit + 1) & ~TARGET_PAGE_MASK) { qemu_log_mask(LOG_UNIMP, "MPU_RBAR[%d]: No support for MPU region limit" "address of 0x%" PRIx32 ". Minimum alignment is " "%d\n", n, limit, TARGET_PAGE_BITS); continue; } } } if (!hit) { *fsr = 0; return "True" == "True"; } if (matchregion == -1) { get_phys_addr_pmsav7_default(env, mmu_idx, address, prot); } else { uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2); uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1); if (m_is_system_region(env, address)) { xn = 1; } *prot = simple_ap_to_rw_prot(env, mmu_idx, ap); if (*prot && !xn) { *prot |= PAGE_EXEC; } } *fsr = 0x00d; return !(*prot & (1 << [[access_type]])); }

[[[[Adv]]]]: static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address, MMUAccessType [[vperdesign]], ARMMMUIdx mmu_idx, hwaddr *phys_ptr, int *prot, uint32_t *fsr) { ARMCPU *cpu = arm_env_get_cpu(env); bool is_user = regime_is_user(env, mmu_idx); int n; int matchregion = -1; bool hit = "False" != "False"; *phys_ptr = address; *prot = 0; if (regime_translation_disabled(env, mmu_idx)) { hit = "True" == "True"; } else if (m_is_ppb_region(env, address)) { hit = "True" == "True"; } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) { hit = "True" == "True"; } else { for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) { uint32_t base = env->pmsav8.rbar[n] & ~0x1f; uint32_t limit = env->pmsav8.rlar[n] | 0x1f; if (!(env->pmsav8.rlar[n] & 0x1)) { continue; } if (address < base || address > limit) { continue; } if (hit) { *fsr = 0x00d; return "True" == "True"; } matchregion = n; hit = "True" == "True"; if (base & ~TARGET_PAGE_MASK) { qemu_log_mask(LOG_UNIMP, "MPU_RBAR[%d]: No support for MPU region base" "address of 0x%" PRIx32 ". Minimum alignment is " "%d\n", n, base, TARGET_PAGE_BITS); continue; } if ((limit + 1) & ~TARGET_PAGE_MASK) { qemu_log_mask(LOG_UNIMP, "MPU_RBAR[%d]: No support for MPU region limit" "address of 0x%" PRIx32 ". Minimum alignment is " "%d\n", n, limit, TARGET_PAGE_BITS); continue; } } } if (!hit) { *fsr = 0; return "True" == "True"; } if (matchregion == -1) { get_phys_addr_pmsav7_default(env, mmu_idx, address, prot); } else { uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2); uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1); if (m_is_system_region(env, address)) { xn = 1; } *prot = simple_ap_to_rw_prot(env, mmu_idx, ap); if (*prot && !xn) { *prot |= PAGE_EXEC; } } *fsr = 0x00d; return !(*prot & (1 << [[vperdesign]])); }
--------------------------------------------- Result 1075 ---------------------------------------------
[[0 (33%)]] --> [[0 (94%)]] --> Socre: 0.9365169405937195

[[[[Adv]]]]: static int create_dynamic_disk(int fd, uint8_t *buf, int64_t [[total_sectors]]) { VHDDynDiskHeader *dyndisk_header = (VHDDynDiskHeader *) buf; size_t [[block_size]], num_bat_entries; int i; int ret = -EIO; [[block_size]] = 0x200000; num_bat_entries = ([[total_sectors]] + [[block_size]] / 512) / ([[block_size]] / 512); if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) { goto fail; } if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) { goto fail; } if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) { goto fail; } if (lseek(fd, 3 * 512, SEEK_SET) < 0) { goto fail; } memset(buf, 0xFF, 512); for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) { if (write(fd, buf, 512) != 512) { goto fail; } } memset(buf, 0, 1024); memcpy(dyndisk_header->magic, "cxsparse", 8); dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL); dyndisk_header->table_offset = be64_to_cpu(3 * 512); dyndisk_header->version = be32_to_cpu(0x00010000); dyndisk_header->block_size = be32_to_cpu([[block_size]]); dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries); dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024)); if (lseek(fd, 512, SEEK_SET) < 0) { goto fail; } if (write(fd, buf, 1024) != 1024) { goto fail; } ret = 0; fail: return ret; }

[[[[Adv]]]]: static int create_dynamic_disk(int fd, uint8_t *buf, int64_t [[prime²sectors]]) { VHDDynDiskHeader *dyndisk_header = (VHDDynDiskHeader *) buf; size_t [[towerablesizes]], num_bat_entries; int i; int ret = -EIO; [[towerablesizes]] = 0x200000; num_bat_entries = ([[prime²sectors]] + [[towerablesizes]] / 512) / ([[towerablesizes]] / 512); if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) { goto fail; } if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) { goto fail; } if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) { goto fail; } if (lseek(fd, 3 * 512, SEEK_SET) < 0) { goto fail; } memset(buf, 0xFF, 512); for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) { if (write(fd, buf, 512) != 512) { goto fail; } } memset(buf, 0, 1024); memcpy(dyndisk_header->magic, "cxsparse", 8); dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL); dyndisk_header->table_offset = be64_to_cpu(3 * 512); dyndisk_header->version = be32_to_cpu(0x00010000); dyndisk_header->block_size = be32_to_cpu([[towerablesizes]]); dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries); dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024)); if (lseek(fd, 512, SEEK_SET) < 0) { goto fail; } if (write(fd, buf, 1024) != 1024) { goto fail; } ret = 0; fail: return ret; }
--------------------------------------------- Result 1076 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num, const uint8_t *buf, int nb_sectors) { int ret; BDRVVmdkState *s = bs->opaque; qemu_co_mutex_lock(&s->lock); ret = vmdk_write(bs, sector_num, buf, nb_sectors); qemu_co_mutex_unlock(&s->lock); return ret; }
--------------------------------------------- Result 1077 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 569 / 117 / 391 / 1077:  40%|████      | 1077/2690 [2:46:02<4:08:40,  9.25s/it][Succeeded / Failed / Skipped / Total] 569 / 117 / 391 / 1077:  40%|████      | 1078/2690 [2:46:03<4:08:18,  9.24s/it][Succeeded / Failed / Skipped / Total] 569 / 117 / 392 / 1078:  40%|████      | 1078/2690 [2:46:03<4:08:18,  9.24s/it][Succeeded / Failed / Skipped / Total] 569 / 117 / 392 / 1078:  40%|████      | 1079/2690 [2:46:22<4:08:24,  9.25s/it][Succeeded / Failed / Skipped / Total] 569 / 118 / 392 / 1079:  40%|████      | 1079/2690 [2:46:22<4:08:24,  9.25s/it][Succeeded / Failed / Skipped / Total] 569 / 118 / 392 / 1079:  40%|████      | 1080/2690 [2:46:24<4:08:04,  9.25s/it][Succeeded / Failed / Skipped / Total] 570 / 118 / 392 / 1080:  40%|████      | 1080/2690 [2:46:24<4:08:04,  9.25s/it][Succeeded / Failed / Skipped / Total] 570 / 118 / 392 / 1080:  40%|████      | 1081/2690 [2:46:39<4:08:04,  9.25s/it][Succeeded / Failed / Skipped / Total] 571 / 118 / 392 / 1081:  40%|████      | 1081/2690 [2:46:39<4:08:04,  9.25s/it][Succeeded / Failed / Skipped / Total] 571 / 118 / 392 / 1081:  40%|████      | 1082/2690 [2:46:40<4:07:41,  9.24s/it][Succeeded / Failed / Skipped / Total] 571 / 118 / 393 / 1082:  40%|████      | 1082/2690 [2:46:40<4:07:41,  9.24s/it][Succeeded / Failed / Skipped / Total] 571 / 118 / 393 / 1082:  40%|████      | 1083/2690 [2:46:59<4:07:47,  9.25s/it][[0 (51%)]] --> [[0 (42%)]] --> Socre: 0.5806892216205597

[[[[Adv]]]]: static int v9fs_xattr_read(V9fsState *[[s]], V9fsPDU *pdu, V9fsFidState *fidp, uint64_t off, uint32_t max_count) { ssize_t err; size_t offset = 7; int read_count; int64_t xattr_len; V9fsVirtioState *v = container_of([[s]], V9fsVirtioState, state); VirtQueueElement *elem = v->elems[pdu->idx]; xattr_len = fidp->fs.xattr.len; read_count = xattr_len - off; if (read_count > max_count) { read_count = max_count; } else if (read_count < 0) { read_count = 0; } err = pdu_marshal(pdu, offset, "d", read_count); if (err < 0) { return err; } offset += err; err = v9fs_pack(elem->in_sg, elem->in_num, offset, ((char *)fidp->fs.xattr.value) + off, read_count); if (err < 0) { return err; } offset += err; return offset; }

[[[[Adv]]]]: static int v9fs_xattr_read(V9fsState *[[east]], V9fsPDU *pdu, V9fsFidState *fidp, uint64_t off, uint32_t max_count) { ssize_t err; size_t offset = 7; int read_count; int64_t xattr_len; V9fsVirtioState *v = container_of([[east]], V9fsVirtioState, state); VirtQueueElement *elem = v->elems[pdu->idx]; xattr_len = fidp->fs.xattr.len; read_count = xattr_len - off; if (read_count > max_count) { read_count = max_count; } else if (read_count < 0) { read_count = 0; } err = pdu_marshal(pdu, offset, "d", read_count); if (err < 0) { return err; } offset += err; err = v9fs_pack(elem->in_sg, elem->in_num, offset, ((char *)fidp->fs.xattr.value) + off, read_count); if (err < 0) { return err; } offset += err; return offset; }
--------------------------------------------- Result 1078 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold void init_atrac3_transforms(ATRAC3Context *q) { float enc_window[256]; int i; for (i=0 ; i<256; i++) enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5; if (!mdct_window[0]) for (i=0 ; i<256; i++) { mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]); mdct_window[511-i] = mdct_window[i]; } ff_mdct_init(&mdct_ctx, 9, 1, 1.0); }
--------------------------------------------- Result 1079 ---------------------------------------------
[[0 (91%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void get_sensor_evt_enable(IPMIBmcSim *ibs, uint8_t *cmd, unsigned int [[cmd_len]], uint8_t *[[rsp]], unsigned int *[[rsp_len]], unsigned int [[max_rsp_len]]) { IPMISensor *[[sens]]; IPMI_CHECK_CMD_LEN(3); if ((cmd[2] > MAX_SENSORS) || !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) { [[rsp]][2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT; return; } [[sens]] = ibs->sensors + cmd[2]; IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS([[sens]])); IPMI_ADD_RSP_DATA([[sens]]->assert_enable & 0xff); IPMI_ADD_RSP_DATA(([[sens]]->assert_enable >> 8) & 0xff); IPMI_ADD_RSP_DATA([[sens]]->deassert_enable & 0xff); IPMI_ADD_RSP_DATA(([[sens]]->deassert_enable >> 8) & 0xff); }

[[[[Adv]]]]: static void get_sensor_evt_enable(IPMIBmcSim *ibs, uint8_t *cmd, unsigned int [[sarrofnot]], uint8_t *[[pasl]], unsigned int *[[insn16me]], unsigned int [[minuslogresspbnu]]) { IPMISensor *[[muss]]; IPMI_CHECK_CMD_LEN(3); if ((cmd[2] > MAX_SENSORS) || !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) { [[pasl]][2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT; return; } [[muss]] = ibs->sensors + cmd[2]; IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS([[muss]])); IPMI_ADD_RSP_DATA([[muss]]->assert_enable & 0xff); IPMI_ADD_RSP_DATA(([[muss]]->assert_enable >> 8) & 0xff); IPMI_ADD_RSP_DATA([[muss]]->deassert_enable & 0xff); IPMI_ADD_RSP_DATA(([[muss]]->deassert_enable >> 8) & 0xff); }
--------------------------------------------- Result 1080 ---------------------------------------------
[[0 (89%)]] --> [[0 (41%)]] --> Socre: 0.5865998268127441

[[[[Adv]]]]: int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen, uint8_t *[[dst]], int dlen) { uint32_t zrun_len = 0, nzrun_len = 0; int [[d]] = 0, i = 0; long res, xor; uint8_t *nzrun_start = NULL; g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) % sizeof(long))); while (i < slen) { if ([[d]] + 2 > dlen) { return -1; } res = (slen - i) % sizeof(long); while (res && old_buf[i] == new_buf[i]) { zrun_len++; i++; res--; } if (!res) { while (i < slen && (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) { i += sizeof(long); zrun_len += sizeof(long); } while (i < slen && old_buf[i] == new_buf[i]) { zrun_len++; i++; } } if (zrun_len == slen) { return 0; } if (i == slen) { return [[d]]; } [[d]] += uleb128_encode_small([[dst]] + [[d]], zrun_len); zrun_len = 0; nzrun_start = new_buf + i; if ([[d]] + 2 > dlen) { return -1; } res = (slen - i) % sizeof(long); while (res && old_buf[i] != new_buf[i]) { i++; nzrun_len++; res--; } if (!res) { long mask = (long)0x0101010101010101ULL; while (i < slen) { xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i); if ((xor - mask) & ~xor & (mask << 7)) { while (old_buf[i] != new_buf[i]) { nzrun_len++; i++; } break; } else { i += sizeof(long); nzrun_len += sizeof(long); } } } [[d]] += uleb128_encode_small([[dst]] + [[d]], nzrun_len); if ([[d]] + nzrun_len > dlen) { return -1; } memcpy([[dst]] + [[d]], nzrun_start, nzrun_len); [[d]] += nzrun_len; nzrun_len = 0; } return [[d]]; }

[[[[Adv]]]]: int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen, uint8_t *[[secondsr]], int dlen) { uint32_t zrun_len = 0, nzrun_len = 0; int [[3d]] = 0, i = 0; long res, xor; uint8_t *nzrun_start = NULL; g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) % sizeof(long))); while (i < slen) { if ([[3d]] + 2 > dlen) { return -1; } res = (slen - i) % sizeof(long); while (res && old_buf[i] == new_buf[i]) { zrun_len++; i++; res--; } if (!res) { while (i < slen && (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) { i += sizeof(long); zrun_len += sizeof(long); } while (i < slen && old_buf[i] == new_buf[i]) { zrun_len++; i++; } } if (zrun_len == slen) { return 0; } if (i == slen) { return [[3d]]; } [[3d]] += uleb128_encode_small([[secondsr]] + [[3d]], zrun_len); zrun_len = 0; nzrun_start = new_buf + i; if ([[3d]] + 2 > dlen) { return -1; } res = (slen - i) % sizeof(long); while (res && old_buf[i] != new_buf[i]) { i++; nzrun_len++; res--; } if (!res) { long mask = (long)0x0101010101010101ULL; while (i < slen) { xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i); if ((xor - mask) & ~xor & (mask << 7)) { while (old_buf[i] != new_buf[i]) { nzrun_len++; i++; } break; } else { i += sizeof(long); nzrun_len += sizeof(long); } } } [[3d]] += uleb128_encode_small([[secondsr]] + [[3d]], nzrun_len); if ([[3d]] + nzrun_len > dlen) { return -1; } memcpy([[secondsr]] + [[3d]], nzrun_start, nzrun_len); [[3d]] += nzrun_len; nzrun_len = 0; } return [[3d]]; }
--------------------------------------------- Result 1081 ---------------------------------------------
[[0 (77%)]] --> [[0 (20%)]] --> Socre: 0.7995390743017197

[[[[Adv]]]]: void lm32_juart_set_jtx(DeviceState *[[d]], uint32_t jtx) { LM32JuartState *s = LM32_JUART([[d]]); unsigned char ch = jtx & 0xff; trace_lm32_juart_set_jtx(s->jtx); s->jtx = jtx; if (s->chr) { qemu_chr_fe_write_all(s->chr, &ch, 1); } }

[[[[Adv]]]]: void lm32_juart_set_jtx(DeviceState *[[park]], uint32_t jtx) { LM32JuartState *s = LM32_JUART([[park]]); unsigned char ch = jtx & 0xff; trace_lm32_juart_set_jtx(s->jtx); s->jtx = jtx; if (s->chr) { qemu_chr_fe_write_all(s->chr, &ch, 1); } }
--------------------------------------------- Result 1082 ---------------------------------------------
[[0 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: send_msg( VSCMsgType type, uint32_t reader_id, const void *msg, unsigned int length ) { VSCMsgHeader mhHeader; qemu_mutex_lock(&socket_to_send_lock); if (verbose > 10) { printf("sending type=%d id=%u, len =%u (0x%x)\n", type, reader_id, length, length); } mhHeader.type = htonl(type); mhHeader.reader_id = 0; mhHeader.length = htonl(length); g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader)); g_byte_array_append(socket_to_send, (guint8 *)msg, length); g_idle_add(socket_prepare_sending, NULL); qemu_mutex_unlock(&socket_to_send_lock); return 0; }
--------------------------------------------- Result 1083 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 572 / 118 / 393 / 1083:  40%|████      | 1083/2690 [2:46:59<4:07:47,  9.25s/it][Succeeded / Failed / Skipped / Total] 572 / 118 / 393 / 1083:  40%|████      | 1084/2690 [2:47:01<4:07:26,  9.24s/it][Succeeded / Failed / Skipped / Total] 573 / 118 / 393 / 1084:  40%|████      | 1084/2690 [2:47:01<4:07:26,  9.24s/it][Succeeded / Failed / Skipped / Total] 573 / 118 / 393 / 1084:  40%|████      | 1085/2690 [2:47:01<4:07:04,  9.24s/it][Succeeded / Failed / Skipped / Total] 573 / 118 / 394 / 1085:  40%|████      | 1085/2690 [2:47:01<4:07:04,  9.24s/it][Succeeded / Failed / Skipped / Total] 573 / 118 / 394 / 1085:  40%|████      | 1086/2690 [2:47:39<4:07:38,  9.26s/it][Succeeded / Failed / Skipped / Total] 574 / 118 / 394 / 1086:  40%|████      | 1086/2690 [2:47:39<4:07:38,  9.26s/it][Succeeded / Failed / Skipped / Total] 574 / 118 / 394 / 1086:  40%|████      | 1087/2690 [2:47:58<4:07:42,  9.27s/it][[0 (100%)]] --> [[0 (47%)]] --> Socre: 0.5305868685245514

[[[[Adv]]]]: static void matroska_fix_ass_packet(MatroskaDemuxContext *[[matroska]], AVPacket *pkt, uint64_t [[display_duration]]) { char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') layer = ++ptr; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') { int64_t end_pts = pkt->pts + [[display_duration]]; int sc = [[matroska]]->time_scale * pkt->pts / 10000000; int ec = [[matroska]]->time_scale * end_pts / 10000000; int sh, sm, ss, eh, em, es, len; sh = sc/360000; sc -= 360000*sh; sm = sc/ 6000; sc -= 6000*sm; ss = sc/ 100; sc -= 100*ss; eh = ec/360000; ec -= 360000*eh; em = ec/ 6000; ec -= 6000*em; es = ec/ 100; ec -= 100*es; *ptr++ = '\0'; len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE; if (!(line = av_malloc(len))) return; snprintf(line,len,"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s", layer, sh, sm, ss, sc, eh, em, es, ec, ptr); av_free(pkt->data); pkt->data = line; pkt->size = strlen(line); } }

[[[[Adv]]]]: static void matroska_fix_ass_packet(MatroskaDemuxContext *[[afpasک]], AVPacket *pkt, uint64_t [[expositionefterm]]) { char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') layer = ++ptr; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') { int64_t end_pts = pkt->pts + [[expositionefterm]]; int sc = [[afpasک]]->time_scale * pkt->pts / 10000000; int ec = [[afpasک]]->time_scale * end_pts / 10000000; int sh, sm, ss, eh, em, es, len; sh = sc/360000; sc -= 360000*sh; sm = sc/ 6000; sc -= 6000*sm; ss = sc/ 100; sc -= 100*ss; eh = ec/360000; ec -= 360000*eh; em = ec/ 6000; ec -= 6000*em; es = ec/ 100; ec -= 100*es; *ptr++ = '\0'; len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE; if (!(line = av_malloc(len))) return; snprintf(line,len,"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s", layer, sh, sm, ss, sc, eh, em, es, ec, ptr); av_free(pkt->data); pkt->data = line; pkt->size = strlen(line); } }
--------------------------------------------- Result 1084 ---------------------------------------------
[[0 (40%)]] --> [[0 (98%)]] --> Socre: 0.9829036593437195

[[[[Adv]]]]: void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){ int [[i]], j; int dc = (((dctcoef*)block)[0] + 32) >> 6; pixel *dst = (pixel*)_dst; stride >>= sizeof(pixel)-1; for( j = 0; j < 4; j++ ) { for( [[i]] = 0; [[i]] < 4; [[i]]++ ) dst[[[i]]] = av_clip_pixel( dst[[[i]]] + dc ); dst += stride; } }

[[[[Adv]]]]: void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){ int [[ι]], j; int dc = (((dctcoef*)block)[0] + 32) >> 6; pixel *dst = (pixel*)_dst; stride >>= sizeof(pixel)-1; for( j = 0; j < 4; j++ ) { for( [[ι]] = 0; [[ι]] < 4; [[ι]]++ ) dst[[[ι]]] = av_clip_pixel( dst[[[ι]]] + dc ); dst += stride; } }
--------------------------------------------- Result 1085 ---------------------------------------------
[[0 (100%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_vc1_decode_blocks(VC1Context *v) { v->s.esc3_level_length = 0; if (v->x8_type) { ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer); ff_er_add_slice(&v->s.er, 0, 0, (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1, ER_MB_END); } else { v->cur_blk_idx = 0; v->left_blk_idx = -1; v->topleft_blk_idx = 1; v->top_blk_idx = 2; switch (v->s.pict_type) { case AV_PICTURE_TYPE_I: if (v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v); else vc1_decode_i_blocks(v); break; case AV_PICTURE_TYPE_P: if (v->p_frame_skipped) vc1_decode_skip_blocks(v); else vc1_decode_p_blocks(v); break; case AV_PICTURE_TYPE_B: if (v->bi_type) { if (v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v); else vc1_decode_i_blocks(v); } else vc1_decode_b_blocks(v); break; } } }
--------------------------------------------- Result 1086 ---------------------------------------------
[[0 (72%)]] --> [[0 (45%)]] --> Socre: 0.5542432963848114

[[[[Adv]]]]: static void gd_resize(DisplayChangeListener *[[dcl]], DisplayState *[[ds]]) { GtkDisplayState *[[s]] = [[ds]]->opaque; cairo_format_t [[kind]]; int stride; DPRINTF("resize(width=%d, height=%d)\n", ds_get_width([[ds]]), ds_get_height([[ds]])); if ([[s]]->surface) { cairo_surface_destroy([[s]]->surface); } switch ([[ds]]->surface->pf.bits_per_pixel) { case 8: [[kind]] = CAIRO_FORMAT_A8; break; case 16: [[kind]] = CAIRO_FORMAT_RGB16_565; break; case 32: [[kind]] = CAIRO_FORMAT_RGB24; break; default: g_assert_not_reached(); break; } stride = cairo_format_stride_for_width([[kind]], ds_get_width([[ds]])); g_assert(ds_get_linesize([[ds]]) == stride); [[s]]->surface = cairo_image_surface_create_for_data(ds_get_data([[ds]]), [[kind]], ds_get_width([[ds]]), ds_get_height([[ds]]), ds_get_linesize([[ds]])); if (![[s]]->full_screen) { GtkRequisition [[req]]; double sx, sy; if ([[s]]->free_scale) { sx = [[s]]->scale_x; sy = [[s]]->scale_y; [[s]]->scale_y = 1.0; [[s]]->scale_x = 1.0; } else { sx = 1.0; sy = 1.0; } gtk_widget_set_size_request([[s]]->drawing_area, ds_get_width([[ds]]) * [[s]]->scale_x, ds_get_height([[ds]]) * [[s]]->scale_y); #if GTK_CHECK_VERSION(3, 0, 0) gtk_widget_get_preferred_size([[s]]->vbox, NULL, &[[req]]); #else gtk_widget_size_request([[s]]->vbox, &[[req]]); #endif gtk_window_resize(GTK_WINDOW([[s]]->window), [[req]].width * sx, [[req]].height * sy); } }

[[[[Adv]]]]: static void gd_resize(DisplayChangeListener *[[bc4]], DisplayState *[[sg]]) { GtkDisplayState *[[reason]] = [[sg]]->opaque; cairo_format_t [[light]]; int stride; DPRINTF("resize(width=%d, height=%d)\n", ds_get_width([[sg]]), ds_get_height([[sg]])); if ([[reason]]->surface) { cairo_surface_destroy([[reason]]->surface); } switch ([[sg]]->surface->pf.bits_per_pixel) { case 8: [[light]] = CAIRO_FORMAT_A8; break; case 16: [[light]] = CAIRO_FORMAT_RGB16_565; break; case 32: [[light]] = CAIRO_FORMAT_RGB24; break; default: g_assert_not_reached(); break; } stride = cairo_format_stride_for_width([[light]], ds_get_width([[sg]])); g_assert(ds_get_linesize([[sg]]) == stride); [[reason]]->surface = cairo_image_surface_create_for_data(ds_get_data([[sg]]), [[light]], ds_get_width([[sg]]), ds_get_height([[sg]]), ds_get_linesize([[sg]])); if (![[reason]]->full_screen) { GtkRequisition [[bit]]; double sx, sy; if ([[reason]]->free_scale) { sx = [[reason]]->scale_x; sy = [[reason]]->scale_y; [[reason]]->scale_y = 1.0; [[reason]]->scale_x = 1.0; } else { sx = 1.0; sy = 1.0; } gtk_widget_set_size_request([[reason]]->drawing_area, ds_get_width([[sg]]) * [[reason]]->scale_x, ds_get_height([[sg]]) * [[reason]]->scale_y); #if GTK_CHECK_VERSION(3, 0, 0) gtk_widget_get_preferred_size([[reason]]->vbox, NULL, &[[bit]]); #else gtk_widget_size_request([[reason]]->vbox, &[[bit]]); #endif gtk_window_resize(GTK_WINDOW([[reason]]->window), [[bit]].width * sx, [[bit]].height * sy); } }
--------------------------------------------- Result 1087 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 575 / 118 / 394 / 1087:  40%|████      | 1087/2690 [2:47:58<4:07:42,  9.27s/it][Succeeded / Failed / Skipped / Total] 575 / 118 / 394 / 1087:  40%|████      | 1088/2690 [2:48:17<4:07:47,  9.28s/it][Succeeded / Failed / Skipped / Total] 575 / 119 / 394 / 1088:  40%|████      | 1088/2690 [2:48:17<4:07:47,  9.28s/it][Succeeded / Failed / Skipped / Total] 575 / 119 / 394 / 1088:  40%|████      | 1089/2690 [2:48:17<4:07:25,  9.27s/it][Succeeded / Failed / Skipped / Total] 575 / 119 / 395 / 1089:  40%|████      | 1089/2690 [2:48:17<4:07:25,  9.27s/it][Succeeded / Failed / Skipped / Total] 575 / 119 / 395 / 1089:  41%|████      | 1090/2690 [2:48:28<4:07:18,  9.27s/it][[0 (41%)]] --> [[0 (54%)]] --> Socre: 0.5409958362579346

[[[[Adv]]]]: static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *[[got_packet]]) { const AVFrame *const p = pict; const int near = avctx->prediction_method; PutBitContext pb, pb2; GetBitContext [[gb]]; uint8_t *buf2 = NULL; uint8_t *zero = NULL; uint8_t *cur = NULL; uint8_t *last = NULL; JLSState *[[state]]; int i, size, ret; int comps; if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 || avctx->pix_fmt == AV_PIX_FMT_GRAY16) comps = 1; else comps = 3; if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 + AV_INPUT_BUFFER_MIN_SIZE)) < 0) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet.\n"); return ret; } buf2 = av_malloc(pkt->size); if (!buf2) goto memfail; init_put_bits(&pb, pkt->data, pkt->size); init_put_bits(&pb2, buf2, pkt->size); put_marker(&pb, SOI); put_marker(&pb, SOF48); put_bits(&pb, 16, 8 + comps * 3); put_bits(&pb, 8, (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8); put_bits(&pb, 16, avctx->height); put_bits(&pb, 16, avctx->width); put_bits(&pb, 8, comps); for (i = 1; i <= comps; i++) { put_bits(&pb, 8, i); put_bits(&pb, 8, 0x11); put_bits(&pb, 8, 0); } put_marker(&pb, SOS); put_bits(&pb, 16, 6 + comps * 2); put_bits(&pb, 8, comps); for (i = 1; i <= comps; i++) { put_bits(&pb, 8, i); put_bits(&pb, 8, 0); } put_bits(&pb, 8, near); put_bits(&pb, 8, (comps > 1) ? 1 : 0); put_bits(&pb, 8, 0); [[state]] = av_mallocz(sizeof(JLSState)); if (![[state]]) goto memfail; [[state]]->near = near; [[state]]->bpp = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8; ff_jpegls_reset_coding_parameters([[state]], 0); ff_jpegls_init_state([[state]]); ls_store_lse([[state]], &pb); zero = last = av_mallocz(p->linesize[0]); if (!zero) goto memfail; cur = p->data[0]; if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) { int t = 0; for (i = 0; i < avctx->height; i++) { ls_encode_line([[state]], &pb2, last, cur, t, avctx->width, 1, 0, 8); t = last[0]; last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_GRAY16) { int t = 0; for (i = 0; i < avctx->height; i++) { ls_encode_line([[state]], &pb2, last, cur, t, avctx->width, 1, 0, 16); t = *((uint16_t *)last); last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 0; j < 3; j++) { ls_encode_line([[state]], &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_BGR24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 2; j >= 0; j--) { ls_encode_line([[state]], &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } av_freep(&zero); av_freep(&[[state]]); put_bits(&pb2, 7, 0); size = put_bits_count(&pb2); flush_put_bits(&pb2); init_get_bits(&[[gb]], buf2, size); size -= 7; while (get_bits_count(&[[gb]]) < size) { int v; v = get_bits(&[[gb]], 8); put_bits(&pb, 8, v); if (v == 0xFF) { v = get_bits(&[[gb]], 7); put_bits(&pb, 8, v); } } avpriv_align_put_bits(&pb); av_freep(&buf2); put_marker(&pb, EOI); flush_put_bits(&pb); emms_c(); pkt->size = put_bits_count(&pb) >> 3; pkt->flags |= AV_PKT_FLAG_KEY; *[[got_packet]] = 1; return 0; memfail: av_packet_unref(pkt); av_freep(&buf2); av_freep(&[[state]]); av_freep(&zero); return AVERROR(ENOMEM); }

[[[[Adv]]]]: static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *[[sawsrit]]) { const AVFrame *const p = pict; const int near = avctx->prediction_method; PutBitContext pb, pb2; GetBitContext [[bam]]; uint8_t *buf2 = NULL; uint8_t *zero = NULL; uint8_t *cur = NULL; uint8_t *last = NULL; JLSState *[[height]]; int i, size, ret; int comps; if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 || avctx->pix_fmt == AV_PIX_FMT_GRAY16) comps = 1; else comps = 3; if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 + AV_INPUT_BUFFER_MIN_SIZE)) < 0) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet.\n"); return ret; } buf2 = av_malloc(pkt->size); if (!buf2) goto memfail; init_put_bits(&pb, pkt->data, pkt->size); init_put_bits(&pb2, buf2, pkt->size); put_marker(&pb, SOI); put_marker(&pb, SOF48); put_bits(&pb, 16, 8 + comps * 3); put_bits(&pb, 8, (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8); put_bits(&pb, 16, avctx->height); put_bits(&pb, 16, avctx->width); put_bits(&pb, 8, comps); for (i = 1; i <= comps; i++) { put_bits(&pb, 8, i); put_bits(&pb, 8, 0x11); put_bits(&pb, 8, 0); } put_marker(&pb, SOS); put_bits(&pb, 16, 6 + comps * 2); put_bits(&pb, 8, comps); for (i = 1; i <= comps; i++) { put_bits(&pb, 8, i); put_bits(&pb, 8, 0); } put_bits(&pb, 8, near); put_bits(&pb, 8, (comps > 1) ? 1 : 0); put_bits(&pb, 8, 0); [[height]] = av_mallocz(sizeof(JLSState)); if (![[height]]) goto memfail; [[height]]->near = near; [[height]]->bpp = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8; ff_jpegls_reset_coding_parameters([[height]], 0); ff_jpegls_init_state([[height]]); ls_store_lse([[height]], &pb); zero = last = av_mallocz(p->linesize[0]); if (!zero) goto memfail; cur = p->data[0]; if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) { int t = 0; for (i = 0; i < avctx->height; i++) { ls_encode_line([[height]], &pb2, last, cur, t, avctx->width, 1, 0, 8); t = last[0]; last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_GRAY16) { int t = 0; for (i = 0; i < avctx->height; i++) { ls_encode_line([[height]], &pb2, last, cur, t, avctx->width, 1, 0, 16); t = *((uint16_t *)last); last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 0; j < 3; j++) { ls_encode_line([[height]], &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_BGR24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 2; j >= 0; j--) { ls_encode_line([[height]], &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } av_freep(&zero); av_freep(&[[height]]); put_bits(&pb2, 7, 0); size = put_bits_count(&pb2); flush_put_bits(&pb2); init_get_bits(&[[bam]], buf2, size); size -= 7; while (get_bits_count(&[[bam]]) < size) { int v; v = get_bits(&[[bam]], 8); put_bits(&pb, 8, v); if (v == 0xFF) { v = get_bits(&[[bam]], 7); put_bits(&pb, 8, v); } } avpriv_align_put_bits(&pb); av_freep(&buf2); put_marker(&pb, EOI); flush_put_bits(&pb); emms_c(); pkt->size = put_bits_count(&pb) >> 3; pkt->flags |= AV_PKT_FLAG_KEY; *[[sawsrit]] = 1; return 0; memfail: av_packet_unref(pkt); av_freep(&buf2); av_freep(&[[height]]); av_freep(&zero); return AVERROR(ENOMEM); }
--------------------------------------------- Result 1088 ---------------------------------------------
[[0 (27%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int avfilter_register(AVFilter *[[filter]]) { if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB) return -1; registered_avfilters[next_registered_avfilter_idx++] = [[filter]]; return 0; }

[[[[Adv]]]]: int avfilter_register(AVFilter *[[buffer]]) { if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB) return -1; registered_avfilters[next_registered_avfilter_idx++] = [[buffer]]; return 0; }
--------------------------------------------- Result 1089 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_migrate_cancel(Error **errp) { migrate_fd_cancel(migrate_get_current()); }
--------------------------------------------- Result 1090 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 576 / 119 / 395 / 1090:  41%|████      | 1090/2690 [2:48:28<4:07:18,  9.27s/it][Succeeded / Failed / Skipped / Total] 576 / 119 / 395 / 1090:  41%|████      | 1091/2690 [2:49:08<4:07:54,  9.30s/it][Succeeded / Failed / Skipped / Total] 577 / 119 / 395 / 1091:  41%|████      | 1091/2690 [2:49:08<4:07:54,  9.30s/it][Succeeded / Failed / Skipped / Total] 577 / 119 / 395 / 1091:  41%|████      | 1092/2690 [2:49:09<4:07:32,  9.29s/it][Succeeded / Failed / Skipped / Total] 577 / 119 / 396 / 1092:  41%|████      | 1092/2690 [2:49:09<4:07:32,  9.29s/it][Succeeded / Failed / Skipped / Total] 577 / 119 / 396 / 1092:  41%|████      | 1093/2690 [2:49:09<4:07:10,  9.29s/it][Succeeded / Failed / Skipped / Total] 577 / 119 / 397 / 1093:  41%|████      | 1093/2690 [2:49:09<4:07:10,  9.29s/it][Succeeded / Failed / Skipped / Total] 577 / 119 / 397 / 1093:  41%|████      | 1094/2690 [2:49:10<4:06:47,  9.28s/it][Succeeded / Failed / Skipped / Total] 577 / 119 / 398 / 1094:  41%|████      | 1094/2690 [2:49:10<4:06:47,  9.28s/it][Succeeded / Failed / Skipped / Total] 577 / 119 / 398 / 1094:  41%|████      | 1095/2690 [2:49:24<4:06:45,  9.28s/it][[0 (98%)]] --> [[0 (39%)]] --> Socre: 0.6058820486068726

[[[[Adv]]]]: paint_mouse_pointer(XImage *image, struct x11_grab *[[s]]) { int x_off = [[s]]->x_off; int y_off = [[s]]->y_off; int [[width]] = [[s]]->width; int height = [[s]]->height; Display *dpy = [[s]]->dpy; XFixesCursorImage *[[xcim]]; int x, y; int [[line]], column; int to_line, to_column; int image_addr, xcim_addr; [[xcim]] = XFixesGetCursorImage(dpy); x = [[xcim]]->x - [[xcim]]->xhot; y = [[xcim]]->y - [[xcim]]->yhot; to_line = FFMIN((y + [[xcim]]->height), (height + y_off)); to_column = FFMIN((x + [[xcim]]->width), ([[width]] + x_off)); for ([[line]] = FFMAX(y, y_off); [[line]] < to_line; [[line]]++) { for (column = FFMAX(x, x_off); column < to_column; column++) { xcim_addr = ([[line]] - y) * [[xcim]]->width + column - x; if ((unsigned char)([[xcim]]->pixels[xcim_addr] >> 24) != 0) { image_addr = (([[line]] - y_off) * [[width]] + column - x_off) * 4; image->data[image_addr] = (unsigned char)([[xcim]]->pixels[xcim_addr] >> 0); image->data[image_addr+1] = (unsigned char)([[xcim]]->pixels[xcim_addr] >> 8); image->data[image_addr+2] = (unsigned char)([[xcim]]->pixels[xcim_addr] >> 16); } } } XFree([[xcim]]); [[xcim]] = NULL; }

[[[[Adv]]]]: paint_mouse_pointer(XImage *image, struct x11_grab *[[с]]) { int x_off = [[с]]->x_off; int y_off = [[с]]->y_off; int [[volume]] = [[с]]->width; int height = [[с]]->height; Display *dpy = [[с]]->dpy; XFixesCursorImage *[[cyzimi]]; int x, y; int [[plane]], column; int to_line, to_column; int image_addr, xcim_addr; [[cyzimi]] = XFixesGetCursorImage(dpy); x = [[cyzimi]]->x - [[cyzimi]]->xhot; y = [[cyzimi]]->y - [[cyzimi]]->yhot; to_line = FFMIN((y + [[cyzimi]]->height), (height + y_off)); to_column = FFMIN((x + [[cyzimi]]->width), ([[volume]] + x_off)); for ([[plane]] = FFMAX(y, y_off); [[plane]] < to_line; [[plane]]++) { for (column = FFMAX(x, x_off); column < to_column; column++) { xcim_addr = ([[plane]] - y) * [[cyzimi]]->width + column - x; if ((unsigned char)([[cyzimi]]->pixels[xcim_addr] >> 24) != 0) { image_addr = (([[plane]] - y_off) * [[volume]] + column - x_off) * 4; image->data[image_addr] = (unsigned char)([[cyzimi]]->pixels[xcim_addr] >> 0); image->data[image_addr+1] = (unsigned char)([[cyzimi]]->pixels[xcim_addr] >> 8); image->data[image_addr+2] = (unsigned char)([[cyzimi]]->pixels[xcim_addr] >> 16); } } } XFree([[cyzimi]]); [[cyzimi]] = NULL; }
--------------------------------------------- Result 1091 ---------------------------------------------
[[0 (89%)]] --> [[0 (45%)]] --> Socre: 0.5490647256374359

[[[[Adv]]]]: static uint64_t boston_platreg_read(void *[[opaque]], hwaddr [[addr]], unsigned [[size]]) { BostonState *[[s]] = [[opaque]]; uint32_t gic_freq, val; if ([[size]] != 4) { qemu_log_mask(LOG_UNIMP, "%uB platform register read", [[size]]); return 0; } switch ([[addr]] & 0xffff) { case PLAT_FPGA_BUILD: case PLAT_CORE_CL: case PLAT_WRAPPER_CL: return 0; case PLAT_DDR3_STATUS: return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED; case PLAT_MMCM_DIV: gic_freq = mips_gictimer_get_freq([[s]]->cps->gic.gic_timer) / 1000000; val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT; val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT; val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT; val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT; return val; case PLAT_BUILD_CFG: val = PLAT_BUILD_CFG_PCIE0_EN; val |= PLAT_BUILD_CFG_PCIE1_EN; val |= PLAT_BUILD_CFG_PCIE2_EN; return val; case PLAT_DDR_CFG: val = [[s]]->mach->ram_size / G_BYTE; assert(!(val & ~PLAT_DDR_CFG_SIZE)); val |= PLAT_DDR_CFG_MHZ; return val; default: qemu_log_mask(LOG_UNIMP, "Read platform register 0x%" HWADDR_PRIx, [[addr]] & 0xffff); return 0; } }

[[[[Adv]]]]: static uint64_t boston_platreg_read(void *[[implicit]], hwaddr [[ixrp]], unsigned [[diameter]]) { BostonState *[[gross]] = [[implicit]]; uint32_t gic_freq, val; if ([[diameter]] != 4) { qemu_log_mask(LOG_UNIMP, "%uB platform register read", [[diameter]]); return 0; } switch ([[ixrp]] & 0xffff) { case PLAT_FPGA_BUILD: case PLAT_CORE_CL: case PLAT_WRAPPER_CL: return 0; case PLAT_DDR3_STATUS: return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED; case PLAT_MMCM_DIV: gic_freq = mips_gictimer_get_freq([[gross]]->cps->gic.gic_timer) / 1000000; val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT; val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT; val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT; val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT; return val; case PLAT_BUILD_CFG: val = PLAT_BUILD_CFG_PCIE0_EN; val |= PLAT_BUILD_CFG_PCIE1_EN; val |= PLAT_BUILD_CFG_PCIE2_EN; return val; case PLAT_DDR_CFG: val = [[gross]]->mach->ram_size / G_BYTE; assert(!(val & ~PLAT_DDR_CFG_SIZE)); val |= PLAT_DDR_CFG_MHZ; return val; default: qemu_log_mask(LOG_UNIMP, "Read platform register 0x%" HWADDR_PRIx, [[ixrp]] & 0xffff); return 0; } }
--------------------------------------------- Result 1092 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_text_tx3g(AVCodecContext *avctx, MovTextContext *m) { char *tx3g_ptr = avctx->extradata; int i, box_size, font_length; int8_t v_align, h_align; int style_fontID; StyleBox s_default; m->count_f = 0; m->ftab_entries = 0; box_size = BOX_SIZE_INITIAL; if (avctx->extradata_size < box_size) return -1; tx3g_ptr += 4; h_align = *tx3g_ptr++; v_align = *tx3g_ptr++; if (h_align == 0) { if (v_align == 0) m->d.alignment = TOP_LEFT; if (v_align == 1) m->d.alignment = MIDDLE_LEFT; if (v_align == -1) m->d.alignment = BOTTOM_LEFT; } if (h_align == 1) { if (v_align == 0) m->d.alignment = TOP_CENTER; if (v_align == 1) m->d.alignment = MIDDLE_CENTER; if (v_align == -1) m->d.alignment = BOTTOM_CENTER; } if (h_align == -1) { if (v_align == 0) m->d.alignment = TOP_RIGHT; if (v_align == 1) m->d.alignment = MIDDLE_RIGHT; if (v_align == -1) m->d.alignment = BOTTOM_RIGHT; } m->d.back_color = AV_RB24(tx3g_ptr); tx3g_ptr += 4; tx3g_ptr += 8; tx3g_ptr += 4; style_fontID = AV_RB16(tx3g_ptr); tx3g_ptr += 2; s_default.style_flag = *tx3g_ptr++; m->d.bold = s_default.style_flag & STYLE_FLAG_BOLD; m->d.italic = s_default.style_flag & STYLE_FLAG_ITALIC; m->d.underline = s_default.style_flag & STYLE_FLAG_UNDERLINE; m->d.fontsize = *tx3g_ptr++; m->d.color = AV_RB24(tx3g_ptr); tx3g_ptr += 4; tx3g_ptr += 4; tx3g_ptr += 4; m->ftab_entries = AV_RB16(tx3g_ptr); tx3g_ptr += 2; for (i = 0; i < m->ftab_entries; i++) { box_size += 3; if (avctx->extradata_size < box_size) { mov_text_cleanup_ftab(m); m->ftab_entries = 0; return -1; } m->ftab_temp = av_malloc(sizeof(*m->ftab_temp)); if (!m->ftab_temp) { mov_text_cleanup_ftab(m); return AVERROR(ENOMEM); } m->ftab_temp->fontID = AV_RB16(tx3g_ptr); tx3g_ptr += 2; font_length = *tx3g_ptr++; box_size = box_size + font_length; if (avctx->extradata_size < box_size) { mov_text_cleanup_ftab(m); m->ftab_entries = 0; return -1; } m->ftab_temp->font = av_malloc(font_length + 1); if (!m->ftab_temp->font) { mov_text_cleanup_ftab(m); return AVERROR(ENOMEM); } memcpy(m->ftab_temp->font, tx3g_ptr, font_length); m->ftab_temp->font[font_length] = '\0'; av_dynarray_add(&m->ftab, &m->count_f, m->ftab_temp); if (!m->ftab) { mov_text_cleanup_ftab(m); return AVERROR(ENOMEM); } tx3g_ptr = tx3g_ptr + font_length; } for (i = 0; i < m->ftab_entries; i++) { if (style_fontID == m->ftab[i]->fontID) m->d.font = m->ftab[i]->font; } return 0; }
--------------------------------------------- Result 1093 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void msmouse_chr_close (struct CharDriverState *chr) { MouseState *mouse = chr->opaque; qemu_input_handler_unregister(mouse->hs); g_free(mouse); g_free(chr); }
--------------------------------------------- Result 1094 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int qemu_init_main_loop(void) { int ret; ret = qemu_signal_init(); if (ret) { return ret; } qemu_init_sigbus(); return qemu_event_init(); }
--------------------------------------------- Result 1095 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 578 / 119 / 398 / 1095:  41%|████      | 1095/2690 [2:49:24<4:06:45,  9.28s/it][Succeeded / Failed / Skipped / Total] 578 / 119 / 398 / 1095:  41%|████      | 1096/2690 [2:49:28<4:06:29,  9.28s/it][Succeeded / Failed / Skipped / Total] 579 / 119 / 398 / 1096:  41%|████      | 1096/2690 [2:49:28<4:06:29,  9.28s/it][Succeeded / Failed / Skipped / Total] 579 / 119 / 398 / 1096:  41%|████      | 1097/2690 [2:49:35<4:06:16,  9.28s/it][Succeeded / Failed / Skipped / Total] 580 / 119 / 398 / 1097:  41%|████      | 1097/2690 [2:49:35<4:06:16,  9.28s/it][Succeeded / Failed / Skipped / Total] 580 / 119 / 398 / 1097:  41%|████      | 1098/2690 [2:49:47<4:06:10,  9.28s/it][Succeeded / Failed / Skipped / Total] 581 / 119 / 398 / 1098:  41%|████      | 1098/2690 [2:49:47<4:06:10,  9.28s/it][Succeeded / Failed / Skipped / Total] 581 / 119 / 398 / 1098:  41%|████      | 1099/2690 [2:50:06<4:06:16,  9.29s/it][[0 (12%)]] --> [[0 (95%)]] --> Socre: 0.9459550380706787

[[[[Adv]]]]: static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src, ptrdiff_t buf_stride, ptrdiff_t [[src_stride]], int block_w, int block_h, int [[src_x]], int [[src_y]], int [[w]], int h) { emulated_edge_mc(buf, src, buf_stride, [[src_stride]], block_w, block_h, [[src_x]], [[src_y]], [[w]], h, vfixtbl_sse, &ff_emu_edge_vvar_sse, hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext); }

[[[[Adv]]]]: static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src, ptrdiff_t buf_stride, ptrdiff_t [[sarcarealhs]], int block_w, int block_h, int [[vaclcapitalup]], int [[spak_j]], int [[ł]], int h) { emulated_edge_mc(buf, src, buf_stride, [[sarcarealhs]], block_w, block_h, [[vaclcapitalup]], [[spak_j]], [[ł]], h, vfixtbl_sse, &ff_emu_edge_vvar_sse, hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext); }
--------------------------------------------- Result 1096 ---------------------------------------------
[[0 (63%)]] --> [[0 (44%)]] --> Socre: 0.5622777938842773

[[[[Adv]]]]: int load_snapshot(const char *name, Error **[[errp]]) { BlockDriverState *bs, *bs_vm_state; QEMUSnapshotInfo sn; QEMUFile *f; int [[ret]]; AioContext *aio_context; MigrationIncomingState *[[mis]] = migration_incoming_get_current(); if (!bdrv_all_can_snapshot(&bs)) { error_setg([[errp]], "Device '%s' is writable but does not support snapshots", bdrv_get_device_name(bs)); return -ENOTSUP; } [[ret]] = bdrv_all_find_snapshot(name, &bs); if ([[ret]] < 0) { error_setg([[errp]], "Device '%s' does not have the requested snapshot '%s'", bdrv_get_device_name(bs), name); return [[ret]]; } bs_vm_state = bdrv_all_find_vmstate_bs(); if (!bs_vm_state) { error_setg([[errp]], "No block device supports snapshots"); return -ENOTSUP; } aio_context = bdrv_get_aio_context(bs_vm_state); aio_context_acquire(aio_context); [[ret]] = bdrv_snapshot_find(bs_vm_state, &sn, name); aio_context_release(aio_context); if ([[ret]] < 0) { return [[ret]]; } else if (sn.vm_state_size == 0) { error_setg([[errp]], "This is a disk-only snapshot. Revert to it " " offline using qemu-img"); return -EINVAL; } bdrv_drain_all(); [[ret]] = bdrv_all_goto_snapshot(name, &bs); if ([[ret]] < 0) { error_setg([[errp]], "Error %d while activating snapshot '%s' on '%s'", [[ret]], name, bdrv_get_device_name(bs)); return [[ret]]; } f = qemu_fopen_bdrv(bs_vm_state, 0); if (!f) { error_setg([[errp]], "Could not open VM state file"); return -EINVAL; } qemu_system_reset(SHUTDOWN_CAUSE_NONE); [[mis]]->from_src_file = f; aio_context_acquire(aio_context); [[ret]] = qemu_loadvm_state(f); qemu_fclose(f); aio_context_release(aio_context); migration_incoming_state_destroy(); if ([[ret]] < 0) { error_setg([[errp]], "Error %d while loading VM state", [[ret]]); return [[ret]]; } return 0; }

[[[[Adv]]]]: int load_snapshot(const char *name, Error **[[ippass]]) { BlockDriverState *bs, *bs_vm_state; QEMUSnapshotInfo sn; QEMUFile *f; int [[pred]]; AioContext *aio_context; MigrationIncomingState *[[os]] = migration_incoming_get_current(); if (!bdrv_all_can_snapshot(&bs)) { error_setg([[ippass]], "Device '%s' is writable but does not support snapshots", bdrv_get_device_name(bs)); return -ENOTSUP; } [[pred]] = bdrv_all_find_snapshot(name, &bs); if ([[pred]] < 0) { error_setg([[ippass]], "Device '%s' does not have the requested snapshot '%s'", bdrv_get_device_name(bs), name); return [[pred]]; } bs_vm_state = bdrv_all_find_vmstate_bs(); if (!bs_vm_state) { error_setg([[ippass]], "No block device supports snapshots"); return -ENOTSUP; } aio_context = bdrv_get_aio_context(bs_vm_state); aio_context_acquire(aio_context); [[pred]] = bdrv_snapshot_find(bs_vm_state, &sn, name); aio_context_release(aio_context); if ([[pred]] < 0) { return [[pred]]; } else if (sn.vm_state_size == 0) { error_setg([[ippass]], "This is a disk-only snapshot. Revert to it " " offline using qemu-img"); return -EINVAL; } bdrv_drain_all(); [[pred]] = bdrv_all_goto_snapshot(name, &bs); if ([[pred]] < 0) { error_setg([[ippass]], "Error %d while activating snapshot '%s' on '%s'", [[pred]], name, bdrv_get_device_name(bs)); return [[pred]]; } f = qemu_fopen_bdrv(bs_vm_state, 0); if (!f) { error_setg([[ippass]], "Could not open VM state file"); return -EINVAL; } qemu_system_reset(SHUTDOWN_CAUSE_NONE); [[os]]->from_src_file = f; aio_context_acquire(aio_context); [[pred]] = qemu_loadvm_state(f); qemu_fclose(f); aio_context_release(aio_context); migration_incoming_state_destroy(); if ([[pred]] < 0) { error_setg([[ippass]], "Error %d while loading VM state", [[pred]]); return [[pred]]; } return 0; }
--------------------------------------------- Result 1097 ---------------------------------------------
[[0 (77%)]] --> [[0 (21%)]] --> Socre: 0.7858258634805679

[[[[Adv]]]]: envlist_parse(envlist_t *envlist, const char *env, int (*callback)(envlist_t *, const char *)) { char *[[tmpenv]], *envvar; char *envsave = NULL; assert(callback != NULL); if ((envlist == NULL) || (env == NULL)) return (EINVAL); if (([[tmpenv]] = strdup(env)) == NULL) return (errno); envvar = strtok_r([[tmpenv]], ",", &envsave); while (envvar != NULL) { if ((*callback)(envlist, envvar) != 0) { free([[tmpenv]]); return (errno); } envvar = strtok_r(NULL, ",", &envsave); } free([[tmpenv]]); return (0); }

[[[[Adv]]]]: envlist_parse(envlist_t *envlist, const char *env, int (*callback)(envlist_t *, const char *)) { char *[[ctmpsrenj]], *envvar; char *envsave = NULL; assert(callback != NULL); if ((envlist == NULL) || (env == NULL)) return (EINVAL); if (([[ctmpsrenj]] = strdup(env)) == NULL) return (errno); envvar = strtok_r([[ctmpsrenj]], ",", &envsave); while (envvar != NULL) { if ((*callback)(envlist, envvar) != 0) { free([[ctmpsrenj]]); return (errno); } envvar = strtok_r(NULL, ",", &envsave); } free([[ctmpsrenj]]); return (0); }
--------------------------------------------- Result 1098 ---------------------------------------------
[[0 (11%)]] --> [[0 (53%)]] --> Socre: 0.5280611515045166

[[[[Adv]]]]: static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *[[func]]) { if (err != CUDA_SUCCESS) { av_log(avctx, AV_LOG_FATAL, ">> %s - failed with error code 0x%x\n", [[func]], err); return 0; } return 1; }

[[[[Adv]]]]: static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *[[cue]]) { if (err != CUDA_SUCCESS) { av_log(avctx, AV_LOG_FATAL, ">> %s - failed with error code 0x%x\n", [[cue]], err); return 0; } return 1; }
--------------------------------------------- Result 1099 ---------------------------------------------
[[0 (26%)]] --> [[0 (80%)]] --> Socre: 0.797960638999939

[[[[Adv]]]]: static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int [[stream_idx]], int in_program) { AVStream *stream = fmt_ctx->streams[[[stream_idx]]]; AVCodecContext *dec_ctx; const AVCodec *dec; char [[val_str]][128]; const char *s; AVRational sar, dar; AVBPrint pbuf; av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED); writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM); print_int("index", stream->index); if ((dec_ctx = stream->codec)) { const char *profile = NULL; dec = dec_ctx->codec; if (dec) { print_str("codec_name", dec->name); if (!do_bitexact) { if (dec->long_name) print_str ("codec_long_name", dec->long_name); else print_str_opt("codec_long_name", "unknown"); } } else { print_str_opt("codec_name", "unknown"); if (!do_bitexact) { print_str_opt("codec_long_name", "unknown"); } } if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile))) print_str("profile", profile); else print_str_opt("profile", "unknown"); s = av_get_media_type_string(dec_ctx->codec_type); if (s) print_str ("codec_type", s); else print_str_opt("codec_type", "unknown"); print_q("codec_time_base", dec_ctx->time_base, '/'); av_get_codec_tag_string([[val_str]], sizeof([[val_str]]), dec_ctx->codec_tag); print_str("codec_tag_string", [[val_str]]); print_fmt("codec_tag", "0x%04x", dec_ctx->codec_tag); switch (dec_ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int("width", dec_ctx->width); print_int("height", dec_ctx->height); print_int("has_b_frames", dec_ctx->has_b_frames); sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL); if (sar.den) { print_q("sample_aspect_ratio", sar, ':'); av_reduce(&dar.num, &dar.den, dec_ctx->width * sar.num, dec_ctx->height * sar.den, 1024*1024); print_q("display_aspect_ratio", dar, ':'); } else { print_str_opt("sample_aspect_ratio", "N/A"); print_str_opt("display_aspect_ratio", "N/A"); } s = av_get_pix_fmt_name(dec_ctx->pix_fmt); if (s) print_str ("pix_fmt", s); else print_str_opt("pix_fmt", "unknown"); print_int("level", dec_ctx->level); if (dec_ctx->timecode_frame_start >= 0) { char tcbuf[AV_TIMECODE_STR_SIZE]; av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start); print_str("timecode", tcbuf); } else { print_str_opt("timecode", "N/A"); } break; case AVMEDIA_TYPE_AUDIO: s = av_get_sample_fmt_name(dec_ctx->sample_fmt); if (s) print_str ("sample_fmt", s); else print_str_opt("sample_fmt", "unknown"); print_val("sample_rate", dec_ctx->sample_rate, unit_hertz_str); print_int("channels", dec_ctx->channels); if (dec_ctx->channel_layout) { av_bprint_clear(&pbuf); av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout); print_str ("channel_layout", pbuf.str); } else { print_str_opt("channel_layout", "unknown"); } print_int("bits_per_sample", av_get_bits_per_sample(dec_ctx->codec_id)); break; case AVMEDIA_TYPE_SUBTITLE: if (dec_ctx->width) print_int("width", dec_ctx->width); else print_str_opt("width", "N/A"); if (dec_ctx->height) print_int("height", dec_ctx->height); else print_str_opt("height", "N/A"); break; } } else { print_str_opt("codec_type", "unknown"); } if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt ("id", "0x%x", stream->id); else print_str_opt("id", "N/A"); print_q("r_frame_rate", stream->r_frame_rate, '/'); print_q("avg_frame_rate", stream->avg_frame_rate, '/'); print_q("time_base", stream->time_base, '/'); print_ts ("start_pts", stream->start_time); print_time("start_time", stream->start_time, &stream->time_base); print_ts ("duration_ts", stream->duration); print_time("duration", stream->duration, &stream->time_base); if (dec_ctx->bit_rate > 0) print_val ("bit_rate", dec_ctx->bit_rate, unit_bit_per_second_str); else print_str_opt("bit_rate", "N/A"); if (stream->nb_frames) print_fmt ("nb_frames", "%"PRId64, stream->nb_frames); else print_str_opt("nb_frames", "N/A"); if (nb_streams_frames[[[stream_idx]]]) print_fmt ("nb_read_frames", "%"PRIu64, nb_streams_frames[[[stream_idx]]]); else print_str_opt("nb_read_frames", "N/A"); if (nb_streams_packets[[[stream_idx]]]) print_fmt ("nb_read_packets", "%"PRIu64, nb_streams_packets[[[stream_idx]]]); else print_str_opt("nb_read_packets", "N/A"); if (do_show_data) writer_print_data(w, "extradata", dec_ctx->extradata, dec_ctx->extradata_size); #define PRINT_DISPOSITION(flagname, name) do { \ print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \ } while (0) if (do_show_stream_disposition) { writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION); PRINT_DISPOSITION(DEFAULT, "default"); PRINT_DISPOSITION(DUB, "dub"); PRINT_DISPOSITION(ORIGINAL, "original"); PRINT_DISPOSITION(COMMENT, "comment"); PRINT_DISPOSITION(LYRICS, "lyrics"); PRINT_DISPOSITION(KARAOKE, "karaoke"); PRINT_DISPOSITION(FORCED, "forced"); PRINT_DISPOSITION(HEARING_IMPAIRED, "hearing_impaired"); PRINT_DISPOSITION(VISUAL_IMPAIRED, "visual_impaired"); PRINT_DISPOSITION(CLEAN_EFFECTS, "clean_effects"); PRINT_DISPOSITION(ATTACHED_PIC, "attached_pic"); writer_print_section_footer(w); } show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS); writer_print_section_footer(w); av_bprint_finalize(&pbuf, NULL); fflush(stdout); }

[[[[Adv]]]]: static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int [[broadcastwyerc]], int in_program) { AVStream *stream = fmt_ctx->streams[[[broadcastwyerc]]]; AVCodecContext *dec_ctx; const AVCodec *dec; char [[rollryswi]][128]; const char *s; AVRational sar, dar; AVBPrint pbuf; av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED); writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM); print_int("index", stream->index); if ((dec_ctx = stream->codec)) { const char *profile = NULL; dec = dec_ctx->codec; if (dec) { print_str("codec_name", dec->name); if (!do_bitexact) { if (dec->long_name) print_str ("codec_long_name", dec->long_name); else print_str_opt("codec_long_name", "unknown"); } } else { print_str_opt("codec_name", "unknown"); if (!do_bitexact) { print_str_opt("codec_long_name", "unknown"); } } if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile))) print_str("profile", profile); else print_str_opt("profile", "unknown"); s = av_get_media_type_string(dec_ctx->codec_type); if (s) print_str ("codec_type", s); else print_str_opt("codec_type", "unknown"); print_q("codec_time_base", dec_ctx->time_base, '/'); av_get_codec_tag_string([[rollryswi]], sizeof([[rollryswi]]), dec_ctx->codec_tag); print_str("codec_tag_string", [[rollryswi]]); print_fmt("codec_tag", "0x%04x", dec_ctx->codec_tag); switch (dec_ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int("width", dec_ctx->width); print_int("height", dec_ctx->height); print_int("has_b_frames", dec_ctx->has_b_frames); sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL); if (sar.den) { print_q("sample_aspect_ratio", sar, ':'); av_reduce(&dar.num, &dar.den, dec_ctx->width * sar.num, dec_ctx->height * sar.den, 1024*1024); print_q("display_aspect_ratio", dar, ':'); } else { print_str_opt("sample_aspect_ratio", "N/A"); print_str_opt("display_aspect_ratio", "N/A"); } s = av_get_pix_fmt_name(dec_ctx->pix_fmt); if (s) print_str ("pix_fmt", s); else print_str_opt("pix_fmt", "unknown"); print_int("level", dec_ctx->level); if (dec_ctx->timecode_frame_start >= 0) { char tcbuf[AV_TIMECODE_STR_SIZE]; av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start); print_str("timecode", tcbuf); } else { print_str_opt("timecode", "N/A"); } break; case AVMEDIA_TYPE_AUDIO: s = av_get_sample_fmt_name(dec_ctx->sample_fmt); if (s) print_str ("sample_fmt", s); else print_str_opt("sample_fmt", "unknown"); print_val("sample_rate", dec_ctx->sample_rate, unit_hertz_str); print_int("channels", dec_ctx->channels); if (dec_ctx->channel_layout) { av_bprint_clear(&pbuf); av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout); print_str ("channel_layout", pbuf.str); } else { print_str_opt("channel_layout", "unknown"); } print_int("bits_per_sample", av_get_bits_per_sample(dec_ctx->codec_id)); break; case AVMEDIA_TYPE_SUBTITLE: if (dec_ctx->width) print_int("width", dec_ctx->width); else print_str_opt("width", "N/A"); if (dec_ctx->height) print_int("height", dec_ctx->height); else print_str_opt("height", "N/A"); break; } } else { print_str_opt("codec_type", "unknown"); } if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt ("id", "0x%x", stream->id); else print_str_opt("id", "N/A"); print_q("r_frame_rate", stream->r_frame_rate, '/'); print_q("avg_frame_rate", stream->avg_frame_rate, '/'); print_q("time_base", stream->time_base, '/'); print_ts ("start_pts", stream->start_time); print_time("start_time", stream->start_time, &stream->time_base); print_ts ("duration_ts", stream->duration); print_time("duration", stream->duration, &stream->time_base); if (dec_ctx->bit_rate > 0) print_val ("bit_rate", dec_ctx->bit_rate, unit_bit_per_second_str); else print_str_opt("bit_rate", "N/A"); if (stream->nb_frames) print_fmt ("nb_frames", "%"PRId64, stream->nb_frames); else print_str_opt("nb_frames", "N/A"); if (nb_streams_frames[[[broadcastwyerc]]]) print_fmt ("nb_read_frames", "%"PRIu64, nb_streams_frames[[[broadcastwyerc]]]); else print_str_opt("nb_read_frames", "N/A"); if (nb_streams_packets[[[broadcastwyerc]]]) print_fmt ("nb_read_packets", "%"PRIu64, nb_streams_packets[[[broadcastwyerc]]]); else print_str_opt("nb_read_packets", "N/A"); if (do_show_data) writer_print_data(w, "extradata", dec_ctx->extradata, dec_ctx->extradata_size); #define PRINT_DISPOSITION(flagname, name) do { \ print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \ } while (0) if (do_show_stream_disposition) { writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION); PRINT_DISPOSITION(DEFAULT, "default"); PRINT_DISPOSITION(DUB, "dub"); PRINT_DISPOSITION(ORIGINAL, "original"); PRINT_DISPOSITION(COMMENT, "comment"); PRINT_DISPOSITION(LYRICS, "lyrics"); PRINT_DISPOSITION(KARAOKE, "karaoke"); PRINT_DISPOSITION(FORCED, "forced"); PRINT_DISPOSITION(HEARING_IMPAIRED, "hearing_impaired"); PRINT_DISPOSITION(VISUAL_IMPAIRED, "visual_impaired"); PRINT_DISPOSITION(CLEAN_EFFECTS, "clean_effects"); PRINT_DISPOSITION(ATTACHED_PIC, "attached_pic"); writer_print_section_footer(w); } show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS); writer_print_section_footer(w); av_bprint_finalize(&pbuf, NULL); fflush(stdout); }[Succeeded / Failed / Skipped / Total] 582 / 119 / 398 / 1099:  41%|████      | 1099/2690 [2:50:06<4:06:16,  9.29s/it][Succeeded / Failed / Skipped / Total] 582 / 119 / 398 / 1099:  41%|████      | 1100/2690 [2:50:15<4:06:05,  9.29s/it][Succeeded / Failed / Skipped / Total] 583 / 119 / 398 / 1100:  41%|████      | 1100/2690 [2:50:15<4:06:05,  9.29s/it][Succeeded / Failed / Skipped / Total] 583 / 119 / 398 / 1100:  41%|████      | 1101/2690 [2:50:15<4:05:43,  9.28s/it][Succeeded / Failed / Skipped / Total] 583 / 119 / 399 / 1101:  41%|████      | 1101/2690 [2:50:15<4:05:43,  9.28s/it][Succeeded / Failed / Skipped / Total] 583 / 119 / 399 / 1101:  41%|████      | 1102/2690 [2:50:16<4:05:21,  9.27s/it][Succeeded / Failed / Skipped / Total] 583 / 119 / 400 / 1102:  41%|████      | 1102/2690 [2:50:16<4:05:21,  9.27s/it][Succeeded / Failed / Skipped / Total] 583 / 119 / 400 / 1102:  41%|████      | 1103/2690 [2:50:32<4:05:22,  9.28s/it][Succeeded / Failed / Skipped / Total] 584 / 119 / 400 / 1103:  41%|████      | 1103/2690 [2:50:32<4:05:22,  9.28s/it][Succeeded / Failed / Skipped / Total] 584 / 119 / 400 / 1103:  41%|████      | 1104/2690 [2:50:32<4:05:00,  9.27s/it]
--------------------------------------------- Result 1100 ---------------------------------------------
[[0 (45%)]] --> [[0 (74%)]] --> Socre: 0.7356343865394592

[[[[Adv]]]]: static int avi_write_packet(AVFormatContext *[[s]], AVPacket *pkt) { unsigned char tag[5]; unsigned int flags = 0; const int stream_index = pkt->stream_index; int size = pkt->size; AVIContext *avi = [[s]]->priv_data; AVIOContext *pb = [[s]]->pb; AVIStream *[[avist]] = [[s]]->streams[stream_index]->priv_data; AVCodecParameters *par = [[s]]->streams[stream_index]->codecpar; while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE && pkt->dts > [[avist]]->packet_count) { AVPacket empty_packet; av_init_packet(&empty_packet); empty_packet.size = 0; empty_packet.data = NULL; empty_packet.stream_index = stream_index; avi_write_packet([[s]], &empty_packet); } [[avist]]->packet_count++; if (pb->seekable && (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) { avi_write_ix([[s]]); ff_end_tag(pb, avi->movi_list); if (avi->riff_id == 1) avi_write_idx1([[s]]); ff_end_tag(pb, avi->riff_start); avi->movi_list = avi_start_new_riff([[s]], pb, "AVIX", "movi"); } avi_stream2fourcc(tag, stream_index, par->codec_type); if (pkt->flags & AV_PKT_FLAG_KEY) flags = 0x10; if (par->codec_type == AVMEDIA_TYPE_AUDIO) [[avist]]->audio_strm_length += size; if ([[s]]->pb->seekable) { int err; AVIIndex *idx = &[[avist]]->indexes; int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE; int id = idx->entry % AVI_INDEX_CLUSTER_SIZE; if (idx->ents_allocated <= idx->entry) { if ((err = av_reallocp(&idx->cluster, (cl + 1) * sizeof(*idx->cluster))) < 0) { idx->ents_allocated = 0; idx->entry = 0; return err; } idx->cluster[cl] = av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry)); if (!idx->cluster[cl]) return -1; idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE; } idx->cluster[cl][id].flags = flags; idx->cluster[cl][id].pos = avio_tell(pb) - avi->movi_list; idx->cluster[cl][id].len = size; idx->entry++; } avio_write(pb, tag, 4); avio_wl32(pb, size); avio_write(pb, pkt->data, size); if (size & 1) avio_w8(pb, 0); return 0; }

[[[[Adv]]]]: static int avi_write_packet(AVFormatContext *[[brent]], AVPacket *pkt) { unsigned char tag[5]; unsigned int flags = 0; const int stream_index = pkt->stream_index; int size = pkt->size; AVIContext *avi = [[brent]]->priv_data; AVIOContext *pb = [[brent]]->pb; AVIStream *[[avidiac]] = [[brent]]->streams[stream_index]->priv_data; AVCodecParameters *par = [[brent]]->streams[stream_index]->codecpar; while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE && pkt->dts > [[avidiac]]->packet_count) { AVPacket empty_packet; av_init_packet(&empty_packet); empty_packet.size = 0; empty_packet.data = NULL; empty_packet.stream_index = stream_index; avi_write_packet([[brent]], &empty_packet); } [[avidiac]]->packet_count++; if (pb->seekable && (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) { avi_write_ix([[brent]]); ff_end_tag(pb, avi->movi_list); if (avi->riff_id == 1) avi_write_idx1([[brent]]); ff_end_tag(pb, avi->riff_start); avi->movi_list = avi_start_new_riff([[brent]], pb, "AVIX", "movi"); } avi_stream2fourcc(tag, stream_index, par->codec_type); if (pkt->flags & AV_PKT_FLAG_KEY) flags = 0x10; if (par->codec_type == AVMEDIA_TYPE_AUDIO) [[avidiac]]->audio_strm_length += size; if ([[brent]]->pb->seekable) { int err; AVIIndex *idx = &[[avidiac]]->indexes; int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE; int id = idx->entry % AVI_INDEX_CLUSTER_SIZE; if (idx->ents_allocated <= idx->entry) { if ((err = av_reallocp(&idx->cluster, (cl + 1) * sizeof(*idx->cluster))) < 0) { idx->ents_allocated = 0; idx->entry = 0; return err; } idx->cluster[cl] = av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry)); if (!idx->cluster[cl]) return -1; idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE; } idx->cluster[cl][id].flags = flags; idx->cluster[cl][id].pos = avio_tell(pb) - avi->movi_list; idx->cluster[cl][id].len = size; idx->entry++; } avio_write(pb, tag, 4); avio_wl32(pb, size); avio_write(pb, pkt->data, size); if (size & 1) avio_w8(pb, 0); return 0; }
--------------------------------------------- Result 1101 ---------------------------------------------
[[0 (97%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size) { if (buf_size < 13) return AVERROR_INVALIDDATA; if (memcmp(buf, "FLV", 3)) return AVERROR_INVALIDDATA; buf += 13; buf_size -= 13; while (buf_size >= 11 + 4) { int type = buf[0]; int size = AV_RB24(&buf[1]) + 11 + 4; if (size > buf_size) return AVERROR_INVALIDDATA; if (type == 8 || type == 9) { if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets)) return AVERROR_INVALIDDATA; os->extra_packet_sizes[os->nb_extra_packets] = size; os->extra_packets[os->nb_extra_packets] = av_malloc(size); if (!os->extra_packets[os->nb_extra_packets]) return AVERROR(ENOMEM); memcpy(os->extra_packets[os->nb_extra_packets], buf, size); os->nb_extra_packets++; } else if (type == 0x12) { if (os->metadata) return AVERROR_INVALIDDATA; os->metadata_size = size - 11 - 4; os->metadata = av_malloc(os->metadata_size); if (!os->metadata) return AVERROR(ENOMEM); memcpy(os->metadata, buf + 11, os->metadata_size); } buf += size; buf_size -= size; } if (!os->metadata) return AVERROR_INVALIDDATA; return 0; }
--------------------------------------------- Result 1102 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc) { int err = 0; int i; __get_user(regs->CP0_EPC, &sc->sc_pc); __get_user(regs->active_tc.HI[0], &sc->sc_mdhi); __get_user(regs->active_tc.LO[0], &sc->sc_mdlo); for (i = 1; i < 32; ++i) { __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]); } __get_user(regs->active_tc.HI[1], &sc->sc_hi1); __get_user(regs->active_tc.HI[2], &sc->sc_hi2); __get_user(regs->active_tc.HI[3], &sc->sc_hi3); __get_user(regs->active_tc.LO[1], &sc->sc_lo1); __get_user(regs->active_tc.LO[2], &sc->sc_lo2); __get_user(regs->active_tc.LO[3], &sc->sc_lo3); { uint32_t dsp; __get_user(dsp, &sc->sc_dsp); cpu_wrdsp(dsp, 0x3ff, regs); } for (i = 0; i < 32; ++i) { __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]); } return err; }
--------------------------------------------- Result 1103 ---------------------------------------------
[[0 (64%)]] --> [[0 (17%)]] --> Socre: 0.8346429467201233

[[[[Adv]]]]: static inline int get_block(GetBitContext *[[gb]], DCTELEM *block, const uint8_t *scan, const uint32_t *quant) { int [[coeff]], i, n; int8_t ac; uint8_t dc = get_bits([[gb]], 8); if (dc == 255) [[coeff]] = get_bits([[gb]], 6); if (get_bits_count([[gb]]) + ([[coeff]] << 1) >= [[gb]]->size_in_bits) memset(block, 0, 64 * sizeof(DCTELEM)); while ([[coeff]]) { ac = get_sbits([[gb]], 2); if (ac == -2) break; PUT_COEFF(ac); } ALIGN(4); while ([[coeff]]) { ac = get_sbits([[gb]], 4); if (ac == -8) break; PUT_COEFF(ac); } ALIGN(8); if (get_bits_count([[gb]]) + ([[coeff]] << 3) >= [[gb]]->size_in_bits) while ([[coeff]]) { ac = get_sbits([[gb]], 8); PUT_COEFF(ac); } PUT_COEFF(dc); return 1; }

[[[[Adv]]]]: static inline int get_block(GetBitContext *[[uk]], DCTELEM *block, const uint8_t *scan, const uint32_t *quant) { int [[veffed]], i, n; int8_t ac; uint8_t dc = get_bits([[uk]], 8); if (dc == 255) [[veffed]] = get_bits([[uk]], 6); if (get_bits_count([[uk]]) + ([[veffed]] << 1) >= [[uk]]->size_in_bits) memset(block, 0, 64 * sizeof(DCTELEM)); while ([[veffed]]) { ac = get_sbits([[uk]], 2); if (ac == -2) break; PUT_COEFF(ac); } ALIGN(4); while ([[veffed]]) { ac = get_sbits([[uk]], 4); if (ac == -8) break; PUT_COEFF(ac); } ALIGN(8); if (get_bits_count([[uk]]) + ([[veffed]] << 3) >= [[uk]]->size_in_bits) while ([[veffed]]) { ac = get_sbits([[uk]], 8); PUT_COEFF(ac); } PUT_COEFF(dc); return 1; }
--------------------------------------------- Result 1104 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 584 / 119 / 401 / 1104:  41%|████      | 1104/2690 [2:50:32<4:05:00,  9.27s/it][Succeeded / Failed / Skipped / Total] 584 / 119 / 401 / 1104:  41%|████      | 1105/2690 [2:50:33<4:04:38,  9.26s/it][Succeeded / Failed / Skipped / Total] 584 / 119 / 402 / 1105:  41%|████      | 1105/2690 [2:50:33<4:04:38,  9.26s/it][Succeeded / Failed / Skipped / Total] 584 / 119 / 402 / 1105:  41%|████      | 1106/2690 [2:50:37<4:04:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 585 / 119 / 402 / 1106:  41%|████      | 1106/2690 [2:50:37<4:04:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 585 / 119 / 402 / 1106:  41%|████      | 1107/2690 [2:50:56<4:04:26,  9.26s/it][Succeeded / Failed / Skipped / Total] 586 / 119 / 402 / 1107:  41%|████      | 1107/2690 [2:50:56<4:04:26,  9.26s/it][Succeeded / Failed / Skipped / Total] 586 / 119 / 402 / 1107:  41%|████      | 1108/2690 [2:50:56<4:04:04,  9.26s/it][Succeeded / Failed / Skipped / Total] 586 / 119 / 403 / 1108:  41%|████      | 1108/2690 [2:50:56<4:04:04,  9.26s/it][Succeeded / Failed / Skipped / Total] 586 / 119 / 403 / 1108:  41%|████      | 1109/2690 [2:50:57<4:03:42,  9.25s/it][Succeeded / Failed / Skipped / Total] 586 / 119 / 404 / 1109:  41%|████      | 1109/2690 [2:50:57<4:03:42,  9.25s/it][Succeeded / Failed / Skipped / Total] 586 / 119 / 404 / 1109:  41%|████▏     | 1110/2690 [2:50:57<4:03:21,  9.24s/it][Succeeded / Failed / Skipped / Total] 587 / 119 / 404 / 1110:  41%|████▏     | 1110/2690 [2:50:57<4:03:21,  9.24s/it][Succeeded / Failed / Skipped / Total] 587 / 119 / 404 / 1110:  41%|████▏     | 1111/2690 [2:50:58<4:02:59,  9.23s/it][Succeeded / Failed / Skipped / Total] 587 / 119 / 405 / 1111:  41%|████▏     | 1111/2690 [2:50:58<4:02:59,  9.23s/it][Succeeded / Failed / Skipped / Total] 587 / 119 / 405 / 1111:  41%|████▏     | 1112/2690 [2:51:09<4:02:52,  9.23s/it][[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static AHCIQState *ahci_boot(void) { AHCIQState *s; const char *cli; s = g_malloc0(sizeof(AHCIQState)); cli = "-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s" ",format=qcow2" " -M q35 " "-device ide-hd,drive=drive0 " "-global ide-hd.ver=%s"; s->parent = qtest_pc_boot(cli, tmp_path, "testdisk", "version"); alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT); s->dev = get_ahci_device(&s->fingerprint); return s; }
--------------------------------------------- Result 1105 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void address_space_destroy_dispatch(AddressSpace *as) { AddressSpaceDispatch *d = as->dispatch; memory_listener_unregister(&d->listener); g_free(d); as->dispatch = NULL; }
--------------------------------------------- Result 1106 ---------------------------------------------
[[0 (26%)]] --> [[0 (58%)]] --> Socre: 0.5846925377845764

[[[[Adv]]]]: static void sdhci_write_block_to_card(SDHCIState *[[s]]) { int index = 0; if ([[s]]->prnsts & SDHC_SPACE_AVAILABLE) { if ([[s]]->norintstsen & SDHC_NISEN_WBUFRDY) { [[s]]->norintsts |= SDHC_NIS_WBUFRDY; } sdhci_update_irq([[s]]); return; } if ([[s]]->trnmod & SDHC_TRNS_BLK_CNT_EN) { if ([[s]]->blkcnt == 0) { return; } else { [[s]]->blkcnt--; } } for (index = 0; index < ([[s]]->blksize & 0x0fff); index++) { sd_write_data([[s]]->card, [[s]]->fifo_buffer[index]); } [[s]]->prnsts |= SDHC_SPACE_AVAILABLE; if (([[s]]->trnmod & SDHC_TRNS_MULTI) == 0 || (([[s]]->trnmod & SDHC_TRNS_MULTI) && ([[s]]->trnmod & SDHC_TRNS_BLK_CNT_EN) && ([[s]]->blkcnt == 0))) { SDHCI_GET_CLASS([[s]])->end_data_transfer([[s]]); } else if ([[s]]->norintstsen & SDHC_NISEN_WBUFRDY) { [[s]]->norintsts |= SDHC_NIS_WBUFRDY; } if ([[s]]->stopped_state == sdhc_gap_write && ([[s]]->trnmod & SDHC_TRNS_MULTI) && [[s]]->blkcnt > 0) { [[s]]->prnsts &= ~SDHC_DOING_WRITE; if ([[s]]->norintstsen & SDHC_EISEN_BLKGAP) { [[s]]->norintsts |= SDHC_EIS_BLKGAP; } SDHCI_GET_CLASS([[s]])->end_data_transfer([[s]]); } sdhci_update_irq([[s]]); }

[[[[Adv]]]]: static void sdhci_write_block_to_card(SDHCIState *[[с]]) { int index = 0; if ([[с]]->prnsts & SDHC_SPACE_AVAILABLE) { if ([[с]]->norintstsen & SDHC_NISEN_WBUFRDY) { [[с]]->norintsts |= SDHC_NIS_WBUFRDY; } sdhci_update_irq([[с]]); return; } if ([[с]]->trnmod & SDHC_TRNS_BLK_CNT_EN) { if ([[с]]->blkcnt == 0) { return; } else { [[с]]->blkcnt--; } } for (index = 0; index < ([[с]]->blksize & 0x0fff); index++) { sd_write_data([[с]]->card, [[с]]->fifo_buffer[index]); } [[с]]->prnsts |= SDHC_SPACE_AVAILABLE; if (([[с]]->trnmod & SDHC_TRNS_MULTI) == 0 || (([[с]]->trnmod & SDHC_TRNS_MULTI) && ([[с]]->trnmod & SDHC_TRNS_BLK_CNT_EN) && ([[с]]->blkcnt == 0))) { SDHCI_GET_CLASS([[с]])->end_data_transfer([[с]]); } else if ([[с]]->norintstsen & SDHC_NISEN_WBUFRDY) { [[с]]->norintsts |= SDHC_NIS_WBUFRDY; } if ([[с]]->stopped_state == sdhc_gap_write && ([[с]]->trnmod & SDHC_TRNS_MULTI) && [[с]]->blkcnt > 0) { [[с]]->prnsts &= ~SDHC_DOING_WRITE; if ([[с]]->norintstsen & SDHC_EISEN_BLKGAP) { [[с]]->norintsts |= SDHC_EIS_BLKGAP; } SDHCI_GET_CLASS([[с]])->end_data_transfer([[с]]); } sdhci_update_irq([[с]]); }
--------------------------------------------- Result 1107 ---------------------------------------------
[[0 (14%)]] --> [[0 (98%)]] --> Socre: 0.9803339838981628

[[[[Adv]]]]: static int pci_piix_ide_initfn(PCIIDEState *[[d]]) { uint8_t *pci_conf = [[d]]->dev.config; pci_conf[PCI_CLASS_PROG] = 0x80; pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE); qemu_register_reset(piix3_reset, [[d]]); pci_register_bar(&[[d]]->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map); vmstate_register(&[[d]]->dev.qdev, 0, &vmstate_ide_pci, [[d]]); pci_piix_init_ports([[d]]); return 0; }

[[[[Adv]]]]: static int pci_piix_ide_initfn(PCIIDEState *[[δ]]) { uint8_t *pci_conf = [[δ]]->dev.config; pci_conf[PCI_CLASS_PROG] = 0x80; pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE); qemu_register_reset(piix3_reset, [[δ]]); pci_register_bar(&[[δ]]->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map); vmstate_register(&[[δ]]->dev.qdev, 0, &vmstate_ide_pci, [[δ]]); pci_piix_init_ports([[δ]]); return 0; }
--------------------------------------------- Result 1108 ---------------------------------------------
[[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp) { DeviceState *qdev = DEVICE(vpci_dev); VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev); DeviceState *vdev = DEVICE(&dev->vdev); virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features); virtio_net_set_netclient_name(&dev->vdev, qdev->id, object_get_typename(OBJECT(qdev))); qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus)); object_property_set_bool(OBJECT(vdev), "True" == "True", "realized", errp); }
--------------------------------------------- Result 1109 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp) { sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev); int ret; if (nvram->blk) { nvram->size = blk_getlength(nvram->blk); ret = blk_set_perm(nvram->blk, BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE, BLK_PERM_ALL, errp); if (ret < 0) { return; } } else { nvram->size = DEFAULT_NVRAM_SIZE; } nvram->buf = g_malloc0(nvram->size); if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) { error_setg(errp, "spapr-nvram must be between %d and %d bytes in size", MIN_NVRAM_SIZE, MAX_NVRAM_SIZE); return; } if (nvram->blk) { int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size); if (alen != nvram->size) { error_setg(errp, "can't read spapr-nvram contents"); return; } } else if (nb_prom_envs > 0) { chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4); chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4], nvram->size - MIN_NVRAM_SIZE / 4); } spapr_rtas_register(RTAS_NVRAM_FETCH, "nvram-fetch", rtas_nvram_fetch); spapr_rtas_register(RTAS_NVRAM_STORE, "nvram-store", rtas_nvram_store); }
--------------------------------------------- Result 1110 ---------------------------------------------
[[0 (1%)]] --> [[0 (58%)]] --> Socre: 0.5791791677474976

[[[[Adv]]]]: mst_fpga_readb(void *opaque, target_phys_addr_t [[addr]]) { mst_irq_state *s = (mst_irq_state *) opaque; switch ([[addr]]) { case MST_LEDDAT1: return s->leddat1; case MST_LEDDAT2: return s->leddat2; case MST_LEDCTRL: return s->ledctrl; case MST_GPSWR: return s->gpswr; case MST_MSCWR1: return s->mscwr1; case MST_MSCWR2: return s->mscwr2; case MST_MSCWR3: return s->mscwr3; case MST_MSCRD: return s->mscrd; case MST_INTMSKENA: return s->intmskena; case MST_INTSETCLR: return s->intsetclr; case MST_PCMCIA0: return s->pcmcia0; case MST_PCMCIA1: return s->pcmcia1; default: printf("Mainstone - mst_fpga_readb: Bad register offset " "0x" TARGET_FMT_plx " \n", [[addr]]); } return 0; }

[[[[Adv]]]]: mst_fpga_readb(void *opaque, target_phys_addr_t [[adsर]]) { mst_irq_state *s = (mst_irq_state *) opaque; switch ([[adsर]]) { case MST_LEDDAT1: return s->leddat1; case MST_LEDDAT2: return s->leddat2; case MST_LEDCTRL: return s->ledctrl; case MST_GPSWR: return s->gpswr; case MST_MSCWR1: return s->mscwr1; case MST_MSCWR2: return s->mscwr2; case MST_MSCWR3: return s->mscwr3; case MST_MSCRD: return s->mscrd; case MST_INTMSKENA: return s->intmskena; case MST_INTSETCLR: return s->intsetclr; case MST_PCMCIA0: return s->pcmcia0; case MST_PCMCIA1: return s->pcmcia1; default: printf("Mainstone - mst_fpga_readb: Bad register offset " "0x" TARGET_FMT_plx " \n", [[adsर]]); } return 0; }
--------------------------------------------- Result 1111 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused) { RENAME(nvXXtoUV)(dstU, dstV, src1, width); }
--------------------------------------------- Result 1112 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 587 / 120 / 405 / 1112:  41%|████▏     | 1112/2690 [2:51:09<4:02:52,  9.23s/it][Succeeded / Failed / Skipped / Total] 587 / 120 / 405 / 1112:  41%|████▏     | 1113/2690 [2:51:12<4:02:34,  9.23s/it][Succeeded / Failed / Skipped / Total] 587 / 121 / 405 / 1113:  41%|████▏     | 1113/2690 [2:51:12<4:02:34,  9.23s/it][Succeeded / Failed / Skipped / Total] 587 / 121 / 405 / 1113:  41%|████▏     | 1114/2690 [2:51:20<4:02:24,  9.23s/it][Succeeded / Failed / Skipped / Total] 587 / 122 / 405 / 1114:  41%|████▏     | 1114/2690 [2:51:20<4:02:24,  9.23s/it][Succeeded / Failed / Skipped / Total] 587 / 122 / 405 / 1114:  41%|████▏     | 1115/2690 [2:51:35<4:02:23,  9.23s/it][Succeeded / Failed / Skipped / Total] 588 / 122 / 405 / 1115:  41%|████▏     | 1115/2690 [2:51:35<4:02:23,  9.23s/it][Succeeded / Failed / Skipped / Total] 588 / 122 / 405 / 1115:  41%|████▏     | 1116/2690 [2:51:36<4:02:01,  9.23s/it][Succeeded / Failed / Skipped / Total] 588 / 122 / 406 / 1116:  41%|████▏     | 1116/2690 [2:51:36<4:02:01,  9.23s/it][Succeeded / Failed / Skipped / Total] 588 / 122 / 406 / 1116:  42%|████▏     | 1117/2690 [2:51:44<4:01:51,  9.23s/it][Succeeded / Failed / Skipped / Total] 589 / 122 / 406 / 1117:  42%|████▏     | 1117/2690 [2:51:44<4:01:51,  9.23s/it][Succeeded / Failed / Skipped / Total] 589 / 122 / 406 / 1117:  42%|████▏     | 1118/2690 [2:51:55<4:01:44,  9.23s/it][[0 (87%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void gen_neon_trn_u16(TCGv [[t0]], TCGv [[t1]]) { TCGv [[rd]], tmp; [[rd]] = new_tmp(); tmp = new_tmp(); tcg_gen_shli_i32([[rd]], [[t0]], 16); tcg_gen_andi_i32(tmp, [[t1]], 0xffff); tcg_gen_or_i32([[rd]], [[rd]], tmp); tcg_gen_shri_i32([[t1]], [[t1]], 16); tcg_gen_andi_i32(tmp, [[t0]], 0xffff0000); tcg_gen_or_i32([[t1]], [[t1]], tmp); tcg_gen_mov_i32([[t0]], [[rd]]); dead_tmp(tmp); dead_tmp([[rd]]); }

[[[[Adv]]]]: static void gen_neon_trn_u16(TCGv [[pt9]], TCGv [[waiti]]) { TCGv [[road]], tmp; [[road]] = new_tmp(); tmp = new_tmp(); tcg_gen_shli_i32([[road]], [[pt9]], 16); tcg_gen_andi_i32(tmp, [[waiti]], 0xffff); tcg_gen_or_i32([[road]], [[road]], tmp); tcg_gen_shri_i32([[waiti]], [[waiti]], 16); tcg_gen_andi_i32(tmp, [[pt9]], 0xffff0000); tcg_gen_or_i32([[waiti]], [[waiti]], tmp); tcg_gen_mov_i32([[pt9]], [[road]]); dead_tmp(tmp); dead_tmp([[road]]); }
--------------------------------------------- Result 1113 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ehci_free_packet(EHCIPacket *[[p]]) { trace_usb_ehci_packet_action([[p]]->queue, [[p]], "free"); if ([[p]]->async == EHCI_ASYNC_INFLIGHT) { usb_cancel_packet(&[[p]]->packet); usb_packet_unmap(&[[p]]->packet, &[[p]]->sgl); qemu_sglist_destroy(&[[p]]->sgl); QTAILQ_REMOVE(&[[p]]->queue->packets, [[p]], next); usb_packet_cleanup(&[[p]]->packet); g_free([[p]]);

[[[[Adv]]]]: static void ehci_free_packet(EHCIPacket *[[п]]) { trace_usb_ehci_packet_action([[п]]->queue, [[п]], "free"); if ([[п]]->async == EHCI_ASYNC_INFLIGHT) { usb_cancel_packet(&[[п]]->packet); usb_packet_unmap(&[[п]]->packet, &[[п]]->sgl); qemu_sglist_destroy(&[[п]]->sgl); QTAILQ_REMOVE(&[[п]]->queue->packets, [[п]], next); usb_packet_cleanup(&[[п]]->packet); g_free([[п]]);
--------------------------------------------- Result 1114 ---------------------------------------------
[[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int ff_thread_init(AVCodecContext *[[avctx]]) { if ([[avctx]]->thread_opaque) { av_log([[avctx]], AV_LOG_ERROR, "avcodec_thread_init is ignored after avcodec_open\n"); return -1; } #if HAVE_W32THREADS w32thread_init(); #endif if ([[avctx]]->codec) { validate_thread_parameters([[avctx]]); if ([[avctx]]->active_thread_type&FF_THREAD_SLICE) return thread_init([[avctx]]); else if ([[avctx]]->active_thread_type&FF_THREAD_FRAME) return frame_thread_init([[avctx]]); } return 0; }

[[[[Adv]]]]: int ff_thread_init(AVCodecContext *[[viacentp]]) { if ([[viacentp]]->thread_opaque) { av_log([[viacentp]], AV_LOG_ERROR, "avcodec_thread_init is ignored after avcodec_open\n"); return -1; } #if HAVE_W32THREADS w32thread_init(); #endif if ([[viacentp]]->codec) { validate_thread_parameters([[viacentp]]); if ([[viacentp]]->active_thread_type&FF_THREAD_SLICE) return thread_init([[viacentp]]); else if ([[viacentp]]->active_thread_type&FF_THREAD_FRAME) return frame_thread_init([[viacentp]]); } return 0; }
--------------------------------------------- Result 1115 ---------------------------------------------
[[0 (36%)]] --> [[0 (72%)]] --> Socre: 0.7244513630867004

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk) { VirtIOBlock *[[s]]; int cylinders, heads, secs; static int [[virtio_blk_id]]; DriveInfo *dinfo; if (!blk->conf.bs) { error_report("drive property not set"); return NULL; } if (!bdrv_is_inserted(blk->conf.bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!blk->serial) { dinfo = drive_get_by_blockdev(blk->conf.bs); if (*dinfo->serial) { blk->serial = strdup(dinfo->serial); } } [[s]] = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); [[s]]->vdev.get_config = virtio_blk_update_config; [[s]]->vdev.get_features = virtio_blk_get_features; [[s]]->vdev.reset = virtio_blk_reset; [[s]]->bs = blk->conf.bs; [[s]]->conf = &blk->conf; [[s]]->blk = blk; [[s]]->rq = NULL; [[s]]->sector_mask = ([[s]]->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry([[s]]->bs, &cylinders, &heads, &secs); [[s]]->vq = virtio_add_queue(&[[s]]->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, [[s]]); [[s]]->qdev = dev; register_savevm(dev, "virtio-blk", [[virtio_blk_id]]++, 2, virtio_blk_save, virtio_blk_load, [[s]]); bdrv_set_dev_ops([[s]]->bs, &virtio_block_ops, [[s]]); bdrv_set_buffer_alignment([[s]]->bs, [[s]]->conf->logical_block_size); bdrv_iostatus_enable([[s]]->bs); add_boot_device_path([[s]]->conf->bootindex, dev, "/disk@0,0"); return &[[s]]->vdev; }

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk) { VirtIOBlock *[[bars]]; int cylinders, heads, secs; static int [[vuladoovonbcлfactorgage]]; DriveInfo *dinfo; if (!blk->conf.bs) { error_report("drive property not set"); return NULL; } if (!bdrv_is_inserted(blk->conf.bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!blk->serial) { dinfo = drive_get_by_blockdev(blk->conf.bs); if (*dinfo->serial) { blk->serial = strdup(dinfo->serial); } } [[bars]] = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); [[bars]]->vdev.get_config = virtio_blk_update_config; [[bars]]->vdev.get_features = virtio_blk_get_features; [[bars]]->vdev.reset = virtio_blk_reset; [[bars]]->bs = blk->conf.bs; [[bars]]->conf = &blk->conf; [[bars]]->blk = blk; [[bars]]->rq = NULL; [[bars]]->sector_mask = ([[bars]]->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry([[bars]]->bs, &cylinders, &heads, &secs); [[bars]]->vq = virtio_add_queue(&[[bars]]->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, [[bars]]); [[bars]]->qdev = dev; register_savevm(dev, "virtio-blk", [[vuladoovonbcлfactorgage]]++, 2, virtio_blk_save, virtio_blk_load, [[bars]]); bdrv_set_dev_ops([[bars]]->bs, &virtio_block_ops, [[bars]]); bdrv_set_buffer_alignment([[bars]]->bs, [[bars]]->conf->logical_block_size); bdrv_iostatus_enable([[bars]]->bs); add_boot_device_path([[bars]]->conf->bootindex, dev, "/disk@0,0"); return &[[bars]]->vdev; }
--------------------------------------------- Result 1116 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value) { if (ri->crm > 8) { return EXCP_UDEF; } env->cp15.c6_region[ri->crm] = value; return 0; }
--------------------------------------------- Result 1117 ---------------------------------------------
[[0 (2%)]] --> [[0 (84%)]] --> Socre: 0.8391140699386597

[[[[Adv]]]]: static inline bool memory_access_is_direct(MemoryRegion *[[mr]], bool [[is_write]]) { if (memory_region_is_ram([[mr]])) { return !([[is_write]] && [[mr]]->readonly); } if (memory_region_is_romd([[mr]])) { return ![[is_write]]; } return "False" != "False"; }

[[[[Adv]]]]: static inline bool memory_access_is_direct(MemoryRegion *[[bob]], bool [[andvchange]]) { if (memory_region_is_ram([[bob]])) { return !([[andvchange]] && [[bob]]->readonly); } if (memory_region_is_romd([[bob]])) { return ![[andvchange]]; } return "False" != "False"; }
--------------------------------------------- Result 1118 ---------------------------------------------
[[0 (100%)]] --> [[0 (44%)]] --> Socre: 0.5577722191810608

[[[[Adv]]]]: static int pcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *[[avpkt]]) { const uint8_t *buf = [[avpkt]]->data; int buf_size = [[avpkt]]->size; PCMDecode *s = avctx->priv_data; int sample_size, c, n, i; short *samples; const uint8_t *src, *src8, *src2[MAX_CHANNELS]; uint8_t *dstu8; int16_t *dst_int16_t; int32_t *dst_int32_t; int64_t *dst_int64_t; uint16_t *dst_uint16_t; uint32_t *dst_uint32_t; samples = data; src = buf; if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) { av_log(avctx, AV_LOG_ERROR, "invalid sample_fmt\n"); return -1; if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){ av_log(avctx, AV_LOG_ERROR, "PCM channels out of bounds\n"); return -1; sample_size = av_get_bits_per_sample(avctx->codec_id)/8; if (CODEC_ID_PCM_DVD == avctx->codec_id) sample_size = avctx->bits_per_coded_sample * 2 / 8; else if (avctx->codec_id == CODEC_ID_PCM_LXF) sample_size = 5; n = avctx->channels * sample_size; if(n && buf_size % n){ if (buf_size < n) { av_log(avctx, AV_LOG_ERROR, "invalid PCM packet\n"); return -1; }else buf_size -= buf_size % n; buf_size= FFMIN(buf_size, *data_size/2); *data_size=0; n = buf_size/sample_size; switch(avctx->codec->id) { case CODEC_ID_PCM_U32LE: DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_U32BE: DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_S24LE: DECODE(int32_t, le24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_S24BE: DECODE(int32_t, be24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_U24LE: DECODE(uint32_t, le24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_U24BE: DECODE(uint32_t, be24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_S24DAUD: for(;n>0;n--) { uint32_t v = bytestream_get_be24(&src); v >>= 4; *samples++ = av_reverse[(v >> 8) & 0xff] + (av_reverse[v & 0xff] << 8); break; case CODEC_ID_PCM_S16LE_PLANAR: n /= avctx->channels; for(c=0;c<avctx->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<avctx->channels;c++) *samples++ = bytestream_get_le16(&src2[c]); src = src2[avctx->channels-1]; break; case CODEC_ID_PCM_U16LE: DECODE(uint16_t, le16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_U16BE: DECODE(uint16_t, be16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_S8: dstu8= (uint8_t*)samples; for(;n>0;n--) { *dstu8++ = *src++ + 128; samples= (short*)dstu8; break; #if HAVE_BIGENDIAN case CODEC_ID_PCM_F64LE: DECODE(int64_t, le64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_F32LE: DECODE(int32_t, le32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16LE: DECODE(int16_t, le16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64BE: case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: case CODEC_ID_PCM_S16BE: #else case CODEC_ID_PCM_F64BE: DECODE(int64_t, be64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: DECODE(int32_t, be32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16BE: DECODE(int16_t, be16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64LE: case CODEC_ID_PCM_F32LE: case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_S16LE: #endif case CODEC_ID_PCM_U8: memcpy(samples, src, n*sample_size); src += n*sample_size; samples = (short*)((uint8_t*)data + n*sample_size); break; case CODEC_ID_PCM_ZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; *samples++ = x << 8; break; case CODEC_ID_PCM_ALAW: case CODEC_ID_PCM_MULAW: for(;n>0;n--) { *samples++ = s->table[*src++]; break; case CODEC_ID_PCM_DVD: dst_int32_t = data; n /= avctx->channels; switch (avctx->bits_per_coded_sample) { case 20: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8 &0xf0) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12); src = src8; break; case 24: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); src = src8; break; default: av_log(avctx, AV_LOG_ERROR, "PCM DVD unsupported sample depth\n"); return -1; break; samples = (short *) dst_int32_t; break; case CODEC_ID_PCM_LXF: dst_int32_t = data; n /= avctx->channels; for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); src += n * avctx->channels * 5; samples = (short *) dst_int32_t; break; default: return -1; *data_size = (uint8_t *)samples - (uint8_t *)data; return src - buf;

[[[[Adv]]]]: static int pcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *[[asaпxt]]) { const uint8_t *buf = [[asaпxt]]->data; int buf_size = [[asaпxt]]->size; PCMDecode *s = avctx->priv_data; int sample_size, c, n, i; short *samples; const uint8_t *src, *src8, *src2[MAX_CHANNELS]; uint8_t *dstu8; int16_t *dst_int16_t; int32_t *dst_int32_t; int64_t *dst_int64_t; uint16_t *dst_uint16_t; uint32_t *dst_uint32_t; samples = data; src = buf; if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) { av_log(avctx, AV_LOG_ERROR, "invalid sample_fmt\n"); return -1; if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){ av_log(avctx, AV_LOG_ERROR, "PCM channels out of bounds\n"); return -1; sample_size = av_get_bits_per_sample(avctx->codec_id)/8; if (CODEC_ID_PCM_DVD == avctx->codec_id) sample_size = avctx->bits_per_coded_sample * 2 / 8; else if (avctx->codec_id == CODEC_ID_PCM_LXF) sample_size = 5; n = avctx->channels * sample_size; if(n && buf_size % n){ if (buf_size < n) { av_log(avctx, AV_LOG_ERROR, "invalid PCM packet\n"); return -1; }else buf_size -= buf_size % n; buf_size= FFMIN(buf_size, *data_size/2); *data_size=0; n = buf_size/sample_size; switch(avctx->codec->id) { case CODEC_ID_PCM_U32LE: DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_U32BE: DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_S24LE: DECODE(int32_t, le24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_S24BE: DECODE(int32_t, be24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_U24LE: DECODE(uint32_t, le24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_U24BE: DECODE(uint32_t, be24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_S24DAUD: for(;n>0;n--) { uint32_t v = bytestream_get_be24(&src); v >>= 4; *samples++ = av_reverse[(v >> 8) & 0xff] + (av_reverse[v & 0xff] << 8); break; case CODEC_ID_PCM_S16LE_PLANAR: n /= avctx->channels; for(c=0;c<avctx->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<avctx->channels;c++) *samples++ = bytestream_get_le16(&src2[c]); src = src2[avctx->channels-1]; break; case CODEC_ID_PCM_U16LE: DECODE(uint16_t, le16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_U16BE: DECODE(uint16_t, be16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_S8: dstu8= (uint8_t*)samples; for(;n>0;n--) { *dstu8++ = *src++ + 128; samples= (short*)dstu8; break; #if HAVE_BIGENDIAN case CODEC_ID_PCM_F64LE: DECODE(int64_t, le64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_F32LE: DECODE(int32_t, le32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16LE: DECODE(int16_t, le16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64BE: case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: case CODEC_ID_PCM_S16BE: #else case CODEC_ID_PCM_F64BE: DECODE(int64_t, be64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: DECODE(int32_t, be32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16BE: DECODE(int16_t, be16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64LE: case CODEC_ID_PCM_F32LE: case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_S16LE: #endif case CODEC_ID_PCM_U8: memcpy(samples, src, n*sample_size); src += n*sample_size; samples = (short*)((uint8_t*)data + n*sample_size); break; case CODEC_ID_PCM_ZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; *samples++ = x << 8; break; case CODEC_ID_PCM_ALAW: case CODEC_ID_PCM_MULAW: for(;n>0;n--) { *samples++ = s->table[*src++]; break; case CODEC_ID_PCM_DVD: dst_int32_t = data; n /= avctx->channels; switch (avctx->bits_per_coded_sample) { case 20: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8 &0xf0) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12); src = src8; break; case 24: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); src = src8; break; default: av_log(avctx, AV_LOG_ERROR, "PCM DVD unsupported sample depth\n"); return -1; break; samples = (short *) dst_int32_t; break; case CODEC_ID_PCM_LXF: dst_int32_t = data; n /= avctx->channels; for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); src += n * avctx->channels * 5; samples = (short *) dst_int32_t; break; default: return -1; *data_size = (uint8_t *)samples - (uint8_t *)data; return src - buf;[Succeeded / Failed / Skipped / Total] 590 / 122 / 406 / 1118:  42%|████▏     | 1118/2690 [2:51:55<4:01:44,  9.23s/it][Succeeded / Failed / Skipped / Total] 590 / 122 / 406 / 1118:  42%|████▏     | 1119/2690 [2:52:10<4:01:43,  9.23s/it][Succeeded / Failed / Skipped / Total] 591 / 122 / 406 / 1119:  42%|████▏     | 1119/2690 [2:52:10<4:01:43,  9.23s/it][Succeeded / Failed / Skipped / Total] 591 / 122 / 406 / 1119:  42%|████▏     | 1120/2690 [2:52:33<4:01:54,  9.24s/it][Succeeded / Failed / Skipped / Total] 592 / 122 / 406 / 1120:  42%|████▏     | 1120/2690 [2:52:33<4:01:54,  9.24s/it][Succeeded / Failed / Skipped / Total] 592 / 122 / 406 / 1120:  42%|████▏     | 1121/2690 [2:52:34<4:01:32,  9.24s/it][Succeeded / Failed / Skipped / Total] 592 / 122 / 407 / 1121:  42%|████▏     | 1121/2690 [2:52:34<4:01:32,  9.24s/it][Succeeded / Failed / Skipped / Total] 592 / 122 / 407 / 1121:  42%|████▏     | 1122/2690 [2:52:39<4:01:17,  9.23s/it][Succeeded / Failed / Skipped / Total] 593 / 122 / 407 / 1122:  42%|████▏     | 1122/2690 [2:52:39<4:01:17,  9.23s/it][Succeeded / Failed / Skipped / Total] 593 / 122 / 407 / 1122:  42%|████▏     | 1123/2690 [2:53:04<4:01:30,  9.25s/it]
--------------------------------------------- Result 1119 ---------------------------------------------
[[0 (65%)]] --> [[0 (28%)]] --> Socre: 0.723262757062912

[[[[Adv]]]]: static int esp_pci_scsi_init(PCIDevice *dev) { PCIESPState *pci = PCI_ESP(dev); DeviceState *d = DEVICE(dev); ESPState *s = &pci->esp; uint8_t *pci_conf; Error *[[err]] = NULL; pci_conf = dev->config; pci_conf[PCI_INTERRUPT_PIN] = 0x01; s->dma_memory_read = esp_pci_dma_memory_read; s->dma_memory_write = esp_pci_dma_memory_write; s->dma_opaque = pci; s->chip_id = TCHI_AM53C974; memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci, "esp-io", 0x80); pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io); s->irq = pci_allocate_irq(dev); scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, &[[err]]); if ([[err]] != NULL) { error_free([[err]]); return -1; } } return 0; }

[[[[Adv]]]]: static int esp_pci_scsi_init(PCIDevice *dev) { PCIESPState *pci = PCI_ESP(dev); DeviceState *d = DEVICE(dev); ESPState *s = &pci->esp; uint8_t *pci_conf; Error *[[idst]] = NULL; pci_conf = dev->config; pci_conf[PCI_INTERRUPT_PIN] = 0x01; s->dma_memory_read = esp_pci_dma_memory_read; s->dma_memory_write = esp_pci_dma_memory_write; s->dma_opaque = pci; s->chip_id = TCHI_AM53C974; memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci, "esp-io", 0x80); pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io); s->irq = pci_allocate_irq(dev); scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, &[[idst]]); if ([[idst]] != NULL) { error_free([[idst]]); return -1; } } return 0; }
--------------------------------------------- Result 1120 ---------------------------------------------
[[0 (1%)]] --> [[0 (59%)]] --> Socre: 0.5931697487831116

[[[[Adv]]]]: static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *[[fs]]) { return telldir([[fs]]->dir); }

[[[[Adv]]]]: static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *[[фses]]) { return telldir([[фses]]->dir); }
--------------------------------------------- Result 1121 ---------------------------------------------
[[0 (69%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref) { AResampleContext *aresample = inlink->dst->priv; const int n_in = insamplesref->audio->nb_samples; int n_out = FFMAX(n_in * aresample->ratio * 2, 1); AVFilterLink *const outlink = inlink->dst->outputs[0]; AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out); int ret; if(!outsamplesref) return AVERROR(ENOMEM); avfilter_copy_buffer_ref_props(outsamplesref, insamplesref); outsamplesref->format = outlink->format; outsamplesref->audio->channel_layout = outlink->channel_layout; outsamplesref->audio->sample_rate = outlink->sample_rate; if(insamplesref->pts != AV_NOPTS_VALUE) { int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den); int64_t outpts= swr_next_pts(aresample->swr, inpts); aresample->next_pts = outsamplesref->pts = (outpts + inlink->sample_rate/2) / inlink->sample_rate; } else { outsamplesref->pts = AV_NOPTS_VALUE; } n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out, (void *)insamplesref->extended_data, n_in); if (n_out <= 0) { avfilter_unref_buffer(outsamplesref); avfilter_unref_buffer(insamplesref); return 0; } outsamplesref->audio->nb_samples = n_out; ret = ff_filter_samples(outlink, outsamplesref); aresample->req_fullfilled= 1; avfilter_unref_buffer(insamplesref); return ret; }
--------------------------------------------- Result 1122 ---------------------------------------------
[[0 (63%)]] --> [[0 (46%)]] --> Socre: 0.544574499130249

[[[[Adv]]]]: static int usb_host_open(USBHostDevice *dev, int bus_num, int [[addr]], const char *port, const char *prod_name, int speed) { int [[fd]] = -1, ret; trace_usb_host_open_started(bus_num, [[addr]]); if (dev->fd != -1) { goto fail; } [[fd]] = usb_host_open_device(bus_num, [[addr]]); if ([[fd]] < 0) { goto fail; } DPRINTF("husb: opened %s\n", buf); dev->bus_num = bus_num; dev->addr = [[addr]]; strcpy(dev->port, port); dev->fd = [[fd]]; dev->descr_len = read([[fd]], dev->descr, sizeof(dev->descr)); if (dev->descr_len <= 0) { perror("husb: reading device data failed"); goto fail; } #ifdef DEBUG { int [[x]]; printf("=== begin dumping device descriptor data ===\n"); for ([[x]] = 0; [[x]] < dev->descr_len; [[x]]++) { printf("%02x ", dev->descr[[[x]]]); } printf("\n=== end dumping device descriptor data ===\n"); } #endif if (!usb_host_claim_interfaces(dev, 0)) { goto fail; } usb_ep_init(&dev->dev); usb_linux_update_endp_table(dev); if (speed == -1) { struct usbdevfs_connectinfo ci; ret = ioctl([[fd]], USBDEVFS_CONNECTINFO, &ci); if (ret < 0) { perror("usb_host_device_open: USBDEVFS_CONNECTINFO"); goto fail; } if (ci.slow) { speed = USB_SPEED_LOW; } else { speed = USB_SPEED_HIGH; } } dev->dev.speed = speed; dev->dev.speedmask = (1 << speed); if (dev->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat(dev)) { dev->dev.speedmask |= USB_SPEED_MASK_FULL; } trace_usb_host_open_success(bus_num, [[addr]]); if (!prod_name || prod_name[0] == '\0') { snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc), "host:%d.%d", bus_num, [[addr]]); } else { pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc), prod_name); } ret = usb_device_attach(&dev->dev); if (ret) { goto fail; } qemu_set_fd_handler(dev->fd, NULL, async_complete, dev); return 0; fail: trace_usb_host_open_failure(bus_num, [[addr]]); if (dev->fd != -1) { close(dev->fd); dev->fd = -1; } return -1; }

[[[[Adv]]]]: static int usb_host_open(USBHostDevice *dev, int bus_num, int [[fxrp]], const char *port, const char *prod_name, int speed) { int [[notesr]] = -1, ret; trace_usb_host_open_started(bus_num, [[fxrp]]); if (dev->fd != -1) { goto fail; } [[notesr]] = usb_host_open_device(bus_num, [[fxrp]]); if ([[notesr]] < 0) { goto fail; } DPRINTF("husb: opened %s\n", buf); dev->bus_num = bus_num; dev->addr = [[fxrp]]; strcpy(dev->port, port); dev->fd = [[notesr]]; dev->descr_len = read([[notesr]], dev->descr, sizeof(dev->descr)); if (dev->descr_len <= 0) { perror("husb: reading device data failed"); goto fail; } #ifdef DEBUG { int [[park]]; printf("=== begin dumping device descriptor data ===\n"); for ([[park]] = 0; [[park]] < dev->descr_len; [[park]]++) { printf("%02x ", dev->descr[[[park]]]); } printf("\n=== end dumping device descriptor data ===\n"); } #endif if (!usb_host_claim_interfaces(dev, 0)) { goto fail; } usb_ep_init(&dev->dev); usb_linux_update_endp_table(dev); if (speed == -1) { struct usbdevfs_connectinfo ci; ret = ioctl([[notesr]], USBDEVFS_CONNECTINFO, &ci); if (ret < 0) { perror("usb_host_device_open: USBDEVFS_CONNECTINFO"); goto fail; } if (ci.slow) { speed = USB_SPEED_LOW; } else { speed = USB_SPEED_HIGH; } } dev->dev.speed = speed; dev->dev.speedmask = (1 << speed); if (dev->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat(dev)) { dev->dev.speedmask |= USB_SPEED_MASK_FULL; } trace_usb_host_open_success(bus_num, [[fxrp]]); if (!prod_name || prod_name[0] == '\0') { snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc), "host:%d.%d", bus_num, [[fxrp]]); } else { pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc), prod_name); } ret = usb_device_attach(&dev->dev); if (ret) { goto fail; } qemu_set_fd_handler(dev->fd, NULL, async_complete, dev); return 0; fail: trace_usb_host_open_failure(bus_num, [[fxrp]]); if (dev->fd != -1) { close(dev->fd); dev->fd = -1; } return -1; }
--------------------------------------------- Result 1123 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 594 / 122 / 407 / 1123:  42%|████▏     | 1123/2690 [2:53:04<4:01:30,  9.25s/it][Succeeded / Failed / Skipped / Total] 594 / 122 / 407 / 1123:  42%|████▏     | 1124/2690 [2:53:05<4:01:08,  9.24s/it][Succeeded / Failed / Skipped / Total] 594 / 122 / 408 / 1124:  42%|████▏     | 1124/2690 [2:53:05<4:01:08,  9.24s/it][Succeeded / Failed / Skipped / Total] 594 / 122 / 408 / 1124:  42%|████▏     | 1125/2690 [2:53:30<4:01:21,  9.25s/it][Succeeded / Failed / Skipped / Total] 594 / 123 / 408 / 1125:  42%|████▏     | 1125/2690 [2:53:30<4:01:21,  9.25s/it][Succeeded / Failed / Skipped / Total] 594 / 123 / 408 / 1125:  42%|████▏     | 1126/2690 [2:54:11<4:01:57,  9.28s/it][Succeeded / Failed / Skipped / Total] 594 / 124 / 408 / 1126:  42%|████▏     | 1126/2690 [2:54:11<4:01:57,  9.28s/it][Succeeded / Failed / Skipped / Total] 594 / 124 / 408 / 1126:  42%|████▏     | 1127/2690 [2:54:29<4:01:59,  9.29s/it][Succeeded / Failed / Skipped / Total] 595 / 124 / 408 / 1127:  42%|████▏     | 1127/2690 [2:54:29<4:01:59,  9.29s/it][Succeeded / Failed / Skipped / Total] 595 / 124 / 408 / 1127:  42%|████▏     | 1128/2690 [2:54:34<4:01:44,  9.29s/it][[0 (75%)]] --> [[0 (37%)]] --> Socre: 0.6258873045444489

[[[[Adv]]]]: int64_t av_get_int(void *[[obj]], const char *name, const AVOption **o_out) { int64_t intnum=1; double num=1; int den=1; av_get_number([[obj]], name, o_out, &num, &den, &intnum); return num*intnum/den; }

[[[[Adv]]]]: int64_t av_get_int(void *[[obejs]], const char *name, const AVOption **o_out) { int64_t intnum=1; double num=1; int den=1; av_get_number([[obejs]], name, o_out, &num, &den, &intnum); return num*intnum/den; }
--------------------------------------------- Result 1124 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void commit_active_start(BlockDriverState *bs, BlockDriverState *base, int64_t speed, BlockdevOnError on_error, BlockDriverCompletionFunc *cb, void *opaque, Error **errp) { int64_t length, base_length; int orig_base_flags; orig_base_flags = bdrv_get_flags(base); if (bdrv_reopen(base, bs->open_flags, errp)) { return; } length = bdrv_getlength(bs); if (length < 0) { error_setg(errp, "Unable to determine length of %s", bs->filename); goto error_restore_flags; } base_length = bdrv_getlength(base); if (base_length < 0) { error_setg(errp, "Unable to determine length of %s", base->filename); goto error_restore_flags; } if (length > base_length) { if (bdrv_truncate(base, length) < 0) { error_setg(errp, "Top image %s is larger than base image %s, and " "resize of base image failed", bs->filename, base->filename); goto error_restore_flags; } } bdrv_ref(base); mirror_start_job(bs, base, speed, 0, 0, on_error, on_error, cb, opaque, errp, &commit_active_job_driver, "False" != "False", base); if (error_is_set(errp)) { goto error_restore_flags; } return; error_restore_flags: bdrv_reopen(base, orig_base_flags, NULL); return; }
--------------------------------------------- Result 1125 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void copy_frame(Jpeg2000EncoderContext *[[s]]) { int tileno, compno, i, y, x; uint8_t *[[line]]; for (tileno = 0; tileno < [[s]]->numXtiles * [[s]]->numYtiles; tileno++){ Jpeg2000Tile *[[tile]] = [[s]]->tile + tileno; if ([[s]]->planar){ for (compno = 0; compno < [[s]]->ncomponents; compno++){ Jpeg2000Component *comp = [[tile]]->comp + compno; int *[[dst]] = comp->data; [[line]] = [[s]]->picture.data[compno] + comp->coord[1][0] * [[s]]->picture.linesize[compno] + comp->coord[0][0]; for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){ uint8_t *ptr = [[line]]; for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++) *[[dst]]++ = *ptr++ - (1 << 7); [[line]] += [[s]]->picture.linesize[compno]; } } } else{ [[line]] = [[s]]->picture.data[0] + [[tile]]->comp[0].coord[1][0] * [[s]]->picture.linesize[0] + [[tile]]->comp[0].coord[0][0] * [[s]]->ncomponents; i = 0; for (y = [[tile]]->comp[0].coord[1][0]; y < [[tile]]->comp[0].coord[1][1]; y++){ uint8_t *ptr = [[line]]; for (x = [[tile]]->comp[0].coord[0][0]; x < [[tile]]->comp[0].coord[0][1]; x++, i++){ for (compno = 0; compno < [[s]]->ncomponents; compno++){ [[tile]]->comp[compno].data[i] = *ptr++ - (1 << 7); } } [[line]] += [[s]]->picture.linesize[0]; } } } }

[[[[Adv]]]]: static void copy_frame(Jpeg2000EncoderContext *[[с]]) { int tileno, compno, i, y, x; uint8_t *[[s]]; for (tileno = 0; tileno < [[с]]->numXtiles * [[с]]->numYtiles; tileno++){ Jpeg2000Tile *[[display]] = [[с]]->tile + tileno; if ([[с]]->planar){ for (compno = 0; compno < [[с]]->ncomponents; compno++){ Jpeg2000Component *comp = [[display]]->comp + compno; int *[[gpts]] = comp->data; [[s]] = [[с]]->picture.data[compno] + comp->coord[1][0] * [[с]]->picture.linesize[compno] + comp->coord[0][0]; for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){ uint8_t *ptr = [[s]]; for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++) *[[gpts]]++ = *ptr++ - (1 << 7); [[s]] += [[с]]->picture.linesize[compno]; } } } else{ [[s]] = [[с]]->picture.data[0] + [[display]]->comp[0].coord[1][0] * [[с]]->picture.linesize[0] + [[display]]->comp[0].coord[0][0] * [[с]]->ncomponents; i = 0; for (y = [[display]]->comp[0].coord[1][0]; y < [[display]]->comp[0].coord[1][1]; y++){ uint8_t *ptr = [[s]]; for (x = [[display]]->comp[0].coord[0][0]; x < [[display]]->comp[0].coord[0][1]; x++, i++){ for (compno = 0; compno < [[с]]->ncomponents; compno++){ [[display]]->comp[compno].data[i] = *ptr++ - (1 << 7); } } [[s]] += [[с]]->picture.linesize[0]; } } } }
--------------------------------------------- Result 1126 ---------------------------------------------
[[0 (25%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int mov_read_ctts(MOVContext *[[c]], ByteIOContext *[[pb]], MOV_atom_t atom) { AVStream *[[st]] = [[c]]->fc->streams[[[c]]->fc->nb_streams-1]; MOVStreamContext *[[sc]] = [[st]]->priv_data; unsigned int [[i]], entries; get_byte([[pb]]); get_be24([[pb]]); entries = get_be32([[pb]]); if(entries >= UINT_MAX / sizeof(MOV_stts_t)) return -1; [[sc]]->ctts_count = entries; [[sc]]->ctts_data = av_malloc(entries * sizeof(MOV_stts_t)); if (![[sc]]->ctts_data) return -1; dprintf([[c]]->fc, "track[%i].ctts.entries = %i\n", [[c]]->fc->nb_streams-1, entries); for([[i]]=0; [[i]]<entries; [[i]]++) { int count =get_be32([[pb]]); int duration =get_be32([[pb]]); if (duration < 0) { av_log([[c]]->fc, AV_LOG_ERROR, "negative ctts, ignoring\n"); [[sc]]->ctts_count = 0; url_fskip([[pb]], 8 * (entries - [[i]] - 1)); break; } [[sc]]->ctts_data[[[i]]].count = count; [[sc]]->ctts_data[[[i]]].duration= duration; [[sc]]->time_rate= ff_gcd([[sc]]->time_rate, duration); } return 0; }

[[[[Adv]]]]: static int mov_read_ctts(MOVContext *[[roc]], ByteIOContext *[[epbe]], MOV_atom_t atom) { AVStream *[[dc]] = [[roc]]->fc->streams[[[roc]]->fc->nb_streams-1]; MOVStreamContext *[[carp]] = [[dc]]->priv_data; unsigned int [[f]], entries; get_byte([[epbe]]); get_be24([[epbe]]); entries = get_be32([[epbe]]); if(entries >= UINT_MAX / sizeof(MOV_stts_t)) return -1; [[carp]]->ctts_count = entries; [[carp]]->ctts_data = av_malloc(entries * sizeof(MOV_stts_t)); if (![[carp]]->ctts_data) return -1; dprintf([[roc]]->fc, "track[%i].ctts.entries = %i\n", [[roc]]->fc->nb_streams-1, entries); for([[f]]=0; [[f]]<entries; [[f]]++) { int count =get_be32([[epbe]]); int duration =get_be32([[epbe]]); if (duration < 0) { av_log([[roc]]->fc, AV_LOG_ERROR, "negative ctts, ignoring\n"); [[carp]]->ctts_count = 0; url_fskip([[epbe]], 8 * (entries - [[f]] - 1)); break; } [[carp]]->ctts_data[[[f]]].count = count; [[carp]]->ctts_data[[[f]]].duration= duration; [[carp]]->time_rate= ff_gcd([[carp]]->time_rate, duration); } return 0; }
--------------------------------------------- Result 1127 ---------------------------------------------
[[0 (9%)]] --> [[0 (69%)]] --> Socre: 0.6887127161026001

[[[[Adv]]]]: void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr, bool is_write, bool [[is_exec]], int [[unused]], unsigned size) { AlphaCPU *cpu = ALPHA_CPU(cs); CPUAlphaState *[[env]] = &cpu->env; [[env]]->trap_arg0 = addr; [[env]]->trap_arg1 = is_write ? 1 : 0; dynamic_excp([[env]], 0, EXCP_MCHK, 0); }

[[[[Adv]]]]: void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr, bool is_write, bool [[readsloggingannend]], int [[amount]], unsigned size) { AlphaCPU *cpu = ALPHA_CPU(cs); CPUAlphaState *[[gent]] = &cpu->env; [[gent]]->trap_arg0 = addr; [[gent]]->trap_arg1 = is_write ? 1 : 0; dynamic_excp([[gent]], 0, EXCP_MCHK, 0); }
--------------------------------------------- Result 1128 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 596 / 124 / 408 / 1128:  42%|████▏     | 1128/2690 [2:54:34<4:01:44,  9.29s/it][Succeeded / Failed / Skipped / Total] 596 / 124 / 408 / 1128:  42%|████▏     | 1129/2690 [2:54:42<4:01:33,  9.28s/it][Succeeded / Failed / Skipped / Total] 597 / 124 / 408 / 1129:  42%|████▏     | 1129/2690 [2:54:42<4:01:33,  9.28s/it][Succeeded / Failed / Skipped / Total] 597 / 124 / 408 / 1129:  42%|████▏     | 1130/2690 [2:54:47<4:01:18,  9.28s/it][Succeeded / Failed / Skipped / Total] 598 / 124 / 408 / 1130:  42%|████▏     | 1130/2690 [2:54:47<4:01:18,  9.28s/it][Succeeded / Failed / Skipped / Total] 598 / 124 / 408 / 1130:  42%|████▏     | 1131/2690 [2:54:52<4:01:03,  9.28s/it][[0 (30%)]] --> [[0 (79%)]] --> Socre: 0.7853097915649414

[[[[Adv]]]]: static int virtio_serial_init_pci(PCIDevice *pci_dev) { VirtIOPCIProxy *[[proxy]] = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev); VirtIODevice *vdev; if ([[proxy]]->class_code != PCI_CLASS_COMMUNICATION_OTHER && [[proxy]]->class_code != PCI_CLASS_DISPLAY_OTHER && [[proxy]]->class_code != PCI_CLASS_OTHERS) [[proxy]]->class_code = PCI_CLASS_COMMUNICATION_OTHER; vdev = virtio_serial_init(&pci_dev->qdev, &[[proxy]]->serial); if (!vdev) { return -1; } vdev->nvectors = [[proxy]]->nvectors == DEV_NVECTORS_UNSPECIFIED ? [[proxy]]->serial.max_virtserial_ports + 1 : [[proxy]]->nvectors; virtio_init_pci([[proxy]], vdev, PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_DEVICE_ID_VIRTIO_CONSOLE, [[proxy]]->class_code, 0x00); [[proxy]]->nvectors = vdev->nvectors; return 0; }

[[[[Adv]]]]: static int virtio_serial_init_pci(PCIDevice *pci_dev) { VirtIOPCIProxy *[[mug]] = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev); VirtIODevice *vdev; if ([[mug]]->class_code != PCI_CLASS_COMMUNICATION_OTHER && [[mug]]->class_code != PCI_CLASS_DISPLAY_OTHER && [[mug]]->class_code != PCI_CLASS_OTHERS) [[mug]]->class_code = PCI_CLASS_COMMUNICATION_OTHER; vdev = virtio_serial_init(&pci_dev->qdev, &[[mug]]->serial); if (!vdev) { return -1; } vdev->nvectors = [[mug]]->nvectors == DEV_NVECTORS_UNSPECIFIED ? [[mug]]->serial.max_virtserial_ports + 1 : [[mug]]->nvectors; virtio_init_pci([[mug]], vdev, PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_DEVICE_ID_VIRTIO_CONSOLE, [[mug]]->class_code, 0x00); [[mug]]->nvectors = vdev->nvectors; return 0; }
--------------------------------------------- Result 1129 ---------------------------------------------
[[0 (88%)]] --> [[0 (46%)]] --> Socre: 0.5352630317211151

[[[[Adv]]]]: static int matroska_decode_buffer(uint8_t** buf, int* buf_size, MatroskaTrack *track) { MatroskaTrackEncoding *encodings = track->encodings.elem; uint8_t* [[data]] = *buf; int isize = *buf_size; uint8_t* [[pkt_data]] = NULL; int [[pkt_size]] = isize; int [[result]] = 0; int [[olen]]; switch (encodings[0].compression.algo) { case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: return encodings[0].compression.settings.size; case MATROSKA_TRACK_ENCODING_COMP_LZO: do { [[olen]] = [[pkt_size]] *= 3; [[pkt_data]] = av_realloc([[pkt_data]], [[pkt_size]]+AV_LZO_OUTPUT_PADDING); [[result]] = av_lzo1x_decode([[pkt_data]], &[[olen]], [[data]], &isize); } while ([[result]]==AV_LZO_OUTPUT_FULL && [[pkt_size]]<10000000); if ([[result]]) goto failed; [[pkt_size]] -= [[olen]]; break; #if CONFIG_ZLIB case MATROSKA_TRACK_ENCODING_COMP_ZLIB: { z_stream zstream = {0}; if (inflateInit(&zstream) != Z_OK) zstream.next_in = [[data]]; zstream.avail_in = isize; do { [[pkt_size]] *= 3; [[pkt_data]] = av_realloc([[pkt_data]], [[pkt_size]]); zstream.avail_out = [[pkt_size]] - zstream.total_out; zstream.next_out = [[pkt_data]] + zstream.total_out; [[result]] = inflate(&zstream, Z_NO_FLUSH); } while ([[result]]==Z_OK && [[pkt_size]]<10000000); [[pkt_size]] = zstream.total_out; inflateEnd(&zstream); if ([[result]] != Z_STREAM_END) goto failed; break; } #endif #if CONFIG_BZLIB case MATROSKA_TRACK_ENCODING_COMP_BZLIB: { bz_stream bzstream = {0}; if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK) bzstream.next_in = [[data]]; bzstream.avail_in = isize; do { [[pkt_size]] *= 3; [[pkt_data]] = av_realloc([[pkt_data]], [[pkt_size]]); bzstream.avail_out = [[pkt_size]] - bzstream.total_out_lo32; bzstream.next_out = [[pkt_data]] + bzstream.total_out_lo32; [[result]] = BZ2_bzDecompress(&bzstream); } while ([[result]]==BZ_OK && [[pkt_size]]<10000000); [[pkt_size]] = bzstream.total_out_lo32; BZ2_bzDecompressEnd(&bzstream); if ([[result]] != BZ_STREAM_END) goto failed; break; } #endif default: } *buf = [[pkt_data]]; *buf_size = [[pkt_size]]; return 0; failed: av_free([[pkt_data]]); }

[[[[Adv]]]]: static int matroska_decode_buffer(uint8_t** buf, int* buf_size, MatroskaTrack *track) { MatroskaTrackEncoding *encodings = track->encodings.elem; uint8_t* [[bus]] = *buf; int isize = *buf_size; uint8_t* [[vκrafmaterial]] = NULL; int [[bakingcellweight]] = isize; int [[fraction]] = 0; int [[oled]]; switch (encodings[0].compression.algo) { case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: return encodings[0].compression.settings.size; case MATROSKA_TRACK_ENCODING_COMP_LZO: do { [[oled]] = [[bakingcellweight]] *= 3; [[vκrafmaterial]] = av_realloc([[vκrafmaterial]], [[bakingcellweight]]+AV_LZO_OUTPUT_PADDING); [[fraction]] = av_lzo1x_decode([[vκrafmaterial]], &[[oled]], [[bus]], &isize); } while ([[fraction]]==AV_LZO_OUTPUT_FULL && [[bakingcellweight]]<10000000); if ([[fraction]]) goto failed; [[bakingcellweight]] -= [[oled]]; break; #if CONFIG_ZLIB case MATROSKA_TRACK_ENCODING_COMP_ZLIB: { z_stream zstream = {0}; if (inflateInit(&zstream) != Z_OK) zstream.next_in = [[bus]]; zstream.avail_in = isize; do { [[bakingcellweight]] *= 3; [[vκrafmaterial]] = av_realloc([[vκrafmaterial]], [[bakingcellweight]]); zstream.avail_out = [[bakingcellweight]] - zstream.total_out; zstream.next_out = [[vκrafmaterial]] + zstream.total_out; [[fraction]] = inflate(&zstream, Z_NO_FLUSH); } while ([[fraction]]==Z_OK && [[bakingcellweight]]<10000000); [[bakingcellweight]] = zstream.total_out; inflateEnd(&zstream); if ([[fraction]] != Z_STREAM_END) goto failed; break; } #endif #if CONFIG_BZLIB case MATROSKA_TRACK_ENCODING_COMP_BZLIB: { bz_stream bzstream = {0}; if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK) bzstream.next_in = [[bus]]; bzstream.avail_in = isize; do { [[bakingcellweight]] *= 3; [[vκrafmaterial]] = av_realloc([[vκrafmaterial]], [[bakingcellweight]]); bzstream.avail_out = [[bakingcellweight]] - bzstream.total_out_lo32; bzstream.next_out = [[vκrafmaterial]] + bzstream.total_out_lo32; [[fraction]] = BZ2_bzDecompress(&bzstream); } while ([[fraction]]==BZ_OK && [[bakingcellweight]]<10000000); [[bakingcellweight]] = bzstream.total_out_lo32; BZ2_bzDecompressEnd(&bzstream); if ([[fraction]] != BZ_STREAM_END) goto failed; break; } #endif default: } *buf = [[vκrafmaterial]]; *buf_size = [[bakingcellweight]]; return 0; failed: av_free([[vκrafmaterial]]); }
--------------------------------------------- Result 1130 ---------------------------------------------
[[0 (33%)]] --> [[0 (98%)]] --> Socre: 0.9809094071388245

[[[[Adv]]]]: void alpha_pci_vga_setup(PCIBus *[[pci_bus]]) { switch (vga_interface_type) { #ifdef CONFIG_SPICE case VGA_QXL: pci_create_simple([[pci_bus]], -1, "qxl-vga"); return; #endif case VGA_CIRRUS: pci_cirrus_vga_init([[pci_bus]]); return; case VGA_VMWARE: if (pci_vmsvga_init([[pci_bus]])) { return; } break; } if (vga_interface_type != VGA_NONE) { pci_vga_init([[pci_bus]]); } }

[[[[Adv]]]]: void alpha_pci_vga_setup(PCIBus *[[windowsиmodiv]]) { switch (vga_interface_type) { #ifdef CONFIG_SPICE case VGA_QXL: pci_create_simple([[windowsиmodiv]], -1, "qxl-vga"); return; #endif case VGA_CIRRUS: pci_cirrus_vga_init([[windowsиmodiv]]); return; case VGA_VMWARE: if (pci_vmsvga_init([[windowsиmodiv]])) { return; } break; } if (vga_interface_type != VGA_NONE) { pci_vga_init([[windowsиmodiv]]); } }
--------------------------------------------- Result 1131 ---------------------------------------------
[[0 (38%)]] --> [[0 (52%)]] --> Socre: 0.5204941034317017

[[[[Adv]]]]: static void QEMU_NORETURN help(void) { const char *[[help_msg]] = QEMU_IMG_VERSION "usage: qemu-img [standard options] command [command options]\n" "QEMU disk image utility\n" "\n" " '-h', '--help' display this help and exit\n" " '-V', '--version' output version information and exit\n" " '-T', '--trace' [[enable=]<pattern>][,events=<file>][,file=<file>]\n" " specify tracing options\n" "\n" "Command syntax:\n" #define DEF(option, callback, arg_string) \ " " arg_string "\n" #include "qemu-img-cmds.h" #undef DEF #undef GEN_DOCS "\n" "Command parameters:\n" " 'filename' is a disk image filename\n" " 'objectdef' is a QEMU user creatable object definition. See the qemu(1)\n" " manual page for a description of the object properties. The most common\n" " object type is a 'secret', which is used to supply passwords and/or\n" " encryption keys.\n" " 'fmt' is the disk image format. It is guessed automatically in most cases\n" " 'cache' is the cache mode used to write the output disk image, the valid\n" " options are: 'none', 'writeback' (default, except for convert), 'writethrough',\n" " 'directsync' and 'unsafe' (default for convert)\n" " 'src_cache' is the cache mode used to read input disk images, the valid\n" " options are the same as for the 'cache' option\n" " 'size' is the disk image size in bytes. Optional suffixes\n" " 'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\n" " 'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P) are\n" " supported. 'b' is ignored.\n" " 'output_filename' is the destination disk image filename\n" " 'output_fmt' is the destination format\n" " 'options' is a comma separated list of format specific options in a\n" " name=value format. Use -o ? for an overview of the options supported by the\n" " used format\n" " 'snapshot_param' is param used for internal snapshot, format\n" " is 'snapshot.id=[ID],snapshot.name=[NAME]', or\n" " '[ID_OR_NAME]'\n" " 'snapshot_id_or_name' is deprecated, use 'snapshot_param'\n" " instead\n" " '-c' indicates that target image must be compressed (qcow format only)\n" " '-u' enables unsafe rebasing. It is assumed that old and new backing file\n" " match exactly. The image doesn't need a working backing file before\n" " rebasing in this case (useful for renaming the backing file)\n" " '-h' with or without a command shows this help and lists the supported formats\n" " '-p' show progress of command (only certain commands)\n" " '-q' use Quiet mode - do not print any output (except errors)\n" " '-S' indicates the consecutive number of bytes (defaults to 4k) that must\n" " contain only zeros for qemu-img to create a sparse image during\n" " conversion. If the number of bytes is 0, the source will not be scanned for\n" " unallocated or zero sectors, and the destination image will always be\n" " fully allocated\n" " '--output' takes the format in which the output must be done (human or json)\n" " '-n' skips the target volume creation (useful if the volume is created\n" " prior to running qemu-img)\n" "\n" "Parameters to check subcommand:\n" " '-r' tries to repair any inconsistencies that are found during the check.\n" " '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\n" " kinds of errors, with a higher risk of choosing the wrong fix or\n" " hiding corruption that has already occurred.\n" "\n" "Parameters to convert subcommand:\n" " '-m' specifies how many coroutines work in parallel during the convert\n" " process (defaults to 8)\n" " '-W' allow to write to the target out of order rather than sequential\n" "\n" "Parameters to snapshot subcommand:\n" " 'snapshot' is the name of the snapshot to create, apply or delete\n" " '-a' applies a snapshot (revert disk to saved state)\n" " '-c' creates a snapshot\n" " '-d' deletes a snapshot\n" " '-l' lists all snapshots in the given image\n" "\n" "Parameters to compare subcommand:\n" " '-f' first image format\n" " '-F' second image format\n" " '-s' run in Strict mode - fail on different image size or sector allocation\n" "\n" "Parameters to dd subcommand:\n" " 'bs=BYTES' read and write up to BYTES bytes at a time " "(default: 512)\n" " 'count=N' copy only N input blocks\n" " 'if=FILE' read from FILE\n" " 'of=FILE' write to FILE\n" " 'skip=N' skip N bs-sized blocks at the start of input\n"; printf("%s\nSupported formats:", [[help_msg]]); bdrv_iterate_format(format_print, NULL); printf("\n"); exit(EXIT_SUCCESS); }

[[[[Adv]]]]: static void QEMU_NORETURN help(void) { const char *[[seeabletcase]] = QEMU_IMG_VERSION "usage: qemu-img [standard options] command [command options]\n" "QEMU disk image utility\n" "\n" " '-h', '--help' display this help and exit\n" " '-V', '--version' output version information and exit\n" " '-T', '--trace' [[enable=]<pattern>][,events=<file>][,file=<file>]\n" " specify tracing options\n" "\n" "Command syntax:\n" #define DEF(option, callback, arg_string) \ " " arg_string "\n" #include "qemu-img-cmds.h" #undef DEF #undef GEN_DOCS "\n" "Command parameters:\n" " 'filename' is a disk image filename\n" " 'objectdef' is a QEMU user creatable object definition. See the qemu(1)\n" " manual page for a description of the object properties. The most common\n" " object type is a 'secret', which is used to supply passwords and/or\n" " encryption keys.\n" " 'fmt' is the disk image format. It is guessed automatically in most cases\n" " 'cache' is the cache mode used to write the output disk image, the valid\n" " options are: 'none', 'writeback' (default, except for convert), 'writethrough',\n" " 'directsync' and 'unsafe' (default for convert)\n" " 'src_cache' is the cache mode used to read input disk images, the valid\n" " options are the same as for the 'cache' option\n" " 'size' is the disk image size in bytes. Optional suffixes\n" " 'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\n" " 'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P) are\n" " supported. 'b' is ignored.\n" " 'output_filename' is the destination disk image filename\n" " 'output_fmt' is the destination format\n" " 'options' is a comma separated list of format specific options in a\n" " name=value format. Use -o ? for an overview of the options supported by the\n" " used format\n" " 'snapshot_param' is param used for internal snapshot, format\n" " is 'snapshot.id=[ID],snapshot.name=[NAME]', or\n" " '[ID_OR_NAME]'\n" " 'snapshot_id_or_name' is deprecated, use 'snapshot_param'\n" " instead\n" " '-c' indicates that target image must be compressed (qcow format only)\n" " '-u' enables unsafe rebasing. It is assumed that old and new backing file\n" " match exactly. The image doesn't need a working backing file before\n" " rebasing in this case (useful for renaming the backing file)\n" " '-h' with or without a command shows this help and lists the supported formats\n" " '-p' show progress of command (only certain commands)\n" " '-q' use Quiet mode - do not print any output (except errors)\n" " '-S' indicates the consecutive number of bytes (defaults to 4k) that must\n" " contain only zeros for qemu-img to create a sparse image during\n" " conversion. If the number of bytes is 0, the source will not be scanned for\n" " unallocated or zero sectors, and the destination image will always be\n" " fully allocated\n" " '--output' takes the format in which the output must be done (human or json)\n" " '-n' skips the target volume creation (useful if the volume is created\n" " prior to running qemu-img)\n" "\n" "Parameters to check subcommand:\n" " '-r' tries to repair any inconsistencies that are found during the check.\n" " '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\n" " kinds of errors, with a higher risk of choosing the wrong fix or\n" " hiding corruption that has already occurred.\n" "\n" "Parameters to convert subcommand:\n" " '-m' specifies how many coroutines work in parallel during the convert\n" " process (defaults to 8)\n" " '-W' allow to write to the target out of order rather than sequential\n" "\n" "Parameters to snapshot subcommand:\n" " 'snapshot' is the name of the snapshot to create, apply or delete\n" " '-a' applies a snapshot (revert disk to saved state)\n" " '-c' creates a snapshot\n" " '-d' deletes a snapshot\n" " '-l' lists all snapshots in the given image\n" "\n" "Parameters to compare subcommand:\n" " '-f' first image format\n" " '-F' second image format\n" " '-s' run in Strict mode - fail on different image size or sector allocation\n" "\n" "Parameters to dd subcommand:\n" " 'bs=BYTES' read and write up to BYTES bytes at a time " "(default: 512)\n" " 'count=N' copy only N input blocks\n" " 'if=FILE' read from FILE\n" " 'of=FILE' write to FILE\n" " 'skip=N' skip N bs-sized blocks at the start of input\n"; printf("%s\nSupported formats:", [[seeabletcase]]); bdrv_iterate_format(format_print, NULL); printf("\n"); exit(EXIT_SUCCESS); }[Succeeded / Failed / Skipped / Total] 599 / 124 / 408 / 1131:  42%|████▏     | 1131/2690 [2:54:52<4:01:03,  9.28s/it][Succeeded / Failed / Skipped / Total] 599 / 124 / 408 / 1131:  42%|████▏     | 1132/2690 [2:54:54<4:00:44,  9.27s/it][Succeeded / Failed / Skipped / Total] 600 / 124 / 408 / 1132:  42%|████▏     | 1132/2690 [2:54:54<4:00:44,  9.27s/it][Succeeded / Failed / Skipped / Total] 600 / 124 / 408 / 1132:  42%|████▏     | 1133/2690 [2:55:32<4:01:14,  9.30s/it][Succeeded / Failed / Skipped / Total] 601 / 124 / 408 / 1133:  42%|████▏     | 1133/2690 [2:55:32<4:01:14,  9.30s/it][Succeeded / Failed / Skipped / Total] 601 / 124 / 408 / 1133:  42%|████▏     | 1134/2690 [2:55:35<4:00:56,  9.29s/it][Succeeded / Failed / Skipped / Total] 602 / 124 / 408 / 1134:  42%|████▏     | 1134/2690 [2:55:35<4:00:56,  9.29s/it][Succeeded / Failed / Skipped / Total] 602 / 124 / 408 / 1134:  42%|████▏     | 1135/2690 [2:55:36<4:00:34,  9.28s/it][Succeeded / Failed / Skipped / Total] 602 / 124 / 409 / 1135:  42%|████▏     | 1135/2690 [2:55:36<4:00:34,  9.28s/it][Succeeded / Failed / Skipped / Total] 602 / 124 / 409 / 1135:  42%|████▏     | 1136/2690 [2:55:43<4:00:23,  9.28s/it][Succeeded / Failed / Skipped / Total] 603 / 124 / 409 / 1136:  42%|████▏     | 1136/2690 [2:55:43<4:00:23,  9.28s/it][Succeeded / Failed / Skipped / Total] 603 / 124 / 409 / 1136:  42%|████▏     | 1137/2690 [2:55:55<4:00:17,  9.28s/it][Succeeded / Failed / Skipped / Total] 603 / 125 / 409 / 1137:  42%|████▏     | 1137/2690 [2:55:55<4:00:17,  9.28s/it][Succeeded / Failed / Skipped / Total] 603 / 125 / 409 / 1137:  42%|████▏     | 1138/2690 [2:56:13<4:00:20,  9.29s/it]
--------------------------------------------- Result 1132 ---------------------------------------------
[[0 (4%)]] --> [[0 (92%)]] --> Socre: 0.921865701675415

[[[[Adv]]]]: static CharDriverState *qmp_chardev_open_serial(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { ChardevHostdev *serial = backend->serial; int [[fd]]; [[fd]] = qmp_chardev_open_file_source(serial->device, O_RDWR, errp); if ([[fd]] < 0) { return NULL; } qemu_set_nonblock([[fd]]); return qemu_chr_open_tty_fd([[fd]]); }

[[[[Adv]]]]: static CharDriverState *qmp_chardev_open_serial(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { ChardevHostdev *serial = backend->serial; int [[fiδ]]; [[fiδ]] = qmp_chardev_open_file_source(serial->device, O_RDWR, errp); if ([[fiδ]] < 0) { return NULL; } qemu_set_nonblock([[fiδ]]); return qemu_chr_open_tty_fd([[fiδ]]); }
--------------------------------------------- Result 1133 ---------------------------------------------
[[0 (6%)]] --> [[0 (63%)]] --> Socre: 0.6333250403404236

[[[[Adv]]]]: static void coroutine_fn bdrv_create_co_entry(void *[[opaque]]) { Error *local_err = NULL; int [[ret]]; CreateCo *cco = [[opaque]]; assert(cco->drv); [[ret]] = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err); if (local_err) { error_propagate(&cco->err, local_err); } cco->ret = [[ret]]; }

[[[[Adv]]]]: static void coroutine_fn bdrv_create_co_entry(void *[[olympia]]) { Error *local_err = NULL; int [[sakem]]; CreateCo *cco = [[olympia]]; assert(cco->drv); [[sakem]] = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err); if (local_err) { error_propagate(&cco->err, local_err); } cco->ret = [[sakem]]; }
--------------------------------------------- Result 1134 ---------------------------------------------
[[0 (7%)]] --> [[0 (73%)]] --> Socre: 0.7330228686332703

[[[[Adv]]]]: void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong [[arg1]]) { target_ulong [[old]], val, mask; mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask; if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) { mask |= 1 << CP0EnHi_EHINV; } #if defined(TARGET_MIPS64) if (env->insn_flags & ISA_MIPS32R6) { int entryhi_r = extract64([[arg1]], 62, 2); int config0_at = extract32(env->CP0_Config0, 13, 2); bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0; if ((entryhi_r == 2) || (entryhi_r == 1 && (no_supervisor || config0_at == 1))) { mask &= ~(0x3ull << 62); } } mask &= env->SEGMask; #endif [[old]] = env->CP0_EntryHi; val = ([[arg1]] & mask) | ([[old]] & ~mask); env->CP0_EntryHi = val; if (env->CP0_Config3 & (1 << CP0C3_MT)) { sync_c0_entryhi(env, env->current_tc); } if (([[old]] & env->CP0_EntryHi_ASID_mask) != (val & env->CP0_EntryHi_ASID_mask)) { cpu_mips_tlb_flush(env); } }

[[[[Adv]]]]: void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong [[barγwork]]) { target_ulong [[iron]], val, mask; mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask; if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) { mask |= 1 << CP0EnHi_EHINV; } #if defined(TARGET_MIPS64) if (env->insn_flags & ISA_MIPS32R6) { int entryhi_r = extract64([[barγwork]], 62, 2); int config0_at = extract32(env->CP0_Config0, 13, 2); bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0; if ((entryhi_r == 2) || (entryhi_r == 1 && (no_supervisor || config0_at == 1))) { mask &= ~(0x3ull << 62); } } mask &= env->SEGMask; #endif [[iron]] = env->CP0_EntryHi; val = ([[barγwork]] & mask) | ([[iron]] & ~mask); env->CP0_EntryHi = val; if (env->CP0_Config3 & (1 << CP0C3_MT)) { sync_c0_entryhi(env, env->current_tc); } if (([[iron]] & env->CP0_EntryHi_ASID_mask) != (val & env->CP0_EntryHi_ASID_mask)) { cpu_mips_tlb_flush(env); } }
--------------------------------------------- Result 1135 ---------------------------------------------
[[0 (5%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr) { ram_addr_t ram_addr; if (qemu_ram_addr_from_host(ptr, &ram_addr)) { fprintf(stderr, "Bad ram pointer %p\n", ptr); abort(); } return ram_addr; }
--------------------------------------------- Result 1136 ---------------------------------------------
[[0 (6%)]] --> [[0 (72%)]] --> Socre: 0.7175260186195374

[[[[Adv]]]]: struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta, qemu_irq irq, omap_clk fclk, omap_clk iclk, qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr) { target_phys_addr_t [[base]] = omap_l4_attach(ta, 0, 0); struct omap_uart_s *[[s]] = omap_uart_init([[base]], irq, fclk, iclk, txdma, rxdma, chr); int [[iomemtype]] = cpu_register_io_memory(0, omap_uart_readfn, omap_uart_writefn, [[s]]); [[s]]->ta = ta; [[s]]->base = [[base]]; cpu_register_physical_memory([[s]]->base + 0x20, 0x100, [[iomemtype]]); return [[s]]; }

[[[[Adv]]]]: struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta, qemu_irq irq, omap_clk fclk, omap_clk iclk, qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr) { target_phys_addr_t [[monument]] = omap_l4_attach(ta, 0, 0); struct omap_uart_s *[[was]] = omap_uart_init([[monument]], irq, fclk, iclk, txdma, rxdma, chr); int [[iomiтure]] = cpu_register_io_memory(0, omap_uart_readfn, omap_uart_writefn, [[was]]); [[was]]->ta = ta; [[was]]->base = [[monument]]; cpu_register_physical_memory([[was]]->base + 0x20, 0x100, [[iomiтure]]); return [[was]]; }
--------------------------------------------- Result 1137 ---------------------------------------------
[[0 (82%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static bool vmxnet3_verify_driver_magic(hwaddr [[dshmem]]) { return (VMXNET3_READ_DRV_SHARED32([[dshmem]], magic) == VMXNET3_REV1_MAGIC); }

[[[[Adv]]]]: static bool vmxnet3_verify_driver_magic(hwaddr [[dlmdemon]]) { return (VMXNET3_READ_DRV_SHARED32([[dlmdemon]], magic) == VMXNET3_REV1_MAGIC); }
--------------------------------------------- Result 1138 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 604 / 125 / 409 / 1138:  42%|████▏     | 1138/2690 [2:56:13<4:00:20,  9.29s/it]