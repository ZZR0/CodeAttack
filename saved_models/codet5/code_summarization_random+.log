textattack: Running 8 worker(s) on 8 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1635.21it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1839.20it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 2089.49it/s][Succeeded / Failed / Skipped / Total] 3 / 1 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 2210.44it/s][Succeeded / Failed / Skipped / Total] 3 / 2 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 2350.80it/s][Succeeded / Failed / Skipped / Total] 4 / 2 / 0 / 6:   1%|          | 6/1000 [00:00<00:00, 2428.43it/s]--------------------------------------------- Result 1 ---------------------------------------------
Wraps an ObservableSource . --> Anesthesiology a source of subsidiaries --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[anesthesiology]] ( ObservableSource < T > [[subsidiaries]] ) { ObjectHelper . requireNonNull ( [[subsidiaries]] , "source is null" ) ; if ( [[subsidiaries]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[subsidiaries]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[subsidiaries]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Perform a fast path ordered emit . --> MCSHANA descripción descripción --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U [[value]] , boolean delayError , Disposable disposable ) { final Observer < ? super V > [[observer]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[observer]] , [[value]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[value]] ) ; } } else { q . offer ( [[value]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[observer]] , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[mcshane]] ( U [[attaboy]] , boolean delayError , Disposable disposable ) { final Observer < ? super V > [[escondido]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[escondido]] , [[attaboy]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[attaboy]] ) ; } } else { q . offer ( [[attaboy]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[escondido]] , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 3 ---------------------------------------------
Creates a ReplayableObservable that can be used to replay a ConnectableObservable . --> Baryshnikov Observable Observable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > co , final Scheduler [[scheduler]] ) { final Observable < T > observable = co . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[baryshnikov]] ( final ConnectableObservable < T > co , final Scheduler [[bushy]] ) { final Observable < T > observable = co . observeOn ( [[bushy]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 4 ---------------------------------------------
Returns an observable that is sorted by the specified comparator . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[noronha]] ( Comparator < ? super T > [[thinks]] ) { ObjectHelper . requireNonNull ( [[thinks]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[thinks]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 5 ---------------------------------------------
Creates a new unicast processor . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[yat]] ( int [[franziska]] ) { return new UnicastProcessor < T > ( [[franziska]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 6 ---------------------------------------------
Reset the scheduler . --> Trackuit method for tracksuit --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[tracksuit]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 2 / 0 / 7:   1%|          | 7/1000 [00:00<00:00, 2472.22it/s][Succeeded / Failed / Skipped / Total] 5 / 3 / 0 / 8:   1%|          | 8/1000 [00:00<00:00, 2533.75it/s][Succeeded / Failed / Skipped / Total] 5 / 4 / 0 / 9:   1%|          | 9/1000 [00:00<00:00, 2606.60it/s][Succeeded / Failed / Skipped / Total] 6 / 4 / 0 / 10:   1%|          | 10/1000 [00:00<00:00, 2660.01it/s][Succeeded / Failed / Skipped / Total] 6 / 5 / 0 / 11:   1%|          | 11/1000 [00:00<00:00, 2724.38it/s][Succeeded / Failed / Skipped / Total] 6 / 6 / 0 / 12:   1%|          | 12/1000 [00:00<00:00, 2767.15it/s]Creates a Flowable that maps a single value to a single value . --> Accretion на на --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[accretion]] ( final T [[на]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[franziska]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[на]] , [[franziska]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 8 ---------------------------------------------
Creates a new unicast processor . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[repeater]] ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 9 ---------------------------------------------
Creates a Maybe from a Completable source . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[object]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 10 ---------------------------------------------
Retry a Maybe by a given number of times . --> Dravel a Maybe --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long times , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( times , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[drivel]] ( long times , Predicate < ? super Throwable > [[quadriplegic]] ) { return toFlowable ( ) . retry ( times , [[quadriplegic]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 11 ---------------------------------------------
Throws a NullPointerException if the object is null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[montparnasse]] > [[montparnasse]] requireNonNull ( [[montparnasse]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 12 ---------------------------------------------
Creates a Maybe from a SingleSource . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[leggings]] ( SingleSource < T > [[footballing]] ) { ObjectHelper . requireNonNull ( [[footballing]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[footballing]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 13 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 7 / 0 / 13:   1%|▏         | 13/1000 [00:00<00:00, 2670.88it/s][Succeeded / Failed / Skipped / Total] 7 / 7 / 0 / 14:   1%|▏         | 14/1000 [00:00<00:00, 2698.05it/s][Succeeded / Failed / Skipped / Total] 8 / 7 / 0 / 15:   2%|▏         | 15/1000 [00:00<00:00, 2721.81it/s][Succeeded / Failed / Skipped / Total] 8 / 7 / 0 / 15:   2%|▏         | 16/1000 [00:30<30:51,  1.88s/it]  [Succeeded / Failed / Skipped / Total] 8 / 8 / 0 / 16:   2%|▏         | 16/1000 [00:30<30:51,  1.88s/it][Succeeded / Failed / Skipped / Total] 8 / 8 / 0 / 16:   2%|▏         | 17/1000 [00:39<38:22,  2.34s/it][Succeeded / Failed / Skipped / Total] 8 / 9 / 0 / 17:   2%|▏         | 17/1000 [00:39<38:22,  2.34s/it][Succeeded / Failed / Skipped / Total] 8 / 9 / 0 / 17:   2%|▏         | 18/1000 [00:55<50:15,  3.07s/it][Succeeded / Failed / Skipped / Total] 8 / 10 / 0 / 18:   2%|▏         | 18/1000 [00:55<50:15,  3.07s/it][Succeeded / Failed / Skipped / Total] 8 / 10 / 0 / 18:   2%|▏         | 19/1000 [01:03<54:55,  3.36s/it][Succeeded / Failed / Skipped / Total] 8 / 11 / 0 / 19:   2%|▏         | 19/1000 [01:03<54:55,  3.36s/it][Succeeded / Failed / Skipped / Total] 8 / 11 / 0 / 19:   2%|▏         | 20/1000 [01:11<58:10,  3.56s/it][Succeeded / Failed / Skipped / Total] 8 / 12 / 0 / 20:   2%|▏         | 20/1000 [01:11<58:10,  3.56s/it][Succeeded / Failed / Skipped / Total] 8 / 12 / 0 / 20:   2%|▏         | 21/1000 [01:23<1:05:07,  3.99s/it]Try a scalar x map subscribe . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 14 ---------------------------------------------
Creates a callable that returns the given value . --> Liefert die buckwheat --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[comédie]] ( T [[buckwheat]] ) { return new JustValue < Object , T > ( [[buckwheat]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 15 ---------------------------------------------
Returns an identity function . --> Tomoya - > tomoya - > tomoya --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[tomoya]] > Function < [[tomoya]] , [[tomoya]] > [[mangy]] ( ) { return ( Function < [[tomoya]] , [[tomoya]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 16 ---------------------------------------------
Wait for the thread to get an error . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[vaja]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 17 ---------------------------------------------
Creates a new unicast subject . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[kazimierz]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a function that just returns the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[margarita]] , U > Function < [[margarita]] , U > [[bogeyman]] ( U [[tootie]] ) { return new JustValue < [[margarita]] , U > ( [[tootie]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 19 ---------------------------------------------
Creates a new unicast subject . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[haryana]] ( boolean [[inhale]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[inhale]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 20 ---------------------------------------------
Creates a new unicast subject with the given capacity hint . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[shrunken]] ( int [[alds]] ) { return new UnicastSubject < T > ( [[alds]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 8 / 13 / 0 / 21:   2%|▏         | 21/1000 [01:23<1:05:07,  3.99s/it][Succeeded / Failed / Skipped / Total] 8 / 13 / 0 / 21:   2%|▏         | 22/1000 [01:56<1:26:23,  5.30s/it][Succeeded / Failed / Skipped / Total] 8 / 14 / 0 / 22:   2%|▏         | 22/1000 [01:56<1:26:23,  5.30s/it][Succeeded / Failed / Skipped / Total] 8 / 14 / 0 / 22:   2%|▏         | 23/1000 [02:03<1:27:29,  5.37s/it][Succeeded / Failed / Skipped / Total] 8 / 15 / 0 / 23:   2%|▏         | 23/1000 [02:03<1:27:29,  5.37s/it][Succeeded / Failed / Skipped / Total] 8 / 15 / 0 / 23:   2%|▏         | 24/1000 [02:05<1:25:02,  5.23s/it][Succeeded / Failed / Skipped / Total] 9 / 15 / 0 / 24:   2%|▏         | 24/1000 [02:05<1:25:02,  5.23s/it][Succeeded / Failed / Skipped / Total] 9 / 15 / 0 / 24:   2%|▎         | 25/1000 [02:09<1:24:14,  5.18s/it][Succeeded / Failed / Skipped / Total] 10 / 15 / 0 / 25:   2%|▎         | 25/1000 [02:09<1:24:14,  5.18s/it][Succeeded / Failed / Skipped / Total] 10 / 15 / 0 / 25:   3%|▎         | 26/1000 [02:21<1:28:29,  5.45s/it][Succeeded / Failed / Skipped / Total] 10 / 16 / 0 / 26:   3%|▎         | 26/1000 [02:21<1:28:29,  5.45s/it][Succeeded / Failed / Skipped / Total] 10 / 16 / 0 / 26:   3%|▎         | 27/1000 [02:26<1:28:14,  5.44s/it][Succeeded / Failed / Skipped / Total] 11 / 16 / 0 / 27:   3%|▎         | 27/1000 [02:26<1:28:14,  5.44s/it][Succeeded / Failed / Skipped / Total] 11 / 16 / 0 / 27:   3%|▎         | 28/1000 [02:29<1:26:42,  5.35s/it][Succeeded / Failed / Skipped / Total] 12 / 16 / 0 / 28:   3%|▎         | 28/1000 [02:29<1:26:42,  5.35s/it][Succeeded / Failed / Skipped / Total] 12 / 16 / 0 / 28:   3%|▎         | 29/1000 [02:44<1:32:02,  5.69s/it]Creates a function that casts a value to a given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > [[target]] ) { return new CastToClass < [[T]] , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[brodeur]] , U > Function < [[brodeur]] , U > [[zaphod]] ( Class < U > [[marijuana]] ) { return new CastToClass < [[brodeur]] , U > ( [[marijuana]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 22 ---------------------------------------------
Returns the error or null if there is no error . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long timeout , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[compress]] ( long timeout , TimeUnit [[meenie]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[meenie]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , [[meenie]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 23 ---------------------------------------------
Creates a new unicast subject . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[swizzle]] ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 24 ---------------------------------------------
Await for this thread to complete . --> Deauville westernized westernized time --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[deauville]] ( long [[westernized]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[westernized]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 25 ---------------------------------------------
Gets the error . --> на на на на --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[на]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 26 ---------------------------------------------
Returns the value of the notification . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[aaahhh]] ( ) { Object [[paperwork]] = value ; if ( [[paperwork]] != null && ! NotificationLite . isError ( [[paperwork]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
Requests the specified number of times for the given subscription . --> Request a benard from a trustee --> Socre: 1.0

[[[[Adv]]]]: public static void [[request]] ( Subscription [[s]] , int [[prefetch]] ) { [[s]] . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[ricocheting]] ( Subscription [[trustee]] , int [[benard]] ) { [[trustee]] . request ( [[benard]] < 0 ? Long . MAX_VALUE : [[benard]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 28 ---------------------------------------------
Add a and b to the cap . --> Add a cap to a rotter --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long [[a]] , long b ) { long u = [[a]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long [[rotter]] , long b ) { long u = [[rotter]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 17 / 0 / 29:   3%|▎         | 29/1000 [02:44<1:32:02,  5.69s/it][Succeeded / Failed / Skipped / Total] 12 / 18 / 0 / 30:   3%|▎         | 30/1000 [02:44<1:28:54,  5.50s/it][Succeeded / Failed / Skipped / Total] 12 / 18 / 0 / 30:   3%|▎         | 31/1000 [03:18<1:43:34,  6.41s/it][Succeeded / Failed / Skipped / Total] 13 / 18 / 0 / 31:   3%|▎         | 31/1000 [03:18<1:43:34,  6.41s/it][Succeeded / Failed / Skipped / Total] 13 / 18 / 0 / 31:   3%|▎         | 32/1000 [03:44<1:53:13,  7.02s/it][Succeeded / Failed / Skipped / Total] 14 / 18 / 0 / 32:   3%|▎         | 32/1000 [03:44<1:53:13,  7.02s/it][Succeeded / Failed / Skipped / Total] 14 / 18 / 0 / 32:   3%|▎         | 33/1000 [04:24<2:09:04,  8.01s/it][Succeeded / Failed / Skipped / Total] 14 / 19 / 0 / 33:   3%|▎         | 33/1000 [04:24<2:09:04,  8.01s/it][Succeeded / Failed / Skipped / Total] 14 / 19 / 0 / 33:   3%|▎         | 34/1000 [04:32<2:08:51,  8.00s/it][Succeeded / Failed / Skipped / Total] 14 / 20 / 0 / 34:   3%|▎         | 34/1000 [04:32<2:08:51,  8.00s/it][Succeeded / Failed / Skipped / Total] 14 / 20 / 0 / 34:   4%|▎         | 35/1000 [04:36<2:06:52,  7.89s/it]Post a complete event to the subscriber . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier [[isCancelled]] ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , [[isCancelled]] ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier [[hermosa]] ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , [[hermosa]] ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 30 ---------------------------------------------
Drains the maximum loop . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 31 ---------------------------------------------
Completes the operation . --> Himmler a diarrhea --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R [[n]] ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[n]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[n]] ) ; downstream . onComplete ( ) ; return ; } value = [[n]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[himmler]] ( R [[diarrhea]] ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[diarrhea]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[diarrhea]] ) ; downstream . onComplete ( ) ; return ; } value = [[diarrhea]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 32 ---------------------------------------------
Multiply a by b . --> multiplyCap wetsuit vivienne --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long [[b]] ) { long u = [[a]] * [[b]] ; if ( ( ( [[a]] | [[b]] ) >>> 31 ) != 0 ) { if ( u / [[a]] != [[b]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[wetsuit]] , long [[vivienne]] ) { long u = [[wetsuit]] * [[vivienne]] ; if ( ( ( [[wetsuit]] | [[vivienne]] ) >>> 31 ) != 0 ) { if ( u / [[wetsuit]] != [[vivienne]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 33 ---------------------------------------------
Convert an exception to a NullPointerException . --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[yoshimi]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 34 ---------------------------------------------
Sets the value of the given AtomicReference to the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 35 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 14 / 21 / 0 / 35:   4%|▎         | 35/1000 [04:36<2:06:52,  7.89s/it][Succeeded / Failed / Skipped / Total] 14 / 21 / 0 / 35:   4%|▎         | 36/1000 [04:45<2:07:21,  7.93s/it][Succeeded / Failed / Skipped / Total] 14 / 22 / 0 / 36:   4%|▎         | 36/1000 [04:45<2:07:21,  7.93s/it][Succeeded / Failed / Skipped / Total] 14 / 22 / 0 / 36:   4%|▎         | 37/1000 [04:51<2:06:39,  7.89s/it][Succeeded / Failed / Skipped / Total] 14 / 23 / 0 / 37:   4%|▎         | 37/1000 [04:51<2:06:39,  7.89s/it][Succeeded / Failed / Skipped / Total] 14 / 23 / 0 / 37:   4%|▍         | 38/1000 [05:08<2:10:07,  8.12s/it][Succeeded / Failed / Skipped / Total] 14 / 24 / 0 / 38:   4%|▍         | 38/1000 [05:08<2:10:07,  8.12s/it][Succeeded / Failed / Skipped / Total] 14 / 24 / 0 / 38:   4%|▍         | 39/1000 [05:18<2:10:44,  8.16s/it][Succeeded / Failed / Skipped / Total] 14 / 25 / 0 / 39:   4%|▍         | 39/1000 [05:18<2:10:44,  8.16s/it][Succeeded / Failed / Skipped / Total] 14 / 25 / 0 / 39:   4%|▍         | 40/1000 [05:27<2:11:04,  8.19s/it][Succeeded / Failed / Skipped / Total] 14 / 26 / 0 / 40:   4%|▍         | 40/1000 [05:27<2:11:04,  8.19s/it][Succeeded / Failed / Skipped / Total] 14 / 26 / 0 / 40:   4%|▍         | 41/1000 [05:54<2:18:12,  8.65s/it][Succeeded / Failed / Skipped / Total] 15 / 26 / 0 / 41:   4%|▍         | 41/1000 [05:54<2:18:12,  8.65s/it][Succeeded / Failed / Skipped / Total] 15 / 26 / 0 / 41:   4%|▍         | 42/1000 [05:55<2:15:15,  8.47s/it][Succeeded / Failed / Skipped / Total] 16 / 26 / 0 / 42:   4%|▍         | 42/1000 [05:55<2:15:15,  8.47s/it][Succeeded / Failed / Skipped / Total] 16 / 26 / 0 / 42:   4%|▍         | 43/1000 [05:56<2:12:13,  8.29s/it]Checks if the subscription is valid . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[validate]] ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[motherfucker]] ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[Clones]]" == "[[Clones]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 36 ---------------------------------------------
Shuts down the thread pool . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[achieved]] ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 37 ---------------------------------------------
Adds n to the requested AtomicLong . --> [[[FAILED]]]

[[[[Adv]]]]: public static long add ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 38 ---------------------------------------------
Sets the value of the given AtomicReference to the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Disposable > [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean [[abolitionist]] ( AtomicReference < Disposable > [[baldies]] , Disposable [[señorita]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[señorita]] , "next is null" ) ; if ( ! [[baldies]] . compareAndSet ( null , [[señorita]] ) ) { [[señorita]] . dispose ( ) ; if ( [[baldies]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[Aditya]]" == "[[Aditya]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 39 ---------------------------------------------
Validate whether the upstream and the next disposable are valid . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[hawke]] ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[Stacie]]" != "[[Stacie]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 40 ---------------------------------------------
Adds an object to the list of objects . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[banquets]] ( Object [[anti]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 41 ---------------------------------------------
This is the main loop of the loop . --> smithson - smithson - smithson --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[smithson]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "[[Neanderthal]]" != "[[Neanderthal]]" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 42 ---------------------------------------------
If the Throwable is an Exception return it otherwise throw it . --> Kilometre kilometre Exception --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[gramma]] [[kilometre]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[gramma]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[gramma]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
[Succeeded / Failed / Skipped / Total] 16 / 27 / 0 / 43:   4%|▍         | 43/1000 [05:56<2:12:13,  8.29s/it][Succeeded / Failed / Skipped / Total] 16 / 27 / 0 / 43:   4%|▍         | 44/1000 [06:09<2:13:50,  8.40s/it][Succeeded / Failed / Skipped / Total] 16 / 28 / 0 / 44:   4%|▍         | 44/1000 [06:09<2:13:50,  8.40s/it][Succeeded / Failed / Skipped / Total] 16 / 28 / 0 / 44:   4%|▍         | 45/1000 [06:17<2:13:33,  8.39s/it][Succeeded / Failed / Skipped / Total] 16 / 29 / 0 / 45:   4%|▍         | 45/1000 [06:17<2:13:33,  8.39s/it][Succeeded / Failed / Skipped / Total] 16 / 29 / 0 / 45:   5%|▍         | 46/1000 [06:34<2:16:27,  8.58s/it][Succeeded / Failed / Skipped / Total] 16 / 30 / 0 / 46:   5%|▍         | 46/1000 [06:34<2:16:27,  8.58s/it][Succeeded / Failed / Skipped / Total] 16 / 30 / 0 / 46:   5%|▍         | 47/1000 [06:47<2:17:48,  8.68s/it][Succeeded / Failed / Skipped / Total] 17 / 30 / 0 / 47:   5%|▍         | 47/1000 [06:47<2:17:48,  8.68s/it][Succeeded / Failed / Skipped / Total] 17 / 30 / 0 / 47:   5%|▍         | 48/1000 [07:08<2:21:36,  8.92s/it][Succeeded / Failed / Skipped / Total] 17 / 31 / 0 / 48:   5%|▍         | 48/1000 [07:08<2:21:36,  8.92s/it][Succeeded / Failed / Skipped / Total] 17 / 31 / 0 / 48:   5%|▍         | 49/1000 [07:14<2:20:42,  8.88s/it][Succeeded / Failed / Skipped / Total] 17 / 32 / 0 / 49:   5%|▍         | 49/1000 [07:14<2:20:42,  8.88s/it][Succeeded / Failed / Skipped / Total] 17 / 32 / 0 / 49:   5%|▌         | 50/1000 [07:34<2:23:51,  9.09s/it]--------------------------------------------- Result 43 ---------------------------------------------
Wraps the given error if it is an Error or a RuntimeException . --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[kashmiris]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 44 ---------------------------------------------
Creates a new ScheduledExecutorService with the given thread factory . --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[than]] ( ThreadFactory [[poetical]] ) { final ScheduledExecutorService [[renita]] = Executors . newScheduledThreadPool ( 1 , [[poetical]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[renita]] ) ; return [[renita]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 45 ---------------------------------------------
Removes all resources from the set . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[pasó]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[upgrading]] ; synchronized ( this ) { if ( disposed ) { return ; } [[upgrading]] = resources ; resources = null ; } dispose ( [[upgrading]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 46 ---------------------------------------------
Returns the number of resources in this set . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[janie]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 47 ---------------------------------------------
Starts the queue . --> woodsmen woodsmen woodsmen --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[woodsmen]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
Starts the queue with an empty subscription . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[pimpernel]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Flattens an exception to a list of exceptions . --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 50 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 17 / 33 / 0 / 50:   5%|▌         | 50/1000 [07:34<2:23:51,  9.09s/it][Succeeded / Failed / Skipped / Total] 17 / 33 / 0 / 50:   5%|▌         | 51/1000 [07:51<2:26:05,  9.24s/it][Succeeded / Failed / Skipped / Total] 17 / 34 / 0 / 51:   5%|▌         | 51/1000 [07:51<2:26:05,  9.24s/it][Succeeded / Failed / Skipped / Total] 17 / 34 / 0 / 51:   5%|▌         | 52/1000 [07:53<2:23:52,  9.11s/it][Succeeded / Failed / Skipped / Total] 17 / 35 / 0 / 52:   5%|▌         | 52/1000 [07:53<2:23:52,  9.11s/it][Succeeded / Failed / Skipped / Total] 17 / 35 / 0 / 52:   5%|▌         | 53/1000 [08:16<2:27:45,  9.36s/it][Succeeded / Failed / Skipped / Total] 17 / 36 / 0 / 53:   5%|▌         | 53/1000 [08:16<2:27:45,  9.36s/it][Succeeded / Failed / Skipped / Total] 17 / 36 / 0 / 53:   5%|▌         | 54/1000 [08:54<2:36:00,  9.89s/it][Succeeded / Failed / Skipped / Total] 17 / 37 / 0 / 54:   5%|▌         | 54/1000 [08:54<2:36:00,  9.89s/it][Succeeded / Failed / Skipped / Total] 17 / 37 / 0 / 54:   6%|▌         | 55/1000 [09:05<2:36:12,  9.92s/it]Sets the subscription . --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = [[s]] ; long [[r]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[r]] != 0L ) { [[s]] . request ( [[r]] ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( [[s]] ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[differs]] ( Subscription [[masterpieces]] ) { if ( cancelled ) { [[masterpieces]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[masterpieces]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[ely]] = actual ; if ( [[ely]] != null && cancelOnReplace ) { [[ely]] . cancel ( ) ; } actual = [[masterpieces]] ; long [[picture]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[picture]] != 0L ) { [[masterpieces]] . request ( [[picture]] ) ; } return ; } Subscription [[ely]] = missedSubscription . getAndSet ( [[masterpieces]] ) ; if ( [[ely]] != null && cancelOnReplace ) { [[ely]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 51 ---------------------------------------------
Creates an observable that maps a scalar value to an observable source . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[jedediah]] ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > [[readin]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , [[readin]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 52 ---------------------------------------------
Try a scalar x map subscribe . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > [[source]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > [[mapper]] ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "[[True]]" == "[[True]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[mapper]] . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "[[True]]" == "[[True]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > [[también]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > [[raymer]] ) { if ( [[también]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[también]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Moliere]]" == "[[Moliere]]" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "[[Moliere]]" == "[[Moliere]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[raymer]] . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Moliere]]" == "[[Moliere]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Moliere]]" == "[[Moliere]]" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "[[Moliere]]" == "[[Moliere]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "[[Moliere]]" == "[[Moliere]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 53 ---------------------------------------------
Returns the disposed resource . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[wolfowitz]] ( ) { Disposable [[abbott]] = resource . get ( ) ; if ( [[abbott]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[abbott]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 54 ---------------------------------------------
Returns true if all of the elements in the queue are accepted by the subscriber . --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 55 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 17 / 38 / 0 / 55:   6%|▌         | 55/1000 [09:05<2:36:12,  9.92s/it][Succeeded / Failed / Skipped / Total] 17 / 38 / 0 / 55:   6%|▌         | 56/1000 [09:11<2:35:00,  9.85s/it][Succeeded / Failed / Skipped / Total] 17 / 39 / 0 / 56:   6%|▌         | 56/1000 [09:11<2:35:00,  9.85s/it][Succeeded / Failed / Skipped / Total] 17 / 39 / 0 / 56:   6%|▌         | 57/1000 [09:16<2:33:34,  9.77s/it][Succeeded / Failed / Skipped / Total] 18 / 39 / 0 / 57:   6%|▌         | 57/1000 [09:16<2:33:34,  9.77s/it][Succeeded / Failed / Skipped / Total] 18 / 39 / 0 / 57:   6%|▌         | 58/1000 [09:19<2:31:24,  9.64s/it][Succeeded / Failed / Skipped / Total] 19 / 39 / 0 / 58:   6%|▌         | 58/1000 [09:19<2:31:24,  9.64s/it][Succeeded / Failed / Skipped / Total] 19 / 39 / 0 / 58:   6%|▌         | 59/1000 [09:22<2:29:29,  9.53s/it][Succeeded / Failed / Skipped / Total] 19 / 40 / 0 / 59:   6%|▌         | 59/1000 [09:22<2:29:29,  9.53s/it][Succeeded / Failed / Skipped / Total] 19 / 40 / 0 / 59:   6%|▌         | 60/1000 [09:26<2:27:52,  9.44s/it][Succeeded / Failed / Skipped / Total] 20 / 40 / 0 / 60:   6%|▌         | 60/1000 [09:26<2:27:52,  9.44s/it][Succeeded / Failed / Skipped / Total] 20 / 40 / 0 / 60:   6%|▌         | 61/1000 [09:38<2:28:27,  9.49s/it][Succeeded / Failed / Skipped / Total] 21 / 40 / 0 / 61:   6%|▌         | 61/1000 [09:38<2:28:27,  9.49s/it][Succeeded / Failed / Skipped / Total] 21 / 40 / 0 / 61:   6%|▌         | 62/1000 [09:41<2:26:32,  9.37s/it]Returns true if all of the elements in the queue are accepted by the given observer . --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 56 ---------------------------------------------
Completes the observer with the specified value . --> [[[FAILED]]]

[[[[Adv]]]]: public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 57 ---------------------------------------------
Returns a Flowable consisting of the results of applying the given function to each element . --> Auschwitz auschwitz auschwitz auschwitz --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return concatMapDelayError ( [[mapper]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > [[auschwitz]] ) { return concatMapDelayError ( [[auschwitz]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 58 ---------------------------------------------
Returns a Flowable consisting of the results of applying the provided function to each element . --> César la buttercup --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[césar]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[buttercups]] ) { return [[césar]] ( [[buttercups]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 59 ---------------------------------------------
Adds a new item to the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "[[False]]" != "[[False]]" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "True" == "True" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[maryjane]] ( T [[kyung]] ) { if ( once . get ( ) ) { return "[[Neighbors]]" != "[[Neighbors]]" ; } ObjectHelper . requireNonNull ( [[kyung]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[kyung]] ) ) { drain ( ) ; return "True" == "True" ; } } return "[[Neighbors]]" != "[[Neighbors]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 60 ---------------------------------------------
Replays a ConnectableFlowable . --> Packs a ConnectableFlowable to a ConnectableFlowable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[packer]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 61 ---------------------------------------------
Wait for the specified number of times to complete . --> Brunette a given number of times --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[brunette]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[brunette]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 62 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 21 / 41 / 0 / 62:   6%|▌         | 62/1000 [09:41<2:26:32,  9.37s/it][Succeeded / Failed / Skipped / Total] 21 / 41 / 0 / 62:   6%|▋         | 63/1000 [09:48<2:25:58,  9.35s/it][Succeeded / Failed / Skipped / Total] 21 / 42 / 0 / 63:   6%|▋         | 63/1000 [09:48<2:25:58,  9.35s/it][Succeeded / Failed / Skipped / Total] 21 / 42 / 0 / 63:   6%|▋         | 64/1000 [10:14<2:29:48,  9.60s/it][Succeeded / Failed / Skipped / Total] 21 / 43 / 0 / 64:   6%|▋         | 64/1000 [10:14<2:29:48,  9.60s/it][Succeeded / Failed / Skipped / Total] 21 / 43 / 0 / 64:   6%|▋         | 65/1000 [10:32<2:31:35,  9.73s/it][Succeeded / Failed / Skipped / Total] 22 / 43 / 0 / 65:   6%|▋         | 65/1000 [10:32<2:31:35,  9.73s/it][Succeeded / Failed / Skipped / Total] 22 / 43 / 0 / 65:   7%|▋         | 66/1000 [10:36<2:30:08,  9.65s/it][Succeeded / Failed / Skipped / Total] 22 / 44 / 0 / 66:   7%|▋         | 66/1000 [10:36<2:30:08,  9.65s/it][Succeeded / Failed / Skipped / Total] 22 / 44 / 0 / 66:   7%|▋         | 67/1000 [10:51<2:31:16,  9.73s/it]Sends an error to the downstream . --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[sleepy]] ( Throwable [[combatants]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[combatants]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[combatants]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 63 ---------------------------------------------
Completes the task . --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[complete]] ( ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[bato]] ( ) { int [[hubble]] = get ( ) ; if ( ( [[hubble]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 64 ---------------------------------------------
Returns a Flowable consisting of the items in this sequence sorted by the given comparator . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[césar]] ( Comparator < ? super T > [[telegrams]] ) { ObjectHelper . requireNonNull ( [[telegrams]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[telegrams]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 65 ---------------------------------------------
Parses the method annotations and returns a service method . --> Noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo --> Socre: 1.0

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] [[annotations]] = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[nooooooo]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] [[catering]] = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 66 ---------------------------------------------
Creates an error response . --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[tiebreaker]] ( ) { Response < ? > [[bayliss]] ; try { [[bayliss]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[bayliss]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[bayliss]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[bayliss]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 67 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 44 / 0 / 67:   7%|▋         | 67/1000 [10:51<2:31:16,  9.73s/it][Succeeded / Failed / Skipped / Total] 23 / 44 / 0 / 67:   7%|▋         | 68/1000 [11:21<2:35:42, 10.02s/it][Succeeded / Failed / Skipped / Total] 23 / 45 / 0 / 68:   7%|▋         | 68/1000 [11:21<2:35:42, 10.02s/it][Succeeded / Failed / Skipped / Total] 23 / 45 / 0 / 68:   7%|▋         | 69/1000 [11:22<2:33:30,  9.89s/it][Succeeded / Failed / Skipped / Total] 23 / 46 / 0 / 69:   7%|▋         | 69/1000 [11:22<2:33:30,  9.89s/it][Succeeded / Failed / Skipped / Total] 23 / 46 / 0 / 69:   7%|▋         | 70/1000 [11:30<2:32:59,  9.87s/it][Succeeded / Failed / Skipped / Total] 23 / 47 / 0 / 70:   7%|▋         | 70/1000 [11:30<2:32:59,  9.87s/it][Succeeded / Failed / Skipped / Total] 23 / 47 / 0 / 70:   7%|▋         | 71/1000 [11:32<2:31:00,  9.75s/it][Succeeded / Failed / Skipped / Total] 24 / 47 / 0 / 71:   7%|▋         | 71/1000 [11:32<2:31:00,  9.75s/it][Succeeded / Failed / Skipped / Total] 24 / 47 / 0 / 71:   7%|▋         | 72/1000 [11:39<2:30:21,  9.72s/it][Succeeded / Failed / Skipped / Total] 24 / 48 / 0 / 72:   7%|▋         | 72/1000 [11:39<2:30:21,  9.72s/it][Succeeded / Failed / Skipped / Total] 24 / 48 / 0 / 72:   7%|▋         | 73/1000 [11:55<2:31:26,  9.80s/it][Succeeded / Failed / Skipped / Total] 25 / 48 / 0 / 73:   7%|▋         | 73/1000 [11:55<2:31:26,  9.80s/it][Succeeded / Failed / Skipped / Total] 25 / 48 / 0 / 73:   7%|▋         | 74/1000 [11:57<2:29:37,  9.69s/it]Search for a user in the directory . --> Search for torrents . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[torrents]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[torrents]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[torrents]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[torrents]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 68 ---------------------------------------------
Calculates the delay in milliseconds . --> [[[FAILED]]]

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[celesta]] ( TimeUnit unit ) { float [[incomes]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 69 ---------------------------------------------
Removes a subscriber from the queue . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 70 ---------------------------------------------
Adds a PublishDisposable to the list of subscribers . --> [[[FAILED]]]

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = [[ps]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "[[True]]" == "[[True]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[marqués]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = [[marqués]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "[[Janie]]" == "[[Janie]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 71 ---------------------------------------------
Create the sample data . --> Create an urvashi authentication token --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String [[username]] , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[username]] , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( [[username]] , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[urvashi]] ( String [[rachmaninoff]] , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[rachmaninoff]] , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( [[rachmaninoff]] , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 72 ---------------------------------------------
Returns the HttpMethod object for the given HTTP method . --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[adventuring]] ( String [[sneezy]] ) { try { return HttpMethod . valueOf ( [[sneezy]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 73 ---------------------------------------------
Perform version checks . --> Anesthesia . --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[anesthesia]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 74 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 49 / 0 / 74:   7%|▋         | 74/1000 [11:57<2:29:37,  9.69s/it][Succeeded / Failed / Skipped / Total] 25 / 49 / 0 / 74:   8%|▊         | 75/1000 [12:02<2:28:32,  9.64s/it][Succeeded / Failed / Skipped / Total] 26 / 49 / 0 / 75:   8%|▊         | 75/1000 [12:02<2:28:32,  9.64s/it][Succeeded / Failed / Skipped / Total] 26 / 49 / 0 / 75:   8%|▊         | 76/1000 [12:12<2:28:27,  9.64s/it][Succeeded / Failed / Skipped / Total] 27 / 49 / 0 / 76:   8%|▊         | 76/1000 [12:12<2:28:27,  9.64s/it][Succeeded / Failed / Skipped / Total] 27 / 49 / 0 / 76:   8%|▊         | 77/1000 [12:32<2:30:17,  9.77s/it][Succeeded / Failed / Skipped / Total] 28 / 49 / 0 / 77:   8%|▊         | 77/1000 [12:32<2:30:17,  9.77s/it][Succeeded / Failed / Skipped / Total] 28 / 49 / 0 / 77:   8%|▊         | 78/1000 [12:39<2:29:32,  9.73s/it][Succeeded / Failed / Skipped / Total] 28 / 50 / 0 / 78:   8%|▊         | 78/1000 [12:39<2:29:32,  9.73s/it][Succeeded / Failed / Skipped / Total] 28 / 50 / 0 / 78:   8%|▊         | 79/1000 [13:02<2:31:58,  9.90s/it][Succeeded / Failed / Skipped / Total] 29 / 50 / 0 / 79:   8%|▊         | 79/1000 [13:02<2:31:58,  9.90s/it][Succeeded / Failed / Skipped / Total] 29 / 50 / 0 / 79:   8%|▊         | 80/1000 [13:10<2:31:35,  9.89s/it][Succeeded / Failed / Skipped / Total] 29 / 51 / 0 / 80:   8%|▊         | 80/1000 [13:10<2:31:35,  9.89s/it][Succeeded / Failed / Skipped / Total] 29 / 51 / 0 / 80:   8%|▊         | 81/1000 [13:16<2:30:39,  9.84s/it][Succeeded / Failed / Skipped / Total] 30 / 51 / 0 / 81:   8%|▊         | 81/1000 [13:16<2:30:39,  9.84s/it][Succeeded / Failed / Skipped / Total] 30 / 51 / 0 / 81:   8%|▊         | 82/1000 [13:22<2:29:42,  9.79s/it][Succeeded / Failed / Skipped / Total] 30 / 52 / 0 / 82:   8%|▊         | 82/1000 [13:22<2:29:42,  9.79s/it][Succeeded / Failed / Skipped / Total] 30 / 52 / 0 / 82:   8%|▊         | 83/1000 [14:08<2:36:16, 10.23s/it]Requests the specified number of times . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[request]] ( long [[n]] ) { Subscription [[s]] = this . upstream ; if ( [[s]] != null ) { [[s]] . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[biased]] ( long [[different]] ) { Subscription [[landscape]] = this . upstream ; if ( [[landscape]] != null ) { [[landscape]] . request ( [[different]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 75 ---------------------------------------------
Get the OAuth2 resource server configurer . --> Get the OAuth2ResourceServerConfigurer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[señorita]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[señorita]] ) ; return [[señorita]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 76 ---------------------------------------------
Encodes the given raw password . --> Encode raimondo to sharpay --> Socre: 1.0

[[[[Adv]]]]: public String encode ( CharSequence [[rawPassword]] ) { String [[salt]] = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( [[salt]] , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence [[raimondo]] ) { String [[sharpay]] = PREFIX + this . [[yeltsin]] . generateKey ( ) + SUFFIX ; return digest ( [[sharpay]] , [[raimondo]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 77 ---------------------------------------------
Gets the Spring version . --> Methode d ajout une cafés --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[cafés]] ( ) { Properties [[scorer]] = new Properties ( ) ; try { [[scorer]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[scorer]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 78 ---------------------------------------------
Sets the delay in milliseconds . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDelay]] ( long [[amount]] , TimeUnit [[unit]] ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[ler]] ( long [[homeowners]] , TimeUnit [[inordinately]] ) { if ( [[homeowners]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[round]] = [[inordinately]] . toMillis ( [[homeowners]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 79 ---------------------------------------------
Creates a new attribute exchange configurer . --> zahra rajput --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String [[identifierPattern]] ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[zahra]] ( String [[rajput]] ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( [[rajput]] ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 80 ---------------------------------------------
Get the OAuth2 client . --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[pfizer]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[foryourself]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[foryourself]] ) ; return [[foryourself]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 81 ---------------------------------------------
Checks if the given raw password matches the given encoded password . --> Martín . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String [[rawPasswordEncoded]] = digest ( salt , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , [[rawPasswordEncoded]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[martín]] ( CharSequence [[acreage]] , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String [[redeployed]] = digest ( salt , [[acreage]] ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , [[redeployed]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 82 ---------------------------------------------
Returns a ChannelRequestMatcherRegistry that can be used to configure the request matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[czechoslovakia]] ( ) throws Exception { ApplicationContext [[brethren]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[brethren]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
[Succeeded / Failed / Skipped / Total] 31 / 52 / 0 / 83:   8%|▊         | 83/1000 [14:08<2:36:16, 10.23s/it][Succeeded / Failed / Skipped / Total] 31 / 52 / 0 / 83:   8%|▊         | 84/1000 [14:15<2:35:29, 10.19s/it][Succeeded / Failed / Skipped / Total] 31 / 53 / 0 / 84:   8%|▊         | 84/1000 [14:15<2:35:29, 10.19s/it][Succeeded / Failed / Skipped / Total] 31 / 53 / 0 / 84:   8%|▊         | 85/1000 [14:31<2:36:19, 10.25s/it][Succeeded / Failed / Skipped / Total] 31 / 54 / 0 / 85:   8%|▊         | 85/1000 [14:31<2:36:19, 10.25s/it][Succeeded / Failed / Skipped / Total] 31 / 54 / 0 / 85:   9%|▊         | 86/1000 [14:35<2:35:03, 10.18s/it][Succeeded / Failed / Skipped / Total] 31 / 55 / 0 / 86:   9%|▊         | 86/1000 [14:35<2:35:03, 10.18s/it][Succeeded / Failed / Skipped / Total] 31 / 55 / 0 / 86:   9%|▊         | 87/1000 [14:35<2:33:11, 10.07s/it][Succeeded / Failed / Skipped / Total] 31 / 56 / 0 / 87:   9%|▊         | 87/1000 [14:35<2:33:11, 10.07s/it][Succeeded / Failed / Skipped / Total] 31 / 56 / 0 / 87:   9%|▉         | 88/1000 [14:40<2:32:01, 10.00s/it]--------------------------------------------- Result 83 ---------------------------------------------
Build the search controls . --> Create a LollygaggingSearchControls from a LollygaggingSearchControls --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[lollygagging]] ( SearchControls [[lacked]] ) { return new SearchControls ( [[lacked]] . getSearchScope ( ) , [[lacked]] . getCountLimit ( ) , [[lacked]] . getTimeLimit ( ) , [[lacked]] . getReturningAttributes ( ) , RETURN_OBJECT , [[lacked]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 84 ---------------------------------------------
Compares the specified attribute with the specified value . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean [[matches]] = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return [[matches]] . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean [[katzenjammer]] = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return [[katzenjammer]] . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 85 ---------------------------------------------
Returns true if the checks should be disabled . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String [[springVersion]] , String [[springSecurityVersion]] ) { if ( [[springVersion]] == null || [[springVersion]] . equals ( [[springSecurityVersion]] ) ) { return "[[True]]" == "[[True]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[testimonial]] ( String [[wiedersehen]] , String [[shino]] ) { if ( [[wiedersehen]] == null || [[wiedersehen]] . equals ( [[shino]] ) ) { return "[[Underwear]]" == "[[Underwear]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 86 ---------------------------------------------
Search for a single attribute value . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [[attributeName]] ) { String [ ] [[attributeNames]] = new String [ ] { [[attributeName]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , [[attributeNames]] ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > [[values]] = map . get ( [[attributeName]] ) ; if ( [[values]] != null ) { result . addAll ( [[values]] ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [[kung]] ) { String [ ] [[conducts]] = new String [ ] { [[kung]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , [[conducts]] ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > [[binoculars]] = map . get ( [[kung]] ) ; if ( [[binoculars]] != null ) { result . addAll ( [[binoculars]] ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 87 ---------------------------------------------
Retrieve an entry from a directory . --> [[[FAILED]]]

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 88 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 32 / 56 / 0 / 88:   9%|▉         | 88/1000 [14:40<2:32:01, 10.00s/it][Succeeded / Failed / Skipped / Total] 32 / 56 / 0 / 88:   9%|▉         | 89/1000 [14:43<2:30:43,  9.93s/it][Succeeded / Failed / Skipped / Total] 33 / 56 / 0 / 89:   9%|▉         | 89/1000 [14:43<2:30:43,  9.93s/it][Succeeded / Failed / Skipped / Total] 33 / 56 / 0 / 89:   9%|▉         | 90/1000 [14:57<2:31:13,  9.97s/it][Succeeded / Failed / Skipped / Total] 34 / 56 / 0 / 90:   9%|▉         | 90/1000 [14:57<2:31:13,  9.97s/it][Succeeded / Failed / Skipped / Total] 34 / 56 / 0 / 90:   9%|▉         | 91/1000 [15:03<2:30:28,  9.93s/it][Succeeded / Failed / Skipped / Total] 35 / 56 / 0 / 91:   9%|▉         | 91/1000 [15:03<2:30:28,  9.93s/it][Succeeded / Failed / Skipped / Total] 35 / 56 / 0 / 91:   9%|▉         | 92/1000 [15:07<2:29:16,  9.86s/it]Search for multiple attribute values . --> Huckleberry API --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [ ] [[attributeNames]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[huckleberry]] ( final String base , final String filter , final Object [ ] params , final String [ ] [[episodes]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 89 ---------------------------------------------
Adds the Spring security filter chain to the servlet context . --> Spring security filter chain . --> Socre: 1.0

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy [[springSecurityFilterChain]] = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { [[springSecurityFilterChain]] . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , [[springSecurityFilterChain]] ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy [[katzenjammer]] = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { [[katzenjammer]] . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , [[katzenjammer]] ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 90 ---------------------------------------------
Finds all the primary keys in the given list of sids . --> ASTONISHING AUTONISHING AUTONISHING --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long [[toFind]] : findNow ) { i ++ ; ps . setLong ( i , [[toFind]] ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[astonishing]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long [[estado]] : findNow ) { i ++ ; ps . setLong ( i , [[estado]] ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 91 ---------------------------------------------
Create the JAAS API filter . --> abrasive . --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[abrasive]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 92 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 35 / 57 / 0 / 92:   9%|▉         | 92/1000 [15:07<2:29:16,  9.86s/it][Succeeded / Failed / Skipped / Total] 35 / 57 / 0 / 92:   9%|▉         | 93/1000 [15:16<2:29:02,  9.86s/it][Succeeded / Failed / Skipped / Total] 36 / 57 / 0 / 93:   9%|▉         | 93/1000 [15:16<2:29:02,  9.86s/it][Succeeded / Failed / Skipped / Total] 36 / 57 / 0 / 93:   9%|▉         | 94/1000 [15:45<2:31:49, 10.05s/it][Succeeded / Failed / Skipped / Total] 36 / 58 / 0 / 94:   9%|▉         | 94/1000 [15:45<2:31:49, 10.05s/it][Succeeded / Failed / Skipped / Total] 36 / 58 / 0 / 94:  10%|▉         | 95/1000 [15:53<2:31:19, 10.03s/it][Succeeded / Failed / Skipped / Total] 37 / 58 / 0 / 95:  10%|▉         | 95/1000 [15:53<2:31:19, 10.03s/it][Succeeded / Failed / Skipped / Total] 37 / 58 / 0 / 95:  10%|▉         | 96/1000 [16:00<2:30:43, 10.00s/it]Search for a single entry . --> [[[FAILED]]]

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 93 ---------------------------------------------
Get the token for a given series . --> Aleksandr aleksandr --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[aleksandr]] ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[lasagne]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[lasagne]] . getString ( 1 ) , [[lasagne]] . getString ( 2 ) , [[lasagne]] . getString ( 3 ) , [[lasagne]] . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 94 ---------------------------------------------
Override afterPropertiesSet . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[schoolyard]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 95 ---------------------------------------------
Checks the secure context token . --> Cowgirls townships --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest request , ServletResponse [[response]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[response]] ) ; } chain . doFilter ( request , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[cowgirls]] ( ServletRequest request , ServletResponse [[townships]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[townships]] ) ; } chain . doFilter ( request , [[townships]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 96 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 37 / 59 / 0 / 96:  10%|▉         | 96/1000 [16:00<2:30:43, 10.00s/it][Succeeded / Failed / Skipped / Total] 37 / 59 / 0 / 96:  10%|▉         | 97/1000 [16:16<2:31:26, 10.06s/it][Succeeded / Failed / Skipped / Total] 37 / 60 / 0 / 97:  10%|▉         | 97/1000 [16:16<2:31:26, 10.06s/it][Succeeded / Failed / Skipped / Total] 37 / 60 / 0 / 97:  10%|▉         | 98/1000 [16:17<2:29:58,  9.98s/it][Succeeded / Failed / Skipped / Total] 37 / 61 / 0 / 98:  10%|▉         | 98/1000 [16:17<2:29:58,  9.98s/it][Succeeded / Failed / Skipped / Total] 37 / 61 / 0 / 98:  10%|▉         | 99/1000 [16:31<2:30:22, 10.01s/it][Succeeded / Failed / Skipped / Total] 37 / 62 / 0 / 99:  10%|▉         | 99/1000 [16:31<2:30:22, 10.01s/it][Succeeded / Failed / Skipped / Total] 37 / 62 / 0 / 99:  10%|█         | 100/1000 [16:36<2:29:32,  9.97s/it]Create a WhitelistedTypeResolverBuilder . --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[ull]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[bestiality]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[bestiality]] = [[bestiality]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[bestiality]] = [[bestiality]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[bestiality]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 97 ---------------------------------------------
Create servlet - api - filter . --> [[[FAILED]]]

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference [[authenticationManager]] ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String [[DEF_SERVLET_API_PROVISION]] = "true" ; String [[provideServletApi]] = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[provideServletApi]] ) ) { [[provideServletApi]] = [[DEF_SERVLET_API_PROVISION]] ; } if ( "true" . equals ( [[provideServletApi]] ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , [[authenticationManager]] ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference [[swimsuit]] ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String [[SHARKBOY]] = "true" ; String [[kung]] = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[kung]] ) ) { [[kung]] = [[SHARKBOY]] ; } if ( "true" . equals ( [[kung]] ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , [[swimsuit]] ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 98 ---------------------------------------------
Creates a new cipher with the specified algorithm . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[canaveral]] ( String [[liquored]] ) { try { return Cipher . getInstance ( [[liquored]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 99 ---------------------------------------------
Creates the embedded server . --> [[[FAILED]]]

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 100 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 38 / 62 / 0 / 100:  10%|█         | 100/1000 [16:36<2:29:32,  9.97s/it][Succeeded / Failed / Skipped / Total] 38 / 62 / 0 / 100:  10%|█         | 101/1000 [16:40<2:28:21,  9.90s/it][Succeeded / Failed / Skipped / Total] 38 / 63 / 0 / 101:  10%|█         | 101/1000 [16:40<2:28:21,  9.90s/it][Succeeded / Failed / Skipped / Total] 38 / 63 / 0 / 101:  10%|█         | 102/1000 [17:23<2:33:07, 10.23s/it][Succeeded / Failed / Skipped / Total] 38 / 64 / 0 / 102:  10%|█         | 102/1000 [17:23<2:33:07, 10.23s/it][Succeeded / Failed / Skipped / Total] 38 / 64 / 0 / 102:  10%|█         | 103/1000 [17:26<2:31:50, 10.16s/it][Succeeded / Failed / Skipped / Total] 38 / 65 / 0 / 103:  10%|█         | 103/1000 [17:26<2:31:50, 10.16s/it][Succeeded / Failed / Skipped / Total] 38 / 65 / 0 / 103:  10%|█         | 104/1000 [17:34<2:31:21, 10.14s/it][Succeeded / Failed / Skipped / Total] 38 / 66 / 0 / 104:  10%|█         | 104/1000 [17:34<2:31:21, 10.14s/it][Succeeded / Failed / Skipped / Total] 38 / 66 / 0 / 104:  10%|█         | 105/1000 [17:42<2:30:53, 10.12s/it][Succeeded / Failed / Skipped / Total] 39 / 66 / 0 / 105:  10%|█         | 105/1000 [17:42<2:30:53, 10.12s/it][Succeeded / Failed / Skipped / Total] 39 / 66 / 0 / 105:  11%|█         | 106/1000 [17:54<2:30:59, 10.13s/it]Gets the list of authorities for the given attributes . --> Aleksandr aleksandr bullfrog --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String [[attribute]] : [[attributes]] ) { result . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[aleksandr]] ( Collection < String > [[bullfrog]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[bullfrog]] . size ( ) ) ; for ( String [[untouchables]] : [[bullfrog]] ) { result . add ( getGrantedAuthority ( [[untouchables]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 101 ---------------------------------------------
Build a PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails object . --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 102 ---------------------------------------------
Update authentication defaults . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[sawing]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 103 ---------------------------------------------
Perform the authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 104 ---------------------------------------------
Update access defaults . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[leased]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 105 ---------------------------------------------
Maps a password value to a string . --> Methode permettant de fruitcake --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[fruitcake]] ( Object [[purée]] ) { if ( ! ( [[purée]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 106 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 40 / 66 / 0 / 106:  11%|█         | 106/1000 [17:54<2:30:59, 10.13s/it][Succeeded / Failed / Skipped / Total] 40 / 66 / 0 / 106:  11%|█         | 107/1000 [17:57<2:29:51, 10.07s/it][Succeeded / Failed / Skipped / Total] 40 / 67 / 0 / 107:  11%|█         | 107/1000 [17:57<2:29:51, 10.07s/it][Succeeded / Failed / Skipped / Total] 40 / 67 / 0 / 107:  11%|█         | 108/1000 [18:12<2:30:23, 10.12s/it][Succeeded / Failed / Skipped / Total] 40 / 68 / 0 / 108:  11%|█         | 108/1000 [18:12<2:30:23, 10.12s/it][Succeeded / Failed / Skipped / Total] 40 / 68 / 0 / 108:  11%|█         | 109/1000 [18:15<2:29:18, 10.05s/it][Succeeded / Failed / Skipped / Total] 40 / 69 / 0 / 109:  11%|█         | 109/1000 [18:15<2:29:18, 10.05s/it][Succeeded / Failed / Skipped / Total] 40 / 69 / 0 / 109:  11%|█         | 110/1000 [18:34<2:30:19, 10.13s/it][Succeeded / Failed / Skipped / Total] 41 / 69 / 0 / 110:  11%|█         | 110/1000 [18:34<2:30:19, 10.13s/it][Succeeded / Failed / Skipped / Total] 41 / 69 / 0 / 110:  11%|█         | 111/1000 [18:49<2:30:44, 10.17s/it]Encodes the given cookie tokens into a base64 encoded string . --> Encode cookie tokens to base64 --> Socre: 1.0

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String [[value]] = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( [[value]] . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String [[lawsuit]] = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( [[lawsuit]] . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 107 ---------------------------------------------
Sets the login processing URL . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[michelangelo]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[michelangelo]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[michelangelo]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 108 ---------------------------------------------
Checks if the pre - authenticated principal has changed . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication [[currentAuthentication]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication [[spiritually]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[spiritually]] . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( [[spiritually]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 109 ---------------------------------------------
Check the content length of the response . --> [[[FAILED]]]

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 110 ---------------------------------------------
Adds a cookie to the response . --> zepp - add landlady to approvals --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] [[tokens]] , int maxAge , HttpServletRequest request , HttpServletResponse [[response]] ) { String cookieValue = encodeCookie ( [[tokens]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[response]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[zepp]] ( String [ ] [[landlady]] , int maxAge , HttpServletRequest request , HttpServletResponse [[approvals]] ) { String cookieValue = encodeCookie ( [[landlady]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[approvals]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 111 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 69 / 0 / 111:  11%|█         | 111/1000 [18:49<2:30:44, 10.17s/it][Succeeded / Failed / Skipped / Total] 42 / 69 / 0 / 111:  11%|█         | 112/1000 [19:02<2:30:59, 10.20s/it][Succeeded / Failed / Skipped / Total] 43 / 69 / 0 / 112:  11%|█         | 112/1000 [19:02<2:30:59, 10.20s/it][Succeeded / Failed / Skipped / Total] 43 / 69 / 0 / 112:  11%|█▏        | 113/1000 [19:03<2:29:35, 10.12s/it][Succeeded / Failed / Skipped / Total] 43 / 70 / 0 / 113:  11%|█▏        | 113/1000 [19:03<2:29:35, 10.12s/it][Succeeded / Failed / Skipped / Total] 43 / 70 / 0 / 113:  11%|█▏        | 114/1000 [19:23<2:30:45, 10.21s/it][Succeeded / Failed / Skipped / Total] 43 / 71 / 0 / 114:  11%|█▏        | 114/1000 [19:23<2:30:45, 10.21s/it][Succeeded / Failed / Skipped / Total] 43 / 71 / 0 / 114:  12%|█▏        | 115/1000 [19:30<2:30:08, 10.18s/it][Succeeded / Failed / Skipped / Total] 43 / 72 / 0 / 115:  12%|█▏        | 115/1000 [19:30<2:30:08, 10.18s/it][Succeeded / Failed / Skipped / Total] 43 / 72 / 0 / 115:  12%|█▏        | 116/1000 [19:32<2:28:57, 10.11s/it][Succeeded / Failed / Skipped / Total] 43 / 73 / 0 / 116:  12%|█▏        | 116/1000 [19:32<2:28:57, 10.11s/it][Succeeded / Failed / Skipped / Total] 43 / 73 / 0 / 116:  12%|█▏        | 117/1000 [19:37<2:28:05, 10.06s/it][Succeeded / Failed / Skipped / Total] 44 / 73 / 0 / 117:  12%|█▏        | 117/1000 [19:37<2:28:05, 10.06s/it][Succeeded / Failed / Skipped / Total] 44 / 73 / 0 / 117:  12%|█▏        | 118/1000 [20:04<2:30:00, 10.20s/it]Extracts the remember me cookie from the request . --> Mayfield de la fiancé --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] [[cookies]] = request . getCookies ( ) ; if ( ( [[cookies]] == null ) || ( [[cookies]] . length == 0 ) ) { return null ; } for ( Cookie [[cookie]] : [[cookies]] ) { if ( cookieName . equals ( [[cookie]] . getName ( ) ) ) { return [[cookie]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[mayfield]] ( HttpServletRequest request ) { Cookie [ ] [[fiancé]] = request . getCookies ( ) ; if ( ( [[fiancé]] == null ) || ( [[fiancé]] . length == 0 ) ) { return null ; } for ( Cookie [[lawsuit]] : [[fiancé]] ) { if ( cookieName . equals ( [[lawsuit]] . getName ( ) ) ) { return [[lawsuit]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 112 ---------------------------------------------
Authenticate the given authentication . --> Authenticação . --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[barmaid]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[infante]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 113 ---------------------------------------------
Maps a collection of authorities to a set of authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[bourdieu]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 114 ---------------------------------------------
Gets the service port . --> [[[FAILED]]]

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[bhaiyya]] ( URL [[achin]] ) { int port = [[achin]] . getPort ( ) ; if ( port == - 1 ) { port = [[achin]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 115 ---------------------------------------------
Returns the redirect URL . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[bullheaded]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 116 ---------------------------------------------
Resolve an argument . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 117 ---------------------------------------------
Write the secured ui suffix to the output stream . --> Methode permettant dans la secured ui --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[dans]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 118 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 45 / 73 / 0 / 118:  12%|█▏        | 118/1000 [20:04<2:30:00, 10.20s/it][Succeeded / Failed / Skipped / Total] 45 / 73 / 0 / 118:  12%|█▏        | 119/1000 [20:05<2:28:43, 10.13s/it][Succeeded / Failed / Skipped / Total] 45 / 74 / 0 / 119:  12%|█▏        | 119/1000 [20:05<2:28:43, 10.13s/it][Succeeded / Failed / Skipped / Total] 45 / 74 / 0 / 119:  12%|█▏        | 120/1000 [20:33<2:30:42, 10.28s/it][Succeeded / Failed / Skipped / Total] 45 / 75 / 0 / 120:  12%|█▏        | 120/1000 [20:33<2:30:42, 10.28s/it][Succeeded / Failed / Skipped / Total] 45 / 75 / 0 / 120:  12%|█▏        | 121/1000 [20:33<2:29:19, 10.19s/it][Succeeded / Failed / Skipped / Total] 45 / 76 / 0 / 121:  12%|█▏        | 121/1000 [20:33<2:29:19, 10.19s/it][Succeeded / Failed / Skipped / Total] 45 / 76 / 0 / 121:  12%|█▏        | 122/1000 [20:34<2:28:06, 10.12s/it][Succeeded / Failed / Skipped / Total] 45 / 77 / 0 / 122:  12%|█▏        | 122/1000 [20:34<2:28:06, 10.12s/it][Succeeded / Failed / Skipped / Total] 45 / 77 / 0 / 122:  12%|█▏        | 123/1000 [20:53<2:28:59, 10.19s/it]Sets the context environment properties . --> Guildenster n die Amaretto --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[guildenstern]] ( Map < String , Object > [[amaretto]] ) { Assert . notEmpty ( [[amaretto]] , "environment must not be empty" ) ; this . [[beechwood]] = new Hashtable <> ( [[amaretto]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 119 ---------------------------------------------
Gets the query string from the request . --> [[[FAILED]]]

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 120 ---------------------------------------------
Invalidate the session and clear the context . --> [[[FAILED]]]

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 121 ---------------------------------------------
Gets the principal from the SecurityContext . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[inconvenience]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 122 ---------------------------------------------
Gets the UserDetailsService . --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[zamboni]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 123 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 45 / 78 / 0 / 123:  12%|█▏        | 123/1000 [20:53<2:28:59, 10.19s/it][Succeeded / Failed / Skipped / Total] 45 / 78 / 0 / 123:  12%|█▏        | 124/1000 [21:12<2:29:50, 10.26s/it][Succeeded / Failed / Skipped / Total] 46 / 78 / 0 / 124:  12%|█▏        | 124/1000 [21:12<2:29:50, 10.26s/it][Succeeded / Failed / Skipped / Total] 46 / 78 / 0 / 124:  12%|█▎        | 125/1000 [21:14<2:28:38, 10.19s/it][Succeeded / Failed / Skipped / Total] 47 / 78 / 0 / 125:  12%|█▎        | 125/1000 [21:14<2:28:38, 10.19s/it][Succeeded / Failed / Skipped / Total] 47 / 78 / 0 / 125:  13%|█▎        | 126/1000 [21:22<2:28:19, 10.18s/it][Succeeded / Failed / Skipped / Total] 48 / 78 / 0 / 126:  13%|█▎        | 126/1000 [21:22<2:28:19, 10.18s/it][Succeeded / Failed / Skipped / Total] 48 / 78 / 0 / 126:  13%|█▎        | 127/1000 [21:31<2:27:56, 10.17s/it][Succeeded / Failed / Skipped / Total] 49 / 78 / 0 / 127:  13%|█▎        | 127/1000 [21:31<2:27:56, 10.17s/it][Succeeded / Failed / Skipped / Total] 49 / 78 / 0 / 127:  13%|█▎        | 128/1000 [21:34<2:27:01, 10.12s/it][Succeeded / Failed / Skipped / Total] 49 / 79 / 0 / 128:  13%|█▎        | 128/1000 [21:34<2:27:01, 10.12s/it][Succeeded / Failed / Skipped / Total] 49 / 79 / 0 / 128:  13%|█▎        | 129/1000 [21:37<2:25:58, 10.06s/it]Build the provider URL . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[salcedo]] ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 124 ---------------------------------------------
Check if the request is a proxy ticket request . --> Rivière rivière --> Socre: 1.0

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean [[serviceTicketRequest]] , final HttpServletRequest request ) { if ( [[serviceTicketRequest]] ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean [[rivière]] , final HttpServletRequest request ) { if ( [[rivière]] ) { return "False" != "False" ; } final boolean [[goofy]] = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[goofy]] ) ; } return [[goofy]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 125 ---------------------------------------------
Creates a method security expression root . --> Factory method to create a MethodSecurityExpressionRoot --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication [[authentication]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[authentication]] ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication [[wetsuit]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[wetsuit]] ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 126 ---------------------------------------------
Adds the PKCE parameters . --> Method to generate code verifier --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > [[additionalParameters]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[lawsuit]] ( Map < String , Object > attributes , Map < String , Object > [[inveterate]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[inveterate]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[inveterate]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[inveterate]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 127 ---------------------------------------------
Service ticket request . --> на на на на на --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[на]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 128 ---------------------------------------------
Initializes the user details service . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[hannukah]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
[Succeeded / Failed / Skipped / Total] 49 / 80 / 0 / 129:  13%|█▎        | 129/1000 [21:37<2:25:58, 10.06s/it][Succeeded / Failed / Skipped / Total] 49 / 80 / 0 / 129:  13%|█▎        | 130/1000 [21:48<2:25:54, 10.06s/it][Succeeded / Failed / Skipped / Total] 50 / 80 / 0 / 130:  13%|█▎        | 130/1000 [21:48<2:25:54, 10.06s/it][Succeeded / Failed / Skipped / Total] 50 / 80 / 0 / 130:  13%|█▎        | 131/1000 [22:01<2:26:07, 10.09s/it][Succeeded / Failed / Skipped / Total] 51 / 80 / 0 / 131:  13%|█▎        | 131/1000 [22:01<2:26:07, 10.09s/it][Succeeded / Failed / Skipped / Total] 51 / 80 / 0 / 131:  13%|█▎        | 132/1000 [22:23<2:27:12, 10.18s/it][Succeeded / Failed / Skipped / Total] 51 / 81 / 0 / 132:  13%|█▎        | 132/1000 [22:23<2:27:12, 10.18s/it][Succeeded / Failed / Skipped / Total] 51 / 81 / 0 / 132:  13%|█▎        | 133/1000 [22:44<2:28:17, 10.26s/it][Succeeded / Failed / Skipped / Total] 52 / 81 / 0 / 133:  13%|█▎        | 133/1000 [22:44<2:28:17, 10.26s/it][Succeeded / Failed / Skipped / Total] 52 / 81 / 0 / 133:  13%|█▎        | 134/1000 [22:55<2:28:11, 10.27s/it][Succeeded / Failed / Skipped / Total] 53 / 81 / 0 / 134:  13%|█▎        | 134/1000 [22:55<2:28:11, 10.27s/it][Succeeded / Failed / Skipped / Total] 53 / 81 / 0 / 134:  14%|█▎        | 135/1000 [23:03<2:27:44, 10.25s/it][Succeeded / Failed / Skipped / Total] 53 / 82 / 0 / 135:  14%|█▎        | 135/1000 [23:03<2:27:44, 10.25s/it][Succeeded / Failed / Skipped / Total] 53 / 82 / 0 / 135:  14%|█▎        | 136/1000 [23:05<2:26:38, 10.18s/it]--------------------------------------------- Result 129 ---------------------------------------------
Returns true if the current user is authenticated . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[koska]] ( ) { Authentication [[purée]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[purée]] != null && [[purée]] . isAuthenticated ( ) && ! ( [[purée]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 130 ---------------------------------------------
URL - encode a string using UTF - 8 encoding . --> Returns the beard of the given value . --> Socre: 1.0

[[[[Adv]]]]: private String [[utf8UrlEncode]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error [[err]] = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; [[err]] . initCause ( e ) ; throw [[err]] ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String [[beard]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error [[cameroon]] = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; [[cameroon]] . initCause ( e ) ; throw [[cameroon]] ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 131 ---------------------------------------------
Checks if the request is a proxy receptor request . --> rivière rivière --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[rivière]] ( final HttpServletRequest [[seneca]] ) { final boolean [[noc]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[seneca]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[noc]] ) ; } return [[noc]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 132 ---------------------------------------------
Check if authentication is required . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 133 ---------------------------------------------
Gets the list of grants for the given attributes . --> Methode permettantes siufflés --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String [[attribute]] : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( [[attribute]] ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[soufflés]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String [[naniwa]] : [[soufflés]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( [[naniwa]] ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 134 ---------------------------------------------
Gets the collection of grants for the given value . --> Methode melanie zurueck . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , value ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > [[melanie]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[melanie]] , value ) ; return [[melanie]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 135 ---------------------------------------------
Gets the pre - authenticated principal . --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[anointed]] ( HttpServletRequest [[digital]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 136 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 54 / 82 / 0 / 136:  14%|█▎        | 136/1000 [23:05<2:26:38, 10.18s/it][Succeeded / Failed / Skipped / Total] 54 / 82 / 0 / 136:  14%|█▎        | 137/1000 [23:07<2:25:41, 10.13s/it][Succeeded / Failed / Skipped / Total] 54 / 83 / 0 / 137:  14%|█▎        | 137/1000 [23:07<2:25:41, 10.13s/it][Succeeded / Failed / Skipped / Total] 54 / 83 / 0 / 137:  14%|█▍        | 138/1000 [23:10<2:24:47, 10.08s/it][Succeeded / Failed / Skipped / Total] 54 / 84 / 0 / 138:  14%|█▍        | 138/1000 [23:10<2:24:47, 10.08s/it][Succeeded / Failed / Skipped / Total] 54 / 84 / 0 / 138:  14%|█▍        | 139/1000 [23:13<2:23:50, 10.02s/it][Succeeded / Failed / Skipped / Total] 54 / 85 / 0 / 139:  14%|█▍        | 139/1000 [23:13<2:23:50, 10.02s/it][Succeeded / Failed / Skipped / Total] 54 / 85 / 0 / 139:  14%|█▍        | 140/1000 [23:24<2:23:49, 10.03s/it][Succeeded / Failed / Skipped / Total] 55 / 85 / 0 / 140:  14%|█▍        | 140/1000 [23:24<2:23:49, 10.03s/it][Succeeded / Failed / Skipped / Total] 55 / 85 / 0 / 140:  14%|█▍        | 141/1000 [23:54<2:25:41, 10.18s/it][Succeeded / Failed / Skipped / Total] 56 / 85 / 0 / 141:  14%|█▍        | 141/1000 [23:54<2:25:41, 10.18s/it][Succeeded / Failed / Skipped / Total] 56 / 85 / 0 / 141:  14%|█▍        | 142/1000 [23:58<2:24:50, 10.13s/it]Pre - processes the attributes2grantedAuthoritiesMap . --> Kanazawa zurueck . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[preProcessMap]] ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[result]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[result]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[kanazawa]] ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[huit]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[huit]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[huit]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 137 ---------------------------------------------
Load user details by assertion . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[balsam]] ( final Assertion [[antoinette]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[antoinette]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 138 ---------------------------------------------
Get the webSphere groups based Granted Authorities for the current user . --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[cachaça]] ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[convert]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + [[convert]] ) ; } return [[convert]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 139 ---------------------------------------------
Gets the JWKSet . --> [[[FAILED]]]

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[died]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 140 ---------------------------------------------
Concatenates the given arrays . --> zahara a steamroller --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... [[arrays]] ) { int length = 0 ; for ( byte [ ] array : [[arrays]] ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : [[arrays]] ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[zahara]] ( byte [ ] ... [[steamroller]] ) { int length = 0 ; for ( byte [ ] array : [[steamroller]] ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : [[steamroller]] ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 141 ---------------------------------------------
Returns the shared object for the given type . --> Get the right hand hand hand hand hand hand hand hand hand hand --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[juices]] > [[juices]] getSharedObject ( Class < [[juices]] > sharedType ) { return ( [[juices]] ) this . [[wrongdoings]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 142 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 85 / 0 / 142:  14%|█▍        | 142/1000 [23:58<2:24:50, 10.13s/it][Succeeded / Failed / Skipped / Total] 57 / 85 / 0 / 142:  14%|█▍        | 143/1000 [24:19<2:25:46, 10.21s/it][Succeeded / Failed / Skipped / Total] 58 / 85 / 0 / 143:  14%|█▍        | 143/1000 [24:19<2:25:46, 10.21s/it][Succeeded / Failed / Skipped / Total] 58 / 85 / 0 / 143:  14%|█▍        | 144/1000 [24:28<2:25:31, 10.20s/it][Succeeded / Failed / Skipped / Total] 58 / 86 / 0 / 144:  14%|█▍        | 144/1000 [24:28<2:25:31, 10.20s/it][Succeeded / Failed / Skipped / Total] 58 / 86 / 0 / 144:  14%|█▍        | 145/1000 [24:30<2:24:33, 10.14s/it][Succeeded / Failed / Skipped / Total] 59 / 86 / 0 / 145:  14%|█▍        | 145/1000 [24:30<2:24:33, 10.14s/it][Succeeded / Failed / Skipped / Total] 59 / 86 / 0 / 145:  15%|█▍        | 146/1000 [24:50<2:25:18, 10.21s/it][Succeeded / Failed / Skipped / Total] 59 / 87 / 0 / 146:  15%|█▍        | 146/1000 [24:50<2:25:18, 10.21s/it][Succeeded / Failed / Skipped / Total] 59 / 87 / 0 / 146:  15%|█▍        | 147/1000 [24:58<2:24:54, 10.19s/it][Succeeded / Failed / Skipped / Total] 59 / 88 / 0 / 147:  15%|█▍        | 147/1000 [24:58<2:24:54, 10.19s/it][Succeeded / Failed / Skipped / Total] 59 / 88 / 0 / 147:  15%|█▍        | 148/1000 [25:13<2:25:13, 10.23s/it]Process the auto login cookie . --> zoë zoë --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[zoë]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 143 ---------------------------------------------
Returns the role name for the given role . --> Jewelz на на --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[jewelz]] ( String [[на]] ) { Assert . isTrue ( ! [[на]] . startsWith ( "ROLE_" ) , ( ) -> [[на]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[на]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 144 ---------------------------------------------
Creates a sub - array of the given array . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int [[length]] = endIndex - beginIndex ; byte [ ] [[subarray]] = new byte [ [[length]] ] ; System . arraycopy ( array , beginIndex , [[subarray]] , 0 , [[length]] ) ; return [[subarray]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int [[jeanie]] = endIndex - beginIndex ; byte [ ] [[lale]] = new byte [ [[jeanie]] ] ; System . arraycopy ( array , beginIndex , [[lale]] , 0 , [[jeanie]] ) ; return [[lale]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 145 ---------------------------------------------
Invoke the interceptor . --> Baaing a policing --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint [[jp]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object [[result]] ; try { [[result]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[result]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[baaing]] ( JoinPoint [[policing]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[policing]] ) ) ; Object [[communiqué]] ; try { [[communiqué]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[communiqué]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 146 ---------------------------------------------
Adds the given value to the given collection of grants . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[fractional]] ( Collection < GrantedAuthority > [[aberrations]] , Object [[flung]] ) { if ( [[flung]] == null ) { return ; } if ( [[flung]] instanceof Collection < ? > ) { [[fractional]] ( [[aberrations]] , ( Collection < ? > ) [[flung]] ) ; } else if ( [[flung]] instanceof Object [ ] ) { [[fractional]] ( [[aberrations]] , ( Object [ ] ) [[flung]] ) ; } else if ( [[flung]] instanceof String ) { [[fractional]] ( [[aberrations]] , ( String ) [[flung]] ) ; } else if ( [[flung]] instanceof GrantedAuthority ) { [[aberrations]] . add ( ( GrantedAuthority ) [[flung]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[flung]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 147 ---------------------------------------------
Gets the pre - authenticated J2EE principal . --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object [[principal]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[died]] ( HttpServletRequest httpRequest ) { Object [[eliminating]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[eliminating]] ) ; } return [[eliminating]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 148 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 59 / 89 / 0 / 148:  15%|█▍        | 148/1000 [25:13<2:25:13, 10.23s/it][Succeeded / Failed / Skipped / Total] 59 / 89 / 0 / 148:  15%|█▍        | 149/1000 [25:16<2:24:19, 10.18s/it][Succeeded / Failed / Skipped / Total] 60 / 89 / 0 / 149:  15%|█▍        | 149/1000 [25:16<2:24:19, 10.18s/it][Succeeded / Failed / Skipped / Total] 60 / 89 / 0 / 149:  15%|█▌        | 150/1000 [25:19<2:23:31, 10.13s/it][Succeeded / Failed / Skipped / Total] 60 / 90 / 0 / 150:  15%|█▌        | 150/1000 [25:19<2:23:31, 10.13s/it][Succeeded / Failed / Skipped / Total] 60 / 90 / 0 / 150:  15%|█▌        | 151/1000 [25:19<2:22:25, 10.07s/it][Succeeded / Failed / Skipped / Total] 61 / 90 / 0 / 151:  15%|█▌        | 151/1000 [25:19<2:22:25, 10.07s/it][Succeeded / Failed / Skipped / Total] 61 / 90 / 0 / 151:  15%|█▌        | 152/1000 [25:20<2:21:20, 10.00s/it][Succeeded / Failed / Skipped / Total] 61 / 90 / 1 / 152:  15%|█▌        | 152/1000 [25:20<2:21:20, 10.00s/it][Succeeded / Failed / Skipped / Total] 61 / 90 / 1 / 152:  15%|█▌        | 153/1000 [25:26<2:20:49,  9.98s/it][Succeeded / Failed / Skipped / Total] 62 / 90 / 1 / 153:  15%|█▌        | 153/1000 [25:26<2:20:49,  9.98s/it][Succeeded / Failed / Skipped / Total] 62 / 90 / 1 / 153:  15%|█▌        | 154/1000 [25:39<2:20:59, 10.00s/it][Succeeded / Failed / Skipped / Total] 62 / 91 / 1 / 154:  15%|█▌        | 154/1000 [25:39<2:20:59, 10.00s/it][Succeeded / Failed / Skipped / Total] 62 / 91 / 1 / 154:  16%|█▌        | 155/1000 [25:49<2:20:48, 10.00s/it][Succeeded / Failed / Skipped / Total] 63 / 91 / 1 / 155:  16%|█▌        | 155/1000 [25:49<2:20:48, 10.00s/it][Succeeded / Failed / Skipped / Total] 63 / 91 / 1 / 155:  16%|█▌        | 156/1000 [25:50<2:19:46,  9.94s/it]Build a https redirect url for the given request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 149 ---------------------------------------------
Decodes a JWT . --> Decodes a shochu token . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT [[jwt]] = parse ( token ) ; if ( [[jwt]] instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , [[jwt]] ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + [[jwt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT [[shochu]] = parse ( token ) ; if ( [[shochu]] instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , [[shochu]] ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + [[shochu]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 150 ---------------------------------------------
Returns an array of roles that have any of the given roles . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int [[i]] = 0 ; [[i]] < [[roles]] . length ; [[i]] ++ ) { [[roles]] [ [[i]] ] = "ROLE_" + [[roles]] [ [[i]] ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[sniffin]] ( String ... [[bungle]] ) { for ( int [[bonneville]] = 0 ; [[bonneville]] < [[bungle]] . length ; [[bonneville]] ++ ) { [[bungle]] [ [[bonneville]] ] = "ROLE_" + [[bungle]] [ [[bonneville]] ] ; } return [[bungle]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 151 ---------------------------------------------
Display the public index of the user --> Methode asmar --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact [[rnd]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[rnd]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[asmar]] ( ) { Contact [[erzurum]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[erzurum]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 152 ---------------------------------------------
Convert a JWT to a collection of GrantedAuthorities . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 153 ---------------------------------------------
Generates a new CSRF token . --> Dinosaur der Dinosaur . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[dinosaur]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 154 ---------------------------------------------
Attempt to exit a user . --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[sympathizer]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 155 ---------------------------------------------
Sets the exit user URL . --> DIOXIN - DIOXIN - DIOXIN - DIOXIN --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[dioxin]] ( String [[simmer]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[simmer]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[alves]] = createMatcher ( [[simmer]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 156 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 64 / 91 / 1 / 156:  16%|█▌        | 156/1000 [25:50<2:19:46,  9.94s/it][Succeeded / Failed / Skipped / Total] 64 / 91 / 1 / 156:  16%|█▌        | 157/1000 [25:59<2:19:31,  9.93s/it][Succeeded / Failed / Skipped / Total] 64 / 92 / 1 / 157:  16%|█▌        | 157/1000 [25:59<2:19:31,  9.93s/it][Succeeded / Failed / Skipped / Total] 64 / 92 / 1 / 157:  16%|█▌        | 158/1000 [26:22<2:20:33, 10.02s/it][Succeeded / Failed / Skipped / Total] 64 / 93 / 1 / 158:  16%|█▌        | 158/1000 [26:22<2:20:33, 10.02s/it][Succeeded / Failed / Skipped / Total] 64 / 93 / 1 / 158:  16%|█▌        | 159/1000 [26:26<2:19:53,  9.98s/it][Succeeded / Failed / Skipped / Total] 65 / 93 / 1 / 159:  16%|█▌        | 159/1000 [26:26<2:19:53,  9.98s/it][Succeeded / Failed / Skipped / Total] 65 / 93 / 1 / 159:  16%|█▌        | 160/1000 [26:29<2:19:05,  9.94s/it][Succeeded / Failed / Skipped / Total] 66 / 93 / 1 / 160:  16%|█▌        | 160/1000 [26:29<2:19:05,  9.94s/it][Succeeded / Failed / Skipped / Total] 66 / 93 / 1 / 160:  16%|█▌        | 161/1000 [26:33<2:18:23,  9.90s/it][Succeeded / Failed / Skipped / Total] 67 / 93 / 1 / 161:  16%|█▌        | 161/1000 [26:33<2:18:23,  9.90s/it][Succeeded / Failed / Skipped / Total] 67 / 93 / 1 / 161:  16%|█▌        | 162/1000 [26:48<2:18:41,  9.93s/it]Display admin page --> Schoolmistress view --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[schoolmistress]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 157 ---------------------------------------------
Create a persistent login for the user . --> [[[FAILED]]]

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 158 ---------------------------------------------
Attempt to switch to a user . --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 159 ---------------------------------------------
Spring security filter chain . --> Entendre entendre . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[entendre]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 160 ---------------------------------------------
Authorize using url check . --> Methode d ajout une fiancée --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[amoy]] ( ) throws IOException { String [[fiancée]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[fiancée]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 161 ---------------------------------------------
Gets the first attribute value . --> Aleksander die Aleksander . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[aleksander]] ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 162 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 68 / 93 / 1 / 162:  16%|█▌        | 162/1000 [26:48<2:18:41,  9.93s/it][Succeeded / Failed / Skipped / Total] 68 / 93 / 1 / 162:  16%|█▋        | 163/1000 [27:20<2:20:22, 10.06s/it][Succeeded / Failed / Skipped / Total] 68 / 94 / 1 / 163:  16%|█▋        | 163/1000 [27:20<2:20:22, 10.06s/it][Succeeded / Failed / Skipped / Total] 68 / 94 / 1 / 163:  16%|█▋        | 164/1000 [27:23<2:19:40, 10.02s/it][Succeeded / Failed / Skipped / Total] 68 / 95 / 1 / 164:  16%|█▋        | 164/1000 [27:23<2:19:40, 10.02s/it][Succeeded / Failed / Skipped / Total] 68 / 95 / 1 / 164:  16%|█▋        | 165/1000 [27:29<2:19:05,  9.99s/it][Succeeded / Failed / Skipped / Total] 68 / 96 / 1 / 165:  16%|█▋        | 165/1000 [27:29<2:19:05,  9.99s/it][Succeeded / Failed / Skipped / Total] 68 / 96 / 1 / 165:  17%|█▋        | 166/1000 [27:36<2:18:43,  9.98s/it]Returns the role with the default prefix if the prefix is null or empty . --> Liefert die Aahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahhehehehehehehehehehehehehehehahahahahahahahahahahahahah --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String role ) { if ( role == null ) { return role ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[defaultRolePrefix]] ) ) { return role ; } return [[defaultRolePrefix]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[lindbergh]] ( String [[aahh]] , String role ) { if ( role == null ) { return role ; } if ( [[aahh]] == null || [[aahh]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[aahh]] ) ) { return role ; } return [[aahh]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 163 ---------------------------------------------
Delete a permission . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 164 ---------------------------------------------
Display the add permission page for a contact --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 165 ---------------------------------------------
Returns true if the access expression is evaluated as a boolean . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 166 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 68 / 97 / 1 / 166:  17%|█▋        | 166/1000 [27:36<2:18:43,  9.98s/it][Succeeded / Failed / Skipped / Total] 68 / 97 / 1 / 166:  17%|█▋        | 167/1000 [27:50<2:18:53, 10.00s/it][Succeeded / Failed / Skipped / Total] 69 / 97 / 1 / 167:  17%|█▋        | 167/1000 [27:50<2:18:53, 10.00s/it][Succeeded / Failed / Skipped / Total] 69 / 97 / 1 / 167:  17%|█▋        | 168/1000 [27:51<2:17:56,  9.95s/it][Succeeded / Failed / Skipped / Total] 70 / 97 / 1 / 168:  17%|█▋        | 168/1000 [27:51<2:17:56,  9.95s/it][Succeeded / Failed / Skipped / Total] 70 / 97 / 1 / 168:  17%|█▋        | 169/1000 [27:51<2:16:59,  9.89s/it][Succeeded / Failed / Skipped / Total] 70 / 98 / 1 / 169:  17%|█▋        | 169/1000 [27:51<2:16:59,  9.89s/it][Succeeded / Failed / Skipped / Total] 70 / 98 / 1 / 169:  17%|█▋        | 170/1000 [28:16<2:18:02,  9.98s/it][Succeeded / Failed / Skipped / Total] 71 / 98 / 1 / 170:  17%|█▋        | 170/1000 [28:16<2:18:02,  9.98s/it][Succeeded / Failed / Skipped / Total] 71 / 98 / 1 / 170:  17%|█▋        | 171/1000 [28:22<2:17:32,  9.95s/it][Succeeded / Failed / Skipped / Total] 72 / 98 / 1 / 171:  17%|█▋        | 171/1000 [28:22<2:17:32,  9.95s/it][Succeeded / Failed / Skipped / Total] 72 / 98 / 1 / 171:  17%|█▋        | 172/1000 [28:39<2:17:58, 10.00s/it]Add a permission to a contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 167 ---------------------------------------------
Creates a user details resource factory bean from a string . --> Factory method to get banalities --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String [[users]] ) { InMemoryResource [[resource]] = new InMemoryResource ( [[users]] ) ; return fromResource ( [[resource]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[banalities]] ( String [[adulteress]] ) { InMemoryResource [[huit]] = new InMemoryResource ( [[adulteress]] ) ; return fromResource ( [[huit]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 168 ---------------------------------------------
Returns the values of an attribute . --> Ganymede disappeared . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[ganymede]] ( String [[goldfish]] ) { List < String > [[disappeared]] = null ; if ( attributes != null ) { [[disappeared]] = attributes . get ( [[goldfish]] ) ; } if ( [[disappeared]] == null ) { [[disappeared]] = Collections . emptyList ( ) ; } return [[disappeared]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 169 ---------------------------------------------
Decodes a byte array into a string . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[cabeça]] ( byte [ ] [[bollocks]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bollocks]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 170 ---------------------------------------------
Find the attributes that are specified for the given method . --> Liefert die WARHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHA --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[coupla]] ( Method method , Class < ? > [[warhammer]] ) { if ( [[warhammer]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[warhammer]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 171 ---------------------------------------------
Add a new contact . --> Add amputate to bloodletting --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact [[form]] , BindingResult [[result]] ) { validator . validate ( [[form]] , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact [[amputate]] , BindingResult [[inhale]] ) { validator . validate ( [[amputate]] , [[inhale]] ) ; if ( [[inhale]] . hasErrors ( ) ) { return "add" ; } Contact [[bloodletting]] = new Contact ( [[amputate]] . getName ( ) , [[amputate]] . getEmail ( ) ) ; contactManager . create ( [[bloodletting]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 172 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 72 / 99 / 1 / 172:  17%|█▋        | 172/1000 [28:39<2:17:58, 10.00s/it][Succeeded / Failed / Skipped / Total] 72 / 99 / 1 / 172:  17%|█▋        | 173/1000 [29:11<2:19:31, 10.12s/it][Succeeded / Failed / Skipped / Total] 73 / 99 / 1 / 173:  17%|█▋        | 173/1000 [29:11<2:19:31, 10.12s/it][Succeeded / Failed / Skipped / Total] 73 / 99 / 1 / 173:  17%|█▋        | 174/1000 [29:20<2:19:19, 10.12s/it][Succeeded / Failed / Skipped / Total] 73 / 100 / 1 / 174:  17%|█▋        | 174/1000 [29:20<2:19:19, 10.12s/it][Succeeded / Failed / Skipped / Total] 73 / 100 / 1 / 174:  18%|█▊        | 175/1000 [29:21<2:18:26, 10.07s/it][Succeeded / Failed / Skipped / Total] 74 / 100 / 1 / 175:  18%|█▊        | 175/1000 [29:21<2:18:26, 10.07s/it][Succeeded / Failed / Skipped / Total] 74 / 100 / 1 / 175:  18%|█▊        | 176/1000 [29:33<2:18:25, 10.08s/it][Succeeded / Failed / Skipped / Total] 75 / 100 / 1 / 176:  18%|█▊        | 176/1000 [29:33<2:18:25, 10.08s/it][Succeeded / Failed / Skipped / Total] 75 / 100 / 1 / 176:  18%|█▊        | 177/1000 [29:49<2:18:38, 10.11s/it][Succeeded / Failed / Skipped / Total] 75 / 101 / 1 / 177:  18%|█▊        | 177/1000 [29:49<2:18:38, 10.11s/it][Succeeded / Failed / Skipped / Total] 75 / 101 / 1 / 177:  18%|█▊        | 178/1000 [29:56<2:18:15, 10.09s/it][Succeeded / Failed / Skipped / Total] 75 / 102 / 1 / 178:  18%|█▊        | 178/1000 [29:56<2:18:15, 10.09s/it][Succeeded / Failed / Skipped / Total] 75 / 102 / 1 / 178:  18%|█▊        | 179/1000 [29:59<2:17:33, 10.05s/it]Encodes a CharSequence to a byte array . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence string ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[harmonic]] ( CharSequence string ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 173 ---------------------------------------------
Returns true if the method name matches the mapped method name . --> Cambodia yapping --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String methodName , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && methodName . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && methodName . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[cambodia]] ( String methodName , String [[yapping]] ) { return ( [[yapping]] . endsWith ( "*" ) && methodName . startsWith ( [[yapping]] . substring ( 0 , [[yapping]] . length ( ) - 1 ) ) ) || ( [[yapping]] . startsWith ( "*" ) && methodName . endsWith ( [[yapping]] . substring ( 1 , [[yapping]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 174 ---------------------------------------------
Lookup parameter names . --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 175 ---------------------------------------------
Adds a secure method . --> wheeze wheeze --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod method , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( method , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[wheeze]] ( RegisteredMethod method , List < ConfigAttribute > [[toying]] ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( [[toying]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + [[toying]] + "]" ) ; } this . [[huit]] . put ( method , [[toying]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 176 ---------------------------------------------
Clear authentication attributes . --> Testament testament --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[testament]] ( HttpServletRequest [[jesuit]] ) { HttpSession session = [[jesuit]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 177 ---------------------------------------------
Returns a collection of all config attributes . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { [[allAttributes]] . addAll ( [[attributeList]] ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[zizi]] ( ) { Set < ConfigAttribute > [[lubbock]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[faulted]] : methodMap . values ( ) ) { [[lubbock]] . addAll ( [[faulted]] ) ; } return [[lubbock]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 178 ---------------------------------------------
Returns a random contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 179 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 103 / 1 / 179:  18%|█▊        | 179/1000 [29:59<2:17:33, 10.05s/it][Succeeded / Failed / Skipped / Total] 75 / 103 / 1 / 179:  18%|█▊        | 180/1000 [30:01<2:16:46, 10.01s/it][Succeeded / Failed / Skipped / Total] 76 / 103 / 1 / 180:  18%|█▊        | 180/1000 [30:01<2:16:46, 10.01s/it][Succeeded / Failed / Skipped / Total] 76 / 103 / 1 / 180:  18%|█▊        | 181/1000 [30:19<2:17:13, 10.05s/it][Succeeded / Failed / Skipped / Total] 76 / 104 / 1 / 181:  18%|█▊        | 181/1000 [30:19<2:17:13, 10.05s/it][Succeeded / Failed / Skipped / Total] 76 / 104 / 1 / 181:  18%|█▊        | 182/1000 [30:34<2:17:24, 10.08s/it][Succeeded / Failed / Skipped / Total] 77 / 104 / 1 / 182:  18%|█▊        | 182/1000 [30:34<2:17:24, 10.08s/it][Succeeded / Failed / Skipped / Total] 77 / 104 / 1 / 182:  18%|█▊        | 183/1000 [30:36<2:16:39, 10.04s/it][Succeeded / Failed / Skipped / Total] 78 / 104 / 1 / 183:  18%|█▊        | 183/1000 [30:36<2:16:39, 10.04s/it][Succeeded / Failed / Skipped / Total] 78 / 104 / 1 / 183:  18%|█▊        | 184/1000 [30:40<2:16:00, 10.00s/it][Succeeded / Failed / Skipped / Total] 79 / 104 / 1 / 184:  18%|█▊        | 184/1000 [30:40<2:16:00, 10.00s/it][Succeeded / Failed / Skipped / Total] 79 / 104 / 1 / 184:  18%|█▊        | 185/1000 [30:44<2:15:26,  9.97s/it][Succeeded / Failed / Skipped / Total] 80 / 104 / 1 / 185:  18%|█▊        | 185/1000 [30:44<2:15:26,  9.97s/it][Succeeded / Failed / Skipped / Total] 80 / 104 / 1 / 185:  19%|█▊        | 186/1000 [30:58<2:15:31,  9.99s/it]Configure any request . --> [[[FAILED]]]

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "True" == "True" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[also]] ( ) { Assert . state ( ! this . [[reopen]] , "Can't configure anyRequest after itself" ) ; C [[nebuchadnezzar]] = requestMatchers ( ANY_REQUEST ) ; this . [[reopen]] = "True" == "True" ; return [[nebuchadnezzar]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 180 ---------------------------------------------
Check for duplicate filters . --> Removes duplicate filters . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[eliminate]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 181 ---------------------------------------------
Handles a bind exception . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[handleBindException]] ( String [[userDn]] , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[userDn]] + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[amplification]] ( String [[geddes]] , String username , Throwable [[taniguchi]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[geddes]] + ": " + [[taniguchi]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 182 ---------------------------------------------
Extracts the cause of a throwable . --> Bioluminescent de bioluminescente --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = [[entry]] . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = [[entry]] . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[bioluminescent]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[détente]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = [[détente]] . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = [[détente]] . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 183 ---------------------------------------------
The pre - authenticated entry point is called . --> Pikachu pikachu --> Socre: 1.0

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest [[request]] , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[pikachu]] ( HttpServletRequest [[bridie]] , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 184 ---------------------------------------------
Checks if two byte arrays are equal . --> Returns true if the expected byte array matches the actual byte array --> Socre: 1.0

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "[[False]]" != "[[False]]" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "[[Concept]]" != "[[Concept]]" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 185 ---------------------------------------------
Gets the registered types . --> cachaça de excepciones --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . extractorMap . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[cachaça]] ( ) { Set < Class < ? extends Throwable > > [[clued]] = this . extractorMap . keySet ( ) ; return [[clued]] . toArray ( new Class [ [[clued]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 186 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 105 / 1 / 186:  19%|█▊        | 186/1000 [30:58<2:15:31,  9.99s/it][Succeeded / Failed / Skipped / Total] 80 / 105 / 1 / 186:  19%|█▊        | 187/1000 [30:58<2:14:39,  9.94s/it][Succeeded / Failed / Skipped / Total] 80 / 106 / 1 / 187:  19%|█▊        | 187/1000 [30:58<2:14:39,  9.94s/it][Succeeded / Failed / Skipped / Total] 80 / 106 / 1 / 187:  19%|█▉        | 188/1000 [30:59<2:13:51,  9.89s/it][Succeeded / Failed / Skipped / Total] 80 / 107 / 1 / 188:  19%|█▉        | 188/1000 [30:59<2:13:51,  9.89s/it][Succeeded / Failed / Skipped / Total] 80 / 107 / 1 / 188:  19%|█▉        | 189/1000 [31:06<2:13:31,  9.88s/it][Succeeded / Failed / Skipped / Total] 80 / 108 / 1 / 189:  19%|█▉        | 189/1000 [31:06<2:13:31,  9.88s/it][Succeeded / Failed / Skipped / Total] 80 / 108 / 1 / 189:  19%|█▉        | 190/1000 [31:18<2:13:28,  9.89s/it][Succeeded / Failed / Skipped / Total] 81 / 108 / 1 / 190:  19%|█▉        | 190/1000 [31:18<2:13:28,  9.89s/it][Succeeded / Failed / Skipped / Total] 81 / 108 / 1 / 190:  19%|█▉        | 191/1000 [31:44<2:14:26,  9.97s/it][Succeeded / Failed / Skipped / Total] 82 / 108 / 1 / 191:  19%|█▉        | 191/1000 [31:44<2:14:26,  9.97s/it][Succeeded / Failed / Skipped / Total] 82 / 108 / 1 / 191:  19%|█▉        | 192/1000 [31:58<2:14:35,  9.99s/it]Create redirect url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 187 ---------------------------------------------
Gets a field from a class . --> [[[FAILED]]]

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[riviera]] ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 188 ---------------------------------------------
Create service url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 189 ---------------------------------------------
Extract the SHA prefix from a string . --> [[[FAILED]]]

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[lamé]] ( String [[tea]] ) { if ( ! [[tea]] . startsWith ( "{" ) ) { return null ; } int [[unrelated]] = [[tea]] . lastIndexOf ( ' ' ) ; if ( [[unrelated]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[tea]] . substring ( 0 , [[unrelated]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 190 ---------------------------------------------
Convert a string identifier to a class identifier . --> Convert a Schoolyard identifier to a Schoolyard identifier --> Socre: 1.0

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[identifier]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[schoolyard]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[schoolyard]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[schoolyard]] = convertFromStringTo ( ( String ) [[schoolyard]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 191 ---------------------------------------------
Build the request URL . --> Maréchal darwinism --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String servletPath , String [[requestURI]] , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( [[requestURI]] . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[darwinism]] ( String servletPath , String [[maréchal]] , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( [[maréchal]] . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 192 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 82 / 109 / 1 / 192:  19%|█▉        | 192/1000 [31:58<2:14:35,  9.99s/it][Succeeded / Failed / Skipped / Total] 82 / 109 / 1 / 192:  19%|█▉        | 193/1000 [32:16<2:14:55, 10.03s/it][Succeeded / Failed / Skipped / Total] 82 / 110 / 1 / 193:  19%|█▉        | 193/1000 [32:16<2:14:55, 10.03s/it][Succeeded / Failed / Skipped / Total] 82 / 110 / 1 / 193:  19%|█▉        | 194/1000 [32:35<2:15:26, 10.08s/it][Succeeded / Failed / Skipped / Total] 82 / 111 / 1 / 194:  19%|█▉        | 194/1000 [32:35<2:15:26, 10.08s/it][Succeeded / Failed / Skipped / Total] 82 / 111 / 1 / 194:  20%|█▉        | 195/1000 [32:40<2:14:51, 10.05s/it][Succeeded / Failed / Skipped / Total] 83 / 111 / 1 / 195:  20%|█▉        | 195/1000 [32:40<2:14:51, 10.05s/it][Succeeded / Failed / Skipped / Total] 83 / 111 / 1 / 195:  20%|█▉        | 196/1000 [32:44<2:14:17, 10.02s/it][Succeeded / Failed / Skipped / Total] 84 / 111 / 1 / 196:  20%|█▉        | 196/1000 [32:44<2:14:17, 10.02s/it][Succeeded / Failed / Skipped / Total] 84 / 111 / 1 / 196:  20%|█▉        | 197/1000 [32:44<2:13:29,  9.97s/it][Succeeded / Failed / Skipped / Total] 84 / 112 / 1 / 197:  20%|█▉        | 197/1000 [32:44<2:13:29,  9.97s/it][Succeeded / Failed / Skipped / Total] 84 / 112 / 1 / 197:  20%|█▉        | 198/1000 [33:07<2:14:11, 10.04s/it]Register an access manager . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 193 ---------------------------------------------
Sets the default failure URL . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[triffid]] ( String [[eenie]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[eenie]] ) , ( ) -> "'" + [[eenie]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[eenie]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 194 ---------------------------------------------
Sets the function to use when resolving hidden inputs . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[incriminating]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . [[stereotypes]] = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 195 ---------------------------------------------
Create or update an object identity . --> Daaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[True]]" == "[[True]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[True]]" == "[[True]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[dna]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[Dizzy]]" == "[[Dizzy]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[Dizzy]]" == "[[Dizzy]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 196 ---------------------------------------------
Matches any exchange . --> Returns a ServerWebExchangeMatcher for affording requests . --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[affording]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 197 ---------------------------------------------
Returns an attribute list for the given identifier . --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String [[identifier]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( [[identifier]] ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[bakho]] ( String [[taniguchi]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( [[taniguchi]] ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 198 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 84 / 113 / 1 / 198:  20%|█▉        | 198/1000 [33:07<2:14:11, 10.04s/it][Succeeded / Failed / Skipped / Total] 84 / 113 / 1 / 198:  20%|█▉        | 199/1000 [33:09<2:13:28, 10.00s/it][Succeeded / Failed / Skipped / Total] 84 / 114 / 1 / 199:  20%|█▉        | 199/1000 [33:09<2:13:28, 10.00s/it][Succeeded / Failed / Skipped / Total] 84 / 114 / 1 / 199:  20%|██        | 200/1000 [33:32<2:14:08, 10.06s/it][Succeeded / Failed / Skipped / Total] 84 / 115 / 1 / 200:  20%|██        | 200/1000 [33:32<2:14:08, 10.06s/it][Succeeded / Failed / Skipped / Total] 84 / 115 / 1 / 200:  20%|██        | 201/1000 [33:33<2:13:25, 10.02s/it][Succeeded / Failed / Skipped / Total] 85 / 115 / 1 / 201:  20%|██        | 201/1000 [33:33<2:13:25, 10.02s/it][Succeeded / Failed / Skipped / Total] 85 / 115 / 1 / 201:  20%|██        | 202/1000 [33:40<2:13:03, 10.00s/it]Creates the entries for the given ACL . --> [[[FAILED]]]

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 199 ---------------------------------------------
Convert a collection of authorities to a set of authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority [[authority]] : userAuthorities ) { [[set]] . add ( [[authority]] . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[gyroscope]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > [[kawashima]] = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority [[wird]] : userAuthorities ) { [[kawashima]] . add ( [[wird]] . getAuthority ( ) ) ; } return [[kawashima]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 200 ---------------------------------------------
Returns true if the given URL is an absolute URL . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[clavo]] ( String [[kaczynski]] ) { if ( [[kaczynski]] == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[kaczynski]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 201 ---------------------------------------------
Write the headers to the response . --> Method to write headers to response --> Socre: 1.0

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( [[request]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest [[breadfruit]] , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( [[breadfruit]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 202 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 85 / 116 / 1 / 202:  20%|██        | 202/1000 [33:40<2:13:03, 10.00s/it][Succeeded / Failed / Skipped / Total] 85 / 116 / 1 / 202:  20%|██        | 203/1000 [34:17<2:14:39, 10.14s/it][Succeeded / Failed / Skipped / Total] 86 / 116 / 1 / 203:  20%|██        | 203/1000 [34:17<2:14:39, 10.14s/it][Succeeded / Failed / Skipped / Total] 86 / 116 / 1 / 203:  20%|██        | 204/1000 [34:29<2:14:35, 10.15s/it][Succeeded / Failed / Skipped / Total] 87 / 116 / 1 / 204:  20%|██        | 204/1000 [34:29<2:14:35, 10.15s/it][Succeeded / Failed / Skipped / Total] 87 / 116 / 1 / 204:  20%|██        | 205/1000 [34:40<2:14:27, 10.15s/it][Succeeded / Failed / Skipped / Total] 87 / 117 / 1 / 205:  20%|██        | 205/1000 [34:40<2:14:27, 10.15s/it][Succeeded / Failed / Skipped / Total] 87 / 117 / 1 / 205:  21%|██        | 206/1000 [34:51<2:14:20, 10.15s/it][Succeeded / Failed / Skipped / Total] 87 / 118 / 1 / 206:  21%|██        | 206/1000 [34:51<2:14:20, 10.15s/it][Succeeded / Failed / Skipped / Total] 87 / 118 / 1 / 206:  21%|██        | 207/1000 [34:54<2:13:43, 10.12s/it][Succeeded / Failed / Skipped / Total] 88 / 118 / 1 / 207:  21%|██        | 207/1000 [34:54<2:13:43, 10.12s/it][Succeeded / Failed / Skipped / Total] 88 / 118 / 1 / 207:  21%|██        | 208/1000 [35:04<2:13:33, 10.12s/it][Succeeded / Failed / Skipped / Total] 88 / 119 / 1 / 208:  21%|██        | 208/1000 [35:04<2:13:33, 10.12s/it][Succeeded / Failed / Skipped / Total] 88 / 119 / 1 / 208:  21%|██        | 209/1000 [35:05<2:12:50, 10.08s/it]Update the ObjectIdentity . --> [[[FAILED]]]

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 203 ---------------------------------------------
Returns a server web exchange matcher for the given path patterns . --> Aleikum aleikum --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[aleikum]] ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > [[breadfruit]] = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { [[breadfruit]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( [[breadfruit]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 204 ---------------------------------------------
Determine the target URL . --> Schreibt die Warhammer . --> Socre: 1.0

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( [[request]] , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest [[warhammer]] , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( [[warhammer]] , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 205 ---------------------------------------------
Save the request . --> [[[FAILED]]]

[[[[Adv]]]]: public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 206 ---------------------------------------------
Creates a text encryptor for the given password and salt . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[shacked]] ( CharSequence [[omer]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[omer]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 207 ---------------------------------------------
Sets the target url parameter . --> Takayuki Takayuki --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . [[targetUrlParameter]] = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[takayuki]] ( String [[astronomical]] ) { if ( [[astronomical]] != null ) { Assert . hasText ( [[astronomical]] , "targetUrlParameter cannot be empty" ) ; } this . [[injector]] = [[astronomical]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 208 ---------------------------------------------
Returns a new HexEncodingTextEncryptor that encrypts the given password using the given salt . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[kamlesh]] ( CharSequence [[zhivago]] , CharSequence [[impresario]] ) { return new HexEncodingTextEncryptor ( stronger ( [[zhivago]] , [[impresario]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 209 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 88 / 120 / 1 / 209:  21%|██        | 209/1000 [35:05<2:12:50, 10.08s/it][Succeeded / Failed / Skipped / Total] 88 / 120 / 1 / 209:  21%|██        | 210/1000 [35:19<2:12:51, 10.09s/it][Succeeded / Failed / Skipped / Total] 88 / 121 / 1 / 210:  21%|██        | 210/1000 [35:19<2:12:51, 10.09s/it][Succeeded / Failed / Skipped / Total] 88 / 121 / 1 / 210:  21%|██        | 211/1000 [35:21<2:12:11, 10.05s/it][Succeeded / Failed / Skipped / Total] 89 / 121 / 1 / 211:  21%|██        | 211/1000 [35:21<2:12:11, 10.05s/it][Succeeded / Failed / Skipped / Total] 89 / 121 / 1 / 211:  21%|██        | 212/1000 [35:25<2:11:38, 10.02s/it][Succeeded / Failed / Skipped / Total] 90 / 121 / 1 / 212:  21%|██        | 212/1000 [35:25<2:11:38, 10.02s/it][Succeeded / Failed / Skipped / Total] 90 / 121 / 1 / 212:  21%|██▏       | 213/1000 [35:47<2:12:13, 10.08s/it][Succeeded / Failed / Skipped / Total] 91 / 121 / 1 / 213:  21%|██▏       | 213/1000 [35:47<2:12:13, 10.08s/it][Succeeded / Failed / Skipped / Total] 91 / 121 / 1 / 213:  21%|██▏       | 214/1000 [35:51<2:11:41, 10.05s/it][Succeeded / Failed / Skipped / Total] 91 / 122 / 1 / 214:  21%|██▏       | 214/1000 [35:51<2:11:41, 10.05s/it][Succeeded / Failed / Skipped / Total] 91 / 122 / 1 / 214:  22%|██▏       | 215/1000 [36:02<2:11:35, 10.06s/it][Succeeded / Failed / Skipped / Total] 91 / 123 / 1 / 215:  22%|██▏       | 215/1000 [36:02<2:11:35, 10.06s/it][Succeeded / Failed / Skipped / Total] 91 / 123 / 1 / 215:  22%|██▏       | 216/1000 [36:07<2:11:07, 10.04s/it]Determine the target url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[hollerin]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 210 ---------------------------------------------
Queryable text encryptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[cachaça]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 211 ---------------------------------------------
Create shared objects . --> Celtic weaving . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[celtic]] ( ) { Map < Class < ? extends Object > , Object > [[weaving]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[weaving]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[weaving]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[weaving]] . put ( ApplicationContext . class , context ) ; [[weaving]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[weaving]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[weaving]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 212 ---------------------------------------------
Build a DistinguishedName for the given username . --> Creates a Mariane DistinguishedName for a moira user --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String username ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , username ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[moira]] ( String username ) { DistinguishedName [[mariane]] = new DistinguishedName ( userDnBase ) ; [[mariane]] . add ( usernameAttribute , username ) ; return [[mariane]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 213 ---------------------------------------------
Update the cache with the given key and value --> Update the bismol with the given key and value --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap [[cache]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap [[bismol]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[bismol]] . size ( ) > 1000 ) { [[bismol]] . clear ( ) ; } [[bismol]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 214 ---------------------------------------------
Returns the current date . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[dereliction]] ( ) { long [[teenie]] = System . currentTimeMillis ( ) ; if ( ( [[teenie]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[teenie]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[teenie]] ; currentDate = format . format ( new Date ( [[teenie]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 215 ---------------------------------------------
Returns the directory with the immediate parent populated . --> [[[FAILED]]]

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long [[id]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[id]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long [[parentDirectoryId]] = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( [[parentDirectoryId]] != null && ! [[parentDirectoryId]] . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long [[breadfruit]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[breadfruit]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long [[begrudge]] = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( [[begrudge]] != null && ! [[begrudge]] . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 216 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 92 / 123 / 1 / 216:  22%|██▏       | 216/1000 [36:07<2:11:07, 10.04s/it][Succeeded / Failed / Skipped / Total] 92 / 123 / 1 / 216:  22%|██▏       | 217/1000 [36:32<2:11:51, 10.10s/it][Succeeded / Failed / Skipped / Total] 93 / 123 / 1 / 217:  22%|██▏       | 217/1000 [36:32<2:11:51, 10.10s/it][Succeeded / Failed / Skipped / Total] 93 / 123 / 1 / 217:  22%|██▏       | 218/1000 [36:51<2:12:14, 10.15s/it][Succeeded / Failed / Skipped / Total] 94 / 123 / 1 / 218:  22%|██▏       | 218/1000 [36:51<2:12:14, 10.15s/it][Succeeded / Failed / Skipped / Total] 94 / 123 / 1 / 218:  22%|██▏       | 219/1000 [37:01<2:12:01, 10.14s/it][Succeeded / Failed / Skipped / Total] 94 / 124 / 1 / 219:  22%|██▏       | 219/1000 [37:01<2:12:01, 10.14s/it][Succeeded / Failed / Skipped / Total] 94 / 124 / 1 / 219:  22%|██▏       | 220/1000 [37:06<2:11:32, 10.12s/it][Succeeded / Failed / Skipped / Total] 95 / 124 / 1 / 220:  22%|██▏       | 220/1000 [37:06<2:11:32, 10.12s/it][Succeeded / Failed / Skipped / Total] 95 / 124 / 1 / 220:  22%|██▏       | 221/1000 [37:21<2:11:39, 10.14s/it][Succeeded / Failed / Skipped / Total] 95 / 125 / 1 / 221:  22%|██▏       | 221/1000 [37:21<2:11:39, 10.14s/it][Succeeded / Failed / Skipped / Total] 95 / 125 / 1 / 221:  22%|██▏       | 222/1000 [37:29<2:11:22, 10.13s/it][Succeeded / Failed / Skipped / Total] 95 / 126 / 1 / 222:  22%|██▏       | 222/1000 [37:29<2:11:22, 10.13s/it][Succeeded / Failed / Skipped / Total] 95 / 126 / 1 / 222:  22%|██▏       | 223/1000 [37:34<2:10:54, 10.11s/it]Sets the authentication details . --> Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôtel den Hôt den den den den den den den den den den den den den Hôtel den Hôtel den Hôtel --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[hôtel]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken [[flagging]] ) { [[flagging]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 217 ---------------------------------------------
Returns a list of webSphere groups . --> Liefert die skagway --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String [[securityName]] ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[skagway]] ( final String [[dizzy]] ) { Context [[fiancés]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 218 ---------------------------------------------
Sets the login . config . url . --> Peckerhead - Peckerhead --> Socre: 1.0

[[[[Adv]]]]: private void [[configureJaasUsingLoop]] ( ) throws IOException { String [[loginConfigUrl]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( [[loginConfigUrl]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + [[loginConfigUrl]] ) ; Security . setProperty ( key , [[loginConfigUrl]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void [[peckerhead]] ( ) throws IOException { String [[breadfruit]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( [[breadfruit]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + [[breadfruit]] ) ; Security . setProperty ( key , [[breadfruit]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 219 ---------------------------------------------
Determines the Websphere security name for the given subject . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[economize]] ( final Subject [[impulse]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[impulse]] ) ; } String [[arena]] = null ; if ( [[impulse]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 220 ---------------------------------------------
Get the list of filters for the given url . --> Aziza a url --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String url ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[aziza]] ( String url ) { return [[aziza]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 221 ---------------------------------------------
Change user s password . --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 222 ---------------------------------------------
Internal parse date . --> [[[FAILED]]]

[[[[Adv]]]]: private static Long internalParseDate ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long internalParseDate ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 223 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 95 / 127 / 1 / 223:  22%|██▏       | 223/1000 [37:34<2:10:54, 10.11s/it][Succeeded / Failed / Skipped / Total] 95 / 127 / 1 / 223:  22%|██▏       | 224/1000 [37:40<2:10:31, 10.09s/it][Succeeded / Failed / Skipped / Total] 96 / 127 / 1 / 224:  22%|██▏       | 224/1000 [37:40<2:10:31, 10.09s/it][Succeeded / Failed / Skipped / Total] 96 / 127 / 1 / 224:  22%|██▎       | 225/1000 [38:06<2:11:15, 10.16s/it][Succeeded / Failed / Skipped / Total] 97 / 127 / 1 / 225:  22%|██▎       | 225/1000 [38:06<2:11:15, 10.16s/it][Succeeded / Failed / Skipped / Total] 97 / 127 / 1 / 225:  23%|██▎       | 226/1000 [38:19<2:11:13, 10.17s/it][Succeeded / Failed / Skipped / Total] 97 / 128 / 1 / 226:  23%|██▎       | 226/1000 [38:19<2:11:13, 10.17s/it][Succeeded / Failed / Skipped / Total] 97 / 128 / 1 / 226:  23%|██▎       | 227/1000 [38:31<2:11:11, 10.18s/it][Succeeded / Failed / Skipped / Total] 97 / 129 / 1 / 227:  23%|██▎       | 227/1000 [38:31<2:11:11, 10.18s/it][Succeeded / Failed / Skipped / Total] 97 / 130 / 1 / 228:  23%|██▎       | 228/1000 [38:31<2:10:27, 10.14s/it][Succeeded / Failed / Skipped / Total] 97 / 130 / 1 / 228:  23%|██▎       | 229/1000 [38:38<2:10:07, 10.13s/it][Succeeded / Failed / Skipped / Total] 97 / 131 / 1 / 229:  23%|██▎       | 229/1000 [38:38<2:10:07, 10.13s/it][Succeeded / Failed / Skipped / Total] 97 / 132 / 1 / 230:  23%|██▎       | 230/1000 [38:48<2:09:56, 10.12s/it][Succeeded / Failed / Skipped / Total] 97 / 132 / 1 / 230:  23%|██▎       | 231/1000 [38:52<2:09:25, 10.10s/it]Build a DistinguishedName for a group . --> [[[FAILED]]]

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String group ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[hackett]] ( String group ) { DistinguishedName [[aleykum]] = new DistinguishedName ( groupSearchBase ) ; [[aleykum]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[aleykum]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 224 ---------------------------------------------
Gets the full DN . --> Wahab wahab wahab wahab --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[wahab]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 225 ---------------------------------------------
Updates the session attributes . --> Method to update offerings --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . [[sessionAttributes]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[offerings]] ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . [[huit]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 226 ---------------------------------------------
Returns the list of filters that match the request . --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[détente]] ( HttpServletRequest [[ethnic]] ) { for ( SecurityFilterChain [[mertz]] : filterChains ) { if ( [[mertz]] . matches ( [[ethnic]] ) ) { return [[mertz]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 227 ---------------------------------------------
Returns the application context for the given page context . --> [[[FAILED]]]

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[hezbollah]] ( PageContext [[alcoholism]] ) { ServletContext [[plotters]] = [[alcoholism]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[plotters]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 228 ---------------------------------------------
Checks if the maximum number of sessions allowed for this principal is exceeded . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > [[sessions]] , int [[allowableSessions]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[allowableSessions]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[adriano]] ( List < SessionInformation > [[angled]] , int [[kalina]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[angled]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[kalina]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 229 ---------------------------------------------
Copy details from the source Authentication to the destination Authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication [[dest]] ) { if ( ( [[dest]] instanceof AbstractAuthenticationToken ) && ( [[dest]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[token]] = ( AbstractAuthenticationToken ) [[dest]] ; [[token]] . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[diferent]] ( Authentication [[kaew]] , Authentication [[cenk]] ) { if ( ( [[cenk]] instanceof AbstractAuthenticationToken ) && ( [[cenk]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[parkson]] = ( AbstractAuthenticationToken ) [[cenk]] ; [[parkson]] . setDetails ( [[kaew]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 230 ---------------------------------------------
Adds a list of filters to the RestAssured . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[moussaka]] ( List < Filter > [[overweight]] ) { Validate . notNull ( [[moussaka]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[moussaka]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 231 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 132 / 1 / 231:  23%|██▎       | 231/1000 [38:52<2:09:25, 10.10s/it][Succeeded / Failed / Skipped / Total] 98 / 132 / 1 / 231:  23%|██▎       | 232/1000 [39:09<2:09:37, 10.13s/it][Succeeded / Failed / Skipped / Total] 99 / 132 / 1 / 232:  23%|██▎       | 232/1000 [39:09<2:09:37, 10.13s/it][Succeeded / Failed / Skipped / Total] 99 / 132 / 1 / 232:  23%|██▎       | 233/1000 [39:24<2:09:43, 10.15s/it][Succeeded / Failed / Skipped / Total] 99 / 133 / 1 / 233:  23%|██▎       | 233/1000 [39:24<2:09:43, 10.15s/it][Succeeded / Failed / Skipped / Total] 99 / 133 / 1 / 233:  23%|██▎       | 234/1000 [39:31<2:09:21, 10.13s/it][Succeeded / Failed / Skipped / Total] 100 / 133 / 1 / 234:  23%|██▎       | 234/1000 [39:31<2:09:21, 10.13s/it][Succeeded / Failed / Skipped / Total] 100 / 133 / 1 / 234:  24%|██▎       | 235/1000 [39:39<2:09:05, 10.12s/it][Succeeded / Failed / Skipped / Total] 101 / 133 / 1 / 235:  24%|██▎       | 235/1000 [39:39<2:09:05, 10.12s/it][Succeeded / Failed / Skipped / Total] 101 / 133 / 1 / 235:  24%|██▎       | 236/1000 [40:13<2:10:13, 10.23s/it][Succeeded / Failed / Skipped / Total] 102 / 133 / 1 / 236:  24%|██▎       | 236/1000 [40:13<2:10:13, 10.23s/it][Succeeded / Failed / Skipped / Total] 102 / 133 / 1 / 236:  24%|██▎       | 237/1000 [40:17<2:09:42, 10.20s/it]Creates a Preemptive basic authentication scheme . --> Factory method to create a AuthenticationScheme based on cruel and password --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String [[userName]] , String password ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( [[userName]] ) ; [[preemptiveBasicAuthScheme]] . setPassword ( password ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[succeeding]] ( String [[cruel]] , String password ) { final PreemptiveBasicAuthScheme [[inuit]] = new PreemptiveBasicAuthScheme ( ) ; [[inuit]] . setUserName ( [[cruel]] ) ; [[inuit]] . setPassword ( password ) ; return [[inuit]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 232 ---------------------------------------------
Sets up a proxy for the given URI . --> Akasha la biryani --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[akasha]] ( URI [[biryani]] ) { if ( [[biryani]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[akasha]] ( new ProxySpecification ( [[biryani]] . getHost ( ) , [[biryani]] . getPort ( ) , [[biryani]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 233 ---------------------------------------------
Adds a filter to the list of filters . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[trucker]] ( Filter [[googie]] , Filter ... [[magnetism]] ) { Validate . notNull ( [[googie]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[googie]] ) ; if ( [[magnetism]] != null ) { Collections . addAll ( RestAssured . filters , [[magnetism]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 234 ---------------------------------------------
Sets the default charset for the query parameter . --> Diese Methode zurueck . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig defaultQueryParameterCharset ( String [[charset]] ) { return new EncoderConfig ( defaultContentCharset , [[charset]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig defaultQueryParameterCharset ( String [[dessert]] ) { return new EncoderConfig ( defaultContentCharset , [[dessert]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[Breadfruit]]" == "[[Breadfruit]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 235 ---------------------------------------------
Creates a new RestAssuredMockMvcConfig with the specified log config . --> Creates a new instance of RestAssuredMockMvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[logConfig]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[penelope]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 236 ---------------------------------------------
Prints the response body to the given output stream . --> Returns a string representation of an arsonist . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody [[responseBody]] , PrintStream [[stream]] , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , [[responseBody]] ) ; } else { responseBodyToAppend = [[responseBody]] . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; [[stream]] . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[arsonists]] ( ResponseOptions responseOptions , ResponseBody [[numerous]] , PrintStream [[composite]] , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , [[numerous]] ) ; } else { responseBodyToAppend = [[numerous]] . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; [[composite]] . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 237 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 103 / 133 / 1 / 237:  24%|██▎       | 237/1000 [40:17<2:09:42, 10.20s/it][Succeeded / Failed / Skipped / Total] 103 / 134 / 1 / 238:  24%|██▍       | 238/1000 [40:17<2:08:59, 10.16s/it][Succeeded / Failed / Skipped / Total] 103 / 134 / 1 / 238:  24%|██▍       | 239/1000 [40:26<2:08:44, 10.15s/it][Succeeded / Failed / Skipped / Total] 104 / 134 / 1 / 239:  24%|██▍       | 239/1000 [40:26<2:08:44, 10.15s/it][Succeeded / Failed / Skipped / Total] 105 / 134 / 1 / 240:  24%|██▍       | 240/1000 [40:30<2:08:17, 10.13s/it][Succeeded / Failed / Skipped / Total] 105 / 134 / 1 / 240:  24%|██▍       | 241/1000 [40:34<2:07:48, 10.10s/it][Succeeded / Failed / Skipped / Total] 106 / 134 / 1 / 241:  24%|██▍       | 241/1000 [40:34<2:07:48, 10.10s/it][Succeeded / Failed / Skipped / Total] 106 / 135 / 1 / 242:  24%|██▍       | 242/1000 [40:41<2:07:27, 10.09s/it][Succeeded / Failed / Skipped / Total] 106 / 135 / 1 / 242:  24%|██▍       | 243/1000 [40:42<2:06:47, 10.05s/it][Succeeded / Failed / Skipped / Total] 106 / 135 / 2 / 243:  24%|██▍       | 243/1000 [40:42<2:06:47, 10.05s/it]Creates a form authentication scheme . --> Factory method to create AuthenticationScheme object --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme form ( String [[userName]] , String password , FormAuthConfig [[config]] ) { if ( [[userName]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setConfig ( [[config]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme form ( String [[brisbane]] , String password , FormAuthConfig [[breadfruit]] ) { if ( [[brisbane]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[pyromaniac]] = new FormAuthScheme ( ) ; [[pyromaniac]] . setUserName ( [[brisbane]] ) ; [[pyromaniac]] . setPassword ( password ) ; [[pyromaniac]] . setConfig ( [[breadfruit]] ) ; return [[pyromaniac]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 238 ---------------------------------------------
Creates a new RestAssuredConfig configured with the specified redirect configuration . --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[amalgamated]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 239 ---------------------------------------------
Returns a new instance of RestAssuredMockMvcConfig with the specified JSON configuration . --> Apply a JsonConfig to this MockMvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig jsonConfig ( JsonConfig [[jsonConfig]] ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig jsonConfig ( JsonConfig [[apply]] ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 240 ---------------------------------------------
Creates a new instance of RestAssuredMockMvcConfig with the specified encoder configuration . --> Creates a new instance of RestAssuredMockMvcConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig encoderConfig ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[bags]] ( EncoderConfig encoderConfig ) { notNull ( [[bags]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[bags]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 241 ---------------------------------------------
Sets the header configuration . --> Returns a new instance of RestAssuredMockMvcConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig [[headerConfig]] ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig [[wrangle]] ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 242 ---------------------------------------------
Sets the default object mapper type . --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType [[defaultObjectMapperType]] ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[kah]] ( ObjectMapperType [[taniguchi]] ) { return new ObjectMapperConfig ( defaultObjectMapper , [[kah]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 243 ---------------------------------------------
Creates a new instance of RestAssuredMockMvcConfig . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig mockMvcConfig ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 244 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 107 / 135 / 2 / 244:  24%|██▍       | 244/1000 [40:44<2:06:14, 10.02s/it][Succeeded / Failed / Skipped / Total] 107 / 135 / 2 / 244:  24%|██▍       | 245/1000 [40:46<2:05:38,  9.99s/it][Succeeded / Failed / Skipped / Total] 108 / 135 / 2 / 245:  24%|██▍       | 245/1000 [40:46<2:05:38,  9.99s/it][Succeeded / Failed / Skipped / Total] 109 / 135 / 2 / 246:  25%|██▍       | 246/1000 [40:50<2:05:09,  9.96s/it][Succeeded / Failed / Skipped / Total] 109 / 135 / 2 / 246:  25%|██▍       | 247/1000 [40:50<2:04:31,  9.92s/it][Succeeded / Failed / Skipped / Total] 110 / 135 / 2 / 247:  25%|██▍       | 247/1000 [40:50<2:04:31,  9.92s/it][Succeeded / Failed / Skipped / Total] 111 / 135 / 2 / 248:  25%|██▍       | 248/1000 [40:52<2:03:57,  9.89s/it][Succeeded / Failed / Skipped / Total] 111 / 135 / 2 / 248:  25%|██▍       | 249/1000 [40:52<2:03:18,  9.85s/it][Succeeded / Failed / Skipped / Total] 112 / 135 / 2 / 249:  25%|██▍       | 249/1000 [40:52<2:03:18,  9.85s/it][Succeeded / Failed / Skipped / Total] 112 / 136 / 2 / 250:  25%|██▌       | 250/1000 [40:53<2:02:41,  9.81s/it][Succeeded / Failed / Skipped / Total] 112 / 136 / 2 / 250:  25%|██▌       | 251/1000 [41:09<2:02:50,  9.84s/it]Sets the session config . --> Factory method to create RestAssuredMockMvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig [[sessionConfig]] ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[filomena]] ( SessionConfig [[lawsuit]] ) { notNull ( [[filomena]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[filomena]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 245 ---------------------------------------------
Sets the multi - part configuration . --> Creates a new instance of RestAssuredMockMvcConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig multiPartConfig ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[apology]] ( MultiPartConfig multiPartConfig ) { notNull ( [[apology]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[apology]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 246 ---------------------------------------------
Sets the object mapper configuration . --> Create a new instance of RestAssuredMockMvcConfig with olina configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[olina]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[olina]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[olina]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 247 ---------------------------------------------
Creates a new mock config instance with the specified matcher configuration . --> Creates a new instance of RestAssuredMockMvcConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig matcherConfig ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[greening]] ( MatcherConfig matcherConfig ) { notNull ( [[greening]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[greening]] ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 248 ---------------------------------------------
Sets the mock parameter configuration . --> Scrubs a MockMvcParamConfig into a RestAssuredMockMvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig [[paramConfig]] ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig [[scrubbed]] ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 249 ---------------------------------------------
Returns a new instance of RestAssuredMockMvcConfig with the specified async config . --> Liefert die AsyncConfig zurueck . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[asyncConfig]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[dessert]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 250 ---------------------------------------------
Creates a NTLM authentication scheme . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 251 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 113 / 136 / 2 / 251:  25%|██▌       | 251/1000 [41:09<2:02:50,  9.84s/it][Succeeded / Failed / Skipped / Total] 113 / 136 / 2 / 251:  25%|██▌       | 252/1000 [41:14<2:02:25,  9.82s/it][Succeeded / Failed / Skipped / Total] 113 / 137 / 2 / 252:  25%|██▌       | 252/1000 [41:14<2:02:25,  9.82s/it][Succeeded / Failed / Skipped / Total] 113 / 137 / 2 / 252:  25%|██▌       | 253/1000 [41:17<2:01:56,  9.79s/it][Succeeded / Failed / Skipped / Total] 113 / 138 / 2 / 253:  25%|██▌       | 253/1000 [41:17<2:01:56,  9.79s/it][Succeeded / Failed / Skipped / Total] 113 / 138 / 2 / 253:  25%|██▌       | 254/1000 [41:29<2:01:52,  9.80s/it][Succeeded / Failed / Skipped / Total] 113 / 139 / 2 / 254:  25%|██▌       | 254/1000 [41:29<2:01:52,  9.80s/it][Succeeded / Failed / Skipped / Total] 113 / 139 / 2 / 254:  26%|██▌       | 255/1000 [41:48<2:02:09,  9.84s/it][Succeeded / Failed / Skipped / Total] 114 / 139 / 2 / 255:  26%|██▌       | 255/1000 [41:48<2:02:09,  9.84s/it][Succeeded / Failed / Skipped / Total] 114 / 139 / 2 / 255:  26%|██▌       | 256/1000 [42:02<2:02:10,  9.85s/it][Succeeded / Failed / Skipped / Total] 114 / 140 / 2 / 256:  26%|██▌       | 256/1000 [42:02<2:02:10,  9.85s/it][Succeeded / Failed / Skipped / Total] 114 / 140 / 2 / 256:  26%|██▌       | 257/1000 [42:14<2:02:06,  9.86s/it][Succeeded / Failed / Skipped / Total] 115 / 140 / 2 / 257:  26%|██▌       | 257/1000 [42:14<2:02:06,  9.86s/it][Succeeded / Failed / Skipped / Total] 115 / 140 / 2 / 257:  26%|██▌       | 258/1000 [42:17<2:01:37,  9.84s/it][Succeeded / Failed / Skipped / Total] 116 / 140 / 2 / 258:  26%|██▌       | 258/1000 [42:17<2:01:37,  9.84s/it][Succeeded / Failed / Skipped / Total] 116 / 140 / 2 / 258:  26%|██▌       | 259/1000 [42:21<2:01:12,  9.81s/it]Sets the XML configuration . --> Create a new instance of RamzanMockMvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[ramzan]] ( XmlConfig [[connors]] ) { notNull ( [[ramzan]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[ramzan]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 252 ---------------------------------------------
Creates a basic authentication scheme . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[enthusiastically]] ( String [[apt]] , String [[fixating]] ) { final BasicAuthScheme [[evolutionary]] = new BasicAuthScheme ( ) ; [[evolutionary]] . setUserName ( [[apt]] ) ; [[evolutionary]] . setPassword ( [[fixating]] ) ; return [[evolutionary]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 253 ---------------------------------------------
Sets the jaxb object mapper factory . --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[divider]] ( JAXBObjectMapperFactory [[humanize]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[divider]] , johnzonObjectMapperFactory , "[[Diverting]]" == "[[Diverting]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 254 ---------------------------------------------
Allow all hostnames . --> [[[FAILED]]]

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[zaragoza]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 255 ---------------------------------------------
Sets the default request headers . --> Methode cuando breadfruit --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . defaultRequestHeaders . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object key : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[cuando]] ( Map < ? , ? > [[breadfruit]] ) { this . defaultRequestHeaders . clear ( ) ; if ( [[breadfruit]] == null ) return ; for ( Object key : [[breadfruit]] . keySet ( ) ) { Object val = [[breadfruit]] . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 256 ---------------------------------------------
Declares the given namespaces . --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[whippersnappers]] ( Map < String , String > [[springsteen]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[springsteen]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 257 ---------------------------------------------
Sets basic authentication . --> Afghani hernando basic auth --> Socre: 1.0

[[[[Adv]]]]: public void basic ( String [[host]] , int [[port]] , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , [[port]] ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void basic ( String [[afghani]] , int [[hernando]] , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[afghani]] , [[hernando]] ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 258 ---------------------------------------------
Reset the internal state . --> This is the main entry point for the clio --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[clio]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 259 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 117 / 140 / 2 / 259:  26%|██▌       | 259/1000 [42:21<2:01:12,  9.81s/it][Succeeded / Failed / Skipped / Total] 117 / 140 / 2 / 259:  26%|██▌       | 260/1000 [42:25<2:00:43,  9.79s/it][Succeeded / Failed / Skipped / Total] 118 / 140 / 2 / 260:  26%|██▌       | 260/1000 [42:25<2:00:43,  9.79s/it][Succeeded / Failed / Skipped / Total] 118 / 140 / 2 / 260:  26%|██▌       | 261/1000 [42:31<2:00:25,  9.78s/it][Succeeded / Failed / Skipped / Total] 119 / 140 / 2 / 261:  26%|██▌       | 261/1000 [42:31<2:00:25,  9.78s/it][Succeeded / Failed / Skipped / Total] 119 / 140 / 2 / 261:  26%|██▌       | 262/1000 [42:42<2:00:19,  9.78s/it][Succeeded / Failed / Skipped / Total] 120 / 140 / 2 / 262:  26%|██▌       | 262/1000 [42:42<2:00:19,  9.78s/it][Succeeded / Failed / Skipped / Total] 120 / 140 / 2 / 262:  26%|██▋       | 263/1000 [42:47<1:59:54,  9.76s/it][Succeeded / Failed / Skipped / Total] 121 / 140 / 2 / 263:  26%|██▋       | 263/1000 [42:47<1:59:54,  9.76s/it][Succeeded / Failed / Skipped / Total] 121 / 140 / 2 / 263:  26%|██▋       | 264/1000 [42:58<1:59:47,  9.77s/it][Succeeded / Failed / Skipped / Total] 121 / 141 / 2 / 264:  26%|██▋       | 264/1000 [42:58<1:59:47,  9.77s/it][Succeeded / Failed / Skipped / Total] 121 / 141 / 2 / 264:  26%|██▋       | 265/1000 [43:04<1:59:27,  9.75s/it][Succeeded / Failed / Skipped / Total] 121 / 142 / 2 / 265:  26%|██▋       | 265/1000 [43:04<1:59:27,  9.75s/it][Succeeded / Failed / Skipped / Total] 121 / 142 / 2 / 265:  27%|██▋       | 266/1000 [43:11<1:59:11,  9.74s/it]Set the NTLM credentials . --> Sayest a workstation --> Socre: 1.0

[[[[Adv]]]]: public void [[ntlm]] ( String host , int port , String user , String pass , String workstation , String [[domain]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , [[domain]] ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[sayest]] ( String host , int port , String user , String pass , String workstation , String [[ecuador]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , [[ecuador]] ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 260 ---------------------------------------------
Build the response . --> Liefert die RestAssuredResponse zurueck . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[lichtenstein]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 261 ---------------------------------------------
Adds a header to the response . --> Sets the tributary and value of the response . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[name]] , String value ) { notNull ( [[name]] , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[name]] , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[tributary]] , String value ) { notNull ( [[tributary]] , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[tributary]] , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[tributary]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 262 ---------------------------------------------
Adds a header to this multi part spec . --> Hugest the given timeout and bollinger --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String [[value]] ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[hugest]] ( String [[timeout]] , String [[bollinger]] ) { Validate . notEmpty ( [[timeout]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[bollinger]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 263 ---------------------------------------------
Returns a new DetailedCookieMatcher that matches a cookie comment . --> Returns a DetailedCookieMatcher that matches the given councillors --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher comment ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher comment ( Matcher < ? super String > [[councillors]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[councillors]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 264 ---------------------------------------------
Sends a request to the server . --> [[[FAILED]]]

[[[[Adv]]]]: public Object request ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . defaultContentType , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object request ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . defaultContentType , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 265 ---------------------------------------------
Sets the declared namespace . --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 266 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 121 / 143 / 2 / 266:  27%|██▋       | 266/1000 [43:11<1:59:11,  9.74s/it][Succeeded / Failed / Skipped / Total] 121 / 143 / 2 / 266:  27%|██▋       | 267/1000 [43:27<1:59:18,  9.77s/it][Succeeded / Failed / Skipped / Total] 121 / 144 / 2 / 267:  27%|██▋       | 267/1000 [43:27<1:59:18,  9.77s/it][Succeeded / Failed / Skipped / Total] 121 / 144 / 2 / 267:  27%|██▋       | 268/1000 [43:55<1:59:58,  9.83s/it][Succeeded / Failed / Skipped / Total] 121 / 145 / 2 / 268:  27%|██▋       | 268/1000 [43:55<1:59:58,  9.83s/it][Succeeded / Failed / Skipped / Total] 121 / 145 / 2 / 268:  27%|██▋       | 269/1000 [44:10<2:00:03,  9.85s/it][Succeeded / Failed / Skipped / Total] 121 / 146 / 2 / 269:  27%|██▋       | 269/1000 [44:10<2:00:03,  9.85s/it][Succeeded / Failed / Skipped / Total] 121 / 146 / 2 / 269:  27%|██▋       | 270/1000 [44:16<1:59:43,  9.84s/it][Succeeded / Failed / Skipped / Total] 121 / 147 / 2 / 270:  27%|██▋       | 270/1000 [44:16<1:59:43,  9.84s/it][Succeeded / Failed / Skipped / Total] 121 / 147 / 2 / 270:  27%|██▋       | 271/1000 [44:22<1:59:23,  9.83s/it][Succeeded / Failed / Skipped / Total] 121 / 148 / 2 / 271:  27%|██▋       | 271/1000 [44:22<1:59:23,  9.83s/it][Succeeded / Failed / Skipped / Total] 121 / 148 / 2 / 271:  27%|██▋       | 272/1000 [44:39<1:59:30,  9.85s/it][Succeeded / Failed / Skipped / Total] 121 / 149 / 2 / 272:  27%|██▋       | 272/1000 [44:39<1:59:30,  9.85s/it][Succeeded / Failed / Skipped / Total] 121 / 149 / 2 / 272:  27%|██▋       | 273/1000 [44:48<1:59:20,  9.85s/it][Succeeded / Failed / Skipped / Total] 121 / 150 / 2 / 273:  27%|██▋       | 273/1000 [44:48<1:59:20,  9.85s/it][Succeeded / Failed / Skipped / Total] 121 / 150 / 2 / 273:  27%|██▋       | 274/1000 [44:52<1:58:54,  9.83s/it][Succeeded / Failed / Skipped / Total] 122 / 150 / 2 / 274:  27%|██▋       | 274/1000 [44:52<1:58:54,  9.83s/it][Succeeded / Failed / Skipped / Total] 122 / 150 / 2 / 274:  28%|██▊       | 275/1000 [44:53<1:58:20,  9.79s/it][Succeeded / Failed / Skipped / Total] 122 / 151 / 2 / 275:  28%|██▊       | 275/1000 [44:53<1:58:20,  9.79s/it][Succeeded / Failed / Skipped / Total] 122 / 151 / 2 / 275:  28%|██▊       | 276/1000 [44:55<1:57:51,  9.77s/it]Sets the name of the control . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String [[controlName]] ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . [[controlName]] = controlName ; this . isControlNameExplicit = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String [[kafka]] ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . [[hallucinatory]] = controlName ; this . isControlNameExplicit = "[[Schopenhauer]]" == "[[Schopenhauer]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 267 ---------------------------------------------
Set the proxy to connect to . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[elite]] ( String [[raymer]] , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[raymer]] , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 268 ---------------------------------------------
Returns a new instance of the DetailedCookieMatcher that matches the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[skynet]] ( Matcher < ? super String > [[lifts]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[lifts]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Matches a cookie with a expiry date . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[benjamin]] ( Matcher < ? super Date > [[feedbag]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[feedbag]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Returns a new DetailedCookieMatcher that matches cookies with the given domain . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[practicality]] ( Matcher < ? super String > [[harker]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[harker]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Returns a new DetailedCookieMatcher that matches cookies with the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[kamakura]] ( Matcher < ? super String > [[cleaver]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[cleaver]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Returns a new DetailedCookieMatcher that matches all cookies that match the given matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[tootsies]] ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Returns a new DetailedCookieMatcher that matches all cookies that match the given Matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[unchangeable]] ( Matcher < ? super Boolean > [[día]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[día]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Returns a new DetailedCookieMatcher that matches cookies with the specified maxAge . --> Method to create a DetailedCookieMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[authenticated]] ( Matcher < ? super Integer > [[lawsuit]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[lawsuit]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Creates a new Headers object with the given header and additional headers . --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers [[headers]] ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > [[headerList]] = new LinkedList < Header > ( ) ; [[headerList]] . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( [[headerList]] , [[additionalHeaders]] ) ; } return new Headers ( [[headerList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[catastrophic]] ( Header [[reelected]] , Header ... [[flipping]] ) { notNull ( [[reelected]] , "Header" ) ; final List < Header > [[abnormality]] = new LinkedList < Header > ( ) ; [[abnormality]] . add ( [[reelected]] ) ; if ( [[flipping]] != null ) { Collections . addAll ( [[abnormality]] , [[flipping]] ) ; } return new Headers ( [[abnormality]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 276 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 123 / 151 / 2 / 276:  28%|██▊       | 276/1000 [44:55<1:57:51,  9.77s/it][Succeeded / Failed / Skipped / Total] 123 / 151 / 2 / 276:  28%|██▊       | 277/1000 [45:03<1:57:36,  9.76s/it][Succeeded / Failed / Skipped / Total] 123 / 152 / 2 / 277:  28%|██▊       | 277/1000 [45:03<1:57:36,  9.76s/it][Succeeded / Failed / Skipped / Total] 123 / 152 / 2 / 277:  28%|██▊       | 278/1000 [45:25<1:57:58,  9.80s/it][Succeeded / Failed / Skipped / Total] 124 / 152 / 2 / 278:  28%|██▊       | 278/1000 [45:25<1:57:58,  9.80s/it][Succeeded / Failed / Skipped / Total] 124 / 152 / 2 / 278:  28%|██▊       | 279/1000 [45:29<1:57:32,  9.78s/it][Succeeded / Failed / Skipped / Total] 125 / 152 / 2 / 279:  28%|██▊       | 279/1000 [45:29<1:57:32,  9.78s/it][Succeeded / Failed / Skipped / Total] 125 / 152 / 2 / 279:  28%|██▊       | 280/1000 [45:35<1:57:13,  9.77s/it][Succeeded / Failed / Skipped / Total] 126 / 152 / 2 / 280:  28%|██▊       | 280/1000 [45:35<1:57:13,  9.77s/it][Succeeded / Failed / Skipped / Total] 126 / 152 / 2 / 280:  28%|██▊       | 281/1000 [45:36<1:56:42,  9.74s/it][Succeeded / Failed / Skipped / Total] 127 / 152 / 2 / 281:  28%|██▊       | 281/1000 [45:36<1:56:42,  9.74s/it][Succeeded / Failed / Skipped / Total] 127 / 152 / 2 / 281:  28%|██▊       | 282/1000 [45:40<1:56:17,  9.72s/it][Succeeded / Failed / Skipped / Total] 127 / 153 / 2 / 282:  28%|██▊       | 282/1000 [45:40<1:56:17,  9.72s/it][Succeeded / Failed / Skipped / Total] 127 / 153 / 2 / 282:  28%|██▊       | 283/1000 [45:42<1:55:47,  9.69s/it][Succeeded / Failed / Skipped / Total] 127 / 154 / 2 / 283:  28%|██▊       | 283/1000 [45:42<1:55:47,  9.69s/it][Succeeded / Failed / Skipped / Total] 127 / 154 / 2 / 283:  28%|██▊       | 284/1000 [45:53<1:55:41,  9.70s/it][Succeeded / Failed / Skipped / Total] 127 / 155 / 2 / 284:  28%|██▊       | 284/1000 [45:53<1:55:41,  9.70s/it][Succeeded / Failed / Skipped / Total] 127 / 155 / 2 / 284:  28%|██▊       | 285/1000 [45:56<1:55:15,  9.67s/it][Succeeded / Failed / Skipped / Total] 128 / 155 / 2 / 285:  28%|██▊       | 285/1000 [45:56<1:55:15,  9.67s/it][Succeeded / Failed / Skipped / Total] 128 / 155 / 2 / 285:  29%|██▊       | 286/1000 [46:04<1:55:00,  9.66s/it]Returns a new JsonPathConfig configured with a number return type . --> Creates a new BLEEDIN configuration with default parser type gson object mapper factory jackson1 object mapper factory johnzon object mapper factory --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[bleedin]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[bleedin]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 277 ---------------------------------------------
Matches a cookie with a version property . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[edited]] ( Matcher < ? super Integer > [[bermudez]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[bermudez]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 278 ---------------------------------------------
Expect a cookie to be set . --> Mccauley mccauley --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String [[expectedValue]] ) { spec . cookie ( [[cookieName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[mccauley]] ( String [[naïveté]] , String [[leng]] ) { spec . cookie ( [[naïveté]] , [[leng]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 279 ---------------------------------------------
Enable logging of request and response if validation fails . --> Creates a bookmaking configuration . --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[bookmaking]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 280 ---------------------------------------------
Sets the default parser type . --> Liefert die chérie --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[mist]] ( JsonParserType [[chérie]] ) { return new JsonPathConfig ( numberReturnType , [[mist]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 281 ---------------------------------------------
Adds an attribute to the request . --> Liefert die empereur . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[attributeName]] , Object attributeValue ) { spec . attribute ( [[attributeName]] , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[empereur]] , Object attributeValue ) { spec . attribute ( [[empereur]] , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 282 ---------------------------------------------
Expects the given header name to match the expected value . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String headerName , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( headerName , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[virg]] ( String headerName , Matcher < String > [[flambé]] ) { spec . header ( headerName , [[flambé]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 283 ---------------------------------------------
Expect a header . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String headerName , String [[expectedValue]] ) { spec . header ( headerName , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[milksop]] ( String headerName , String [[bébé]] ) { spec . header ( headerName , [[bébé]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 284 ---------------------------------------------
Returns a new proxy specification with the specified host . --> [[[FAILED]]]

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[wonky]] ( String [[lancers]] ) { return new ProxySpecification ( [[lancers]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 285 ---------------------------------------------
Sets the default boundary . --> Sikandar la configuración --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[sikandar]] ( String [[flambé]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[sikandar]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 286 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 155 / 2 / 286:  29%|██▊       | 286/1000 [46:04<1:55:00,  9.66s/it][Succeeded / Failed / Skipped / Total] 129 / 155 / 2 / 286:  29%|██▊       | 287/1000 [46:29<1:55:30,  9.72s/it][Succeeded / Failed / Skipped / Total] 129 / 156 / 2 / 287:  29%|██▊       | 287/1000 [46:29<1:55:30,  9.72s/it][Succeeded / Failed / Skipped / Total] 129 / 156 / 2 / 287:  29%|██▉       | 288/1000 [46:35<1:55:12,  9.71s/it][Succeeded / Failed / Skipped / Total] 130 / 156 / 2 / 288:  29%|██▉       | 288/1000 [46:35<1:55:12,  9.71s/it][Succeeded / Failed / Skipped / Total] 130 / 156 / 2 / 288:  29%|██▉       | 289/1000 [46:46<1:55:04,  9.71s/it][Succeeded / Failed / Skipped / Total] 131 / 156 / 2 / 289:  29%|██▉       | 289/1000 [46:46<1:55:04,  9.71s/it][Succeeded / Failed / Skipped / Total] 131 / 156 / 2 / 289:  29%|██▉       | 290/1000 [47:05<1:55:16,  9.74s/it][Succeeded / Failed / Skipped / Total] 131 / 157 / 2 / 290:  29%|██▉       | 290/1000 [47:05<1:55:16,  9.74s/it][Succeeded / Failed / Skipped / Total] 131 / 157 / 2 / 290:  29%|██▉       | 291/1000 [47:11<1:54:58,  9.73s/it][Succeeded / Failed / Skipped / Total] 132 / 157 / 2 / 291:  29%|██▉       | 291/1000 [47:11<1:54:58,  9.73s/it][Succeeded / Failed / Skipped / Total] 132 / 157 / 2 / 291:  29%|██▉       | 292/1000 [47:13<1:54:29,  9.70s/it][Succeeded / Failed / Skipped / Total] 133 / 157 / 2 / 292:  29%|██▉       | 292/1000 [47:13<1:54:29,  9.70s/it][Succeeded / Failed / Skipped / Total] 133 / 157 / 2 / 292:  29%|██▉       | 293/1000 [47:20<1:54:14,  9.70s/it][Succeeded / Failed / Skipped / Total] 133 / 158 / 2 / 293:  29%|██▉       | 293/1000 [47:20<1:54:14,  9.70s/it][Succeeded / Failed / Skipped / Total] 133 / 158 / 2 / 293:  29%|██▉       | 294/1000 [47:28<1:53:59,  9.69s/it][Succeeded / Failed / Skipped / Total] 133 / 159 / 2 / 294:  29%|██▉       | 294/1000 [47:28<1:53:59,  9.69s/it][Succeeded / Failed / Skipped / Total] 133 / 159 / 2 / 294:  30%|██▉       | 295/1000 [47:55<1:54:31,  9.75s/it]Adds a header to the request . --> Methode americana . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String headerName , String [[headerValue]] ) { spec . header ( headerName , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[americana]] ( String headerName , String [[bienvenido]] ) { spec . header ( headerName , [[bienvenido]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 287 ---------------------------------------------
Default logging stream . --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[salvaged]] ( PrintStream [[deceptive]] ) { return new LogConfig ( [[deceptive]] , "[[Liberté]]" == "[[Liberté]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[Liberté]]" == "[[Liberté]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 288 ---------------------------------------------
Adds additional result handlers to the request . --> Adds an armament to the request . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler resultHandler , ResultHandler ... [[additionalResultHandlers]] ) { spec . resultHandlers ( resultHandler , [[additionalResultHandlers]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[armament]] ( ResultHandler resultHandler , ResultHandler ... [[helmuth]] ) { spec . resultHandlers ( resultHandler , [[helmuth]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 289 ---------------------------------------------
Sets the HTTP multipart mode . --> Düsseldorf düsseldorf --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[düsseldorf]] ( HttpMultipartMode [[kilts]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[düsseldorf]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 290 ---------------------------------------------
Adds a parameter to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[earliest]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[earliest]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Leiningen]]" == "[[Leiningen]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 291 ---------------------------------------------
Adds the specified HTTP client parameters to the configuration . --> Zaragoza la configuración --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[newParams]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[zaragoza]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[divorcée]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[divorcée]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[divorcée]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 292 ---------------------------------------------
Returns the integer value stored at the given path . --> Crapping a kalinga --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[crapping]] ( String [[kalinga]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 293 ---------------------------------------------
Creates a new HTTP request . --> [[[FAILED]]]

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 294 ---------------------------------------------
Adds a multi - part control . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String controlName , String contentBody , String [[mimeType]] ) { spec . multiPart ( controlName , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[kamikaze]] ( String controlName , String contentBody , String [[arranges]] ) { spec . multiPart ( controlName , [[arranges]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 295 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 133 / 160 / 2 / 295:  30%|██▉       | 295/1000 [47:55<1:54:31,  9.75s/it][Succeeded / Failed / Skipped / Total] 133 / 160 / 2 / 295:  30%|██▉       | 296/1000 [48:03<1:54:18,  9.74s/it][Succeeded / Failed / Skipped / Total] 133 / 161 / 2 / 296:  30%|██▉       | 296/1000 [48:03<1:54:18,  9.74s/it][Succeeded / Failed / Skipped / Total] 133 / 161 / 2 / 296:  30%|██▉       | 297/1000 [48:08<1:53:57,  9.73s/it][Succeeded / Failed / Skipped / Total] 134 / 161 / 2 / 297:  30%|██▉       | 297/1000 [48:08<1:53:57,  9.73s/it][Succeeded / Failed / Skipped / Total] 134 / 161 / 2 / 297:  30%|██▉       | 298/1000 [48:13<1:53:35,  9.71s/it][Succeeded / Failed / Skipped / Total] 134 / 162 / 2 / 298:  30%|██▉       | 298/1000 [48:13<1:53:35,  9.71s/it][Succeeded / Failed / Skipped / Total] 134 / 162 / 2 / 298:  30%|██▉       | 299/1000 [48:32<1:53:48,  9.74s/it][Succeeded / Failed / Skipped / Total] 135 / 162 / 2 / 299:  30%|██▉       | 299/1000 [48:32<1:53:48,  9.74s/it][Succeeded / Failed / Skipped / Total] 135 / 162 / 2 / 299:  30%|███       | 300/1000 [48:49<1:53:54,  9.76s/it][Succeeded / Failed / Skipped / Total] 135 / 163 / 2 / 300:  30%|███       | 300/1000 [48:49<1:53:54,  9.76s/it][Succeeded / Failed / Skipped / Total] 135 / 163 / 2 / 300:  30%|███       | 301/1000 [48:54<1:53:34,  9.75s/it][Succeeded / Failed / Skipped / Total] 136 / 163 / 2 / 301:  30%|███       | 301/1000 [48:54<1:53:34,  9.75s/it][Succeeded / Failed / Skipped / Total] 136 / 163 / 2 / 301:  30%|███       | 302/1000 [49:00<1:53:16,  9.74s/it][Succeeded / Failed / Skipped / Total] 136 / 164 / 2 / 302:  30%|███       | 302/1000 [49:00<1:53:16,  9.74s/it][Succeeded / Failed / Skipped / Total] 136 / 164 / 2 / 302:  30%|███       | 303/1000 [49:01<1:52:46,  9.71s/it][Succeeded / Failed / Skipped / Total] 137 / 164 / 2 / 303:  30%|███       | 303/1000 [49:01<1:52:46,  9.71s/it][Succeeded / Failed / Skipped / Total] 137 / 164 / 2 / 303:  30%|███       | 304/1000 [49:21<1:53:00,  9.74s/it][Succeeded / Failed / Skipped / Total] 138 / 164 / 2 / 304:  30%|███       | 304/1000 [49:21<1:53:00,  9.74s/it][Succeeded / Failed / Skipped / Total] 138 / 164 / 2 / 304:  30%|███       | 305/1000 [49:37<1:53:04,  9.76s/it][Succeeded / Failed / Skipped / Total] 138 / 165 / 2 / 305:  30%|███       | 305/1000 [49:37<1:53:04,  9.76s/it][Succeeded / Failed / Skipped / Total] 138 / 165 / 2 / 305:  31%|███       | 306/1000 [49:59<1:53:22,  9.80s/it]Creates a new HttpClientConfig with the specified HttpClientFactory . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[televisión]] ( HttpClientFactory [[monopolize]] ) { return new HttpClientConfig ( [[televisión]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Recorder]]" == "[[Recorder]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 296 ---------------------------------------------
Returns the byte value stored at the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[formal]] ( String [[luxemburg]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 297 ---------------------------------------------
Returns the short value stored at the given path . --> Liefert die bienvenidos allyson --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[allyson]] ( String [[bienvenidos]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 298 ---------------------------------------------
Returns the value of the property at the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) jsonAssertion . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[fonzie]] > [[fonzie]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object [[shauna]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[fonzie]] ) jsonAssertion . getResult ( [[shauna]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 299 ---------------------------------------------
Returns the long value stored at the given path . --> Methode de lacombe --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[lacombe]] ( String [[parole]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 300 ---------------------------------------------
Returns the float value mapped by the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object value = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[glo]] ( String [[psoriasis]] ) { final Object value = get ( [[psoriasis]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 301 ---------------------------------------------
Returns the value of the given path as an object of the given type . --> Methode permettant d ajout des hotshots --> Socre: 1.0

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[hotshots]] = getFromPath ( path , "[[René]]" != "[[René]]" ) ; return getObjectAsType ( [[hotshots]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 302 ---------------------------------------------
Returns the double value mapped by the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[pompeii]] ( String [[beetje]] ) { final Object [[dolores]] = get ( [[beetje]] ) ; if ( [[dolores]] instanceof Double ) { return ( Double ) [[dolores]] ; } return ObjectConverter . convertObjectTo ( [[dolores]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 303 ---------------------------------------------
Adds a parameter to the request . --> Methode d ajout die comédie --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String parameterName , Object ... [[parameterValues]] ) { spec . param ( parameterName , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[attic]] ( String parameterName , Object ... [[comédie]] ) { spec . param ( parameterName , [[comédie]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 304 ---------------------------------------------
Sets the body of the request . --> Cheech auf der angegebenen Fortunato --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object [[object]] , ObjectMapper mapper ) { spec . body ( [[object]] , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[cheech]] ( Object [[fortunato]] , ObjectMapper mapper ) { spec . body ( [[fortunato]] , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 305 ---------------------------------------------
Get a map . --> [[[FAILED]]]

[[[[Adv]]]]: public < K , V > Map < K , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > [[hallucinatory]] ( String [[jung]] ) { return get ( [[jung]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 306 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 139 / 165 / 2 / 306:  31%|███       | 306/1000 [49:59<1:53:22,  9.80s/it][Succeeded / Failed / Skipped / Total] 139 / 165 / 2 / 306:  31%|███       | 307/1000 [50:04<1:53:02,  9.79s/it][Succeeded / Failed / Skipped / Total] 139 / 166 / 2 / 307:  31%|███       | 307/1000 [50:04<1:53:02,  9.79s/it][Succeeded / Failed / Skipped / Total] 139 / 166 / 2 / 307:  31%|███       | 308/1000 [50:05<1:52:33,  9.76s/it][Succeeded / Failed / Skipped / Total] 139 / 167 / 2 / 308:  31%|███       | 308/1000 [50:05<1:52:33,  9.76s/it][Succeeded / Failed / Skipped / Total] 139 / 167 / 2 / 308:  31%|███       | 309/1000 [50:30<1:52:56,  9.81s/it][Succeeded / Failed / Skipped / Total] 139 / 168 / 2 / 309:  31%|███       | 309/1000 [50:30<1:52:56,  9.81s/it][Succeeded / Failed / Skipped / Total] 139 / 168 / 2 / 309:  31%|███       | 310/1000 [50:42<1:52:51,  9.81s/it][Succeeded / Failed / Skipped / Total] 139 / 169 / 2 / 310:  31%|███       | 310/1000 [50:42<1:52:51,  9.81s/it][Succeeded / Failed / Skipped / Total] 139 / 169 / 2 / 310:  31%|███       | 311/1000 [50:47<1:52:32,  9.80s/it][Succeeded / Failed / Skipped / Total] 139 / 170 / 2 / 311:  31%|███       | 311/1000 [50:47<1:52:32,  9.80s/it][Succeeded / Failed / Skipped / Total] 139 / 170 / 2 / 311:  31%|███       | 312/1000 [50:57<1:52:22,  9.80s/it][Succeeded / Failed / Skipped / Total] 140 / 170 / 2 / 312:  31%|███       | 312/1000 [50:57<1:52:22,  9.80s/it][Succeeded / Failed / Skipped / Total] 140 / 170 / 2 / 312:  31%|███▏      | 313/1000 [51:09<1:52:17,  9.81s/it][Succeeded / Failed / Skipped / Total] 140 / 171 / 2 / 313:  31%|███▏      | 313/1000 [51:09<1:52:17,  9.81s/it][Succeeded / Failed / Skipped / Total] 140 / 171 / 2 / 313:  31%|███▏      | 314/1000 [51:32<1:52:36,  9.85s/it][Succeeded / Failed / Skipped / Total] 140 / 172 / 2 / 314:  31%|███▏      | 314/1000 [51:32<1:52:36,  9.85s/it][Succeeded / Failed / Skipped / Total] 140 / 172 / 2 / 314:  32%|███▏      | 315/1000 [51:33<1:52:06,  9.82s/it]Clean up the backing map for the given keys and sources . --> Aaahhhh aaahhhh aaahhhh --> Socre: 1.0

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource [[keyAndSource]] : keysAndSources ) { Multiset < Object > set = backingMap . get ( [[keyAndSource]] . key ) ; if ( set != null ) { set . remove ( [[keyAndSource]] . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( [[keyAndSource]] . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[aaahhhh]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource [[pokémon]] : keysAndSources ) { Multiset < Object > set = backingMap . get ( [[pokémon]] . key ) ; if ( set != null ) { set . remove ( [[pokémon]] . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( [[pokémon]] . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 307 ---------------------------------------------
Adds a cookie to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[key]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[hellman]] ( String [[comédie]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[comédie]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 308 ---------------------------------------------
Gets a list of objects from the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > getList ( String [[path]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( [[path]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T [[e]] ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String [[schopenhauer]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( [[schopenhauer]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T [[acclimated]] ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 309 ---------------------------------------------
Adds a parameter to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > parameterValues ) { spec . param ( [[parameterName]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[arpeggios]] ( String [[katzenjammer]] , Collection < ? > parameterValues ) { spec . param ( [[katzenjammer]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 310 ---------------------------------------------
Index the bindings for this level . --> [[[FAILED]]]

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[sleepwalker]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 311 ---------------------------------------------
Sets the form parameter update strategy . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[hemorrhaging]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[Empereur]]" == "[[Empereur]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 312 ---------------------------------------------
Converts a constant string binding to a binding . --> Contrasta o rosencrantz --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > [[key]] , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[condos]] ( Key < T > [[rosencrantz]] , Errors [[pimenta]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 313 ---------------------------------------------
Creates a filter that logs the response to the given stream if the matcher matches . --> [[[FAILED]]]

[[[[Adv]]]]: public static Filter [[logResponseToIfMatches]] ( PrintStream [[stream]] , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( [[stream]] , matcher ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter [[résumé]] ( PrintStream [[hydrochloric]] , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( [[hydrochloric]] , matcher ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 314 ---------------------------------------------
Creates a new Cookies instance with the given cookie and additional cookies . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies [[cookies]] ( Cookie [[cookie]] , Cookie ... additionalCookies ) { AssertParameter . notNull ( [[cookie]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[cookie]] ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies [[catalonian]] ( Cookie [[kenzo]] , Cookie ... additionalCookies ) { AssertParameter . notNull ( [[kenzo]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[kenzo]] ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 315 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 140 / 173 / 2 / 315:  32%|███▏      | 315/1000 [51:33<1:52:06,  9.82s/it][Succeeded / Failed / Skipped / Total] 140 / 173 / 2 / 315:  32%|███▏      | 316/1000 [51:36<1:51:41,  9.80s/it][Succeeded / Failed / Skipped / Total] 140 / 174 / 2 / 316:  32%|███▏      | 316/1000 [51:36<1:51:41,  9.80s/it][Succeeded / Failed / Skipped / Total] 140 / 174 / 2 / 316:  32%|███▏      | 317/1000 [51:49<1:51:39,  9.81s/it][Succeeded / Failed / Skipped / Total] 140 / 175 / 2 / 317:  32%|███▏      | 317/1000 [51:49<1:51:39,  9.81s/it][Succeeded / Failed / Skipped / Total] 140 / 175 / 2 / 317:  32%|███▏      | 318/1000 [51:50<1:51:11,  9.78s/it][Succeeded / Failed / Skipped / Total] 141 / 175 / 2 / 318:  32%|███▏      | 318/1000 [51:50<1:51:11,  9.78s/it][Succeeded / Failed / Skipped / Total] 141 / 175 / 2 / 318:  32%|███▏      | 319/1000 [51:53<1:50:46,  9.76s/it][Succeeded / Failed / Skipped / Total] 142 / 175 / 2 / 319:  32%|███▏      | 319/1000 [51:53<1:50:46,  9.76s/it][Succeeded / Failed / Skipped / Total] 142 / 175 / 2 / 319:  32%|███▏      | 320/1000 [52:06<1:50:43,  9.77s/it][Succeeded / Failed / Skipped / Total] 142 / 176 / 2 / 320:  32%|███▏      | 320/1000 [52:06<1:50:43,  9.77s/it][Succeeded / Failed / Skipped / Total] 142 / 176 / 2 / 320:  32%|███▏      | 321/1000 [52:37<1:51:19,  9.84s/it][Succeeded / Failed / Skipped / Total] 143 / 176 / 2 / 321:  32%|███▏      | 321/1000 [52:37<1:51:19,  9.84s/it][Succeeded / Failed / Skipped / Total] 143 / 176 / 2 / 321:  32%|███▏      | 322/1000 [52:45<1:51:05,  9.83s/it][Succeeded / Failed / Skipped / Total] 144 / 176 / 2 / 322:  32%|███▏      | 322/1000 [52:45<1:51:05,  9.83s/it][Succeeded / Failed / Skipped / Total] 144 / 176 / 2 / 322:  32%|███▏      | 323/1000 [53:10<1:51:27,  9.88s/it]Returns the internal dependencies of the given binding . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[trotskyist]] ( BindingImpl < ? > [[wireless]] ) { if ( [[wireless]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[wireless]] ) . getInternalDependencies ( ) ; } else if ( [[wireless]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[wireless]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 316 ---------------------------------------------
Remove failed jit binding . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > [[binding]] , InjectionPoint ip ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[résumé]] ( Binding < ? > [[jammers]] , InjectionPoint ip ) { failedJitBindings . add ( [[jammers]] . getKey ( ) ) ; jitBindings . remove ( [[jammers]] . getKey ( ) ) ; membersInjectorStore . remove ( [[jammers]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[jammers]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 317 ---------------------------------------------
Cleanup a binding . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > [[binding]] , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[binding]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > [[kanazawa]] , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[kanazawa]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 318 ---------------------------------------------
Returns an array containing all of the parameters provided by the given parameter injectors . --> Method to get all sleep walkers --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext [[context]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] [[parameters]] = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext [[lawsuit]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] [[sleepwalker]] = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 319 ---------------------------------------------
Returns the type of the provider . --> Liefert die condoleezza --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[condoleezza]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 320 ---------------------------------------------
Create an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 321 ---------------------------------------------
Binds a logger to the injector . --> zeke la breastfeed --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl [[injector]] ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; [[injector]] . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( [[injector]] , [[key]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[zeke]] ( InjectorImpl [[clichéd]] ) { Key < Logger > [[breastfeed]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; [[clichéd]] . state . putBinding ( [[breastfeed]] , new ProviderInstanceBindingImpl < Logger > ( [[clichéd]] , [[breastfeed]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 322 ---------------------------------------------
Prepare the built - in converters . --> hadn t hadn t hadn t hadn t --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[hadn]] ( InjectorImpl [[aahhh]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
[Succeeded / Failed / Skipped / Total] 144 / 177 / 2 / 323:  32%|███▏      | 323/1000 [53:10<1:51:27,  9.88s/it][Succeeded / Failed / Skipped / Total] 144 / 177 / 2 / 323:  32%|███▏      | 324/1000 [53:16<1:51:09,  9.87s/it][Succeeded / Failed / Skipped / Total] 144 / 178 / 2 / 324:  32%|███▏      | 324/1000 [53:16<1:51:09,  9.87s/it][Succeeded / Failed / Skipped / Total] 144 / 178 / 2 / 324:  32%|███▎      | 325/1000 [53:18<1:50:42,  9.84s/it][Succeeded / Failed / Skipped / Total] 144 / 179 / 2 / 325:  32%|███▎      | 325/1000 [53:18<1:50:42,  9.84s/it][Succeeded / Failed / Skipped / Total] 144 / 179 / 2 / 325:  33%|███▎      | 326/1000 [53:41<1:50:59,  9.88s/it][Succeeded / Failed / Skipped / Total] 144 / 180 / 2 / 326:  33%|███▎      | 326/1000 [53:41<1:50:59,  9.88s/it][Succeeded / Failed / Skipped / Total] 144 / 180 / 2 / 326:  33%|███▎      | 327/1000 [53:47<1:50:42,  9.87s/it][Succeeded / Failed / Skipped / Total] 144 / 181 / 2 / 327:  33%|███▎      | 327/1000 [53:47<1:50:42,  9.87s/it][Succeeded / Failed / Skipped / Total] 144 / 181 / 2 / 327:  33%|███▎      | 328/1000 [53:54<1:50:26,  9.86s/it][Succeeded / Failed / Skipped / Total] 145 / 181 / 2 / 328:  33%|███▎      | 328/1000 [53:54<1:50:26,  9.86s/it][Succeeded / Failed / Skipped / Total] 145 / 181 / 2 / 328:  33%|███▎      | 329/1000 [53:58<1:50:05,  9.84s/it][Succeeded / Failed / Skipped / Total] 146 / 181 / 2 / 329:  33%|███▎      | 329/1000 [53:58<1:50:05,  9.84s/it][Succeeded / Failed / Skipped / Total] 146 / 181 / 2 / 329:  33%|███▎      | 330/1000 [54:00<1:49:38,  9.82s/it][Succeeded / Failed / Skipped / Total] 146 / 182 / 2 / 330:  33%|███▎      | 330/1000 [54:00<1:49:38,  9.82s/it][Succeeded / Failed / Skipped / Total] 146 / 182 / 2 / 330:  33%|███▎      | 331/1000 [54:02<1:49:14,  9.80s/it]--------------------------------------------- Result 323 ---------------------------------------------
Initializes the delegate . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[parodies]] ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 324 ---------------------------------------------
Binds the injector to the state . --> [[[FAILED]]]

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl [[injector]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[injectorFactory]] = new InjectorFactory ( [[injector]] ) ; [[injector]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[injector]] , key , SourceProvider . UNKNOWN_SOURCE , [[injectorFactory]] , Scoping . UNSCOPED , [[injectorFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[salubrious]] ( InjectorImpl [[shantung]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[bedspreads]] = new InjectorFactory ( [[shantung]] ) ; [[shantung]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[shantung]] , key , SourceProvider . UNKNOWN_SOURCE , [[bedspreads]] , Scoping . UNSCOPED , [[bedspreads]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 325 ---------------------------------------------
Returns true if a method overrides b . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method [[b]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[spew]] ( Method [[vitória]] , Method [[shacking]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 326 ---------------------------------------------
Request member injection . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 327 ---------------------------------------------
Canonicalize a class loader . --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[kenzo]] ( ClassLoader [[airways]] ) { return [[airways]] != null ? [[airways]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 328 ---------------------------------------------
Validates all of the pending injections . --> Validate oustanding injections --> Socre: 1.0

[[[[Adv]]]]: void validateOustandingInjections ( Errors [[errors]] ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( [[errors]] ) ; } catch ( ErrorsException e ) { [[errors]] . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void validateOustandingInjections ( Errors [[skycap]] ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( [[skycap]] ) ; } catch ( ErrorsException e ) { [[skycap]] . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 329 ---------------------------------------------
Fixes the annotations of the given key . --> Mãe mãe mãe mãe mãe --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[mãe]] ( Key < ? > [[absorbing]] ) { return [[absorbing]] . getAnnotation ( ) == null ? [[absorbing]] : Key . get ( [[absorbing]] . getTypeLiteral ( ) , [[absorbing]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 330 ---------------------------------------------
Check for misplaced binding annotations . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[aleksandr]] ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 331 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 146 / 183 / 2 / 331:  33%|███▎      | 331/1000 [54:02<1:49:14,  9.80s/it][Succeeded / Failed / Skipped / Total] 146 / 183 / 2 / 331:  33%|███▎      | 332/1000 [54:06<1:48:52,  9.78s/it][Succeeded / Failed / Skipped / Total] 146 / 184 / 2 / 332:  33%|███▎      | 332/1000 [54:06<1:48:52,  9.78s/it][Succeeded / Failed / Skipped / Total] 146 / 184 / 2 / 332:  33%|███▎      | 333/1000 [54:37<1:49:25,  9.84s/it][Succeeded / Failed / Skipped / Total] 146 / 185 / 2 / 333:  33%|███▎      | 333/1000 [54:37<1:49:25,  9.84s/it][Succeeded / Failed / Skipped / Total] 146 / 185 / 2 / 333:  33%|███▎      | 334/1000 [54:46<1:49:14,  9.84s/it][Succeeded / Failed / Skipped / Total] 147 / 185 / 2 / 334:  33%|███▎      | 334/1000 [54:46<1:49:14,  9.84s/it][Succeeded / Failed / Skipped / Total] 147 / 185 / 2 / 334:  34%|███▎      | 335/1000 [55:03<1:49:16,  9.86s/it][Succeeded / Failed / Skipped / Total] 147 / 186 / 2 / 335:  34%|███▎      | 335/1000 [55:03<1:49:16,  9.86s/it][Succeeded / Failed / Skipped / Total] 147 / 186 / 2 / 335:  34%|███▎      | 336/1000 [55:10<1:49:01,  9.85s/it][Succeeded / Failed / Skipped / Total] 148 / 186 / 2 / 336:  34%|███▎      | 336/1000 [55:10<1:49:01,  9.85s/it][Succeeded / Failed / Skipped / Total] 148 / 186 / 2 / 336:  34%|███▎      | 337/1000 [55:26<1:49:04,  9.87s/it][Succeeded / Failed / Skipped / Total] 148 / 187 / 2 / 337:  34%|███▎      | 337/1000 [55:26<1:49:04,  9.87s/it][Succeeded / Failed / Skipped / Total] 148 / 187 / 2 / 337:  34%|███▍      | 338/1000 [56:17<1:50:15,  9.99s/it]Resolves all of the given types . --> [[[FAILED]]]

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int [[t]] = 0 ; [[t]] < [[types]] . length ; [[t]] ++ ) { [[result]] [ [[t]] ] = resolve ( [[types]] [ [[t]] ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[yokosuka]] ( Type [ ] [[bangers]] ) { TypeLiteral < ? > [ ] [[replication]] = new TypeLiteral < ? > [ [[bangers]] . length ] ; for ( int [[beetje]] = 0 ; [[beetje]] < [[bangers]] . length ; [[beetje]] ++ ) { [[replication]] [ [[beetje]] ] = resolve ( [[bangers]] [ [[beetje]] ] ) ; } return ImmutableList . copyOf ( [[replication]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 332 ---------------------------------------------
Canonicalizes a type literal for a key . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[canonicalizeForKey]] ( TypeLiteral < T > typeLiteral ) { Type [[type]] = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( [[type]] ) ) { Errors [[errors]] = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( [[errors]] . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[parameterizedType]] = ( ParameterizedType ) [[type]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[hiawatha]] ( TypeLiteral < T > typeLiteral ) { Type [[puerta]] = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( [[puerta]] ) ) { Errors [[drugstores]] = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( [[drugstores]] . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[memorize]] = ( ParameterizedType ) [[puerta]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 333 ---------------------------------------------
Generates an annotation for the given annotation type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[dum]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 334 ---------------------------------------------
Returns true if the given member is publicly callable . --> Musée à Musée --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[ahman]] ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "[[Musée]]" != "[[Musée]]" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[Musée]]" != "[[Musée]]" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[Musée]]" != "[[Musée]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 335 ---------------------------------------------
Checks if the class loader has the same version of cglib . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[dusseldorf]] ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 336 ---------------------------------------------
Adds the servlet request dispatcher to the request . --> Purer als deteriorated servlets --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest [[servletRequest]] , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[purer]] ( ServletRequest [[durante]] , final ManagedServletPipeline [[deteriorated]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 337 ---------------------------------------------
Creates a new instance of this class . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[zagreb]] ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "[[Storytellers]]" == "[[Storytellers]]" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 338 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 149 / 187 / 2 / 338:  34%|███▍      | 338/1000 [56:17<1:50:15,  9.99s/it][Succeeded / Failed / Skipped / Total] 149 / 187 / 2 / 338:  34%|███▍      | 339/1000 [56:24<1:49:58,  9.98s/it][Succeeded / Failed / Skipped / Total] 149 / 188 / 2 / 339:  34%|███▍      | 339/1000 [56:24<1:49:58,  9.98s/it][Succeeded / Failed / Skipped / Total] 149 / 188 / 2 / 339:  34%|███▍      | 340/1000 [56:25<1:49:31,  9.96s/it][Succeeded / Failed / Skipped / Total] 149 / 189 / 2 / 340:  34%|███▍      | 340/1000 [56:25<1:49:31,  9.96s/it][Succeeded / Failed / Skipped / Total] 149 / 189 / 2 / 340:  34%|███▍      | 341/1000 [56:36<1:49:23,  9.96s/it][Succeeded / Failed / Skipped / Total] 149 / 190 / 2 / 341:  34%|███▍      | 341/1000 [56:36<1:49:23,  9.96s/it][Succeeded / Failed / Skipped / Total] 149 / 190 / 2 / 341:  34%|███▍      | 342/1000 [56:44<1:49:11,  9.96s/it][Succeeded / Failed / Skipped / Total] 149 / 191 / 2 / 342:  34%|███▍      | 342/1000 [56:44<1:49:11,  9.96s/it][Succeeded / Failed / Skipped / Total] 149 / 191 / 2 / 342:  34%|███▍      | 343/1000 [56:50<1:48:53,  9.94s/it][Succeeded / Failed / Skipped / Total] 150 / 191 / 2 / 343:  34%|███▍      | 343/1000 [56:50<1:48:53,  9.94s/it][Succeeded / Failed / Skipped / Total] 150 / 191 / 2 / 343:  34%|███▍      | 344/1000 [57:04<1:48:51,  9.96s/it][Succeeded / Failed / Skipped / Total] 150 / 192 / 2 / 344:  34%|███▍      | 344/1000 [57:04<1:48:51,  9.96s/it][Succeeded / Failed / Skipped / Total] 150 / 192 / 2 / 344:  34%|███▍      | 345/1000 [57:29<1:49:08, 10.00s/it]Normalize a path . --> Liefert den WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - WAKE - W --> Socre: 1.0

[[[[Adv]]]]: static String normalizePath ( String [[path]] ) { StringBuilder sb = new StringBuilder ( [[path]] . length ( ) ) ; int [[queryStart]] = [[path]] . indexOf ( ' ' ) ; String [[query]] = null ; if ( [[queryStart]] != - 1 ) { [[query]] = [[path]] . substring ( [[queryStart]] ) ; [[path]] = [[path]] . substring ( 0 , [[queryStart]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String normalizePath ( String [[wwill]] ) { StringBuilder sb = new StringBuilder ( [[wwill]] . length ( ) ) ; int [[eragon]] = [[wwill]] . indexOf ( ' ' ) ; String [[gentlewomen]] = null ; if ( [[eragon]] != - 1 ) { [[gentlewomen]] = [[wwill]] . substring ( [[eragon]] ) ; [[wwill]] = [[wwill]] . substring ( 0 , [[eragon]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 339 ---------------------------------------------
Checks if the given annotation is retained at runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention retention = [[annotationType]] . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[zuckerberg]] ( Class < ? extends Annotation > [[conman]] ) { Retention retention = [[conman]] . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 340 ---------------------------------------------
Returns the scope for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 341 ---------------------------------------------
Make an injectable for the given Scoping . --> [[[FAILED]]]

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl injector , Errors [[errors]] ) { Class < ? extends Annotation > [[scopeAnnotation]] = scoping . getScopeAnnotation ( ) ; if ( [[scopeAnnotation]] == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( [[scopeAnnotation]] ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } [[errors]] . scopeNotFound ( [[scopeAnnotation]] ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[milkshake]] ( Scoping scoping , InjectorImpl injector , Errors [[citrus]] ) { Class < ? extends Annotation > [[wiedersehen]] = scoping . getScopeAnnotation ( ) ; if ( [[wiedersehen]] == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( [[wiedersehen]] ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } [[citrus]] . scopeNotFound ( [[wiedersehen]] ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 342 ---------------------------------------------
Finds the scope annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > [[found]] = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[found]] != null ) { errors . duplicateScopeAnnotations ( [[found]] , annotationType ) ; } else { [[found]] = annotationType ; } } } return [[found]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[kym]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > [[placido]] = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[placido]] != null ) { errors . duplicateScopeAnnotations ( [[placido]] , annotationType ) ; } else { [[placido]] = annotationType ; } } } return [[placido]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 343 ---------------------------------------------
Adds a direct type binding . --> Muslimah muslimah muslimah muslimah muslimah --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder [[binder]] ) { [[binder]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[muslimah]] ( Binder [[twelves]] ) { [[twelves]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 344 ---------------------------------------------
Initializes the delegate . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > delegate ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[leftists]] ( Provider < T > delegate ) { checkState ( this . [[contreras]] == null , "delegate already initialized" ) ; this . [[contreras]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 345 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 150 / 193 / 2 / 345:  34%|███▍      | 345/1000 [57:29<1:49:08, 10.00s/it][Succeeded / Failed / Skipped / Total] 150 / 193 / 2 / 345:  35%|███▍      | 346/1000 [57:29<1:48:39,  9.97s/it][Succeeded / Failed / Skipped / Total] 150 / 194 / 2 / 346:  35%|███▍      | 346/1000 [57:29<1:48:39,  9.97s/it][Succeeded / Failed / Skipped / Total] 150 / 194 / 2 / 346:  35%|███▍      | 347/1000 [57:48<1:48:46, 10.00s/it][Succeeded / Failed / Skipped / Total] 150 / 195 / 2 / 347:  35%|███▍      | 347/1000 [57:48<1:48:46, 10.00s/it][Succeeded / Failed / Skipped / Total] 150 / 195 / 2 / 347:  35%|███▍      | 348/1000 [57:51<1:48:24,  9.98s/it][Succeeded / Failed / Skipped / Total] 150 / 196 / 2 / 348:  35%|███▍      | 348/1000 [57:51<1:48:24,  9.98s/it][Succeeded / Failed / Skipped / Total] 150 / 196 / 2 / 348:  35%|███▍      | 349/1000 [58:08<1:48:26,  9.99s/it][Succeeded / Failed / Skipped / Total] 150 / 197 / 2 / 349:  35%|███▍      | 349/1000 [58:08<1:48:26,  9.99s/it][Succeeded / Failed / Skipped / Total] 150 / 197 / 2 / 349:  35%|███▌      | 350/1000 [58:11<1:48:04,  9.98s/it][Succeeded / Failed / Skipped / Total] 151 / 197 / 2 / 350:  35%|███▌      | 350/1000 [58:11<1:48:04,  9.98s/it][Succeeded / Failed / Skipped / Total] 151 / 197 / 2 / 350:  35%|███▌      | 351/1000 [58:42<1:48:32, 10.03s/it][Succeeded / Failed / Skipped / Total] 151 / 198 / 2 / 351:  35%|███▌      | 351/1000 [58:42<1:48:32, 10.03s/it][Succeeded / Failed / Skipped / Total] 151 / 198 / 2 / 351:  35%|███▌      | 352/1000 [59:04<1:48:44, 10.07s/it]Returns the name of a key . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[zuckerberg]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 346 ---------------------------------------------
Returns the key for the given type member and annotations . --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member [[member]] , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , [[member]] , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member [[sledgehammer]] , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , [[sledgehammer]] , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 347 ---------------------------------------------
Gets the key for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[valueKey]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[valueKey]] ) ) ; return [[valueKey]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[coarse]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[coarse]] ) ) ; return [[coarse]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 348 ---------------------------------------------
Get a ConstructorInjector from the cache . --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[anesthesiology]] ( InjectionPoint [[mys]] , Errors [[rember]] ) throws ErrorsException { return cache . get ( [[mys]] , [[rember]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 349 ---------------------------------------------
Returns a collection of all assisted methods . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[gargoyle]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 350 ---------------------------------------------
Checks if the interceptor class has a scope annotation . --> Methode d ajout des liquors --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[annotation]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[annotation]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[liquors]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[crépuscule]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[crépuscule]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 351 ---------------------------------------------
Returns a module for the given module . --> [[[FAILED]]]

[[[[Adv]]]]: static Module forModule ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module forModule ( Module [[scheherazade]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 352 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 151 / 199 / 2 / 352:  35%|███▌      | 352/1000 [59:04<1:48:44, 10.07s/it][Succeeded / Failed / Skipped / Total] 151 / 199 / 2 / 352:  35%|███▌      | 353/1000 [59:04<1:48:16, 10.04s/it][Succeeded / Failed / Skipped / Total] 151 / 200 / 2 / 353:  35%|███▌      | 353/1000 [59:04<1:48:16, 10.04s/it][Succeeded / Failed / Skipped / Total] 151 / 200 / 2 / 353:  35%|███▌      | 354/1000 [59:10<1:47:58, 10.03s/it][Succeeded / Failed / Skipped / Total] 151 / 201 / 2 / 354:  35%|███▌      | 354/1000 [59:10<1:47:58, 10.03s/it][Succeeded / Failed / Skipped / Total] 151 / 201 / 2 / 354:  36%|███▌      | 355/1000 [59:44<1:48:33, 10.10s/it][Succeeded / Failed / Skipped / Total] 152 / 201 / 2 / 355:  36%|███▌      | 355/1000 [59:44<1:48:33, 10.10s/it][Succeeded / Failed / Skipped / Total] 152 / 201 / 2 / 355:  36%|███▌      | 356/1000 [59:48<1:48:11, 10.08s/it][Succeeded / Failed / Skipped / Total] 152 / 202 / 2 / 356:  36%|███▌      | 356/1000 [59:48<1:48:11, 10.08s/it][Succeeded / Failed / Skipped / Total] 152 / 202 / 2 / 356:  36%|███▌      | 357/1000 [59:53<1:47:53, 10.07s/it][Succeeded / Failed / Skipped / Total] 152 / 203 / 2 / 357:  36%|███▌      | 357/1000 [59:53<1:47:53, 10.07s/it][Succeeded / Failed / Skipped / Total] 152 / 203 / 2 / 357:  36%|███▌      | 358/1000 [59:59<1:47:34, 10.05s/it]Create a new instance of the given construction context . --> [[[FAILED]]]

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[t]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[prodded]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[marion]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[marion]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[marion]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 353 ---------------------------------------------
Write a replace message to the stream . --> [[[FAILED]]]

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[hanukkah]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 354 ---------------------------------------------
Creates a new map binder with the specified key and value type and annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 355 ---------------------------------------------
Invoke the method on the proxy . --> Enchanté à horsemeat --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method [[method]] , final Object [ ] [[args]] ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method [[enchanté]] , final Object [ ] [[horsemeat]] ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 356 ---------------------------------------------
Returns an error message that indicates that no implementation for the given key was bound . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[vibrato]] = new StringBuilder ( ) ; [[vibrato]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 357 ---------------------------------------------
Checks if a constructor has matching parameters . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 358 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 152 / 204 / 2 / 358:  36%|███▌      | 358/1000 [59:59<1:47:34, 10.05s/it][Succeeded / Failed / Skipped / Total] 152 / 204 / 2 / 358:  36%|███▌      | 359/1000 [1:00:31<1:48:04, 10.12s/it][Succeeded / Failed / Skipped / Total] 152 / 205 / 2 / 359:  36%|███▌      | 359/1000 [1:00:31<1:48:04, 10.12s/it][Succeeded / Failed / Skipped / Total] 152 / 205 / 2 / 359:  36%|███▌      | 360/1000 [1:00:35<1:47:42, 10.10s/it][Succeeded / Failed / Skipped / Total] 152 / 206 / 2 / 360:  36%|███▌      | 360/1000 [1:00:35<1:47:42, 10.10s/it][Succeeded / Failed / Skipped / Total] 152 / 206 / 2 / 360:  36%|███▌      | 361/1000 [1:00:46<1:47:35, 10.10s/it][Succeeded / Failed / Skipped / Total] 152 / 207 / 2 / 361:  36%|███▌      | 361/1000 [1:00:46<1:47:35, 10.10s/it][Succeeded / Failed / Skipped / Total] 152 / 207 / 2 / 361:  36%|███▌      | 362/1000 [1:01:06<1:47:42, 10.13s/it][Succeeded / Failed / Skipped / Total] 152 / 208 / 2 / 362:  36%|███▌      | 362/1000 [1:01:06<1:47:42, 10.13s/it][Succeeded / Failed / Skipped / Total] 152 / 208 / 2 / 362:  36%|███▋      | 363/1000 [1:01:10<1:47:20, 10.11s/it][Succeeded / Failed / Skipped / Total] 152 / 209 / 2 / 363:  36%|███▋      | 363/1000 [1:01:10<1:47:20, 10.11s/it][Succeeded / Failed / Skipped / Total] 152 / 209 / 2 / 363:  36%|███▋      | 364/1000 [1:01:27<1:47:23, 10.13s/it][Succeeded / Failed / Skipped / Total] 152 / 210 / 2 / 364:  36%|███▋      | 364/1000 [1:01:27<1:47:23, 10.13s/it][Succeeded / Failed / Skipped / Total] 152 / 210 / 2 / 364:  36%|███▋      | 365/1000 [1:01:31<1:47:02, 10.11s/it]Checks if a type is not specified . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[aymara]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 359 ---------------------------------------------
Returns the injection point for the constructor . --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[dorinda]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 360 ---------------------------------------------
Returns a set of dependencies for the given constructor and the given implementation . --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint ctorPoint , TypeLiteral < ? > [[implementation]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! [[implementation]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( [[implementation]] ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[cataloguing]] ( InjectionPoint ctorPoint , TypeLiteral < ? > [[username]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! [[username]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( [[username]] ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 361 ---------------------------------------------
Get the binding from a new injector . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method [[method]] , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method [[costel]] , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 362 ---------------------------------------------
Returns true if the constructor has at inject annotation . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[nineteenth]] ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 363 ---------------------------------------------
Returns true if the given dependencies are valid for an optimized assisted inject . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 364 ---------------------------------------------
Remove assisted dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[dep]] : [[deps]] ) { Class < ? > annotationType = [[dep]] . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( [[dep]] ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[valentini]] ( Set < Dependency < ? > > [[experiments]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[leaving]] : [[experiments]] ) { Class < ? > annotationType = [[leaving]] . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( [[leaving]] ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 365 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 153 / 210 / 2 / 365:  36%|███▋      | 365/1000 [1:01:31<1:47:02, 10.11s/it][Succeeded / Failed / Skipped / Total] 153 / 210 / 2 / 365:  37%|███▋      | 366/1000 [1:01:44<1:46:57, 10.12s/it][Succeeded / Failed / Skipped / Total] 154 / 210 / 2 / 366:  37%|███▋      | 366/1000 [1:01:44<1:46:57, 10.12s/it][Succeeded / Failed / Skipped / Total] 154 / 211 / 2 / 367:  37%|███▋      | 367/1000 [1:01:44<1:46:29, 10.09s/it][Succeeded / Failed / Skipped / Total] 154 / 211 / 2 / 367:  37%|███▋      | 368/1000 [1:02:13<1:46:51, 10.15s/it][Succeeded / Failed / Skipped / Total] 154 / 212 / 2 / 368:  37%|███▋      | 368/1000 [1:02:13<1:46:51, 10.15s/it][Succeeded / Failed / Skipped / Total] 154 / 212 / 2 / 368:  37%|███▋      | 369/1000 [1:02:24<1:46:43, 10.15s/it][Succeeded / Failed / Skipped / Total] 154 / 213 / 2 / 369:  37%|███▋      | 369/1000 [1:02:24<1:46:43, 10.15s/it][Succeeded / Failed / Skipped / Total] 154 / 213 / 2 / 369:  37%|███▋      | 370/1000 [1:02:41<1:46:44, 10.17s/it][Succeeded / Failed / Skipped / Total] 154 / 214 / 2 / 370:  37%|███▋      | 370/1000 [1:02:41<1:46:44, 10.17s/it][Succeeded / Failed / Skipped / Total] 154 / 214 / 2 / 370:  37%|███▋      | 371/1000 [1:02:50<1:46:32, 10.16s/it][Succeeded / Failed / Skipped / Total] 154 / 215 / 2 / 371:  37%|███▋      | 371/1000 [1:02:50<1:46:32, 10.16s/it][Succeeded / Failed / Skipped / Total] 154 / 215 / 2 / 371:  37%|███▋      | 372/1000 [1:02:53<1:46:10, 10.14s/it][Succeeded / Failed / Skipped / Total] 154 / 216 / 2 / 372:  37%|███▋      | 372/1000 [1:02:53<1:46:10, 10.14s/it][Succeeded / Failed / Skipped / Total] 154 / 216 / 2 / 372:  37%|███▋      | 373/1000 [1:03:13<1:46:16, 10.17s/it]Find the next matching filter . --> Maricón do maricón --> Socre: 1.0

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest [[request]] ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( [[request]] ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[maricón]] ( HttpServletRequest [[samehada]] ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( [[samehada]] ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 366 ---------------------------------------------
Initializes the lookup manager . --> Processes a joelle footie --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[footie]] ( Errors [[joelle]] ) { injector . lookups = injector ; new LookupProcessor ( [[joelle]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 367 ---------------------------------------------
Returns a set of internal dependencies for this factory . --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[greedier]] ( ) { ImmutableSet . Builder < InjectionPoint > [[tojo]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[tojo]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 368 ---------------------------------------------
Returns the line number of the given member . --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[fredericksburg]] ( Member [[dewdrops]] ) { Preconditions . checkArgument ( type == [[dewdrops]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[dewdrops]] , [[dewdrops]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[dewdrops]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 369 ---------------------------------------------
Creates a new multibinder that is bound to the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[result]] = new RealMultibinder <> ( binder , key ) ; binder . install ( [[result]] ) ; return [[result]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[chewed]] = new RealMultibinder <> ( binder , key ) ; binder . install ( [[chewed]] ) ; return [[chewed]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 370 ---------------------------------------------
Transfers a request to a callable . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[bellingham]] ( Callable < T > [[michael]] ) { return wrap ( [[michael]] , [[bellingham]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 371 ---------------------------------------------
Returns the annotation claimed by the given method . --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation getAnnotation ( Binder [[binder]] , Method [[method]] ) { if ( [[method]] . isBridge ( ) || [[method]] . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = [[method]] . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[annotation]] != null ) { [[binder]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , [[method]] ) ; return null ; } [[annotation]] = foundAnnotation ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder [[kelley]] , Method [[inhale]] ) { if ( [[inhale]] . isBridge ( ) || [[inhale]] . isSynthetic ( ) ) { return null ; } Annotation [[midsummer]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = [[inhale]] . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[midsummer]] != null ) { [[kelley]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , [[inhale]] ) ; return null ; } [[midsummer]] = foundAnnotation ; } } return [[midsummer]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 372 ---------------------------------------------
Returns a Module for the given module . --> [[[FAILED]]]

[[[[Adv]]]]: public static Module [[forModule]] ( Object module , ModuleAnnotatedMethodScanner scanner ) { return forObject ( module , "[[False]]" != "[[False]]" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[zuckerberg]] ( Object module , ModuleAnnotatedMethodScanner scanner ) { return forObject ( module , "[[Gaston]]" != "[[Gaston]]" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 373 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 155 / 216 / 2 / 373:  37%|███▋      | 373/1000 [1:03:13<1:46:16, 10.17s/it][Succeeded / Failed / Skipped / Total] 155 / 216 / 2 / 373:  37%|███▋      | 374/1000 [1:03:35<1:46:26, 10.20s/it][Succeeded / Failed / Skipped / Total] 155 / 217 / 2 / 374:  37%|███▋      | 374/1000 [1:03:35<1:46:26, 10.20s/it][Succeeded / Failed / Skipped / Total] 155 / 217 / 2 / 374:  38%|███▊      | 375/1000 [1:03:44<1:46:14, 10.20s/it][Succeeded / Failed / Skipped / Total] 155 / 218 / 2 / 375:  38%|███▊      | 375/1000 [1:03:44<1:46:14, 10.20s/it][Succeeded / Failed / Skipped / Total] 155 / 218 / 2 / 375:  38%|███▊      | 376/1000 [1:04:03<1:46:17, 10.22s/it][Succeeded / Failed / Skipped / Total] 155 / 219 / 2 / 376:  38%|███▊      | 376/1000 [1:04:03<1:46:17, 10.22s/it][Succeeded / Failed / Skipped / Total] 155 / 219 / 2 / 376:  38%|███▊      | 377/1000 [1:04:13<1:46:07, 10.22s/it][Succeeded / Failed / Skipped / Total] 155 / 220 / 2 / 377:  38%|███▊      | 377/1000 [1:04:13<1:46:07, 10.22s/it][Succeeded / Failed / Skipped / Total] 155 / 220 / 2 / 377:  38%|███▊      | 378/1000 [1:04:15<1:45:44, 10.20s/it]Returns a callable that will continue the execution of the given callable with the given seed map . --> Salcedo aleichem aleichem --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > [[seedMap]] ) { return wrap ( [[callable]] , [[continueRequest]] ( [[seedMap]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[salcedo]] ( Callable < T > [[aleichem]] , Map < Key < ? > , Object > [[curl]] ) { return wrap ( [[aleichem]] , [[salcedo]] ( [[curl]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 374 ---------------------------------------------
Validate and canonicalize a value . --> [[[FAILED]]]

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object [[object]] ) { if ( [[object]] == null || [[object]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[object]] ) ) { throw new IllegalArgumentException ( "Value[" + [[object]] + "] of type[" + [[object]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[object]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[galaxy]] ( Key < ? > key , Object [[tsung]] ) { if ( [[tsung]] == null || [[tsung]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[tsung]] ) ) { throw new IllegalArgumentException ( "Value[" + [[tsung]] + "] of type[" + [[tsung]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[tsung]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 375 ---------------------------------------------
Returns the source of the binding . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[haemorrhage]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 376 ---------------------------------------------
Returns a strategy for the given annotation type . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[susceptible]] ( Class < ? extends Annotation > [[neurons]] ) { [[neurons]] = Annotations . canonicalizeIfNamed ( [[neurons]] ) ; if ( isAllDefaultMethods ( [[neurons]] ) ) { return [[susceptible]] ( generateAnnotation ( [[neurons]] ) ) ; } checkNotNull ( [[neurons]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[neurons]] ) ; ensureIsBindingAnnotation ( [[neurons]] ) ; return new AnnotationTypeStrategy ( [[neurons]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 377 ---------------------------------------------
Creates a new members injector with listeners for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 378 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 155 / 221 / 2 / 378:  38%|███▊      | 378/1000 [1:04:15<1:45:44, 10.20s/it][Succeeded / Failed / Skipped / Total] 155 / 221 / 2 / 378:  38%|███▊      | 379/1000 [1:04:29<1:45:40, 10.21s/it][Succeeded / Failed / Skipped / Total] 155 / 222 / 2 / 379:  38%|███▊      | 379/1000 [1:04:29<1:45:40, 10.21s/it][Succeeded / Failed / Skipped / Total] 155 / 222 / 2 / 379:  38%|███▊      | 380/1000 [1:04:45<1:45:39, 10.22s/it][Succeeded / Failed / Skipped / Total] 156 / 222 / 2 / 380:  38%|███▊      | 380/1000 [1:04:45<1:45:39, 10.22s/it][Succeeded / Failed / Skipped / Total] 156 / 222 / 2 / 380:  38%|███▊      | 381/1000 [1:05:10<1:45:53, 10.26s/it][Succeeded / Failed / Skipped / Total] 156 / 223 / 2 / 381:  38%|███▊      | 381/1000 [1:05:10<1:45:53, 10.26s/it][Succeeded / Failed / Skipped / Total] 156 / 223 / 2 / 381:  38%|███▊      | 382/1000 [1:05:41<1:46:16, 10.32s/it][Succeeded / Failed / Skipped / Total] 156 / 224 / 2 / 382:  38%|███▊      | 382/1000 [1:05:41<1:46:16, 10.32s/it][Succeeded / Failed / Skipped / Total] 156 / 224 / 2 / 382:  38%|███▊      | 383/1000 [1:05:44<1:45:54, 10.30s/it]Returns a new key for the given type and annotation strategy . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > [[acquainted]] , AnnotationStrategy [[bennie]] ) { return new Key < T > ( [[acquainted]] , [[bennie]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 379 ---------------------------------------------
Returns a strategy for the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , annotation ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[niles]] ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > [[tightened]] = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( [[tightened]] ) ; ensureIsBindingAnnotation ( [[tightened]] ) ; if ( Annotations . isMarker ( [[tightened]] ) ) { return new AnnotationTypeStrategy ( [[tightened]] , annotation ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 380 ---------------------------------------------
Prunes the stack trace of a throwable . --> Lawmakers lawmakers --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable [[t]] = throwable ; [[t]] != null ; [[t]] = [[t]] . getCause ( ) ) { StackTraceElement [ ] stackTrace = [[t]] . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } [[t]] . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[lawmakers]] ( Throwable throwable ) { for ( Throwable [[attaché]] = throwable ; [[attaché]] != null ; [[attaché]] = [[attaché]] . getCause ( ) ) { StackTraceElement [ ] stackTrace = [[attaché]] . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } [[attaché]] . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 381 ---------------------------------------------
Gets the injectors for the given set of injection points . --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[injectionPoint]] : injectionPoints ) { try { Errors errorsForMember = [[injectionPoint]] . isOptional ( ) ? new Errors ( [[injectionPoint]] ) : errors . withSource ( [[injectionPoint]] ) ; SingleMemberInjector [[injector]] = [[injectionPoint]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , [[injectionPoint]] , errorsForMember ) : new SingleMethodInjector ( this . injector , [[injectionPoint]] , errorsForMember ) ; [[injectors]] . add ( [[injector]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[appétit]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[incisors]] : injectionPoints ) { try { Errors errorsForMember = [[incisors]] . isOptional ( ) ? new Errors ( [[incisors]] ) : errors . withSource ( [[incisors]] ) ; SingleMemberInjector [[column]] = [[incisors]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , [[incisors]] , errorsForMember ) : new SingleMethodInjector ( this . injector , [[incisors]] , errorsForMember ) ; [[appétit]] . add ( [[column]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 382 ---------------------------------------------
Returns true if the class should be skipped . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[czechoslovak]] ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 383 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 156 / 225 / 2 / 383:  38%|███▊      | 383/1000 [1:05:44<1:45:54, 10.30s/it][Succeeded / Failed / Skipped / Total] 156 / 225 / 2 / 383:  38%|███▊      | 384/1000 [1:06:07<1:46:04, 10.33s/it][Succeeded / Failed / Skipped / Total] 156 / 226 / 2 / 384:  38%|███▊      | 384/1000 [1:06:07<1:46:04, 10.33s/it][Succeeded / Failed / Skipped / Total] 156 / 226 / 2 / 384:  38%|███▊      | 385/1000 [1:06:13<1:45:47, 10.32s/it][Succeeded / Failed / Skipped / Total] 156 / 227 / 2 / 385:  38%|███▊      | 385/1000 [1:06:13<1:45:47, 10.32s/it][Succeeded / Failed / Skipped / Total] 156 / 227 / 2 / 385:  39%|███▊      | 386/1000 [1:06:31<1:45:49, 10.34s/it][Succeeded / Failed / Skipped / Total] 157 / 227 / 2 / 386:  39%|███▊      | 386/1000 [1:06:31<1:45:49, 10.34s/it][Succeeded / Failed / Skipped / Total] 157 / 227 / 2 / 386:  39%|███▊      | 387/1000 [1:06:36<1:45:29, 10.33s/it][Succeeded / Failed / Skipped / Total] 157 / 228 / 2 / 387:  39%|███▊      | 387/1000 [1:06:36<1:45:29, 10.33s/it][Succeeded / Failed / Skipped / Total] 157 / 228 / 2 / 387:  39%|███▉      | 388/1000 [1:06:47<1:45:20, 10.33s/it][Succeeded / Failed / Skipped / Total] 157 / 229 / 2 / 388:  39%|███▉      | 388/1000 [1:06:47<1:45:20, 10.33s/it][Succeeded / Failed / Skipped / Total] 157 / 229 / 2 / 388:  39%|███▉      | 389/1000 [1:06:49<1:44:57, 10.31s/it]Formats a list of error messages . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[formatMessages]] ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[i]] = dependencies . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { Object [[source]] = dependencies . get ( [[i]] ) ; formatSource ( fmt , [[source]] ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String [[cathartic]] ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[paganini]] = dependencies . size ( ) - 1 ; [[paganini]] >= 0 ; [[paganini]] -- ) { Object [[kyung]] = dependencies . get ( [[paganini]] ) ; formatSource ( fmt , [[kyung]] ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 384 ---------------------------------------------
Creates a new message with the given message format and arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( String messageFormat , Object ... [[arguments]] ) { return [[create]] ( null , messageFormat , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[sportswriter]] ( String messageFormat , Object ... [[majestically]] ) { return [[sportswriter]] ( null , messageFormat , [[majestically]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 385 ---------------------------------------------
Convert an object to an object . --> [[[FAILED]]]

[[[[Adv]]]]: static Object convert ( Object [[o]] ) { ElementSource source = null ; if ( [[o]] instanceof ElementSource ) { source = ( ElementSource ) [[o]] ; [[o]] = source . getDeclaringSource ( ) ; } return convert ( [[o]] , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object convert ( Object [[davers]] ) { ElementSource source = null ; if ( [[davers]] instanceof ElementSource ) { source = ( ElementSource ) [[davers]] ; [[davers]] = source . getDeclaringSource ( ) ; } return convert ( [[davers]] , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 386 ---------------------------------------------
Provision a provider . --> Provision the given provider into the given burdensome --> Socre: 1.0

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[constructionContext]] . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > [[burdensome]] ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[burdensome]] . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 387 ---------------------------------------------
Creates a new exception message . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 388 ---------------------------------------------
Creates a new message with the given message format and arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String messageFormat , Object ... arguments ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[inhospitable]] ( Throwable [[warhammer]] , String messageFormat , Object ... arguments ) { return [[inhospitable]] ( [[warhammer]] , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 389 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 157 / 230 / 2 / 389:  39%|███▉      | 389/1000 [1:06:49<1:44:57, 10.31s/it][Succeeded / Failed / Skipped / Total] 157 / 230 / 2 / 389:  39%|███▉      | 390/1000 [1:06:49<1:44:31, 10.28s/it][Succeeded / Failed / Skipped / Total] 157 / 230 / 3 / 390:  39%|███▉      | 390/1000 [1:06:49<1:44:31, 10.28s/it][Succeeded / Failed / Skipped / Total] 157 / 230 / 3 / 390:  39%|███▉      | 391/1000 [1:07:03<1:44:26, 10.29s/it][Succeeded / Failed / Skipped / Total] 158 / 230 / 3 / 391:  39%|███▉      | 391/1000 [1:07:03<1:44:26, 10.29s/it][Succeeded / Failed / Skipped / Total] 158 / 230 / 3 / 391:  39%|███▉      | 392/1000 [1:07:15<1:44:19, 10.30s/it][Succeeded / Failed / Skipped / Total] 158 / 231 / 3 / 392:  39%|███▉      | 392/1000 [1:07:15<1:44:19, 10.30s/it][Succeeded / Failed / Skipped / Total] 158 / 231 / 3 / 392:  39%|███▉      | 393/1000 [1:07:28<1:44:13, 10.30s/it][Succeeded / Failed / Skipped / Total] 158 / 232 / 3 / 393:  39%|███▉      | 393/1000 [1:07:28<1:44:13, 10.30s/it][Succeeded / Failed / Skipped / Total] 158 / 232 / 3 / 393:  39%|███▉      | 394/1000 [1:07:37<1:44:01, 10.30s/it][Succeeded / Failed / Skipped / Total] 158 / 233 / 3 / 394:  39%|███▉      | 394/1000 [1:07:37<1:44:01, 10.30s/it][Succeeded / Failed / Skipped / Total] 158 / 233 / 3 / 394:  40%|███▉      | 395/1000 [1:07:40<1:43:39, 10.28s/it][Succeeded / Failed / Skipped / Total] 159 / 233 / 3 / 395:  40%|███▉      | 395/1000 [1:07:40<1:43:39, 10.28s/it][Succeeded / Failed / Skipped / Total] 159 / 233 / 3 / 395:  40%|███▉      | 396/1000 [1:07:43<1:43:17, 10.26s/it][Succeeded / Failed / Skipped / Total] 159 / 234 / 3 / 396:  40%|███▉      | 396/1000 [1:07:43<1:43:17, 10.26s/it][Succeeded / Failed / Skipped / Total] 159 / 234 / 3 / 396:  40%|███▉      | 397/1000 [1:07:46<1:42:56, 10.24s/it]Get the stack trace from a list of module class names . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[yesss]] ( List < String > [[fugitives]] ) { Preconditions . checkNotNull ( [[fugitives]] , "The list of module class names cannot be null." ) ; for ( final String [[stimuli]] : [[fugitives]] ) { if ( ! shouldBeSkipped ( [[stimuli]] ) ) { return new StackTraceElement ( [[stimuli]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 390 ---------------------------------------------
Throws an exception if it is an unchecked exception . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 391 ---------------------------------------------
Pushes a state to the stack . --> Pelvic a comstock downsizing --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > [[key]] , Object [[source]] ) { doPushState ( [[key]] , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[pelvic]] ( com . google . inject . Key < ? > [[comstock]] , Object [[downsizing]] ) { doPushState ( [[comstock]] , [[downsizing]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 392 ---------------------------------------------
Main entry point . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[main]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[enthusiasts]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 393 ---------------------------------------------
Returns a new instance of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[sandrock]] ( final T [[exerted]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[exerted]] ; } @ Override public String toString ( ) { return String . valueOf ( [[exerted]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 394 ---------------------------------------------
Pushes a dependency to the stack . --> [[[FAILED]]]

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = [[dependency]] ; doPushState ( [[dependency]] , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[haruka]] ( Dependency < ? > [[gitmo]] , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = [[gitmo]] ; doPushState ( [[gitmo]] , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 395 ---------------------------------------------
Called when a connection event is received . --> Send a connection event to all registered blossoms --> Socre: 1.0

[[[[Adv]]]]: public void [[onEvent]] ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > [[processorList]] = this . [[processors]] . get ( type ) ; if ( [[processorList]] != null ) { for ( ConnectionEventProcessor processor : [[processorList]] ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void [[leão]] ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > [[blossoms]] = this . [[ernestine]] . get ( type ) ; if ( [[blossoms]] != null ) { for ( ConnectionEventProcessor processor : [[blossoms]] ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 396 ---------------------------------------------
Get the result of a future task . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[aurora]] > [[aurora]] getFutureTaskResult ( RunStateRecordedFutureTask < [[aurora]] > task , Logger logger ) { [[aurora]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 397 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 160 / 234 / 3 / 397:  40%|███▉      | 397/1000 [1:07:46<1:42:56, 10.24s/it][Succeeded / Failed / Skipped / Total] 160 / 234 / 3 / 397:  40%|███▉      | 398/1000 [1:07:49<1:42:35, 10.22s/it][Succeeded / Failed / Skipped / Total] 161 / 234 / 3 / 398:  40%|███▉      | 398/1000 [1:07:49<1:42:35, 10.22s/it][Succeeded / Failed / Skipped / Total] 161 / 234 / 3 / 398:  40%|███▉      | 399/1000 [1:07:52<1:42:14, 10.21s/it][Succeeded / Failed / Skipped / Total] 162 / 234 / 3 / 399:  40%|███▉      | 399/1000 [1:07:52<1:42:14, 10.21s/it][Succeeded / Failed / Skipped / Total] 162 / 234 / 3 / 399:  40%|████      | 400/1000 [1:08:01<1:42:02, 10.20s/it][Succeeded / Failed / Skipped / Total] 163 / 234 / 3 / 400:  40%|████      | 400/1000 [1:08:01<1:42:02, 10.20s/it][Succeeded / Failed / Skipped / Total] 163 / 234 / 3 / 400:  40%|████      | 401/1000 [1:08:05<1:41:42, 10.19s/it][Succeeded / Failed / Skipped / Total] 164 / 234 / 3 / 401:  40%|████      | 401/1000 [1:08:05<1:41:42, 10.19s/it][Succeeded / Failed / Skipped / Total] 164 / 234 / 3 / 401:  40%|████      | 402/1000 [1:08:10<1:41:24, 10.17s/it][Succeeded / Failed / Skipped / Total] 165 / 234 / 3 / 402:  40%|████      | 402/1000 [1:08:10<1:41:24, 10.17s/it][Succeeded / Failed / Skipped / Total] 165 / 234 / 3 / 402:  40%|████      | 403/1000 [1:08:21<1:41:15, 10.18s/it][Succeeded / Failed / Skipped / Total] 166 / 234 / 3 / 403:  40%|████      | 403/1000 [1:08:21<1:41:15, 10.18s/it][Succeeded / Failed / Skipped / Total] 166 / 234 / 3 / 403:  40%|████      | 404/1000 [1:08:31<1:41:05, 10.18s/it][Succeeded / Failed / Skipped / Total] 167 / 234 / 3 / 404:  40%|████      | 404/1000 [1:08:31<1:41:05, 10.18s/it][Succeeded / Failed / Skipped / Total] 167 / 234 / 3 / 404:  40%|████      | 405/1000 [1:08:37<1:40:48, 10.17s/it]Registers the default processor . --> Daniel a RemotingProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > [[processor]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[processor]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[daniel]] ( RemotingProcessor < ? > [[fla]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[fla]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 398 ---------------------------------------------
Try to get a url . --> Returns the pollining url for the given url . --> Socre: 1.0

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > [[softRef]] = Url . parsedUrls . get ( url ) ; return ( null == [[softRef]] ) ? null : [[softRef]] . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > [[pollinating]] = Url . parsedUrls . get ( url ) ; return ( null == [[pollinating]] ) ? null : [[pollinating]] . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 399 ---------------------------------------------
Returns a connection for the given url if it does not exist . --> Marek a connection to a remote host --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[marek]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 400 ---------------------------------------------
Decodes the protocol code . --> Liefert die fiancées . --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode decodeProtocolCode ( ByteBuf [[in]] ) { if ( [[in]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; [[in]] . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode decodeProtocolCode ( ByteBuf [[fiancées]] ) { if ( [[fiancées]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; [[fiancées]] . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 401 ---------------------------------------------
Heal if need . --> Czechoslovakia . --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[czechoslovakia]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 402 ---------------------------------------------
Scan all connections . --> Adiós . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[scan]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void [[adiós]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 403 ---------------------------------------------
Create a connection and heal if need . --> DITKA - DITKA --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[ditka]] ( Url [[airspace]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 404 ---------------------------------------------
Create a connection . --> Schreibt die Kimonos . --> Socre: 1.0

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String [[taskName]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int [[actualNum]] = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( [[actualNum]] < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , [[actualNum]] , expectNum , [[taskName]] ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = [[actualNum]] ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String [[kimonos]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int [[diverted]] = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( [[diverted]] < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , [[diverted]] , expectNum , [[kimonos]] ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = [[diverted]] ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 405 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 168 / 234 / 3 / 405:  40%|████      | 405/1000 [1:08:37<1:40:48, 10.17s/it][Succeeded / Failed / Skipped / Total] 169 / 234 / 3 / 406:  41%|████      | 406/1000 [1:08:37<1:40:23, 10.14s/it][Succeeded / Failed / Skipped / Total] 169 / 234 / 3 / 406:  41%|████      | 407/1000 [1:08:49<1:40:17, 10.15s/it][Succeeded / Failed / Skipped / Total] 169 / 235 / 3 / 407:  41%|████      | 407/1000 [1:08:49<1:40:17, 10.15s/it][Succeeded / Failed / Skipped / Total] 169 / 235 / 3 / 407:  41%|████      | 408/1000 [1:09:35<1:40:58, 10.23s/it][Succeeded / Failed / Skipped / Total] 169 / 236 / 3 / 408:  41%|████      | 408/1000 [1:09:35<1:40:58, 10.23s/it][Succeeded / Failed / Skipped / Total] 169 / 236 / 3 / 408:  41%|████      | 409/1000 [1:09:49<1:40:53, 10.24s/it][Succeeded / Failed / Skipped / Total] 170 / 236 / 3 / 409:  41%|████      | 409/1000 [1:09:49<1:40:53, 10.24s/it][Succeeded / Failed / Skipped / Total] 170 / 236 / 3 / 409:  41%|████      | 410/1000 [1:09:50<1:40:30, 10.22s/it][Succeeded / Failed / Skipped / Total] 170 / 237 / 3 / 410:  41%|████      | 410/1000 [1:09:50<1:40:30, 10.22s/it][Succeeded / Failed / Skipped / Total] 170 / 237 / 3 / 410:  41%|████      | 411/1000 [1:09:54<1:40:10, 10.20s/it][Succeeded / Failed / Skipped / Total] 171 / 237 / 3 / 411:  41%|████      | 411/1000 [1:09:54<1:40:10, 10.20s/it][Succeeded / Failed / Skipped / Total] 171 / 237 / 3 / 411:  41%|████      | 412/1000 [1:10:01<1:39:56, 10.20s/it][Succeeded / Failed / Skipped / Total] 172 / 237 / 3 / 412:  41%|████      | 412/1000 [1:10:01<1:39:56, 10.20s/it][Succeeded / Failed / Skipped / Total] 172 / 237 / 3 / 412:  41%|████▏     | 413/1000 [1:10:16<1:39:53, 10.21s/it]Closes a connection . --> Remove aurelie . --> Socre: 1.0

[[[[Adv]]]]: public void [[closeConnection]] ( String addr ) { Url url = this . [[addressParser]] . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void [[aurelie]] ( String addr ) { Url url = this . [[bookstores]] . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 406 ---------------------------------------------
Registers a remoting processor for the given command code . --> methamphetamine a RemotingProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode [[cmdCode]] , RemotingProcessor < ? > processor ) { if ( this . [[cmd2processors]] . containsKey ( [[cmdCode]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[cmdCode]] , cmd2processors . get ( [[cmdCode]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( [[cmdCode]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[methamphetamine]] ( CommandCode [[gaelic]] , RemotingProcessor < ? > processor ) { if ( this . [[diverted]] . containsKey ( [[gaelic]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[gaelic]] , cmd2processors . get ( [[gaelic]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[diverted]] . put ( [[gaelic]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 407 ---------------------------------------------
Adds a connection event processor . --> [[[FAILED]]]

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 408 ---------------------------------------------
Returns the processor for the given command code . --> [[[FAILED]]]

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 409 ---------------------------------------------
Remove a connection pool . --> Apologize a benda . --> Socre: 1.0

[[[[Adv]]]]: private void [[removeTask]] ( String [[poolKey]] ) { RunStateRecordedFutureTask < ConnectionPool > [[task]] = this . [[connTasks]] . remove ( [[poolKey]] ) ; if ( null != [[task]] ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[task]] , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void [[apologize]] ( String [[benda]] ) { RunStateRecordedFutureTask < ConnectionPool > [[negotiators]] = this . [[earthworms]] . remove ( [[benda]] ) ; if ( null != [[negotiators]] ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[negotiators]] , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 410 ---------------------------------------------
Returns a map of all connections in the pool . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 411 ---------------------------------------------
Adds an attribute to the map if it is not already present . --> Adds a trite to the list of attributes for the given haemorrhaging --> Socre: 1.0

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String [[key]] , Object [[value]] ) { return attributes . putIfAbsent ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String [[haemorrhaging]] , Object [[trite]] ) { return attributes . putIfAbsent ( [[haemorrhaging]] , [[trite]] ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 412 ---------------------------------------------
Dispatch to the user processor . --> Methode d ajout une addressing . --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte [[type]] = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[addressing]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte [[soirée]] = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 413 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 172 / 238 / 3 / 413:  41%|████▏     | 413/1000 [1:10:16<1:39:53, 10.21s/it][Succeeded / Failed / Skipped / Total] 172 / 238 / 3 / 413:  41%|████▏     | 414/1000 [1:10:21<1:39:35, 10.20s/it][Succeeded / Failed / Skipped / Total] 172 / 239 / 3 / 414:  41%|████▏     | 414/1000 [1:10:21<1:39:35, 10.20s/it][Succeeded / Failed / Skipped / Total] 172 / 239 / 3 / 414:  42%|████▏     | 415/1000 [1:10:43<1:39:42, 10.23s/it][Succeeded / Failed / Skipped / Total] 173 / 239 / 3 / 415:  42%|████▏     | 415/1000 [1:10:43<1:39:42, 10.23s/it][Succeeded / Failed / Skipped / Total] 173 / 239 / 3 / 415:  42%|████▏     | 416/1000 [1:10:47<1:39:22, 10.21s/it][Succeeded / Failed / Skipped / Total] 173 / 240 / 3 / 416:  42%|████▏     | 416/1000 [1:10:47<1:39:22, 10.21s/it][Succeeded / Failed / Skipped / Total] 173 / 240 / 3 / 416:  42%|████▏     | 417/1000 [1:10:50<1:39:02, 10.19s/it][Succeeded / Failed / Skipped / Total] 174 / 240 / 3 / 417:  42%|████▏     | 417/1000 [1:10:50<1:39:02, 10.19s/it][Succeeded / Failed / Skipped / Total] 174 / 240 / 3 / 417:  42%|████▏     | 418/1000 [1:10:52<1:38:40, 10.17s/it]Closes the connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 414 ---------------------------------------------
Called when the connection is closed . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture [[future]] = entry . getValue ( ) ; if ( [[future]] != null ) { [[future]] . putResponse ( [[future]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[future]] . cancelTimeout ( ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[strategically]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture [[bertha]] = entry . getValue ( ) ; if ( [[bertha]] != null ) { [[bertha]] . putResponse ( [[bertha]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[bertha]] . cancelTimeout ( ) ; [[bertha]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 415 ---------------------------------------------
Pre - process remoting context . --> Carine a request . --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext [[ctx]] , RpcRequestCommand cmd , long currentTimestamp ) { [[ctx]] . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; [[ctx]] . setTimeout ( cmd . getTimeout ( ) ) ; [[ctx]] . setRpcCommandType ( cmd . getType ( ) ) ; [[ctx]] . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[carine]] ( RemotingContext [[buffaloes]] , RpcRequestCommand cmd , long currentTimestamp ) { [[buffaloes]] . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; [[buffaloes]] . setTimeout ( cmd . getTimeout ( ) ) ; [[buffaloes]] . setRpcCommandType ( cmd . getType ( ) ) ; [[buffaloes]] . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 416 ---------------------------------------------
Registers a user processor . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) processor , [[userProcessors]] ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[nadja]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[tomoya]] ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[nadja]] ( ( MultiInterestUserProcessor ) processor , [[tomoya]] ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[tomoya]] . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 417 ---------------------------------------------
Debug log . --> Carb the discouragement . --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext ctx , RpcRequestCommand [[cmd]] , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , [[cmd]] . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , [[cmd]] . getId ( ) , currentTimestamp , [[cmd]] . getArriveTime ( ) , ( currentTimestamp - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[carb]] ( RemotingContext ctx , RpcRequestCommand [[discouragement]] , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , [[discouragement]] . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , [[discouragement]] . getId ( ) , currentTimestamp , [[discouragement]] . getArriveTime ( ) , ( currentTimestamp - [[discouragement]] . getArriveTime ( ) ) , [[discouragement]] . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 418 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 174 / 241 / 3 / 418:  42%|████▏     | 418/1000 [1:10:52<1:38:40, 10.17s/it][Succeeded / Failed / Skipped / Total] 174 / 241 / 3 / 418:  42%|████▏     | 419/1000 [1:10:53<1:38:17, 10.15s/it][Succeeded / Failed / Skipped / Total] 175 / 241 / 3 / 419:  42%|████▏     | 419/1000 [1:10:53<1:38:17, 10.15s/it][Succeeded / Failed / Skipped / Total] 175 / 241 / 3 / 419:  42%|████▏     | 420/1000 [1:10:56<1:37:58, 10.14s/it][Succeeded / Failed / Skipped / Total] 176 / 241 / 3 / 420:  42%|████▏     | 420/1000 [1:10:56<1:37:58, 10.14s/it][Succeeded / Failed / Skipped / Total] 176 / 241 / 3 / 420:  42%|████▏     | 421/1000 [1:10:57<1:37:35, 10.11s/it][Succeeded / Failed / Skipped / Total] 177 / 241 / 3 / 421:  42%|████▏     | 421/1000 [1:10:57<1:37:35, 10.11s/it][Succeeded / Failed / Skipped / Total] 177 / 241 / 3 / 421:  42%|████▏     | 422/1000 [1:11:00<1:37:15, 10.10s/it][Succeeded / Failed / Skipped / Total] 178 / 241 / 3 / 422:  42%|████▏     | 422/1000 [1:11:00<1:37:15, 10.10s/it][Succeeded / Failed / Skipped / Total] 178 / 241 / 3 / 422:  42%|████▏     | 423/1000 [1:11:18<1:37:15, 10.11s/it]Registers a user processor . --> [[[FAILED]]]

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == [[processor]] . multiInterest ( ) || [[processor]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[processor]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( interest , [[processor]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > [[botulism]] , ConcurrentHashMap < String , UserProcessor < ? > > [[leastwise]] ) { if ( null == [[botulism]] . multiInterest ( ) || [[botulism]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[botulism]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[leastwise]] . putIfAbsent ( interest , [[botulism]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 419 ---------------------------------------------
Sends a remoting command to the remote peer . --> Fianc les fiancées --> Socre: 1.0

[[[[Adv]]]]: protected void [[oneway]] ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void [[fiancées]] ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 420 ---------------------------------------------
Stop heal connection . --> This method is called when a connection is abandoned . --> Socre: 1.0

[[[[Adv]]]]: public void [[stop]] ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread

[[[[Adv]]]]: public void [[abandoned]] ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 421 ---------------------------------------------
Converts a bit set to a byte . --> Liefert die protégé . --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[protégé]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 422 ---------------------------------------------
Convert an integer to a bit set . --> Convert a Hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha --> Socre: 1.0

[[[[Adv]]]]: public static BitSet toBitSet ( int [[value]] ) { if ( [[value]] > Byte . MAX_VALUE || [[value]] < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + [[value]] + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( [[value]] != 0 ) { if ( [[value]] % 2 != 0 ) { bs . set ( index ) ; } ++ index ; [[value]] = ( byte ) ( [[value]] >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet toBitSet ( int [[hahahaha]] ) { if ( [[hahahaha]] > Byte . MAX_VALUE || [[hahahaha]] < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + [[hahahaha]] + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( [[hahahaha]] != 0 ) { if ( [[hahahaha]] % 2 != 0 ) { bs . set ( index ) ; } ++ index ; [[hahahaha]] = ( byte ) ( [[hahahaha]] >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 423 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 178 / 242 / 3 / 423:  42%|████▏     | 423/1000 [1:11:18<1:37:15, 10.11s/it][Succeeded / Failed / Skipped / Total] 178 / 242 / 3 / 423:  42%|████▏     | 424/1000 [1:11:20<1:36:54, 10.10s/it][Succeeded / Failed / Skipped / Total] 179 / 242 / 3 / 424:  42%|████▏     | 424/1000 [1:11:20<1:36:54, 10.10s/it][Succeeded / Failed / Skipped / Total] 179 / 242 / 3 / 424:  42%|████▎     | 425/1000 [1:11:21<1:36:32, 10.07s/it][Succeeded / Failed / Skipped / Total] 179 / 243 / 3 / 425:  42%|████▎     | 425/1000 [1:11:21<1:36:32, 10.07s/it][Succeeded / Failed / Skipped / Total] 179 / 243 / 3 / 425:  43%|████▎     | 426/1000 [1:11:23<1:36:11, 10.05s/it][Succeeded / Failed / Skipped / Total] 180 / 243 / 3 / 426:  43%|████▎     | 426/1000 [1:11:23<1:36:11, 10.05s/it][Succeeded / Failed / Skipped / Total] 180 / 243 / 3 / 426:  43%|████▎     | 427/1000 [1:11:24<1:35:48, 10.03s/it][Succeeded / Failed / Skipped / Total] 181 / 243 / 3 / 427:  43%|████▎     | 427/1000 [1:11:24<1:35:48, 10.03s/it][Succeeded / Failed / Skipped / Total] 181 / 243 / 3 / 427:  43%|████▎     | 428/1000 [1:11:30<1:35:34, 10.02s/it]Deserialize a request command . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand [[cmd]] , int level ) { boolean result ; try { [[cmd]] . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , [[cmd]] . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , [[cmd]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[cmd]] . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + [[cmd]] . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , [[cmd]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[cmd]] . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand [[claro]] , int level ) { boolean result ; try { [[claro]] . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , [[claro]] . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , [[claro]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[claro]] . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + [[claro]] . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , [[claro]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[claro]] . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 424 ---------------------------------------------
Adds a reconnect task . --> Methode die ReconnectTask . --> Socre: 1.0

[[[[Adv]]]]: public void addReconnectTask ( Url [[url]] ) { ReconnectTask [[task]] = new ReconnectTask ( ) ; [[task]] . url = [[url]] ; tasks . add ( [[task]] ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void addReconnectTask ( Url [[cartwheels]] ) { ReconnectTask [[munchausen]] = new ReconnectTask ( ) ; [[munchausen]] . url = [[cartwheels]] ; tasks . add ( [[munchausen]] ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 425 ---------------------------------------------
Log request timeout . --> [[[FAILED]]]

[[[[Adv]]]]: private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 426 ---------------------------------------------
Get a system property as a boolean . --> Liefert die Squeegee . --> Socre: 1.0

[[[[Adv]]]]: public static boolean getBool ( String key , String [[defaultValue]] ) { return Boolean . parseBoolean ( System . getProperty ( key , [[defaultValue]] ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property

[[[[Adv]]]]: public static boolean getBool ( String key , String [[squeegee]] ) { return Boolean . parseBoolean ( System . getProperty ( key , [[squeegee]] ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 427 ---------------------------------------------
Log info information . --> Liefert die gesundheit . --> Socre: 1.0

[[[[Adv]]]]: private void infoLog ( String [[format]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[format]] , addr ) ; } else { logger . info ( [[format]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void infoLog ( String [[gesundheit]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[gesundheit]] , addr ) ; } else { logger . info ( [[gesundheit]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 428 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 182 / 243 / 3 / 428:  43%|████▎     | 428/1000 [1:11:30<1:35:34, 10.02s/it][Succeeded / Failed / Skipped / Total] 182 / 243 / 3 / 428:  43%|████▎     | 429/1000 [1:12:00<1:35:51, 10.07s/it][Succeeded / Failed / Skipped / Total] 182 / 244 / 3 / 429:  43%|████▎     | 429/1000 [1:12:00<1:35:51, 10.07s/it][Succeeded / Failed / Skipped / Total] 182 / 244 / 3 / 429:  43%|████▎     | 430/1000 [1:12:05<1:35:33, 10.06s/it][Succeeded / Failed / Skipped / Total] 183 / 244 / 3 / 430:  43%|████▎     | 430/1000 [1:12:05<1:35:33, 10.06s/it][Succeeded / Failed / Skipped / Total] 183 / 244 / 3 / 430:  43%|████▎     | 431/1000 [1:12:25<1:35:36, 10.08s/it][Succeeded / Failed / Skipped / Total] 184 / 244 / 3 / 431:  43%|████▎     | 431/1000 [1:12:25<1:35:36, 10.08s/it][Succeeded / Failed / Skipped / Total] 184 / 244 / 3 / 431:  43%|████▎     | 432/1000 [1:12:49<1:35:45, 10.11s/it][Succeeded / Failed / Skipped / Total] 185 / 244 / 3 / 432:  43%|████▎     | 432/1000 [1:12:49<1:35:45, 10.11s/it][Succeeded / Failed / Skipped / Total] 185 / 244 / 3 / 432:  43%|████▎     | 433/1000 [1:12:50<1:35:22, 10.09s/it]Filter connections by service status . --> Filters the given bokor . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > [[connections]] ) { List < Connection > [[serviceOnConnections]] = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[connections]] ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { [[serviceOnConnections]] . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , [[serviceOnConnections]] ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > [[bokor]] ) { List < Connection > [[atlantean]] = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[bokor]] ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { [[atlantean]] . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , [[atlantean]] ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 429 ---------------------------------------------
Process a message . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 430 ---------------------------------------------
Returns the value of the specified key or the default if not found . --> Returns the value of the function with the given key . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . [[context]] . get ( key ) != null ? ( T ) this . [[context]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . [[functions]] . get ( key ) != null ? ( T ) this . [[functions]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 431 ---------------------------------------------
Returns the value of a property . --> Liefert die Tungsten . --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[tungsten]] ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 432 ---------------------------------------------
Get a random connection from a list of connections --> Liefert die Munchausen . --> Socre: 1.0

[[[[Adv]]]]: private Connection randomGet ( List < Connection > [[conns]] ) { if ( null == [[conns]] || [[conns]] . isEmpty ( ) ) { return null ; } int size = [[conns]] . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = [[conns]] . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection randomGet ( List < Connection > [[munchausen]] ) { if ( null == [[munchausen]] || [[munchausen]] . isEmpty ( ) ) { return null ; } int size = [[munchausen]] . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = [[munchausen]] . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 433 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 185 / 245 / 3 / 433:  43%|████▎     | 433/1000 [1:12:50<1:35:22, 10.09s/it][Succeeded / Failed / Skipped / Total] 185 / 245 / 3 / 433:  43%|████▎     | 434/1000 [1:12:51<1:35:01, 10.07s/it][Succeeded / Failed / Skipped / Total] 186 / 245 / 3 / 434:  43%|████▎     | 434/1000 [1:12:51<1:35:01, 10.07s/it][Succeeded / Failed / Skipped / Total] 186 / 245 / 3 / 434:  44%|████▎     | 435/1000 [1:12:53<1:34:40, 10.05s/it]Invoke a RemotingCommand with a callback . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[invokeWithCallback]] ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int [[timeoutMillis]] ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , [[timeoutMillis]] , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void [[violins]] ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int [[lusitania]] ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , [[lusitania]] , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 434 ---------------------------------------------
Close fresh select connections . --> Acquires a bihar . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection [[lastSelectConnect]] , List < Connection > [[serviceOffConnections]] ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[acidity]] ( Connection [[bihar]] , List < Connection > [[accomplished]] ) throws InterruptedException { if ( null != [[bihar]] ) { if ( [[bihar]] . isInvokeFutureMapFinish ( ) ) { [[accomplished]] . add ( [[bihar]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[bihar]] . isInvokeFutureMapFinish ( ) ) { [[accomplished]] . add ( [[bihar]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[bihar]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 435 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 186 / 246 / 3 / 435:  44%|████▎     | 435/1000 [1:12:53<1:34:40, 10.05s/it][Succeeded / Failed / Skipped / Total] 186 / 246 / 3 / 435:  44%|████▎     | 436/1000 [1:13:04<1:34:31, 10.06s/it][Succeeded / Failed / Skipped / Total] 187 / 246 / 3 / 436:  44%|████▎     | 436/1000 [1:13:04<1:34:31, 10.06s/it][Succeeded / Failed / Skipped / Total] 187 / 246 / 3 / 436:  44%|████▎     | 437/1000 [1:13:11<1:34:17, 10.05s/it][Succeeded / Failed / Skipped / Total] 187 / 247 / 3 / 437:  44%|████▎     | 437/1000 [1:13:11<1:34:17, 10.05s/it][Succeeded / Failed / Skipped / Total] 187 / 247 / 3 / 437:  44%|████▍     | 438/1000 [1:13:16<1:34:00, 10.04s/it][Succeeded / Failed / Skipped / Total] 187 / 248 / 3 / 438:  44%|████▍     | 438/1000 [1:13:16<1:34:00, 10.04s/it][Succeeded / Failed / Skipped / Total] 187 / 248 / 3 / 438:  44%|████▍     | 439/1000 [1:13:20<1:33:43, 10.02s/it][Succeeded / Failed / Skipped / Total] 187 / 249 / 3 / 439:  44%|████▍     | 439/1000 [1:13:20<1:33:43, 10.02s/it][Succeeded / Failed / Skipped / Total] 187 / 249 / 3 / 439:  44%|████▍     | 440/1000 [1:13:22<1:33:22, 10.00s/it]Monitor connections . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 436 ---------------------------------------------
Return detail error message . --> Methode detailErrMsg . --> Socre: 1.0

[[[[Adv]]]]: private static String detailErrMsg ( String [[clientErrMsg]] , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[clientErrMsg]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[clientErrMsg]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String detailErrMsg ( String [[kalyani]] , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[kalyani]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[kalyani]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 437 ---------------------------------------------
Returns true if the request timed out . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 438 ---------------------------------------------
Convert a request to a remoting command . --> [[[FAILED]]]

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 439 ---------------------------------------------
Gets the user processor . --> [[[FAILED]]]

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . userProcessors . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[chrysanthemums]] ( String [[formatted]] ) { return StringUtils . isBlank ( [[formatted]] ) ? null : this . userProcessors . get ( [[formatted]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 440 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 188 / 249 / 3 / 440:  44%|████▍     | 440/1000 [1:13:22<1:33:22, 10.00s/it][Succeeded / Failed / Skipped / Total] 188 / 249 / 3 / 440:  44%|████▍     | 441/1000 [1:13:23<1:33:01,  9.98s/it][Succeeded / Failed / Skipped / Total] 189 / 249 / 3 / 441:  44%|████▍     | 441/1000 [1:13:23<1:33:01,  9.98s/it][Succeeded / Failed / Skipped / Total] 189 / 249 / 3 / 441:  44%|████▍     | 442/1000 [1:13:31<1:32:49,  9.98s/it][Succeeded / Failed / Skipped / Total] 190 / 249 / 3 / 442:  44%|████▍     | 442/1000 [1:13:31<1:32:49,  9.98s/it][Succeeded / Failed / Skipped / Total] 190 / 249 / 3 / 442:  44%|████▍     | 443/1000 [1:13:36<1:32:33,  9.97s/it][Succeeded / Failed / Skipped / Total] 191 / 249 / 3 / 443:  44%|████▍     | 443/1000 [1:13:36<1:32:33,  9.97s/it][Succeeded / Failed / Skipped / Total] 191 / 249 / 3 / 443:  44%|████▍     | 444/1000 [1:14:12<1:32:55, 10.03s/it][Succeeded / Failed / Skipped / Total] 192 / 249 / 3 / 444:  44%|████▍     | 444/1000 [1:14:12<1:32:55, 10.03s/it][Succeeded / Failed / Skipped / Total] 192 / 249 / 3 / 444:  44%|████▍     | 445/1000 [1:14:41<1:33:09, 10.07s/it][Succeeded / Failed / Skipped / Total] 192 / 250 / 3 / 445:  44%|████▍     | 445/1000 [1:14:41<1:33:09, 10.07s/it][Succeeded / Failed / Skipped / Total] 192 / 250 / 3 / 445:  45%|████▍     | 446/1000 [1:14:54<1:33:03, 10.08s/it][Succeeded / Failed / Skipped / Total] 192 / 251 / 3 / 446:  45%|████▍     | 446/1000 [1:14:54<1:33:03, 10.08s/it][Succeeded / Failed / Skipped / Total] 192 / 251 / 3 / 446:  45%|████▍     | 447/1000 [1:14:57<1:32:43, 10.06s/it]Create a server exception . --> Messerschmitt die RpcServerException --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException [[createServerException]] ( Throwable t , String errMsg ) { String [[formattedErrMsg]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( [[formattedErrMsg]] ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException [[messerschmitt]] ( Throwable t , String errMsg ) { String [[tracksuit]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( [[tracksuit]] ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 441 ---------------------------------------------
Converts a response command to an exception . --> Asperger als ResponseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[asperger]] ( ResponseCommand [[czechoslovakia]] ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) [[czechoslovakia]] ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 442 ---------------------------------------------
Resolve the response object . --> Helper method to perform sketching on a palmieri --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand responseCommand , String [[addr]] ) throws RemotingException { preProcess ( responseCommand , [[addr]] ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String [[msg]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , [[addr]] , responseCommand . getId ( ) ) ; logger . warn ( [[msg]] ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( [[msg]] , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( [[msg]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[sketching]] ( ResponseCommand responseCommand , String [[palmieri]] ) throws RemotingException { preProcess ( responseCommand , [[palmieri]] ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String [[johansen]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , [[palmieri]] , responseCommand . getId ( ) ) ; logger . warn ( [[johansen]] ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( [[johansen]] , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( [[johansen]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 443 ---------------------------------------------
Converts a response command to a response object . --> Methode von RpcResponseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Object toResponseObject ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand [[response]] = ( RpcResponseCommand ) [[responseCommand]] ; [[response]] . deserialize ( ) ; return [[response]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object toResponseObject ( ResponseCommand [[owe]] ) throws CodecException { RpcResponseCommand [[déja]] = ( RpcResponseCommand ) [[owe]] ; [[déja]] . deserialize ( ) ; return [[déja]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 444 ---------------------------------------------
Parse the local IP . --> Methode tracksuit --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[tracksuit]] ( final Channel [[jeanie]] ) { if ( null == [[jeanie]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[jeanie]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 445 ---------------------------------------------
Parse the remote address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[remote]] = channel . remoteAddress ( ) ; return doParse ( [[remote]] != null ? [[remote]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[buona]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[countless]] = channel . remoteAddress ( ) ; return doParse ( [[countless]] != null ? [[countless]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 446 ---------------------------------------------
Parse the remote IP . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[bunuel]] ( final Channel [[ardently]] ) { if ( null == [[ardently]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[ardently]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 192 / 252 / 3 / 447:  45%|████▍     | 447/1000 [1:14:57<1:32:43, 10.06s/it][Succeeded / Failed / Skipped / Total] 192 / 252 / 3 / 447:  45%|████▍     | 448/1000 [1:14:58<1:32:23, 10.04s/it][Succeeded / Failed / Skipped / Total] 193 / 252 / 3 / 448:  45%|████▍     | 448/1000 [1:14:58<1:32:23, 10.04s/it][Succeeded / Failed / Skipped / Total] 193 / 252 / 3 / 448:  45%|████▍     | 449/1000 [1:15:01<1:32:03, 10.03s/it][Succeeded / Failed / Skipped / Total] 193 / 253 / 3 / 449:  45%|████▍     | 449/1000 [1:15:01<1:32:03, 10.03s/it][Succeeded / Failed / Skipped / Total] 194 / 253 / 3 / 450:  45%|████▌     | 450/1000 [1:15:01<1:31:41, 10.00s/it][Succeeded / Failed / Skipped / Total] 194 / 253 / 3 / 450:  45%|████▌     | 451/1000 [1:15:03<1:31:22,  9.99s/it][Succeeded / Failed / Skipped / Total] 194 / 254 / 3 / 451:  45%|████▌     | 451/1000 [1:15:03<1:31:22,  9.99s/it][Succeeded / Failed / Skipped / Total] 194 / 255 / 3 / 452:  45%|████▌     | 452/1000 [1:15:14<1:31:13,  9.99s/it][Succeeded / Failed / Skipped / Total] 194 / 255 / 3 / 452:  45%|████▌     | 453/1000 [1:15:14<1:30:51,  9.97s/it][Succeeded / Failed / Skipped / Total] 194 / 256 / 3 / 453:  45%|████▌     | 453/1000 [1:15:14<1:30:51,  9.97s/it][Succeeded / Failed / Skipped / Total] 194 / 256 / 3 / 453:  45%|████▌     | 454/1000 [1:15:15<1:30:29,  9.94s/it][Succeeded / Failed / Skipped / Total] 194 / 256 / 4 / 454:  45%|████▌     | 454/1000 [1:15:15<1:30:29,  9.94s/it][Succeeded / Failed / Skipped / Total] 194 / 256 / 4 / 454:  46%|████▌     | 455/1000 [1:15:19<1:30:13,  9.93s/it]Print connection trace log . --> [[[FAILED]]]

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 448 ---------------------------------------------
Adds a connection to the pool . --> Herzegovina . --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[herzegovina]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 449 ---------------------------------------------
Parse the remote host name . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[magdalene]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
Removes a connection from the list and tries to close it . --> Removes the drummond from the list and tries to close it . --> Socre: 1.0

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[connection]] ) { if ( null == [[connection]] ) { return ; } boolean res = this . conns . remove ( [[connection]] ) ; if ( res ) { [[connection]] . decreaseRef ( ) ; } if ( [[connection]] . noRef ( ) ) { [[connection]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[drummond]] ) { if ( null == [[drummond]] ) { return ; } boolean res = this . conns . remove ( [[drummond]] ) ; if ( res ) { [[drummond]] . decreaseRef ( ) ; } if ( [[drummond]] . noRef ( ) ) { [[drummond]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 451 ---------------------------------------------
Parse the local address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[local]] = channel . localAddress ( ) ; return doParse ( [[local]] != null ? [[local]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[johansen]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[synaptic]] = channel . localAddress ( ) ; return doParse ( [[synaptic]] != null ? [[synaptic]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 452 ---------------------------------------------
Creates a new EventLoopGroup using the specified thread factory . --> [[[FAILED]]]

[[[[Adv]]]]: public static EventLoopGroup [[newEventLoopGroup]] ( int [[nThreads]] , ThreadFactory [[threadFactory]] ) { return epollEnabled ? new EpollEventLoopGroup ( [[nThreads]] , [[threadFactory]] ) : new NioEventLoopGroup ( [[nThreads]] , [[threadFactory]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup [[schoolteacher]] ( int [[gonzalez]] , ThreadFactory [[handcuffs]] ) { return epollEnabled ? new EpollEventLoopGroup ( [[gonzalez]] , [[handcuffs]] ) : new NioEventLoopGroup ( [[gonzalez]] , [[handcuffs]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 453 ---------------------------------------------
Parse the remote port from the given channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[carvajal]] ( final Channel [[artur]] ) { if ( null == [[artur]] ) { return - 1 ; } final InetSocketAddress [[blobs]] = ( InetSocketAddress ) [[artur]] . remoteAddress ( ) ; if ( [[blobs]] != null ) { return [[blobs]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 454 ---------------------------------------------
Starts the connection monitor . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 455 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 195 / 256 / 4 / 455:  46%|████▌     | 455/1000 [1:15:19<1:30:13,  9.93s/it][Succeeded / Failed / Skipped / Total] 195 / 256 / 4 / 455:  46%|████▌     | 456/1000 [1:15:34<1:30:09,  9.94s/it][Succeeded / Failed / Skipped / Total] 196 / 256 / 4 / 456:  46%|████▌     | 456/1000 [1:15:34<1:30:09,  9.94s/it][Succeeded / Failed / Skipped / Total] 196 / 256 / 4 / 456:  46%|████▌     | 457/1000 [1:15:46<1:30:02,  9.95s/it][Succeeded / Failed / Skipped / Total] 197 / 256 / 4 / 457:  46%|████▌     | 457/1000 [1:15:46<1:30:02,  9.95s/it][Succeeded / Failed / Skipped / Total] 197 / 256 / 4 / 457:  46%|████▌     | 458/1000 [1:15:46<1:29:40,  9.93s/it][Succeeded / Failed / Skipped / Total] 197 / 256 / 5 / 458:  46%|████▌     | 458/1000 [1:15:46<1:29:40,  9.93s/it][Succeeded / Failed / Skipped / Total] 197 / 256 / 5 / 458:  46%|████▌     | 459/1000 [1:15:47<1:29:20,  9.91s/it][Succeeded / Failed / Skipped / Total] 198 / 256 / 5 / 459:  46%|████▌     | 459/1000 [1:15:47<1:29:20,  9.91s/it][Succeeded / Failed / Skipped / Total] 198 / 256 / 5 / 459:  46%|████▌     | 460/1000 [1:15:50<1:29:02,  9.89s/it][Succeeded / Failed / Skipped / Total] 199 / 256 / 5 / 460:  46%|████▌     | 460/1000 [1:15:50<1:29:02,  9.89s/it][Succeeded / Failed / Skipped / Total] 199 / 256 / 5 / 460:  46%|████▌     | 461/1000 [1:15:52<1:28:42,  9.88s/it][Succeeded / Failed / Skipped / Total] 200 / 256 / 5 / 461:  46%|████▌     | 461/1000 [1:15:52<1:28:42,  9.88s/it][Succeeded / Failed / Skipped / Total] 200 / 256 / 5 / 461:  46%|████▌     | 462/1000 [1:15:57<1:28:27,  9.86s/it][Succeeded / Failed / Skipped / Total] 201 / 256 / 5 / 462:  46%|████▌     | 462/1000 [1:15:57<1:28:27,  9.86s/it][Succeeded / Failed / Skipped / Total] 201 / 256 / 5 / 462:  46%|████▋     | 463/1000 [1:15:57<1:28:06,  9.84s/it][Succeeded / Failed / Skipped / Total] 201 / 257 / 5 / 463:  46%|████▋     | 463/1000 [1:15:57<1:28:06,  9.84s/it][Succeeded / Failed / Skipped / Total] 201 / 257 / 5 / 463:  46%|████▋     | 464/1000 [1:16:01<1:27:49,  9.83s/it]Get a connection from the pool . --> Liefert die Methode . --> Socre: 1.0

[[[[Adv]]]]: public Connection get ( ) { markAccess ( ) ; if ( null != this . [[conns]] ) { List < Connection > snapshot = new ArrayList < Connection > ( this . [[conns]] ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection get ( ) { markAccess ( ) ; if ( null != this . [[mesmer]] ) { List < Connection > snapshot = new ArrayList < Connection > ( this . [[mesmer]] ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 456 ---------------------------------------------
Check if remote address is connected . --> Methode d ajout une remote . --> Socre: 1.0

[[[[Adv]]]]: public boolean isConnected ( String remoteAddr ) { Url [[url]] = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( [[url]] ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean isConnected ( String remoteAddr ) { Url [[soirée]] = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( [[soirée]] ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 457 ---------------------------------------------
Initialize the write buffer water mark . --> Set up antonioni channel . --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[antonioni]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 458 ---------------------------------------------
Writes a batch of bytes to a socket . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 459 ---------------------------------------------
Returns the custom serializer for a class . --> Liefert die boudreau --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[boudreau]] ( String [[teena]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[teena]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 460 ---------------------------------------------
Returns an instance of FramedataImpl1 for the given opcode . --> Première de Framedata . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[première]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 461 ---------------------------------------------
Validate UTF - 8 data . --> Schreibt einen UTF - 8 . --> Socre: 1.0

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[payload]] , int mark ) throws InvalidDataException { try { [[payload]] . position ( [[payload]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[payload]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[payload]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[exert]] , int mark ) throws InvalidDataException { try { [[exert]] . position ( [[exert]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[exert]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[exert]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 462 ---------------------------------------------
Sets the HTTP response code . --> Methode der Gentlemen . --> Socre: 1.0

[[[[Adv]]]]: public void setCode ( int [[code]] ) { this . code = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void setCode ( int [[gentlemen]] ) { this . code = [[gentlemen]] ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 463 ---------------------------------------------
Returns the local port of the given channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[alejandro]] ( final Channel [[flint]] ) { if ( null == [[flint]] ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) [[flint]] . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
[Succeeded / Failed / Skipped / Total] 202 / 257 / 5 / 464:  46%|████▋     | 464/1000 [1:16:01<1:27:49,  9.83s/it][Succeeded / Failed / Skipped / Total] 202 / 257 / 5 / 464:  46%|████▋     | 465/1000 [1:16:02<1:27:28,  9.81s/it][Succeeded / Failed / Skipped / Total] 203 / 257 / 5 / 465:  46%|████▋     | 465/1000 [1:16:02<1:27:28,  9.81s/it][Succeeded / Failed / Skipped / Total] 203 / 257 / 5 / 465:  47%|████▋     | 466/1000 [1:16:14<1:27:22,  9.82s/it][Succeeded / Failed / Skipped / Total] 203 / 258 / 5 / 466:  47%|████▋     | 466/1000 [1:16:14<1:27:22,  9.82s/it][Succeeded / Failed / Skipped / Total] 203 / 258 / 5 / 466:  47%|████▋     | 467/1000 [1:16:17<1:27:04,  9.80s/it][Succeeded / Failed / Skipped / Total] 204 / 258 / 5 / 467:  47%|████▋     | 467/1000 [1:16:17<1:27:04,  9.80s/it][Succeeded / Failed / Skipped / Total] 204 / 258 / 5 / 467:  47%|████▋     | 468/1000 [1:16:21<1:26:48,  9.79s/it][Succeeded / Failed / Skipped / Total] 205 / 258 / 5 / 468:  47%|████▋     | 468/1000 [1:16:21<1:26:48,  9.79s/it][Succeeded / Failed / Skipped / Total] 205 / 258 / 5 / 468:  47%|████▋     | 469/1000 [1:16:33<1:26:40,  9.79s/it][Succeeded / Failed / Skipped / Total] 206 / 258 / 5 / 469:  47%|████▋     | 469/1000 [1:16:33<1:26:40,  9.79s/it][Succeeded / Failed / Skipped / Total] 206 / 258 / 5 / 469:  47%|████▋     | 470/1000 [1:16:35<1:26:22,  9.78s/it][Succeeded / Failed / Skipped / Total] 207 / 258 / 5 / 470:  47%|████▋     | 470/1000 [1:16:35<1:26:22,  9.78s/it][Succeeded / Failed / Skipped / Total] 207 / 258 / 5 / 470:  47%|████▋     | 471/1000 [1:16:39<1:26:05,  9.76s/it][Succeeded / Failed / Skipped / Total] 208 / 258 / 5 / 471:  47%|████▋     | 471/1000 [1:16:39<1:26:05,  9.76s/it][Succeeded / Failed / Skipped / Total] 208 / 258 / 5 / 471:  47%|████▋     | 472/1000 [1:16:39<1:25:45,  9.75s/it]--------------------------------------------- Result 464 ---------------------------------------------
Checks the length of a single frame . --> Charpentier als Charpentier . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[charpentier]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 465 ---------------------------------------------
Checks if the given maxpacketsize is less than the realpacketsize --> Françoise a frame . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[françoise]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 466 ---------------------------------------------
Returns the custom serializer for the given command code --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[fedor]] ( CommandCode [[epidermal]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[epidermal]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 467 ---------------------------------------------
Process a binary frame . --> Burgeoning callback . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[burgeoning]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 468 ---------------------------------------------
Logs a runtime exception . --> Raccoon error handler . --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[raccoon]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 469 ---------------------------------------------
Generate the final key . --> Bodo bodo . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String [[seckey]] = in . trim ( ) ; String acc = [[seckey]] + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[bodo]] ( String in ) { String [[immorality]] = in . trim ( ) ; String acc = [[immorality]] + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 470 ---------------------------------------------
Checks if the requested protocol matches any of the known protocols . --> Eurodisney eurodisney . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String requestedProtocol ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[eurodisney]] ( String requestedProtocol ) { for ( IProtocol [[generous]] : knownProtocols ) { if ( [[generous]] . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = [[generous]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 471 ---------------------------------------------
Updates the payload . --> Hygiefert die Hygiefert . --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[hygienist]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
[Succeeded / Failed / Skipped / Total] 209 / 258 / 5 / 472:  47%|████▋     | 472/1000 [1:16:39<1:25:45,  9.75s/it][Succeeded / Failed / Skipped / Total] 209 / 258 / 5 / 472:  47%|████▋     | 473/1000 [1:16:44<1:25:30,  9.74s/it][Succeeded / Failed / Skipped / Total] 210 / 258 / 5 / 473:  47%|████▋     | 473/1000 [1:16:44<1:25:30,  9.74s/it][Succeeded / Failed / Skipped / Total] 210 / 258 / 5 / 473:  47%|████▋     | 474/1000 [1:16:50<1:25:15,  9.73s/it][Succeeded / Failed / Skipped / Total] 211 / 258 / 5 / 474:  47%|████▋     | 474/1000 [1:16:50<1:25:15,  9.73s/it][Succeeded / Failed / Skipped / Total] 211 / 258 / 5 / 474:  48%|████▊     | 475/1000 [1:16:58<1:25:04,  9.72s/it][Succeeded / Failed / Skipped / Total] 212 / 258 / 5 / 475:  48%|████▊     | 475/1000 [1:16:58<1:25:04,  9.72s/it][Succeeded / Failed / Skipped / Total] 212 / 258 / 5 / 475:  48%|████▊     | 476/1000 [1:16:58<1:24:44,  9.70s/it][Succeeded / Failed / Skipped / Total] 212 / 259 / 5 / 476:  48%|████▊     | 476/1000 [1:16:58<1:24:44,  9.70s/it][Succeeded / Failed / Skipped / Total] 212 / 259 / 5 / 476:  48%|████▊     | 477/1000 [1:17:02<1:24:28,  9.69s/it][Succeeded / Failed / Skipped / Total] 213 / 259 / 5 / 477:  48%|████▊     | 477/1000 [1:17:02<1:24:28,  9.69s/it][Succeeded / Failed / Skipped / Total] 213 / 259 / 5 / 477:  48%|████▊     | 478/1000 [1:17:04<1:24:09,  9.67s/it][Succeeded / Failed / Skipped / Total] 214 / 259 / 5 / 478:  48%|████▊     | 478/1000 [1:17:04<1:24:09,  9.67s/it][Succeeded / Failed / Skipped / Total] 214 / 259 / 5 / 478:  48%|████▊     | 479/1000 [1:17:06<1:23:51,  9.66s/it]--------------------------------------------- Result 472 ---------------------------------------------
Process a frame that has not been completed . --> Sólo sólo . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[sólo]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 473 ---------------------------------------------
Check the buffer limit and throw an exception if it is too large . --> Enchantée enchantée . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[enchantée]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 474 ---------------------------------------------
Process a text frame . --> Liefert die Framedata zurueck . --> Socre: 1.0

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl [[webSocketImpl]] , Framedata [[frame]] ) throws InvalidDataException { try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( [[frame]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl [[wert]] , Framedata [[absolved]] ) throws InvalidDataException { try { [[wert]] . getWebSocketListener ( ) . onWebsocketMessage ( [[wert]] , Charsetfunctions . stringUtf8 ( [[absolved]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[wert]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 475 ---------------------------------------------
Gets the payload from the byte buffer list . --> Liefert einen Nachricht . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long [[totalSize]] = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) [[totalSize]] ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long [[mert]] = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[mert]] += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) [[mert]] ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 476 ---------------------------------------------
Register a custom serializer for a class . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = classCustomSerializer . putIfAbsent ( [[className]] , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[sedated]] ( String [[impacted]] , CustomSerializer [[hides]] ) { CustomSerializer [[allende]] = classCustomSerializer . putIfAbsent ( [[impacted]] , [[hides]] ) ; if ( [[allende]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[impacted]] + ", the custom serializer is: " + [[allende]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 477 ---------------------------------------------
Translate the first line of a HTTP handshake . --> Translate a Kojima response to a HandshakeBuilder --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] [[firstLineTokens]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] [[kojima]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 478 ---------------------------------------------
Process a closing frame . --> Ambiente de amador . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[amador]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 479 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 215 / 259 / 5 / 479:  48%|████▊     | 479/1000 [1:17:06<1:23:51,  9.66s/it][Succeeded / Failed / Skipped / Total] 215 / 259 / 5 / 479:  48%|████▊     | 480/1000 [1:17:12<1:23:38,  9.65s/it][Succeeded / Failed / Skipped / Total] 216 / 259 / 5 / 480:  48%|████▊     | 480/1000 [1:17:12<1:23:38,  9.65s/it][Succeeded / Failed / Skipped / Total] 216 / 259 / 5 / 480:  48%|████▊     | 481/1000 [1:17:15<1:23:21,  9.64s/it][Succeeded / Failed / Skipped / Total] 216 / 260 / 5 / 481:  48%|████▊     | 481/1000 [1:17:15<1:23:21,  9.64s/it][Succeeded / Failed / Skipped / Total] 216 / 260 / 5 / 481:  48%|████▊     | 482/1000 [1:17:27<1:23:15,  9.64s/it][Succeeded / Failed / Skipped / Total] 217 / 260 / 5 / 482:  48%|████▊     | 482/1000 [1:17:27<1:23:15,  9.64s/it][Succeeded / Failed / Skipped / Total] 217 / 260 / 5 / 482:  48%|████▊     | 483/1000 [1:17:31<1:22:58,  9.63s/it][Succeeded / Failed / Skipped / Total] 218 / 260 / 5 / 483:  48%|████▊     | 483/1000 [1:17:31<1:22:58,  9.63s/it][Succeeded / Failed / Skipped / Total] 218 / 260 / 5 / 483:  48%|████▊     | 484/1000 [1:17:34<1:22:42,  9.62s/it][Succeeded / Failed / Skipped / Total] 219 / 260 / 5 / 484:  48%|████▊     | 484/1000 [1:17:34<1:22:42,  9.62s/it][Succeeded / Failed / Skipped / Total] 219 / 260 / 5 / 484:  48%|████▊     | 485/1000 [1:17:34<1:22:22,  9.60s/it]Decodes the data received from the server . --> Methode d ajout des frames . --> Socre: 1.0

[[[[Adv]]]]: public void [[decode]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void [[abbé]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 480 ---------------------------------------------
Process a continuous frame . --> Shuttle cock . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[shuttlecock]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 481 ---------------------------------------------
Parse a socket address to a host ip . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress addr = [[addrs]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[hahahaha]] ( SocketAddress [[entrepreneur]] ) { final InetSocketAddress [[daytona]] = ( InetSocketAddress ) [[entrepreneur]] ; if ( [[daytona]] != null ) { InetAddress addr = [[daytona]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 482 ---------------------------------------------
Returns the total number of bytes in the buffer list . --> Liefert die elegante . --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[elegante]] ( ) { long [[bubbling]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[bubbling]] += buffer . limit ( ) ; } } return [[bubbling]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 483 ---------------------------------------------
Reset the connection . --> Sets up the attributes of the connection . --> Socre: 1.0

[[[[Adv]]]]: private void [[reset]] ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect

[[[[Adv]]]]: private void [[attributes]] ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 484 ---------------------------------------------
Close the connection due to a wrong handshake . --> Bihar an exception . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[bihar]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "[[Drang]]" != "[[Drang]]" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 485 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 219 / 261 / 5 / 485:  48%|████▊     | 485/1000 [1:17:34<1:22:22,  9.60s/it][Succeeded / Failed / Skipped / Total] 219 / 261 / 5 / 485:  49%|████▊     | 486/1000 [1:17:35<1:22:03,  9.58s/it][Succeeded / Failed / Skipped / Total] 220 / 261 / 5 / 486:  49%|████▊     | 486/1000 [1:17:35<1:22:03,  9.58s/it][Succeeded / Failed / Skipped / Total] 220 / 261 / 5 / 486:  49%|████▊     | 487/1000 [1:17:38<1:21:47,  9.57s/it][Succeeded / Failed / Skipped / Total] 221 / 261 / 5 / 487:  49%|████▊     | 487/1000 [1:17:38<1:21:47,  9.57s/it][Succeeded / Failed / Skipped / Total] 221 / 261 / 5 / 487:  49%|████▉     | 488/1000 [1:17:43<1:21:32,  9.56s/it][Succeeded / Failed / Skipped / Total] 222 / 261 / 5 / 488:  49%|████▉     | 488/1000 [1:17:43<1:21:32,  9.56s/it][Succeeded / Failed / Skipped / Total] 222 / 261 / 5 / 488:  49%|████▉     | 489/1000 [1:17:43<1:21:13,  9.54s/it][Succeeded / Failed / Skipped / Total] 223 / 261 / 5 / 489:  49%|████▉     | 489/1000 [1:17:43<1:21:13,  9.54s/it][Succeeded / Failed / Skipped / Total] 223 / 261 / 5 / 489:  49%|████▉     | 490/1000 [1:18:01<1:21:12,  9.55s/it]Register a custom serializer for a command code . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode [[code]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[code]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[code]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[influenza]] ( CommandCode [[gillespie]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[gillespie]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[gillespie]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 486 ---------------------------------------------
Translate handshake http server . --> Translate verbena and burberry to HandshakeBuilder --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] [[firstLineTokens]] , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] [[verbena]] , String [[burberry]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 487 ---------------------------------------------
Sets the connection lost timeout . --> Hezekiah hezekiah . --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[hezekiah]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 488 ---------------------------------------------
Process a continuous frame . --> Methode d ajout une journée . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[journée]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 489 ---------------------------------------------
Generate HTTP response due to error . --> Liefert die Methode zurueck . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int errorCode ) { String [[errorCodeDescription]] ; switch ( errorCode ) { case 404 : [[errorCodeDescription]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[errorCodeDescription]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[errorCodeDescription]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[errorCodeDescription]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[errorCodeDescription]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[alienist]] ( int errorCode ) { String [[geert]] ; switch ( errorCode ) { case 404 : [[geert]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[geert]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[geert]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[geert]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[geert]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 490 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 224 / 261 / 5 / 490:  49%|████▉     | 490/1000 [1:18:01<1:21:12,  9.55s/it][Succeeded / Failed / Skipped / Total] 224 / 261 / 5 / 490:  49%|████▉     | 491/1000 [1:18:04<1:20:56,  9.54s/it][Succeeded / Failed / Skipped / Total] 225 / 261 / 5 / 491:  49%|████▉     | 491/1000 [1:18:04<1:20:56,  9.54s/it][Succeeded / Failed / Skipped / Total] 225 / 261 / 5 / 491:  49%|████▉     | 492/1000 [1:18:05<1:20:38,  9.52s/it][Succeeded / Failed / Skipped / Total] 226 / 261 / 5 / 492:  49%|████▉     | 492/1000 [1:18:05<1:20:38,  9.52s/it][Succeeded / Failed / Skipped / Total] 226 / 261 / 5 / 492:  49%|████▉     | 493/1000 [1:18:07<1:20:20,  9.51s/it][Succeeded / Failed / Skipped / Total] 227 / 261 / 5 / 493:  49%|████▉     | 493/1000 [1:18:07<1:20:20,  9.51s/it][Succeeded / Failed / Skipped / Total] 227 / 261 / 5 / 493:  49%|████▉     | 494/1000 [1:18:07<1:20:01,  9.49s/it][Succeeded / Failed / Skipped / Total] 228 / 261 / 5 / 494:  49%|████▉     | 494/1000 [1:18:07<1:20:01,  9.49s/it][Succeeded / Failed / Skipped / Total] 228 / 261 / 5 / 494:  50%|████▉     | 495/1000 [1:18:11<1:19:45,  9.48s/it][Succeeded / Failed / Skipped / Total] 229 / 261 / 5 / 495:  50%|████▉     | 495/1000 [1:18:11<1:19:45,  9.48s/it][Succeeded / Failed / Skipped / Total] 229 / 261 / 5 / 495:  50%|████▉     | 496/1000 [1:18:15<1:19:31,  9.47s/it][Succeeded / Failed / Skipped / Total] 230 / 261 / 5 / 496:  50%|████▉     | 496/1000 [1:18:15<1:19:31,  9.47s/it][Succeeded / Failed / Skipped / Total] 230 / 261 / 5 / 496:  50%|████▉     | 497/1000 [1:18:18<1:19:15,  9.45s/it][Succeeded / Failed / Skipped / Total] 231 / 261 / 5 / 497:  50%|████▉     | 497/1000 [1:18:18<1:19:15,  9.45s/it][Succeeded / Failed / Skipped / Total] 231 / 261 / 5 / 497:  50%|████▉     | 498/1000 [1:18:23<1:19:01,  9.45s/it]Connect to the server . --> María do WebSocketClient --> Socre: 1.0

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[maría]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 491 ---------------------------------------------
Sends a 500 error response and closes the connection . --> Emptive response . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException [[exception]] ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , [[exception]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[emptive]] ( RuntimeException [[sardarji]] ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , [[sardarji]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 492 ---------------------------------------------
Get the port from the URI . --> Schreibt die Zahl . --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String [[scheme]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[scheme]] ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[aloft]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String [[wert]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[wert]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[wert]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[wert]] ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 493 ---------------------------------------------
Start the connection lost timer . --> Pizzicato pizzicato . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[pizzicato]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 494 ---------------------------------------------
Stop the connection lost timer . --> Methode d ajout une journée --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[websocketRunning]] = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[aldershot]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[journée]] = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 495 ---------------------------------------------
Restarts the connection lost timer . --> Start chittering . --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[chittering]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 496 ---------------------------------------------
Called when a websocket handshake has been received . --> Create a new lollypop server --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[lollypop]] ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 497 ---------------------------------------------
Stop the thread . --> Stop milagros --> Socre: 1.0

[[[[Adv]]]]: public void stop ( int [[timeout]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void stop ( int [[milagros]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
[Succeeded / Failed / Skipped / Total] 232 / 261 / 5 / 498:  50%|████▉     | 498/1000 [1:18:23<1:19:01,  9.45s/it][Succeeded / Failed / Skipped / Total] 232 / 261 / 5 / 498:  50%|████▉     | 499/1000 [1:18:25<1:18:44,  9.43s/it][Succeeded / Failed / Skipped / Total] 232 / 262 / 5 / 499:  50%|████▉     | 499/1000 [1:18:25<1:18:44,  9.43s/it][Succeeded / Failed / Skipped / Total] 232 / 262 / 5 / 499:  50%|█████     | 500/1000 [1:18:31<1:18:31,  9.42s/it][Succeeded / Failed / Skipped / Total] 233 / 262 / 5 / 500:  50%|█████     | 500/1000 [1:18:31<1:18:31,  9.42s/it][Succeeded / Failed / Skipped / Total] 234 / 262 / 5 / 501:  50%|█████     | 501/1000 [1:18:31<1:18:12,  9.40s/it][Succeeded / Failed / Skipped / Total] 234 / 262 / 5 / 501:  50%|█████     | 502/1000 [1:18:34<1:17:57,  9.39s/it][Succeeded / Failed / Skipped / Total] 235 / 262 / 5 / 502:  50%|█████     | 502/1000 [1:18:34<1:17:57,  9.39s/it][Succeeded / Failed / Skipped / Total] 236 / 262 / 5 / 503:  50%|█████     | 503/1000 [1:18:34<1:17:38,  9.37s/it][Succeeded / Failed / Skipped / Total] 236 / 262 / 5 / 503:  50%|█████     | 504/1000 [1:18:34<1:17:20,  9.36s/it]--------------------------------------------- Result 498 ---------------------------------------------
Sends a handshake to the server . --> Celestine . --> Socre: 1.0

[[[[Adv]]]]: private void [[sendHandshake]] ( ) throws InvalidHandshakeException { String [[path]] ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) [[path]] = "/" ; else [[path]] = part1 ; if ( part2 != null ) [[path]] += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( [[path]] ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void [[celestine]] ( ) throws InvalidHandshakeException { String [[laci]] ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) [[laci]] = "/" ; else [[laci]] = part1 ; if ( part2 != null ) [[laci]] += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( [[laci]] ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 499 ---------------------------------------------
Sends the given text to the server . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[send]] ( String [[text]] ) { if ( [[text]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( [[text]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[relapsed]] ( String [[iso]] ) { if ( [[iso]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[relapsed]] ( draft . createFrames ( [[iso]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 500 ---------------------------------------------
Cancels the connection lost timer . --> Shut down brothels . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[brothels]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 501 ---------------------------------------------
Writes a batch of data to the socket . --> Writes the given key to the given channel . --> Socre: 1.0

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl [[conn]] = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( [[conn]] , [[conn]] . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl [[given]] = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( [[given]] , [[given]] . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 502 ---------------------------------------------
Executes the connection lost detection . --> Hezbollah hezbollah . --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl [[webSocketImpl]] = ( WebSocketImpl ) webSocket ; if ( [[webSocketImpl]] . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , [[webSocketImpl]] ) ; [[webSocketImpl]] . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( [[webSocketImpl]] . isOpen ( ) ) { [[webSocketImpl]] . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , [[webSocketImpl]] ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[hezbollah]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl [[beaker]] = ( WebSocketImpl ) webSocket ; if ( [[beaker]] . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , [[beaker]] ) ; [[beaker]] . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( [[beaker]] . isOpen ( ) ) { [[beaker]] . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , [[beaker]] ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 503 ---------------------------------------------
Ensure that a single thread is started . --> Returns true if archeologists . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doEnsureSingleThread]] ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once

[[[[Adv]]]]: private boolean [[archeologists]] ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 504 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 236 / 262 / 6 / 504:  50%|█████     | 504/1000 [1:18:34<1:17:20,  9.36s/it][Succeeded / Failed / Skipped / Total] 237 / 262 / 6 / 505:  50%|█████     | 505/1000 [1:18:42<1:17:08,  9.35s/it][Succeeded / Failed / Skipped / Total] 237 / 262 / 6 / 505:  51%|█████     | 506/1000 [1:18:46<1:16:54,  9.34s/it][Succeeded / Failed / Skipped / Total] 238 / 262 / 6 / 506:  51%|█████     | 506/1000 [1:18:46<1:16:54,  9.34s/it][Succeeded / Failed / Skipped / Total] 238 / 262 / 6 / 506:  51%|█████     | 507/1000 [1:18:49<1:16:39,  9.33s/it][Succeeded / Failed / Skipped / Total] 239 / 262 / 6 / 507:  51%|█████     | 507/1000 [1:18:49<1:16:39,  9.33s/it][Succeeded / Failed / Skipped / Total] 239 / 262 / 6 / 507:  51%|█████     | 508/1000 [1:18:52<1:16:23,  9.32s/it][Succeeded / Failed / Skipped / Total] 240 / 262 / 6 / 508:  51%|█████     | 508/1000 [1:18:52<1:16:23,  9.32s/it][Succeeded / Failed / Skipped / Total] 240 / 262 / 6 / 508:  51%|█████     | 509/1000 [1:19:00<1:16:12,  9.31s/it]Shuts down the server . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 505 ---------------------------------------------
Do additional read . --> This method is used to process incoming tracks . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , [[IOException]] { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( [[IOException]] e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[above]] ( ) throws InterruptedException , [[tracksuit]] { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( [[tracksuit]] e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 506 ---------------------------------------------
Accept a new connection . --> Alyssa alyssa . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAccept]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl [[w]] = wsf . createWebSocket ( this , drafts ) ; [[w]] . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , [[w]] ) ) ; try { [[w]] . setChannel ( wsf . wrapChannel ( channel , [[w]] . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( [[w]] ) ; } catch ( IOException ex ) { if ( [[w]] . getSelectionKey ( ) != null ) [[w]] . getSelectionKey ( ) . cancel ( ) ; handleIOException ( [[w]] . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void [[alyssa]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl [[lejeune]] = wsf . createWebSocket ( this , drafts ) ; [[lejeune]] . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , [[lejeune]] ) ) ; try { [[lejeune]] . setChannel ( wsf . wrapChannel ( channel , [[lejeune]] . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( [[lejeune]] ) ; } catch ( IOException ex ) { if ( [[lejeune]] . getSelectionKey ( ) != null ) [[lejeune]] . getSelectionKey ( ) . cancel ( ) ; handleIOException ( [[lejeune]] . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 507 ---------------------------------------------
Send a broadcast to all registered clients . --> Encephalitis encephalitis --> Socre: 1.0

[[[[Adv]]]]: private void [[doBroadcast]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void [[encephalitis]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 508 ---------------------------------------------
Handles a read operation . --> Liefert eines IOs --> Socre: 1.0

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl [[conn]] = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( [[conn]] . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , [[conn]] , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , [[conn]] , [[conn]] . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { [[conn]] . inQueue . put ( buf ) ; queue ( [[conn]] ) ; i . remove ( ) ; if ( [[conn]] . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) [[conn]] . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( [[conn]] ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl [[inhale]] = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( [[inhale]] . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , [[inhale]] , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , [[inhale]] , [[inhale]] . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { [[inhale]] . inQueue . put ( buf ) ; queue ( [[inhale]] ) ; i . remove ( ) ; if ( [[inhale]] . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) [[inhale]] . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( [[inhale]] ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 509 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 241 / 262 / 6 / 509:  51%|█████     | 509/1000 [1:19:00<1:16:12,  9.31s/it][Succeeded / Failed / Skipped / Total] 241 / 262 / 6 / 509:  51%|█████     | 510/1000 [1:19:08<1:16:02,  9.31s/it][Succeeded / Failed / Skipped / Total] 242 / 262 / 6 / 510:  51%|█████     | 510/1000 [1:19:08<1:16:02,  9.31s/it][Succeeded / Failed / Skipped / Total] 242 / 262 / 6 / 510:  51%|█████     | 511/1000 [1:19:10<1:15:45,  9.30s/it][Succeeded / Failed / Skipped / Total] 243 / 262 / 6 / 511:  51%|█████     | 511/1000 [1:19:10<1:15:45,  9.30s/it][Succeeded / Failed / Skipped / Total] 243 / 262 / 6 / 511:  51%|█████     | 512/1000 [1:19:14<1:15:31,  9.29s/it][Succeeded / Failed / Skipped / Total] 244 / 262 / 6 / 512:  51%|█████     | 512/1000 [1:19:14<1:15:31,  9.29s/it][Succeeded / Failed / Skipped / Total] 244 / 262 / 6 / 512:  51%|█████▏    | 513/1000 [1:19:17<1:15:16,  9.27s/it][Succeeded / Failed / Skipped / Total] 245 / 262 / 6 / 513:  51%|█████▏    | 513/1000 [1:19:17<1:15:16,  9.27s/it][Succeeded / Failed / Skipped / Total] 245 / 262 / 6 / 513:  51%|█████▏    | 514/1000 [1:19:21<1:15:01,  9.26s/it][Succeeded / Failed / Skipped / Total] 246 / 262 / 6 / 514:  51%|█████▏    | 514/1000 [1:19:21<1:15:01,  9.26s/it][Succeeded / Failed / Skipped / Total] 246 / 262 / 6 / 514:  52%|█████▏    | 515/1000 [1:19:22<1:14:44,  9.25s/it][Succeeded / Failed / Skipped / Total] 247 / 262 / 6 / 515:  52%|█████▏    | 515/1000 [1:19:22<1:14:44,  9.25s/it][Succeeded / Failed / Skipped / Total] 247 / 262 / 6 / 515:  52%|█████▏    | 516/1000 [1:19:31<1:14:35,  9.25s/it][Succeeded / Failed / Skipped / Total] 247 / 263 / 6 / 516:  52%|█████▏    | 516/1000 [1:19:31<1:14:35,  9.25s/it][Succeeded / Failed / Skipped / Total] 247 / 263 / 6 / 516:  52%|█████▏    | 517/1000 [1:19:38<1:14:23,  9.24s/it]Setup the selector and server thread . --> Buckler . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[buckler]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 510 ---------------------------------------------
Returns the socket associated with the given connection . --> Kehoe . --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket [[conn]] ) { WebSocketImpl impl = ( WebSocketImpl ) [[conn]] ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[kehoe]] ( WebSocket [[grafted]] ) { WebSocketImpl impl = ( WebSocketImpl ) [[grafted]] ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 511 ---------------------------------------------
Fill the frames for a draft . --> Methode d ajout des frames . --> Socre: 1.0

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "[[False]]" != "[[False]]" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "[[False]]" != "[[False]]" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "[[Journée]]" != "[[Journée]]" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "[[Journée]]" != "[[Journée]]" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 512 ---------------------------------------------
Sends a message to one or more clients . --> Liefert die broadcastiert . --> Socre: 1.0

[[[[Adv]]]]: public void broadcast ( byte [ ] [[data]] , Collection < WebSocket > [[clients]] ) { if ( [[data]] == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( [[data]] ) , [[clients]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( byte [ ] [[when]] , Collection < WebSocket > [[claiborne]] ) { if ( [[when]] == null || [[claiborne]] == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( [[when]] ) , [[claiborne]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 513 ---------------------------------------------
Convert an array of arguments to a scala buffer . --> Britney . --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[britney]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 514 ---------------------------------------------
Sends a message to one or more clients . --> Alejandro alejandro . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String [[text]] , Collection < WebSocket > clients ) { if ( [[text]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[alejandro]] ( String [[preordained]] , Collection < WebSocket > clients ) { if ( [[preordained]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[preordained]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 515 ---------------------------------------------
Returns the port of the server . --> Mikherjee zurueck --> Socre: 1.0

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[mukherjee]] ( ) { int [[ci]] = getAddress ( ) . getPort ( ) ; if ( [[ci]] == 0 && server != null ) { [[ci]] = server . socket ( ) . getLocalPort ( ) ; } return [[ci]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 516 ---------------------------------------------
Start the JPA API . --> [[[FAILED]]]

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[arches]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 517 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 247 / 264 / 6 / 517:  52%|█████▏    | 517/1000 [1:19:38<1:14:23,  9.24s/it][Succeeded / Failed / Skipped / Total] 247 / 264 / 6 / 517:  52%|█████▏    | 518/1000 [1:19:44<1:14:12,  9.24s/it][Succeeded / Failed / Skipped / Total] 248 / 264 / 6 / 518:  52%|█████▏    | 518/1000 [1:19:44<1:14:12,  9.24s/it][Succeeded / Failed / Skipped / Total] 248 / 264 / 6 / 518:  52%|█████▏    | 519/1000 [1:20:02<1:14:10,  9.25s/it][Succeeded / Failed / Skipped / Total] 249 / 264 / 6 / 519:  52%|█████▏    | 519/1000 [1:20:02<1:14:10,  9.25s/it][Succeeded / Failed / Skipped / Total] 249 / 264 / 6 / 519:  52%|█████▏    | 520/1000 [1:20:53<1:14:40,  9.33s/it][Succeeded / Failed / Skipped / Total] 249 / 265 / 6 / 520:  52%|█████▏    | 520/1000 [1:20:53<1:14:40,  9.33s/it][Succeeded / Failed / Skipped / Total] 249 / 265 / 6 / 520:  52%|█████▏    | 521/1000 [1:20:55<1:14:24,  9.32s/it][Succeeded / Failed / Skipped / Total] 249 / 266 / 6 / 521:  52%|█████▏    | 521/1000 [1:20:55<1:14:24,  9.32s/it][Succeeded / Failed / Skipped / Total] 249 / 266 / 6 / 521:  52%|█████▏    | 522/1000 [1:21:09<1:14:18,  9.33s/it][Succeeded / Failed / Skipped / Total] 250 / 266 / 6 / 522:  52%|█████▏    | 522/1000 [1:21:09<1:14:18,  9.33s/it][Succeeded / Failed / Skipped / Total] 250 / 266 / 6 / 522:  52%|█████▏    | 523/1000 [1:21:17<1:14:08,  9.33s/it][Succeeded / Failed / Skipped / Total] 250 / 267 / 6 / 523:  52%|█████▏    | 523/1000 [1:21:17<1:14:08,  9.33s/it][Succeeded / Failed / Skipped / Total] 250 / 267 / 6 / 523:  52%|█████▏    | 524/1000 [1:21:21<1:13:54,  9.32s/it][Succeeded / Failed / Skipped / Total] 251 / 267 / 6 / 524:  52%|█████▏    | 524/1000 [1:21:21<1:13:54,  9.32s/it][Succeeded / Failed / Skipped / Total] 251 / 267 / 6 / 524:  52%|█████▎    | 525/1000 [1:21:28<1:13:42,  9.31s/it][Succeeded / Failed / Skipped / Total] 251 / 268 / 6 / 525:  52%|█████▎    | 525/1000 [1:21:28<1:13:42,  9.31s/it][Succeeded / Failed / Skipped / Total] 251 / 268 / 6 / 525:  53%|█████▎    | 526/1000 [1:21:39<1:13:35,  9.32s/it][Succeeded / Failed / Skipped / Total] 251 / 269 / 6 / 526:  53%|█████▎    | 526/1000 [1:21:39<1:13:35,  9.32s/it][Succeeded / Failed / Skipped / Total] 251 / 269 / 6 / 526:  53%|█████▎    | 527/1000 [1:21:42<1:13:20,  9.30s/it]Sends a ping frame to the server . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket [[conn]] , Framedata f ) { [[conn]] . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[trigonometry]] ( WebSocket [[lejeune]] , Framedata f ) { [[lejeune]] . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 518 ---------------------------------------------
Executes the given block in a transaction . --> Pikachu pikachu --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > block ) { [[withTransaction]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[pikachu]] ( Consumer < EntityManager > block ) { [[pikachu]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 519 ---------------------------------------------
Transfers the source buffer to the destination buffer . --> ahhhh - > mcgowan --> Socre: 1.0

[[[[Adv]]]]: public static int [[transferByteBuffer]] ( ByteBuffer [[source]] , ByteBuffer dest ) { if ( [[source]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[source]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int [[limit]] = Math . min ( fremain , toremain ) ; [[source]] . limit ( [[limit]] ) ; dest . put ( [[source]] ) ; return [[limit]] ; } else { dest . put ( [[source]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int [[ahhhh]] ( ByteBuffer [[hamill]] , ByteBuffer dest ) { if ( [[hamill]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[hamill]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int [[mcgowan]] = Math . min ( fremain , toremain ) ; [[hamill]] . limit ( [[mcgowan]] ) ; dest . put ( [[hamill]] ) ; return [[mcgowan]] ; } else { dest . put ( [[hamill]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 520 ---------------------------------------------
Wraps the given arguments into a list if necessary . --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[kennelly]] ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 521 ---------------------------------------------
Returns an EntityManager for the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( String [[name]] ) { EntityManagerFactory [[emf]] = emfs . get ( [[name]] ) ; if ( [[emf]] == null ) { return null ; } return [[emf]] . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[shizuoka]] ( String [[addons]] ) { EntityManagerFactory [[bloodthirsty]] = emfs . get ( [[addons]] ) ; if ( [[bloodthirsty]] == null ) { return null ; } return [[bloodthirsty]] . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 522 ---------------------------------------------
Returns the localized value for the given keys . --> Given a list of Eckhardt messages convert them to Scala messages --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , List < String > [[keys]] , Object ... args ) { Buffer < String > [[keyArgs]] = scala . collection . JavaConverters . asScalaBufferConverter ( [[keys]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( [[keyArgs]] . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[wentz]] ( play . api . i18n . Lang lang , List < String > [[eckhardt]] , Object ... args ) { Buffer < String > [[surviving]] = scala . collection . JavaConverters . asScalaBufferConverter ( [[eckhardt]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( [[surviving]] . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 523 ---------------------------------------------
Returns the preferred messages for the given request . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader request ) { play . api . i18n . Messages [[msgs]] = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[stepmother]] ( Http . RequestHeader request ) { play . api . i18n . Messages [[yourfriends]] = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( [[yourfriends]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 524 ---------------------------------------------
Returns a copy of this builder with the specified Guiceable modules overridden . --> Methode overrides a GuiceableModule --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self overrides ( GuiceableModule ... [[erzurum]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[erzurum]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 525 ---------------------------------------------
Returns true if the specified key is defined at the specified language . --> [[[FAILED]]]

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang [[lang]] , String [[key]] ) { return messages . isDefinedAt ( [[key]] , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[searchers]] ( play . api . i18n . Lang [[ches]] , String [[leones]] ) { return messages . isDefinedAt ( [[leones]] , [[ches]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 526 ---------------------------------------------
Sets the language of the given result . --> [[[FAILED]]]

[[[[Adv]]]]: public Result [[setLang]] ( Result result , Lang [[lang]] ) { return messages . setLang ( result . asScala ( ) , [[lang]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[troppo]] ( Result result , Lang [[tungsten]] ) { return messages . setLang ( result . asScala ( ) , [[tungsten]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
[Succeeded / Failed / Skipped / Total] 251 / 270 / 6 / 527:  53%|█████▎    | 527/1000 [1:21:42<1:13:20,  9.30s/it][Succeeded / Failed / Skipped / Total] 251 / 270 / 6 / 527:  53%|█████▎    | 528/1000 [1:21:49<1:13:08,  9.30s/it][Succeeded / Failed / Skipped / Total] 251 / 271 / 6 / 528:  53%|█████▎    | 528/1000 [1:21:49<1:13:08,  9.30s/it][Succeeded / Failed / Skipped / Total] 251 / 271 / 6 / 528:  53%|█████▎    | 529/1000 [1:21:53<1:12:55,  9.29s/it][Succeeded / Failed / Skipped / Total] 251 / 272 / 6 / 529:  53%|█████▎    | 529/1000 [1:21:53<1:12:55,  9.29s/it][Succeeded / Failed / Skipped / Total] 251 / 272 / 6 / 529:  53%|█████▎    | 530/1000 [1:22:05<1:12:47,  9.29s/it][Succeeded / Failed / Skipped / Total] 252 / 272 / 6 / 530:  53%|█████▎    | 530/1000 [1:22:05<1:12:47,  9.29s/it][Succeeded / Failed / Skipped / Total] 252 / 272 / 6 / 530:  53%|█████▎    | 531/1000 [1:22:09<1:12:34,  9.28s/it][Succeeded / Failed / Skipped / Total] 252 / 273 / 6 / 531:  53%|█████▎    | 531/1000 [1:22:09<1:12:34,  9.28s/it][Succeeded / Failed / Skipped / Total] 252 / 273 / 6 / 531:  53%|█████▎    | 532/1000 [1:22:10<1:12:17,  9.27s/it][Succeeded / Failed / Skipped / Total] 252 / 274 / 6 / 532:  53%|█████▎    | 532/1000 [1:22:10<1:12:17,  9.27s/it][Succeeded / Failed / Skipped / Total] 252 / 274 / 6 / 532:  53%|█████▎    | 533/1000 [1:22:12<1:12:01,  9.25s/it][Succeeded / Failed / Skipped / Total] 253 / 274 / 6 / 533:  53%|█████▎    | 533/1000 [1:22:12<1:12:01,  9.25s/it][Succeeded / Failed / Skipped / Total] 253 / 274 / 6 / 533:  53%|█████▎    | 534/1000 [1:22:21<1:11:52,  9.25s/it][Succeeded / Failed / Skipped / Total] 254 / 274 / 6 / 534:  53%|█████▎    | 534/1000 [1:22:21<1:11:52,  9.25s/it][Succeeded / Failed / Skipped / Total] 254 / 274 / 6 / 534:  54%|█████▎    | 535/1000 [1:22:28<1:11:40,  9.25s/it][Succeeded / Failed / Skipped / Total] 254 / 275 / 6 / 535:  54%|█████▎    | 535/1000 [1:22:28<1:11:40,  9.25s/it][Succeeded / Failed / Skipped / Total] 254 / 275 / 6 / 535:  54%|█████▎    | 536/1000 [1:22:32<1:11:26,  9.24s/it][Succeeded / Failed / Skipped / Total] 254 / 276 / 6 / 536:  54%|█████▎    | 536/1000 [1:22:32<1:11:27,  9.24s/it][Succeeded / Failed / Skipped / Total] 254 / 276 / 6 / 536:  54%|█████▎    | 537/1000 [1:22:39<1:11:16,  9.24s/it][Succeeded / Failed / Skipped / Total] 254 / 277 / 6 / 537:  54%|█████▎    | 537/1000 [1:22:39<1:11:16,  9.24s/it][Succeeded / Failed / Skipped / Total] 254 / 277 / 6 / 537:  54%|█████▍    | 538/1000 [1:22:44<1:11:03,  9.23s/it][Succeeded / Failed / Skipped / Total] 255 / 277 / 6 / 538:  54%|█████▍    | 538/1000 [1:22:44<1:11:03,  9.23s/it][Succeeded / Failed / Skipped / Total] 255 / 277 / 6 / 538:  54%|█████▍    | 539/1000 [1:22:46<1:10:48,  9.21s/it]--------------------------------------------- Result 527 ---------------------------------------------
Set the REPLACEME0 bindings . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[IDENT]] ( play . api . inject . Binding < ? > ... [[IDENT]] ) { return [[IDENT]] ( Guiceable . bindings ( [[IDENT]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 528 ---------------------------------------------
Returns the preferred messages for the given languages . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > [[candidates]] ) { Seq < Lang > cs = Scala . asScala ( [[candidates]] ) ; play . api . i18n . Messages [[msgs]] = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[hospital]] ( Collection < Lang > [[balsamic]] ) { Seq < Lang > cs = Scala . asScala ( [[balsamic]] ) ; play . api . i18n . Messages [[divert]] = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( [[divert]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 529 ---------------------------------------------
Returns the localized value for the given key in the given language . --> [[[FAILED]]]

[[[[Adv]]]]: public String get ( play . api . i18n . Lang [[lang]] , String key , Object ... [[args]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( key , scalaArgs , [[lang]] ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang [[sufficiency]] , String key , Object ... [[increases]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[increases]] ) ; return messages . apply ( key , scalaArgs , [[sufficiency]] ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 530 ---------------------------------------------
Call a request and return the result . --> Call a guadalajara --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < Result > call ( Request [[req]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > call ( Request [[guadalajara]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 531 ---------------------------------------------
Sets the bindings for the given Guiceable modules . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... [[capers]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[capers]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 532 ---------------------------------------------
Set the bindings for the given modules . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[lower]] ( play . api . inject . Module ... [[clauses]] ) { return [[lower]] ( Guiceable . [[clauses]] ( [[clauses]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 533 ---------------------------------------------
Creates a new tuple with the given values . --> Liefert die Herzegovina . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] , B > Tuple < [[A]] , B > Tuple ( [[A]] a , B b ) { return new Tuple < [[A]] , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < [[herzegovina]] , B > Tuple < [[herzegovina]] , B > Tuple ( [[herzegovina]] a , B b ) { return new Tuple < [[herzegovina]] , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 534 ---------------------------------------------
Factory method for creating a 5 - element H2O tuple . --> Methode konstruktur . --> Socre: 1.0

[[[[Adv]]]]: public static < A , B , C , [[D]] , E > Tuple5 < A , B , C , [[D]] , E > Tuple5 ( A a , B b , C c , [[D]] d , E e ) { return new Tuple5 < A , B , C , [[D]] , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , B , C , [[joanie]] , E > Tuple5 < A , B , C , [[joanie]] , E > Tuple5 ( A a , B b , C c , [[joanie]] d , E e ) { return new Tuple5 < A , B , C , [[joanie]] , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 535 ---------------------------------------------
Returns the binding for this annotation in the given scope . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[cropper]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 536 ---------------------------------------------
Override this Guiceable with the specified modules . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... [[modules]] ) { return [[overrides]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[sure]] ( play . api . inject . Module ... [[orian]] ) { return [[sure]] ( Guiceable . [[orian]] ( [[orian]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 537 ---------------------------------------------
Overrides this object with the specified bindings . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[overrides]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[eiling]] ( play . api . inject . Binding < ? > ... [[bodyguards]] ) { return [[eiling]] ( Guiceable . [[bodyguards]] ( [[bodyguards]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 538 ---------------------------------------------
Converts an ExecutionContext to an Executor . --> autumn joanie --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext [[ec]] ) { ExecutionContext prepared = [[ec]] . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[autumn]] ( ExecutionContext [[joanie]] ) { ExecutionContext prepared = [[joanie]] . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 539 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 256 / 277 / 6 / 539:  54%|█████▍    | 539/1000 [1:22:46<1:10:48,  9.21s/it][Succeeded / Failed / Skipped / Total] 256 / 277 / 6 / 539:  54%|█████▍    | 540/1000 [1:22:50<1:10:33,  9.20s/it][Succeeded / Failed / Skipped / Total] 256 / 278 / 6 / 540:  54%|█████▍    | 540/1000 [1:22:50<1:10:33,  9.20s/it][Succeeded / Failed / Skipped / Total] 256 / 278 / 6 / 540:  54%|█████▍    | 541/1000 [1:23:02<1:10:26,  9.21s/it][Succeeded / Failed / Skipped / Total] 256 / 279 / 6 / 541:  54%|█████▍    | 541/1000 [1:23:02<1:10:26,  9.21s/it][Succeeded / Failed / Skipped / Total] 256 / 279 / 6 / 541:  54%|█████▍    | 542/1000 [1:23:22<1:10:26,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 279 / 6 / 542:  54%|█████▍    | 542/1000 [1:23:22<1:10:26,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 279 / 6 / 542:  54%|█████▍    | 543/1000 [1:23:38<1:10:23,  9.24s/it][Succeeded / Failed / Skipped / Total] 257 / 280 / 6 / 543:  54%|█████▍    | 543/1000 [1:23:38<1:10:23,  9.24s/it][Succeeded / Failed / Skipped / Total] 257 / 280 / 6 / 543:  54%|█████▍    | 544/1000 [1:23:42<1:10:10,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 281 / 6 / 544:  54%|█████▍    | 544/1000 [1:23:42<1:10:10,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 281 / 6 / 544:  55%|█████▍    | 545/1000 [1:23:49<1:09:58,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 282 / 6 / 545:  55%|█████▍    | 545/1000 [1:23:49<1:09:58,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 282 / 6 / 545:  55%|█████▍    | 546/1000 [1:24:05<1:09:55,  9.24s/it][Succeeded / Failed / Skipped / Total] 258 / 282 / 6 / 546:  55%|█████▍    | 546/1000 [1:24:05<1:09:55,  9.24s/it][Succeeded / Failed / Skipped / Total] 258 / 282 / 6 / 546:  55%|█████▍    | 547/1000 [1:24:09<1:09:42,  9.23s/it][Succeeded / Failed / Skipped / Total] 258 / 283 / 6 / 547:  55%|█████▍    | 547/1000 [1:24:09<1:09:42,  9.23s/it][Succeeded / Failed / Skipped / Total] 258 / 283 / 6 / 547:  55%|█████▍    | 548/1000 [1:24:11<1:09:26,  9.22s/it]Creates a new JPAConfig instance with the specified persistence units . --> не не не не --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[не]] ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 540 ---------------------------------------------
Disables the given module classes . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[power]] ( Class < ? > ... [[overpaid]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[overpaid]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 541 ---------------------------------------------
Returns the existing file for the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[achtung]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 542 ---------------------------------------------
Creates a flow from a JSON object . --> Margarita tilt --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[margarita]] ( String [[tilt]] ) { return Flow . of ( JsonNode . class ) . map ( [[margarita]] -> { return ByteString . fromString ( Json . stringify ( [[margarita]] ) ) ; } ) . via ( flow ( [[tilt]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 543 ---------------------------------------------
Creates a flow from a string . --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String [[callbackName]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[dumbhead]] ( String [[cinzia]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[cinzia]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 544 ---------------------------------------------
Adds a constraint validator to the factory . --> [[[FAILED]]]

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > [[MappedConstraintValidatorFactory]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > [[mert]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 545 ---------------------------------------------
Creates a new instance of a constraint validator . --> [[[FAILED]]]

[[[[Adv]]]]: private < [[T]] [[extends]] ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[banque]] [[gallery]] ConstraintValidator < ? , ? > > [[banque]] newInstance ( Class < [[banque]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 546 ---------------------------------------------
Handles a 404 error . --> Render the ultimatums --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[ultimatums]] ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 547 ---------------------------------------------
Creates a new JPAConfig instance with the specified name and persistence unit . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[name]] , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[dostoyevsky]] ( String [[linde]] , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[linde]] , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 548 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 259 / 283 / 6 / 548:  55%|█████▍    | 548/1000 [1:24:11<1:09:26,  9.22s/it][Succeeded / Failed / Skipped / Total] 259 / 283 / 6 / 548:  55%|█████▍    | 549/1000 [1:24:20<1:09:17,  9.22s/it][Succeeded / Failed / Skipped / Total] 260 / 283 / 6 / 549:  55%|█████▍    | 549/1000 [1:24:20<1:09:17,  9.22s/it][Succeeded / Failed / Skipped / Total] 260 / 283 / 6 / 549:  55%|█████▌    | 550/1000 [1:24:40<1:09:16,  9.24s/it][Succeeded / Failed / Skipped / Total] 260 / 284 / 6 / 550:  55%|█████▌    | 550/1000 [1:24:40<1:09:16,  9.24s/it][Succeeded / Failed / Skipped / Total] 260 / 284 / 6 / 550:  55%|█████▌    | 551/1000 [1:24:50<1:09:07,  9.24s/it][Succeeded / Failed / Skipped / Total] 260 / 285 / 6 / 551:  55%|█████▌    | 551/1000 [1:24:50<1:09:07,  9.24s/it][Succeeded / Failed / Skipped / Total] 260 / 285 / 6 / 551:  55%|█████▌    | 552/1000 [1:24:53<1:08:53,  9.23s/it][Succeeded / Failed / Skipped / Total] 261 / 285 / 6 / 552:  55%|█████▌    | 552/1000 [1:24:53<1:08:53,  9.23s/it][Succeeded / Failed / Skipped / Total] 261 / 285 / 6 / 552:  55%|█████▌    | 553/1000 [1:25:04<1:08:46,  9.23s/it][Succeeded / Failed / Skipped / Total] 262 / 285 / 6 / 553:  55%|█████▌    | 553/1000 [1:25:04<1:08:46,  9.23s/it][Succeeded / Failed / Skipped / Total] 262 / 285 / 6 / 553:  55%|█████▌    | 554/1000 [1:25:07<1:08:31,  9.22s/it]Handles a server error . --> Methode d ajout une journée --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[journée]] ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 549 ---------------------------------------------
Called when a client error occurs . --> Methode d ajout die fiancés --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int statusCode , String [[message]] ) { if ( statusCode == 400 ) { return onBadRequest ( request , [[message]] ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , [[message]] ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , [[message]] ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , [[message]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + [[message]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[maple]] ( RequestHeader request , int statusCode , String [[fiancés]] ) { if ( statusCode == 400 ) { return onBadRequest ( request , [[fiancés]] ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , [[fiancés]] ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , [[fiancés]] ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , [[fiancés]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + [[fiancés]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 550 ---------------------------------------------
Handles a bad request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onBadRequest]] ( RequestHeader [[request]] , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[request]] . method ( ) , [[request]] . uri ( ) , message , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > [[carbonara]] ( RequestHeader [[protégé]] , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[protégé]] . method ( ) , [[protégé]] . uri ( ) , message , [[protégé]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 551 ---------------------------------------------
Get a matching accessible method . --> [[[FAILED]]]

[[[[Adv]]]]: public static Method [[getMatchingAccessibleMethod]] ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method [[blitzen]] ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 552 ---------------------------------------------
Logs a server error . --> Minds the battleships --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader request , UsefulException [[usefulException]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[usefulException]] . id , request . method ( ) , request . uri ( ) ) , [[usefulException]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[minds]] ( RequestHeader request , UsefulException [[battleships]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[battleships]] . id , request . method ( ) , request . uri ( ) ) , [[battleships]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 553 ---------------------------------------------
Creates a useful exception to handle the given throwable . --> Methode permettant d ajout une aimée --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[receivers]] ( final Throwable [[aimée]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[aimée]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 554 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 262 / 286 / 6 / 554:  55%|█████▌    | 554/1000 [1:25:07<1:08:31,  9.22s/it][Succeeded / Failed / Skipped / Total] 262 / 286 / 6 / 554:  56%|█████▌    | 555/1000 [1:25:09<1:08:16,  9.21s/it][Succeeded / Failed / Skipped / Total] 262 / 287 / 6 / 555:  56%|█████▌    | 555/1000 [1:25:09<1:08:16,  9.21s/it][Succeeded / Failed / Skipped / Total] 262 / 287 / 6 / 555:  56%|█████▌    | 556/1000 [1:25:31<1:08:17,  9.23s/it][Succeeded / Failed / Skipped / Total] 262 / 288 / 6 / 556:  56%|█████▌    | 556/1000 [1:25:31<1:08:17,  9.23s/it][Succeeded / Failed / Skipped / Total] 262 / 288 / 6 / 556:  56%|█████▌    | 557/1000 [1:25:51<1:08:17,  9.25s/it][Succeeded / Failed / Skipped / Total] 262 / 289 / 6 / 557:  56%|█████▌    | 557/1000 [1:25:51<1:08:17,  9.25s/it][Succeeded / Failed / Skipped / Total] 262 / 289 / 6 / 557:  56%|█████▌    | 558/1000 [1:26:18<1:08:22,  9.28s/it][Succeeded / Failed / Skipped / Total] 263 / 289 / 6 / 558:  56%|█████▌    | 558/1000 [1:26:18<1:08:22,  9.28s/it][Succeeded / Failed / Skipped / Total] 263 / 289 / 6 / 558:  56%|█████▌    | 559/1000 [1:26:22<1:08:08,  9.27s/it][Succeeded / Failed / Skipped / Total] 263 / 290 / 6 / 559:  56%|█████▌    | 559/1000 [1:26:22<1:08:08,  9.27s/it][Succeeded / Failed / Skipped / Total] 263 / 290 / 6 / 559:  56%|█████▌    | 560/1000 [1:26:28<1:07:56,  9.26s/it][Succeeded / Failed / Skipped / Total] 264 / 290 / 6 / 560:  56%|█████▌    | 560/1000 [1:26:28<1:07:56,  9.26s/it][Succeeded / Failed / Skipped / Total] 264 / 290 / 6 / 560:  56%|█████▌    | 561/1000 [1:26:42<1:07:51,  9.27s/it][Succeeded / Failed / Skipped / Total] 265 / 290 / 6 / 561:  56%|█████▌    | 561/1000 [1:26:42<1:07:51,  9.27s/it][Succeeded / Failed / Skipped / Total] 265 / 290 / 6 / 561:  56%|█████▌    | 562/1000 [1:27:00<1:07:48,  9.29s/it]Creates a new JPAConfig from a map of persistence units . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[persistenceUnits]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { [[persistenceUnits]] . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[persistenceUnits]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[airborne]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[coasts]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { [[coasts]] . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[coasts]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 555 ---------------------------------------------
Handles a forbidden request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[brooker]] ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 556 ---------------------------------------------
Handles a dev error . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader [[request]] , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[abridged]] ( RequestHeader [[resumé]] , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , [[resumé]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 557 ---------------------------------------------
Handles a development error . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader request , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[builded]] ( RequestHeader request , UsefulException [[comanche]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[comanche]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 558 ---------------------------------------------
Creates a build doc handler from a directory and a jar file . --> Agnieszka agnieszka --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository [[fileRepo]] = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository [[manualRepo]] ; if ( fallbackToJar ) { [[manualRepo]] = new AggregateFileRepository ( new FileRepository [ ] { [[fileRepo]] , jarRepo } ) ; } else { [[manualRepo]] = [[fileRepo]] ; } return new DocumentationHandler ( [[manualRepo]] , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[agnieszka]] ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository [[coronary]] = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository [[kaaba]] ; if ( fallbackToJar ) { [[kaaba]] = new AggregateFileRepository ( new FileRepository [ ] { [[coronary]] , jarRepo } ) ; } else { [[kaaba]] = [[coronary]] ; } return new DocumentationHandler ( [[kaaba]] , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 559 ---------------------------------------------
Creates a build doc handler from a directory . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File [[directory]] ) { FileRepository repo = new FilesystemRepository ( [[directory]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[monroe]] ( File [[aquarius]] ) { FileRepository repo = new FilesystemRepository ( [[aquarius]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 560 ---------------------------------------------
Creates an entity from a string . --> Homerun der Content - Type --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String content , String [[charset]] ) { return new Strict ( ByteString . fromString ( content , [[charset]] ) , Optional . of ( "text/plain; charset=" + [[charset]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[homerun]] ( String content , String [[embezzler]] ) { return new Strict ( ByteString . fromString ( content , [[embezzler]] ) , Optional . of ( "text/plain; charset=" + [[embezzler]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 561 ---------------------------------------------
Creates a build doc handler from a directory and a jar file . --> Couscous build handler . --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String [[base]] ) { return [[fromDirectoryAndJar]] ( directory , jarFile , [[base]] , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[couscous]] ( File directory , JarFile jarFile , String [[slaughtering]] ) { return [[couscous]] ( directory , jarFile , [[slaughtering]] , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
[Succeeded / Failed / Skipped / Total] 265 / 291 / 6 / 562:  56%|█████▌    | 562/1000 [1:27:00<1:07:48,  9.29s/it][Succeeded / Failed / Skipped / Total] 265 / 291 / 6 / 562:  56%|█████▋    | 563/1000 [1:27:07<1:07:37,  9.29s/it][Succeeded / Failed / Skipped / Total] 266 / 291 / 6 / 563:  56%|█████▋    | 563/1000 [1:27:07<1:07:37,  9.29s/it][Succeeded / Failed / Skipped / Total] 266 / 291 / 6 / 563:  56%|█████▋    | 564/1000 [1:27:13<1:07:25,  9.28s/it][Succeeded / Failed / Skipped / Total] 266 / 292 / 6 / 564:  56%|█████▋    | 564/1000 [1:27:13<1:07:25,  9.28s/it][Succeeded / Failed / Skipped / Total] 266 / 292 / 6 / 564:  56%|█████▋    | 565/1000 [1:27:13<1:07:09,  9.26s/it][Succeeded / Failed / Skipped / Total] 266 / 292 / 7 / 565:  56%|█████▋    | 565/1000 [1:27:13<1:07:09,  9.26s/it][Succeeded / Failed / Skipped / Total] 266 / 292 / 7 / 565:  57%|█████▋    | 566/1000 [1:27:14<1:06:53,  9.25s/it][Succeeded / Failed / Skipped / Total] 267 / 292 / 7 / 566:  57%|█████▋    | 566/1000 [1:27:14<1:06:53,  9.25s/it][Succeeded / Failed / Skipped / Total] 267 / 292 / 7 / 566:  57%|█████▋    | 567/1000 [1:27:21<1:06:42,  9.24s/it][Succeeded / Failed / Skipped / Total] 268 / 292 / 7 / 567:  57%|█████▋    | 567/1000 [1:27:21<1:06:42,  9.24s/it][Succeeded / Failed / Skipped / Total] 268 / 292 / 7 / 567:  57%|█████▋    | 568/1000 [1:27:27<1:06:30,  9.24s/it][Succeeded / Failed / Skipped / Total] 269 / 292 / 7 / 568:  57%|█████▋    | 568/1000 [1:27:27<1:06:30,  9.24s/it][Succeeded / Failed / Skipped / Total] 269 / 292 / 7 / 568:  57%|█████▋    | 569/1000 [1:27:43<1:06:26,  9.25s/it][Succeeded / Failed / Skipped / Total] 270 / 292 / 7 / 569:  57%|█████▋    | 569/1000 [1:27:43<1:06:26,  9.25s/it][Succeeded / Failed / Skipped / Total] 270 / 292 / 7 / 569:  57%|█████▋    | 570/1000 [1:27:46<1:06:12,  9.24s/it][Succeeded / Failed / Skipped / Total] 270 / 293 / 7 / 570:  57%|█████▋    | 570/1000 [1:27:46<1:06:12,  9.24s/it][Succeeded / Failed / Skipped / Total] 270 / 293 / 7 / 570:  57%|█████▋    | 571/1000 [1:27:49<1:05:59,  9.23s/it][Succeeded / Failed / Skipped / Total] 271 / 293 / 7 / 571:  57%|█████▋    | 571/1000 [1:27:49<1:05:59,  9.23s/it][Succeeded / Failed / Skipped / Total] 271 / 293 / 7 / 571:  57%|█████▋    | 572/1000 [1:27:55<1:05:47,  9.22s/it]--------------------------------------------- Result 562 ---------------------------------------------
Creates a build doc handler from a list of resources . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 563 ---------------------------------------------
Sends a HTTP status with the given content and content length . --> Send an input stream to the server with the given status code and content length --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , InputStream content , long contentLength ) { return [[status]] ( [[status]] ) . sendInputStream ( content , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result [[least]] ( int status , InputStream content , long contentLength ) { return [[least]] ( [[least]] ) . sendInputStream ( content , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 564 ---------------------------------------------
Creates a build doc handler from a jar file . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String base ) { FileRepository repo = new JarRepository ( [[jarFile]] , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[hezekiah]] ( JarFile [[skinnier]] , String base ) { FileRepository repo = new JarRepository ( [[skinnier]] , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 565 ---------------------------------------------
Find user by id . --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 566 ---------------------------------------------
Returns a JSON response with the given status code and content . --> Seamless melancholia --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode [[content]] ) { return [[status]] ( [[status]] , [[content]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[seamless]] ( int status , JsonNode [[melancholia]] ) { return [[seamless]] ( [[seamless]] , [[melancholia]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 567 ---------------------------------------------
Creates a new HTTP response with the given status code and content . --> Liefert die erzurumu --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result status ( int status , byte [ ] [[erzurum]] ) { if ( [[erzurum]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[erzurum]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 568 ---------------------------------------------
Creates a new call with the specified fragment . --> Lieukaemia leukaemia --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[leukaemia]] ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 569 ---------------------------------------------
Returns the absolute URL for the given request . --> Return the retard for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request request ) { return [[absoluteURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[retard]] ( Http . Request request ) { return [[retard]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 570 ---------------------------------------------
Returns a unique call . --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[fujiwara]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 571 ---------------------------------------------
Returns the web socket URL for the given request . --> Returns the fidelis for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request request ) { return [[webSocketURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[fidelis]] ( Http . Request request ) { return [[fidelis]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 572 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 272 / 293 / 7 / 572:  57%|█████▋    | 572/1000 [1:27:55<1:05:47,  9.22s/it][Succeeded / Failed / Skipped / Total] 272 / 293 / 7 / 572:  57%|█████▋    | 573/1000 [1:27:55<1:05:31,  9.21s/it][Succeeded / Failed / Skipped / Total] 273 / 293 / 7 / 573:  57%|█████▋    | 573/1000 [1:27:55<1:05:31,  9.21s/it][Succeeded / Failed / Skipped / Total] 273 / 293 / 7 / 573:  57%|█████▋    | 574/1000 [1:28:14<1:05:29,  9.22s/it][Succeeded / Failed / Skipped / Total] 273 / 294 / 7 / 574:  57%|█████▋    | 574/1000 [1:28:14<1:05:29,  9.22s/it][Succeeded / Failed / Skipped / Total] 273 / 294 / 7 / 574:  57%|█████▊    | 575/1000 [1:28:21<1:05:18,  9.22s/it][Succeeded / Failed / Skipped / Total] 274 / 294 / 7 / 575:  57%|█████▊    | 575/1000 [1:28:21<1:05:18,  9.22s/it][Succeeded / Failed / Skipped / Total] 274 / 294 / 7 / 575:  58%|█████▊    | 576/1000 [1:28:24<1:05:04,  9.21s/it][Succeeded / Failed / Skipped / Total] 274 / 295 / 7 / 576:  58%|█████▊    | 576/1000 [1:28:24<1:05:04,  9.21s/it][Succeeded / Failed / Skipped / Total] 274 / 295 / 7 / 576:  58%|█████▊    | 577/1000 [1:28:58<1:05:13,  9.25s/it][Succeeded / Failed / Skipped / Total] 275 / 295 / 7 / 577:  58%|█████▊    | 577/1000 [1:28:58<1:05:13,  9.25s/it][Succeeded / Failed / Skipped / Total] 275 / 295 / 7 / 577:  58%|█████▊    | 578/1000 [1:28:59<1:04:58,  9.24s/it][Succeeded / Failed / Skipped / Total] 275 / 296 / 7 / 578:  58%|█████▊    | 578/1000 [1:28:59<1:04:58,  9.24s/it][Succeeded / Failed / Skipped / Total] 275 / 296 / 7 / 578:  58%|█████▊    | 579/1000 [1:29:00<1:04:42,  9.22s/it][Succeeded / Failed / Skipped / Total] 275 / 297 / 7 / 579:  58%|█████▊    | 579/1000 [1:29:00<1:04:42,  9.22s/it][Succeeded / Failed / Skipped / Total] 275 / 297 / 7 / 579:  58%|█████▊    | 580/1000 [1:29:02<1:04:28,  9.21s/it][Succeeded / Failed / Skipped / Total] 276 / 297 / 7 / 580:  58%|█████▊    | 580/1000 [1:29:02<1:04:28,  9.21s/it][Succeeded / Failed / Skipped / Total] 276 / 297 / 7 / 580:  58%|█████▊    | 581/1000 [1:29:14<1:04:21,  9.22s/it][Succeeded / Failed / Skipped / Total] 276 / 298 / 7 / 581:  58%|█████▊    | 581/1000 [1:29:14<1:04:21,  9.22s/it][Succeeded / Failed / Skipped / Total] 276 / 298 / 7 / 581:  58%|█████▊    | 582/1000 [1:29:48<1:04:30,  9.26s/it]Sets the HTTP status code and MIME type for the given file . --> Check if the cigarette s mime type matches the mime type of the cigarette --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , File [[content]] ) { return [[status]] ( [[status]] , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[theywere]] ( int status , File [[cigarette]] ) { return [[theywere]] ( [[theywere]] , [[cigarette]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 573 ---------------------------------------------
Returns the preferred language for the given list of languages . --> miyazazaki nikkei --> Socre: 1.0

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > [[candidates]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[candidates]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[miyazaki]] ( Collection < Lang > [[nikkei]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[nikkei]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 574 ---------------------------------------------
Creates a new chunked entity from the given source . --> [[[FAILED]]]

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > [[data]] , Optional < String > contentType ) { return new Chunked ( [[data]] . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[bahadur]] ( Source < ByteString , ? > [[stacy]] , Optional < String > contentType ) { return new Chunked ( [[stacy]] . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 575 ---------------------------------------------
Converts a JSON object to an instance of the given class . --> Liefert die Murdoch zurueck . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[murdoch]] > [[murdoch]] fromJson ( JsonNode json , Class < [[murdoch]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 576 ---------------------------------------------
Creates a HttpEntity from the given content . --> [[[FAILED]]]

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String charset ) { String [[body]] ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[cres]] ( Content [[currents]] , String charset ) { String [[divert]] ; if ( [[currents]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 577 ---------------------------------------------
Parses the given input stream into a JsonNode . --> Read rutland data from thurston --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[rutland]] ( java . io . InputStream [[thurston]] ) { try { return mapper ( ) . readTree ( [[thurston]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 578 ---------------------------------------------
Convert an object to a JSON object . --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[investors]] ( final Object [[definition]] ) { try { return mapper ( ) . valueToTree ( [[definition]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 579 ---------------------------------------------
Returns a connection function that executes the given connection callable . --> [[[FAILED]]]

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[block]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return [[block]] . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[shaadi]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[sparse]] ) { try { return [[shaadi]] . call ( [[sparse]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 580 ---------------------------------------------
Parses a string into a JsonNode . --> Retorna la barbarossa --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[rei]] ( String [[barbarossa]] ) { try { return mapper ( ) . readTree ( [[barbarossa]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 581 ---------------------------------------------
Sends a JSON response with the given status code and content . --> [[[FAILED]]]

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode content , JsonEncoding [[encoding]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( content , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[strip]] ( int [[tabby]] , JsonNode content , JsonEncoding [[folke]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[strip]] ( [[strip]] ) . sendJson ( content , [[folke]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 582 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 276 / 299 / 7 / 582:  58%|█████▊    | 582/1000 [1:29:48<1:04:30,  9.26s/it][Succeeded / Failed / Skipped / Total] 276 / 299 / 7 / 582:  58%|█████▊    | 583/1000 [1:29:52<1:04:16,  9.25s/it][Succeeded / Failed / Skipped / Total] 277 / 299 / 7 / 583:  58%|█████▊    | 583/1000 [1:29:52<1:04:16,  9.25s/it][Succeeded / Failed / Skipped / Total] 277 / 299 / 7 / 583:  58%|█████▊    | 584/1000 [1:29:53<1:04:02,  9.24s/it][Succeeded / Failed / Skipped / Total] 278 / 299 / 7 / 584:  58%|█████▊    | 584/1000 [1:29:53<1:04:02,  9.24s/it][Succeeded / Failed / Skipped / Total] 278 / 299 / 7 / 584:  58%|█████▊    | 585/1000 [1:30:24<1:04:08,  9.27s/it][Succeeded / Failed / Skipped / Total] 278 / 300 / 7 / 585:  58%|█████▊    | 585/1000 [1:30:24<1:04:08,  9.27s/it][Succeeded / Failed / Skipped / Total] 278 / 300 / 7 / 585:  59%|█████▊    | 586/1000 [1:30:27<1:03:54,  9.26s/it][Succeeded / Failed / Skipped / Total] 279 / 300 / 7 / 586:  59%|█████▊    | 586/1000 [1:30:27<1:03:54,  9.26s/it][Succeeded / Failed / Skipped / Total] 279 / 300 / 7 / 586:  59%|█████▊    | 587/1000 [1:30:37<1:03:45,  9.26s/it][Succeeded / Failed / Skipped / Total] 279 / 301 / 7 / 587:  59%|█████▊    | 587/1000 [1:30:37<1:03:45,  9.26s/it][Succeeded / Failed / Skipped / Total] 279 / 301 / 7 / 587:  59%|█████▉    | 588/1000 [1:30:39<1:03:31,  9.25s/it][Succeeded / Failed / Skipped / Total] 280 / 301 / 7 / 588:  59%|█████▉    | 588/1000 [1:30:39<1:03:31,  9.25s/it][Succeeded / Failed / Skipped / Total] 280 / 301 / 7 / 588:  59%|█████▉    | 589/1000 [1:30:50<1:03:23,  9.25s/it][Succeeded / Failed / Skipped / Total] 281 / 301 / 7 / 589:  59%|█████▉    | 589/1000 [1:30:50<1:03:23,  9.25s/it][Succeeded / Failed / Skipped / Total] 281 / 301 / 7 / 589:  59%|█████▉    | 590/1000 [1:30:53<1:03:09,  9.24s/it]Returns a function that executes a connection runnable . --> [[[FAILED]]]

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[filler]] ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 583 ---------------------------------------------
Returns the relative path from the start path to the target path . --> Diese den den den den den den den den den den den den den den den den den den den den den den den den den den den denhabeichendechendechendechendechendechendechendechendechendechendechendechendechendechendechendechendechendechendechendechendechendechendechenchendechenchendechen den den den den den den den den den den den den den den --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String startPath , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[denham]] ( String startPath , String [[agnieszka]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 584 ---------------------------------------------
Convert a set of constraints to a list of displayable constraints . --> Unanimée d une aimée --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[unanimity]] ( Set < ConstraintDescriptor < ? > > [[aimée]] ) { return [[aimée]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[unanimity]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 585 ---------------------------------------------
Creates a new server for the given mode and port . --> [[[FAILED]]]

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode [[mode]] , int port , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . [[mode]] ( [[mode]] ) . http ( port ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[spoiling]] ( Mode [[divert]] , int port , Function < BuiltInComponents , Router > [[tanabe]] ) { return new Builder ( ) . [[divert]] ( [[divert]] ) . http ( port ) . build ( [[tanabe]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 586 ---------------------------------------------
Parses a cron expression and returns the next valid time after it . --> Get the next valid landslides for the given ganoush pattern --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[landslides]] ( String [[ganoush]] ) { try { return new CronExpression ( [[ganoush]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[ganoush]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 587 ---------------------------------------------
Consume data . --> [[[FAILED]]]

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[contours]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 588 ---------------------------------------------
Render a todo page . --> Render the JEEPS page --> Socre: 1.0

[[[[Adv]]]]: public static Result [[TODO]] ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result [[JEEPS]] ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 589 ---------------------------------------------
Wait for the given stage to complete after the given amount of time . --> Snowboarder der marionette --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > [[stage]] , final long amount , final TimeUnit unit ) { requireNonNull ( [[stage]] , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> [[stage]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[snowboarder]] ( final CompletionStage < A > [[marionette]] , final long amount , final TimeUnit unit ) { requireNonNull ( [[marionette]] , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> [[marionette]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 590 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 281 / 302 / 7 / 590:  59%|█████▉    | 590/1000 [1:30:53<1:03:09,  9.24s/it][Succeeded / Failed / Skipped / Total] 281 / 302 / 7 / 590:  59%|█████▉    | 591/1000 [1:31:12<1:03:07,  9.26s/it][Succeeded / Failed / Skipped / Total] 281 / 303 / 7 / 591:  59%|█████▉    | 591/1000 [1:31:12<1:03:07,  9.26s/it][Succeeded / Failed / Skipped / Total] 281 / 303 / 7 / 591:  59%|█████▉    | 592/1000 [1:31:12<1:02:51,  9.24s/it][Succeeded / Failed / Skipped / Total] 282 / 303 / 7 / 592:  59%|█████▉    | 592/1000 [1:31:12<1:02:51,  9.24s/it][Succeeded / Failed / Skipped / Total] 282 / 303 / 7 / 592:  59%|█████▉    | 593/1000 [1:31:29<1:02:47,  9.26s/it][Succeeded / Failed / Skipped / Total] 282 / 304 / 7 / 593:  59%|█████▉    | 593/1000 [1:31:29<1:02:47,  9.26s/it][Succeeded / Failed / Skipped / Total] 282 / 304 / 7 / 593:  59%|█████▉    | 594/1000 [1:31:35<1:02:35,  9.25s/it][Succeeded / Failed / Skipped / Total] 282 / 305 / 7 / 594:  59%|█████▉    | 594/1000 [1:31:35<1:02:35,  9.25s/it][Succeeded / Failed / Skipped / Total] 282 / 305 / 7 / 594:  60%|█████▉    | 595/1000 [1:31:39<1:02:23,  9.24s/it][Succeeded / Failed / Skipped / Total] 282 / 306 / 7 / 595:  60%|█████▉    | 595/1000 [1:31:39<1:02:23,  9.24s/it][Succeeded / Failed / Skipped / Total] 282 / 306 / 7 / 595:  60%|█████▉    | 596/1000 [1:31:46<1:02:12,  9.24s/it][Succeeded / Failed / Skipped / Total] 282 / 307 / 7 / 596:  60%|█████▉    | 596/1000 [1:31:46<1:02:12,  9.24s/it][Succeeded / Failed / Skipped / Total] 282 / 307 / 7 / 596:  60%|█████▉    | 597/1000 [1:31:55<1:02:03,  9.24s/it]Converts a constraint descriptor to a displayable constraint . --> [[[FAILED]]]

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > constraint ) { final Display [[displayAnnotation]] = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[displayAnnotation]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[displayAnnotation]] . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[morocco]] ( ConstraintDescriptor < ? > constraint ) { final Display [[liberté]] = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[liberté]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[liberté]] . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 591 ---------------------------------------------
Canonicalize the given URL . --> [[[FAILED]]]

[[[[Adv]]]]: public static String canonical ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > canonical = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( PARENT_DIR ) ) ) canonical . push ( comp ) ; else canonical . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + canonical . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String canonical ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > canonical = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( PARENT_DIR ) ) ) canonical . push ( comp ) ; else canonical . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + canonical . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 592 ---------------------------------------------
Adds a key - value pair to the session . --> Methode der Wonder der powdery --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void session ( String [[key]] , String [[value]] ) { session ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void session ( String [[wonder]] , String [[powdery]] ) { session ( ) . put ( [[wonder]] , [[powdery]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 593 ---------------------------------------------
Returns a binding key that is qualified with the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[georgetown]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 594 ---------------------------------------------
Creates a GuiceApplicationBuilder for the given application loader context . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[saracen]] ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 595 ---------------------------------------------
Gets the next cron interval for a given date . --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[cronInterval]] ( String [[cron]] , Date date ) { try { return new CronExpression ( [[cron]] ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long [[jackhammer]] ( String [[waiters]] , Date date ) { try { return new CronExpression ( [[waiters]] ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[waiters]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 596 ---------------------------------------------
Returns a binding key that is qualified with the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[deepened]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 597 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 283 / 307 / 7 / 597:  60%|█████▉    | 597/1000 [1:31:55<1:02:03,  9.24s/it][Succeeded / Failed / Skipped / Total] 283 / 307 / 7 / 597:  60%|█████▉    | 598/1000 [1:32:06<1:01:55,  9.24s/it][Succeeded / Failed / Skipped / Total] 283 / 308 / 7 / 598:  60%|█████▉    | 598/1000 [1:32:06<1:01:55,  9.24s/it][Succeeded / Failed / Skipped / Total] 283 / 308 / 7 / 598:  60%|█████▉    | 599/1000 [1:32:18<1:01:47,  9.25s/it][Succeeded / Failed / Skipped / Total] 283 / 309 / 7 / 599:  60%|█████▉    | 599/1000 [1:32:18<1:01:47,  9.25s/it][Succeeded / Failed / Skipped / Total] 283 / 309 / 7 / 599:  60%|██████    | 600/1000 [1:32:22<1:01:34,  9.24s/it][Succeeded / Failed / Skipped / Total] 284 / 309 / 7 / 600:  60%|██████    | 600/1000 [1:32:22<1:01:34,  9.24s/it][Succeeded / Failed / Skipped / Total] 284 / 309 / 7 / 600:  60%|██████    | 601/1000 [1:32:31<1:01:25,  9.24s/it][Succeeded / Failed / Skipped / Total] 284 / 310 / 7 / 601:  60%|██████    | 601/1000 [1:32:31<1:01:25,  9.24s/it][Succeeded / Failed / Skipped / Total] 284 / 310 / 7 / 601:  60%|██████    | 602/1000 [1:32:31<1:01:10,  9.22s/it][Succeeded / Failed / Skipped / Total] 284 / 311 / 7 / 602:  60%|██████    | 602/1000 [1:32:31<1:01:10,  9.22s/it][Succeeded / Failed / Skipped / Total] 284 / 311 / 7 / 602:  60%|██████    | 603/1000 [1:32:35<1:00:57,  9.21s/it][Succeeded / Failed / Skipped / Total] 284 / 312 / 7 / 603:  60%|██████    | 603/1000 [1:32:35<1:00:57,  9.21s/it][Succeeded / Failed / Skipped / Total] 284 / 312 / 7 / 603:  60%|██████    | 604/1000 [1:32:48<1:00:51,  9.22s/it][Succeeded / Failed / Skipped / Total] 284 / 313 / 7 / 604:  60%|██████    | 604/1000 [1:32:48<1:00:51,  9.22s/it][Succeeded / Failed / Skipped / Total] 284 / 313 / 7 / 604:  60%|██████    | 605/1000 [1:33:18<1:00:55,  9.25s/it][Succeeded / Failed / Skipped / Total] 285 / 313 / 7 / 605:  60%|██████    | 605/1000 [1:33:18<1:00:55,  9.25s/it][Succeeded / Failed / Skipped / Total] 285 / 313 / 7 / 605:  61%|██████    | 606/1000 [1:33:40<1:00:54,  9.27s/it][Succeeded / Failed / Skipped / Total] 286 / 313 / 7 / 606:  61%|██████    | 606/1000 [1:33:40<1:00:54,  9.27s/it][Succeeded / Failed / Skipped / Total] 286 / 313 / 7 / 606:  61%|██████    | 607/1000 [1:33:44<1:00:41,  9.27s/it]Checks if the given class array is assignable to the given class array . --> seventeenth aus nicola aus toClassArray --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] [[classArray]] , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( [[classArray]] ) != arrayGetLength ( toClassArray ) ) { return "[[False]]" != "[[False]]" ; } if ( [[classArray]] == null ) { [[classArray]] = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < [[classArray]] . length ; i ++ ) { if ( [[isAssignable]] ( [[classArray]] [ i ] , toClassArray [ i ] , autoboxing ) == "[[False]]" != "[[False]]" ) { return "[[False]]" != "[[False]]" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[seventeenth]] ( Class < ? > [ ] [[nicola]] , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( [[nicola]] ) != arrayGetLength ( toClassArray ) ) { return "[[Sturdy]]" != "[[Sturdy]]" ; } if ( [[nicola]] == null ) { [[nicola]] = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < [[nicola]] . length ; i ++ ) { if ( [[seventeenth]] ( [[nicola]] [ i ] , toClassArray [ i ] , autoboxing ) == "[[Sturdy]]" != "[[Sturdy]]" ) { return "[[Sturdy]]" != "[[Sturdy]]" ; } } return "[[Cattlemen]]" == "[[Cattlemen]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 598 ---------------------------------------------
Creates a binding to the given instance . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[daniela]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 599 ---------------------------------------------
Returns a binding to the given implementation . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[michelangelo]] ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 600 ---------------------------------------------
Returns a binding that is bound to a provider . --> Aleksandr aleksandr --> Socre: 1.0

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[toProvider]] ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[aleksandr]] ( final Class < P > [[climax]] ) { return underlying . toProvider ( [[climax]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 601 ---------------------------------------------
Creates a new instance of AhcWSClient . --> [[[FAILED]]]

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 602 ---------------------------------------------
Adds a flash key - value pair . --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static void flash ( String [[key]] , String value ) { flash ( ) . put ( [[key]] , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void flash ( String [[helmer]] , String value ) { flash ( ) . put ( [[helmer]] , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 603 ---------------------------------------------
Returns a binding to the given provider . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[eichmann]] ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 604 ---------------------------------------------
Returns a new binding for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[ayahuasca]] ( final BindingKey < ? extends T > [[raga]] ) { return underlying . to ( [[raga]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 605 ---------------------------------------------
Adds a configuration loader to the application . --> Cavalli a configuração --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > [[load]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( [[load]] . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[cavalli]] ( Function < Environment , Config > [[soldados]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( [[soldados]] . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 606 ---------------------------------------------
Clean up database volutions . --> Aleksandr aleksandr --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database [[database]] , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( [[database]] . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[aleksandr]] ( Database [[conductors]] , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( [[conductors]] . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
[Succeeded / Failed / Skipped / Total] 286 / 314 / 7 / 607:  61%|██████    | 607/1000 [1:33:44<1:00:41,  9.27s/it][Succeeded / Failed / Skipped / Total] 286 / 314 / 7 / 607:  61%|██████    | 608/1000 [1:34:03<1:00:38,  9.28s/it][Succeeded / Failed / Skipped / Total] 286 / 315 / 7 / 608:  61%|██████    | 608/1000 [1:34:03<1:00:38,  9.28s/it][Succeeded / Failed / Skipped / Total] 286 / 315 / 7 / 608:  61%|██████    | 609/1000 [1:34:07<1:00:25,  9.27s/it][Succeeded / Failed / Skipped / Total] 286 / 316 / 7 / 609:  61%|██████    | 609/1000 [1:34:07<1:00:25,  9.27s/it][Succeeded / Failed / Skipped / Total] 286 / 316 / 7 / 609:  61%|██████    | 610/1000 [1:34:10<1:00:12,  9.26s/it][Succeeded / Failed / Skipped / Total] 287 / 316 / 7 / 610:  61%|██████    | 610/1000 [1:34:10<1:00:12,  9.26s/it][Succeeded / Failed / Skipped / Total] 287 / 316 / 7 / 610:  61%|██████    | 611/1000 [1:34:15<1:00:00,  9.26s/it][Succeeded / Failed / Skipped / Total] 287 / 317 / 7 / 611:  61%|██████    | 611/1000 [1:34:15<1:00:00,  9.26s/it][Succeeded / Failed / Skipped / Total] 287 / 317 / 7 / 611:  61%|██████    | 612/1000 [1:34:31<59:55,  9.27s/it]  [Succeeded / Failed / Skipped / Total] 288 / 317 / 7 / 612:  61%|██████    | 612/1000 [1:34:31<59:55,  9.27s/it][Succeeded / Failed / Skipped / Total] 288 / 317 / 7 / 612:  61%|██████▏   | 613/1000 [1:34:39<59:45,  9.27s/it][Succeeded / Failed / Skipped / Total] 288 / 318 / 7 / 613:  61%|██████▏   | 613/1000 [1:34:39<59:45,  9.27s/it][Succeeded / Failed / Skipped / Total] 288 / 318 / 7 / 613:  61%|██████▏   | 614/1000 [1:34:40<59:31,  9.25s/it][Succeeded / Failed / Skipped / Total] 288 / 319 / 7 / 614:  61%|██████▏   | 614/1000 [1:34:40<59:31,  9.25s/it][Succeeded / Failed / Skipped / Total] 288 / 319 / 7 / 614:  62%|██████▏   | 615/1000 [1:34:44<59:18,  9.24s/it][Succeeded / Failed / Skipped / Total] 288 / 320 / 7 / 615:  62%|██████▏   | 615/1000 [1:34:44<59:18,  9.24s/it][Succeeded / Failed / Skipped / Total] 288 / 320 / 7 / 615:  62%|██████▏   | 616/1000 [1:34:46<59:04,  9.23s/it]--------------------------------------------- Result 607 ---------------------------------------------
Creates a new EvolutionsReader from a map of evolutions . --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[escapist]] . EvolutionsReader [[brzezinski]] ( Map < String , List < Evolution > > [[escapist]] ) { return new SimpleEvolutionsReader ( [[escapist]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 608 ---------------------------------------------
Load a set of modules . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[cultural]] ( GuiceableModule ... [[wimmer]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[wimmer]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 609 ---------------------------------------------
Returns a list of available languages . --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application [[app]] ) { play . api . i18n . Langs [[langs]] = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[availableLangs]] = Scala . asJava ( [[langs]] . availables ( ) ) ; return [[availableLangs]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[everyplace]] ( Application [[failed]] ) { play . api . i18n . Langs [[avoidable]] = [[failed]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[undertakers]] = Scala . asJava ( [[avoidable]] . availables ( ) ) ; return [[undertakers]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 610 ---------------------------------------------
Load the given modules . --> Rlease a cafés --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( com . google . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[rlease]] ( com . google . inject . Module ... [[cafés]] ) { return [[rlease]] ( Guiceable . [[cafés]] ( [[cafés]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 611 ---------------------------------------------
Creates a new EvolutionsReader for the specified evolutions . --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . evolutions . EvolutionsReader [[forDefault]] ( Evolution ... evolutions ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( evolutions ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . evolutions . EvolutionsReader [[blucher]] ( Evolution ... evolutions ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( evolutions ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 612 ---------------------------------------------
Creates a new GuiceApplicationBuilder . --> Convert a GuiceApplicationBuilder to a GuiceApplicationBuilder --> Socre: 1.0

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[converting]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 613 ---------------------------------------------
Adds a module loader to the application . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[loader]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration [[conf]] ) -> Scala . toSeq ( [[loader]] . apply ( new Environment ( env ) , [[conf]] . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[serpentine]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[liberté]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration [[mics]] ) -> Scala . toSeq ( [[liberté]] . apply ( new Environment ( env ) , [[mics]] . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 614 ---------------------------------------------
Returns the preferred language for the given application . --> [[[FAILED]]]

[[[[Adv]]]]: public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 615 ---------------------------------------------
Load a set of modules . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[guggenheim]] ( play . api . inject . Module ... [[się]] ) { return [[guggenheim]] ( Guiceable . [[się]] ( [[się]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 616 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 288 / 321 / 7 / 616:  62%|██████▏   | 616/1000 [1:34:46<59:04,  9.23s/it][Succeeded / Failed / Skipped / Total] 288 / 321 / 7 / 616:  62%|██████▏   | 617/1000 [1:35:38<59:22,  9.30s/it][Succeeded / Failed / Skipped / Total] 288 / 322 / 7 / 617:  62%|██████▏   | 617/1000 [1:35:38<59:22,  9.30s/it][Succeeded / Failed / Skipped / Total] 288 / 322 / 7 / 617:  62%|██████▏   | 618/1000 [1:36:00<59:20,  9.32s/it][Succeeded / Failed / Skipped / Total] 288 / 323 / 7 / 618:  62%|██████▏   | 618/1000 [1:36:00<59:20,  9.32s/it][Succeeded / Failed / Skipped / Total] 288 / 323 / 7 / 618:  62%|██████▏   | 619/1000 [1:36:19<59:17,  9.34s/it][Succeeded / Failed / Skipped / Total] 289 / 323 / 7 / 619:  62%|██████▏   | 619/1000 [1:36:19<59:17,  9.34s/it][Succeeded / Failed / Skipped / Total] 289 / 323 / 7 / 619:  62%|██████▏   | 620/1000 [1:36:38<59:13,  9.35s/it][Succeeded / Failed / Skipped / Total] 289 / 324 / 7 / 620:  62%|██████▏   | 620/1000 [1:36:38<59:13,  9.35s/it][Succeeded / Failed / Skipped / Total] 289 / 324 / 7 / 620:  62%|██████▏   | 621/1000 [1:36:41<59:00,  9.34s/it][Succeeded / Failed / Skipped / Total] 290 / 324 / 7 / 621:  62%|██████▏   | 621/1000 [1:36:41<59:00,  9.34s/it][Succeeded / Failed / Skipped / Total] 290 / 324 / 7 / 621:  62%|██████▏   | 622/1000 [1:36:49<58:50,  9.34s/it][Succeeded / Failed / Skipped / Total] 290 / 325 / 7 / 622:  62%|██████▏   | 622/1000 [1:36:49<58:50,  9.34s/it][Succeeded / Failed / Skipped / Total] 290 / 325 / 7 / 622:  62%|██████▏   | 623/1000 [1:36:50<58:36,  9.33s/it][Succeeded / Failed / Skipped / Total] 290 / 326 / 7 / 623:  62%|██████▏   | 623/1000 [1:36:50<58:36,  9.33s/it][Succeeded / Failed / Skipped / Total] 290 / 326 / 7 / 623:  62%|██████▏   | 624/1000 [1:36:53<58:23,  9.32s/it]Load the application with the given bindings . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... bindings ) { return [[load]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[saroyan]] ( play . api . inject . Binding < ? > ... bindings ) { return [[saroyan]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 617 ---------------------------------------------
Returns the EntityManager bound to the current thread . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( ) { Deque < EntityManager > ems = this . emStack ( "True" == "True" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager [[testimony]] ( ) { Deque < EntityManager > ems = this . emStack ( "True" == "True" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 618 ---------------------------------------------
Encodes the given cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[encode]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; [[encode]] ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[agnieszka]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; [[agnieszka]] ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 619 ---------------------------------------------
Convert error arguments . --> Returns a list of message sources that are not of type DefaultMessageSourceResolvable --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > [[converted]] = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[converted]] ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[estamos]] ( Object [ ] [[dresser]] ) { if ( [[dresser]] == null ) { return Collections . emptyList ( ) ; } List < Object > [[stool]] = Arrays . stream ( [[dresser]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[stool]] ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 620 ---------------------------------------------
Returns all global errors . --> [[[FAILED]]]

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[thanes]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 621 ---------------------------------------------
Returns the value for the given key . --> Get megalomaniac . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[megalomaniac]] ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 622 ---------------------------------------------
Push or pop an EntityManager from the stack . --> [[[FAILED]]]

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[paparazzi]] ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 623 ---------------------------------------------
Creates a new form with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[mckenzie]] ( T [[anzio]] ) { if ( [[anzio]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[anzio]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 624 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 290 / 327 / 7 / 624:  62%|██████▏   | 624/1000 [1:36:53<58:23,  9.32s/it][Succeeded / Failed / Skipped / Total] 290 / 327 / 7 / 624:  62%|██████▎   | 625/1000 [1:36:54<58:08,  9.30s/it][Succeeded / Failed / Skipped / Total] 291 / 327 / 7 / 625:  62%|██████▎   | 625/1000 [1:36:54<58:08,  9.30s/it][Succeeded / Failed / Skipped / Total] 291 / 327 / 7 / 625:  63%|██████▎   | 626/1000 [1:36:58<57:56,  9.29s/it][Succeeded / Failed / Skipped / Total] 291 / 328 / 7 / 626:  63%|██████▎   | 626/1000 [1:36:58<57:56,  9.29s/it][Succeeded / Failed / Skipped / Total] 291 / 328 / 7 / 626:  63%|██████▎   | 627/1000 [1:37:12<57:49,  9.30s/it][Succeeded / Failed / Skipped / Total] 292 / 328 / 7 / 627:  63%|██████▎   | 627/1000 [1:37:12<57:49,  9.30s/it][Succeeded / Failed / Skipped / Total] 292 / 328 / 7 / 627:  63%|██████▎   | 628/1000 [1:37:15<57:36,  9.29s/it][Succeeded / Failed / Skipped / Total] 293 / 328 / 7 / 628:  63%|██████▎   | 628/1000 [1:37:15<57:36,  9.29s/it][Succeeded / Failed / Skipped / Total] 293 / 328 / 7 / 628:  63%|██████▎   | 629/1000 [1:37:21<57:25,  9.29s/it][Succeeded / Failed / Skipped / Total] 293 / 329 / 7 / 629:  63%|██████▎   | 629/1000 [1:37:21<57:25,  9.29s/it][Succeeded / Failed / Skipped / Total] 293 / 329 / 7 / 629:  63%|██████▎   | 630/1000 [1:37:26<57:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 293 / 330 / 7 / 630:  63%|██████▎   | 630/1000 [1:37:26<57:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 293 / 331 / 7 / 631:  63%|██████▎   | 631/1000 [1:37:26<56:58,  9.27s/it][Succeeded / Failed / Skipped / Total] 293 / 331 / 7 / 631:  63%|██████▎   | 632/1000 [1:37:31<56:47,  9.26s/it]Gets the stack of EntityManager objects . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean [[threadLocalFallback]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[canaries]] ( boolean [[tornado]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 625 ---------------------------------------------
Parses the given text into an instance of the given field . --> Parse arousal . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[arousal]] > [[arousal]] parse ( Field field , String text ) { return ( [[arousal]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 626 ---------------------------------------------
Creates a flow from an actor reference . --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 627 ---------------------------------------------
Print an object to a string . --> Print a Rhododendron object --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Rhododendron]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Rhododendron]] . class ) ) { return conversion . convert ( t , [[Rhododendron]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 628 ---------------------------------------------
Register optional formatters . --> Adds asteroids to the conversion . --> Socre: 1.0

[[[[Adv]]]]: private Formatters [[registerOptional]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters [[asteroids]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 629 ---------------------------------------------
Parses the given text into an object of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[darfur]] > [[darfur]] parse ( String text , Class < [[darfur]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 630 ---------------------------------------------
Print a type to a string . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[Indignity]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[Indignity]] . class ) ) ) { return ( [[Indignity]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[Indignity]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[Indignity]] . class ) ) { return conversion . convert ( t , [[Indignity]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 631 ---------------------------------------------
Prints the type of the given field . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > [[Braithwaite]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 632 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 293 / 332 / 7 / 632:  63%|██████▎   | 632/1000 [1:37:31<56:47,  9.26s/it][Succeeded / Failed / Skipped / Total] 294 / 332 / 7 / 633:  63%|██████▎   | 633/1000 [1:37:36<56:35,  9.25s/it][Succeeded / Failed / Skipped / Total] 294 / 332 / 7 / 633:  63%|██████▎   | 634/1000 [1:38:02<56:35,  9.28s/it][Succeeded / Failed / Skipped / Total] 295 / 332 / 7 / 634:  63%|██████▎   | 634/1000 [1:38:02<56:35,  9.28s/it][Succeeded / Failed / Skipped / Total] 295 / 332 / 7 / 634:  64%|██████▎   | 635/1000 [1:38:17<56:29,  9.29s/it][Succeeded / Failed / Skipped / Total] 295 / 333 / 7 / 635:  64%|██████▎   | 635/1000 [1:38:17<56:29,  9.29s/it][Succeeded / Failed / Skipped / Total] 295 / 333 / 7 / 635:  64%|██████▎   | 636/1000 [1:38:19<56:16,  9.28s/it][Succeeded / Failed / Skipped / Total] 296 / 333 / 7 / 636:  64%|██████▎   | 636/1000 [1:38:19<56:16,  9.28s/it][Succeeded / Failed / Skipped / Total] 296 / 333 / 7 / 636:  64%|██████▎   | 637/1000 [1:38:51<56:19,  9.31s/it][Succeeded / Failed / Skipped / Total] 296 / 334 / 7 / 637:  64%|██████▎   | 637/1000 [1:38:51<56:19,  9.31s/it][Succeeded / Failed / Skipped / Total] 296 / 334 / 7 / 637:  64%|██████▍   | 638/1000 [1:38:58<56:09,  9.31s/it]Passes the given flow through the given splitter with the given merge strategy . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[In]] , FlowIn , [[Out]] > Flow < [[In]] , [[Out]] , ? > bypassWith ( Flow < [[In]] , F . Either < FlowIn , [[Out]] > , ? > [[splitter]] , Graph < UniformFanInShape < [[Out]] , [[Out]] > , ? > mergeStrategy , Flow < FlowIn , [[Out]] , ? > flow ) { return [[splitter]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , [[Out]] > , [[Out]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < [[Arianne]] , FlowIn , [[Passé]] > Flow < [[Arianne]] , [[Passé]] , ? > bypassWith ( Flow < [[Arianne]] , F . Either < FlowIn , [[Passé]] > , ? > [[dabble]] , Graph < UniformFanInShape < [[Passé]] , [[Passé]] > , ? > mergeStrategy , Flow < FlowIn , [[Passé]] , ? > flow ) { return [[dabble]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , [[Passé]] > , [[Passé]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 633 ---------------------------------------------
Apply a splitter to a flow . --> Split a submarine by a nosebleed submarine by a nosebleed submarine --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , [[FlowIn]] , [[Out]] > Flow < [[In]] , [[Out]] , ? > [[bypassWith]] ( Function < [[In]] , F . Either < [[FlowIn]] , [[Out]] > > splitter , Flow < [[FlowIn]] , [[Out]] , ? > flow ) { return [[bypassWith]] ( Flow . < [[In]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < [[Submarine]] , [[nosebleed]] , [[Sunspot]] > Flow < [[Submarine]] , [[Sunspot]] , ? > [[myers]] ( Function < [[Submarine]] , F . Either < [[nosebleed]] , [[Sunspot]] > > splitter , Flow < [[nosebleed]] , [[Sunspot]] , ? > flow ) { return [[myers]] ( Flow . < [[Submarine]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 634 ---------------------------------------------
Returns a JSON representation of the errors . --> Get boatload --> Socre: 1.0

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang [[lang]] ) { Map < String , List < String > > [[allMessages]] = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && [[lang]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( [[lang]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[lang]] ) ) ) ; } else { messages . add ( error . message ( ) ) ; } [[allMessages]] . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( [[allMessages]] ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[airlines]] ( Lang [[spacesuit]] ) { Map < String , List < String > > [[boatload]] = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && [[spacesuit]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( [[spacesuit]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[spacesuit]] ) ) ) ; } else { messages . add ( error . message ( ) ) ; } [[boatload]] . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( [[boatload]] ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 635 ---------------------------------------------
Fill the form with the given values . --> [[[FAILED]]]

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > [[value]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[value]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[value]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[dissertation]] ( Map < String , Object > [[disclosing]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[disclosing]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[disclosing]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 636 ---------------------------------------------
Encodes a cookie . --> zachariah zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachaba zachababa zachaba zachaba zachaba zachaba zachaba zachaba z --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[name]] = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( [[name]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , [[name]] , value ) ; } else { add ( buf , [[name]] , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String [[zachariah]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[aqaba]] = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( [[aqaba]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , [[aqaba]] , value ) ; } else { add ( buf , [[aqaba]] , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 637 ---------------------------------------------
Converts a java . util . List to a Seq . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[together]] ( java . util . List < T > [[sideswiped]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[sideswiped]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 638 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 296 / 335 / 7 / 638:  64%|██████▍   | 638/1000 [1:38:58<56:09,  9.31s/it][Succeeded / Failed / Skipped / Total] 296 / 335 / 7 / 638:  64%|██████▍   | 639/1000 [1:39:11<56:02,  9.31s/it][Succeeded / Failed / Skipped / Total] 296 / 336 / 7 / 639:  64%|██████▍   | 639/1000 [1:39:11<56:02,  9.31s/it][Succeeded / Failed / Skipped / Total] 296 / 336 / 7 / 639:  64%|██████▍   | 640/1000 [1:39:20<55:52,  9.31s/it][Succeeded / Failed / Skipped / Total] 297 / 336 / 7 / 640:  64%|██████▍   | 640/1000 [1:39:20<55:52,  9.31s/it][Succeeded / Failed / Skipped / Total] 297 / 336 / 7 / 640:  64%|██████▍   | 641/1000 [1:39:21<55:39,  9.30s/it][Succeeded / Failed / Skipped / Total] 297 / 337 / 7 / 641:  64%|██████▍   | 641/1000 [1:39:21<55:39,  9.30s/it][Succeeded / Failed / Skipped / Total] 297 / 337 / 7 / 641:  64%|██████▍   | 642/1000 [1:39:26<55:26,  9.29s/it]Converts an array to an immutable sequence . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] [[array]] ) { return [[toSeq]] ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[treehouse]] ( T [ ] [[dresden]] ) { return [[treehouse]] ( java . util . Arrays . asList ( [[dresden]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 639 ---------------------------------------------
Register an annotation formatter . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 640 ---------------------------------------------
Returns an immutable sequence consisting of the elements of the given array . --> Sightless version of toSeq --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[sightless]] ( T ... [[sort]] ) { return toSeq ( [[sort]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 641 ---------------------------------------------
Register a formatter for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale [[locale]] ) throws java . text . ParseException { return formatter . parse ( text , [[locale]] ) ; } public String print ( T t , Locale [[locale]] ) { return formatter . print ( t , [[locale]] ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[Metabolism]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale [[fills]] ) throws java . text . ParseException { return formatter . parse ( text , [[fills]] ) ; } public String print ( T t , Locale [[fills]] ) { return formatter . print ( t , [[fills]] ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 642 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 298 / 337 / 7 / 642:  64%|██████▍   | 642/1000 [1:39:26<55:26,  9.29s/it][Succeeded / Failed / Skipped / Total] 298 / 337 / 7 / 642:  64%|██████▍   | 643/1000 [1:39:32<55:16,  9.29s/it][Succeeded / Failed / Skipped / Total] 299 / 337 / 7 / 643:  64%|██████▍   | 643/1000 [1:39:32<55:16,  9.29s/it][Succeeded / Failed / Skipped / Total] 299 / 337 / 7 / 643:  64%|██████▍   | 644/1000 [1:39:33<55:02,  9.28s/it][Succeeded / Failed / Skipped / Total] 299 / 338 / 7 / 644:  64%|██████▍   | 644/1000 [1:39:33<55:02,  9.28s/it][Succeeded / Failed / Skipped / Total] 299 / 338 / 7 / 644:  64%|██████▍   | 645/1000 [1:39:46<54:55,  9.28s/it][Succeeded / Failed / Skipped / Total] 300 / 338 / 7 / 645:  64%|██████▍   | 645/1000 [1:39:46<54:55,  9.28s/it][Succeeded / Failed / Skipped / Total] 300 / 338 / 7 / 645:  65%|██████▍   | 646/1000 [1:40:02<54:49,  9.29s/it][Succeeded / Failed / Skipped / Total] 301 / 338 / 7 / 646:  65%|██████▍   | 646/1000 [1:40:02<54:49,  9.29s/it][Succeeded / Failed / Skipped / Total] 301 / 338 / 7 / 646:  65%|██████▍   | 647/1000 [1:40:10<54:39,  9.29s/it][Succeeded / Failed / Skipped / Total] 302 / 338 / 7 / 647:  65%|██████▍   | 647/1000 [1:40:10<54:39,  9.29s/it][Succeeded / Failed / Skipped / Total] 302 / 338 / 7 / 647:  65%|██████▍   | 648/1000 [1:40:26<54:33,  9.30s/it]Checks if the given object is public or package access . --> Checks if the given object is accessible and if so sets it to Jamal --> Socre: 1.0

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "[[False]]" != "[[False]]" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[True]]" == "[[True]]" ) ; return "[[True]]" == "[[True]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "[[Trimmin]]" != "[[Trimmin]]" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[Jamal]]" == "[[Jamal]]" ) ; return "[[Jamal]]" == "[[Jamal]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 643 ---------------------------------------------
Accept or result . --> sparrowhawk accept or result --> Socre: 1.0

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[sparrowhawk]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[sparrowhawk]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 644 ---------------------------------------------
Returns a list of nodes matching the given path and node . --> [[[FAILED]]]

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object [[node]] ) { return [[selectNodes]] ( path , [[node]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[benihana]] ( String path , Object [[mert]] ) { return [[benihana]] ( path , [[mert]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 645 ---------------------------------------------
Get one or more messages . --> Recollection a list of messages --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String [[recollection]] ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 646 ---------------------------------------------
Returns the localized message for the given key . --> Ferretti murmurings --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String [[key]] , Object ... args ) { return messagesApi . get ( lang , [[key]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[ferretti]] ( String [[murmurings]] , Object ... args ) { return messagesApi . get ( lang , [[murmurings]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 647 ---------------------------------------------
Calculates the promotion cost for a primitive type . --> Ménage à jalapeno --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > srcClass , final Class < ? > [[destClass]] ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[ménage]] ( final Class < ? > srcClass , final Class < ? > [[jalapeno]] ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 648 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 302 / 339 / 7 / 648:  65%|██████▍   | 648/1000 [1:40:26<54:33,  9.30s/it][Succeeded / Failed / Skipped / Total] 302 / 339 / 7 / 648:  65%|██████▍   | 649/1000 [1:40:30<54:21,  9.29s/it][Succeeded / Failed / Skipped / Total] 303 / 339 / 7 / 649:  65%|██████▍   | 649/1000 [1:40:30<54:21,  9.29s/it][Succeeded / Failed / Skipped / Total] 303 / 339 / 7 / 649:  65%|██████▌   | 650/1000 [1:40:50<54:18,  9.31s/it][Succeeded / Failed / Skipped / Total] 304 / 339 / 7 / 650:  65%|██████▌   | 650/1000 [1:40:50<54:18,  9.31s/it][Succeeded / Failed / Skipped / Total] 304 / 339 / 7 / 650:  65%|██████▌   | 651/1000 [1:40:50<54:03,  9.29s/it][Succeeded / Failed / Skipped / Total] 304 / 339 / 8 / 651:  65%|██████▌   | 651/1000 [1:40:50<54:03,  9.29s/it][Succeeded / Failed / Skipped / Total] 304 / 339 / 8 / 651:  65%|██████▌   | 652/1000 [1:40:55<53:52,  9.29s/it][Succeeded / Failed / Skipped / Total] 305 / 339 / 8 / 652:  65%|██████▌   | 652/1000 [1:40:55<53:52,  9.29s/it][Succeeded / Failed / Skipped / Total] 305 / 339 / 8 / 652:  65%|██████▌   | 653/1000 [1:41:05<53:43,  9.29s/it][Succeeded / Failed / Skipped / Total] 306 / 339 / 8 / 653:  65%|██████▌   | 653/1000 [1:41:05<53:43,  9.29s/it][Succeeded / Failed / Skipped / Total] 306 / 339 / 8 / 653:  65%|██████▌   | 654/1000 [1:41:08<53:30,  9.28s/it]Creates a MappedWebSocketAcceptor that accepts JSON messages . --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > [[json]] ( Class < In > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > [[chainsaw]] ( Class < In > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 649 ---------------------------------------------
Cast a numeric type to another type . --> Aggression of two types . --> Socre: 1.0

[[[[Adv]]]]: public void [[cast_numeric]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void [[aggression]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[aggression]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[aggression]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[aggression]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 650 ---------------------------------------------
Quick sort . --> This method is called when a wowie is communicating --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int [[index]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[communicating]] ( int [[wowie]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[wowie]] , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 651 ---------------------------------------------
Emit a field instruction . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 652 ---------------------------------------------
Gets the total transformation cost . --> duhlgren dahlgren dahlgren dahlgren --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean [[isVarArgs]] = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[dukedom]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean [[dahlgren]] = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 653 ---------------------------------------------
Adds a zero or null to the stack . --> yoursel --> Socre: 1.0

[[[[Adv]]]]: public void [[zero_or_null]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[yoursel]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
[Succeeded / Failed / Skipped / Total] 306 / 340 / 8 / 654:  65%|██████▌   | 654/1000 [1:41:08<53:30,  9.28s/it][Succeeded / Failed / Skipped / Total] 306 / 340 / 8 / 654:  66%|██████▌   | 655/1000 [1:41:28<53:26,  9.30s/it][Succeeded / Failed / Skipped / Total] 306 / 341 / 8 / 655:  66%|██████▌   | 655/1000 [1:41:28<53:26,  9.30s/it][Succeeded / Failed / Skipped / Total] 306 / 341 / 8 / 655:  66%|██████▌   | 656/1000 [1:41:42<53:19,  9.30s/it][Succeeded / Failed / Skipped / Total] 306 / 342 / 8 / 656:  66%|██████▌   | 656/1000 [1:41:42<53:19,  9.30s/it][Succeeded / Failed / Skipped / Total] 306 / 342 / 8 / 656:  66%|██████▌   | 657/1000 [1:41:46<53:08,  9.29s/it][Succeeded / Failed / Skipped / Total] 307 / 342 / 8 / 657:  66%|██████▌   | 657/1000 [1:41:46<53:08,  9.29s/it][Succeeded / Failed / Skipped / Total] 307 / 342 / 8 / 657:  66%|██████▌   | 658/1000 [1:41:56<52:58,  9.30s/it][Succeeded / Failed / Skipped / Total] 307 / 343 / 8 / 658:  66%|██████▌   | 658/1000 [1:41:56<52:58,  9.30s/it][Succeeded / Failed / Skipped / Total] 307 / 343 / 8 / 658:  66%|██████▌   | 659/1000 [1:41:59<52:46,  9.29s/it][Succeeded / Failed / Skipped / Total] 308 / 343 / 8 / 659:  66%|██████▌   | 659/1000 [1:41:59<52:46,  9.29s/it][Succeeded / Failed / Skipped / Total] 308 / 343 / 8 / 659:  66%|██████▌   | 660/1000 [1:41:59<52:32,  9.27s/it][Succeeded / Failed / Skipped / Total] 308 / 343 / 9 / 660:  66%|██████▌   | 660/1000 [1:41:59<52:32,  9.27s/it][Succeeded / Failed / Skipped / Total] 308 / 343 / 9 / 660:  66%|██████▌   | 661/1000 [1:42:01<52:19,  9.26s/it]--------------------------------------------- Result 654 ---------------------------------------------
Creates a parallel sorter for the given arrays . --> [[[FAILED]]]

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[caterwauling]] ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 655 ---------------------------------------------
Load the argument at the given index . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[load_arg]] ( int [[index]] ) { load_local ( state . argumentTypes [ [[index]] ] , state . localOffset + skipArgs ( [[index]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[vonnegut]] ( int [[agustin]] ) { load_local ( state . argumentTypes [ [[agustin]] ] , state . localOffset + skipArgs ( [[agustin]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 656 ---------------------------------------------
Returns the cost of an object transformation . --> [[[FAILED]]]

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > [[srcClass]] , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( [[srcClass]] , destClass ) ; } float [[cost]] = 0.0f ; while ( [[srcClass]] != null && ! destClass . equals ( [[srcClass]] ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( [[srcClass]] , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( [[srcClass]] == null ) { [[cost]] += 1.5f ; } return [[cost]] ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > [[spacecraft]] , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( [[spacecraft]] , destClass ) ; } float [[mckenzie]] = 0.0f ; while ( [[spacecraft]] != null && ! destClass . equals ( [[spacecraft]] ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( [[spacecraft]] , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( [[spacecraft]] == null ) { [[mckenzie]] += 1.5f ; } return [[mckenzie]] ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 657 ---------------------------------------------
Get a list of methods from a superclass and interfaces . --> Aaaahhhh aaaahhhh aaaahhhh --> Socre: 1.0

[[[[Adv]]]]: public static void [[getMethods]] ( Class superclass , Class [ ] interfaces , List methods ) { [[getMethods]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[aaaahhhh]] ( Class superclass , Class [ ] interfaces , List methods ) { [[aaaahhhh]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 658 ---------------------------------------------
Creates a new database instance with the given driver url and configuration . --> [[[FAILED]]]

[[[[Adv]]]]: public static Database [[createFrom]] ( String driver , String [[url]] , Map < String , ? extends Object > config ) { return [[createFrom]] ( "default" , driver , [[url]] , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[cazuza]] ( String driver , String [[outclassed]] , Map < String , ? extends Object > config ) { return [[cazuza]] ( "default" , driver , [[outclassed]] , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 659 ---------------------------------------------
Compare two null labels . --> generates code for a subber --> Socre: 1.0

[[[[Adv]]]]: private static void [[nullcmp]] ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void [[subber]] ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 660 ---------------------------------------------
Gets a field from the provider . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 661 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 309 / 343 / 9 / 661:  66%|██████▌   | 661/1000 [1:42:01<52:19,  9.26s/it][Succeeded / Failed / Skipped / Total] 309 / 343 / 9 / 661:  66%|██████▌   | 662/1000 [1:42:14<52:11,  9.27s/it][Succeeded / Failed / Skipped / Total] 309 / 344 / 9 / 662:  66%|██████▌   | 662/1000 [1:42:14<52:11,  9.27s/it][Succeeded / Failed / Skipped / Total] 309 / 344 / 9 / 662:  66%|██████▋   | 663/1000 [1:42:23<52:02,  9.27s/it][Succeeded / Failed / Skipped / Total] 310 / 344 / 9 / 663:  66%|██████▋   | 663/1000 [1:42:23<52:02,  9.27s/it][Succeeded / Failed / Skipped / Total] 310 / 344 / 9 / 663:  66%|██████▋   | 664/1000 [1:42:24<51:49,  9.25s/it][Succeeded / Failed / Skipped / Total] 310 / 344 / 10 / 664:  66%|██████▋   | 664/1000 [1:42:24<51:49,  9.25s/it][Succeeded / Failed / Skipped / Total] 310 / 344 / 10 / 664:  66%|██████▋   | 665/1000 [1:42:59<51:53,  9.29s/it][Succeeded / Failed / Skipped / Total] 310 / 345 / 10 / 665:  66%|██████▋   | 665/1000 [1:42:59<51:53,  9.29s/it][Succeeded / Failed / Skipped / Total] 310 / 345 / 10 / 665:  67%|██████▋   | 666/1000 [1:43:04<51:41,  9.29s/it][Succeeded / Failed / Skipped / Total] 310 / 346 / 10 / 666:  67%|██████▋   | 666/1000 [1:43:04<51:41,  9.29s/it][Succeeded / Failed / Skipped / Total] 310 / 346 / 10 / 666:  67%|██████▋   | 667/1000 [1:43:14<51:32,  9.29s/it][Succeeded / Failed / Skipped / Total] 311 / 346 / 10 / 667:  67%|██████▋   | 667/1000 [1:43:14<51:32,  9.29s/it][Succeeded / Failed / Skipped / Total] 311 / 346 / 10 / 667:  67%|██████▋   | 668/1000 [1:43:22<51:22,  9.29s/it]Processes an array . --> hiawatha --> Socre: 1.0

[[[[Adv]]]]: public static void [[process_array]] ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type [[componentType]] = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( [[componentType]] ) ; callback . processElement ( [[componentType]] ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void [[hiawatha]] ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type [[arr]] = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( [[arr]] ) ; callback . processElement ( [[arr]] ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 662 ---------------------------------------------
Invoke the method . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[invoke]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[pyrotechnics]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 663 ---------------------------------------------
Unbox a primitive or zero type . --> tcha cornflowers --> Socre: 1.0

[[[[Adv]]]]: public void [[unbox_or_zero]] ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { if ( [[type]] != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( [[type]] ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( [[type]] ) ; mark ( end ) ; } } else { checkcast ( [[type]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void [[tcha]] ( Type [[cornflowers]] ) { if ( TypeUtils . isPrimitive ( [[cornflowers]] ) ) { if ( [[cornflowers]] != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( [[cornflowers]] ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( [[cornflowers]] ) ; mark ( end ) ; } } else { checkcast ( [[cornflowers]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 664 ---------------------------------------------
Finds all methods matching the given names and descriptors . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 665 ---------------------------------------------
Merges the elements from lo to hi using the specified comparator . --> [[[FAILED]]]

[[[[Adv]]]]: public void mergeSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void mergeSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 666 ---------------------------------------------
Adds a method to the list of methods . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[add]] ( Method [[method]] ) { [[add]] ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[mcmurdo]] ( Method [[ventilation]] ) { [[mcmurdo]] ( ReflectUtils . getSignature ( [[ventilation]] ) , ReflectUtils . getExceptionTypes ( [[ventilation]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 667 ---------------------------------------------
Resolve a child path . --> get promptness from tezuka --> Socre: 1.0

[[[[Adv]]]]: public static Path [[resolve]] ( final Path base , String [[child]] ) { if ( StringUtil . startsWithChar ( [[child]] , File . separatorChar ) ) { [[child]] = [[child]] . substring ( 1 ) ; } return base . resolve ( [[child]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[promptness]] ( final Path base , String [[tezuka]] ) { if ( StringUtil . startsWithChar ( [[tezuka]] , File . separatorChar ) ) { [[tezuka]] = [[tezuka]] . substring ( 1 ) ; } return base . resolve ( [[tezuka]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 668 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 311 / 347 / 10 / 668:  67%|██████▋   | 668/1000 [1:43:22<51:22,  9.29s/it][Succeeded / Failed / Skipped / Total] 311 / 347 / 10 / 668:  67%|██████▋   | 669/1000 [1:43:36<51:15,  9.29s/it][Succeeded / Failed / Skipped / Total] 311 / 348 / 10 / 669:  67%|██████▋   | 669/1000 [1:43:36<51:15,  9.29s/it][Succeeded / Failed / Skipped / Total] 311 / 348 / 10 / 669:  67%|██████▋   | 670/1000 [1:43:38<51:02,  9.28s/it][Succeeded / Failed / Skipped / Total] 312 / 348 / 10 / 670:  67%|██████▋   | 670/1000 [1:43:38<51:02,  9.28s/it][Succeeded / Failed / Skipped / Total] 312 / 348 / 10 / 670:  67%|██████▋   | 671/1000 [1:43:43<50:51,  9.27s/it][Succeeded / Failed / Skipped / Total] 312 / 349 / 10 / 671:  67%|██████▋   | 671/1000 [1:43:43<50:51,  9.27s/it][Succeeded / Failed / Skipped / Total] 312 / 349 / 10 / 671:  67%|██████▋   | 672/1000 [1:43:49<50:40,  9.27s/it][Succeeded / Failed / Skipped / Total] 313 / 349 / 10 / 672:  67%|██████▋   | 672/1000 [1:43:49<50:40,  9.27s/it][Succeeded / Failed / Skipped / Total] 313 / 349 / 10 / 672:  67%|██████▋   | 673/1000 [1:44:00<50:32,  9.27s/it][Succeeded / Failed / Skipped / Total] 314 / 349 / 10 / 673:  67%|██████▋   | 673/1000 [1:44:00<50:32,  9.27s/it][Succeeded / Failed / Skipped / Total] 314 / 349 / 10 / 673:  67%|██████▋   | 674/1000 [1:44:26<50:31,  9.30s/it][Succeeded / Failed / Skipped / Total] 314 / 350 / 10 / 674:  67%|██████▋   | 674/1000 [1:44:26<50:31,  9.30s/it][Succeeded / Failed / Skipped / Total] 314 / 350 / 10 / 674:  68%|██████▊   | 675/1000 [1:44:32<50:20,  9.29s/it][Succeeded / Failed / Skipped / Total] 314 / 351 / 10 / 675:  68%|██████▊   | 675/1000 [1:44:32<50:20,  9.29s/it][Succeeded / Failed / Skipped / Total] 314 / 351 / 10 / 675:  68%|██████▊   | 676/1000 [1:44:41<50:10,  9.29s/it][Succeeded / Failed / Skipped / Total] 314 / 352 / 10 / 676:  68%|██████▊   | 676/1000 [1:44:41<50:10,  9.29s/it][Succeeded / Failed / Skipped / Total] 314 / 352 / 10 / 676:  68%|██████▊   | 677/1000 [1:44:43<49:58,  9.28s/it][Succeeded / Failed / Skipped / Total] 314 / 353 / 10 / 677:  68%|██████▊   | 677/1000 [1:44:43<49:58,  9.28s/it][Succeeded / Failed / Skipped / Total] 314 / 353 / 10 / 677:  68%|██████▊   | 678/1000 [1:44:46<49:45,  9.27s/it]Sets the superclass of this class . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setSuperclass]] ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . [[superclass]] = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void [[testimony]] ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . [[eightball]] = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 669 ---------------------------------------------
Resolve all bridges . --> [[[FAILED]]]

[[[[Adv]]]]: public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 670 ---------------------------------------------
Filter constructors by visibility . --> zoë --> Socre: 1.0

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class sc , List [[constructors]] ) { CollectionUtils . filter ( [[constructors]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[constructors]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[zoë]] ( Class sc , List [[attain]] ) { CollectionUtils . filter ( [[attain]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[attain]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 671 ---------------------------------------------
Returns the cardinality of this value . --> [[[FAILED]]]

[[[[Adv]]]]: public int cardinality ( ) { int w = value ; int [[c]] = 0 ; while ( w != 0 ) { [[c]] += T [ w & 255 ] ; w >>= 8 ; } return [[c]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int cardinality ( ) { int w = value ; int [[mckenzie]] = 0 ; while ( w != 0 ) { [[mckenzie]] += T [ w & 255 ] ; w >>= 8 ; } return [[mckenzie]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 672 ---------------------------------------------
Sets the host of the request . --> Set the firecrackers to be overjoyed --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String host ) { this . [[host]] = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[overjoyed]] ( final String host ) { this . [[firecrackers]] = [[overjoyed]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[overjoyed]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 673 ---------------------------------------------
Read a string from a file . --> Read a string from a file --> Socre: 1.0

[[[[Adv]]]]: public static String readString ( final Path [[path]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[path]] , StandardCharsets . UTF_8 ) ) { StringWriter [[writer]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String readString ( final Path [[buffs]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[buffs]] , StandardCharsets . UTF_8 ) ) { StringWriter [[brain]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 674 ---------------------------------------------
Creates a CONNECT request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[connect]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest [[asiatic]] ( final String [[wallet]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[wallet]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 675 ---------------------------------------------
Sets the naming policy . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy [[namingPolicy]] ) { if ( [[namingPolicy]] == null ) [[namingPolicy]] = DefaultNamingPolicy . INSTANCE ; this . [[namingPolicy]] = [[namingPolicy]] ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[condom]] ( NamingPolicy [[nearest]] ) { if ( [[nearest]] == null ) [[nearest]] = DefaultNamingPolicy . INSTANCE ; this . [[agamemnon]] = [[nearest]] ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 676 ---------------------------------------------
Create a PUT request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[abduct]] ( final String [[outgrown]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[outgrown]] ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 677 ---------------------------------------------
Create a GET request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[cancelling]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a GET request .
[Succeeded / Failed / Skipped / Total] 314 / 354 / 10 / 678:  68%|██████▊   | 678/1000 [1:44:46<49:45,  9.27s/it][Succeeded / Failed / Skipped / Total] 314 / 354 / 10 / 678:  68%|██████▊   | 679/1000 [1:44:52<49:34,  9.27s/it][Succeeded / Failed / Skipped / Total] 314 / 355 / 10 / 679:  68%|██████▊   | 679/1000 [1:44:52<49:34,  9.27s/it][Succeeded / Failed / Skipped / Total] 314 / 355 / 10 / 679:  68%|██████▊   | 680/1000 [1:44:53<49:21,  9.25s/it][Succeeded / Failed / Skipped / Total] 314 / 356 / 10 / 680:  68%|██████▊   | 680/1000 [1:44:53<49:21,  9.25s/it][Succeeded / Failed / Skipped / Total] 314 / 356 / 10 / 680:  68%|██████▊   | 681/1000 [1:45:06<49:14,  9.26s/it][Succeeded / Failed / Skipped / Total] 315 / 356 / 10 / 681:  68%|██████▊   | 681/1000 [1:45:06<49:14,  9.26s/it][Succeeded / Failed / Skipped / Total] 315 / 356 / 10 / 681:  68%|██████▊   | 682/1000 [1:45:35<49:14,  9.29s/it][Succeeded / Failed / Skipped / Total] 316 / 356 / 10 / 682:  68%|██████▊   | 682/1000 [1:45:35<49:14,  9.29s/it][Succeeded / Failed / Skipped / Total] 316 / 356 / 10 / 682:  68%|██████▊   | 683/1000 [1:45:37<49:01,  9.28s/it][Succeeded / Failed / Skipped / Total] 316 / 357 / 10 / 683:  68%|██████▊   | 683/1000 [1:45:37<49:01,  9.28s/it][Succeeded / Failed / Skipped / Total] 316 / 357 / 10 / 683:  68%|██████▊   | 684/1000 [1:45:38<48:48,  9.27s/it][Succeeded / Failed / Skipped / Total] 317 / 357 / 10 / 684:  68%|██████▊   | 684/1000 [1:45:38<48:48,  9.27s/it][Succeeded / Failed / Skipped / Total] 317 / 357 / 10 / 684:  68%|██████▊   | 685/1000 [1:45:39<48:35,  9.25s/it][Succeeded / Failed / Skipped / Total] 317 / 358 / 10 / 685:  68%|██████▊   | 685/1000 [1:45:39<48:35,  9.25s/it][Succeeded / Failed / Skipped / Total] 317 / 358 / 10 / 685:  69%|██████▊   | 686/1000 [1:45:45<48:24,  9.25s/it][Succeeded / Failed / Skipped / Total] 317 / 359 / 10 / 686:  69%|██████▊   | 686/1000 [1:45:45<48:24,  9.25s/it][Succeeded / Failed / Skipped / Total] 317 / 359 / 10 / 686:  69%|██████▊   | 687/1000 [1:45:49<48:12,  9.24s/it][Succeeded / Failed / Skipped / Total] 318 / 359 / 10 / 687:  69%|██████▊   | 687/1000 [1:45:49<48:12,  9.24s/it][Succeeded / Failed / Skipped / Total] 318 / 359 / 10 / 687:  69%|██████▉   | 688/1000 [1:46:03<48:05,  9.25s/it][Succeeded / Failed / Skipped / Total] 319 / 359 / 10 / 688:  69%|██████▉   | 688/1000 [1:46:03<48:05,  9.25s/it][Succeeded / Failed / Skipped / Total] 319 / 359 / 10 / 688:  69%|██████▉   | 689/1000 [1:46:04<47:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 319 / 360 / 10 / 689:  69%|██████▉   | 689/1000 [1:46:04<47:52,  9.24s/it][Succeeded / Failed / Skipped / Total] 319 / 360 / 10 / 689:  69%|██████▉   | 690/1000 [1:46:39<47:55,  9.28s/it]--------------------------------------------- Result 678 ---------------------------------------------
Create a POST request with the given destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[renegotiate]] ( final String [[revved]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[revved]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 679 ---------------------------------------------
Creates a PATCH request with the given destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[feast]] ( final String [[bullshitted]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[bullshitted]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 680 ---------------------------------------------
Creates a new request with the given method and destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[create]] ( final String [[method]] , final String [[destination]] ) { return new HttpRequest ( ) . [[method]] ( [[method]] . toUpperCase ( ) ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest [[yoshihiro]] ( final String [[suburb]] , final String [[mu]] ) { return new HttpRequest ( ) . [[suburb]] ( [[suburb]] . toUpperCase ( ) ) . set ( [[mu]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 681 ---------------------------------------------
Sets the path for the request . --> Methode d ajout d obtenir québécis --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[path]] ( String path ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[québécois]] ( String path ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 682 ---------------------------------------------
Add a query map to the request . --> Equilibrium d ajout des equilibriums --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[entry]] : queryMap . entrySet ( ) ) { [[query]] . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest [[equilibrium]] ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[résumé]] : queryMap . entrySet ( ) ) { [[equilibrium]] . add ( [[résumé]] . getKey ( ) , [[résumé]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 683 ---------------------------------------------
Creates a TRACE request with the given destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[blackmailer]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 684 ---------------------------------------------
Sets the query string . --> Retreat les fiancés --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String queryString , final boolean decode ) { this . [[query]] = HttpUtil . parseQuery ( [[queryString]] , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[retreat]] ( final String queryString , final boolean decode ) { this . [[fiancés]] = HttpUtil . parseQuery ( [[retreat]] , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 685 ---------------------------------------------
Create a HEAD request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[cookies]] ( final String [[excluding]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[excluding]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 686 ---------------------------------------------
Create an OPTIONS request with the given destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[negate]] ( final String [[topi]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[topi]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 687 ---------------------------------------------
Returns a buffer that can be used to write data to the client . --> If delusion is true then delusion is false then delusion is true --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer buffer ( final boolean [[fullRequest]] ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer buffer ( final boolean [[delusion]] ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 688 ---------------------------------------------
Send the request and receive the response . --> Send and receive a verdugo response --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[verdugo]] > [[verdugo]] sendAndReceive ( final Function < HttpResponse , [[verdugo]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 689 ---------------------------------------------
Returns the query string . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[streptomycin]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 690 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 319 / 361 / 10 / 690:  69%|██████▉   | 690/1000 [1:46:39<47:55,  9.28s/it][Succeeded / Failed / Skipped / Total] 319 / 361 / 10 / 690:  69%|██████▉   | 691/1000 [1:47:02<47:51,  9.29s/it][Succeeded / Failed / Skipped / Total] 319 / 362 / 10 / 691:  69%|██████▉   | 691/1000 [1:47:02<47:51,  9.29s/it][Succeeded / Failed / Skipped / Total] 319 / 362 / 10 / 691:  69%|██████▉   | 692/1000 [1:47:24<47:48,  9.31s/it][Succeeded / Failed / Skipped / Total] 319 / 363 / 10 / 692:  69%|██████▉   | 692/1000 [1:47:24<47:48,  9.31s/it][Succeeded / Failed / Skipped / Total] 319 / 363 / 10 / 692:  69%|██████▉   | 693/1000 [1:47:26<47:35,  9.30s/it][Succeeded / Failed / Skipped / Total] 319 / 364 / 10 / 693:  69%|██████▉   | 693/1000 [1:47:26<47:35,  9.30s/it][Succeeded / Failed / Skipped / Total] 319 / 364 / 10 / 693:  69%|██████▉   | 694/1000 [1:47:28<47:23,  9.29s/it][Succeeded / Failed / Skipped / Total] 320 / 364 / 10 / 694:  69%|██████▉   | 694/1000 [1:47:28<47:23,  9.29s/it][Succeeded / Failed / Skipped / Total] 320 / 364 / 10 / 694:  70%|██████▉   | 695/1000 [1:47:31<47:11,  9.28s/it][Succeeded / Failed / Skipped / Total] 320 / 365 / 10 / 695:  70%|██████▉   | 695/1000 [1:47:31<47:11,  9.28s/it][Succeeded / Failed / Skipped / Total] 320 / 365 / 10 / 695:  70%|██████▉   | 696/1000 [1:47:38<47:00,  9.28s/it][Succeeded / Failed / Skipped / Total] 321 / 365 / 10 / 696:  70%|██████▉   | 696/1000 [1:47:38<47:00,  9.28s/it][Succeeded / Failed / Skipped / Total] 321 / 365 / 10 / 696:  70%|██████▉   | 697/1000 [1:47:46<46:51,  9.28s/it][Succeeded / Failed / Skipped / Total] 321 / 366 / 10 / 697:  70%|██████▉   | 697/1000 [1:47:46<46:51,  9.28s/it][Succeeded / Failed / Skipped / Total] 321 / 366 / 10 / 697:  70%|██████▉   | 698/1000 [1:47:57<46:42,  9.28s/it]Returns the URL of the host . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[carlisle]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 691 ---------------------------------------------
Adds a set of cookies to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder [[cookieString]] = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[cookieString]] . append ( "; " ) ; } first = "[[False]]" != "[[False]]" ; [[cookieString]] . append ( cookie . getName ( ) ) ; [[cookieString]] . append ( ' ' ) ; [[cookieString]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[cookieString]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder [[chemically]] = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[chemically]] . append ( "; " ) ; } first = "[[Deutschmark]]" != "[[Deutschmark]]" ; [[chemically]] . append ( cookie . getName ( ) ) ; [[chemically]] . append ( ' ' ) ; [[chemically]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[chemically]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 692 ---------------------------------------------
Sets the host header . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[khadija]] ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 693 ---------------------------------------------
Add a query parameter to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest query ( final String [[name1]] , final Object [[value1]] , final Object ... parameters ) { query ( [[name1]] , [[value1]] == null ? null : [[value1]] . toString ( ) ) ; for ( int [[i]] = 0 ; [[i]] < parameters . length ; [[i]] += 2 ) { String name = parameters [ [[i]] ] . toString ( ) ; String value = parameters [ [[i]] + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest query ( final String [[face]] , final Object [[gert]] , final Object ... parameters ) { query ( [[face]] , [[gert]] == null ? null : [[gert]] . toString ( ) ) ; for ( int [[groovy]] = 0 ; [[groovy]] < parameters . length ; [[groovy]] += 2 ) { String name = parameters [ [[groovy]] ] . toString ( ) ; String value = parameters [ [[groovy]] + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 694 ---------------------------------------------
Collect all action filters . --> chihuahuas --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > [[filterValues]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[filterValues]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[chihuahuas]] ( ) { final Collection < ? extends ActionFilter > [[archetypes]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[archetypes]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 695 ---------------------------------------------
Create a DELETE request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[overview]] ( final String [[ethically]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[ethically]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 696 ---------------------------------------------
Collect all action runtimes . --> Hacky hacky hacky hacky --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[hacky]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 697 ---------------------------------------------
Collect all action interceptors . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > [[interceptorValues]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[interceptorValues]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[rises]] ( ) { final Collection < ? extends ActionInterceptor > [[receipt]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[receipt]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 698 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 321 / 367 / 10 / 698:  70%|██████▉   | 698/1000 [1:47:57<46:42,  9.28s/it][Succeeded / Failed / Skipped / Total] 321 / 367 / 10 / 698:  70%|██████▉   | 699/1000 [1:47:59<46:30,  9.27s/it][Succeeded / Failed / Skipped / Total] 322 / 367 / 10 / 699:  70%|██████▉   | 699/1000 [1:47:59<46:30,  9.27s/it][Succeeded / Failed / Skipped / Total] 322 / 367 / 10 / 699:  70%|███████   | 700/1000 [1:48:00<46:17,  9.26s/it][Succeeded / Failed / Skipped / Total] 322 / 368 / 10 / 700:  70%|███████   | 700/1000 [1:48:00<46:17,  9.26s/it][Succeeded / Failed / Skipped / Total] 322 / 368 / 10 / 700:  70%|███████   | 701/1000 [1:48:15<46:10,  9.27s/it][Succeeded / Failed / Skipped / Total] 322 / 369 / 10 / 701:  70%|███████   | 701/1000 [1:48:15<46:10,  9.27s/it][Succeeded / Failed / Skipped / Total] 322 / 369 / 10 / 701:  70%|███████   | 702/1000 [1:48:22<46:00,  9.26s/it][Succeeded / Failed / Skipped / Total] 322 / 370 / 10 / 702:  70%|███████   | 702/1000 [1:48:22<46:00,  9.26s/it][Succeeded / Failed / Skipped / Total] 322 / 370 / 10 / 702:  70%|███████   | 703/1000 [1:48:24<45:48,  9.25s/it][Succeeded / Failed / Skipped / Total] 323 / 370 / 10 / 703:  70%|███████   | 703/1000 [1:48:24<45:48,  9.25s/it][Succeeded / Failed / Skipped / Total] 323 / 370 / 10 / 703:  70%|███████   | 704/1000 [1:48:27<45:36,  9.24s/it][Succeeded / Failed / Skipped / Total] 324 / 370 / 10 / 704:  70%|███████   | 704/1000 [1:48:27<45:36,  9.24s/it][Succeeded / Failed / Skipped / Total] 324 / 370 / 10 / 704:  70%|███████   | 705/1000 [1:48:29<45:23,  9.23s/it][Succeeded / Failed / Skipped / Total] 325 / 370 / 10 / 705:  70%|███████   | 705/1000 [1:48:29<45:23,  9.23s/it][Succeeded / Failed / Skipped / Total] 325 / 370 / 10 / 705:  71%|███████   | 706/1000 [1:48:48<45:18,  9.25s/it]Sets the basic authentication header . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[panels]] ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 699 ---------------------------------------------
Sets a simple property . --> Liefert die Maréchal --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty [[bp]] , final Object value ) { Setter setter = [[bp]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[nettie]] ( final BeanProperty [[maréchal]] , final Object value ) { Setter setter = [[maréchal]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 700 ---------------------------------------------
Remove a range from a handler . --> [[[FAILED]]]

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 701 ---------------------------------------------
Returns the length of the exception table . --> [[[FAILED]]]

[[[[Adv]]]]: static int [[getExceptionTableLength]] ( final Handler [[firstHandler]] ) { int [[length]] = 0 ; Handler handler = [[firstHandler]] ; while ( handler != null ) { [[length]] ++ ; handler = handler . nextHandler ; } return [[length]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int [[cappella]] ( final Handler [[principalities]] ) { int [[apparatus]] = 0 ; Handler handler = [[principalities]] ; while ( handler != null ) { [[apparatus]] ++ ; handler = handler . nextHandler ; } return [[apparatus]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 702 ---------------------------------------------
Collect all action results . --> [[[FAILED]]]

[[[[Adv]]]]: protected void collectActionResults ( ) { final Collection < ActionResult > [[resultsValues]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[resultsValues]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void collectActionResults ( ) { final Collection < ActionResult > [[clichéd]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[clichéd]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 703 ---------------------------------------------
extract this reference from a property name --> Liefert die birmingham --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int ndx = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( ndx == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[calibration]] ( final String [[birmingham]] ) { int ndx = StringUtil . indexOfChars ( [[birmingham]] , INDEX_CHARS ) ; if ( ndx == - 1 ) { return [[birmingham]] ; } return [[birmingham]] . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 704 ---------------------------------------------
Gets the writer . --> zoology creates a FastCharArrayWriter --> Socre: 1.0

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[zoology]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 705 ---------------------------------------------
Find table descriptor by column ref . --> Methode d ajout une général --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[général]] ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 706 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 325 / 371 / 10 / 706:  71%|███████   | 706/1000 [1:48:48<45:18,  9.25s/it][Succeeded / Failed / Skipped / Total] 325 / 371 / 10 / 706:  71%|███████   | 707/1000 [1:48:53<45:07,  9.24s/it][Succeeded / Failed / Skipped / Total] 326 / 371 / 10 / 707:  71%|███████   | 707/1000 [1:48:53<45:07,  9.24s/it][Succeeded / Failed / Skipped / Total] 326 / 371 / 10 / 707:  71%|███████   | 708/1000 [1:49:14<45:03,  9.26s/it][Succeeded / Failed / Skipped / Total] 327 / 371 / 10 / 708:  71%|███████   | 708/1000 [1:49:14<45:03,  9.26s/it][Succeeded / Failed / Skipped / Total] 327 / 371 / 10 / 708:  71%|███████   | 709/1000 [1:49:37<44:59,  9.28s/it][Succeeded / Failed / Skipped / Total] 328 / 371 / 10 / 709:  71%|███████   | 709/1000 [1:49:37<44:59,  9.28s/it][Succeeded / Failed / Skipped / Total] 328 / 371 / 10 / 709:  71%|███████   | 710/1000 [1:49:43<44:49,  9.27s/it][Succeeded / Failed / Skipped / Total] 329 / 371 / 10 / 710:  71%|███████   | 710/1000 [1:49:43<44:49,  9.27s/it][Succeeded / Failed / Skipped / Total] 329 / 371 / 10 / 710:  71%|███████   | 711/1000 [1:49:49<44:38,  9.27s/it][Succeeded / Failed / Skipped / Total] 329 / 372 / 10 / 711:  71%|███████   | 711/1000 [1:49:49<44:38,  9.27s/it][Succeeded / Failed / Skipped / Total] 329 / 372 / 10 / 711:  71%|███████   | 712/1000 [1:50:02<44:30,  9.27s/it][Succeeded / Failed / Skipped / Total] 329 / 373 / 10 / 712:  71%|███████   | 712/1000 [1:50:02<44:30,  9.27s/it][Succeeded / Failed / Skipped / Total] 329 / 373 / 10 / 712:  71%|███████▏  | 713/1000 [1:50:04<44:18,  9.26s/it][Succeeded / Failed / Skipped / Total] 329 / 374 / 10 / 713:  71%|███████▏  | 713/1000 [1:50:04<44:18,  9.26s/it][Succeeded / Failed / Skipped / Total] 329 / 374 / 10 / 713:  71%|███████▏  | 714/1000 [1:50:10<44:07,  9.26s/it][Succeeded / Failed / Skipped / Total] 329 / 375 / 10 / 714:  71%|███████▏  | 714/1000 [1:50:10<44:07,  9.26s/it][Succeeded / Failed / Skipped / Total] 329 / 375 / 10 / 714:  72%|███████▏  | 715/1000 [1:50:22<43:59,  9.26s/it][Succeeded / Failed / Skipped / Total] 329 / 376 / 10 / 715:  72%|███████▏  | 715/1000 [1:50:22<43:59,  9.26s/it][Succeeded / Failed / Skipped / Total] 329 / 376 / 10 / 715:  72%|███████▏  | 716/1000 [1:50:51<43:58,  9.29s/it]Returns the value of the named property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < [[T]] > [[T]] getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( [[T]] ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( [[T]] ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < [[mark]] > [[mark]] getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( [[mark]] ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( [[mark]] ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 707 ---------------------------------------------
Get a reference to an object . --> Get the bandwidth for a given affectionate --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String [[name]] ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( [[name]] ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[bandwidth]] ( final String [[affectionate]] ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( [[affectionate]] ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 708 ---------------------------------------------
Set a reference to an object . --> Add a nonessential to the list of francis --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String [[name]] , final Object [[object]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , [[object]] ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[francis]] ( final String [[nonessential]] , final Object [[brokers]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[nonessential]] , [[brokers]] ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 709 ---------------------------------------------
Get the entity descriptor for a table . --> Methode d ajout d une divorcée --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[divorcée]] ( final String [[michele]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[snouts]] = tableRefs . get ( [[michele]] ) ; return [[snouts]] == null ? null : [[snouts]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 710 ---------------------------------------------
Writes the given value to the given JSON context . --> Methode von nebuchadnezzar --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[jsonContext]] , final T [[value]] ) { if ( [[jsonContext]] . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[nebuchadnezzar]] , final T [[nisam]] ) { if ( [[nebuchadnezzar]] . pushValue ( [[nisam]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 711 ---------------------------------------------
Lookup an object reference . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[lookupObject]] ( final String [[ref]] ) { Object value = getObjectReference ( [[ref]] ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[ref]] ) ; } return value ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[shankara]] ( final String [[eisenstein]] ) { Object value = getObjectReference ( [[eisenstein]] ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[eisenstein]] ) ; } return value ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 712 ---------------------------------------------
Registers a hint . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerHint]] ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[succeeded]] ( final String [[tornado]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[tornado]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 713 ---------------------------------------------
Returns the entity descriptor for the given table reference . --> [[[FAILED]]]

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String [[tableRef]] ) { DbEntityDescriptor [[ded]] = getTableDescriptor ( [[tableRef]] ) ; if ( [[ded]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[tableRef]] ) ; } return [[ded]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[tempe]] ( final String [[trolleys]] ) { DbEntityDescriptor [[choices]] = getTableDescriptor ( [[trolleys]] ) ; if ( [[choices]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[trolleys]] ) ; } return [[choices]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 714 ---------------------------------------------
Get the alias for a table . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getTableAlias]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[innumerable]] ( final String [[both]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[lawsuits]] = tableRefs . get ( [[both]] ) ; return [[lawsuits]] == null ? null : [[lawsuits]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 715 ---------------------------------------------
Register a table reference . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 716 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 329 / 377 / 10 / 716:  72%|███████▏  | 716/1000 [1:50:51<43:58,  9.29s/it][Succeeded / Failed / Skipped / Total] 329 / 377 / 10 / 716:  72%|███████▏  | 717/1000 [1:51:04<43:50,  9.29s/it][Succeeded / Failed / Skipped / Total] 330 / 377 / 10 / 717:  72%|███████▏  | 717/1000 [1:51:04<43:50,  9.29s/it][Succeeded / Failed / Skipped / Total] 330 / 377 / 10 / 717:  72%|███████▏  | 718/1000 [1:51:29<43:47,  9.32s/it][Succeeded / Failed / Skipped / Total] 330 / 378 / 10 / 718:  72%|███████▏  | 718/1000 [1:51:29<43:47,  9.32s/it][Succeeded / Failed / Skipped / Total] 330 / 378 / 10 / 718:  72%|███████▏  | 719/1000 [1:51:44<43:40,  9.32s/it][Succeeded / Failed / Skipped / Total] 330 / 379 / 10 / 719:  72%|███████▏  | 719/1000 [1:51:44<43:40,  9.32s/it][Succeeded / Failed / Skipped / Total] 330 / 379 / 10 / 719:  72%|███████▏  | 720/1000 [1:51:46<43:28,  9.31s/it]Prepare get value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[E]] > [[E]] prepareGetValue ( final T t , final Class < [[E]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[E]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[yung]] > [[yung]] prepareGetValue ( final T t , final Class < [[yung]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[yung]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 717 ---------------------------------------------
Convert column name to property name . --> Tuskekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekeke --> Socre: 1.0

[[[[Adv]]]]: public String [[convertColumnNameToPropertyName]] ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "[[True]]" == "[[True]]" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String [[tuskegee]] ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "[[Concertos]]" == "[[Concertos]]" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 718 ---------------------------------------------
Inject the attributes from the servlet request . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 719 ---------------------------------------------
Injects the parameters from the servlet request . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[injectParameters]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] [[paramValues]] = servletRequest . getParameterValues ( paramName ) ; [[paramValues]] = ServletUtil . prepareParameters ( [[paramValues]] , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( [[paramValues]] != null ) { if ( encode ) { for ( int j = 0 ; j < [[paramValues]] . length ; j ++ ) { final String p = [[paramValues]] [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; [[paramValues]] [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( [[paramValues]] . length != 1 ? [[paramValues]] : [[paramValues]] [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void [[natal]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] [[worldview]] = servletRequest . getParameterValues ( paramName ) ; [[worldview]] = ServletUtil . prepareParameters ( [[worldview]] , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( [[worldview]] != null ) { if ( encode ) { for ( int j = 0 ; j < [[worldview]] . length ; j ++ ) { final String p = [[worldview]] [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; [[worldview]] [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( [[worldview]] . length != 1 ? [[worldview]] : [[worldview]] [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 720 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 330 / 380 / 10 / 720:  72%|███████▏  | 720/1000 [1:51:46<43:28,  9.31s/it][Succeeded / Failed / Skipped / Total] 330 / 380 / 10 / 720:  72%|███████▏  | 721/1000 [1:51:50<43:16,  9.31s/it][Succeeded / Failed / Skipped / Total] 330 / 381 / 10 / 721:  72%|███████▏  | 721/1000 [1:51:50<43:16,  9.31s/it][Succeeded / Failed / Skipped / Total] 330 / 381 / 10 / 721:  72%|███████▏  | 722/1000 [1:51:52<43:04,  9.30s/it][Succeeded / Failed / Skipped / Total] 330 / 382 / 10 / 722:  72%|███████▏  | 722/1000 [1:51:52<43:04,  9.30s/it][Succeeded / Failed / Skipped / Total] 330 / 382 / 10 / 722:  72%|███████▏  | 723/1000 [1:51:56<42:53,  9.29s/it][Succeeded / Failed / Skipped / Total] 330 / 383 / 10 / 723:  72%|███████▏  | 723/1000 [1:51:56<42:53,  9.29s/it][Succeeded / Failed / Skipped / Total] 330 / 383 / 10 / 723:  72%|███████▏  | 724/1000 [1:51:58<42:41,  9.28s/it][Succeeded / Failed / Skipped / Total] 330 / 384 / 10 / 724:  72%|███████▏  | 724/1000 [1:51:58<42:41,  9.28s/it][Succeeded / Failed / Skipped / Total] 330 / 384 / 10 / 724:  72%|███████▎  | 725/1000 [1:52:11<42:33,  9.29s/it][Succeeded / Failed / Skipped / Total] 330 / 385 / 10 / 725:  72%|███████▎  | 725/1000 [1:52:11<42:33,  9.29s/it][Succeeded / Failed / Skipped / Total] 330 / 385 / 10 / 725:  73%|███████▎  | 726/1000 [1:52:14<42:21,  9.28s/it][Succeeded / Failed / Skipped / Total] 331 / 385 / 10 / 726:  73%|███████▎  | 726/1000 [1:52:14<42:21,  9.28s/it][Succeeded / Failed / Skipped / Total] 331 / 385 / 10 / 726:  73%|███████▎  | 727/1000 [1:52:27<42:13,  9.28s/it]Inject uploaded files . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[injectUploadedFiles]] ( final HttpServletRequest [[servletRequest]] , final Targets targets ) { if ( ! ( [[servletRequest]] instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) [[servletRequest]] ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void [[aubergine]] ( final HttpServletRequest [[backstretch]] , final Targets targets ) { if ( ! ( [[backstretch]] instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) [[backstretch]] ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( [[backstretch]] . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 721 ---------------------------------------------
Convert column name to column name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String columnName ) { String [[propertyName]] = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( [[propertyName]] ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[maréchal]] ( final String columnName ) { String [[confidentiality]] = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( [[confidentiality]] ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 722 ---------------------------------------------
Converts a property name to a column name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder [[tableName]] = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; [[tableName]] . append ( convertedTableName ) ; } else { [[tableName]] . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return [[tableName]] . toString ( ) ; } return uppercase ? toUppercase ( [[tableName]] ) . toString ( ) : toLowercase ( [[tableName]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[refunded]] ( final String [[friends]] ) { StringBuilder [[accession]] = new StringBuilder ( [[friends]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( [[friends]] , separatorChar ) ; [[accession]] . append ( convertedTableName ) ; } else { [[accession]] . append ( [[friends]] ) ; } if ( ! changeCase ) { return [[accession]] . toString ( ) ; } return uppercase ? toUppercase ( [[accession]] ) . toString ( ) : toLowercase ( [[accession]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 723 ---------------------------------------------
Creates an instance of the given wrapper class . --> [[[FAILED]]]

[[[[Adv]]]]: protected < R [[extends]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R [[bellow]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 724 ---------------------------------------------
Returns a set of all wrappers . --> [[[FAILED]]]

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > [[set]] = new HashSet <> ( wrappers . size ( ) ) ; [[set]] . addAll ( wrappers . values ( ) ) ; return [[set]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[makuta]] ( ) { final Set < T > [[antipsychotics]] = new HashSet <> ( wrappers . size ( ) ) ; [[antipsychotics]] . addAll ( wrappers . values ( ) ) ; return [[antipsychotics]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 725 ---------------------------------------------
Store a value to a PreparedStatement . --> [[[FAILED]]]

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 726 ---------------------------------------------
Start the Madvoc server . --> Initialize Madvoc WebApp --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[elk]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 727 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 331 / 386 / 10 / 727:  73%|███████▎  | 727/1000 [1:52:27<42:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 331 / 386 / 10 / 727:  73%|███████▎  | 728/1000 [1:52:31<42:02,  9.27s/it][Succeeded / Failed / Skipped / Total] 332 / 386 / 10 / 728:  73%|███████▎  | 728/1000 [1:52:31<42:02,  9.27s/it][Succeeded / Failed / Skipped / Total] 332 / 386 / 10 / 728:  73%|███████▎  | 729/1000 [1:52:53<41:58,  9.29s/it][Succeeded / Failed / Skipped / Total] 332 / 387 / 10 / 729:  73%|███████▎  | 729/1000 [1:52:53<41:58,  9.29s/it][Succeeded / Failed / Skipped / Total] 332 / 387 / 10 / 729:  73%|███████▎  | 730/1000 [1:52:57<41:46,  9.28s/it][Succeeded / Failed / Skipped / Total] 332 / 388 / 10 / 730:  73%|███████▎  | 730/1000 [1:52:57<41:46,  9.28s/it][Succeeded / Failed / Skipped / Total] 332 / 388 / 10 / 730:  73%|███████▎  | 731/1000 [1:53:01<41:35,  9.28s/it]Adds an action config to the web application . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[bottled]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 728 ---------------------------------------------
Split a filename into its components . --> Split the given HOPKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOK --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] split ( final String [[filename]] ) { String prefix = getPrefix ( [[filename]] ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( [[filename]] ) ; int lastExtensionIndex = indexOfExtension ( [[filename]] ) ; String [[path]] ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { [[path]] = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = [[filename]] . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = [[filename]] . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = [[filename]] . substring ( lastExtensionIndex + 1 ) ; } } else { [[path]] = [[filename]] . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = [[filename]] . substring ( prefix . length ( ) + [[path]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = [[filename]] . substring ( prefix . length ( ) + [[path]] . length ( ) , lastExtensionIndex ) ; extension = [[filename]] . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , [[path]] , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] split ( final String [[hoke]] ) { String prefix = getPrefix ( [[hoke]] ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( [[hoke]] ) ; int lastExtensionIndex = indexOfExtension ( [[hoke]] ) ; String [[knockwurst]] ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { [[knockwurst]] = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = [[hoke]] . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = [[hoke]] . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = [[hoke]] . substring ( lastExtensionIndex + 1 ) ; } } else { [[knockwurst]] = [[hoke]] . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = [[hoke]] . substring ( prefix . length ( ) + [[knockwurst]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = [[hoke]] . substring ( prefix . length ( ) + [[knockwurst]] . length ( ) , lastExtensionIndex ) ; extension = [[hoke]] . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , [[knockwurst]] , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 729 ---------------------------------------------
Converts a path to a system path . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String [[path]] ) { if ( [[path]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[path]] ) ; } else { return separatorsToUnix ( [[path]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[bronchitis]] ( final String [[apu]] ) { if ( [[apu]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[apu]] ) ; } else { return separatorsToUnix ( [[apu]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 730 ---------------------------------------------
Register Madvoc components . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[analyze]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 731 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 332 / 389 / 10 / 731:  73%|███████▎  | 731/1000 [1:53:01<41:35,  9.28s/it][Succeeded / Failed / Skipped / Total] 332 / 389 / 10 / 731:  73%|███████▎  | 732/1000 [1:53:01<41:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 333 / 389 / 10 / 732:  73%|███████▎  | 732/1000 [1:53:01<41:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 333 / 389 / 10 / 732:  73%|███████▎  | 733/1000 [1:53:15<41:15,  9.27s/it][Succeeded / Failed / Skipped / Total] 333 / 390 / 10 / 733:  73%|███████▎  | 733/1000 [1:53:15<41:15,  9.27s/it][Succeeded / Failed / Skipped / Total] 333 / 390 / 10 / 733:  73%|███████▎  | 734/1000 [1:53:25<41:06,  9.27s/it][Succeeded / Failed / Skipped / Total] 334 / 390 / 10 / 734:  73%|███████▎  | 734/1000 [1:53:25<41:06,  9.27s/it][Succeeded / Failed / Skipped / Total] 334 / 390 / 10 / 734:  74%|███████▎  | 735/1000 [1:53:32<40:56,  9.27s/it][Succeeded / Failed / Skipped / Total] 334 / 391 / 10 / 735:  74%|███████▎  | 735/1000 [1:53:32<40:56,  9.27s/it][Succeeded / Failed / Skipped / Total] 334 / 391 / 10 / 735:  74%|███████▎  | 736/1000 [1:53:41<40:46,  9.27s/it][Succeeded / Failed / Skipped / Total] 335 / 391 / 10 / 736:  74%|███████▎  | 736/1000 [1:53:41<40:46,  9.27s/it][Succeeded / Failed / Skipped / Total] 335 / 391 / 10 / 736:  74%|███████▎  | 737/1000 [1:53:42<40:34,  9.26s/it][Succeeded / Failed / Skipped / Total] 335 / 392 / 10 / 737:  74%|███████▎  | 737/1000 [1:53:42<40:34,  9.26s/it][Succeeded / Failed / Skipped / Total] 335 / 392 / 10 / 737:  74%|███████▍  | 738/1000 [1:53:55<40:26,  9.26s/it][Succeeded / Failed / Skipped / Total] 336 / 392 / 10 / 738:  74%|███████▍  | 738/1000 [1:53:55<40:26,  9.26s/it][Succeeded / Failed / Skipped / Total] 336 / 392 / 10 / 738:  74%|███████▍  | 739/1000 [1:54:02<40:16,  9.26s/it][Succeeded / Failed / Skipped / Total] 336 / 393 / 10 / 739:  74%|███████▍  | 739/1000 [1:54:02<40:16,  9.26s/it][Succeeded / Failed / Skipped / Total] 336 / 393 / 10 / 739:  74%|███████▍  | 740/1000 [1:54:09<40:06,  9.26s/it]Register a madvoc component . --> [[[FAILED]]]

[[[[Adv]]]]: public WebApp [[registerComponent]] ( final Class < ? > [[madvocComponent]] ) { Objects . requireNonNull ( [[madvocComponent]] ) ; madvocComponents . add ( ClassConsumer . of ( [[madvocComponent]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp [[poulsen]] ( final Class < ? > [[accuses]] ) { Objects . requireNonNull ( [[accuses]] ) ; madvocComponents . add ( ClassConsumer . of ( [[accuses]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 732 ---------------------------------------------
Resolves the given wrapper class . --> Plebiscite anathema --> Socre: 1.0

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > [[wrapperClass]] ) { String wrapperClassName = [[wrapperClass]] . getName ( ) ; T [[wrapper]] = lookup ( wrapperClassName ) ; if ( [[wrapper]] == null ) { [[wrapper]] = createWrapper ( [[wrapperClass]] ) ; initializeWrapper ( [[wrapper]] ) ; wrappers . put ( wrapperClassName , [[wrapper]] ) ; } return [[wrapper]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[plebiscite]] ( final Class < ? extends T > [[anathema]] ) { String wrapperClassName = [[anathema]] . getName ( ) ; T [[devilish]] = lookup ( wrapperClassName ) ; if ( [[devilish]] == null ) { [[devilish]] = createWrapper ( [[anathema]] ) ; initializeWrapper ( [[devilish]] ) ; wrappers . put ( wrapperClassName , [[devilish]] ) ; } return [[devilish]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 733 ---------------------------------------------
Configure defaults . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager [[actionConfigManager]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[actionConfigManager]] . registerAnnotation ( Action . class ) ; [[actionConfigManager]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[dissuaded]] ( ) { final ActionConfigManager [[castro]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[castro]] . registerAnnotation ( Action . class ) ; [[castro]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 734 ---------------------------------------------
Include all of the specified jars . --> Adds a list of files to be scanned by maximiliano --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String includedJar : [[includedJars]] ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[maximiliano]] ( final String ... [[fabricated]] ) { for ( final String includedJar : [[fabricated]] ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 735 ---------------------------------------------
Returns the relative path of targetPath relative to basePath . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[relativePath]] ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[aleykum]] ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 736 ---------------------------------------------
Scan a list of files . --> Scan a list of scribbles --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner scan ( final String ... paths ) { for ( final String [[path]] : paths ) { filesToScan . add ( new File ( [[path]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner scan ( final String ... paths ) { for ( final String [[scribbles]] : paths ) { filesToScan . add ( new File ( [[scribbles]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 737 ---------------------------------------------
Get the path of a file . --> [[[FAILED]]]

[[[[Adv]]]]: private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 738 ---------------------------------------------
Exclude the given entries from the scan . --> Chihuahuas chihuahuas --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeEntries]] ( final String ... [[excludedEntries]] ) { for ( final String excludedEntry : [[excludedEntries]] ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner [[chihuahuas]] ( final String ... [[toyama]] ) { for ( final String excludedEntry : [[toyama]] ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 739 ---------------------------------------------
Exclude the given jars from scanning . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... excludedJars ) { for ( final String [[excludedJar]] : excludedJars ) { rulesJars . exclude ( [[excludedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[assembles]] ( final String ... excludedJars ) { for ( final String [[buttery]] : excludedJars ) { rulesJars . exclude ( [[buttery]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 740 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 337 / 393 / 10 / 740:  74%|███████▍  | 740/1000 [1:54:09<40:06,  9.26s/it][Succeeded / Failed / Skipped / Total] 337 / 393 / 10 / 740:  74%|███████▍  | 741/1000 [1:54:18<39:57,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 393 / 10 / 741:  74%|███████▍  | 741/1000 [1:54:18<39:57,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 393 / 10 / 741:  74%|███████▍  | 742/1000 [1:54:29<39:48,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 394 / 10 / 742:  74%|███████▍  | 742/1000 [1:54:29<39:48,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 394 / 10 / 742:  74%|███████▍  | 743/1000 [1:54:30<39:36,  9.25s/it][Succeeded / Failed / Skipped / Total] 338 / 395 / 10 / 743:  74%|███████▍  | 743/1000 [1:54:30<39:36,  9.25s/it][Succeeded / Failed / Skipped / Total] 338 / 395 / 10 / 743:  74%|███████▍  | 744/1000 [1:54:49<39:30,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 396 / 10 / 744:  74%|███████▍  | 744/1000 [1:54:49<39:30,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 396 / 10 / 744:  74%|███████▍  | 745/1000 [1:55:01<39:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 397 / 10 / 745:  74%|███████▍  | 745/1000 [1:55:01<39:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 397 / 10 / 745:  75%|███████▍  | 746/1000 [1:55:04<39:10,  9.26s/it]start scanning the files to scan . --> bade all files to scan --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[path]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[path]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[bade]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[polyjuice]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[polyjuice]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 741 ---------------------------------------------
Create a new JtxTransaction . --> Method to create a JtxTransaction --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction [[createNewTransaction]] ( final JtxTransactionMode tm , final Object [[scope]] , final boolean active ) { return new DbJtxTransaction ( this , tm , [[scope]] , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction [[summing]] ( final JtxTransactionMode tm , final Object [[inuit]] , final boolean active ) { return new DbJtxTransaction ( this , tm , [[inuit]] , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 742 ---------------------------------------------
Default or scope type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[burdette]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 743 ---------------------------------------------
Adds a list of entries to be scanned . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... [[includedEntries]] ) { for ( final String includedEntry : [[includedEntries]] ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[shivani]] ( final String ... [[americans]] ) { for ( final String includedEntry : [[americans]] ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 744 ---------------------------------------------
Scan the classpath . --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 745 ---------------------------------------------
Scan a jar file . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[scanJarFile]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void [[marihuana]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 746 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 338 / 398 / 10 / 746:  75%|███████▍  | 746/1000 [1:55:04<39:10,  9.26s/it][Succeeded / Failed / Skipped / Total] 338 / 398 / 10 / 746:  75%|███████▍  | 747/1000 [1:55:45<39:12,  9.30s/it][Succeeded / Failed / Skipped / Total] 338 / 399 / 10 / 747:  75%|███████▍  | 747/1000 [1:55:45<39:12,  9.30s/it][Succeeded / Failed / Skipped / Total] 338 / 399 / 10 / 747:  75%|███████▍  | 748/1000 [1:56:14<39:09,  9.32s/it][Succeeded / Failed / Skipped / Total] 338 / 400 / 10 / 748:  75%|███████▍  | 748/1000 [1:56:14<39:09,  9.32s/it][Succeeded / Failed / Skipped / Total] 338 / 400 / 10 / 748:  75%|███████▍  | 749/1000 [1:56:17<38:58,  9.32s/it][Succeeded / Failed / Skipped / Total] 338 / 401 / 10 / 749:  75%|███████▍  | 749/1000 [1:56:17<38:58,  9.32s/it][Succeeded / Failed / Skipped / Total] 338 / 401 / 10 / 749:  75%|███████▌  | 750/1000 [1:56:18<38:46,  9.30s/it][Succeeded / Failed / Skipped / Total] 338 / 402 / 10 / 750:  75%|███████▌  | 750/1000 [1:56:18<38:46,  9.30s/it][Succeeded / Failed / Skipped / Total] 338 / 402 / 10 / 750:  75%|███████▌  | 751/1000 [1:56:35<38:39,  9.31s/it][Succeeded / Failed / Skipped / Total] 338 / 403 / 10 / 751:  75%|███████▌  | 751/1000 [1:56:35<38:39,  9.31s/it][Succeeded / Failed / Skipped / Total] 338 / 403 / 10 / 751:  75%|███████▌  | 752/1000 [1:56:58<38:34,  9.33s/it][Succeeded / Failed / Skipped / Total] 338 / 404 / 10 / 752:  75%|███████▌  | 752/1000 [1:56:58<38:34,  9.33s/it][Succeeded / Failed / Skipped / Total] 338 / 404 / 10 / 752:  75%|███████▌  | 753/1000 [1:57:03<38:23,  9.33s/it]Returns the bytecode signature of a class . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class [[type]] ) { final String name = ' ' + [[type]] . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[somerville]] ( final Class [[anatomically]] ) { final String name = ' ' + [[anatomically]] . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 747 ---------------------------------------------
Get or initialize scope . --> [[[FAILED]]]

[[[[Adv]]]]: protected MadvocScope [[getOrInitScope]] ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope [[cabrón]] ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 748 ---------------------------------------------
Decodes a string into a byte array . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 749 ---------------------------------------------
Creates a copy of this bean . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[copy]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[True]]" == "[[True]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void [[prem]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[Bondo]]" == "[[Bondo]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 750 ---------------------------------------------
For the given scope type invoke the given consumer for the scope . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[forScope]] ( final Class < ? extends MadvocScope > [[scopeType]] , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( [[scopeType]] ) ; madvocScopeConsumer . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void [[bennington]] ( final Class < ? extends MadvocScope > [[bottled]] , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( [[bottled]] ) ; madvocScopeConsumer . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 751 ---------------------------------------------
Prepare a CSRF token . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[prepareCsrfToken]] ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[fundraiser]] ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 752 ---------------------------------------------
Creates a copy of the given source object . --> [[[FAILED]]]

[[[[Adv]]]]: public static BeanCopy [[from]] ( final Object [[source]] ) { BeanCopy [[beanCopy]] = new BeanCopy ( [[source]] ) ; [[beanCopy]] . isSourceMap = [[source]] instanceof Map ; return [[beanCopy]] ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy [[nagged]] ( final Object [[starbucks]] ) { BeanCopy [[unequal]] = new BeanCopy ( [[starbucks]] ) ; [[unequal]] . isSourceMap = [[starbucks]] instanceof Map ; return [[unequal]] ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 753 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 338 / 405 / 10 / 753:  75%|███████▌  | 753/1000 [1:57:03<38:23,  9.33s/it][Succeeded / Failed / Skipped / Total] 338 / 405 / 10 / 753:  75%|███████▌  | 754/1000 [1:57:08<38:13,  9.32s/it][Succeeded / Failed / Skipped / Total] 338 / 406 / 10 / 754:  75%|███████▌  | 754/1000 [1:57:08<38:13,  9.32s/it][Succeeded / Failed / Skipped / Total] 338 / 406 / 10 / 754:  76%|███████▌  | 755/1000 [1:57:26<38:06,  9.33s/it][Succeeded / Failed / Skipped / Total] 338 / 407 / 10 / 755:  76%|███████▌  | 755/1000 [1:57:26<38:06,  9.33s/it][Succeeded / Failed / Skipped / Total] 338 / 407 / 10 / 755:  76%|███████▌  | 756/1000 [1:57:33<37:56,  9.33s/it][Succeeded / Failed / Skipped / Total] 339 / 407 / 10 / 756:  76%|███████▌  | 756/1000 [1:57:33<37:56,  9.33s/it][Succeeded / Failed / Skipped / Total] 339 / 407 / 10 / 756:  76%|███████▌  | 757/1000 [1:57:49<37:49,  9.34s/it][Succeeded / Failed / Skipped / Total] 340 / 407 / 10 / 757:  76%|███████▌  | 757/1000 [1:57:49<37:49,  9.34s/it][Succeeded / Failed / Skipped / Total] 340 / 407 / 10 / 757:  76%|███████▌  | 758/1000 [1:57:56<37:39,  9.34s/it][Succeeded / Failed / Skipped / Total] 340 / 408 / 10 / 758:  76%|███████▌  | 758/1000 [1:57:56<37:39,  9.34s/it][Succeeded / Failed / Skipped / Total] 340 / 408 / 10 / 758:  76%|███████▌  | 759/1000 [1:58:25<37:36,  9.36s/it]Checks if the session contains a CSRF token . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[checkCsrfToken]] ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return "True" == "True" ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return "[[False]]" != "[[False]]" ; } boolean found = "[[False]]" != "[[False]]" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = "True" == "True" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[wildcats]] ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return "True" == "True" ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return "[[Depending]]" != "[[Depending]]" ; } boolean found = "[[Depending]]" != "[[Depending]]" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = "True" == "True" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 754 ---------------------------------------------
Resolve a Petite scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[rioja]] Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 755 ---------------------------------------------
Assure the size of the token set is at least maxTokensPerSession . --> [[[FAILED]]]

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 756 ---------------------------------------------
Register a petite bean . --> Method to create an axiom for the given type --> Socre: 1.0

[[[[Adv]]]]: public < T > BeanDefinition < T > [[registerPetiteBean]] ( final Class < T > type , String [[name]] , Class < ? extends Scope > scopeType , WiringMode [[wiringMode]] , final boolean define , final Consumer < T > consumer ) { if ( [[name]] == null ) { [[name]] = resolveBeanName ( type ) ; } if ( [[wiringMode]] == null ) { [[wiringMode]] = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( [[wiringMode]] == WiringMode . DEFAULT ) { [[wiringMode]] = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > [[axiom]] ( final Class < T > type , String [[inuit]] , Class < ? extends Scope > scopeType , WiringMode [[abduction]] , final boolean define , final Consumer < T > consumer ) { if ( [[inuit]] == null ) { [[inuit]] = resolveBeanName ( type ) ; } if ( [[abduction]] == null ) { [[abduction]] = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( [[abduction]] == WiringMode . DEFAULT ) { [[abduction]] = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 757 ---------------------------------------------
Remove a bean . --> Veu ve veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu veu --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[veuve]] ( final Class [[masons]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 758 ---------------------------------------------
Visit a property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected boolean [[visitProperty]] ( String name , final Object [[value]] ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , [[value]] ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean [[kellie]] ( String name , final Object [[hammerhead]] ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , [[hammerhead]] ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 759 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 340 / 409 / 10 / 759:  76%|███████▌  | 759/1000 [1:58:25<37:36,  9.36s/it][Succeeded / Failed / Skipped / Total] 340 / 410 / 10 / 760:  76%|███████▌  | 760/1000 [1:58:25<37:23,  9.35s/it][Succeeded / Failed / Skipped / Total] 340 / 410 / 10 / 760:  76%|███████▌  | 761/1000 [1:59:11<37:26,  9.40s/it][Succeeded / Failed / Skipped / Total] 340 / 411 / 10 / 761:  76%|███████▌  | 761/1000 [1:59:11<37:26,  9.40s/it][Succeeded / Failed / Skipped / Total] 340 / 411 / 10 / 761:  76%|███████▌  | 762/1000 [1:59:12<37:13,  9.39s/it][Succeeded / Failed / Skipped / Total] 340 / 412 / 10 / 762:  76%|███████▌  | 762/1000 [1:59:12<37:13,  9.39s/it][Succeeded / Failed / Skipped / Total] 340 / 412 / 10 / 762:  76%|███████▋  | 763/1000 [1:59:21<37:04,  9.39s/it]Register a bean . --> [[[FAILED]]]

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 760 ---------------------------------------------
Register the table reference for the entity . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 761 ---------------------------------------------
Resolve bean names for a given type . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] [[resolveBeanNamesForType]] ( final Class type ) { String [ ] [[beanNames]] = beanCollections . get ( type ) ; if ( [[beanNames]] != null ) { return [[beanNames]] ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition [[beanDefinition]] = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( [[beanDefinition]] . type , type ) ) { String [[beanName]] = entry . getKey ( ) ; list . add ( [[beanName]] ) ; } } if ( list . isEmpty ( ) ) { [[beanNames]] = StringPool . EMPTY_ARRAY ; } else { [[beanNames]] = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , [[beanNames]] ) ; return [[beanNames]] ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] [[scarfed]] ( final Class type ) { String [ ] [[saving]] = beanCollections . get ( type ) ; if ( [[saving]] != null ) { return [[saving]] ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition [[correlation]] = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( [[correlation]] . type , type ) ) { String [[accepted]] = entry . getKey ( ) ; list . add ( [[accepted]] ) ; } } if ( list . isEmpty ( ) ) { [[saving]] = StringPool . EMPTY_ARRAY ; } else { [[saving]] = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , [[saving]] ) ; return [[saving]] ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 762 ---------------------------------------------
Register a Petite constructor injection point . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerPetiteCtorInjectionPoint]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void [[agoraphobic]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 763 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 340 / 413 / 10 / 763:  76%|███████▋  | 763/1000 [1:59:21<37:04,  9.39s/it][Succeeded / Failed / Skipped / Total] 340 / 413 / 10 / 763:  76%|███████▋  | 764/1000 [1:59:26<36:53,  9.38s/it][Succeeded / Failed / Skipped / Total] 340 / 414 / 10 / 764:  76%|███████▋  | 764/1000 [1:59:26<36:53,  9.38s/it][Succeeded / Failed / Skipped / Total] 340 / 414 / 10 / 764:  76%|███████▋  | 765/1000 [1:59:30<36:42,  9.37s/it][Succeeded / Failed / Skipped / Total] 341 / 414 / 10 / 765:  76%|███████▋  | 765/1000 [1:59:30<36:42,  9.37s/it][Succeeded / Failed / Skipped / Total] 341 / 414 / 10 / 765:  77%|███████▋  | 766/1000 [1:59:39<36:33,  9.37s/it][Succeeded / Failed / Skipped / Total] 342 / 414 / 10 / 766:  77%|███████▋  | 766/1000 [1:59:39<36:33,  9.37s/it][Succeeded / Failed / Skipped / Total] 342 / 414 / 10 / 766:  77%|███████▋  | 767/1000 [2:00:00<36:27,  9.39s/it][Succeeded / Failed / Skipped / Total] 342 / 415 / 10 / 767:  77%|███████▋  | 767/1000 [2:00:00<36:27,  9.39s/it][Succeeded / Failed / Skipped / Total] 342 / 415 / 10 / 767:  77%|███████▋  | 768/1000 [2:00:10<36:18,  9.39s/it]Register a Petite set injection point . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 764 ---------------------------------------------
Register a Petite property injection point . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 765 ---------------------------------------------
Iterate through all beans of the given type and accept them to the given consumer . --> nikita bean name consumer --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[nikita]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 766 ---------------------------------------------
Intercepts an action request . --> Intercept a cockamamie --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[actionRequest]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest [[cockamamie]] ) throws Exception { printBefore ( [[cockamamie]] ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[cockamamie]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[cockamamie]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 767 ---------------------------------------------
Register Petite init methods . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 768 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 342 / 416 / 10 / 768:  77%|███████▋  | 768/1000 [2:00:10<36:18,  9.39s/it][Succeeded / Failed / Skipped / Total] 342 / 416 / 10 / 768:  77%|███████▋  | 769/1000 [2:00:15<36:07,  9.38s/it][Succeeded / Failed / Skipped / Total] 343 / 416 / 10 / 769:  77%|███████▋  | 769/1000 [2:00:15<36:07,  9.38s/it][Succeeded / Failed / Skipped / Total] 343 / 416 / 10 / 769:  77%|███████▋  | 770/1000 [2:00:23<35:57,  9.38s/it][Succeeded / Failed / Skipped / Total] 343 / 417 / 10 / 770:  77%|███████▋  | 770/1000 [2:00:23<35:57,  9.38s/it][Succeeded / Failed / Skipped / Total] 343 / 417 / 10 / 770:  77%|███████▋  | 771/1000 [2:00:26<35:46,  9.37s/it][Succeeded / Failed / Skipped / Total] 344 / 417 / 10 / 771:  77%|███████▋  | 771/1000 [2:00:26<35:46,  9.37s/it][Succeeded / Failed / Skipped / Total] 344 / 417 / 10 / 771:  77%|███████▋  | 772/1000 [2:00:27<35:34,  9.36s/it]Register a Petite method injection point . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 769 ---------------------------------------------
Define parameters . --> Compares this schoolmistress to this schoolmistress --> Socre: 1.0

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > [[properties]] ) { for ( Map . Entry < ? , ? > entry : [[properties]] . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[equals]] ( final Map < ? , ? > [[schoolmistress]] ) { for ( Map . Entry < ? , ? > entry : [[schoolmistress]] . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 770 ---------------------------------------------
Register a petite provider . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 771 ---------------------------------------------
Push an integer to the stack . --> push lawsuit to dependable --> Socre: 1.0

[[[[Adv]]]]: public static void pushInt ( final MethodVisitor [[mv]] , final int [[value]] ) { if ( [[value]] <= 5 ) { [[mv]] . visitInsn ( ICONST_0 + [[value]] ) ; } else if ( [[value]] <= Byte . MAX_VALUE ) { [[mv]] . visitIntInsn ( BIPUSH , [[value]] ) ; } else { [[mv]] . visitIntInsn ( SIPUSH , [[value]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void pushInt ( final MethodVisitor [[dependable]] , final int [[lawsuit]] ) { if ( [[lawsuit]] <= 5 ) { [[dependable]] . visitInsn ( ICONST_0 + [[lawsuit]] ) ; } else if ( [[lawsuit]] <= Byte . MAX_VALUE ) { [[dependable]] . visitIntInsn ( BIPUSH , [[lawsuit]] ) ; } else { [[dependable]] . visitIntInsn ( SIPUSH , [[lawsuit]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 772 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 344 / 418 / 10 / 772:  77%|███████▋  | 772/1000 [2:00:27<35:34,  9.36s/it][Succeeded / Failed / Skipped / Total] 344 / 418 / 10 / 772:  77%|███████▋  | 773/1000 [2:01:15<35:36,  9.41s/it][Succeeded / Failed / Skipped / Total] 345 / 418 / 10 / 773:  77%|███████▋  | 773/1000 [2:01:15<35:36,  9.41s/it][Succeeded / Failed / Skipped / Total] 345 / 418 / 10 / 773:  77%|███████▋  | 774/1000 [2:01:15<35:24,  9.40s/it][Succeeded / Failed / Skipped / Total] 345 / 419 / 10 / 774:  77%|███████▋  | 774/1000 [2:01:15<35:24,  9.40s/it][Succeeded / Failed / Skipped / Total] 345 / 419 / 10 / 774:  78%|███████▊  | 775/1000 [2:01:31<35:16,  9.41s/it][Succeeded / Failed / Skipped / Total] 345 / 420 / 10 / 775:  78%|███████▊  | 775/1000 [2:01:31<35:16,  9.41s/it][Succeeded / Failed / Skipped / Total] 345 / 420 / 10 / 775:  78%|███████▊  | 776/1000 [2:01:52<35:10,  9.42s/it][Succeeded / Failed / Skipped / Total] 345 / 421 / 10 / 776:  78%|███████▊  | 776/1000 [2:01:52<35:10,  9.42s/it][Succeeded / Failed / Skipped / Total] 345 / 421 / 10 / 776:  78%|███████▊  | 777/1000 [2:01:53<34:58,  9.41s/it][Succeeded / Failed / Skipped / Total] 345 / 422 / 10 / 777:  78%|███████▊  | 777/1000 [2:01:53<34:58,  9.41s/it][Succeeded / Failed / Skipped / Total] 345 / 422 / 10 / 777:  78%|███████▊  | 778/1000 [2:01:55<34:47,  9.40s/it][Succeeded / Failed / Skipped / Total] 345 / 423 / 10 / 778:  78%|███████▊  | 778/1000 [2:01:55<34:47,  9.40s/it][Succeeded / Failed / Skipped / Total] 345 / 423 / 10 / 778:  78%|███████▊  | 779/1000 [2:02:09<34:39,  9.41s/it]Register Petite destroy methods . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 773 ---------------------------------------------
Load special method arguments . --> Liefert die ALOAD - > ALOAD - > ALOAD - > ALOAD --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { [[mv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[ask]] ( final MethodVisitor [[entrepreneur]] , final MethodInfo methodInfo ) { [[entrepreneur]] . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[entrepreneur]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 774 ---------------------------------------------
Register a petite provider . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 775 ---------------------------------------------
Resolves the Java version . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[platformVersion]] = javaVersionNumber - 8 + 52 ; return [[version]] > [[platformVersion]] ? [[version]] : [[platformVersion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[whereyou]] ( final int [[flava]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[mapping]] = javaVersionNumber - 8 + 52 ; return [[flava]] > [[mapping]] ? [[flava]] : [[mapping]] ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 776 ---------------------------------------------
Advice field name . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String [[name]] , final int [[index]] ) { return ProxettaNames . fieldPrefix + [[name]] + ProxettaNames . fieldDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[suchlike]] ( final String [[networks]] , final int [[coined]] ) { return ProxettaNames . fieldPrefix + [[networks]] + ProxettaNames . fieldDivider + [[coined]] ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 777 ---------------------------------------------
Advice method name . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String [[name]] , final int index ) { return ProxettaNames . methodPrefix + [[name]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[alt]] ( final String [[mutual]] , final int index ) { return ProxettaNames . methodPrefix + [[mutual]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 778 ---------------------------------------------
Check that an argument index is valid . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo [[methodInfo]] , final int [[argIndex]] ) { if ( ( [[argIndex]] < 1 ) || ( [[argIndex]] > [[methodInfo]] . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[argIndex]] ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[lng]] ( final MethodInfo [[occupants]] , final int [[past]] ) { if ( ( [[past]] < 1 ) || ( [[past]] > [[occupants]] . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[past]] ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 779 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 346 / 423 / 10 / 779:  78%|███████▊  | 779/1000 [2:02:09<34:39,  9.41s/it][Succeeded / Failed / Skipped / Total] 346 / 423 / 10 / 779:  78%|███████▊  | 780/1000 [2:02:19<34:30,  9.41s/it][Succeeded / Failed / Skipped / Total] 346 / 424 / 10 / 780:  78%|███████▊  | 780/1000 [2:02:19<34:30,  9.41s/it][Succeeded / Failed / Skipped / Total] 346 / 424 / 10 / 780:  78%|███████▊  | 781/1000 [2:02:36<34:22,  9.42s/it][Succeeded / Failed / Skipped / Total] 347 / 424 / 10 / 781:  78%|███████▊  | 781/1000 [2:02:36<34:22,  9.42s/it][Succeeded / Failed / Skipped / Total] 347 / 424 / 10 / 781:  78%|███████▊  | 782/1000 [2:02:43<34:12,  9.42s/it][Succeeded / Failed / Skipped / Total] 347 / 425 / 10 / 782:  78%|███████▊  | 782/1000 [2:02:43<34:12,  9.42s/it][Succeeded / Failed / Skipped / Total] 347 / 425 / 10 / 782:  78%|███████▊  | 783/1000 [2:02:50<34:02,  9.41s/it][Succeeded / Failed / Skipped / Total] 347 / 426 / 10 / 783:  78%|███████▊  | 783/1000 [2:02:50<34:02,  9.41s/it][Succeeded / Failed / Skipped / Total] 347 / 426 / 10 / 783:  78%|███████▊  | 784/1000 [2:02:56<33:52,  9.41s/it][Succeeded / Failed / Skipped / Total] 348 / 426 / 10 / 784:  78%|███████▊  | 784/1000 [2:02:56<33:52,  9.41s/it][Succeeded / Failed / Skipped / Total] 348 / 426 / 10 / 784:  78%|███████▊  | 785/1000 [2:03:26<33:48,  9.43s/it]Store a primitive type into an array . --> OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[ooooh]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 780 ---------------------------------------------
Load virtual method arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[loadVirtualMethodArguments]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] ) { for ( int i = 1 ; i <= [[methodInfo]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , [[methodInfo]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void [[noblewoman]] ( final MethodVisitor mv , final MethodInfo [[derived]] ) { for ( int i = 1 ; i <= [[derived]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , [[derived]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 781 ---------------------------------------------
Load a method argument . --> ishikawa ishikawa --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[ishikawa]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 782 ---------------------------------------------
Load static method arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { for ( int i = 0 ; i < [[methodInfo]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[raskolnikov]] ( final MethodVisitor [[smelling]] , final MethodInfo [[schopenhauer]] ) { for ( int i = 0 ; i < [[schopenhauer]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[smelling]] , [[schopenhauer]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 783 ---------------------------------------------
Store a method argument . --> [[[FAILED]]]

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int [[index]] ) { int offset = methodInfo . getArgumentOffset ( [[index]] ) ; int [[type]] = methodInfo . getArgument ( [[index]] ) . getOpcode ( ) ; switch ( [[type]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int [[lawsuit]] ) { int offset = methodInfo . getArgumentOffset ( [[lawsuit]] ) ; int [[angela]] = methodInfo . getArgument ( [[lawsuit]] ) . getOpcode ( ) ; switch ( [[angela]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 784 ---------------------------------------------
Creates a key for a method signature . --> Returns a string representation of a holt --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String methodName , final String [[description]] , final String [[className]] ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( [[description]] ) . append ( StringPool . UNDERSCORE ) . append ( [[className]] ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[holt]] ( final int access , final String methodName , final String [[aeroplane]] , final String [[capita]] ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( [[aeroplane]] ) . append ( StringPool . UNDERSCORE ) . append ( [[capita]] ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 785 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 349 / 426 / 10 / 785:  78%|███████▊  | 785/1000 [2:03:26<33:48,  9.43s/it][Succeeded / Failed / Skipped / Total] 349 / 426 / 10 / 785:  79%|███████▊  | 786/1000 [2:03:26<33:36,  9.42s/it][Succeeded / Failed / Skipped / Total] 350 / 426 / 10 / 786:  79%|███████▊  | 786/1000 [2:03:26<33:36,  9.42s/it][Succeeded / Failed / Skipped / Total] 350 / 426 / 10 / 786:  79%|███████▊  | 787/1000 [2:03:28<33:25,  9.41s/it][Succeeded / Failed / Skipped / Total] 351 / 426 / 10 / 787:  79%|███████▊  | 787/1000 [2:03:28<33:25,  9.41s/it][Succeeded / Failed / Skipped / Total] 351 / 427 / 10 / 788:  79%|███████▉  | 788/1000 [2:03:28<33:13,  9.40s/it][Succeeded / Failed / Skipped / Total] 351 / 427 / 10 / 788:  79%|███████▉  | 789/1000 [2:03:36<33:03,  9.40s/it][Succeeded / Failed / Skipped / Total] 351 / 428 / 10 / 789:  79%|███████▉  | 789/1000 [2:03:36<33:03,  9.40s/it]Resolve the bearer token from the Authorization header . --> Get the campesinos from the Authorization header --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int [[ndx]] = header . indexOf ( "Bearer " ) ; if ( [[ndx]] == - 1 ) { return null ; } return header . substring ( [[ndx]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[campesinos]] ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int [[cornerstone]] = header . indexOf ( "Bearer " ) ; if ( [[cornerstone]] == - 1 ) { return null ; } return header . substring ( [[cornerstone]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 786 ---------------------------------------------
Require authentication . --> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACACACACACACACACACACACACACACAAAAAAAAAAAAAA --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse [[resp]] , final String realm ) throws IOException { [[resp]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[resp]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[aaaah]] ( final HttpServletResponse [[ub]] , final String realm ) throws IOException { [[ub]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[ub]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 787 ---------------------------------------------
Prepare a download request . --> zeki zeki olla --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse response , final File [[file]] , final String mimeType ) { if ( ! [[file]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[file]] ) ; } if ( [[file]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[file]] ) ; } prepareResponse ( response , [[file]] . getAbsolutePath ( ) , mimeType , ( int ) [[file]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[zeki]] ( final HttpServletResponse response , final File [[olla]] , final String mimeType ) { if ( ! [[olla]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[olla]] ) ; } if ( [[olla]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[olla]] ) ; } prepareResponse ( response , [[olla]] . getAbsolutePath ( ) , mimeType , ( int ) [[olla]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 788 ---------------------------------------------
Generate a NEWARRAY instruction . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[componentType]] ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[contemptuous]] ( final MethodVisitor mv , final Class [[interchangeable]] ) { if ( [[interchangeable]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[interchangeable]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[interchangeable]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[interchangeable]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[interchangeable]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[interchangeable]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[interchangeable]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[interchangeable]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[interchangeable]] ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 789 ---------------------------------------------
Prepare the return value of a method . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , int [[varOffset]] ) { [[varOffset]] += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : mv . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( mv ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( mv ) ; break ; case ' ' : AsmUtil . valueOfShort ( mv ) ; break ; case ' ' : AsmUtil . valueOfInteger ( mv ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( mv ) ; break ; case ' ' : AsmUtil . valueOfLong ( mv ) ; break ; case ' ' : AsmUtil . valueOfFloat ( mv ) ; break ; case ' ' : AsmUtil . valueOfDouble ( mv ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[contained]] ( final MethodVisitor mv , final MethodInfo [[nonlinear]] , int [[palermo]] ) { [[palermo]] += [[nonlinear]] . getAllArgumentsSize ( ) ; switch ( [[nonlinear]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : mv . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( mv ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( mv ) ; break ; case ' ' : AsmUtil . valueOfShort ( mv ) ; break ; case ' ' : AsmUtil . valueOfInteger ( mv ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( mv ) ; break ; case ' ' : AsmUtil . valueOfLong ( mv ) ; break ; case ' ' : AsmUtil . valueOfFloat ( mv ) ; break ; case ' ' : AsmUtil . valueOfDouble ( mv ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 790 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 352 / 428 / 10 / 790:  79%|███████▉  | 790/1000 [2:03:44<32:53,  9.40s/it][Succeeded / Failed / Skipped / Total] 352 / 428 / 10 / 790:  79%|███████▉  | 791/1000 [2:03:46<32:42,  9.39s/it][Succeeded / Failed / Skipped / Total] 353 / 428 / 10 / 791:  79%|███████▉  | 791/1000 [2:03:46<32:42,  9.39s/it][Succeeded / Failed / Skipped / Total] 354 / 428 / 10 / 792:  79%|███████▉  | 792/1000 [2:03:58<32:33,  9.39s/it][Succeeded / Failed / Skipped / Total] 354 / 428 / 10 / 792:  79%|███████▉  | 793/1000 [2:03:59<32:22,  9.38s/it][Succeeded / Failed / Skipped / Total] 355 / 428 / 10 / 793:  79%|███████▉  | 793/1000 [2:03:59<32:22,  9.38s/it][Succeeded / Failed / Skipped / Total] 355 / 428 / 10 / 793:  79%|███████▉  | 794/1000 [2:04:09<32:12,  9.38s/it][Succeeded / Failed / Skipped / Total] 356 / 428 / 10 / 794:  79%|███████▉  | 794/1000 [2:04:09<32:12,  9.38s/it][Succeeded / Failed / Skipped / Total] 356 / 428 / 10 / 794:  80%|███████▉  | 795/1000 [2:04:44<32:10,  9.41s/it][Succeeded / Failed / Skipped / Total] 357 / 428 / 10 / 795:  80%|███████▉  | 795/1000 [2:04:44<32:10,  9.41s/it][Succeeded / Failed / Skipped / Total] 357 / 428 / 10 / 795:  80%|███████▉  | 796/1000 [2:04:56<32:01,  9.42s/it]Checks if the flags are empty . --> Methode bipolar . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags flags ) { if ( flags == null ) return "[[True]]" == "[[True]]" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] [[userFlags]] = flags . getUserFlags ( ) ; if ( [[userFlags]] != null && [[userFlags]] . length > 0 ) { return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[bipolar]] ( Flags flags ) { if ( flags == null ) return "[[Pullman]]" == "[[Pullman]]" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] [[général]] = flags . getUserFlags ( ) ; if ( [[général]] != null && [[général]] . length > 0 ) { return "False" != "False" ; } return "[[Pullman]]" == "[[Pullman]]" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 791 ---------------------------------------------
Prepare the response to be sent to the client . --> Herder der Content - Type and Content - Length --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareResponse]] ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void [[herder]] ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 792 ---------------------------------------------
Store the context path in the request and servlet context . --> Aaaah aaaah aaaah --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void [[aaaah]] ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 793 ---------------------------------------------
Reads the request body from a reader . --> brimstone a cara --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest [[request]] ) throws IOException { BufferedReader buff = [[request]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[brimstone]] ( final HttpServletRequest [[cara]] ) throws IOException { BufferedReader buff = [[cara]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 794 ---------------------------------------------
Extract the encoding from the given content type . --> Returns the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the first occurrence of the --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String [[contentType]] , String defaultEncoding ) { String [[encoding]] = [[extractEncoding]] ( [[contentType]] ) ; if ( [[encoding]] == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } [[encoding]] = defaultEncoding ; } return [[encoding]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[nearly]] ( final String [[feces]] , String defaultEncoding ) { String [[transmitted]] = [[nearly]] ( [[feces]] ) ; if ( [[transmitted]] == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } [[transmitted]] = defaultEncoding ; } return [[transmitted]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 795 ---------------------------------------------
Read the request body from the request stream . --> zaza a tarantulas --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromStream]] ( final HttpServletRequest [[request]] ) throws IOException { String charEncoding = [[request]] . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream [[inputStream]] = [[request]] . getInputStream ( ) ; if ( [[inputStream]] != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( [[inputStream]] , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[zaza]] ( final HttpServletRequest [[tarantulas]] ) throws IOException { String charEncoding = [[tarantulas]] . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream [[carmine]] = [[tarantulas]] . getInputStream ( ) ; if ( [[carmine]] != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( [[carmine]] , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
[Succeeded / Failed / Skipped / Total] 357 / 429 / 10 / 796:  80%|███████▉  | 796/1000 [2:04:56<32:01,  9.42s/it][Succeeded / Failed / Skipped / Total] 357 / 429 / 10 / 796:  80%|███████▉  | 797/1000 [2:05:31<31:58,  9.45s/it][Succeeded / Failed / Skipped / Total] 357 / 430 / 10 / 797:  80%|███████▉  | 797/1000 [2:05:31<31:58,  9.45s/it][Succeeded / Failed / Skipped / Total] 357 / 430 / 10 / 797:  80%|███████▉  | 798/1000 [2:05:40<31:48,  9.45s/it][Succeeded / Failed / Skipped / Total] 358 / 430 / 10 / 798:  80%|███████▉  | 798/1000 [2:05:40<31:48,  9.45s/it][Succeeded / Failed / Skipped / Total] 358 / 430 / 10 / 798:  80%|███████▉  | 799/1000 [2:05:44<31:37,  9.44s/it][Succeeded / Failed / Skipped / Total] 358 / 431 / 10 / 799:  80%|███████▉  | 799/1000 [2:05:44<31:37,  9.44s/it][Succeeded / Failed / Skipped / Total] 358 / 431 / 10 / 799:  80%|████████  | 800/1000 [2:05:57<31:29,  9.45s/it][Succeeded / Failed / Skipped / Total] 359 / 431 / 10 / 800:  80%|████████  | 800/1000 [2:05:57<31:29,  9.45s/it][Succeeded / Failed / Skipped / Total] 359 / 432 / 10 / 801:  80%|████████  | 801/1000 [2:05:57<31:17,  9.44s/it][Succeeded / Failed / Skipped / Total] 359 / 432 / 10 / 801:  80%|████████  | 802/1000 [2:05:59<31:06,  9.43s/it][Succeeded / Failed / Skipped / Total] 360 / 432 / 10 / 802:  80%|████████  | 802/1000 [2:05:59<31:06,  9.43s/it][Succeeded / Failed / Skipped / Total] 361 / 432 / 10 / 803:  80%|████████  | 803/1000 [2:06:05<30:56,  9.42s/it][Succeeded / Failed / Skipped / Total] 361 / 432 / 10 / 803:  80%|████████  | 804/1000 [2:06:19<30:47,  9.43s/it]--------------------------------------------- Result 796 ---------------------------------------------
Invoke a tag body . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment [[body]] ) throws JspException { if ( [[body]] == null ) { return ; } try { [[body]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[lagged]] ( final JspFragment [[figures]] ) throws JspException { if ( [[figures]] == null ) { return ; } try { [[figures]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 797 ---------------------------------------------
Returns a list of all cookies with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookie [ ] [[getAllCookies]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > [[list]] = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { [[list]] . add ( cookie ) ; } } if ( [[list]] . isEmpty ( ) ) { return null ; } return [[list]] . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] [[kamikaze]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > [[monitoring]] = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { [[monitoring]] . add ( cookie ) ; } } if ( [[monitoring]] . isEmpty ( ) ) { return null ; } return [[monitoring]] . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 798 ---------------------------------------------
Renders the given body . --> box in a gulped fragment --> Socre: 1.0

[[[[Adv]]]]: public static char [ ] [[renderBody]] ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] [[boxin]] ( final JspFragment [[gulped]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[gulped]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 799 ---------------------------------------------
Store the context path . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[storeContextPath]] ( final ServletContext servletContext , final String [[contextPathVariableName]] ) { String [[ctxPath]] = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void [[mcgonagall]] ( final ServletContext servletContext , final String [[basted]] ) { String [[warhammer]] = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[basted]] , [[warhammer]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 800 ---------------------------------------------
Injects the parameters of the bean . --> På på på --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[på]] ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 801 ---------------------------------------------
Returns true if the given name is a GET parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest request , String [[name]] ) { [[name]] = URLCoder . encodeQueryParam ( [[name]] ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( [[name]] ) ) { return "[[True]]" == "[[True]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest request , String [[embodiment]] ) { [[embodiment]] = URLCoder . encodeQueryParam ( [[embodiment]] ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( [[embodiment]] ) ) { return "[[Phone]]" == "[[Phone]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 802 ---------------------------------------------
Invoke all init methods for the given invocation strategy . --> Invoke all tankers for the given invocation strategy --> Socre: 1.0

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint [[initMethod]] : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != [[initMethod]] . invocationStrategy ) { continue ; } try { [[initMethod]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[initMethod]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[tankers]] ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint [[shriver]] : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != [[shriver]] . invocationStrategy ) { continue ; } try { [[shriver]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[shriver]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 803 ---------------------------------------------
Adds a new props entry to the map . --> Methode permettant d ajout une PropsEntry . --> Socre: 1.0

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean [[append]] ) { String realValue = value ; if ( [[append]] || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean [[rené]] ) { String realValue = value ; if ( [[rené]] || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 804 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 361 / 433 / 10 / 804:  80%|████████  | 804/1000 [2:06:19<30:47,  9.43s/it][Succeeded / Failed / Skipped / Total] 361 / 433 / 10 / 804:  80%|████████  | 805/1000 [2:06:21<30:36,  9.42s/it][Succeeded / Failed / Skipped / Total] 361 / 434 / 10 / 805:  80%|████████  | 805/1000 [2:06:21<30:36,  9.42s/it][Succeeded / Failed / Skipped / Total] 361 / 434 / 10 / 805:  81%|████████  | 806/1000 [2:06:21<30:24,  9.41s/it][Succeeded / Failed / Skipped / Total] 361 / 435 / 10 / 806:  81%|████████  | 806/1000 [2:06:21<30:24,  9.41s/it][Succeeded / Failed / Skipped / Total] 361 / 435 / 10 / 806:  81%|████████  | 807/1000 [2:06:25<30:14,  9.40s/it][Succeeded / Failed / Skipped / Total] 361 / 436 / 10 / 807:  81%|████████  | 807/1000 [2:06:25<30:14,  9.40s/it][Succeeded / Failed / Skipped / Total] 361 / 436 / 10 / 807:  81%|████████  | 808/1000 [2:06:31<30:03,  9.40s/it][Succeeded / Failed / Skipped / Total] 362 / 436 / 10 / 808:  81%|████████  | 808/1000 [2:06:31<30:03,  9.40s/it][Succeeded / Failed / Skipped / Total] 363 / 436 / 10 / 809:  81%|████████  | 809/1000 [2:06:31<29:52,  9.38s/it][Succeeded / Failed / Skipped / Total] 363 / 436 / 10 / 809:  81%|████████  | 810/1000 [2:06:35<29:41,  9.38s/it][Succeeded / Failed / Skipped / Total] 364 / 436 / 10 / 810:  81%|████████  | 810/1000 [2:06:35<29:41,  9.38s/it][Succeeded / Failed / Skipped / Total] 365 / 436 / 10 / 811:  81%|████████  | 811/1000 [2:06:45<29:32,  9.38s/it][Succeeded / Failed / Skipped / Total] 365 / 436 / 10 / 811:  81%|████████  | 812/1000 [2:07:06<29:25,  9.39s/it]Renders the given JspFragment to a String . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment [[body]] ) throws JspException { char [ ] result = renderBody ( [[body]] ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[snakehead]] ( final JspFragment [[excerpt]] ) throws JspException { char [ ] result = renderBody ( [[excerpt]] ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 805 ---------------------------------------------
Copy parameters to attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 806 ---------------------------------------------
Prepare the given array of parameters to be used in a request . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 807 ---------------------------------------------
Call all destroy methods . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint [[destroyMethodPoint]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[destroyMethodPoint]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[destroyMethodPoint]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[zafar]] ( ) { for ( final DestroyMethodPoint [[aiden]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[aiden]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[aiden]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 808 ---------------------------------------------
Resolve macros . --> Given a value and a list of profiles return the oryour value --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String value , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[oryour]] ( String value , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 809 ---------------------------------------------
Rewrite an action path . --> Returns the kiri for the given syracuse --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[rewrite]] ( final HttpServletRequest servletRequest , final String actionPath , final String [[httpMethod]] ) { return actionPath ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[kiri]] ( final HttpServletRequest servletRequest , final String actionPath , final String [[syracuse]] ) { return actionPath ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 810 ---------------------------------------------
Extract profiles from a map . --> Extract a tamami from a list of profiles and wildcard patterns --> Socre: 1.0

[[[[Adv]]]]: public Map extract ( Map [[target]] , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( [[target]] == null ) { [[target]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map extract ( Map [[tamami]] , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( [[tamami]] == null ) { [[tamami]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 811 ---------------------------------------------
Adds a base property . --> Method to put morehead --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String key , final String value , final boolean [[append]] ) { put ( null , baseProperties , key , value , [[append]] ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[morehead]] ( final String key , final String value , final boolean [[lawsuit]] ) { put ( null , baseProperties , key , value , [[lawsuit]] ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 812 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 366 / 436 / 10 / 812:  81%|████████  | 812/1000 [2:07:06<29:25,  9.39s/it][Succeeded / Failed / Skipped / Total] 366 / 436 / 10 / 812:  81%|████████▏ | 813/1000 [2:07:13<29:15,  9.39s/it][Succeeded / Failed / Skipped / Total] 366 / 437 / 10 / 813:  81%|████████▏ | 813/1000 [2:07:13<29:15,  9.39s/it][Succeeded / Failed / Skipped / Total] 366 / 437 / 10 / 813:  81%|████████▏ | 814/1000 [2:07:16<29:05,  9.38s/it][Succeeded / Failed / Skipped / Total] 367 / 437 / 10 / 814:  81%|████████▏ | 814/1000 [2:07:16<29:05,  9.38s/it][Succeeded / Failed / Skipped / Total] 367 / 437 / 10 / 814:  82%|████████▏ | 815/1000 [2:07:22<28:54,  9.38s/it][Succeeded / Failed / Skipped / Total] 368 / 437 / 10 / 815:  82%|████████▏ | 815/1000 [2:07:22<28:54,  9.38s/it][Succeeded / Failed / Skipped / Total] 368 / 437 / 10 / 815:  82%|████████▏ | 816/1000 [2:07:24<28:43,  9.37s/it][Succeeded / Failed / Skipped / Total] 369 / 437 / 10 / 816:  82%|████████▏ | 816/1000 [2:07:24<28:43,  9.37s/it][Succeeded / Failed / Skipped / Total] 369 / 437 / 10 / 816:  82%|████████▏ | 817/1000 [2:08:18<28:44,  9.42s/it][Succeeded / Failed / Skipped / Total] 370 / 437 / 10 / 817:  82%|████████▏ | 817/1000 [2:08:18<28:44,  9.42s/it][Succeeded / Failed / Skipped / Total] 370 / 437 / 10 / 817:  82%|████████▏ | 818/1000 [2:08:26<28:34,  9.42s/it][Succeeded / Failed / Skipped / Total] 371 / 437 / 10 / 818:  82%|████████▏ | 818/1000 [2:08:26<28:34,  9.42s/it][Succeeded / Failed / Skipped / Total] 371 / 437 / 10 / 818:  82%|████████▏ | 819/1000 [2:08:26<28:23,  9.41s/it]Reads a 4 byte word from the byte array starting at the given offset . --> stream to ord in margrave --> Socre: 1.0

[[[[Adv]]]]: private static int streamtoword ( byte [ ] [[data]] , int [ ] offp ) { int i ; int [[word]] = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { [[word]] = ( [[word]] << 8 ) | ( [[data]] [ off ] & 0xff ) ; off = ( off + 1 ) % [[data]] . length ; } offp [ 0 ] = off ; return [[word]] ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int streamtoword ( byte [ ] [[margrave]] , int [ ] offp ) { int i ; int [[unimpressive]] = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { [[unimpressive]] = ( [[unimpressive]] << 8 ) | ( [[margrave]] [ off ] & 0xff ) ; off = ( off + 1 ) % [[margrave]] . length ; } offp [ 0 ] = off ; return [[unimpressive]] ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 813 ---------------------------------------------
Creates a new instance of the bean . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[hereabout]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 814 ---------------------------------------------
Adds a property to a profile . --> Methode permettant d ajout une biologist --> Socre: 1.0

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String [[value]] , final String profile , final boolean append ) { Map < String , PropsEntry > [[map]] = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , [[map]] , key , [[value]] , append ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String [[biologist]] , final String profile , final boolean append ) { Map < String , PropsEntry > [[frédéric]] = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , [[frédéric]] , key , [[biologist]] , append ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 815 ---------------------------------------------
Adds a header to the response . --> Liefert die benjie volkswagen --> Socre: 1.0

[[[[Adv]]]]: public void [[addHeader]] ( final String [[name]] , final String value ) { List < String > valuesList = super . getAll ( [[name]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[name]] , value ) ; return ; } super . remove ( [[name]] ) ; valuesList . add ( value ) ; super . addAll ( [[name]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[volkswagen]] ( final String [[benjie]] , final String value ) { List < String > valuesList = super . getAll ( [[benjie]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[benjie]] , value ) ; return ; } super . remove ( [[benjie]] ) ; valuesList . add ( value ) ; super . addAll ( [[benjie]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 816 ---------------------------------------------
Get a profile property . --> Get the PropsEntry for a magellan --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String [[profile]] , final String key ) { final Map < String , PropsEntry > [[profileMap]] = profileProperties . get ( [[profile]] ) ; if ( [[profileMap]] == null ) { return null ; } return [[profileMap]] . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[fruit]] ( final String [[magellan]] , final String key ) { final Map < String , PropsEntry > [[princeton]] = profileProperties . get ( [[magellan]] ) ; if ( [[princeton]] == null ) { return null ; } return [[princeton]] . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 817 ---------------------------------------------
Detect and register an alias . --> Method to register aflame --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues [[annotationValues]] , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( [[annotationValues]] ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[aflame]] ( final ActionAnnotationValues [[breadfruit]] , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( [[breadfruit]] ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 818 ---------------------------------------------
Copies the next max bytes from the stream to the given output stream . --> Methode permettantes avec jérôme --> Socre: 1.0

[[[[Adv]]]]: public int [[copyMax]] ( final OutputStream [[out]] , final int [[maxBytes]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } [[out]] . write ( b ) ; count ++ ; if ( count == [[maxBytes]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int [[information]] ( final OutputStream [[jérôme]] , final int [[escondido]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } [[jérôme]] . write ( b ) ; count ++ ; if ( count == [[escondido]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 819 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 371 / 438 / 10 / 819:  82%|████████▏ | 819/1000 [2:08:26<28:23,  9.41s/it][Succeeded / Failed / Skipped / Total] 371 / 438 / 10 / 819:  82%|████████▏ | 820/1000 [2:08:47<28:16,  9.42s/it][Succeeded / Failed / Skipped / Total] 371 / 439 / 10 / 820:  82%|████████▏ | 820/1000 [2:08:47<28:16,  9.42s/it][Succeeded / Failed / Skipped / Total] 371 / 439 / 10 / 820:  82%|████████▏ | 821/1000 [2:08:49<28:05,  9.41s/it][Succeeded / Failed / Skipped / Total] 371 / 440 / 10 / 821:  82%|████████▏ | 821/1000 [2:08:49<28:05,  9.41s/it][Succeeded / Failed / Skipped / Total] 371 / 440 / 10 / 821:  82%|████████▏ | 822/1000 [2:09:04<27:57,  9.42s/it][Succeeded / Failed / Skipped / Total] 371 / 441 / 10 / 822:  82%|████████▏ | 822/1000 [2:09:04<27:57,  9.42s/it][Succeeded / Failed / Skipped / Total] 371 / 441 / 10 / 822:  82%|████████▏ | 823/1000 [2:09:05<27:45,  9.41s/it][Succeeded / Failed / Skipped / Total] 371 / 441 / 11 / 823:  82%|████████▏ | 823/1000 [2:09:05<27:45,  9.41s/it][Succeeded / Failed / Skipped / Total] 371 / 441 / 11 / 823:  82%|████████▏ | 824/1000 [2:09:07<27:34,  9.40s/it][Succeeded / Failed / Skipped / Total] 371 / 442 / 11 / 824:  82%|████████▏ | 824/1000 [2:09:07<27:34,  9.40s/it][Succeeded / Failed / Skipped / Total] 371 / 442 / 11 / 824:  82%|████████▎ | 825/1000 [2:09:43<27:30,  9.43s/it][Succeeded / Failed / Skipped / Total] 371 / 443 / 11 / 825:  82%|████████▎ | 825/1000 [2:09:43<27:30,  9.43s/it][Succeeded / Failed / Skipped / Total] 371 / 443 / 11 / 825:  83%|████████▎ | 826/1000 [2:09:57<27:22,  9.44s/it][Succeeded / Failed / Skipped / Total] 371 / 444 / 11 / 826:  83%|████████▎ | 826/1000 [2:09:57<27:22,  9.44s/it][Succeeded / Failed / Skipped / Total] 371 / 444 / 11 / 826:  83%|████████▎ | 827/1000 [2:10:15<27:14,  9.45s/it]Hash a password with a salt . --> [[[FAILED]]]

[[[[Adv]]]]: public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 820 ---------------------------------------------
Returns true if the password of the plaintext matches the hashed password . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 821 ---------------------------------------------
Resolve the action config . --> [[[FAILED]]]

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues [[annotationValues]] ) { final Class < ? extends Annotation > [[annotationType]] ; if ( [[annotationValues]] == null ) { [[annotationType]] = Action . class ; } else { [[annotationType]] = [[annotationValues]] . annotationType ( ) ; } return actionConfigManager . lookup ( [[annotationType]] ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[sketching]] ( final ActionAnnotationValues [[cheung]] ) { final Class < ? extends Annotation > [[rotations]] ; if ( [[cheung]] == null ) { [[rotations]] = Action . class ; } else { [[rotations]] = [[cheung]] . annotationType ( ) ; } return actionConfigManager . lookup ( [[rotations]] ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 822 ---------------------------------------------
Parse an action definition . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 823 ---------------------------------------------
This method is called before the response is committed . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 824 ---------------------------------------------
Copy all bytes from the stream to the given output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 825 ---------------------------------------------
Read action interceptors . --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[maricón]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 826 ---------------------------------------------
Apply advice . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
[Succeeded / Failed / Skipped / Total] 371 / 445 / 11 / 827:  83%|████████▎ | 827/1000 [2:10:15<27:14,  9.45s/it][Succeeded / Failed / Skipped / Total] 371 / 445 / 11 / 827:  83%|████████▎ | 828/1000 [2:10:25<27:05,  9.45s/it][Succeeded / Failed / Skipped / Total] 371 / 446 / 11 / 828:  83%|████████▎ | 828/1000 [2:10:25<27:05,  9.45s/it][Succeeded / Failed / Skipped / Total] 371 / 446 / 11 / 828:  83%|████████▎ | 829/1000 [2:10:33<26:55,  9.45s/it][Succeeded / Failed / Skipped / Total] 371 / 447 / 11 / 829:  83%|████████▎ | 829/1000 [2:10:33<26:55,  9.45s/it][Succeeded / Failed / Skipped / Total] 371 / 447 / 11 / 829:  83%|████████▎ | 830/1000 [2:10:36<26:45,  9.44s/it][Succeeded / Failed / Skipped / Total] 372 / 447 / 11 / 830:  83%|████████▎ | 830/1000 [2:10:36<26:45,  9.44s/it][Succeeded / Failed / Skipped / Total] 372 / 447 / 11 / 830:  83%|████████▎ | 831/1000 [2:10:38<26:34,  9.43s/it][Succeeded / Failed / Skipped / Total] 372 / 448 / 11 / 831:  83%|████████▎ | 831/1000 [2:10:38<26:34,  9.43s/it][Succeeded / Failed / Skipped / Total] 372 / 448 / 11 / 831:  83%|████████▎ | 832/1000 [2:10:40<26:23,  9.42s/it][Succeeded / Failed / Skipped / Total] 373 / 448 / 11 / 832:  83%|████████▎ | 832/1000 [2:10:40<26:23,  9.42s/it][Succeeded / Failed / Skipped / Total] 373 / 448 / 11 / 832:  83%|████████▎ | 833/1000 [2:11:08<26:17,  9.45s/it][Succeeded / Failed / Skipped / Total] 373 / 449 / 11 / 833:  83%|████████▎ | 833/1000 [2:11:08<26:17,  9.45s/it][Succeeded / Failed / Skipped / Total] 374 / 449 / 11 / 834:  83%|████████▎ | 834/1000 [2:11:08<26:06,  9.44s/it][Succeeded / Failed / Skipped / Total] 374 / 449 / 11 / 834:  84%|████████▎ | 835/1000 [2:11:44<26:01,  9.47s/it]--------------------------------------------- Result 827 ---------------------------------------------
Parse method alias . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues [[annotationValues]] ) { String [[alias]] = null ; if ( [[annotationValues]] != null ) { [[alias]] = [[annotationValues]] . alias ( ) ; } return [[alias]] ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[eccentricity]] ( final ActionAnnotationValues [[christophe]] ) { String [[blackthorne]] = null ; if ( [[christophe]] != null ) { [[blackthorne]] = [[christophe]] . alias ( ) ; } return [[blackthorne]] ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 828 ---------------------------------------------
Read package action path . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[sanitorium]] ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 829 ---------------------------------------------
Creates an action runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 830 ---------------------------------------------
Visit an annotation . --> Liefert die valenzuela --> Socre: 1.0

[[[[Adv]]]]: public AnnotationVisitor visitAnnotation ( final String [[descriptor]] , final boolean [[visible]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , [[visible]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor visitAnnotation ( final String [[valenzuela]] , final boolean [[orbiting]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[valenzuela]] , [[orbiting]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 831 ---------------------------------------------
Read the action filters . --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] [[result]] = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { [[result]] = filteredBy . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[mcgonagall]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] [[bauer]] = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { [[bauer]] = filteredBy . value ( ) ; if ( [[bauer]] . length == 0 ) { [[bauer]] = null ; } } return [[bauer]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 832 ---------------------------------------------
Read method action path . --> Given a photography and a list of spitballs and hominids return an array of spitballs and hominids --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String [[methodName]] , final ActionAnnotationValues [[annotationValues]] , final ActionConfig [[actionConfig]] ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[aby]] ( final String [[photography]] , final ActionAnnotationValues [[spitballs]] , final ActionConfig [[hominids]] ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 833 ---------------------------------------------
Inject target into proxy . --> [[[FAILED]]]

[[[[Adv]]]]: public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 834 ---------------------------------------------
Returns the real name for the given JSON name . --> Return the top level of aone --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String [[jsonName]] ) { if ( jsonNames == null ) { return [[jsonName]] ; } int [[jsonIndex]] = ArraysUtil . indexOf ( jsonNames , [[jsonName]] ) ; if ( [[jsonIndex]] == - 1 ) { return [[jsonName]] ; } return realNames [ [[jsonIndex]] ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[top]] ( final String [[aone]] ) { if ( jsonNames == null ) { return [[aone]] ; } int [[lawsuit]] = ArraysUtil . indexOf ( jsonNames , [[aone]] ) ; if ( [[lawsuit]] == - 1 ) { return [[aone]] ; } return realNames [ [[lawsuit]] ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 835 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 375 / 449 / 11 / 835:  84%|████████▎ | 835/1000 [2:11:44<26:01,  9.47s/it][Succeeded / Failed / Skipped / Total] 375 / 449 / 11 / 835:  84%|████████▎ | 836/1000 [2:11:45<25:50,  9.46s/it][Succeeded / Failed / Skipped / Total] 375 / 450 / 11 / 836:  84%|████████▎ | 836/1000 [2:11:45<25:50,  9.46s/it][Succeeded / Failed / Skipped / Total] 375 / 450 / 11 / 836:  84%|████████▎ | 837/1000 [2:12:07<25:43,  9.47s/it][Succeeded / Failed / Skipped / Total] 375 / 451 / 11 / 837:  84%|████████▎ | 837/1000 [2:12:07<25:43,  9.47s/it][Succeeded / Failed / Skipped / Total] 375 / 451 / 11 / 837:  84%|████████▍ | 838/1000 [2:12:13<25:33,  9.47s/it][Succeeded / Failed / Skipped / Total] 376 / 451 / 11 / 838:  84%|████████▍ | 838/1000 [2:12:13<25:33,  9.47s/it][Succeeded / Failed / Skipped / Total] 376 / 451 / 11 / 838:  84%|████████▍ | 839/1000 [2:12:19<25:23,  9.46s/it][Succeeded / Failed / Skipped / Total] 376 / 452 / 11 / 839:  84%|████████▍ | 839/1000 [2:12:19<25:23,  9.46s/it][Succeeded / Failed / Skipped / Total] 376 / 452 / 11 / 839:  84%|████████▍ | 840/1000 [2:12:48<25:17,  9.49s/it][Succeeded / Failed / Skipped / Total] 376 / 453 / 11 / 840:  84%|████████▍ | 840/1000 [2:12:48<25:17,  9.49s/it][Succeeded / Failed / Skipped / Total] 376 / 453 / 11 / 840:  84%|████████▍ | 841/1000 [2:12:53<25:07,  9.48s/it][Succeeded / Failed / Skipped / Total] 377 / 453 / 11 / 841:  84%|████████▍ | 841/1000 [2:12:53<25:07,  9.48s/it][Succeeded / Failed / Skipped / Total] 377 / 453 / 11 / 841:  84%|████████▍ | 842/1000 [2:12:54<24:56,  9.47s/it][Succeeded / Failed / Skipped / Total] 377 / 454 / 11 / 842:  84%|████████▍ | 842/1000 [2:12:54<24:56,  9.47s/it][Succeeded / Failed / Skipped / Total] 377 / 454 / 11 / 842:  84%|████████▍ | 843/1000 [2:13:01<24:46,  9.47s/it][Succeeded / Failed / Skipped / Total] 377 / 455 / 11 / 843:  84%|████████▍ | 843/1000 [2:13:01<24:46,  9.47s/it][Succeeded / Failed / Skipped / Total] 377 / 455 / 11 / 843:  84%|████████▍ | 844/1000 [2:13:10<24:36,  9.47s/it]Resolve a JSON name . --> zinc returns unfulfilled or unfulfilled --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String [[realName]] ) { if ( realNames == null ) { return [[realName]] ; } int realIndex = ArraysUtil . indexOf ( realNames , [[realName]] ) ; if ( realIndex == - 1 ) { return [[realName]] ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[zinc]] ( final String [[unfulfilled]] ) { if ( realNames == null ) { return [[unfulfilled]] ; } int realIndex = ArraysUtil . indexOf ( realNames , [[unfulfilled]] ) ; if ( realIndex == - 1 ) { return [[unfulfilled]] ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 836 ---------------------------------------------
Returns the content of the file . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[catriona]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 837 ---------------------------------------------
Lookup the type data for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: protected TypeData [[_lookupTypeData]] ( final Class [[type]] ) { TypeData typeData = typeDataMap . get ( [[type]] ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData [[kalinga]] ( final Class [[champaign]] ) { TypeData typeData = typeDataMap . get ( [[champaign]] ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( [[champaign]] ) ; typeDataMap . put ( [[champaign]] , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 838 ---------------------------------------------
Find the subtype type data . --> zat a bloodsucking class --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class [[type]] ) { final Class < ? extends Annotation > [[defaultAnnotation]] = jsonAnnotation ; if ( [[type]] . getAnnotation ( [[defaultAnnotation]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[zat]] ( final Class [[bloodsucking]] ) { final Class < ? extends Annotation > [[pitchfork]] = jsonAnnotation ; if ( [[bloodsucking]] . getAnnotation ( [[pitchfork]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 839 ---------------------------------------------
Looks up the type data for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public TypeData [[lookupTypeData]] ( final Class [[type]] ) { TypeData typeData = typeDataMap . get ( [[type]] ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( [[type]] ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData [[fiancées]] ( final Class [[dago]] ) { TypeData typeData = typeDataMap . get ( [[dago]] ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( [[dago]] ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( [[dago]] ) ; typeDataMap . put ( [[dago]] , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 840 ---------------------------------------------
Copy bootstrap methods . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[blaney]] ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 841 ---------------------------------------------
Adds a method reference to a constant . --> Arakawa arakawa --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodref]] ( final String owner , final String [[name]] , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , [[name]] , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[arakawa]] ( final String owner , final String [[antidepressants]] , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , [[antidepressants]] , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 842 ---------------------------------------------
Puts the constant pool into the given byte vector . --> [[[FAILED]]]

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[gravity]] ( final ByteVector [[dimmer]] ) { [[dimmer]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 843 ---------------------------------------------
Resolve a JSON name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class [[type]] , final String [[name]] ) { TypeData typeData = lookupTypeData ( [[type]] ) ; return typeData . resolveJsonName ( [[name]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[ferrara]] ( final Class [[summer]] , final String [[gardenia]] ) { TypeData typeData = lookupTypeData ( [[summer]] ) ; return typeData . resolveJsonName ( [[gardenia]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 844 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 377 / 456 / 11 / 844:  84%|████████▍ | 844/1000 [2:13:10<24:36,  9.47s/it][Succeeded / Failed / Skipped / Total] 377 / 456 / 11 / 844:  84%|████████▍ | 845/1000 [2:13:17<24:27,  9.46s/it][Succeeded / Failed / Skipped / Total] 377 / 457 / 11 / 845:  84%|████████▍ | 845/1000 [2:13:17<24:27,  9.46s/it][Succeeded / Failed / Skipped / Total] 377 / 457 / 11 / 845:  85%|████████▍ | 846/1000 [2:13:57<24:23,  9.50s/it][Succeeded / Failed / Skipped / Total] 378 / 457 / 11 / 846:  85%|████████▍ | 846/1000 [2:13:57<24:23,  9.50s/it][Succeeded / Failed / Skipped / Total] 378 / 457 / 11 / 846:  85%|████████▍ | 847/1000 [2:14:12<24:14,  9.51s/it][Succeeded / Failed / Skipped / Total] 378 / 458 / 11 / 847:  85%|████████▍ | 847/1000 [2:14:12<24:14,  9.51s/it][Succeeded / Failed / Skipped / Total] 378 / 458 / 11 / 847:  85%|████████▍ | 848/1000 [2:14:52<24:10,  9.54s/it][Succeeded / Failed / Skipped / Total] 378 / 459 / 11 / 848:  85%|████████▍ | 848/1000 [2:14:52<24:10,  9.54s/it][Succeeded / Failed / Skipped / Total] 378 / 459 / 11 / 848:  85%|████████▍ | 849/1000 [2:15:02<24:01,  9.54s/it][Succeeded / Failed / Skipped / Total] 378 / 460 / 11 / 849:  85%|████████▍ | 849/1000 [2:15:02<24:01,  9.54s/it][Succeeded / Failed / Skipped / Total] 378 / 460 / 11 / 849:  85%|████████▌ | 850/1000 [2:15:12<23:51,  9.54s/it][Succeeded / Failed / Skipped / Total] 378 / 461 / 11 / 850:  85%|████████▌ | 850/1000 [2:15:12<23:51,  9.54s/it][Succeeded / Failed / Skipped / Total] 378 / 461 / 11 / 850:  85%|████████▌ | 851/1000 [2:15:15<23:40,  9.54s/it]Puts the bootstrap methods . --> [[[FAILED]]]

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector [[output]] ) { if ( bootstrapMethods != null ) { [[output]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[antigone]] ( final ByteVector [[allelujah]] ) { if ( bootstrapMethods != null ) { [[allelujah]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 845 ---------------------------------------------
Resolve a real name for a given type . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class [[type]] , final String [[jsonName]] ) { TypeData [[typeData]] = lookupTypeData ( [[type]] ) ; return [[typeData]] . resolveRealName ( [[jsonName]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[scoured]] ( final Class [[chatty]] , final String [[shortcoming]] ) { TypeData [[endives]] = lookupTypeData ( [[chatty]] ) ; return [[endives]] . resolveRealName ( [[shortcoming]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 846 ---------------------------------------------
Adds a field reference to a constant . --> Juxtaposition chap fizzy --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String [[owner]] , final String [[name]] , final String [[descriptor]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[owner]] , [[name]] , [[descriptor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[interceptor]] ( final String [[juxtaposition]] , final String [[chap]] , final String [[fizzy]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[juxtaposition]] , [[chap]] , [[fizzy]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 847 ---------------------------------------------
Sets the major version and class name . --> [[[FAILED]]]

[[[[Adv]]]]: int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 848 ---------------------------------------------
Adds a member reference to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 849 ---------------------------------------------
Adds a constant member reference . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String [[descriptor]] ) { add ( new Entry ( index , tag , owner , name , [[descriptor]] , 0 , hash ( tag , owner , name , [[descriptor]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String [[summer]] ) { add ( new Entry ( index , tag , owner , name , [[summer]] , 0 , hash ( tag , owner , name , [[summer]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a constant integer or float to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int index , final int [[tag]] , final int value ) { add ( new Entry ( index , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[abut]] ( final int index , final int [[fizzy]] , final int value ) { add ( new Entry ( index , [[fizzy]] , value , hash ( [[fizzy]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 851 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 462 / 11 / 851:  85%|████████▌ | 851/1000 [2:15:15<23:40,  9.54s/it][Succeeded / Failed / Skipped / Total] 378 / 462 / 11 / 851:  85%|████████▌ | 852/1000 [2:15:23<23:31,  9.53s/it][Succeeded / Failed / Skipped / Total] 378 / 463 / 11 / 852:  85%|████████▌ | 852/1000 [2:15:23<23:31,  9.53s/it][Succeeded / Failed / Skipped / Total] 378 / 463 / 11 / 852:  85%|████████▌ | 853/1000 [2:15:24<23:20,  9.52s/it][Succeeded / Failed / Skipped / Total] 378 / 464 / 11 / 853:  85%|████████▌ | 853/1000 [2:15:24<23:20,  9.52s/it][Succeeded / Failed / Skipped / Total] 378 / 464 / 11 / 853:  85%|████████▌ | 854/1000 [2:16:12<23:17,  9.57s/it][Succeeded / Failed / Skipped / Total] 378 / 465 / 11 / 854:  85%|████████▌ | 854/1000 [2:16:12<23:17,  9.57s/it][Succeeded / Failed / Skipped / Total] 378 / 465 / 11 / 854:  86%|████████▌ | 855/1000 [2:16:32<23:09,  9.58s/it][Succeeded / Failed / Skipped / Total] 378 / 466 / 11 / 855:  86%|████████▌ | 855/1000 [2:16:32<23:09,  9.58s/it][Succeeded / Failed / Skipped / Total] 378 / 466 / 11 / 855:  86%|████████▌ | 856/1000 [2:16:53<23:01,  9.59s/it][Succeeded / Failed / Skipped / Total] 378 / 467 / 11 / 856:  86%|████████▌ | 856/1000 [2:16:53<23:01,  9.59s/it][Succeeded / Failed / Skipped / Total] 378 / 467 / 11 / 856:  86%|████████▌ | 857/1000 [2:16:54<22:50,  9.59s/it]Add a constant long or double to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long [[value]] ) { int hashCode = hash ( tag , [[value]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == [[value]] ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( [[value]] ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , [[value]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long [[ballers]] ) { int hashCode = hash ( tag , [[ballers]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == [[ballers]] ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( [[ballers]] ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , [[ballers]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 852 ---------------------------------------------
Adds an integer or float constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a constant long or double to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int index , final int [[tag]] , final long value ) { add ( new Entry ( index , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[juxtaposition]] ( final int index , final int [[hoagie]] , final long value ) { add ( new Entry ( index , [[hoagie]] , value , hash ( [[hoagie]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a constant name and type . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 855 ---------------------------------------------
Adds a constant name and type to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 856 ---------------------------------------------
Adds a UTF - 8 constant to the symbol table . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int [[index]] , final String [[value]] ) { add ( new Entry ( [[index]] , Symbol . CONSTANT_UTF8_TAG , [[value]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[rackham]] ( final int [[marbella]] , final String [[woozy]] ) { add ( new Entry ( [[marbella]] , Symbol . CONSTANT_UTF8_TAG , [[woozy]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[woozy]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 857 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 468 / 11 / 857:  86%|████████▌ | 857/1000 [2:16:54<22:50,  9.59s/it][Succeeded / Failed / Skipped / Total] 378 / 468 / 11 / 857:  86%|████████▌ | 858/1000 [2:17:13<22:42,  9.60s/it][Succeeded / Failed / Skipped / Total] 378 / 469 / 11 / 858:  86%|████████▌ | 858/1000 [2:17:13<22:42,  9.60s/it][Succeeded / Failed / Skipped / Total] 378 / 469 / 11 / 858:  86%|████████▌ | 859/1000 [2:17:25<22:33,  9.60s/it][Succeeded / Failed / Skipped / Total] 378 / 470 / 11 / 859:  86%|████████▌ | 859/1000 [2:17:25<22:33,  9.60s/it][Succeeded / Failed / Skipped / Total] 378 / 470 / 11 / 859:  86%|████████▌ | 860/1000 [2:17:26<22:22,  9.59s/it][Succeeded / Failed / Skipped / Total] 378 / 471 / 11 / 860:  86%|████████▌ | 860/1000 [2:17:26<22:22,  9.59s/it][Succeeded / Failed / Skipped / Total] 378 / 471 / 11 / 860:  86%|████████▌ | 861/1000 [2:17:37<22:13,  9.59s/it][Succeeded / Failed / Skipped / Total] 379 / 471 / 11 / 861:  86%|████████▌ | 861/1000 [2:17:37<22:13,  9.59s/it][Succeeded / Failed / Skipped / Total] 379 / 471 / 11 / 861:  86%|████████▌ | 862/1000 [2:17:42<22:02,  9.59s/it][Succeeded / Failed / Skipped / Total] 379 / 472 / 11 / 862:  86%|████████▌ | 862/1000 [2:17:42<22:02,  9.59s/it][Succeeded / Failed / Skipped / Total] 379 / 472 / 11 / 862:  86%|████████▋ | 863/1000 [2:18:23<21:58,  9.62s/it]Adds a UTF8 constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: int [[addConstantUtf8]] ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == Symbol . CONSTANT_UTF8_TAG && [[entry]] . hashCode == hashCode && [[entry]] . value . equals ( value ) ) { return [[entry]] . index ; } [[entry]] = [[entry]] . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[yarmulke]] ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry [[bejesus]] = get ( hashCode ) ; while ( [[bejesus]] != null ) { if ( [[bejesus]] . tag == Symbol . CONSTANT_UTF8_TAG && [[bejesus]] . hashCode == hashCode && [[bejesus]] . value . equals ( value ) ) { return [[bejesus]] . index ; } [[bejesus]] = [[bejesus]] . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 858 ---------------------------------------------
Add a constant method handle . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a constant method handle . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantMethodHandle]] ( final int [[index]] , final int referenceKind , final String owner , final String name , final String descriptor ) { final int [[tag]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( [[tag]] , owner , name , descriptor , referenceKind ) ; add ( new Entry ( [[index]] , [[tag]] , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[prearranged]] ( final int [[dado]] , final int referenceKind , final String owner , final String name , final String descriptor ) { final int [[wimmer]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( [[wimmer]] , owner , name , descriptor , referenceKind ) ; add ( new Entry ( [[dado]] , [[wimmer]] , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 860 ---------------------------------------------
Adds a dynamic constant . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 861 ---------------------------------------------
Returns the hash code of the given name . --> ziva - ziva - ziva --> Socre: 1.0

[[[[Adv]]]]: private int [[hash]] ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int [[ziva]] ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 862 ---------------------------------------------
Adds a constant invoke dynamic . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 863 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 380 / 472 / 11 / 863:  86%|████████▋ | 863/1000 [2:18:23<21:58,  9.62s/it][Succeeded / Failed / Skipped / Total] 380 / 472 / 11 / 863:  86%|████████▋ | 864/1000 [2:18:25<21:47,  9.61s/it][Succeeded / Failed / Skipped / Total] 380 / 473 / 11 / 864:  86%|████████▋ | 864/1000 [2:18:25<21:47,  9.61s/it][Succeeded / Failed / Skipped / Total] 380 / 473 / 11 / 864:  86%|████████▋ | 865/1000 [2:18:50<21:40,  9.63s/it][Succeeded / Failed / Skipped / Total] 380 / 474 / 11 / 865:  86%|████████▋ | 865/1000 [2:18:50<21:40,  9.63s/it][Succeeded / Failed / Skipped / Total] 380 / 474 / 11 / 865:  87%|████████▋ | 866/1000 [2:18:53<21:29,  9.62s/it][Succeeded / Failed / Skipped / Total] 380 / 475 / 11 / 866:  87%|████████▋ | 866/1000 [2:18:53<21:29,  9.62s/it][Succeeded / Failed / Skipped / Total] 380 / 475 / 11 / 866:  87%|████████▋ | 867/1000 [2:19:08<21:20,  9.63s/it][Succeeded / Failed / Skipped / Total] 380 / 476 / 11 / 867:  87%|████████▋ | 867/1000 [2:19:08<21:20,  9.63s/it][Succeeded / Failed / Skipped / Total] 380 / 476 / 11 / 867:  87%|████████▋ | 868/1000 [2:19:21<21:11,  9.63s/it][Succeeded / Failed / Skipped / Total] 381 / 476 / 11 / 868:  87%|████████▋ | 868/1000 [2:19:21<21:11,  9.63s/it][Succeeded / Failed / Skipped / Total] 381 / 476 / 11 / 868:  87%|████████▋ | 869/1000 [2:19:45<21:04,  9.65s/it][Succeeded / Failed / Skipped / Total] 381 / 477 / 11 / 869:  87%|████████▋ | 869/1000 [2:19:45<21:04,  9.65s/it][Succeeded / Failed / Skipped / Total] 381 / 477 / 11 / 869:  87%|████████▋ | 870/1000 [2:19:51<20:53,  9.65s/it]Adds a constant UTF - 8 reference . --> Aaaahhhh aaaahhhh aaaahhhh --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8Reference]] ( final int index , final int [[tag]] , final String [[value]] ) { add ( new Entry ( index , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[aaaahhhh]] ( final int index , final int [[freddie]] , final String [[expunge]] ) { add ( new Entry ( index , [[freddie]] , [[expunge]] , hash ( [[freddie]] , [[expunge]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 864 ---------------------------------------------
Add a constant or invoke a dynamic reference . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 865 ---------------------------------------------
Adds a constant constant or invoke a dynamic reference . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 866 ---------------------------------------------
Removes all entries from this MultiMap . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpMultiMap < V > [[clear]] ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > [[ashley]] ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 867 ---------------------------------------------
Adds a constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 868 ---------------------------------------------
Adds a type to the merged type table . --> plaît tortoise tortoise tortoise --> Socre: 1.0

[[[[Adv]]]]: int [[addMergedType]] ( final int [[typeTableIndex1]] , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int [[plaît]] ( final int [[tortoise]] , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 869 ---------------------------------------------
Adds a bootstrap method . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[civitavecchia]] ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 870 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 382 / 477 / 11 / 870:  87%|████████▋ | 870/1000 [2:19:51<20:53,  9.65s/it][Succeeded / Failed / Skipped / Total] 382 / 477 / 11 / 870:  87%|████████▋ | 871/1000 [2:20:08<20:45,  9.65s/it][Succeeded / Failed / Skipped / Total] 383 / 477 / 11 / 871:  87%|████████▋ | 871/1000 [2:20:08<20:45,  9.65s/it][Succeeded / Failed / Skipped / Total] 383 / 477 / 11 / 871:  87%|████████▋ | 872/1000 [2:20:08<20:34,  9.64s/it][Succeeded / Failed / Skipped / Total] 383 / 478 / 11 / 872:  87%|████████▋ | 872/1000 [2:20:08<20:34,  9.64s/it][Succeeded / Failed / Skipped / Total] 383 / 478 / 11 / 872:  87%|████████▋ | 873/1000 [2:20:11<20:23,  9.64s/it][Succeeded / Failed / Skipped / Total] 383 / 479 / 11 / 873:  87%|████████▋ | 873/1000 [2:20:11<20:23,  9.64s/it][Succeeded / Failed / Skipped / Total] 383 / 479 / 11 / 873:  87%|████████▋ | 874/1000 [2:20:12<20:12,  9.63s/it][Succeeded / Failed / Skipped / Total] 384 / 479 / 11 / 874:  87%|████████▋ | 874/1000 [2:20:12<20:12,  9.63s/it][Succeeded / Failed / Skipped / Total] 384 / 479 / 11 / 874:  88%|████████▊ | 875/1000 [2:20:20<20:02,  9.62s/it][Succeeded / Failed / Skipped / Total] 384 / 480 / 11 / 875:  88%|████████▊ | 875/1000 [2:20:20<20:02,  9.62s/it][Succeeded / Failed / Skipped / Total] 384 / 480 / 11 / 875:  88%|████████▊ | 876/1000 [2:20:21<19:52,  9.61s/it][Succeeded / Failed / Skipped / Total] 385 / 480 / 11 / 876:  88%|████████▊ | 876/1000 [2:20:21<19:52,  9.61s/it][Succeeded / Failed / Skipped / Total] 385 / 480 / 11 / 876:  88%|████████▊ | 877/1000 [2:20:22<19:41,  9.60s/it][Succeeded / Failed / Skipped / Total] 386 / 480 / 11 / 877:  88%|████████▊ | 877/1000 [2:20:22<19:41,  9.60s/it][Succeeded / Failed / Skipped / Total] 386 / 480 / 11 / 877:  88%|████████▊ | 878/1000 [2:20:30<19:31,  9.60s/it][Succeeded / Failed / Skipped / Total] 387 / 480 / 11 / 878:  88%|████████▊ | 878/1000 [2:20:30<19:31,  9.60s/it][Succeeded / Failed / Skipped / Total] 387 / 480 / 11 / 878:  88%|████████▊ | 879/1000 [2:21:10<19:26,  9.64s/it]Create the first chain delegate . --> zinc zinc zinc zinc zinc zinc zinc zinc zinc zinc zinc zinc --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[zinc]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 871 ---------------------------------------------
implements the visitor to visit an annotation . --> Visit a moistened annotation --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor [[visitAnnotation]] ( final String [[desc]] , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( [[desc]] , visible ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor [[isengard]] ( final String [[moistened]] , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( [[moistened]] , visible ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 872 ---------------------------------------------
Returns a list of all values with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 873 ---------------------------------------------
Returns a list of all entries in this map . --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > [[all]] = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { [[all]] . add ( e ) ; e = e . after ; } return [[all]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[benghazi]] ( ) { List < Map . Entry < String , V > > [[feedbag]] = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { [[feedbag]] . add ( e ) ; e = e . after ; } return [[feedbag]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 874 ---------------------------------------------
implements the visitor to create the proxy methods . --> jeśli restarts --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[visitEnd]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void [[restarts]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[jeanie]] = 0 ; [[jeanie]] < tmd . proxyData . length ; [[jeanie]] ++ ) { tmd . selectCurrentProxy ( [[jeanie]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 875 ---------------------------------------------
Returns an iterator over the entries in this map . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[iterator]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[next]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[next]] = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return [[next]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[pinback]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[anchorage]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[anchorage]] = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return [[anchorage]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 876 ---------------------------------------------
Grows the buffer by a given capacity . --> If blended capacity is less than old capacity then blended capacity is less than old capacity --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int [[minCapacity]] ) { final int oldCapacity = buffer . length ; int [[newCapacity]] = oldCapacity << 1 ; if ( [[newCapacity]] - [[minCapacity]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[orbiting]] ( final int [[blended]] ) { final int oldCapacity = buffer . length ; int [[customer]] = oldCapacity << 1 ; if ( [[customer]] - [[blended]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 877 ---------------------------------------------
Append a sequence of characters to the buffer . --> Noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer [[append]] ( final CharSequence csq , final int start , final int end ) { for ( int [[i]] = start ; [[i]] < end ; [[i]] ++ ) { [[append]] ( csq . charAt ( [[i]] ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer [[noooooo]] ( final CharSequence csq , final int start , final int end ) { for ( int [[closest]] = start ; [[closest]] < end ; [[closest]] ++ ) { [[noooooo]] ( csq . charAt ( [[closest]] ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 878 ---------------------------------------------
Parse a path . --> convert azzam to azzam --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[azzam]] ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 879 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 387 / 481 / 11 / 879:  88%|████████▊ | 879/1000 [2:21:10<19:26,  9.64s/it][Succeeded / Failed / Skipped / Total] 387 / 481 / 11 / 879:  88%|████████▊ | 880/1000 [2:21:22<19:16,  9.64s/it][Succeeded / Failed / Skipped / Total] 387 / 482 / 11 / 880:  88%|████████▊ | 880/1000 [2:21:22<19:16,  9.64s/it][Succeeded / Failed / Skipped / Total] 387 / 482 / 11 / 880:  88%|████████▊ | 881/1000 [2:21:38<19:07,  9.65s/it][Succeeded / Failed / Skipped / Total] 388 / 482 / 11 / 881:  88%|████████▊ | 881/1000 [2:21:38<19:07,  9.65s/it][Succeeded / Failed / Skipped / Total] 388 / 482 / 11 / 881:  88%|████████▊ | 882/1000 [2:21:39<18:57,  9.64s/it][Succeeded / Failed / Skipped / Total] 389 / 482 / 11 / 882:  88%|████████▊ | 882/1000 [2:21:39<18:57,  9.64s/it][Succeeded / Failed / Skipped / Total] 389 / 482 / 11 / 882:  88%|████████▊ | 883/1000 [2:21:56<18:48,  9.64s/it][Succeeded / Failed / Skipped / Total] 390 / 482 / 11 / 883:  88%|████████▊ | 883/1000 [2:21:56<18:48,  9.64s/it][Succeeded / Failed / Skipped / Total] 390 / 482 / 11 / 883:  88%|████████▊ | 884/1000 [2:22:08<18:39,  9.65s/it]Adds a field to the path . --> [[[FAILED]]]

[[[[Adv]]]]: public Path [[push]] ( final CharSequence [[field]] ) { _push ( [[field]] ) ; if ( altPath != null ) { altPath . push ( [[field]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[eminently]] ( final CharSequence [[indirectly]] ) { _push ( [[indirectly]] ) ; if ( altPath != null ) { altPath . push ( [[indirectly]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 880 ---------------------------------------------
Create the method for the first chain delegate . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData [[tmd]] ) { methodVisitor . visitCode ( ) ; if ( [[tmd]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[tmd]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[peekaboo]] ( final TargetMethodData [[performs]] ) { methodVisitor . visitCode ( ) ; if ( [[performs]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[performs]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[performs]] . firstMethodName ( ) , [[performs]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[performs]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[performs]] . firstMethodName ( ) , [[performs]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[performs]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 881 ---------------------------------------------
Converts a JtxTransactionMode to a DbTransactionMode . --> Create a warmed DbTransactionMode from a JtxTransactionMode --> Socre: 1.0

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode [[txMode]] ) { final int isolation ; switch ( [[txMode]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , [[txMode]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[warmed]] ( final JtxTransactionMode [[bilbo]] ) { final int isolation ; switch ( [[bilbo]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , [[bilbo]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 882 ---------------------------------------------
Adds all entries from the given map to this map . --> Methode als erzurumu --> Socre: 1.0

[[[[Adv]]]]: @ Override public void putAll ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry [[e]] = ( Map . Entry ) o ; put ( [[e]] . getKey ( ) , [[e]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void putAll ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry [[erzurum]] = ( Map . Entry ) o ; put ( [[erzurum]] . getKey ( ) , [[erzurum]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 883 ---------------------------------------------
Returns an array of all field descriptors . --> Method to get the crazies --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor [ ] [[getAllFieldDescriptors]] ( ) { if ( [[allFields]] == null ) { FieldDescriptor [ ] [[allFields]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[index]] = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { [[allFields]] [ [[index]] ] = fieldDescriptor ; [[index]] ++ ; } Arrays . sort ( [[allFields]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[allFields]] = [[allFields]] ; } return [[allFields]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] [[crazies]] ( ) { if ( [[campaigned]] == null ) { FieldDescriptor [ ] [[campaigned]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[jumpsuit]] = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { [[campaigned]] [ [[jumpsuit]] ] = fieldDescriptor ; [[jumpsuit]] ++ ; } Arrays . sort ( [[campaigned]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[mamacita]] = [[campaigned]] ; } return [[campaigned]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 884 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 390 / 483 / 11 / 884:  88%|████████▊ | 884/1000 [2:22:08<18:39,  9.65s/it][Succeeded / Failed / Skipped / Total] 390 / 483 / 11 / 884:  88%|████████▊ | 885/1000 [2:22:10<18:28,  9.64s/it][Succeeded / Failed / Skipped / Total] 390 / 484 / 11 / 885:  88%|████████▊ | 885/1000 [2:22:10<18:28,  9.64s/it][Succeeded / Failed / Skipped / Total] 391 / 484 / 11 / 886:  89%|████████▊ | 886/1000 [2:22:10<18:17,  9.63s/it][Succeeded / Failed / Skipped / Total] 391 / 484 / 11 / 886:  89%|████████▊ | 887/1000 [2:22:21<18:08,  9.63s/it][Succeeded / Failed / Skipped / Total] 391 / 485 / 11 / 887:  89%|████████▊ | 887/1000 [2:22:21<18:08,  9.63s/it][Succeeded / Failed / Skipped / Total] 391 / 485 / 11 / 887:  89%|████████▉ | 888/1000 [2:22:40<17:59,  9.64s/it][Succeeded / Failed / Skipped / Total] 391 / 486 / 11 / 888:  89%|████████▉ | 888/1000 [2:22:40<17:59,  9.64s/it][Succeeded / Failed / Skipped / Total] 391 / 486 / 11 / 888:  89%|████████▉ | 889/1000 [2:23:17<17:53,  9.67s/it][Succeeded / Failed / Skipped / Total] 392 / 486 / 11 / 889:  89%|████████▉ | 889/1000 [2:23:17<17:53,  9.67s/it][Succeeded / Failed / Skipped / Total] 392 / 486 / 11 / 889:  89%|████████▉ | 890/1000 [2:23:24<17:43,  9.67s/it][Succeeded / Failed / Skipped / Total] 393 / 486 / 11 / 890:  89%|████████▉ | 890/1000 [2:23:24<17:43,  9.67s/it][Succeeded / Failed / Skipped / Total] 393 / 486 / 11 / 890:  89%|████████▉ | 891/1000 [2:23:30<17:33,  9.66s/it]Configure servlet context . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext [[servletContext]] ) { [[servletContext]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration [[filter]] = [[servletContext]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; [[filter]] . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration [[filter]] = [[servletContext]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; [[filter]] . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[incensed]] ( final ServletContext [[descendants]] ) { [[descendants]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration [[socialists]] = [[descendants]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; [[socialists]] . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration [[socialists]] = [[descendants]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; [[socialists]] . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 885 ---------------------------------------------
Execute the method . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[execute]] ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object [[jaune]] ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 886 ---------------------------------------------
Append a buffer to the end of the list . --> ishtar ishtar ishtar --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[ishtar]] ( final Buffer [[scrape]] ) { if ( [[scrape]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 887 ---------------------------------------------
Creates a new bean definition for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 888 ---------------------------------------------
Read a property from the source object . --> [[[FAILED]]]

[[[[Adv]]]]: private Object [[readProperty]] ( final Object source , final PropertyDescriptor [[propertyDescriptor]] ) { Getter [[getter]] = [[propertyDescriptor]] . getGetter ( declared ) ; if ( [[getter]] != null ) { try { return [[getter]] . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[overlapped]] ( final Object source , final PropertyDescriptor [[eiger]] ) { Getter [[swimmer]] = [[eiger]] . getGetter ( declared ) ; if ( [[swimmer]] != null ) { try { return [[swimmer]] . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 889 ---------------------------------------------
Returns the value associated with the given key as a Double . --> Alegación alegación --> Socre: 1.0

[[[[Adv]]]]: public Double [[getDouble]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[alegria]] ( final String [[antarctica]] ) { Number number = ( Number ) map . get ( [[antarctica]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 890 ---------------------------------------------
Returns the value associated with the given key as a Long . --> Sacrilege als AKIRA --> Socre: 1.0

[[[[Adv]]]]: public Long [[getLong]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long [[sacrilege]] ( final String [[akira]] ) { Number number = ( Number ) map . get ( [[akira]] ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 891 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 394 / 486 / 11 / 891:  89%|████████▉ | 891/1000 [2:23:30<17:33,  9.66s/it][Succeeded / Failed / Skipped / Total] 394 / 486 / 11 / 891:  89%|████████▉ | 892/1000 [2:23:34<17:23,  9.66s/it][Succeeded / Failed / Skipped / Total] 394 / 487 / 11 / 892:  89%|████████▉ | 892/1000 [2:23:34<17:23,  9.66s/it][Succeeded / Failed / Skipped / Total] 394 / 487 / 11 / 892:  89%|████████▉ | 893/1000 [2:23:44<17:13,  9.66s/it][Succeeded / Failed / Skipped / Total] 394 / 488 / 11 / 893:  89%|████████▉ | 893/1000 [2:23:44<17:13,  9.66s/it][Succeeded / Failed / Skipped / Total] 394 / 488 / 11 / 893:  89%|████████▉ | 894/1000 [2:23:49<17:03,  9.65s/it][Succeeded / Failed / Skipped / Total] 394 / 489 / 11 / 894:  89%|████████▉ | 894/1000 [2:23:49<17:03,  9.65s/it][Succeeded / Failed / Skipped / Total] 394 / 489 / 11 / 894:  90%|████████▉ | 895/1000 [2:23:52<16:52,  9.65s/it][Succeeded / Failed / Skipped / Total] 394 / 490 / 11 / 895:  90%|████████▉ | 895/1000 [2:23:52<16:52,  9.65s/it][Succeeded / Failed / Skipped / Total] 394 / 490 / 11 / 895:  90%|████████▉ | 896/1000 [2:23:58<16:42,  9.64s/it][Succeeded / Failed / Skipped / Total] 394 / 491 / 11 / 896:  90%|████████▉ | 896/1000 [2:23:58<16:42,  9.64s/it][Succeeded / Failed / Skipped / Total] 394 / 491 / 11 / 896:  90%|████████▉ | 897/1000 [2:24:06<16:32,  9.64s/it][Succeeded / Failed / Skipped / Total] 395 / 491 / 11 / 897:  90%|████████▉ | 897/1000 [2:24:06<16:32,  9.64s/it][Succeeded / Failed / Skipped / Total] 395 / 491 / 11 / 897:  90%|████████▉ | 898/1000 [2:24:14<16:23,  9.64s/it]Returns the float value associated with the given key . --> Liefert die SqueegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegegeGeGeGeGeGeGeGeGeGeGeGeGeGeGegegegegegegegegegegegegegege --> Socre: 1.0

[[[[Adv]]]]: public Float [[getFloat]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float [[noelle]] ( final String [[squeegee]] ) { Number number = ( Number ) map . get ( [[squeegee]] ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 892 ---------------------------------------------
Writes the response to the given output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out , final HttpProgressListener [[progressListener]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[bodega]] ( final OutputStream out , final HttpProgressListener [[mané]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 893 ---------------------------------------------
Writes the contents of the list to the writer . --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final Writer [[writer]] ) throws IOException { for ( Object [[o]] : list ) { if ( [[o]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[o]] ; byte [ ] array = fastByteBuffer . toArray ( ) ; [[writer]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[o]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[o]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[writer]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void writeTo ( final Writer [[armada]] ) throws IOException { for ( Object [[reena]] : list ) { if ( [[reena]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[reena]] ; byte [ ] array = fastByteBuffer . toArray ( ) ; [[armada]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[reena]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[reena]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[armada]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 894 ---------------------------------------------
Returns the string value associated with the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getString]] ( final String key ) { CharSequence [[cs]] = ( CharSequence ) map . get ( key ) ; return [[cs]] == null ? null : [[cs]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[knickknacks]] ( final String key ) { CharSequence [[jackhammer]] = ( CharSequence ) map . get ( key ) ; return [[jackhammer]] == null ? null : [[jackhammer]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 895 ---------------------------------------------
Writes the list to an output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final OutputStream [[out]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[out]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[out]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void writeTo ( final OutputStream [[collaborator]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[collaborator]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[collaborator]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 896 ---------------------------------------------
Returns the Integer value associated with the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public Integer getInteger ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Integer ) { return ( Integer ) [[number]] ; } return [[number]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer getInteger ( final String [[tranquilo]] ) { Number [[bluer]] = ( Number ) map . get ( [[tranquilo]] ) ; if ( [[bluer]] == null ) { return null ; } if ( [[bluer]] instanceof Integer ) { return ( Integer ) [[bluer]] ; } return [[bluer]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 897 ---------------------------------------------
Use a folder . --> Use australia --> Socre: 1.0

[[[[Adv]]]]: public void useFolder ( final String [[folderName]] ) { closeFolderIfOpened ( folder ) ; try { this . [[folderName]] = [[folderName]] ; this . folder = getService ( ) . getFolder ( [[folderName]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[folderName]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void useFolder ( final String [[australia]] ) { closeFolderIfOpened ( folder ) ; try { this . [[jumpsuit]] = [[australia]] ; this . folder = getService ( ) . getFolder ( [[australia]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[australia]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 898 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 395 / 492 / 11 / 898:  90%|████████▉ | 898/1000 [2:24:14<16:23,  9.64s/it][Succeeded / Failed / Skipped / Total] 395 / 492 / 11 / 898:  90%|████████▉ | 899/1000 [2:24:33<16:14,  9.65s/it][Succeeded / Failed / Skipped / Total] 396 / 492 / 11 / 899:  90%|████████▉ | 899/1000 [2:24:33<16:14,  9.65s/it][Succeeded / Failed / Skipped / Total] 396 / 492 / 11 / 899:  90%|█████████ | 900/1000 [2:24:37<16:04,  9.64s/it][Succeeded / Failed / Skipped / Total] 397 / 492 / 11 / 900:  90%|█████████ | 900/1000 [2:24:37<16:04,  9.64s/it][Succeeded / Failed / Skipped / Total] 397 / 492 / 11 / 900:  90%|█████████ | 901/1000 [2:24:43<15:54,  9.64s/it][Succeeded / Failed / Skipped / Total] 398 / 492 / 11 / 901:  90%|█████████ | 901/1000 [2:24:43<15:54,  9.64s/it][Succeeded / Failed / Skipped / Total] 398 / 492 / 11 / 901:  90%|█████████ | 902/1000 [2:24:58<15:45,  9.64s/it][Succeeded / Failed / Skipped / Total] 398 / 493 / 11 / 902:  90%|█████████ | 902/1000 [2:24:58<15:45,  9.64s/it][Succeeded / Failed / Skipped / Total] 398 / 493 / 11 / 902:  90%|█████████ | 903/1000 [2:25:08<15:35,  9.64s/it][Succeeded / Failed / Skipped / Total] 398 / 494 / 11 / 903:  90%|█████████ | 903/1000 [2:25:08<15:35,  9.64s/it][Succeeded / Failed / Skipped / Total] 398 / 494 / 11 / 903:  90%|█████████ | 904/1000 [2:25:18<15:25,  9.64s/it][Succeeded / Failed / Skipped / Total] 398 / 495 / 11 / 904:  90%|█████████ | 904/1000 [2:25:18<15:25,  9.64s/it][Succeeded / Failed / Skipped / Total] 398 / 495 / 11 / 904:  90%|█████████ | 905/1000 [2:25:39<15:17,  9.66s/it][Succeeded / Failed / Skipped / Total] 398 / 496 / 11 / 905:  90%|█████████ | 905/1000 [2:25:39<15:17,  9.66s/it][Succeeded / Failed / Skipped / Total] 398 / 496 / 11 / 905:  91%|█████████ | 906/1000 [2:25:48<15:07,  9.66s/it]Returns the value for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] getValue ( final String key ) { [[T]] [[val]] = ( [[T]] ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( [[T]] ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( [[T]] ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[cachaça]] > [[cachaça]] getValue ( final String key ) { [[cachaça]] [[floodlight]] = ( [[cachaça]] ) map . get ( key ) ; if ( [[floodlight]] instanceof Map ) { return ( [[cachaça]] ) new JsonObject ( ( Map ) [[floodlight]] ) ; } if ( [[floodlight]] instanceof List ) { return ( [[cachaça]] ) new JsonArray ( ( List ) [[floodlight]] ) ; } return [[floodlight]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 899 ---------------------------------------------
Returns the alias for the given target . --> Concatenates the cherubs with the left and right cherubs --> Socre: 1.0

[[[[Adv]]]]: protected String [[alias]] ( final String [[target]] ) { return StringPool . LEFT_CHEV . concat ( [[target]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[sus]] ( final String [[cherubs]] ) { return StringPool . LEFT_CHEV . concat ( [[cherubs]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 900 ---------------------------------------------
Sets the mime type . --> Methode der Methode zurueck . --> Socre: 1.0

[[[[Adv]]]]: public RawData [[as]] ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData [[meerkat]] ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 901 ---------------------------------------------
Updates the flags for a received email . --> Create a clair for an inducement --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail [[receivedEmail]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[receivedEmail]] . messageNumber ( ) } , [[receivedEmail]] . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[clair]] ( final ReceivedEmail [[inducement]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[inducement]] . messageNumber ( ) } , [[inducement]] . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 902 ---------------------------------------------
Adds a key - value pair to the map . --> [[[FAILED]]]

[[[[Adv]]]]: public JsonObject [[put]] ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[shields]] ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 903 ---------------------------------------------
Close the folder if it is open . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[pamplona]] ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 904 ---------------------------------------------
Lookup a named parameter . --> [[[FAILED]]]

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( [[name]] ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[uniqueness]] ( final String [[cheapen]] ) { DbQueryNamedParameter [[modulation]] = rootNP ; while ( [[modulation]] != null ) { if ( [[modulation]] . equalsName ( [[cheapen]] ) ) { return [[modulation]] ; } [[modulation]] = [[modulation]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 905 ---------------------------------------------
Receives all messages matching the given filter . --> [[[FAILED]]]

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[filter]] , final Flags flagsToSet , final Flags [[flagsToUnset]] , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[filter]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[filter]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[beseeching]] , final Flags flagsToSet , final Flags [[campuses]] , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[beseeching]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[beseeching]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 906 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 399 / 496 / 11 / 906:  91%|█████████ | 906/1000 [2:25:48<15:07,  9.66s/it][Succeeded / Failed / Skipped / Total] 399 / 496 / 11 / 906:  91%|█████████ | 907/1000 [2:25:48<14:57,  9.65s/it][Succeeded / Failed / Skipped / Total] 399 / 497 / 11 / 907:  91%|█████████ | 907/1000 [2:25:48<14:57,  9.65s/it][Succeeded / Failed / Skipped / Total] 399 / 497 / 11 / 907:  91%|█████████ | 908/1000 [2:25:50<14:46,  9.64s/it][Succeeded / Failed / Skipped / Total] 399 / 498 / 11 / 908:  91%|█████████ | 908/1000 [2:25:50<14:46,  9.64s/it][Succeeded / Failed / Skipped / Total] 399 / 498 / 11 / 908:  91%|█████████ | 909/1000 [2:25:53<14:36,  9.63s/it][Succeeded / Failed / Skipped / Total] 399 / 499 / 11 / 909:  91%|█████████ | 909/1000 [2:25:53<14:36,  9.63s/it][Succeeded / Failed / Skipped / Total] 399 / 499 / 11 / 909:  91%|█████████ | 910/1000 [2:25:55<14:25,  9.62s/it][Succeeded / Failed / Skipped / Total] 399 / 500 / 11 / 910:  91%|█████████ | 910/1000 [2:25:55<14:25,  9.62s/it][Succeeded / Failed / Skipped / Total] 399 / 500 / 11 / 910:  91%|█████████ | 911/1000 [2:25:57<14:15,  9.61s/it][Succeeded / Failed / Skipped / Total] 399 / 501 / 11 / 911:  91%|█████████ | 911/1000 [2:25:57<14:15,  9.61s/it][Succeeded / Failed / Skipped / Total] 399 / 501 / 11 / 911:  91%|█████████ | 912/1000 [2:26:54<14:10,  9.66s/it][Succeeded / Failed / Skipped / Total] 399 / 502 / 11 / 912:  91%|█████████ | 912/1000 [2:26:54<14:10,  9.66s/it][Succeeded / Failed / Skipped / Total] 399 / 502 / 11 / 912:  91%|█████████▏| 913/1000 [2:26:56<14:00,  9.66s/it][Succeeded / Failed / Skipped / Total] 399 / 503 / 11 / 913:  91%|█████████▏| 913/1000 [2:26:56<14:00,  9.66s/it][Succeeded / Failed / Skipped / Total] 399 / 503 / 11 / 913:  91%|█████████▏| 914/1000 [2:27:01<13:49,  9.65s/it]Sets the target class . --> Biographer for rosarita --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[biographer]] ( final Class [[rosarita]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[rosarita]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[rosarita]] . getName ( ) ) ; } targetClass = [[rosarita]] ; targetClassName = [[rosarita]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[rosarita]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 907 ---------------------------------------------
Sets the target . --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[jamuna]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 908 ---------------------------------------------
Validates the action . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[natalya]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 909 ---------------------------------------------
Adds a violation to the validator . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[addViolation]] ( final String [[name]] , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[name]] , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[implied]] ( final String [[ballesteros]] , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[ballesteros]] , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 910 ---------------------------------------------
Check if the target class is present and if not throw an exception . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[vagrant]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 911 ---------------------------------------------
Sets the target class name . --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[setTarget]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T [[vallejo]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 912 ---------------------------------------------
Create a new instance of this class . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class [[type]] = define ( ) ; try { return ClassUtil . newInstance ( [[type]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[khadija]] ( ) { Class [[glimmer]] = define ( ) ; try { return ClassUtil . newInstance ( [[glimmer]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 913 ---------------------------------------------
Sets the file to be downloaded . --> [[[FAILED]]]

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String [[downloadFileName]] ) { this . downloadFileName = [[downloadFileName]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[francs]] ( final String [[wimmer]] ) { this . downloadFileName = [[wimmer]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[wimmer]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 914 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 399 / 504 / 11 / 914:  91%|█████████▏| 914/1000 [2:27:01<13:49,  9.65s/it][Succeeded / Failed / Skipped / Total] 399 / 504 / 11 / 914:  92%|█████████▏| 915/1000 [2:27:15<13:40,  9.66s/it][Succeeded / Failed / Skipped / Total] 399 / 505 / 11 / 915:  92%|█████████▏| 915/1000 [2:27:15<13:40,  9.66s/it][Succeeded / Failed / Skipped / Total] 399 / 505 / 11 / 915:  92%|█████████▏| 916/1000 [2:27:24<13:31,  9.66s/it][Succeeded / Failed / Skipped / Total] 400 / 505 / 11 / 916:  92%|█████████▏| 916/1000 [2:27:24<13:31,  9.66s/it][Succeeded / Failed / Skipped / Total] 400 / 505 / 11 / 916:  92%|█████████▏| 917/1000 [2:27:34<13:21,  9.66s/it][Succeeded / Failed / Skipped / Total] 400 / 506 / 11 / 917:  92%|█████████▏| 917/1000 [2:27:34<13:21,  9.66s/it][Succeeded / Failed / Skipped / Total] 400 / 506 / 11 / 917:  92%|█████████▏| 918/1000 [2:27:36<13:11,  9.65s/it][Succeeded / Failed / Skipped / Total] 400 / 507 / 11 / 918:  92%|█████████▏| 918/1000 [2:27:36<13:11,  9.65s/it][Succeeded / Failed / Skipped / Total] 400 / 507 / 11 / 918:  92%|█████████▏| 919/1000 [2:27:48<13:01,  9.65s/it][Succeeded / Failed / Skipped / Total] 401 / 507 / 11 / 919:  92%|█████████▏| 919/1000 [2:27:48<13:01,  9.65s/it][Succeeded / Failed / Skipped / Total] 401 / 507 / 11 / 919:  92%|█████████▏| 920/1000 [2:27:53<12:51,  9.64s/it][Succeeded / Failed / Skipped / Total] 401 / 508 / 11 / 920:  92%|█████████▏| 920/1000 [2:27:53<12:51,  9.64s/it][Succeeded / Failed / Skipped / Total] 401 / 508 / 11 / 920:  92%|█████████▏| 921/1000 [2:27:56<12:41,  9.64s/it][Succeeded / Failed / Skipped / Total] 401 / 509 / 11 / 921:  92%|█████████▏| 921/1000 [2:27:56<12:41,  9.64s/it][Succeeded / Failed / Skipped / Total] 401 / 509 / 11 / 921:  92%|█████████▏| 922/1000 [2:28:02<12:31,  9.63s/it]Create the proxy . --> [[[FAILED]]]

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[pharmacists]] ( ) { process ( ) ; byte [ ] [[polling]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[polling]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[polling]] ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 915 ---------------------------------------------
Creates a new proxy class . --> [[[FAILED]]]

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[classLoader]] = proxetta . getClassLoader ( ) ; if ( [[classLoader]] == null ) { [[classLoader]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[classLoader]] == null ) && ( targetClass != null ) ) { [[classLoader]] = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , [[classLoader]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[notify]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[protégée]] = proxetta . getClassLoader ( ) ; if ( [[protégée]] == null ) { [[protégée]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[protégée]] == null ) && ( targetClass != null ) ) { [[protégée]] = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , [[protégée]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 916 ---------------------------------------------
Set the cc address . --> Add a list of ccs to the end of the list --> Socre: 1.0

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... ccs ) { this . [[cc]] = ArraysUtil . join ( this . [[cc]] , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[responsibility]] ( final EmailAddress ... ccs ) { this . [[svend]] = ArraysUtil . join ( this . [[svend]] , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 917 ---------------------------------------------
Sets the from address . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[from]] ( final String personalName , final String [[from]] ) { return [[from]] ( new EmailAddress ( personalName , [[from]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T [[babaloo]] ( final String personalName , final String [[jackhammer]] ) { return [[babaloo]] ( new EmailAddress ( personalName , [[babaloo]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 918 ---------------------------------------------
Add a to address . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[to]] ( final EmailAddress [[to]] ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[times]] ( final EmailAddress [[fizzes]] ) { this . [[scented]] = ArraysUtil . append ( this . [[scented]] , [[times]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 919 ---------------------------------------------
Sends an HTML message . --> Send fruitcakes email --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String html , final String encoding ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[fruitcakes]] ( final String html , final String encoding ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 920 ---------------------------------------------
Dump a class in the debug folder . --> [[[FAILED]]]

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 921 ---------------------------------------------
Sets the to address . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[to]] ( final String personalName , final String to ) { return [[to]] ( new EmailAddress ( personalName , [[to]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T [[lennie]] ( final String personalName , final String to ) { return [[lennie]] ( new EmailAddress ( personalName , [[lennie]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
[Succeeded / Failed / Skipped / Total] 401 / 510 / 11 / 922:  92%|█████████▏| 922/1000 [2:28:02<12:31,  9.63s/it][Succeeded / Failed / Skipped / Total] 401 / 510 / 11 / 922:  92%|█████████▏| 923/1000 [2:28:26<12:23,  9.65s/it][Succeeded / Failed / Skipped / Total] 401 / 511 / 11 / 923:  92%|█████████▏| 923/1000 [2:28:26<12:23,  9.65s/it][Succeeded / Failed / Skipped / Total] 401 / 511 / 11 / 923:  92%|█████████▏| 924/1000 [2:28:44<12:14,  9.66s/it][Succeeded / Failed / Skipped / Total] 401 / 512 / 11 / 924:  92%|█████████▏| 924/1000 [2:28:44<12:14,  9.66s/it][Succeeded / Failed / Skipped / Total] 401 / 512 / 11 / 924:  92%|█████████▎| 925/1000 [2:28:51<12:04,  9.66s/it][Succeeded / Failed / Skipped / Total] 402 / 512 / 11 / 925:  92%|█████████▎| 925/1000 [2:28:51<12:04,  9.66s/it][Succeeded / Failed / Skipped / Total] 402 / 512 / 11 / 925:  93%|█████████▎| 926/1000 [2:28:55<11:54,  9.65s/it][Succeeded / Failed / Skipped / Total] 402 / 513 / 11 / 926:  93%|█████████▎| 926/1000 [2:28:55<11:54,  9.65s/it][Succeeded / Failed / Skipped / Total] 402 / 513 / 11 / 926:  93%|█████████▎| 927/1000 [2:29:38<11:47,  9.69s/it][Succeeded / Failed / Skipped / Total] 402 / 514 / 11 / 927:  93%|█████████▎| 927/1000 [2:29:38<11:47,  9.69s/it][Succeeded / Failed / Skipped / Total] 402 / 514 / 11 / 927:  93%|█████████▎| 928/1000 [2:29:59<11:38,  9.70s/it][Succeeded / Failed / Skipped / Total] 402 / 515 / 11 / 928:  93%|█████████▎| 928/1000 [2:29:59<11:38,  9.70s/it][Succeeded / Failed / Skipped / Total] 402 / 515 / 11 / 928:  93%|█████████▎| 929/1000 [2:30:04<11:28,  9.69s/it][Succeeded / Failed / Skipped / Total] 402 / 516 / 11 / 929:  93%|█████████▎| 929/1000 [2:30:04<11:28,  9.69s/it][Succeeded / Failed / Skipped / Total] 402 / 516 / 11 / 929:  93%|█████████▎| 930/1000 [2:30:19<11:18,  9.70s/it][Succeeded / Failed / Skipped / Total] 402 / 517 / 11 / 930:  93%|█████████▎| 930/1000 [2:30:19<11:18,  9.70s/it][Succeeded / Failed / Skipped / Total] 402 / 517 / 11 / 930:  93%|█████████▎| 931/1000 [2:30:23<11:08,  9.69s/it]--------------------------------------------- Result 922 ---------------------------------------------
Replaces all email addresses with the given email address . --> [[[FAILED]]]

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . [[replyTo]] = ArraysUtil . join ( this . [[replyTo]] , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . [[behemoth]] = ArraysUtil . join ( this . [[behemoth]] , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 923 ---------------------------------------------
Get the resolved parameters for this method . --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[bombé]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 924 ---------------------------------------------
Sends a plain text message . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[textMessage]] ( final String [[text]] , final String encoding ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[questo]] ( final String [[onliest]] , final String encoding ) { return message ( new EmailMessage ( [[onliest]] , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 925 ---------------------------------------------
Resolve an alias . --> Convert akita string to akita string --> Socre: 1.0

[[[[Adv]]]]: protected String [[resolveAlias]] ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String [[akita]] ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 926 ---------------------------------------------
Adds a header to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[header]] ( final String name , final String [[value]] ) { headers . put ( name , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[socially]] ( final String name , final String [[gilda]] ) { headers . put ( name , [[gilda]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 927 ---------------------------------------------
Get a system property . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[get]] ( final String name , final String defaultValue ) { Objects . requireNonNull ( name ) ; String [[value]] = null ; try { if ( System . getSecurityManager ( ) == null ) { [[value]] = System . getProperty ( name ) ; } else { [[value]] = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( [[value]] == null ) { return defaultValue ; } return [[value]] ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String [[magnanimity]] ( final String name , final String defaultValue ) { Objects . requireNonNull ( name ) ; String [[firecracker]] = null ; try { if ( System . getSecurityManager ( ) == null ) { [[firecracker]] = System . getProperty ( name ) ; } else { [[firecracker]] = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( [[firecracker]] == null ) { return defaultValue ; } return [[firecracker]] ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 928 ---------------------------------------------
Serialize a single key - value pair . --> [[[FAILED]]]

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext jsonContext , final Path [[currentPath]] , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { [[currentPath]] . push ( key . toString ( ) ) ; } else { [[currentPath]] . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext jsonContext , final Path [[downriver]] , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { [[downriver]] . push ( key . toString ( ) ) ; } else { [[downriver]] . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 929 ---------------------------------------------
Get a boolean property . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean getBoolean ( final String name , final boolean defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean getBoolean ( final String name , final boolean defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 930 ---------------------------------------------
Returns the value of the given name as a long . --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[getLong]] ( final String [[name]] , final long defaultValue ) { String [[value]] = get ( [[name]] ) ; if ( [[value]] == null ) { return defaultValue ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long [[january]] ( final String [[resolving]] , final long defaultValue ) { String [[coney]] = get ( [[resolving]] ) ; if ( [[coney]] == null ) { return defaultValue ; } [[coney]] = [[coney]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[coney]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .
[Succeeded / Failed / Skipped / Total] 403 / 517 / 11 / 931:  93%|█████████▎| 931/1000 [2:30:23<11:08,  9.69s/it][Succeeded / Failed / Skipped / Total] 403 / 517 / 11 / 931:  93%|█████████▎| 932/1000 [2:30:38<10:59,  9.70s/it][Succeeded / Failed / Skipped / Total] 403 / 518 / 11 / 932:  93%|█████████▎| 932/1000 [2:30:38<10:59,  9.70s/it][Succeeded / Failed / Skipped / Total] 403 / 518 / 11 / 932:  93%|█████████▎| 933/1000 [2:30:43<10:49,  9.69s/it][Succeeded / Failed / Skipped / Total] 403 / 519 / 11 / 933:  93%|█████████▎| 933/1000 [2:30:43<10:49,  9.69s/it][Succeeded / Failed / Skipped / Total] 403 / 519 / 11 / 933:  93%|█████████▎| 934/1000 [2:30:44<10:39,  9.68s/it][Succeeded / Failed / Skipped / Total] 404 / 519 / 11 / 934:  93%|█████████▎| 934/1000 [2:30:44<10:39,  9.68s/it][Succeeded / Failed / Skipped / Total] 404 / 519 / 11 / 934:  94%|█████████▎| 935/1000 [2:30:44<10:28,  9.67s/it][Succeeded / Failed / Skipped / Total] 405 / 519 / 11 / 935:  94%|█████████▎| 935/1000 [2:30:44<10:28,  9.67s/it][Succeeded / Failed / Skipped / Total] 405 / 519 / 11 / 935:  94%|█████████▎| 936/1000 [2:30:52<10:18,  9.67s/it][Succeeded / Failed / Skipped / Total] 406 / 519 / 11 / 936:  94%|█████████▎| 936/1000 [2:30:52<10:18,  9.67s/it][Succeeded / Failed / Skipped / Total] 406 / 519 / 11 / 936:  94%|█████████▎| 937/1000 [2:31:02<10:09,  9.67s/it][Succeeded / Failed / Skipped / Total] 407 / 519 / 11 / 937:  94%|█████████▎| 937/1000 [2:31:02<10:09,  9.67s/it][Succeeded / Failed / Skipped / Total] 407 / 519 / 11 / 937:  94%|█████████▍| 938/1000 [2:31:07<09:59,  9.67s/it][Succeeded / Failed / Skipped / Total] 408 / 519 / 11 / 938:  94%|█████████▍| 938/1000 [2:31:07<09:59,  9.67s/it][Succeeded / Failed / Skipped / Total] 408 / 519 / 11 / 938:  94%|█████████▍| 939/1000 [2:31:12<09:49,  9.66s/it][Succeeded / Failed / Skipped / Total] 409 / 519 / 11 / 939:  94%|█████████▍| 939/1000 [2:31:12<09:49,  9.66s/it][Succeeded / Failed / Skipped / Total] 409 / 519 / 11 / 939:  94%|█████████▍| 940/1000 [2:31:26<09:39,  9.67s/it][Succeeded / Failed / Skipped / Total] 410 / 519 / 11 / 940:  94%|█████████▍| 940/1000 [2:31:26<09:39,  9.67s/it][Succeeded / Failed / Skipped / Total] 410 / 519 / 11 / 940:  94%|█████████▍| 941/1000 [2:31:55<09:31,  9.69s/it]--------------------------------------------- Result 931 ---------------------------------------------
Removes the last camel word from the name . --> Remove all upper case letters from a name . --> Socre: 1.0

[[[[Adv]]]]: public static String [[stripLastCamelWord]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String [[allude]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 932 ---------------------------------------------
Lookup a path alias . --> [[[FAILED]]]

[[[[Adv]]]]: protected String lookupAlias ( final String [[alias]] ) { String value = actionsManager . lookupPathAlias ( [[alias]] ) ; if ( value == null ) { ActionRuntime [[cfg]] = actionsManager . lookup ( [[alias]] ) ; if ( [[cfg]] != null ) { value = [[cfg]] . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String lookupAlias ( final String [[harmon]] ) { String value = actionsManager . lookupPathAlias ( [[harmon]] ) ; if ( value == null ) { ActionRuntime [[avalanche]] = actionsManager . lookup ( [[harmon]] ) ; if ( [[avalanche]] != null ) { value = [[avalanche]] . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 933 ---------------------------------------------
Resolve a result path string . --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveResultPathString ( final String path , final String value ) { final ResultPath resultPath = resolveResultPath ( path , value ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String resolveResultPathString ( final String path , final String value ) { final ResultPath resultPath = resolveResultPath ( path , value ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 934 ---------------------------------------------
Resolve a result path . --> Resolve the given haystack and bangkok --> Socre: 1.0

[[[[Adv]]]]: public ResultPath resolveResultPath ( String [[path]] , String [[value]] ) { boolean absolutePath = "[[False]]" != "[[False]]" ; if ( [[value]] != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath resolveResultPath ( String [[haystack]] , String [[bangkok]] ) { boolean absolutePath = "[[Trucks]]" != "[[Trucks]]" ; if ( [[bangkok]] != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 935 ---------------------------------------------
Returns the index of the last dot after a slash . --> get medo from persecuted string --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String [[str]] ) { int slashNdx = [[str]] . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[medo]] ( final String [[persecuted]] ) { int slashNdx = [[persecuted]] . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( [[persecuted]] , ' ' , [[persecuted]] . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 936 ---------------------------------------------
Returns the index of the last slash dot in the string . --> yosuke a string --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String str ) { int [[slashNdx]] = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[slashNdx]] ) ; if ( dotNdx == - 1 ) { if ( [[slashNdx]] == - 1 ) { return - 1 ; } [[slashNdx]] ++ ; if ( [[slashNdx]] < str . length ( ) - 1 ) { dotNdx = [[slashNdx]] ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[yosuke]] ( final String str ) { int [[attributable]] = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[attributable]] ) ; if ( dotNdx == - 1 ) { if ( [[attributable]] == - 1 ) { return - 1 ; } [[attributable]] ++ ; if ( [[attributable]] < str . length ( ) - 1 ) { dotNdx = [[attributable]] ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 937 ---------------------------------------------
Schedule a key schedule . --> Courtly a number of times --> Socre: 1.0

[[[[Adv]]]]: private void [[keySchedule]] ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .

[[[[Adv]]]]: private void [[courtly]] ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 938 ---------------------------------------------
Mix the x and y values . --> Milieu x = x + x + x + x + x + x + x --> Socre: 1.0

[[[[Adv]]]]: private void mix ( final int [[j]] , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void mix ( final int [[milieu]] , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ [[milieu]] ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 939 ---------------------------------------------
Do a demix . --> motherly = y^j ^ y^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^d^c^c^c^c^c^c^c^d^d^d^d^d^d^d^ --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long [[rotr]] = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long [[motherly]] = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 940 ---------------------------------------------
Returns the index of the last dot after a slash . --> get indulges of tribeca --> Socre: 1.0

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String [[str]] ) { int slashNdx = [[str]] . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return [[str]] . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[indulges]] ( final String [[tribeca]] ) { int slashNdx = [[tribeca]] . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return [[tribeca]] . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 941 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 411 / 519 / 11 / 941:  94%|█████████▍| 941/1000 [2:31:55<09:31,  9.69s/it][Succeeded / Failed / Skipped / Total] 411 / 519 / 11 / 941:  94%|█████████▍| 942/1000 [2:32:03<09:21,  9.68s/it][Succeeded / Failed / Skipped / Total] 412 / 519 / 11 / 942:  94%|█████████▍| 942/1000 [2:32:03<09:21,  9.68s/it][Succeeded / Failed / Skipped / Total] 412 / 519 / 11 / 942:  94%|█████████▍| 943/1000 [2:32:21<09:12,  9.69s/it][Succeeded / Failed / Skipped / Total] 413 / 519 / 11 / 943:  94%|█████████▍| 943/1000 [2:32:21<09:12,  9.69s/it][Succeeded / Failed / Skipped / Total] 413 / 519 / 11 / 943:  94%|█████████▍| 944/1000 [2:32:22<09:02,  9.68s/it][Succeeded / Failed / Skipped / Total] 413 / 520 / 11 / 944:  94%|█████████▍| 944/1000 [2:32:22<09:02,  9.68s/it][Succeeded / Failed / Skipped / Total] 413 / 520 / 11 / 944:  94%|█████████▍| 945/1000 [2:32:22<08:52,  9.67s/it][Succeeded / Failed / Skipped / Total] 413 / 521 / 11 / 945:  94%|█████████▍| 945/1000 [2:32:22<08:52,  9.67s/it][Succeeded / Failed / Skipped / Total] 413 / 521 / 11 / 945:  95%|█████████▍| 946/1000 [2:32:24<08:41,  9.67s/it][Succeeded / Failed / Skipped / Total] 414 / 521 / 11 / 946:  95%|█████████▍| 946/1000 [2:32:24<08:41,  9.67s/it][Succeeded / Failed / Skipped / Total] 414 / 521 / 11 / 946:  95%|█████████▍| 947/1000 [2:32:27<08:31,  9.66s/it][Succeeded / Failed / Skipped / Total] 415 / 521 / 11 / 947:  95%|█████████▍| 947/1000 [2:32:27<08:31,  9.66s/it][Succeeded / Failed / Skipped / Total] 415 / 521 / 11 / 947:  95%|█████████▍| 948/1000 [2:32:58<08:23,  9.68s/it]Initializes the hash table with the given key and tweak . --> Huntsman claustrophobic --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final long [ ] key , final long [ ] [[tweak]] ) { final int [[newNw]] = key . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void [[claustrophobic]] ( final long [ ] key , final long [ ] [[flashlight]] ) { final int [[huntsman]] = key . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 942 ---------------------------------------------
Encrypt a block of data . --> This method is used to encrypt the content and return the encrypted content --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[inuit]] ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 943 ---------------------------------------------
Removes any bound characters from a string . --> yucatan - > yucatan --> Socre: 1.0

[[[[Adv]]]]: private static String [[removeAnyBounding]] ( final char s , final char e , final String [[str]] ) { if ( [[str]] == null || [[str]] . length ( ) < 2 ) { return [[str]] ; } if ( [[str]] . startsWith ( String . valueOf ( s ) ) && [[str]] . endsWith ( String . valueOf ( e ) ) ) { return [[str]] . substring ( 1 , [[str]] . length ( ) - 1 ) ; } return [[str]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String [[yucatan]] ( final char s , final char e , final String [[cfr]] ) { if ( [[cfr]] == null || [[cfr]] . length ( ) < 2 ) { return [[cfr]] ; } if ( [[cfr]] . startsWith ( String . valueOf ( s ) ) && [[cfr]] . endsWith ( String . valueOf ( e ) ) ) { return [[cfr]] . substring ( 1 , [[cfr]] . length ( ) - 1 ) ; } return [[cfr]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 944 ---------------------------------------------
Resolve column descriptors . --> [[[FAILED]]]

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 945 ---------------------------------------------
Resolves the schema name for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static String resolveSchemaName ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String resolveSchemaName ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 946 ---------------------------------------------
Ungzip a file . --> Ungzip a featherstone file --> Socre: 1.0

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String [[outFileName]] = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( [[outFileName]] ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String [[featherstone]] = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( [[featherstone]] ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 947 ---------------------------------------------
Initializes the key with the given key message and tweak . --> Method to perform fruitcakes --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final String keyMessage , final long tweak1 , final long [[tweak2]] ) { long [ ] [[tweak]] = new long [ ] { tweak1 , [[tweak2]] } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; [[init]] ( bytesToLongs ( key ) , [[tweak]] ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void [[fruitcakes]] ( final String keyMessage , final long tweak1 , final long [[paperweights]] ) { long [ ] [[jar]] = new long [ ] { tweak1 , [[paperweights]] } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; [[fruitcakes]] ( bytesToLongs ( key ) , [[jar]] ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 948 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 415 / 522 / 11 / 948:  95%|█████████▍| 948/1000 [2:32:58<08:23,  9.68s/it][Succeeded / Failed / Skipped / Total] 415 / 522 / 11 / 948:  95%|█████████▍| 949/1000 [2:33:09<08:13,  9.68s/it][Succeeded / Failed / Skipped / Total] 416 / 522 / 11 / 949:  95%|█████████▍| 949/1000 [2:33:09<08:13,  9.68s/it][Succeeded / Failed / Skipped / Total] 416 / 522 / 11 / 949:  95%|█████████▌| 950/1000 [2:33:49<08:05,  9.71s/it][Succeeded / Failed / Skipped / Total] 416 / 523 / 11 / 950:  95%|█████████▌| 950/1000 [2:33:49<08:05,  9.71s/it][Succeeded / Failed / Skipped / Total] 416 / 523 / 11 / 950:  95%|█████████▌| 951/1000 [2:33:52<07:55,  9.71s/it][Succeeded / Failed / Skipped / Total] 417 / 523 / 11 / 951:  95%|█████████▌| 951/1000 [2:33:52<07:55,  9.71s/it][Succeeded / Failed / Skipped / Total] 417 / 523 / 11 / 951:  95%|█████████▌| 952/1000 [2:34:01<07:45,  9.71s/it][Succeeded / Failed / Skipped / Total] 417 / 524 / 11 / 952:  95%|█████████▌| 952/1000 [2:34:01<07:45,  9.71s/it][Succeeded / Failed / Skipped / Total] 417 / 524 / 11 / 952:  95%|█████████▌| 953/1000 [2:34:32<07:37,  9.73s/it][Succeeded / Failed / Skipped / Total] 417 / 525 / 11 / 953:  95%|█████████▌| 953/1000 [2:34:32<07:37,  9.73s/it][Succeeded / Failed / Skipped / Total] 417 / 525 / 11 / 953:  95%|█████████▌| 954/1000 [2:34:37<07:27,  9.72s/it][Succeeded / Failed / Skipped / Total] 418 / 525 / 11 / 954:  95%|█████████▌| 954/1000 [2:34:37<07:27,  9.72s/it][Succeeded / Failed / Skipped / Total] 418 / 525 / 11 / 954:  96%|█████████▌| 955/1000 [2:35:14<07:18,  9.75s/it]Returns the path of the method . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String [[methodName]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[methodName]] ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[colonise]] ( ) { if ( methref != null ) { final String [[rst]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[rst]] ; } return [[colonise]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 949 ---------------------------------------------
Unzips the given zip file to the given destination directory . --> Unzip dió arapaho --> Socre: 1.0

[[[[Adv]]]]: public static void unzip ( final String [[zipFile]] , final String [[destDir]] , final String ... patterns ) throws IOException { unzip ( new File ( [[zipFile]] ) , new File ( [[destDir]] ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String [[dió]] , final String [[arapaho]] , final String ... patterns ) throws IOException { unzip ( new File ( [[dió]] ) , new File ( [[arapaho]] ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 950 ---------------------------------------------
Zlib a file . --> [[[FAILED]]]

[[[[Adv]]]]: public static File [[zlib]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream [[fis]] = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream [[dos]] = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( [[fis]] , [[dos]] ) ; } finally { StreamUtil . close ( [[dos]] ) ; StreamUtil . close ( [[fis]] ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File [[extracting]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream [[zeitung]] = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream [[protégée]] = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( [[zeitung]] , [[protégée]] ) ; } finally { StreamUtil . close ( [[protégée]] ) ; StreamUtil . close ( [[zeitung]] ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 951 ---------------------------------------------
Adds a file to a zip output stream . --> abundance for a file --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean [[recursive]] ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean [[isDir]] = file . isDirectory ( ) ; if ( [[isDir]] ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[abundance]] ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean [[wetsuit]] ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean [[boycott]] = file . isDirectory ( ) ; if ( [[boycott]] ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 952 ---------------------------------------------
Convert a byte array to a long array . --> [[[FAILED]]]

[[[[Adv]]]]: protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 953 ---------------------------------------------
Gzip a file . --> [[[FAILED]]]

[[[[Adv]]]]: public static File gzip ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File gzip ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 954 ---------------------------------------------
Adds a file to a zip file . --> add grunwald braithwaite --> Socre: 1.0

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String [[path]] , final String [[comment]] ) throws IOException { while ( [[path]] . length ( ) != 0 && [[path]] . charAt ( 0 ) == ' ' ) { [[path]] = [[path]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[path]] , ' ' ) ) { [[path]] = [[path]] . substring ( 0 , [[path]] . length ( ) - 1 ) ; } ZipEntry [[zipEntry]] = new ZipEntry ( [[path]] ) ; [[zipEntry]] . setTime ( System . currentTimeMillis ( ) ) ; if ( [[comment]] != null ) { [[zipEntry]] . setComment ( [[comment]] ) ; } zos . putNextEntry ( [[zipEntry]] ) ; InputStream [[is]] = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( [[is]] , zos ) ; } finally { StreamUtil . close ( [[is]] ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String [[grunwald]] , final String [[braithwaite]] ) throws IOException { while ( [[grunwald]] . length ( ) != 0 && [[grunwald]] . charAt ( 0 ) == ' ' ) { [[grunwald]] = [[grunwald]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[grunwald]] , ' ' ) ) { [[grunwald]] = [[grunwald]] . substring ( 0 , [[grunwald]] . length ( ) - 1 ) ; } ZipEntry [[was]] = new ZipEntry ( [[grunwald]] ) ; [[was]] . setTime ( System . currentTimeMillis ( ) ) ; if ( [[braithwaite]] != null ) { [[was]] . setComment ( [[braithwaite]] ) ; } zos . putNextEntry ( [[was]] ) ; InputStream [[gender]] = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( [[gender]] , zos ) ; } finally { StreamUtil . close ( [[gender]] ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
[Succeeded / Failed / Skipped / Total] 418 / 526 / 11 / 955:  96%|█████████▌| 955/1000 [2:35:14<07:18,  9.75s/it][Succeeded / Failed / Skipped / Total] 418 / 526 / 11 / 955:  96%|█████████▌| 956/1000 [2:35:19<07:08,  9.75s/it][Succeeded / Failed / Skipped / Total] 418 / 527 / 11 / 956:  96%|█████████▌| 956/1000 [2:35:19<07:08,  9.75s/it][Succeeded / Failed / Skipped / Total] 418 / 527 / 11 / 956:  96%|█████████▌| 957/1000 [2:35:50<07:00,  9.77s/it][Succeeded / Failed / Skipped / Total] 418 / 528 / 11 / 957:  96%|█████████▌| 957/1000 [2:35:50<07:00,  9.77s/it][Succeeded / Failed / Skipped / Total] 418 / 528 / 11 / 957:  96%|█████████▌| 958/1000 [2:35:50<06:49,  9.76s/it][Succeeded / Failed / Skipped / Total] 419 / 528 / 11 / 958:  96%|█████████▌| 958/1000 [2:35:50<06:49,  9.76s/it][Succeeded / Failed / Skipped / Total] 419 / 528 / 11 / 958:  96%|█████████▌| 959/1000 [2:36:00<06:40,  9.76s/it][Succeeded / Failed / Skipped / Total] 419 / 529 / 11 / 959:  96%|█████████▌| 959/1000 [2:36:00<06:40,  9.76s/it][Succeeded / Failed / Skipped / Total] 419 / 529 / 11 / 959:  96%|█████████▌| 960/1000 [2:36:02<06:30,  9.75s/it][Succeeded / Failed / Skipped / Total] 419 / 530 / 11 / 960:  96%|█████████▌| 960/1000 [2:36:02<06:30,  9.75s/it][Succeeded / Failed / Skipped / Total] 419 / 530 / 11 / 960:  96%|█████████▌| 961/1000 [2:36:18<06:20,  9.76s/it][Succeeded / Failed / Skipped / Total] 419 / 531 / 11 / 961:  96%|█████████▌| 961/1000 [2:36:18<06:20,  9.76s/it][Succeeded / Failed / Skipped / Total] 419 / 531 / 11 / 961:  96%|█████████▌| 962/1000 [2:36:20<06:10,  9.75s/it][Succeeded / Failed / Skipped / Total] 419 / 532 / 11 / 962:  96%|█████████▌| 962/1000 [2:36:20<06:10,  9.75s/it][Succeeded / Failed / Skipped / Total] 419 / 532 / 11 / 962:  96%|█████████▋| 963/1000 [2:36:36<06:01,  9.76s/it]--------------------------------------------- Result 955 ---------------------------------------------
Returns a list of all entries in a zip file . --> [[[FAILED]]]

[[[[Adv]]]]: public static List < String > listZip ( final File zipFile ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( zipFile ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > listZip ( final File zipFile ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( zipFile ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 956 ---------------------------------------------
Sets the bundle name for the request . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest request , final String [[bundleName]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[bundleName]] ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[bundleName]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[danke]] ( final ServletRequest request , final String [[agrado]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[agrado]] ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[agrado]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 957 ---------------------------------------------
Gets the session locale . --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale [[getSessionLocale]] ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale [[sawed]] ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 958 ---------------------------------------------
Reads a long from the given byte array starting at the given offset . --> на на на на на --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[на]] ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 959 ---------------------------------------------
Sets the session locale . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession [[session]] , final String [[localeCode]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[localeCode]] ) ; } Locale locale = Locale . forLanguageTag ( [[localeCode]] ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[causality]] ( final HttpSession [[habitation]] , final String [[hoped]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[hoped]] ) ; } Locale locale = Locale . forLanguageTag ( [[hoped]] ) ; [[habitation]] . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 960 ---------------------------------------------
Returns the field descriptor for the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor [[getFieldDescriptor]] ( final String [[name]] , final boolean [[declared]] ) { final FieldDescriptor [[fieldDescriptor]] = getFields ( ) . getFieldDescriptor ( [[name]] ) ; if ( [[fieldDescriptor]] != null ) { if ( ! [[fieldDescriptor]] . matchDeclared ( [[declared]] ) ) { return null ; } } return [[fieldDescriptor]] ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor [[holcomb]] ( final String [[reassigned]] , final boolean [[anklets]] ) { final FieldDescriptor [[nonlinear]] = getFields ( ) . getFieldDescriptor ( [[reassigned]] ) ; if ( [[nonlinear]] != null ) { if ( ! [[nonlinear]] . matchDeclared ( [[anklets]] ) ) { return null ; } } return [[nonlinear]] ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 961 ---------------------------------------------
Adds a profile to the list of profiles . --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntries [[profile]] ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String [[profile]] : profiles ) { addProfiles ( [[profile]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries [[stacks]] ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String [[stacks]] : profiles ) { addProfiles ( [[stacks]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 962 ---------------------------------------------
Returns the property descriptor for the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public PropertyDescriptor [[getPropertyDescriptor]] ( final String [[name]] , final boolean [[declared]] ) { PropertyDescriptor [[propertyDescriptor]] = getProperties ( ) . getPropertyDescriptor ( [[name]] ) ; if ( ( [[propertyDescriptor]] != null ) && [[propertyDescriptor]] . matchDeclared ( [[declared]] ) ) { return [[propertyDescriptor]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor [[braithwaite]] ( final String [[overs]] , final boolean [[necronomicon]] ) { PropertyDescriptor [[misappropriation]] = getProperties ( ) . getPropertyDescriptor ( [[overs]] ) ; if ( ( [[misappropriation]] != null ) && [[misappropriation]] . matchDeclared ( [[necronomicon]] ) ) { return [[misappropriation]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 963 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 419 / 533 / 11 / 963:  96%|█████████▋| 963/1000 [2:36:36<06:01,  9.76s/it][Succeeded / Failed / Skipped / Total] 419 / 533 / 11 / 963:  96%|█████████▋| 964/1000 [2:37:27<05:52,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 534 / 11 / 964:  96%|█████████▋| 964/1000 [2:37:27<05:52,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 534 / 11 / 964:  96%|█████████▋| 965/1000 [2:37:37<05:43,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 535 / 11 / 965:  96%|█████████▋| 965/1000 [2:37:37<05:43,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 535 / 11 / 965:  97%|█████████▋| 966/1000 [2:37:50<05:33,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 536 / 11 / 966:  97%|█████████▋| 966/1000 [2:37:50<05:33,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 536 / 11 / 966:  97%|█████████▋| 967/1000 [2:37:53<05:23,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 537 / 11 / 967:  97%|█████████▋| 967/1000 [2:37:53<05:23,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 537 / 11 / 967:  97%|█████████▋| 968/1000 [2:37:59<05:13,  9.79s/it][Succeeded / Failed / Skipped / Total] 419 / 538 / 11 / 968:  97%|█████████▋| 968/1000 [2:37:59<05:13,  9.79s/it][Succeeded / Failed / Skipped / Total] 419 / 538 / 11 / 968:  97%|█████████▋| 969/1000 [2:38:11<05:03,  9.80s/it]Filter the parameters for the given bean name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 964 ---------------------------------------------
Read a label from the bytecode . --> [[[FAILED]]]

[[[[Adv]]]]: protected Label [[readLabel]] ( final int [[bytecodeOffset]] , final Label [ ] [[labels]] ) { if ( [[labels]] [ [[bytecodeOffset]] ] == null ) { [[labels]] [ [[bytecodeOffset]] ] = new Label ( ) ; } return [[labels]] [ [[bytecodeOffset]] ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label [[parisienne]] ( final int [[adrift]] , final Label [ ] [[teething]] ) { if ( [[teething]] [ [[adrift]] ] == null ) { [[teething]] [ [[adrift]] ] = new Label ( ) ; } return [[teething]] [ [[adrift]] ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 965 ---------------------------------------------
Returns the bytecode offset of a type annotation . --> [[[FAILED]]]

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[haruka]] ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 966 ---------------------------------------------
Read the values of an element . --> [[[FAILED]]]

[[[[Adv]]]]: private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 967 ---------------------------------------------
Read bootstrap methods attribute . --> [[[FAILED]]]

[[[[Adv]]]]: private int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 968 ---------------------------------------------
Reads a byte array from an input stream . --> [[[FAILED]]]

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 969 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 419 / 539 / 11 / 969:  97%|█████████▋| 969/1000 [2:38:11<05:03,  9.80s/it][Succeeded / Failed / Skipped / Total] 419 / 539 / 11 / 969:  97%|█████████▋| 970/1000 [2:38:14<04:53,  9.79s/it][Succeeded / Failed / Skipped / Total] 420 / 539 / 11 / 970:  97%|█████████▋| 970/1000 [2:38:14<04:53,  9.79s/it][Succeeded / Failed / Skipped / Total] 420 / 539 / 11 / 970:  97%|█████████▋| 971/1000 [2:38:15<04:43,  9.78s/it][Succeeded / Failed / Skipped / Total] 421 / 539 / 11 / 971:  97%|█████████▋| 971/1000 [2:38:15<04:43,  9.78s/it][Succeeded / Failed / Skipped / Total] 421 / 539 / 11 / 971:  97%|█████████▋| 972/1000 [2:38:39<04:34,  9.79s/it][Succeeded / Failed / Skipped / Total] 421 / 540 / 11 / 972:  97%|█████████▋| 972/1000 [2:38:39<04:34,  9.79s/it][Succeeded / Failed / Skipped / Total] 421 / 540 / 11 / 972:  97%|█████████▋| 973/1000 [2:38:49<04:24,  9.79s/it][Succeeded / Failed / Skipped / Total] 421 / 541 / 11 / 973:  97%|█████████▋| 973/1000 [2:38:49<04:24,  9.79s/it][Succeeded / Failed / Skipped / Total] 421 / 541 / 11 / 973:  97%|█████████▋| 974/1000 [2:39:12<04:14,  9.81s/it][Succeeded / Failed / Skipped / Total] 422 / 541 / 11 / 974:  97%|█████████▋| 974/1000 [2:39:12<04:14,  9.81s/it][Succeeded / Failed / Skipped / Total] 422 / 541 / 11 / 974:  98%|█████████▊| 975/1000 [2:39:37<04:05,  9.82s/it][Succeeded / Failed / Skipped / Total] 422 / 542 / 11 / 975:  98%|█████████▊| 975/1000 [2:39:37<04:05,  9.82s/it][Succeeded / Failed / Skipped / Total] 422 / 542 / 11 / 975:  98%|█████████▊| 976/1000 [2:39:50<03:55,  9.83s/it]Reads the verification type information . --> [[[FAILED]]]

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] [[frame]] , final int index , final char [ ] charBuffer , final Label [ ] [[labels]] ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : [[frame]] [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : [[frame]] [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : [[frame]] [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : [[frame]] [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : [[frame]] [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : [[frame]] [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : [[frame]] [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : [[frame]] [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : [[frame]] [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , [[labels]] ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] [[malfeasance]] , final int index , final char [ ] charBuffer , final Label [ ] [[soundproof]] ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : [[malfeasance]] [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : [[malfeasance]] [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : [[malfeasance]] [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : [[malfeasance]] [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : [[malfeasance]] [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : [[malfeasance]] [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : [[malfeasance]] [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : [[malfeasance]] [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : [[malfeasance]] [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , [[soundproof]] ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 970 ---------------------------------------------
Initialize the servlet . --> Noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[nooooo]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 971 ---------------------------------------------
Adds a file consumer to the list of consumers . --> Adds a beno to the list of consumers . --> Socre: 1.0

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[fileConsumer]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[fileConsumer]] ) ; } else { consumers . add ( [[fileConsumer]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[beno]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[beno]] ) ; } else { consumers . add ( [[beno]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 972 ---------------------------------------------
Gets the request map . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[lugano]] ( final HttpServletRequest [[empereur]] ) { return ( Map < String , TransientBeanData > ) [[empereur]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 973 ---------------------------------------------
Returns the long value for the given name or the default value if the name is not found . --> [[[FAILED]]]

[[[[Adv]]]]: public static long getInt ( final String [[name]] , final int defaultValue ) { String value = get ( [[name]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long getInt ( final String [[immediately]] , final int defaultValue ) { String value = get ( [[immediately]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 974 ---------------------------------------------
Convert an array to a long array . --> Noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo --> Socre: 1.0

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object [[value]] ) { final Class valueComponentType = [[value]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[result]] ; if ( valueComponentType . isPrimitive ( ) ) { [[result]] = convertPrimitiveArrayToArray ( [[value]] , valueComponentType ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[nooooo]] ( final Object [[odds]] ) { final Class valueComponentType = [[odds]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[buses]] ; if ( valueComponentType . isPrimitive ( ) ) { [[buses]] = convertPrimitiveArrayToArray ( [[odds]] , valueComponentType ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 975 ---------------------------------------------
Gets the request map . --> [[[FAILED]]]

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > [[map]] = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , [[map]] ) ; return [[map]] ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[majesties]] ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > [[benja]] = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , [[benja]] ) ; return [[benja]] ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 976 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 422 / 543 / 11 / 976:  98%|█████████▊| 976/1000 [2:39:50<03:55,  9.83s/it][Succeeded / Failed / Skipped / Total] 422 / 543 / 11 / 976:  98%|█████████▊| 977/1000 [2:39:50<03:45,  9.82s/it][Succeeded / Failed / Skipped / Total] 423 / 543 / 11 / 977:  98%|█████████▊| 977/1000 [2:39:50<03:45,  9.82s/it][Succeeded / Failed / Skipped / Total] 423 / 543 / 11 / 977:  98%|█████████▊| 978/1000 [2:39:51<03:35,  9.81s/it][Succeeded / Failed / Skipped / Total] 423 / 544 / 11 / 978:  98%|█████████▊| 978/1000 [2:39:51<03:35,  9.81s/it][Succeeded / Failed / Skipped / Total] 423 / 544 / 11 / 978:  98%|█████████▊| 979/1000 [2:39:59<03:25,  9.81s/it][Succeeded / Failed / Skipped / Total] 423 / 545 / 11 / 979:  98%|█████████▊| 979/1000 [2:39:59<03:25,  9.81s/it][Succeeded / Failed / Skipped / Total] 423 / 545 / 11 / 979:  98%|█████████▊| 980/1000 [2:40:01<03:15,  9.80s/it][Succeeded / Failed / Skipped / Total] 423 / 546 / 11 / 980:  98%|█████████▊| 980/1000 [2:40:01<03:15,  9.80s/it][Succeeded / Failed / Skipped / Total] 423 / 546 / 11 / 980:  98%|█████████▊| 981/1000 [2:40:18<03:06,  9.81s/it][Succeeded / Failed / Skipped / Total] 423 / 547 / 11 / 981:  98%|█████████▊| 981/1000 [2:40:18<03:06,  9.81s/it][Succeeded / Failed / Skipped / Total] 423 / 547 / 11 / 981:  98%|█████████▊| 982/1000 [2:40:20<02:56,  9.80s/it][Succeeded / Failed / Skipped / Total] 423 / 548 / 11 / 982:  98%|█████████▊| 982/1000 [2:40:20<02:56,  9.80s/it][Succeeded / Failed / Skipped / Total] 423 / 548 / 11 / 982:  98%|█████████▊| 983/1000 [2:40:25<02:46,  9.79s/it][Succeeded / Failed / Skipped / Total] 423 / 549 / 11 / 983:  98%|█████████▊| 983/1000 [2:40:25<02:46,  9.79s/it][Succeeded / Failed / Skipped / Total] 423 / 549 / 11 / 983:  98%|█████████▊| 984/1000 [2:40:37<02:36,  9.79s/it]Add a file to the search path . --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI [[searchPath]] ) { File file ; try { file = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[sauerkraut]] ( final URI [[roadkill]] ) { File file ; try { file = new File ( [[sauerkraut]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[sauerkraut]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 977 ---------------------------------------------
Exclude one or more patterns . --> Adds a progress bar to the list of explosions --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[exclude]] ( final String ... [[patterns]] ) { for ( String [[pattern]] : [[patterns]] ) { rules . exclude ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile [[explosions]] ( final String ... [[progress]] ) { for ( String [[maudie]] : [[progress]] ) { rules . exclude ( [[maudie]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 978 ---------------------------------------------
Add a search path . --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL searchPath ) { File [[file]] = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( [[file]] == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[münster]] ( final URL searchPath ) { File [[fernando]] = FileUtil . toContainerFile ( [[münster]] ) ; if ( [[fernando]] == null ) { throw new FindFileException ( "URL error: " + [[münster]] ) ; } addPath ( [[fernando]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 979 ---------------------------------------------
Inspect constructors . --> [[[FAILED]]]

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 980 ---------------------------------------------
Returns a CtorDescriptor for the given arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public CtorDescriptor [[getCtorDescriptor]] ( final Class ... [[args]] ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[arg]] = ctorDescriptor . getParameters ( ) ; if ( [[arg]] . length != [[args]] . length ) { continue ; } for ( int [[j]] = 0 ; [[j]] < [[arg]] . length ; [[j]] ++ ) { if ( [[arg]] [ [[j]] ] != [[args]] [ [[j]] ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor [[appleton]] ( final Class ... [[subbed]] ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[duplicate]] = ctorDescriptor . getParameters ( ) ; if ( [[duplicate]] . length != [[subbed]] . length ) { continue ; } for ( int [[raised]] = 0 ; [[raised]] < [[duplicate]] . length ; [[raised]] ++ ) { if ( [[duplicate]] [ [[raised]] ] != [[subbed]] [ [[raised]] ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 981 ---------------------------------------------
Adds a pattern to the list of patterns to be included . --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile [[include]] ( final String ... [[patterns]] ) { for ( String pattern : [[patterns]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[sedgwick]] ( final String ... [[chords]] ) { for ( String pattern : [[chords]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 982 ---------------------------------------------
Adds a path to the list of paths . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[addPath]] ( final File [[path]] ) { if ( ! [[path]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[path]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void [[condone]] ( final File [[kaohsiung]] ) { if ( ! [[kaohsiung]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[kaohsiung]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 983 ---------------------------------------------
Returns an iterator over the files in this directory . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < File > [[iterator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > [[prompted]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 984 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 424 / 549 / 11 / 984:  98%|█████████▊| 984/1000 [2:40:37<02:36,  9.79s/it][Succeeded / Failed / Skipped / Total] 424 / 549 / 11 / 984:  98%|█████████▊| 985/1000 [2:40:39<02:26,  9.79s/it][Succeeded / Failed / Skipped / Total] 424 / 550 / 11 / 985:  98%|█████████▊| 985/1000 [2:40:39<02:26,  9.79s/it][Succeeded / Failed / Skipped / Total] 424 / 550 / 11 / 985:  99%|█████████▊| 986/1000 [2:40:50<02:17,  9.79s/it][Succeeded / Failed / Skipped / Total] 425 / 550 / 11 / 986:  99%|█████████▊| 986/1000 [2:40:50<02:17,  9.79s/it][Succeeded / Failed / Skipped / Total] 425 / 550 / 11 / 986:  99%|█████████▊| 987/1000 [2:40:57<02:07,  9.78s/it][Succeeded / Failed / Skipped / Total] 425 / 551 / 11 / 987:  99%|█████████▊| 987/1000 [2:40:57<02:07,  9.78s/it][Succeeded / Failed / Skipped / Total] 425 / 551 / 11 / 987:  99%|█████████▉| 988/1000 [2:41:25<01:57,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 552 / 11 / 988:  99%|█████████▉| 988/1000 [2:41:25<01:57,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 552 / 11 / 988:  99%|█████████▉| 989/1000 [2:41:32<01:47,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 553 / 11 / 989:  99%|█████████▉| 989/1000 [2:41:32<01:47,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 553 / 11 / 989:  99%|█████████▉| 990/1000 [2:41:46<01:38,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 554 / 11 / 990:  99%|█████████▉| 990/1000 [2:41:46<01:38,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 554 / 11 / 990:  99%|█████████▉| 991/1000 [2:41:54<01:28,  9.80s/it]Resolve bean name . --> choctaw a koryo --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class [[type]] , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = [[type]] . getName ( ) ; } else { name = StringUtil . uncapitalize ( [[type]] . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[choctaw]] ( final Class [[koryo]] , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) [[koryo]] ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = [[koryo]] . getName ( ) ; } else { name = StringUtil . uncapitalize ( [[koryo]] . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 985 ---------------------------------------------
Get the output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[feigns]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 986 ---------------------------------------------
Resolve bean wiring mode . --> Wazowski wazowski --> Socre: 1.0

[[[[Adv]]]]: public WiringMode [[resolveBeanWiringMode]] ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode [[wazowski]] ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 987 ---------------------------------------------
Get the output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[devil]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 988 ---------------------------------------------
Returns a list of all files in the directory . --> [[[FAILED]]]

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > allFiles = new ArrayList <> ( ) ; File [[file]] ; while ( ( [[file]] = nextFile ( ) ) != null ) { allFiles . add ( [[file]] ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[benitez]] ( ) { List < File > allFiles = new ArrayList <> ( ) ; File [[excelled]] ; while ( ( [[excelled]] = nextFile ( ) ) != null ) { allFiles . add ( [[excelled]] ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 989 ---------------------------------------------
Returns the size of this object . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getSize]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int [[zoya]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 990 ---------------------------------------------
Returns the class name of this type . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getClassName]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[stringBuilder]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int [[i]] = getDimensions ( ) ; [[i]] > 0 ; -- [[i]] ) { [[stringBuilder]] . append ( "[]" ) ; } return [[stringBuilder]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String [[maría]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[humus]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int [[textbooks]] = getDimensions ( ) ; [[textbooks]] > 0 ; -- [[textbooks]] ) { [[humus]] . append ( "[]" ) ; } return [[humus]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 991 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 425 / 555 / 11 / 991:  99%|█████████▉| 991/1000 [2:41:54<01:28,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 555 / 11 / 991:  99%|█████████▉| 992/1000 [2:41:58<01:18,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 556 / 11 / 992:  99%|█████████▉| 992/1000 [2:41:58<01:18,  9.80s/it][Succeeded / Failed / Skipped / Total] 425 / 556 / 11 / 992:  99%|█████████▉| 993/1000 [2:42:20<01:08,  9.81s/it][Succeeded / Failed / Skipped / Total] 426 / 556 / 11 / 993:  99%|█████████▉| 993/1000 [2:42:20<01:08,  9.81s/it][Succeeded / Failed / Skipped / Total] 426 / 556 / 11 / 993:  99%|█████████▉| 994/1000 [2:42:39<00:58,  9.82s/it][Succeeded / Failed / Skipped / Total] 426 / 557 / 11 / 994:  99%|█████████▉| 994/1000 [2:42:39<00:58,  9.82s/it][Succeeded / Failed / Skipped / Total] 426 / 557 / 11 / 994: 100%|█████████▉| 995/1000 [2:42:45<00:49,  9.82s/it][Succeeded / Failed / Skipped / Total] 426 / 558 / 11 / 995: 100%|█████████▉| 995/1000 [2:42:45<00:49,  9.82s/it][Succeeded / Failed / Skipped / Total] 426 / 558 / 11 / 995: 100%|█████████▉| 996/1000 [2:43:08<00:39,  9.83s/it][Succeeded / Failed / Skipped / Total] 426 / 559 / 11 / 996: 100%|█████████▉| 996/1000 [2:43:08<00:39,  9.83s/it][Succeeded / Failed / Skipped / Total] 426 / 559 / 11 / 996: 100%|█████████▉| 997/1000 [2:43:21<00:29,  9.83s/it]Appends the descriptor to the string builder . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[appendDescriptor]] ( final StringBuilder [[stringBuilder]] ) { if ( sort == OBJECT ) { [[stringBuilder]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[stringBuilder]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[stringBuilder]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void [[experiments]] ( final StringBuilder [[timmer]] ) { if ( sort == OBJECT ) { [[timmer]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[timmer]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[timmer]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 992 ---------------------------------------------
Initialize the todo files and folders . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[init]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int [[index]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ [[index]] ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[index]] != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void [[housewarming]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int [[mcclung]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ [[mcclung]] ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[mcclung]] != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 993 ---------------------------------------------
Gets the method descriptor . --> Exploration of a supercalifragilisticexpialidocious --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Type [[returnType]] , final Type ... argumentTypes ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; [[returnType]] . appendDescriptor ( [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String [[exploration]] ( final Type [[supercalifragilisticexpialidocious]] , final Type ... argumentTypes ) { StringBuilder [[soirée]] = new StringBuilder ( ) ; [[soirée]] . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( [[soirée]] ) ; } [[soirée]] . append ( ' ' ) ; [[supercalifragilisticexpialidocious]] . appendDescriptor ( [[soirée]] ) ; return [[soirée]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 994 ---------------------------------------------
Mark this transaction as rollback only . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[skateboarder]] ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 995 ---------------------------------------------
Gets the constructor descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 996 ---------------------------------------------
Gets the method descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 997 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 426 / 560 / 11 / 997: 100%|█████████▉| 997/1000 [2:43:21<00:29,  9.83s/it][Succeeded / Failed / Skipped / Total] 426 / 560 / 11 / 997: 100%|█████████▉| 998/1000 [2:43:31<00:19,  9.83s/it][Succeeded / Failed / Skipped / Total] 426 / 561 / 11 / 998: 100%|█████████▉| 998/1000 [2:43:31<00:19,  9.83s/it][Succeeded / Failed / Skipped / Total] 426 / 561 / 11 / 998: 100%|█████████▉| 999/1000 [2:43:38<00:09,  9.83s/it][Succeeded / Failed / Skipped / Total] 426 / 562 / 11 / 999: 100%|█████████▉| 999/1000 [2:43:38<00:09,  9.83s/it][Succeeded / Failed / Skipped / Total] 426 / 562 / 11 / 999: 100%|██████████| 1000/1000 [2:43:47<00:00,  9.83s/it][Succeeded / Failed / Skipped / Total] 426 / 563 / 11 / 1000: 100%|██████████| 1000/1000 [2:43:47<00:00,  9.83s/it]Attack(
  (search_method): RandomSearch(
    (trials):  10
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapRandom(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
  (is_black_box):  True
) 

[Succeeded / Failed / Skipped / Total] 426 / 563 / 11 / 1000: 100%|██████████| 1000/1000 [2:43:51<00:00,  9.83s/it]Returns the number of arguments and return sizes for the given method descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String methodDescriptor ) { int [[argumentsSize]] = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[jeet]] ( final String methodDescriptor ) { int [[focuses]] = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 998 ---------------------------------------------
Rollback all resources . --> [[[FAILED]]]

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 999 ---------------------------------------------
Request a resource . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[E]] > [[E]] requestResource ( final Class < [[E]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[E]] resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[E]] > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < [[impropriety]] > [[impropriety]] requestResource ( final Class < [[impropriety]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[impropriety]] resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[impropriety]] > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .
--------------------------------------------- Result 1000 ---------------------------------------------
Commit or rollback all resources . --> [[[FAILED]]]

[[[[Adv]]]]: protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

+-------------------------------+---------+
| Attack Results                |         |
+-------------------------------+---------+
| Number of successful attacks: | 426     |
| Number of failed attacks:     | 563     |
| Number of skipped attacks:    | 11      |
| Original accuracy:            | 98.9%   |
| Accuracy under attack:        | 56.3%   |
| Attack success rate:          | 43.07%  |
| Average perturbed word %:     | 62.12%  |
| Average num. words per input: | 3.91    |
| Avg num queries:              | 1190.92 |
| Original BLEU-4:              | 19.14   |
| Perturbed BLEU-4:             | 4.59    |
+-------------------------------+---------+

