Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertForMaskedLM: ['cls.seq_relationship.weight', 'cls.seq_relationship.bias']
- This IS expected if you are initializing BertForMaskedLM from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing BertForMaskedLM from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
textattack: Running 1 worker(s) on 1 GPU(s).
textattack: Worklist size: 2690
textattack: Worklist candidate size: 0
  0%|          | 0/2690 [00:00<?, ?it/s]  0%|          | 1/2690 [00:03<2:51:00,  3.82s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/2690 [00:03<2:51:21,  3.82s/it]--------------------------------------------- Result 1 ---------------------------------------------
[[0 (50%)]] --> [[1 (54%)]] --> Socre: 0.5386905670166016

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *[[pb]], AVCodecContext *codec, int size, int big_endian) { int id; uint64_t bitrate; if (size < 14) { avpriv_request_sample(codec, "wav header size < 14"); return AVERROR_INVALIDDATA; } codec->codec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) { id = avio_rl16([[pb]]); if (id != 0x0165) { codec->channels = avio_rl16([[pb]]); codec->sample_rate = avio_rl32([[pb]]); bitrate = avio_rl32([[pb]]) * 8LL; codec->block_align = avio_rl16([[pb]]); } } else { id = avio_rb16([[pb]]); codec->channels = avio_rb16([[pb]]); codec->sample_rate = avio_rb32([[pb]]); bitrate = avio_rb32([[pb]]) * 8LL; codec->block_align = avio_rb16([[pb]]); } if (size == 14) { codec->bits_per_coded_sample = 8; } else { if (!big_endian) { codec->bits_per_coded_sample = avio_rl16([[pb]]); } else { codec->bits_per_coded_sample = avio_rb16([[pb]]); } } if (id == 0xFFFE) { codec->codec_tag = 0; } else { codec->codec_tag = id; codec->codec_id = ff_wav_codec_get_id(id, codec->bits_per_coded_sample); } if (size >= 18 && id != 0x0165) { int cbSize = avio_rl16([[pb]]); if (big_endian) { avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { parse_waveformatex([[pb]], codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { av_freep(&codec->extradata); if (ff_get_extradata(codec, [[pb]], cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } if (size > 0) avio_skip([[pb]], size); } else if (id == 0x0165 && size >= 32) { int nb_streams, i; size -= 4; av_freep(&codec->extradata); if (ff_get_extradata(codec, [[pb]], size) < 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec->extradata + 4); codec->sample_rate = AV_RL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i < nb_streams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INT_MAX) { if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; } else { av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec->bit_rate = 0; } } else { codec->bit_rate = bitrate; } if (codec->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec->sample_rate); return AVERROR_INVALIDDATA; } if (codec->codec_id == AV_CODEC_ID_AAC_LATM) { codec->channels = 0; codec->sample_rate = 0; } if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; return 0; }

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *[[rs]], AVCodecContext *codec, int size, int big_endian) { int id; uint64_t bitrate; if (size < 14) { avpriv_request_sample(codec, "wav header size < 14"); return AVERROR_INVALIDDATA; } codec->codec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) { id = avio_rl16([[rs]]); if (id != 0x0165) { codec->channels = avio_rl16([[rs]]); codec->sample_rate = avio_rl32([[rs]]); bitrate = avio_rl32([[rs]]) * 8LL; codec->block_align = avio_rl16([[rs]]); } } else { id = avio_rb16([[rs]]); codec->channels = avio_rb16([[rs]]); codec->sample_rate = avio_rb32([[rs]]); bitrate = avio_rb32([[rs]]) * 8LL; codec->block_align = avio_rb16([[rs]]); } if (size == 14) { codec->bits_per_coded_sample = 8; } else { if (!big_endian) { codec->bits_per_coded_sample = avio_rl16([[rs]]); } else { codec->bits_per_coded_sample = avio_rb16([[rs]]); } } if (id == 0xFFFE) { codec->codec_tag = 0; } else { codec->codec_tag = id; codec->codec_id = ff_wav_codec_get_id(id, codec->bits_per_coded_sample); } if (size >= 18 && id != 0x0165) { int cbSize = avio_rl16([[rs]]); if (big_endian) { avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { parse_waveformatex([[rs]], codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { av_freep(&codec->extradata); if (ff_get_extradata(codec, [[rs]], cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } if (size > 0) avio_skip([[rs]], size); } else if (id == 0x0165 && size >= 32) { int nb_streams, i; size -= 4; av_freep(&codec->extradata); if (ff_get_extradata(codec, [[rs]], size) < 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec->extradata + 4); codec->sample_rate = AV_RL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i < nb_streams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INT_MAX) { if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; } else { av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec->bit_rate = 0; } } else { codec->bit_rate = bitrate; } if (codec->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec->sample_rate); return AVERROR_INVALIDDATA; } if (codec->codec_id == AV_CODEC_ID_AAC_LATM) { codec->channels = 0; codec->sample_rate = 0; } if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; return 0; }
--------------------------------------------- Result 2 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 0 / 1 / 2:   0%|          | 2/2690 [00:03<1:25:57,  1.92s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 2 / 3:   0%|          | 3/2690 [00:03<57:36,  1.29s/it]  [[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *xendev) { int i; Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev); V9fsState *s = &xen_9pdev->state; QemuOpts *fsdev; if (xenstore_read_fe_int(&xen_9pdev->xendev, "num-rings", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) { return -1; } xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing)); for (i = 0; i < xen_9pdev->num_rings; i++) { char *str; int ring_order; xen_9pdev->rings[i].priv = xen_9pdev; xen_9pdev->rings[i].evtchn = -1; xen_9pdev->rings[i].local_port = -1; str = g_strdup_printf("ring-ref%u", i); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) { goto out; } str = g_strdup_printf("event-channel-%u", i); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) { goto out; } xen_9pdev->rings[i].intf = xengnttab_map_grant_ref( xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[i].intf) { goto out; } ring_order = xen_9pdev->rings[i].intf->ring_order; if (ring_order > MAX_RING_ORDER) { goto out; } xen_9pdev->rings[i].ring_order = ring_order; xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs( xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[i].data) { goto out; } xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data; xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE(ring_order); xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]); xen_9pdev->rings[i].out_cons = 0; xen_9pdev->rings[i].out_size = 0; xen_9pdev->rings[i].inprogress = "False" != "False"; xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0); if (xen_9pdev->rings[i].evtchndev == NULL) { goto out; } fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC); xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn); if (xen_9pdev->rings[i].local_port == -1) { xen_pv_printf(xendev, 0, "xenevtchn_bind_interdomain failed port=%d\n", xen_9pdev->rings[i].evtchn); goto out; } xen_pv_printf(xendev, 2, "bind evtchn port %d\n", xendev->local_port); qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]); } xen_9pdev->security_model = xenstore_read_be_str(xendev, "security_model"); xen_9pdev->path = xenstore_read_be_str(xendev, "path"); xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf("xen9p%d", xendev->dev); xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s->fsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", xen_9pdev->path, NULL); qemu_opt_set(fsdev, "security_model", xen_9pdev->security_model, NULL); qemu_opts_set_id(fsdev, s->fsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free(xendev); return -1; }
--------------------------------------------- Result 3 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub, int pred_order) { int p, porder, psize; int i, part_end; int count = 0; count += 8; if (sub->type == FLAC_SUBFRAME_CONSTANT) { count += sub->obits; } else if (sub->type == FLAC_SUBFRAME_VERBATIM) { count += s->frame.blocksize * sub->obits; } else { count += pred_order * sub->obits; if (sub->type == FLAC_SUBFRAME_LPC) count += 4 + 5 + pred_order * s->options.lpc_coeff_precision; count += 2; porder = sub->rc.porder; psize = s->frame.blocksize >> porder; count += 4; i = pred_order; part_end = psize; for (p = 0; p < 1 << porder; p++) { int k = sub->rc.params[p]; count += 4; count += rice_count_exact(&sub->residual[i], part_end - i, k); i = part_end; part_end = FFMIN(s->frame.blocksize, part_end + psize); } } return count; }
--------------------------------------------- Result 4 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 0 / 3 / 4:   0%|          | 4/2690 [00:03<43:30,  1.03it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 4 / 5:   0%|          | 5/2690 [00:03<34:59,  1.28it/s]textattack: Exception encountered for input "OrderedDict([('adv', 'static uint32_t drc_set_unusable(sPAPRDRConnector *@R_1@) { @R_1@->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if (@R_1@->awaiting_release) { uint32_t @R_0@ = spapr_drc_index(@R_1@); trace_spapr_drc_set_allocation_state_finalizing(@R_0@); spapr_drc_detach(@R_1@); } return RTAS_OUT_SUCCESS; }')])".
textattack: Traceback (most recent call last):
  File "/home/zzr/CodeAttack/codeattack/attacker.py", line 590, in attack_from_queue
    result = attack.attack(example, ground_truth_output)
  File "/home/zzr/CodeAttack/codeattack/attack.py", line 423, in attack
    result = self._attack(goal_function_result)
  File "/home/zzr/CodeAttack/codeattack/attack.py", line 372, in _attack
    final_result = self.search_method(initial_result)
  File "/home/zzr/CodeAttack/codeattack/search_methods/search_method.py", line 36, in __call__
    result = self.perform_search(initial_result)
  File "/home/zzr/CodeAttack/codeattack/search_methods/greedy_word_swap_wir.py", line 237, in perform_search
    results, search_over = self.get_goal_results(transformed_text_candidates)
  File "/home/zzr/CodeAttack/codeattack/goal_functions/goal_function.py", line 96, in get_results
    model_outputs = self._call_model(attacked_text_list)
  File "/home/zzr/CodeAttack/codeattack/goal_functions/goal_function.py", line 216, in _call_model
    outputs = self._call_model_uncached(uncached_list)
  File "/home/zzr/CodeAttack/codeattack/goal_functions/goal_function.py", line 165, in _call_model_uncached
    batch_preds = self.model(batch)
  File "/home/zzr/CodeAttack/models/codet5_models.py", line 463, in __call__
    outputs = self.model(input_ids=code_ids)
  File "/home/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/home/zzr/CodeAttack/models/codet5_models.py", line 414, in forward
    vec = self.get_t5_vec(input_ids)
  File "/home/zzr/CodeAttack/models/codet5_models.py", line 400, in get_t5_vec
    outputs = self.encoder(input_ids=source_ids, attention_mask=attention_mask,
  File "/home/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/home/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/transformers/models/t5/modeling_t5.py", line 1641, in forward
    loss = loss_fct(lm_logits.view(-1, lm_logits.size(-1)), labels.view(-1))
  File "/home/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/home/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/loss.py", line 1047, in forward
    return F.cross_entropy(input, target, weight=self.weight,
  File "/home/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/functional.py", line 2693, in cross_entropy
    return nll_loss(log_softmax(input, 1), target, weight, None, ignore_index, None, reduction)
  File "/home/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/functional.py", line 1672, in log_softmax
    ret = input.log_softmax(dim)
RuntimeError: CUDA out of memory. Tried to allocate 1.53 GiB (GPU 0; 11.77 GiB total capacity; 5.53 GiB already allocated; 835.06 MiB free; 7.37 GiB reserved in total by PyTorch)

