textattack: Running 4 worker(s) on 4 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s]  0%|          | 1/1000 [00:17<4:46:34, 17.21s/it][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/1000 [00:17<4:46:35, 17.21s/it][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 2/1000 [06:59<58:08:39, 209.74s/it][Succeeded / Failed / Skipped / Total] 0 / 2 / 0 / 2:   0%|          | 2/1000 [06:59<58:08:39, 209.74s/it][Succeeded / Failed / Skipped / Total] 0 / 2 / 0 / 2:   0%|          | 3/1000 [13:37<75:30:02, 272.62s/it][Succeeded / Failed / Skipped / Total] 0 / 3 / 0 / 3:   0%|          | 3/1000 [13:37<75:30:03, 272.62s/it][Succeeded / Failed / Skipped / Total] 0 / 3 / 0 / 3:   0%|          | 4/1000 [14:35<60:32:18, 218.81s/it][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 4/1000 [14:35<60:32:18, 218.81s/it][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 5/1000 [14:46<48:59:43, 177.27s/it][Succeeded / Failed / Skipped / Total] 1 / 4 / 0 / 5:   0%|          | 5/1000 [14:46<48:59:43, 177.27s/it][Succeeded / Failed / Skipped / Total] 1 / 4 / 0 / 5:   1%|          | 6/1000 [16:37<45:54:21, 166.26s/it][Succeeded / Failed / Skipped / Total] 2 / 4 / 0 / 6:   1%|          | 6/1000 [16:37<45:54:21, 166.26s/it][Succeeded / Failed / Skipped / Total] 2 / 4 / 0 / 6:   1%|          | 7/1000 [18:51<44:34:44, 161.62s/it]--------------------------------------------- Result 1 ---------------------------------------------
Creates a ReplayableObservable that can be used to replay a ConnectableObservable . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 2 ---------------------------------------------
Wraps an ObservableSource . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 3 ---------------------------------------------
Creates a new unicast processor . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 4 ---------------------------------------------
Try a scalar x map subscribe . --> Wakaba wakaba wakaba wakaba wakaba --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[wakaba]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 5 ---------------------------------------------
Returns an observable that is sorted by the specified comparator . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 6 ---------------------------------------------
Creates a Flowable that maps a single value to a single value . --> Kobayashi - > Flowable --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[kobayashi]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 5 / 0 / 7:   1%|          | 7/1000 [18:51<44:34:44, 161.62s/it][Succeeded / Failed / Skipped / Total] 2 / 5 / 0 / 7:   1%|          | 8/1000 [22:05<45:39:01, 165.67s/it][Succeeded / Failed / Skipped / Total] 2 / 6 / 0 / 8:   1%|          | 8/1000 [22:05<45:39:02, 165.67s/it][Succeeded / Failed / Skipped / Total] 2 / 6 / 0 / 8:   1%|          | 9/1000 [23:49<43:43:26, 158.84s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 9/1000 [23:49<43:43:26, 158.84s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 10/1000 [23:54<39:27:27, 143.48s/it][Succeeded / Failed / Skipped / Total] 3 / 7 / 0 / 10:   1%|          | 10/1000 [23:54<39:27:27, 143.48s/it][Succeeded / Failed / Skipped / Total] 3 / 7 / 0 / 10:   1%|          | 11/1000 [24:10<36:12:51, 131.82s/it][Succeeded / Failed / Skipped / Total] 3 / 8 / 0 / 11:   1%|          | 11/1000 [24:10<36:12:51, 131.82s/it][Succeeded / Failed / Skipped / Total] 3 / 8 / 0 / 11:   1%|          | 12/1000 [28:04<38:31:38, 140.38s/it][Succeeded / Failed / Skipped / Total] 3 / 9 / 0 / 12:   1%|          | 12/1000 [28:04<38:31:38, 140.38s/it][Succeeded / Failed / Skipped / Total] 3 / 9 / 0 / 12:   1%|▏         | 13/1000 [28:16<35:47:02, 130.52s/it][Succeeded / Failed / Skipped / Total] 4 / 9 / 0 / 13:   1%|▏         | 13/1000 [28:16<35:47:02, 130.52s/it][Succeeded / Failed / Skipped / Total] 4 / 9 / 0 / 13:   1%|▏         | 14/1000 [29:39<34:49:08, 127.13s/it]Perform a fast path ordered emit . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 8 ---------------------------------------------
Reset the scheduler . --> [[[FAILED]]]

[[[[Adv]]]]: public static void reset ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void reset ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 9 ---------------------------------------------
Retry a Maybe by a given number of times . --> Retry a sequence of items for a given number of seasons --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[times]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[times]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[seasons]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[seasons]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 10 ---------------------------------------------
Creates a new unicast processor . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 11 ---------------------------------------------
Throws a NullPointerException if the object is null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 12 ---------------------------------------------
Creates a Maybe from a Completable source . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 13 ---------------------------------------------
Creates a function that just returns the given value . --> Françoise françoise --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[n]] , U > Function < [[n]] , U > [[françoise]] ( U [[valuing]] ) { return new JustValue < [[n]] , U > ( [[valuing]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 14 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 10 / 0 / 14:   1%|▏         | 14/1000 [29:39<34:49:08, 127.13s/it][Succeeded / Failed / Skipped / Total] 4 / 10 / 0 / 14:   2%|▏         | 15/1000 [30:26<33:18:29, 121.74s/it][Succeeded / Failed / Skipped / Total] 5 / 10 / 0 / 15:   2%|▏         | 15/1000 [30:26<33:18:29, 121.74s/it][Succeeded / Failed / Skipped / Total] 5 / 10 / 0 / 15:   2%|▏         | 16/1000 [34:03<34:54:47, 127.73s/it][Succeeded / Failed / Skipped / Total] 5 / 11 / 0 / 16:   2%|▏         | 16/1000 [34:03<34:54:47, 127.73s/it][Succeeded / Failed / Skipped / Total] 5 / 11 / 0 / 16:   2%|▏         | 17/1000 [37:34<36:12:33, 132.61s/it][Succeeded / Failed / Skipped / Total] 6 / 11 / 0 / 17:   2%|▏         | 17/1000 [37:34<36:12:33, 132.61s/it][Succeeded / Failed / Skipped / Total] 6 / 11 / 0 / 17:   2%|▏         | 18/1000 [39:39<36:03:24, 132.18s/it][Succeeded / Failed / Skipped / Total] 6 / 12 / 0 / 18:   2%|▏         | 18/1000 [39:39<36:03:24, 132.18s/it][Succeeded / Failed / Skipped / Total] 6 / 12 / 0 / 18:   2%|▏         | 19/1000 [46:01<39:36:19, 145.34s/it][Succeeded / Failed / Skipped / Total] 6 / 13 / 0 / 19:   2%|▏         | 19/1000 [46:01<39:36:19, 145.34s/it]