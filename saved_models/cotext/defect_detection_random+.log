textattack: Running 8 worker(s) on 8 GPU(s).
textattack: Worklist size: 2690
textattack: Worklist candidate size: 0
  0%|          | 0/2690 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 1 / 1:   0%|          | 1/2690 [00:00<00:01, 2193.67it/s]--------------------------------------------- Result 1 ---------------------------------------------
[[1 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec, int size, int big_endian) OPEN_CURLY_TOKEN int id; uint64_t bitrate; if (size SMALLER_TOKEN 14) OPEN_CURLY_TOKEN avpriv_request_sample(codec, "wav header size SMALLER_TOKEN 14"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN codec-GREATER_TOKENcodec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) OPEN_CURLY_TOKEN id = avio_rl16(pb); if (id != 0x0165) OPEN_CURLY_TOKEN codec-GREATER_TOKENchannels = avio_rl16(pb); codec-GREATER_TOKENsample_rate = avio_rl32(pb); bitrate = avio_rl32(pb) * 8LL; codec-GREATER_TOKENblock_align = avio_rl16(pb); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN id = avio_rb16(pb); codec-GREATER_TOKENchannels = avio_rb16(pb); codec-GREATER_TOKENsample_rate = avio_rb32(pb); bitrate = avio_rb32(pb) * 8LL; codec-GREATER_TOKENblock_align = avio_rb16(pb); CLOSE_CURLY_TOKEN if (size == 14) OPEN_CURLY_TOKEN codec-GREATER_TOKENbits_per_coded_sample = 8; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (!big_endian) OPEN_CURLY_TOKEN codec-GREATER_TOKENbits_per_coded_sample = avio_rl16(pb); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN codec-GREATER_TOKENbits_per_coded_sample = avio_rb16(pb); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (id == 0xFFFE) OPEN_CURLY_TOKEN codec-GREATER_TOKENcodec_tag = 0; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN codec-GREATER_TOKENcodec_tag = id; codec-GREATER_TOKENcodec_id = ff_wav_codec_get_id(id, codec-GREATER_TOKENbits_per_coded_sample); CLOSE_CURLY_TOKEN if (size GREATER_TOKEN= 18 && id != 0x0165) OPEN_CURLY_TOKEN int cbSize = avio_rl16(pb); if (big_endian) OPEN_CURLY_TOKEN avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; CLOSE_CURLY_TOKEN size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize GREATER_TOKEN= 22 && id == 0xfffe) OPEN_CURLY_TOKEN parse_waveformatex(pb, codec); cbSize -= 22; size -= 22; CLOSE_CURLY_TOKEN if (cbSize GREATER_TOKEN 0) OPEN_CURLY_TOKEN av_freep(&codec-GREATER_TOKENextradata); if (ff_get_extradata(codec, pb, cbSize) SMALLER_TOKEN 0) return AVERROR(ENOMEM); size -= cbSize; CLOSE_CURLY_TOKEN if (size GREATER_TOKEN 0) avio_skip(pb, size); CLOSE_CURLY_TOKEN else if (id == 0x0165 && size GREATER_TOKEN= 32) OPEN_CURLY_TOKEN int nb_streams, i; size -= 4; av_freep(&codec-GREATER_TOKENextradata); if (ff_get_extradata(codec, pb, size) SMALLER_TOKEN 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec-GREATER_TOKENextradata + 4); codec-GREATER_TOKENsample_rate = AV_RL32(codec-GREATER_TOKENextradata + 12); codec-GREATER_TOKENchannels = 0; bitrate = 0; if (size SMALLER_TOKEN 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i SMALLER_TOKEN nb_streams; i++) codec-GREATER_TOKENchannels += codec-GREATER_TOKENextradataOPEN_SQUARE_TOKEN8 + i * 20 + 17CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN if (bitrate GREATER_TOKEN INT_MAX) OPEN_CURLY_TOKEN if (s-GREATER_TOKENerror_recognition & AV_EF_EXPLODE) OPEN_CURLY_TOKEN av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec-GREATER_TOKENbit_rate = 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN codec-GREATER_TOKENbit_rate = bitrate; CLOSE_CURLY_TOKEN if (codec-GREATER_TOKENsample_rate SMALLER_TOKEN= 0) OPEN_CURLY_TOKEN av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec-GREATER_TOKENsample_rate); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if (codec-GREATER_TOKENcodec_id == AV_CODEC_ID_AAC_LATM) OPEN_CURLY_TOKEN codec-GREATER_TOKENchannels = 0; codec-GREATER_TOKENsample_rate = 0; CLOSE_CURLY_TOKEN if (codec-GREATER_TOKENcodec_id == AV_CODEC_ID_ADPCM_G726 && codec-GREATER_TOKENsample_rate) codec-GREATER_TOKENbits_per_coded_sample = codec-GREATER_TOKENbit_rate / codec-GREATER_TOKENsample_rate; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 2 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 0 / 2 / 2:   0%|          | 2/2690 [00:00<00:01, 2638.76it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 3 / 3:   0%|          | 3/2690 [00:00<00:00, 3096.19it/s][[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *xendev) OPEN_CURLY_TOKEN int i; Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev); V9fsState *s = &xen_9pdev-GREATER_TOKENstate; QemuOpts *fsdev; if (xenstore_read_fe_int(&xen_9pdev-GREATER_TOKENxendev, "num-rings", &xen_9pdev-GREATER_TOKENnum_rings) == -1 || xen_9pdev-GREATER_TOKENnum_rings GREATER_TOKEN MAX_RINGS || xen_9pdev-GREATER_TOKENnum_rings SMALLER_TOKEN 1) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN xen_9pdev-GREATER_TOKENrings = g_malloc0(xen_9pdev-GREATER_TOKENnum_rings * sizeof(Xen9pfsRing)); for (i = 0; i SMALLER_TOKEN xen_9pdev-GREATER_TOKENnum_rings; i++) OPEN_CURLY_TOKEN char *str; int ring_order; xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.priv = xen_9pdev; xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchn = -1; xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.local_port = -1; str = g_strdup_printf("ring-ref%u", i); if (xenstore_read_fe_int(&xen_9pdev-GREATER_TOKENxendev, str, &xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.ref) == -1) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN str = g_strdup_printf("event-channel-%u", i); if (xenstore_read_fe_int(&xen_9pdev-GREATER_TOKENxendev, str, &xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchn) == -1) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.intf = xengnttab_map_grant_ref( xen_9pdev-GREATER_TOKENxendev.gnttabdev, xen_9pdev-GREATER_TOKENxendev.dom, xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.ref, PROT_READ | PROT_WRITE); if (!xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.intf) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN ring_order = xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.intf-GREATER_TOKENring_order; if (ring_order GREATER_TOKEN MAX_RING_ORDER) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.ring_order = ring_order; xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.data = xengnttab_map_domain_grant_refs( xen_9pdev-GREATER_TOKENxendev.gnttabdev, (1 SMALLER_TOKENSMALLER_TOKEN ring_order), xen_9pdev-GREATER_TOKENxendev.dom, xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.intf-GREATER_TOKENref, PROT_READ | PROT_WRITE); if (!xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.data) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.ring.in = xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.data; xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.ring.out = xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.data + XEN_FLEX_RING_SIZE(ring_order); xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.out_cons = 0; xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.out_size = 0; xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.inprogress = "False" != "False"; xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchndev = xenevtchn_open(NULL, 0); if (xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchndev == NULL) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN fcntl(xenevtchn_fd(xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchndev), F_SETFD, FD_CLOEXEC); xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.local_port = xenevtchn_bind_interdomain (xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchndev, xendev-GREATER_TOKENdom, xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchn); if (xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.local_port == -1) OPEN_CURLY_TOKEN xen_pv_printf(xendev, 0, "xenevtchn_bind_interdomain failed port=%d\n", xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchn); goto out; CLOSE_CURLY_TOKEN xen_pv_printf(xendev, 2, "bind evtchn port %d\n", xendev-GREATER_TOKENlocal_port); qemu_set_fd_handler(xenevtchn_fd(xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev-GREATER_TOKENringsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN xen_9pdev-GREATER_TOKENsecurity_model = xenstore_read_be_str(xendev, "security_model"); xen_9pdev-GREATER_TOKENpath = xenstore_read_be_str(xendev, "path"); xen_9pdev-GREATER_TOKENid = s-GREATER_TOKENfsconf.fsdev_id = g_strdup_printf("xen9p%d", xendev-GREATER_TOKENdev); xen_9pdev-GREATER_TOKENtag = s-GREATER_TOKENfsconf.tag = xenstore_read_fe_str(xendev, "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s-GREATER_TOKENfsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", xen_9pdev-GREATER_TOKENpath, NULL); qemu_opt_set(fsdev, "security_model", xen_9pdev-GREATER_TOKENsecurity_model, NULL); qemu_opts_set_id(fsdev, s-GREATER_TOKENfsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free(xendev); return -1; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 3 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub, int pred_order) OPEN_CURLY_TOKEN int p, porder, psize; int i, part_end; int count = 0; count += 8; if (sub-GREATER_TOKENtype == FLAC_SUBFRAME_CONSTANT) OPEN_CURLY_TOKEN count += sub-GREATER_TOKENobits; CLOSE_CURLY_TOKEN else if (sub-GREATER_TOKENtype == FLAC_SUBFRAME_VERBATIM) OPEN_CURLY_TOKEN count += s-GREATER_TOKENframe.blocksize * sub-GREATER_TOKENobits; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN count += pred_order * sub-GREATER_TOKENobits; if (sub-GREATER_TOKENtype == FLAC_SUBFRAME_LPC) count += 4 + 5 + pred_order * s-GREATER_TOKENoptions.lpc_coeff_precision; count += 2; porder = sub-GREATER_TOKENrc.porder; psize = s-GREATER_TOKENframe.blocksize GREATER_TOKENGREATER_TOKEN porder; count += 4; i = pred_order; part_end = psize; for (p = 0; p SMALLER_TOKEN 1 SMALLER_TOKENSMALLER_TOKEN porder; p++) OPEN_CURLY_TOKEN int k = sub-GREATER_TOKENrc.paramsOPEN_SQUARE_TOKENpCLOSE_SQUARE_TOKEN; count += 4; count += rice_count_exact(&sub-GREATER_TOKENresidualOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, part_end - i, k); i = part_end; part_end = FFMIN(s-GREATER_TOKENframe.blocksize, part_end + psize); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return count; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 4 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 0 / 4 / 4:   0%|          | 4/2690 [00:00<00:00, 3236.97it/s][[1 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(QEMUMachineInitArgs *args) OPEN_CURLY_TOKEN ram_addr_t ram_size = args-GREATER_TOKENram_size; const char *cpu_model = args-GREATER_TOKENcpu_model; const char *kernel_filename = args-GREATER_TOKENkernel_filename; const char *kernel_cmdline = args-GREATER_TOKENkernel_cmdline; const char *initrd_filename = args-GREATER_TOKENinitrd_filename; const char *boot_device = args-GREATER_TOKENboot_order; PowerPCCPU *cpu; CPUPPCState *env; PCIHostState *phb; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); hwaddr rma_alloc_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; bool kernel_le = "False" != "False"; char *filename; msi_supported = "True" == "True"; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr-GREATER_TOKENphbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) OPEN_CURLY_TOKEN hw_error("qemu: Unable to create RMA\n"); exit(1); CLOSE_CURLY_TOKEN if (rma_alloc_size && (rma_alloc_size SMALLER_TOKEN ram_size)) OPEN_CURLY_TOKEN spapr-GREATER_TOKENrma_size = rma_alloc_size; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN spapr-GREATER_TOKENrma_size = ram_size; if (kvm_enabled()) OPEN_CURLY_TOKEN spapr-GREATER_TOKENvrma_adjust = 1; spapr-GREATER_TOKENrma_size = MIN(spapr-GREATER_TOKENrma_size, 0x10000000); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN rtas_limit = MIN(spapr-GREATER_TOKENrma_size, 0x80000000); spapr-GREATER_TOKENrtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr-GREATER_TOKENfdt_addr = spapr-GREATER_TOKENrtas_addr - FDT_MAX_SIZE; load_limit = spapr-GREATER_TOKENfdt_addr - FW_OVERHEAD; spapr-GREATER_TOKENhtab_shift = 18; while (spapr-GREATER_TOKENhtab_shift SMALLER_TOKEN= 46) OPEN_CURLY_TOKEN if ((1ULL SMALLER_TOKENSMALLER_TOKEN (spapr-GREATER_TOKENhtab_shift + 7)) GREATER_TOKEN= ram_size) OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN spapr-GREATER_TOKENhtab_shift++; CLOSE_CURLY_TOKEN spapr-GREATER_TOKENicp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads, XICS_IRQS); spapr-GREATER_TOKENnext_irq = XICS_IRQ_BASE; if (cpu_model == NULL) OPEN_CURLY_TOKEN cpu_model = kvm_enabled() ? "host" : "POWER7"; CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN smp_cpus; i++) OPEN_CURLY_TOKEN cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) OPEN_CURLY_TOKEN fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); CLOSE_CURLY_TOKEN env = &cpu-GREATER_TOKENenv; xics_cpu_setup(spapr-GREATER_TOKENicp, cpu); cpu_ppc_tb_init(env, TIMEBASE_FREQ); env-GREATER_TOKENmsr_mask &= ~(1 SMALLER_TOKENSMALLER_TOKEN 6); if (kvm_enabled()) OPEN_CURLY_TOKEN kvmppc_set_papr(cpu); CLOSE_CURLY_TOKEN qemu_register_reset(spapr_cpu_reset, cpu); CLOSE_CURLY_TOKEN spapr-GREATER_TOKENram_limit = ram_size; if (spapr-GREATER_TOKENram_limit GREATER_TOKEN rma_alloc_size) OPEN_CURLY_TOKEN ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr-GREATER_TOKENram_limit - rma_alloc_size; memory_region_init_ram(ram, NULL, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); CLOSE_CURLY_TOKEN filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr-GREATER_TOKENrtas_size = load_image_targphys(filename, spapr-GREATER_TOKENrtas_addr, rtas_limit - spapr-GREATER_TOKENrtas_addr); if (spapr-GREATER_TOKENrtas_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); CLOSE_CURLY_TOKEN if (spapr-GREATER_TOKENrtas_size GREATER_TOKEN RTAS_MAX_SIZE) OPEN_CURLY_TOKEN hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr-GREATER_TOKENrtas_size, RTAS_MAX_SIZE); exit(1); CLOSE_CURLY_TOKEN g_free(filename); spapr_events_init(spapr); spapr-GREATER_TOKENvio_bus = spapr_vio_bus_init(); for (i = 0; i SMALLER_TOKEN MAX_SERIAL_PORTS; i++) OPEN_CURLY_TOKEN if (serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN spapr_vty_create(spapr-GREATER_TOKENvio_bus, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN spapr_create_nvram(spapr); spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW); spapr_pci_rtas_init(); phb = spapr_create_phb(spapr, 0); for (i = 0; i SMALLER_TOKEN nb_nics; i++) OPEN_CURLY_TOKEN NICInfo *nd = &nd_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; if (!nd-GREATER_TOKENmodel) OPEN_CURLY_TOKEN nd-GREATER_TOKENmodel = g_strdup("ibmveth"); CLOSE_CURLY_TOKEN if (strcmp(nd-GREATER_TOKENmodel, "ibmveth") == 0) OPEN_CURLY_TOKEN spapr_vlan_create(spapr-GREATER_TOKENvio_bus, nd); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN pci_nic_init_nofail(&nd_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, phb-GREATER_TOKENbus, nd-GREATER_TOKENmodel, NULL); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN= drive_get_max_bus(IF_SCSI); i++) OPEN_CURLY_TOKEN spapr_vscsi_create(spapr-GREATER_TOKENvio_bus); CLOSE_CURLY_TOKEN if (spapr_vga_init(phb-GREATER_TOKENbus)) OPEN_CURLY_TOKEN spapr-GREATER_TOKENhas_graphics = "True" == "True"; CLOSE_CURLY_TOKEN if (usb_enabled(spapr-GREATER_TOKENhas_graphics)) OPEN_CURLY_TOKEN pci_create_simple(phb-GREATER_TOKENbus, -1, "pci-ohci"); if (spapr-GREATER_TOKENhas_graphics) OPEN_CURLY_TOKEN usbdevice_create("keyboard"); usbdevice_create("mouse"); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (spapr-GREATER_TOKENrma_size SMALLER_TOKEN (MIN_RMA_SLOF SMALLER_TOKENSMALLER_TOKEN 20)) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: pSeries SLOF firmware requires GREATER_TOKEN= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); CLOSE_CURLY_TOKEN if (kernel_filename) OPEN_CURLY_TOKEN uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0); kernel_le = kernel_size GREATER_TOKEN 0; CLOSE_CURLY_TOKEN if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); CLOSE_CURLY_TOKEN if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); CLOSE_CURLY_TOKEN if (initrd_filename) OPEN_CURLY_TOKEN initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN initrd_base = 0; initrd_size = 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (bios_name == NULL) OPEN_CURLY_TOKEN bios_name = FW_FILE_NAME; CLOSE_CURLY_TOKEN filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); CLOSE_CURLY_TOKEN g_free(filename); spapr-GREATER_TOKENentry_point = 0x100; vmstate_register(NULL, 0, &vmstate_spapr, spapr); register_savevm_live(NULL, "spapr/htab", -1, 1, &savevm_htab_handlers, spapr); spapr-GREATER_TOKENfdt_skel = spapr_create_fdt_skel(cpu_model, initrd_base, initrd_size, kernel_size, kernel_le, boot_device, kernel_cmdline, spapr-GREATER_TOKENepow_irq); assert(spapr-GREATER_TOKENfdt_skel != NULL); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 5 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 0 / 5 / 5:   0%|          | 5/2690 [00:00<00:00, 3445.30it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 5 / 6:   0%|          | 6/2690 [00:00<00:00, 3209.11it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 6 / 7:   0%|          | 7/2690 [00:00<00:00, 3382.50it/s][[1 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size) OPEN_CURLY_TOKEN Mpeg1Context *s1 = avctx-GREATER_TOKENpriv_data; MpegEncContext *s = &s1-GREATER_TOKENmpeg_enc_ctx; int width, height, i, v, j; float aspect; init_get_bits(&s-GREATER_TOKENgb, buf, buf_size); width = get_bits(&s-GREATER_TOKENgb, 12); height = get_bits(&s-GREATER_TOKENgb, 12); s-GREATER_TOKENaspect_ratio_info= get_bits(&s-GREATER_TOKENgb, 4); if(!s-GREATER_TOKENmpeg2)OPEN_CURLY_TOKEN aspect= mpeg1_aspectOPEN_SQUARE_TOKENs-GREATER_TOKENaspect_ratio_infoCLOSE_SQUARE_TOKEN; if(aspect!=0.0) avctx-GREATER_TOKENaspect_ratio= width/(aspect*height); CLOSE_CURLY_TOKEN s-GREATER_TOKENframe_rate_index = get_bits(&s-GREATER_TOKENgb, 4); if (s-GREATER_TOKENframe_rate_index == 0) return -1; s-GREATER_TOKENbit_rate = get_bits(&s-GREATER_TOKENgb, 18) * 400; if (get_bits1(&s-GREATER_TOKENgb) == 0) return -1; if (width SMALLER_TOKEN= 0 || height SMALLER_TOKEN= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s-GREATER_TOKENwidth || height != s-GREATER_TOKENheight) OPEN_CURLY_TOKEN s-GREATER_TOKENout_format = FMT_MPEG1; if (s1-GREATER_TOKENmpeg_enc_ctx_allocated) OPEN_CURLY_TOKEN MPV_common_end(s); CLOSE_CURLY_TOKEN s-GREATER_TOKENwidth = width; s-GREATER_TOKENheight = height; avctx-GREATER_TOKENhas_b_frames= 1; s-GREATER_TOKENavctx = avctx; avctx-GREATER_TOKENwidth = width; avctx-GREATER_TOKENheight = height; if (s-GREATER_TOKENframe_rate_index GREATER_TOKEN= 9) OPEN_CURLY_TOKEN avctx-GREATER_TOKENframe_rate = 25 * FRAME_RATE_BASE; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN avctx-GREATER_TOKENframe_rate = frame_rate_tabOPEN_SQUARE_TOKENs-GREATER_TOKENframe_rate_indexCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN s-GREATER_TOKENframe_rate = avctx-GREATER_TOKENframe_rate; avctx-GREATER_TOKENbit_rate = s-GREATER_TOKENbit_rate; if (MPV_common_init(s) SMALLER_TOKEN 0) return -1; s1-GREATER_TOKENmpeg_enc_ctx_allocated = 1; CLOSE_CURLY_TOKEN skip_bits(&s-GREATER_TOKENgb, 10); skip_bits(&s-GREATER_TOKENgb, 1); if (get_bits1(&s-GREATER_TOKENgb)) OPEN_CURLY_TOKEN for(i=0;iSMALLER_TOKEN64;i++) OPEN_CURLY_TOKEN v = get_bits(&s-GREATER_TOKENgb, 8); j = s-GREATER_TOKENintra_scantable.permutatedOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; s-GREATER_TOKENintra_matrixOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = v; s-GREATER_TOKENchroma_intra_matrixOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = v; CLOSE_CURLY_TOKEN #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;iSMALLER_TOKEN64;i++) dprintf(" %d", s-GREATER_TOKENintra_matrixOPEN_SQUARE_TOKENs-GREATER_TOKENintra_scantable.permutatedOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN); printf("\n"); #endif CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN for(i=0;iSMALLER_TOKEN64;i++) OPEN_CURLY_TOKEN int j= s-GREATER_TOKENidct_permutationOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; v = ff_mpeg1_default_intra_matrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; s-GREATER_TOKENintra_matrixOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = v; s-GREATER_TOKENchroma_intra_matrixOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = v; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (get_bits1(&s-GREATER_TOKENgb)) OPEN_CURLY_TOKEN for(i=0;iSMALLER_TOKEN64;i++) OPEN_CURLY_TOKEN v = get_bits(&s-GREATER_TOKENgb, 8); j = s-GREATER_TOKENintra_scantable.permutatedOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; s-GREATER_TOKENinter_matrixOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = v; s-GREATER_TOKENchroma_inter_matrixOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = v; CLOSE_CURLY_TOKEN #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;iSMALLER_TOKEN64;i++) dprintf(" %d", s-GREATER_TOKENinter_matrixOPEN_SQUARE_TOKENs-GREATER_TOKENintra_scantable.permutatedOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN); printf("\n"); #endif CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN for(i=0;iSMALLER_TOKEN64;i++) OPEN_CURLY_TOKEN int j= s-GREATER_TOKENidct_permutationOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; v = ff_mpeg1_default_non_intra_matrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; s-GREATER_TOKENinter_matrixOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = v; s-GREATER_TOKENchroma_inter_matrixOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = v; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN s-GREATER_TOKENprogressive_sequence = 1; s-GREATER_TOKENprogressive_frame = 1; s-GREATER_TOKENpicture_structure = PICT_FRAME; s-GREATER_TOKENframe_pred_frame_dct = 1; s-GREATER_TOKENmpeg2 = 0; avctx-GREATER_TOKENsub_id = 1; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 6 ---------------------------------------------
[[0 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *[[drc]]) OPEN_CURLY_TOKEN [[drc]]-GREATER_TOKENallocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if ([[drc]]-GREATER_TOKENawaiting_release) OPEN_CURLY_TOKEN uint32_t [[drc_index]] = spapr_drc_index([[drc]]); trace_spapr_drc_set_allocation_state_finalizing([[drc_index]]); spapr_drc_detach([[drc]]); CLOSE_CURLY_TOKEN return RTAS_OUT_SUCCESS; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *[[survives]]) OPEN_CURLY_TOKEN [[survives]]-GREATER_TOKENallocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if ([[survives]]-GREATER_TOKENawaiting_release) OPEN_CURLY_TOKEN uint32_t [[shortly]] = spapr_drc_index([[survives]]); trace_spapr_drc_set_allocation_state_finalizing([[shortly]]); spapr_drc_detach([[survives]]); CLOSE_CURLY_TOKEN return RTAS_OUT_SUCCESS; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 7 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_read_request(SCSIDiskReq *r) OPEN_CURLY_TOKEN SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r-GREATER_TOKENreq.dev); uint32_t n; if (r-GREATER_TOKENsector_count == (uint32_t)-1) OPEN_CURLY_TOKEN DPRINTF("Read buf_len=%zd\n", r-GREATER_TOKENiov.iov_len); r-GREATER_TOKENsector_count = 0; scsi_req_data(&r-GREATER_TOKENreq, r-GREATER_TOKENiov.iov_len); return; CLOSE_CURLY_TOKEN DPRINTF("Read sector_count=%d\n", r-GREATER_TOKENsector_count); if (r-GREATER_TOKENsector_count == 0) OPEN_CURLY_TOKEN scsi_command_complete(r, GOOD, NO_SENSE); return; CLOSE_CURLY_TOKEN assert(r-GREATER_TOKENreq.aiocb == NULL); n = r-GREATER_TOKENsector_count; if (n GREATER_TOKEN SCSI_DMA_BUF_SIZE / 512) n = SCSI_DMA_BUF_SIZE / 512; r-GREATER_TOKENiov.iov_len = n * 512; qemu_iovec_init_external(&r-GREATER_TOKENqiov, &r-GREATER_TOKENiov, 1); r-GREATER_TOKENreq.aiocb = bdrv_aio_readv(s-GREATER_TOKENbs, r-GREATER_TOKENsector, &r-GREATER_TOKENqiov, n, scsi_read_complete, r); if (r-GREATER_TOKENreq.aiocb == NULL) OPEN_CURLY_TOKEN scsi_read_complete(r, -EIO); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 8 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 1 / 6 / 8:   0%|          | 8/2690 [00:00<00:01, 2617.55it/s][[1 (59%)]] --> [[0 (61%)]] --> Socre: 0.6061147451400757

[[[[Adv]]]]: static void lm32_evr_init(MachineState *machine) OPEN_CURLY_TOKEN const char *cpu_model = machine-GREATER_TOKENcpu_model; const char *kernel_filename = machine-GREATER_TOKENkernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq irqOPEN_SQUARE_TOKEN32CLOSE_SQUARE_TOKEN; ResetInfo *[[reset_info]]; int i; hwaddr flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; hwaddr ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; hwaddr timer0_base = 0x80002000; hwaddr uart0_base = 0x80006000; hwaddr timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; [[reset_info]] = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) OPEN_CURLY_TOKEN cpu_model = "lm32-full"; CLOSE_CURLY_TOKEN cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model)); if (cpu == NULL) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model); exit(1); CLOSE_CURLY_TOKEN env = &cpu-GREATER_TOKENenv; [[reset_info]]-GREATER_TOKENcpu = cpu; [[reset_info]]-GREATER_TOKENflash_base = flash_base; memory_region_allocate_system_memory(phys_ram, NULL, "lm32_evr.sdram", ram_size); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? blk_by_legacy_dinfo(dinfo) : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); env-GREATER_TOKENpic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0)); for (i = 0; i SMALLER_TOKEN 32; i++) OPEN_CURLY_TOKEN irqOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = qdev_get_gpio_in(env-GREATER_TOKENpic_state, i); CLOSE_CURLY_TOKEN lm32_uart_create(uart0_base, irqOPEN_SQUARE_TOKENuart0_irqCLOSE_SQUARE_TOKEN, serial_hdsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN); sysbus_create_simple("lm32-timer", timer0_base, irqOPEN_SQUARE_TOKENtimer0_irqCLOSE_SQUARE_TOKEN); sysbus_create_simple("lm32-timer", timer1_base, irqOPEN_SQUARE_TOKENtimer1_irqCLOSE_SQUARE_TOKEN); env-GREATER_TOKENjuart_state = lm32_juart_init(serial_hdsOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN); [[reset_info]]-GREATER_TOKENbootstrap_pc = flash_base; if (kernel_filename) OPEN_CURLY_TOKEN uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, EM_LATTICEMICO32, 0, 0); [[reset_info]]-GREATER_TOKENbootstrap_pc = entry; if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); [[reset_info]]-GREATER_TOKENbootstrap_pc = ram_base; CLOSE_CURLY_TOKEN if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN qemu_register_reset(main_cpu_reset, [[reset_info]]); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void lm32_evr_init(MachineState *machine) OPEN_CURLY_TOKEN const char *cpu_model = machine-GREATER_TOKENcpu_model; const char *kernel_filename = machine-GREATER_TOKENkernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq irqOPEN_SQUARE_TOKEN32CLOSE_SQUARE_TOKEN; ResetInfo *[[gof]]; int i; hwaddr flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; hwaddr ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; hwaddr timer0_base = 0x80002000; hwaddr uart0_base = 0x80006000; hwaddr timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; [[gof]] = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) OPEN_CURLY_TOKEN cpu_model = "lm32-full"; CLOSE_CURLY_TOKEN cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model)); if (cpu == NULL) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model); exit(1); CLOSE_CURLY_TOKEN env = &cpu-GREATER_TOKENenv; [[gof]]-GREATER_TOKENcpu = cpu; [[gof]]-GREATER_TOKENflash_base = flash_base; memory_region_allocate_system_memory(phys_ram, NULL, "lm32_evr.sdram", ram_size); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? blk_by_legacy_dinfo(dinfo) : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); env-GREATER_TOKENpic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0)); for (i = 0; i SMALLER_TOKEN 32; i++) OPEN_CURLY_TOKEN irqOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = qdev_get_gpio_in(env-GREATER_TOKENpic_state, i); CLOSE_CURLY_TOKEN lm32_uart_create(uart0_base, irqOPEN_SQUARE_TOKENuart0_irqCLOSE_SQUARE_TOKEN, serial_hdsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN); sysbus_create_simple("lm32-timer", timer0_base, irqOPEN_SQUARE_TOKENtimer0_irqCLOSE_SQUARE_TOKEN); sysbus_create_simple("lm32-timer", timer1_base, irqOPEN_SQUARE_TOKENtimer1_irqCLOSE_SQUARE_TOKEN); env-GREATER_TOKENjuart_state = lm32_juart_init(serial_hdsOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN); [[gof]]-GREATER_TOKENbootstrap_pc = flash_base; if (kernel_filename) OPEN_CURLY_TOKEN uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, EM_LATTICEMICO32, 0, 0); [[gof]]-GREATER_TOKENbootstrap_pc = entry; if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); [[gof]]-GREATER_TOKENbootstrap_pc = ram_base; CLOSE_CURLY_TOKEN if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN qemu_register_reset(main_cpu_reset, [[gof]]); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 9 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 1 / 7 / 9:   0%|          | 9/2690 [00:00<00:00, 2708.72it/s][Succeeded / Failed / Skipped / Total] 1 / 2 / 7 / 10:   0%|          | 10/2690 [00:00<00:00, 2698.17it/s][Succeeded / Failed / Skipped / Total] 1 / 2 / 8 / 11:   0%|          | 11/2690 [00:00<00:00, 2807.94it/s][Succeeded / Failed / Skipped / Total] 1 / 2 / 9 / 12:   0%|          | 12/2690 [00:00<00:00, 2919.47it/s][[0 (60%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vmdk_parse_extents(const char *desc, BlockDriverState *bs, const char *desc_file_path) OPEN_CURLY_TOKEN int ret; char accessOPEN_SQUARE_TOKEN11CLOSE_SQUARE_TOKEN; char typeOPEN_SQUARE_TOKEN11CLOSE_SQUARE_TOKEN; char fnameOPEN_SQUARE_TOKEN512CLOSE_SQUARE_TOKEN; const char *p = desc; int64_t sectors = 0; int64_t flat_offset; char extent_pathOPEN_SQUARE_TOKENPATH_MAXCLOSE_SQUARE_TOKEN; BlockDriverState *extent_file; Error *local_err = NULL; while (*p) OPEN_CURLY_TOKEN flat_offset = -1; ret = sscanf(p, "%10s %" SCNd64 " %10s \"%511OPEN_SQUARE_TOKEN^\n\r\"CLOSE_SQUARE_TOKEN\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret SMALLER_TOKEN 4 || strcmp(access, "RW")) OPEN_CURLY_TOKEN goto next_line; CLOSE_CURLY_TOKEN else if (!strcmp(type, "FLAT")) OPEN_CURLY_TOKEN if (ret != 5 || flat_offset SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return -EINVAL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (ret != 4) OPEN_CURLY_TOKEN return -EINVAL; CLOSE_CURLY_TOKEN if (sectors SMALLER_TOKEN= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) OPEN_CURLY_TOKEN goto next_line; CLOSE_CURLY_TOKEN path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); ret = bdrv_file_open(&extent_file, extent_path, NULL, bs-GREATER_TOKENopen_flags, &local_err); if (ret) OPEN_CURLY_TOKEN qerror_report_err(local_err); error_free(local_err); return ret; CLOSE_CURLY_TOKEN if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) OPEN_CURLY_TOKEN VmdkExtent *extent; ret = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, sectors, &extent); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN extent-GREATER_TOKENflat_start_offset = flat_offset SMALLER_TOKENSMALLER_TOKEN 9; CLOSE_CURLY_TOKEN else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) OPEN_CURLY_TOKEN ret = vmdk_open_sparse(bs, extent_file, bs-GREATER_TOKENopen_flags); if (ret) OPEN_CURLY_TOKEN bdrv_unref(extent_file); return ret; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN fprintf(stderr, "VMDK: Not supported extent type \"%s\""".\n", type); return -ENOTSUP; CLOSE_CURLY_TOKEN next_line: while (*p && *p != '\n') OPEN_CURLY_TOKEN p++; CLOSE_CURLY_TOKEN p++; CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 10 ---------------------------------------------
[[1 (90%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *[[avctx]], PNGDecContext *[[s]], uint32_t [[length]]) OPEN_CURLY_TOKEN int [[n]], i, r, g, b; if (([[length]] % 3) != 0 || [[length]] GREATER_TOKEN 256 * 3) return AVERROR_INVALIDDATA; [[n]] = [[length]] / 3; for (i = 0; i SMALLER_TOKEN [[n]]; i++) OPEN_CURLY_TOKEN r = bytestream2_get_byte(&[[s]]-GREATER_TOKENgb); g = bytestream2_get_byte(&[[s]]-GREATER_TOKENgb); b = bytestream2_get_byte(&[[s]]-GREATER_TOKENgb); [[s]]-GREATER_TOKENpaletteOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = (0xFFU SMALLER_TOKENSMALLER_TOKEN 24) | (r SMALLER_TOKENSMALLER_TOKEN 16) | (g SMALLER_TOKENSMALLER_TOKEN 8) | b; CLOSE_CURLY_TOKEN for (; i SMALLER_TOKEN 256; i++) [[s]]-GREATER_TOKENpaletteOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = (0xFFU SMALLER_TOKENSMALLER_TOKEN 24); [[s]]-GREATER_TOKENstate |= PNG_PLTE; bytestream2_skip(&[[s]]-GREATER_TOKENgb, 4); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *[[thermopylae]], PNGDecContext *[[recommending]], uint32_t [[warmer]]) OPEN_CURLY_TOKEN int [[kaew]], i, r, g, b; if (([[warmer]] % 3) != 0 || [[warmer]] GREATER_TOKEN 256 * 3) return AVERROR_INVALIDDATA; [[kaew]] = [[warmer]] / 3; for (i = 0; i SMALLER_TOKEN [[kaew]]; i++) OPEN_CURLY_TOKEN r = bytestream2_get_byte(&[[recommending]]-GREATER_TOKENgb); g = bytestream2_get_byte(&[[recommending]]-GREATER_TOKENgb); b = bytestream2_get_byte(&[[recommending]]-GREATER_TOKENgb); [[recommending]]-GREATER_TOKENpaletteOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = (0xFFU SMALLER_TOKENSMALLER_TOKEN 24) | (r SMALLER_TOKENSMALLER_TOKEN 16) | (g SMALLER_TOKENSMALLER_TOKEN 8) | b; CLOSE_CURLY_TOKEN for (; i SMALLER_TOKEN 256; i++) [[recommending]]-GREATER_TOKENpaletteOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = (0xFFU SMALLER_TOKENSMALLER_TOKEN 24); [[recommending]]-GREATER_TOKENstate |= PNG_PLTE; bytestream2_skip(&[[recommending]]-GREATER_TOKENgb, 4); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 11 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int crypto_open(URLContext *h, const char *uri, int flags) OPEN_CURLY_TOKEN const char *nested_url; int ret; CryptoContext *c = h-GREATER_TOKENpriv_data; if (!av_strstart(uri, "crypto+", &nested_url) && !av_strstart(uri, "crypto:", &nested_url)) OPEN_CURLY_TOKEN av_log(h, AV_LOG_ERROR, "Unsupported url %s\n", uri); ret = AVERROR(EINVAL); goto err; CLOSE_CURLY_TOKEN if (c-GREATER_TOKENkeylen SMALLER_TOKEN BLOCKSIZE || c-GREATER_TOKENivlen SMALLER_TOKEN BLOCKSIZE) OPEN_CURLY_TOKEN av_log(h, AV_LOG_ERROR, "Key or IV not set\n"); ret = AVERROR(EINVAL); goto err; CLOSE_CURLY_TOKEN if (flags & AVIO_FLAG_WRITE) OPEN_CURLY_TOKEN av_log(h, AV_LOG_ERROR, "Only decryption is supported currently\n"); ret = AVERROR(ENOSYS); goto err; CLOSE_CURLY_TOKEN if ((ret = ffurl_open(&c-GREATER_TOKENhd, nested_url, AVIO_FLAG_READ)) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log(h, AV_LOG_ERROR, "Unable to open input\n"); goto err; CLOSE_CURLY_TOKEN c-GREATER_TOKENaes = av_mallocz(av_aes_size); if (!c-GREATER_TOKENaes) OPEN_CURLY_TOKEN ret = AVERROR(ENOMEM); goto err; CLOSE_CURLY_TOKEN av_aes_init(c-GREATER_TOKENaes, c-GREATER_TOKENkey, 128, 1); h-GREATER_TOKENis_streamed = 1; return 0; err: av_free(c-GREATER_TOKENkey); av_free(c-GREATER_TOKENiv); return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 12 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_alloc_entries(AVCodecContext *avctx, int count) OPEN_CURLY_TOKEN int i; if (avctx-GREATER_TOKENactive_thread_type & FF_THREAD_SLICE) OPEN_CURLY_TOKEN SliceThreadContext *p = avctx-GREATER_TOKENinternal-GREATER_TOKENthread_ctx; p-GREATER_TOKENthread_count = avctx-GREATER_TOKENthread_count; p-GREATER_TOKENentries = av_mallocz_array(count, sizeof(int)); if (!p-GREATER_TOKENentries) OPEN_CURLY_TOKEN return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN p-GREATER_TOKENentries_count = count; p-GREATER_TOKENprogress_mutex = av_malloc_array(p-GREATER_TOKENthread_count, sizeof(pthread_mutex_t)); p-GREATER_TOKENprogress_cond = av_malloc_array(p-GREATER_TOKENthread_count, sizeof(pthread_cond_t)); for (i = 0; i SMALLER_TOKEN p-GREATER_TOKENthread_count; i++) OPEN_CURLY_TOKEN pthread_mutex_init(&p-GREATER_TOKENprogress_mutexOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, NULL); pthread_cond_init(&p-GREATER_TOKENprogress_condOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, NULL); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 13 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 2 / 9 / 13:   0%|          | 13/2690 [00:00<00:00, 2870.84it/s][Succeeded / Failed / Skipped / Total] 2 / 2 / 10 / 14:   1%|          | 14/2690 [00:00<00:00, 2953.44it/s][Succeeded / Failed / Skipped / Total] 2 / 2 / 11 / 15:   1%|          | 15/2690 [00:00<00:00, 3034.66it/s][[1 (79%)]] --> [[0 (53%)]] --> Socre: 0.5270174741744995

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *[[got_picture_ptr]], AVPacket *avpkt) OPEN_CURLY_TOKEN int ret; *[[got_picture_ptr]] = 0; if ((avctx-GREATER_TOKENcoded_width || avctx-GREATER_TOKENcoded_height) && av_image_check_size(avctx-GREATER_TOKENcoded_width, avctx-GREATER_TOKENcoded_height, 0, avctx)) return -1; avctx-GREATER_TOKENpkt = avpkt; apply_param_change(avctx, avpkt); if ((avctx-GREATER_TOKENcodec-GREATER_TOKENcapabilities & CODEC_CAP_DELAY) || avpkt-GREATER_TOKENsize || (avctx-GREATER_TOKENactive_thread_type & FF_THREAD_FRAME)) OPEN_CURLY_TOKEN if (HAVE_THREADS && avctx-GREATER_TOKENactive_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, [[got_picture_ptr]], avpkt); else OPEN_CURLY_TOKEN ret = avctx-GREATER_TOKENcodec-GREATER_TOKENdecode(avctx, picture, [[got_picture_ptr]], avpkt); picture-GREATER_TOKENpkt_dts = avpkt-GREATER_TOKENdts; picture-GREATER_TOKENsample_aspect_ratio = avctx-GREATER_TOKENsample_aspect_ratio; picture-GREATER_TOKENwidth = avctx-GREATER_TOKENwidth; picture-GREATER_TOKENheight = avctx-GREATER_TOKENheight; picture-GREATER_TOKENformat = avctx-GREATER_TOKENpix_fmt; CLOSE_CURLY_TOKEN emms_c(); if (*[[got_picture_ptr]]) avctx-GREATER_TOKENframe_number++; CLOSE_CURLY_TOKEN else ret = 0; picture-GREATER_TOKENextended_data = picture-GREATER_TOKENdata; return ret; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *[[chantel]], AVPacket *avpkt) OPEN_CURLY_TOKEN int ret; *[[chantel]] = 0; if ((avctx-GREATER_TOKENcoded_width || avctx-GREATER_TOKENcoded_height) && av_image_check_size(avctx-GREATER_TOKENcoded_width, avctx-GREATER_TOKENcoded_height, 0, avctx)) return -1; avctx-GREATER_TOKENpkt = avpkt; apply_param_change(avctx, avpkt); if ((avctx-GREATER_TOKENcodec-GREATER_TOKENcapabilities & CODEC_CAP_DELAY) || avpkt-GREATER_TOKENsize || (avctx-GREATER_TOKENactive_thread_type & FF_THREAD_FRAME)) OPEN_CURLY_TOKEN if (HAVE_THREADS && avctx-GREATER_TOKENactive_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, [[chantel]], avpkt); else OPEN_CURLY_TOKEN ret = avctx-GREATER_TOKENcodec-GREATER_TOKENdecode(avctx, picture, [[chantel]], avpkt); picture-GREATER_TOKENpkt_dts = avpkt-GREATER_TOKENdts; picture-GREATER_TOKENsample_aspect_ratio = avctx-GREATER_TOKENsample_aspect_ratio; picture-GREATER_TOKENwidth = avctx-GREATER_TOKENwidth; picture-GREATER_TOKENheight = avctx-GREATER_TOKENheight; picture-GREATER_TOKENformat = avctx-GREATER_TOKENpix_fmt; CLOSE_CURLY_TOKEN emms_c(); if (*[[chantel]]) avctx-GREATER_TOKENframe_number++; CLOSE_CURLY_TOKEN else ret = 0; picture-GREATER_TOKENextended_data = picture-GREATER_TOKENdata; return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 14 ---------------------------------------------
[[1 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: aio_write_f(int argc, char **argv) OPEN_CURLY_TOKEN char *p; int count = 0; int nr_iov, i, c; int pattern = 0xcd; struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *acb; while ((c = getopt(argc, argv, "CqP:")) != EOF) OPEN_CURLY_TOKEN switch (c) OPEN_CURLY_TOKEN case 'C': ctx-GREATER_TOKENCflag = 1; break; case 'q': ctx-GREATER_TOKENqflag = 1; break; case 'P': pattern = atoi(optarg); break; default: return command_usage(&aio_write_cmd); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (optind GREATER_TOKEN argc - 2) return command_usage(&aio_write_cmd); ctx-GREATER_TOKENoffset = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if (ctx-GREATER_TOKENoffset SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("non-numeric length argument -- %s\n", argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN optind++; if (ctx-GREATER_TOKENoffset & 0x1ff) OPEN_CURLY_TOKEN printf("offset %lld is not sector aligned\n", (long long)ctx-GREATER_TOKENoffset); return 0; CLOSE_CURLY_TOKEN if (count & 0x1ff) OPEN_CURLY_TOKEN printf("count %d is not sector aligned\n", count); return 0; CLOSE_CURLY_TOKEN for (i = optind; i SMALLER_TOKEN argc; i++) OPEN_CURLY_TOKEN size_t len; len = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if (len SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("non-numeric length argument -- %s\n", argvOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN count += len; CLOSE_CURLY_TOKEN nr_iov = argc - optind; qemu_iovec_init(&ctx-GREATER_TOKENqiov, nr_iov); ctx-GREATER_TOKENbuf = p = qemu_io_alloc(count, pattern); for (i = 0; i SMALLER_TOKEN nr_iov; i++) OPEN_CURLY_TOKEN size_t len; len = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if (len SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("non-numeric length argument -- %s\n", argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN qemu_iovec_add(&ctx-GREATER_TOKENqiov, p, len); p += len; optind++; CLOSE_CURLY_TOKEN gettimeofday(&ctx-GREATER_TOKENt1, NULL); acb = bdrv_aio_writev(bs, ctx-GREATER_TOKENoffset GREATER_TOKENGREATER_TOKEN 9, &ctx-GREATER_TOKENqiov, ctx-GREATER_TOKENqiov.size GREATER_TOKENGREATER_TOKEN 9, aio_write_done, ctx); if (!acb) return -EIO; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 15 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void compute_rematrixing_strategy(AC3EncodeContext *s) OPEN_CURLY_TOKEN int nb_coefs; int blk, bnd, i; AC3Block *block, *block0; s-GREATER_TOKENnum_rematrixing_bands = 4; if (s-GREATER_TOKENrematrixing & AC3_REMATRIXING_IS_STATIC) return; nb_coefs = FFMIN(s-GREATER_TOKENnb_coefsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, s-GREATER_TOKENnb_coefsOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN); for (blk = 0; blk SMALLER_TOKEN AC3_MAX_BLOCKS; blk++) OPEN_CURLY_TOKEN block = &s-GREATER_TOKENblocksOPEN_SQUARE_TOKENblkCLOSE_SQUARE_TOKEN; block-GREATER_TOKENnew_rematrixing_strategy = !blk; for (bnd = 0; bnd SMALLER_TOKEN s-GREATER_TOKENnum_rematrixing_bands; bnd++) OPEN_CURLY_TOKEN int start = ff_ac3_rematrix_band_tabOPEN_SQUARE_TOKENbndCLOSE_SQUARE_TOKEN; int end = FFMIN(nb_coefs, ff_ac3_rematrix_band_tabOPEN_SQUARE_TOKENbnd+1CLOSE_SQUARE_TOKEN); CoefSumType sumOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN0,CLOSE_CURLY_TOKEN; for (i = start; i SMALLER_TOKEN end; i++) OPEN_CURLY_TOKEN CoefType lt = block-GREATER_TOKENmdct_coefOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; CoefType rt = block-GREATER_TOKENmdct_coefOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; CoefType md = lt + rt; CoefType sd = lt - rt; sumOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN += lt * lt; sumOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN += rt * rt; sumOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN += md * md; sumOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN += sd * sd; CLOSE_CURLY_TOKEN if (FFMIN(sumOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN, sumOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN) SMALLER_TOKEN FFMIN(sumOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, sumOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN)) block-GREATER_TOKENrematrixing_flagsOPEN_SQUARE_TOKENbndCLOSE_SQUARE_TOKEN = 1; else block-GREATER_TOKENrematrixing_flagsOPEN_SQUARE_TOKENbndCLOSE_SQUARE_TOKEN = 0; if (blk && block-GREATER_TOKENrematrixing_flagsOPEN_SQUARE_TOKENbndCLOSE_SQUARE_TOKEN != block0-GREATER_TOKENrematrixing_flagsOPEN_SQUARE_TOKENbndCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN block-GREATER_TOKENnew_rematrixing_strategy = 1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN block0 = block; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 16 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 2 / 12 / 16:   1%|          | 16/2690 [00:00<00:00, 3106.46it/s][Succeeded / Failed / Skipped / Total] 2 / 2 / 13 / 17:   1%|          | 17/2690 [00:00<00:00, 3187.02it/s][Succeeded / Failed / Skipped / Total] 2 / 3 / 13 / 18:   1%|          | 18/2690 [00:00<00:00, 3140.10it/s][[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int floppy_probe_device(const char *filename) OPEN_CURLY_TOKEN int fd, ret; int prio = 0; struct floppy_struct fdparam; struct stat st; if (strstart(filename, "/dev/fd", NULL) && !strstart(filename, "/dev/fdset/", NULL)) OPEN_CURLY_TOKEN prio = 50; CLOSE_CURLY_TOKEN fd = qemu_open(filename, O_RDONLY | O_NONBLOCK); if (fd SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN ret = fstat(fd, &st); if (ret == -1 || !S_ISBLK(st.st_mode)) OPEN_CURLY_TOKEN goto outc; CLOSE_CURLY_TOKEN ret = ioctl(fd, FDGETPRM, &fdparam); if (ret GREATER_TOKEN= 0) prio = 100; outc: qemu_close(fd); out: return prio; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 17 ---------------------------------------------
[[0 (75%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int omap_gpio_init(SysBusDevice *sbd) OPEN_CURLY_TOKEN DeviceState *dev = DEVICE(sbd); struct omap_gpif_s *s = OMAP1_GPIO(dev); if (!s-GREATER_TOKENclk) OPEN_CURLY_TOKEN hw_error("omap-gpio: clk not connected\n"); CLOSE_CURLY_TOKEN qdev_init_gpio_in(dev, omap_gpio_set, 16); qdev_init_gpio_out(dev, s-GREATER_TOKENomap1.handler, 16); sysbus_init_irq(sbd, &s-GREATER_TOKENomap1.irq); memory_region_init_io(&s-GREATER_TOKENiomem, OBJECT(s), &omap_gpio_ops, &s-GREATER_TOKENomap1, "omap.gpio", 0x1000); sysbus_init_mmio(sbd, &s-GREATER_TOKENiomem); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 18 ---------------------------------------------
[[1 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) OPEN_CURLY_TOKEN uint64_t [[x0]]; uint32_t [[x1]]; [[x0]] = T0 | ((uint64_t) (env-GREATER_TOKENy) SMALLER_TOKENSMALLER_TOKEN 32); [[x1]] = T1; [[x0]] = [[x0]] / [[x1]]; if ([[x0]] GREATER_TOKEN 0xffffffff) OPEN_CURLY_TOKEN T0 = 0xffffffff; T1 = 1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN T0 = [[x0]]; T1 = 0; FORCE_RET();

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) OPEN_CURLY_TOKEN uint64_t [[strengths]]; uint32_t [[tonino]]; [[strengths]] = T0 | ((uint64_t) (env-GREATER_TOKENy) SMALLER_TOKENSMALLER_TOKEN 32); [[tonino]] = T1; [[strengths]] = [[strengths]] / [[tonino]]; if ([[strengths]] GREATER_TOKEN 0xffffffff) OPEN_CURLY_TOKEN T0 = 0xffffffff; T1 = 1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN T0 = [[strengths]]; T1 = 0; FORCE_RET();
--------------------------------------------- Result 19 ---------------------------------------------
[[0 (64%)]] --> [[1 (67%)]] --> Socre: 0.6698272228240967

[[[[Adv]]]]: static void sun4uv_init(ram_addr_t RAM_size, const char *[[boot_devices]], const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model, const struct hwdef *hwdef) OPEN_CURLY_TOKEN CPUState *env; char *filename; m48t59_t *nvram; int ret, linux_boot; unsigned int i; ram_addr_t ram_offset, prom_offset; long initrd_size, kernel_size; PCIBus *pci_bus, *pci_bus2, *pci_bus3; QEMUBH *bh; qemu_irq *irq; int drive_index; BlockDriverState *hdOPEN_SQUARE_TOKENMAX_IDE_BUS * MAX_IDE_DEVSCLOSE_SQUARE_TOKEN; BlockDriverState *fdOPEN_SQUARE_TOKENMAX_FDCLOSE_SQUARE_TOKEN; void *fw_cfg; ResetData *reset_info; linux_boot = (kernel_filename != NULL); if (!cpu_model) cpu_model = hwdef-GREATER_TOKENdefault_cpu_model; env = cpu_init(cpu_model); if (!env) OPEN_CURLY_TOKEN fprintf(stderr, "Unable to find Sparc CPU definition\n"); exit(1); CLOSE_CURLY_TOKEN bh = qemu_bh_new(tick_irq, env); env-GREATER_TOKENtick = ptimer_init(bh); ptimer_set_period(env-GREATER_TOKENtick, 1ULL); bh = qemu_bh_new(stick_irq, env); env-GREATER_TOKENstick = ptimer_init(bh); ptimer_set_period(env-GREATER_TOKENstick, 1ULL); bh = qemu_bh_new(hstick_irq, env); env-GREATER_TOKENhstick = ptimer_init(bh); ptimer_set_period(env-GREATER_TOKENhstick, 1ULL); reset_info = qemu_mallocz(sizeof(ResetData)); reset_info-GREATER_TOKENenv = env; reset_info-GREATER_TOKENreset_addr = hwdef-GREATER_TOKENprom_addr + 0x40ULL; qemu_register_reset(main_cpu_reset, reset_info); main_cpu_reset(reset_info); env-GREATER_TOKENpc = hwdef-GREATER_TOKENprom_addr + 0x20ULL; env-GREATER_TOKENnpc = env-GREATER_TOKENpc + 4; ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef-GREATER_TOKENprom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) OPEN_CURLY_TOKEN ret = load_elf(filename, hwdef-GREATER_TOKENprom_addr - PROM_VADDR, NULL, NULL, NULL); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN ret = load_image_targphys(filename, hwdef-GREATER_TOKENprom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK); CLOSE_CURLY_TOKEN qemu_free(filename); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ret = -1; CLOSE_CURLY_TOKEN if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name); exit(1); CLOSE_CURLY_TOKEN kernel_size = 0; initrd_size = 0; if (linux_boot) OPEN_CURLY_TOKEN kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL); if (kernel_size SMALLER_TOKEN 0) kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size SMALLER_TOKEN 0) kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); CLOSE_CURLY_TOKEN if (initrd_filename) OPEN_CURLY_TOKEN initrd_size = load_image_targphys(initrd_filename, INITRD_LOAD_ADDR, ram_size - INITRD_LOAD_ADDR); if (initrd_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (initrd_size GREATER_TOKEN 0) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) OPEN_CURLY_TOKEN if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) OPEN_CURLY_TOKEN stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR); stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2, &pci_bus3); isa_mem_base = VGA_BASE; pci_vga_init(pci_bus, 0, 0); pci_ebus_init(pci_bus, -1); i = 0; if (hwdef-GREATER_TOKENconsole_serial_base) OPEN_CURLY_TOKEN serial_mm_init(hwdef-GREATER_TOKENconsole_serial_base, 0, NULL, 115200, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1); i++; CLOSE_CURLY_TOKEN for(; i SMALLER_TOKEN MAX_SERIAL_PORTS; i++) OPEN_CURLY_TOKEN if (serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN serial_init(serial_ioOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, NULL , 115200, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN MAX_PARALLEL_PORTS; i++) OPEN_CURLY_TOKEN if (parallel_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN parallel_init(parallel_ioOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, NULL , parallel_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN nb_nics; i++) pci_nic_init(&nd_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, "ne2k_pci", NULL); irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS); if (drive_get_max_bus(IF_IDE) GREATER_TOKEN= MAX_IDE_BUS) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN MAX_IDE_BUS * MAX_IDE_DEVS; i++) OPEN_CURLY_TOKEN drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if (drive_index != -1) hdOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = drives_tableOPEN_SQUARE_TOKENdrive_indexCLOSE_SQUARE_TOKEN.bdrv; else hdOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = NULL; CLOSE_CURLY_TOKEN pci_cmd646_ide_init(pci_bus, hd, 1); i8042_init(NULL , NULL , 0x60); for(i = 0; i SMALLER_TOKEN MAX_FD; i++) OPEN_CURLY_TOKEN drive_index = drive_get_index(IF_FLOPPY, 0, i); if (drive_index != -1) fdOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = drives_tableOPEN_SQUARE_TOKENdrive_indexCLOSE_SQUARE_TOKEN.bdrv; else fdOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = NULL; CLOSE_CURLY_TOKEN floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd); nvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59); sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", RAM_size, [[boot_devices]], KERNEL_LOAD_ADDR, kernel_size, kernel_cmdline, INITRD_LOAD_ADDR, initrd_size, 0, graphic_width, graphic_height, graphic_depth, (uint8_t *)&nd_tableOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.macaddr); fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef-GREATER_TOKENmachine_id); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if (kernel_cmdline) OPEN_CURLY_TOKEN fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); CLOSE_CURLY_TOKEN fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, [[boot_devices]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN); qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void sun4uv_init(ram_addr_t RAM_size, const char *[[foetuses]], const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model, const struct hwdef *hwdef) OPEN_CURLY_TOKEN CPUState *env; char *filename; m48t59_t *nvram; int ret, linux_boot; unsigned int i; ram_addr_t ram_offset, prom_offset; long initrd_size, kernel_size; PCIBus *pci_bus, *pci_bus2, *pci_bus3; QEMUBH *bh; qemu_irq *irq; int drive_index; BlockDriverState *hdOPEN_SQUARE_TOKENMAX_IDE_BUS * MAX_IDE_DEVSCLOSE_SQUARE_TOKEN; BlockDriverState *fdOPEN_SQUARE_TOKENMAX_FDCLOSE_SQUARE_TOKEN; void *fw_cfg; ResetData *reset_info; linux_boot = (kernel_filename != NULL); if (!cpu_model) cpu_model = hwdef-GREATER_TOKENdefault_cpu_model; env = cpu_init(cpu_model); if (!env) OPEN_CURLY_TOKEN fprintf(stderr, "Unable to find Sparc CPU definition\n"); exit(1); CLOSE_CURLY_TOKEN bh = qemu_bh_new(tick_irq, env); env-GREATER_TOKENtick = ptimer_init(bh); ptimer_set_period(env-GREATER_TOKENtick, 1ULL); bh = qemu_bh_new(stick_irq, env); env-GREATER_TOKENstick = ptimer_init(bh); ptimer_set_period(env-GREATER_TOKENstick, 1ULL); bh = qemu_bh_new(hstick_irq, env); env-GREATER_TOKENhstick = ptimer_init(bh); ptimer_set_period(env-GREATER_TOKENhstick, 1ULL); reset_info = qemu_mallocz(sizeof(ResetData)); reset_info-GREATER_TOKENenv = env; reset_info-GREATER_TOKENreset_addr = hwdef-GREATER_TOKENprom_addr + 0x40ULL; qemu_register_reset(main_cpu_reset, reset_info); main_cpu_reset(reset_info); env-GREATER_TOKENpc = hwdef-GREATER_TOKENprom_addr + 0x20ULL; env-GREATER_TOKENnpc = env-GREATER_TOKENpc + 4; ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef-GREATER_TOKENprom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) OPEN_CURLY_TOKEN ret = load_elf(filename, hwdef-GREATER_TOKENprom_addr - PROM_VADDR, NULL, NULL, NULL); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN ret = load_image_targphys(filename, hwdef-GREATER_TOKENprom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK); CLOSE_CURLY_TOKEN qemu_free(filename); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ret = -1; CLOSE_CURLY_TOKEN if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name); exit(1); CLOSE_CURLY_TOKEN kernel_size = 0; initrd_size = 0; if (linux_boot) OPEN_CURLY_TOKEN kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL); if (kernel_size SMALLER_TOKEN 0) kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size SMALLER_TOKEN 0) kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); CLOSE_CURLY_TOKEN if (initrd_filename) OPEN_CURLY_TOKEN initrd_size = load_image_targphys(initrd_filename, INITRD_LOAD_ADDR, ram_size - INITRD_LOAD_ADDR); if (initrd_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (initrd_size GREATER_TOKEN 0) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) OPEN_CURLY_TOKEN if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) OPEN_CURLY_TOKEN stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR); stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2, &pci_bus3); isa_mem_base = VGA_BASE; pci_vga_init(pci_bus, 0, 0); pci_ebus_init(pci_bus, -1); i = 0; if (hwdef-GREATER_TOKENconsole_serial_base) OPEN_CURLY_TOKEN serial_mm_init(hwdef-GREATER_TOKENconsole_serial_base, 0, NULL, 115200, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1); i++; CLOSE_CURLY_TOKEN for(; i SMALLER_TOKEN MAX_SERIAL_PORTS; i++) OPEN_CURLY_TOKEN if (serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN serial_init(serial_ioOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, NULL , 115200, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN MAX_PARALLEL_PORTS; i++) OPEN_CURLY_TOKEN if (parallel_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN parallel_init(parallel_ioOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, NULL , parallel_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN nb_nics; i++) pci_nic_init(&nd_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, "ne2k_pci", NULL); irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS); if (drive_get_max_bus(IF_IDE) GREATER_TOKEN= MAX_IDE_BUS) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN MAX_IDE_BUS * MAX_IDE_DEVS; i++) OPEN_CURLY_TOKEN drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if (drive_index != -1) hdOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = drives_tableOPEN_SQUARE_TOKENdrive_indexCLOSE_SQUARE_TOKEN.bdrv; else hdOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = NULL; CLOSE_CURLY_TOKEN pci_cmd646_ide_init(pci_bus, hd, 1); i8042_init(NULL , NULL , 0x60); for(i = 0; i SMALLER_TOKEN MAX_FD; i++) OPEN_CURLY_TOKEN drive_index = drive_get_index(IF_FLOPPY, 0, i); if (drive_index != -1) fdOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = drives_tableOPEN_SQUARE_TOKENdrive_indexCLOSE_SQUARE_TOKEN.bdrv; else fdOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = NULL; CLOSE_CURLY_TOKEN floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd); nvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59); sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", RAM_size, [[foetuses]], KERNEL_LOAD_ADDR, kernel_size, kernel_cmdline, INITRD_LOAD_ADDR, initrd_size, 0, graphic_width, graphic_height, graphic_depth, (uint8_t *)&nd_tableOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.macaddr); fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef-GREATER_TOKENmachine_id); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if (kernel_cmdline) OPEN_CURLY_TOKEN fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); CLOSE_CURLY_TOKEN fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, [[foetuses]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN); qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 3 / 3 / 13 / 19:   1%|          | 19/2690 [00:00<00:00, 2762.95it/s][Succeeded / Failed / Skipped / Total] 4 / 3 / 13 / 20:   1%|          | 20/2690 [00:00<00:00, 2673.23it/s][Succeeded / Failed / Skipped / Total] 4 / 4 / 13 / 21:   1%|          | 21/2690 [00:00<00:00, 2696.89it/s]
--------------------------------------------- Result 20 ---------------------------------------------
[[1 (74%)]] --> [[0 (58%)]] --> Socre: 0.5839084386825562

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts) OPEN_CURLY_TOKEN ObjectClass *oc; DeviceClass *[[dc]]; const char *driver, *path, *id; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) OPEN_CURLY_TOKEN qerror_report(QERR_MISSING_PARAMETER, "driver"); return NULL; CLOSE_CURLY_TOKEN oc = object_class_by_name(driver); if (!oc) OPEN_CURLY_TOKEN const char *typename = find_typename_by_alias(driver); if (typename) OPEN_CURLY_TOKEN driver = typename; oc = object_class_by_name(driver); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) OPEN_CURLY_TOKEN qerror_report(ERROR_CLASS_GENERIC_ERROR, "'%s' is not a valid device model name", driver); return NULL; CLOSE_CURLY_TOKEN if (object_class_is_abstract(oc)) OPEN_CURLY_TOKEN qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "non-abstract device type"); return NULL; CLOSE_CURLY_TOKEN [[dc]] = DEVICE_CLASS(oc); if ([[dc]]-GREATER_TOKENcannot_instantiate_with_device_add_yet) OPEN_CURLY_TOKEN qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "pluggable device type"); return NULL; CLOSE_CURLY_TOKEN path = qemu_opt_get(opts, "bus"); if (path != NULL) OPEN_CURLY_TOKEN bus = qbus_find(path); if (!bus) OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN if (!object_dynamic_cast(OBJECT(bus), [[dc]]-GREATER_TOKENbus_type)) OPEN_CURLY_TOKEN qerror_report(QERR_BAD_BUS_FOR_DEVICE, driver, object_get_typename(OBJECT(bus))); return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if ([[dc]]-GREATER_TOKENbus_type != NULL) OPEN_CURLY_TOKEN bus = qbus_find_recursive(sysbus_get_default(), NULL, [[dc]]-GREATER_TOKENbus_type); if (!bus) OPEN_CURLY_TOKEN qerror_report(QERR_NO_BUS_FOR_DEVICE, [[dc]]-GREATER_TOKENbus_type, driver); return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (qdev_hotplug && bus && !bus-GREATER_TOKENallow_hotplug) OPEN_CURLY_TOKEN qerror_report(QERR_BUS_NO_HOTPLUG, bus-GREATER_TOKENname); return NULL; CLOSE_CURLY_TOKEN dev = DEVICE(object_new(driver)); if (bus) OPEN_CURLY_TOKEN qdev_set_parent_bus(dev, bus); CLOSE_CURLY_TOKEN id = qemu_opts_id(opts); if (id) OPEN_CURLY_TOKEN dev-GREATER_TOKENid = id; CLOSE_CURLY_TOKEN if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) OPEN_CURLY_TOKEN object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; CLOSE_CURLY_TOKEN if (dev-GREATER_TOKENid) OPEN_CURLY_TOKEN object_property_add_child(qdev_get_peripheral(), dev-GREATER_TOKENid, OBJECT(dev), NULL); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN static int anon_count; gchar *name = g_strdup_printf("deviceOPEN_SQUARE_TOKEN%dCLOSE_SQUARE_TOKEN", anon_count++); object_property_add_child(qdev_get_peripheral_anon(), name, OBJECT(dev), NULL); g_free(name); CLOSE_CURLY_TOKEN dev-GREATER_TOKENopts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) OPEN_CURLY_TOKEN qerror_report_err(err); error_free(err); dev-GREATER_TOKENopts = NULL; object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); qerror_report(QERR_DEVICE_INIT_FAILED, driver); return NULL; CLOSE_CURLY_TOKEN return dev; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts) OPEN_CURLY_TOKEN ObjectClass *oc; DeviceClass *[[frederica]]; const char *driver, *path, *id; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) OPEN_CURLY_TOKEN qerror_report(QERR_MISSING_PARAMETER, "driver"); return NULL; CLOSE_CURLY_TOKEN oc = object_class_by_name(driver); if (!oc) OPEN_CURLY_TOKEN const char *typename = find_typename_by_alias(driver); if (typename) OPEN_CURLY_TOKEN driver = typename; oc = object_class_by_name(driver); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) OPEN_CURLY_TOKEN qerror_report(ERROR_CLASS_GENERIC_ERROR, "'%s' is not a valid device model name", driver); return NULL; CLOSE_CURLY_TOKEN if (object_class_is_abstract(oc)) OPEN_CURLY_TOKEN qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "non-abstract device type"); return NULL; CLOSE_CURLY_TOKEN [[frederica]] = DEVICE_CLASS(oc); if ([[frederica]]-GREATER_TOKENcannot_instantiate_with_device_add_yet) OPEN_CURLY_TOKEN qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "pluggable device type"); return NULL; CLOSE_CURLY_TOKEN path = qemu_opt_get(opts, "bus"); if (path != NULL) OPEN_CURLY_TOKEN bus = qbus_find(path); if (!bus) OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN if (!object_dynamic_cast(OBJECT(bus), [[frederica]]-GREATER_TOKENbus_type)) OPEN_CURLY_TOKEN qerror_report(QERR_BAD_BUS_FOR_DEVICE, driver, object_get_typename(OBJECT(bus))); return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if ([[frederica]]-GREATER_TOKENbus_type != NULL) OPEN_CURLY_TOKEN bus = qbus_find_recursive(sysbus_get_default(), NULL, [[frederica]]-GREATER_TOKENbus_type); if (!bus) OPEN_CURLY_TOKEN qerror_report(QERR_NO_BUS_FOR_DEVICE, [[frederica]]-GREATER_TOKENbus_type, driver); return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (qdev_hotplug && bus && !bus-GREATER_TOKENallow_hotplug) OPEN_CURLY_TOKEN qerror_report(QERR_BUS_NO_HOTPLUG, bus-GREATER_TOKENname); return NULL; CLOSE_CURLY_TOKEN dev = DEVICE(object_new(driver)); if (bus) OPEN_CURLY_TOKEN qdev_set_parent_bus(dev, bus); CLOSE_CURLY_TOKEN id = qemu_opts_id(opts); if (id) OPEN_CURLY_TOKEN dev-GREATER_TOKENid = id; CLOSE_CURLY_TOKEN if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) OPEN_CURLY_TOKEN object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; CLOSE_CURLY_TOKEN if (dev-GREATER_TOKENid) OPEN_CURLY_TOKEN object_property_add_child(qdev_get_peripheral(), dev-GREATER_TOKENid, OBJECT(dev), NULL); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN static int anon_count; gchar *name = g_strdup_printf("deviceOPEN_SQUARE_TOKEN%dCLOSE_SQUARE_TOKEN", anon_count++); object_property_add_child(qdev_get_peripheral_anon(), name, OBJECT(dev), NULL); g_free(name); CLOSE_CURLY_TOKEN dev-GREATER_TOKENopts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) OPEN_CURLY_TOKEN qerror_report_err(err); error_free(err); dev-GREATER_TOKENopts = NULL; object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); qerror_report(QERR_DEVICE_INIT_FAILED, driver); return NULL; CLOSE_CURLY_TOKEN return dev; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 21 ---------------------------------------------
[[0 (91%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void thread_pool_submit(ThreadPoolFunc *[[func]], void *[[arg]]) OPEN_CURLY_TOKEN thread_pool_submit_aio([[func]], [[arg]], NULL, NULL); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void thread_pool_submit(ThreadPoolFunc *[[vfb]], void *[[investigations]]) OPEN_CURLY_TOKEN thread_pool_submit_aio([[vfb]], [[investigations]], NULL, NULL); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 22 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 4 / 13 / 22:   1%|          | 22/2690 [00:00<00:00, 2673.62it/s][Succeeded / Failed / Skipped / Total] 6 / 4 / 13 / 23:   1%|          | 23/2690 [00:00<00:00, 2688.43it/s][Succeeded / Failed / Skipped / Total] 7 / 4 / 13 / 24:   1%|          | 24/2690 [00:00<00:00, 2698.31it/s][Succeeded / Failed / Skipped / Total] 7 / 4 / 14 / 25:   1%|          | 25/2690 [00:00<00:00, 2748.42it/s][Succeeded / Failed / Skipped / Total] 8 / 4 / 14 / 26:   1%|          | 26/2690 [00:00<00:00, 2758.50it/s][[1 (94%)]] --> [[0 (56%)]] --> Socre: 0.5583593845367432

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *[[dest]], int linesize, DCTELEM *[[block]]) OPEN_CURLY_TOKEN int i; int [[dc]] = [[block]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; const uint8_t *[[cm]]; [[dc]] = (3 * [[dc]] + 1) GREATER_TOKENGREATER_TOKEN 1; [[dc]] = (3 * [[dc]] + 16) GREATER_TOKENGREATER_TOKEN 5; [[cm]] = ff_cropTbl + MAX_NEG_CROP + [[dc]]; for(i = 0; i SMALLER_TOKEN 8; i++)OPEN_CURLY_TOKEN [[dest]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = [[cm]]OPEN_SQUARE_TOKEN[[dest]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[dest]]OPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = [[cm]]OPEN_SQUARE_TOKEN[[dest]]OPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[dest]]OPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = [[cm]]OPEN_SQUARE_TOKEN[[dest]]OPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[dest]]OPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = [[cm]]OPEN_SQUARE_TOKEN[[dest]]OPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[dest]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = [[cm]]OPEN_SQUARE_TOKEN[[dest]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[dest]]OPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN = [[cm]]OPEN_SQUARE_TOKEN[[dest]]OPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[dest]]OPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN = [[cm]]OPEN_SQUARE_TOKEN[[dest]]OPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[dest]]OPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKEN = [[cm]]OPEN_SQUARE_TOKEN[[dest]]OPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[dest]] += linesize; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *[[capacitor]], int linesize, DCTELEM *[[vision]]) OPEN_CURLY_TOKEN int i; int [[kendricks]] = [[vision]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; const uint8_t *[[daylight]]; [[kendricks]] = (3 * [[kendricks]] + 1) GREATER_TOKENGREATER_TOKEN 1; [[kendricks]] = (3 * [[kendricks]] + 16) GREATER_TOKENGREATER_TOKEN 5; [[daylight]] = ff_cropTbl + MAX_NEG_CROP + [[kendricks]]; for(i = 0; i SMALLER_TOKEN 8; i++)OPEN_CURLY_TOKEN [[capacitor]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = [[daylight]]OPEN_SQUARE_TOKEN[[capacitor]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[capacitor]]OPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = [[daylight]]OPEN_SQUARE_TOKEN[[capacitor]]OPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[capacitor]]OPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = [[daylight]]OPEN_SQUARE_TOKEN[[capacitor]]OPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[capacitor]]OPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = [[daylight]]OPEN_SQUARE_TOKEN[[capacitor]]OPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[capacitor]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = [[daylight]]OPEN_SQUARE_TOKEN[[capacitor]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[capacitor]]OPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN = [[daylight]]OPEN_SQUARE_TOKEN[[capacitor]]OPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[capacitor]]OPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN = [[daylight]]OPEN_SQUARE_TOKEN[[capacitor]]OPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[capacitor]]OPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKEN = [[daylight]]OPEN_SQUARE_TOKEN[[capacitor]]OPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; [[capacitor]] += linesize; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 23 ---------------------------------------------
[[1 (87%)]] --> [[0 (70%)]] --> Socre: 0.6960231065750122

[[[[Adv]]]]: void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *[[s]], I2SCodec *[[slave]]) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENcodec = [[slave]]; [[slave]]-GREATER_TOKENrx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, [[s]], 1)OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; [[slave]]-GREATER_TOKENtx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, [[s]], 1)OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *[[knockoffs]], I2SCodec *[[fainter]]) OPEN_CURLY_TOKEN [[knockoffs]]-GREATER_TOKENcodec = [[fainter]]; [[fainter]]-GREATER_TOKENrx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, [[knockoffs]], 1)OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; [[fainter]]-GREATER_TOKENtx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, [[knockoffs]], 1)OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 24 ---------------------------------------------
[[0 (72%)]] --> [[1 (62%)]] --> Socre: 0.6194237470626831

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *[[s]], bool [[link_down]]) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENnc.link_down = [[link_down]]; if ([[s]]-GREATER_TOKENnc.peer) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENnc.peer-GREATER_TOKENlink_down = [[link_down]]; CLOSE_CURLY_TOKEN if ([[s]]-GREATER_TOKENnc.info-GREATER_TOKENlink_status_changed) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENnc.info-GREATER_TOKENlink_status_changed(&[[s]]-GREATER_TOKENnc); CLOSE_CURLY_TOKEN if ([[s]]-GREATER_TOKENnc.peer && [[s]]-GREATER_TOKENnc.peer-GREATER_TOKENinfo-GREATER_TOKENlink_status_changed) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENnc.peer-GREATER_TOKENinfo-GREATER_TOKENlink_status_changed([[s]]-GREATER_TOKENnc.peer); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *[[unexplored]], bool [[footballing]]) OPEN_CURLY_TOKEN [[unexplored]]-GREATER_TOKENnc.link_down = [[footballing]]; if ([[unexplored]]-GREATER_TOKENnc.peer) OPEN_CURLY_TOKEN [[unexplored]]-GREATER_TOKENnc.peer-GREATER_TOKENlink_down = [[footballing]]; CLOSE_CURLY_TOKEN if ([[unexplored]]-GREATER_TOKENnc.info-GREATER_TOKENlink_status_changed) OPEN_CURLY_TOKEN [[unexplored]]-GREATER_TOKENnc.info-GREATER_TOKENlink_status_changed(&[[unexplored]]-GREATER_TOKENnc); CLOSE_CURLY_TOKEN if ([[unexplored]]-GREATER_TOKENnc.peer && [[unexplored]]-GREATER_TOKENnc.peer-GREATER_TOKENinfo-GREATER_TOKENlink_status_changed) OPEN_CURLY_TOKEN [[unexplored]]-GREATER_TOKENnc.peer-GREATER_TOKENinfo-GREATER_TOKENlink_status_changed([[unexplored]]-GREATER_TOKENnc.peer); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 25 ---------------------------------------------
[[0 (97%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 26 ---------------------------------------------
[[0 (94%)]] --> [[1 (61%)]] --> Socre: 0.6052075624465942

[[[[Adv]]]]: void json_lexer_init(JSONLexer *[[lexer]], JSONLexerEmitter [[func]]) OPEN_CURLY_TOKEN [[lexer]]-GREATER_TOKENemit = [[func]]; [[lexer]]-GREATER_TOKENstate = IN_START; [[lexer]]-GREATER_TOKENtoken = qstring_new(); [[lexer]]-GREATER_TOKENx = [[lexer]]-GREATER_TOKENy = 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void json_lexer_init(JSONLexer *[[debutante]], JSONLexerEmitter [[lavatories]]) OPEN_CURLY_TOKEN [[debutante]]-GREATER_TOKENemit = [[lavatories]]; [[debutante]]-GREATER_TOKENstate = IN_START; [[debutante]]-GREATER_TOKENtoken = qstring_new(); [[debutante]]-GREATER_TOKENx = [[debutante]]-GREATER_TOKENy = 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 27 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 8 / 4 / 15 / 27:   1%|          | 27/2690 [00:00<00:00, 2796.76it/s][Succeeded / Failed / Skipped / Total] 8 / 5 / 15 / 28:   1%|          | 28/2690 [00:00<00:00, 2815.44it/s][Succeeded / Failed / Skipped / Total] 8 / 6 / 15 / 29:   1%|          | 29/2690 [00:00<00:00, 2785.96it/s][Succeeded / Failed / Skipped / Total] 8 / 6 / 16 / 30:   1%|          | 30/2690 [00:00<00:00, 2826.29it/s][Succeeded / Failed / Skipped / Total] 8 / 6 / 17 / 31:   1%|          | 31/2690 [00:00<00:00, 2870.21it/s][Succeeded / Failed / Skipped / Total] 9 / 6 / 17 / 32:   1%|          | 32/2690 [00:00<00:00, 2876.51it/s][[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_blockdev_add(BlockdevOptions *options, Error **errp) OPEN_CURLY_TOKEN QmpOutputVisitor *ov = qmp_output_visitor_new(); QObject *obj; QDict *qdict; Error *local_err = NULL; if (!options-GREATER_TOKENhas_id) OPEN_CURLY_TOKEN error_setg(errp, "Block device needs an ID"); goto fail; CLOSE_CURLY_TOKEN if (options-GREATER_TOKENhas_aio && options-GREATER_TOKENaio == BLOCKDEV_AIO_OPTIONS_NATIVE) OPEN_CURLY_TOKEN bool direct = options-GREATER_TOKENcache-GREATER_TOKENhas_direct && options-GREATER_TOKENcache-GREATER_TOKENdirect; if (!options-GREATER_TOKENhas_cache && !direct) OPEN_CURLY_TOKEN error_setg(errp, "aio=native requires cache.direct=true"); goto fail; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN visit_type_BlockdevOptions(qmp_output_get_visitor(ov), &options, NULL, &local_err); if (local_err) OPEN_CURLY_TOKEN error_propagate(errp, local_err); goto fail; CLOSE_CURLY_TOKEN obj = qmp_output_get_qobject(ov); qdict = qobject_to_qdict(obj); qdict_flatten(qdict); blockdev_init(NULL, qdict, &local_err); if (local_err) OPEN_CURLY_TOKEN error_propagate(errp, local_err); goto fail; CLOSE_CURLY_TOKEN fail: qmp_output_visitor_cleanup(ov); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 28 ---------------------------------------------
[[0 (91%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *[[env]]) OPEN_CURLY_TOKEN a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0([[env]]); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *[[commend]]) OPEN_CURLY_TOKEN a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0([[commend]]); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 29 ---------------------------------------------
[[1 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int read_code_table(CLLCContext *[[ctx]], GetBitContext *[[gb]], VLC *vlc) OPEN_CURLY_TOKEN uint8_t [[symbols]]OPEN_SQUARE_TOKEN256CLOSE_SQUARE_TOKEN; uint8_t [[bits]]OPEN_SQUARE_TOKEN256CLOSE_SQUARE_TOKEN; uint16_t [[codes]]OPEN_SQUARE_TOKEN256CLOSE_SQUARE_TOKEN; int num_lens, num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; num_lens = get_bits([[gb]], 5); for (i = 0; i SMALLER_TOKEN num_lens; i++) OPEN_CURLY_TOKEN num_codes = get_bits([[gb]], 9); num_codes_sum += num_codes; if (num_codes_sum GREATER_TOKEN 256) OPEN_CURLY_TOKEN av_log([[ctx]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j SMALLER_TOKEN num_codes; j++) OPEN_CURLY_TOKEN [[symbols]]OPEN_SQUARE_TOKENcountCLOSE_SQUARE_TOKEN = get_bits([[gb]], 8); [[bits]]OPEN_SQUARE_TOKENcountCLOSE_SQUARE_TOKEN = i + 1; [[codes]]OPEN_SQUARE_TOKENcountCLOSE_SQUARE_TOKEN = prefix++; count++; if (prefix GREATER_TOKEN (65535 - 256)/2) OPEN_CURLY_TOKEN prefix SMALLER_TOKENSMALLER_TOKEN= 1; return ff_init_vlc_sparse(vlc, VLC_BITS, count, [[bits]], 1, 1, [[codes]], 2, 2, [[symbols]], 1, 1, 0);

[[[[Adv]]]]: static int read_code_table(CLLCContext *[[howie]], GetBitContext *[[rain]], VLC *vlc) OPEN_CURLY_TOKEN uint8_t [[reportedly]]OPEN_SQUARE_TOKEN256CLOSE_SQUARE_TOKEN; uint8_t [[promotional]]OPEN_SQUARE_TOKEN256CLOSE_SQUARE_TOKEN; uint16_t [[received]]OPEN_SQUARE_TOKEN256CLOSE_SQUARE_TOKEN; int num_lens, num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; num_lens = get_bits([[rain]], 5); for (i = 0; i SMALLER_TOKEN num_lens; i++) OPEN_CURLY_TOKEN num_codes = get_bits([[rain]], 9); num_codes_sum += num_codes; if (num_codes_sum GREATER_TOKEN 256) OPEN_CURLY_TOKEN av_log([[howie]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j SMALLER_TOKEN num_codes; j++) OPEN_CURLY_TOKEN [[reportedly]]OPEN_SQUARE_TOKENcountCLOSE_SQUARE_TOKEN = get_bits([[rain]], 8); [[promotional]]OPEN_SQUARE_TOKENcountCLOSE_SQUARE_TOKEN = i + 1; [[received]]OPEN_SQUARE_TOKENcountCLOSE_SQUARE_TOKEN = prefix++; count++; if (prefix GREATER_TOKEN (65535 - 256)/2) OPEN_CURLY_TOKEN prefix SMALLER_TOKENSMALLER_TOKEN= 1; return ff_init_vlc_sparse(vlc, VLC_BITS, count, [[promotional]], 1, 1, [[received]], 2, 2, [[reportedly]], 1, 1, 0);
--------------------------------------------- Result 30 ---------------------------------------------
[[0 (94%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void kvmclock_pre_save(void *opaque) OPEN_CURLY_TOKEN KVMClockState *s = opaque; struct kvm_clock_data data; int ret; if (s-GREATER_TOKENclock_valid) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret)); data.clock = 0; CLOSE_CURLY_TOKEN s-GREATER_TOKENclock = data.clock; s-GREATER_TOKENclock_valid = !runstate_is_running(); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 31 ---------------------------------------------
[[0 (95%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static size_t header_ext_add(char *buf, uint32_t magic, const void *s, size_t len, size_t buflen) OPEN_CURLY_TOKEN QCowExtension *ext_backing_fmt = (QCowExtension*) buf; size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7); if (buflen SMALLER_TOKEN ext_len) OPEN_CURLY_TOKEN return -ENOSPC; CLOSE_CURLY_TOKEN *ext_backing_fmt = (QCowExtension) OPEN_CURLY_TOKEN .magic = cpu_to_be32(magic), .len = cpu_to_be32(len), CLOSE_CURLY_TOKEN; memcpy(buf + sizeof(QCowExtension), s, len); return ext_len; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 32 ---------------------------------------------
[[1 (89%)]] --> [[0 (74%)]] --> Socre: 0.7405229806900024

[[[[Adv]]]]: static void handle_satn(ESPState *[[s]]) OPEN_CURLY_TOKEN uint8_t bufOPEN_SQUARE_TOKEN32CLOSE_SQUARE_TOKEN; int len; if ([[s]]-GREATER_TOKENdma && ![[s]]-GREATER_TOKENdma_enabled) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENdma_cb = handle_satn; return; CLOSE_CURLY_TOKEN len = get_cmd([[s]], buf); if (len) do_cmd([[s]], buf); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void handle_satn(ESPState *[[tartarus]]) OPEN_CURLY_TOKEN uint8_t bufOPEN_SQUARE_TOKEN32CLOSE_SQUARE_TOKEN; int len; if ([[tartarus]]-GREATER_TOKENdma && ![[tartarus]]-GREATER_TOKENdma_enabled) OPEN_CURLY_TOKEN [[tartarus]]-GREATER_TOKENdma_cb = handle_satn; return; CLOSE_CURLY_TOKEN len = get_cmd([[tartarus]], buf); if (len) do_cmd([[tartarus]], buf); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 33 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 6 / 17 / 33:   1%|          | 33/2690 [00:00<00:00, 2872.21it/s][Succeeded / Failed / Skipped / Total] 11 / 6 / 17 / 34:   1%|         | 34/2690 [00:00<00:00, 2832.36it/s][Succeeded / Failed / Skipped / Total] 11 / 7 / 17 / 35:   1%|         | 35/2690 [00:00<00:00, 2844.59it/s][Succeeded / Failed / Skipped / Total] 11 / 8 / 17 / 36:   1%|         | 36/2690 [00:00<00:00, 2849.55it/s][Succeeded / Failed / Skipped / Total] 11 / 8 / 18 / 37:   1%|         | 37/2690 [00:00<00:00, 2882.04it/s][[1 (84%)]] --> [[0 (57%)]] --> Socre: 0.5713173747062683

[[[[Adv]]]]: static int mov_read_strf(MOVContext *[[c]], AVIOContext *pb, MOVAtom atom) OPEN_CURLY_TOKEN AVStream *st; if ([[c]]-GREATER_TOKENfc-GREATER_TOKENnb_streams SMALLER_TOKEN 1) return 0; if (atom.size SMALLER_TOKEN= 40) return 0; st = [[c]]-GREATER_TOKENfc-GREATER_TOKENstreamsOPEN_SQUARE_TOKEN[[c]]-GREATER_TOKENfc-GREATER_TOKENnb_streams-1CLOSE_SQUARE_TOKEN; if ((uint64_t)atom.size GREATER_TOKEN (1SMALLER_TOKENSMALLER_TOKEN30)) return AVERROR_INVALIDDATA; av_free(st-GREATER_TOKENcodec-GREATER_TOKENextradata); st-GREATER_TOKENcodec-GREATER_TOKENextradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE); if (!st-GREATER_TOKENcodec-GREATER_TOKENextradata) return AVERROR(ENOMEM); st-GREATER_TOKENcodec-GREATER_TOKENextradata_size = atom.size - 40; avio_skip(pb, 40); avio_read(pb, st-GREATER_TOKENcodec-GREATER_TOKENextradata, atom.size - 40); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int mov_read_strf(MOVContext *[[trond]], AVIOContext *pb, MOVAtom atom) OPEN_CURLY_TOKEN AVStream *st; if ([[trond]]-GREATER_TOKENfc-GREATER_TOKENnb_streams SMALLER_TOKEN 1) return 0; if (atom.size SMALLER_TOKEN= 40) return 0; st = [[trond]]-GREATER_TOKENfc-GREATER_TOKENstreamsOPEN_SQUARE_TOKEN[[trond]]-GREATER_TOKENfc-GREATER_TOKENnb_streams-1CLOSE_SQUARE_TOKEN; if ((uint64_t)atom.size GREATER_TOKEN (1SMALLER_TOKENSMALLER_TOKEN30)) return AVERROR_INVALIDDATA; av_free(st-GREATER_TOKENcodec-GREATER_TOKENextradata); st-GREATER_TOKENcodec-GREATER_TOKENextradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE); if (!st-GREATER_TOKENcodec-GREATER_TOKENextradata) return AVERROR(ENOMEM); st-GREATER_TOKENcodec-GREATER_TOKENextradata_size = atom.size - 40; avio_skip(pb, 40); avio_read(pb, st-GREATER_TOKENcodec-GREATER_TOKENextradata, atom.size - 40); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 34 ---------------------------------------------
[[0 (80%)]] --> [[1 (58%)]] --> Socre: 0.5832480788230896

[[[[Adv]]]]: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd, int64_t sector_num, QEMUIOVector *[[qiov]], int [[nb_sectors]], BlockDriverCompletionFunc *cb, void *[[opaque]], int type) OPEN_CURLY_TOKEN struct qemu_paiocb *acb; acb = qemu_aio_get(&raw_aio_pool, bs, cb, [[opaque]]); if (!acb) return NULL; acb-GREATER_TOKENaio_type = type; acb-GREATER_TOKENaio_fildes = fd; acb-GREATER_TOKENev_signo = SIGUSR2; acb-GREATER_TOKENasync_context_id = get_async_context_id(); if ([[qiov]]) OPEN_CURLY_TOKEN acb-GREATER_TOKENaio_iov = [[qiov]]-GREATER_TOKENiov; acb-GREATER_TOKENaio_niov = [[qiov]]-GREATER_TOKENniov; CLOSE_CURLY_TOKEN acb-GREATER_TOKENaio_nbytes = [[nb_sectors]] * 512; acb-GREATER_TOKENaio_offset = sector_num * 512; acb-GREATER_TOKENnext = posix_aio_state-GREATER_TOKENfirst_aio; posix_aio_state-GREATER_TOKENfirst_aio = acb; trace_paio_submit(acb, [[opaque]], sector_num, [[nb_sectors]], type); qemu_paio_submit(acb); return &acb-GREATER_TOKENcommon; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd, int64_t sector_num, QEMUIOVector *[[kristine]], int [[mckinnon]], BlockDriverCompletionFunc *cb, void *[[sally]], int type) OPEN_CURLY_TOKEN struct qemu_paiocb *acb; acb = qemu_aio_get(&raw_aio_pool, bs, cb, [[sally]]); if (!acb) return NULL; acb-GREATER_TOKENaio_type = type; acb-GREATER_TOKENaio_fildes = fd; acb-GREATER_TOKENev_signo = SIGUSR2; acb-GREATER_TOKENasync_context_id = get_async_context_id(); if ([[kristine]]) OPEN_CURLY_TOKEN acb-GREATER_TOKENaio_iov = [[kristine]]-GREATER_TOKENiov; acb-GREATER_TOKENaio_niov = [[kristine]]-GREATER_TOKENniov; CLOSE_CURLY_TOKEN acb-GREATER_TOKENaio_nbytes = [[mckinnon]] * 512; acb-GREATER_TOKENaio_offset = sector_num * 512; acb-GREATER_TOKENnext = posix_aio_state-GREATER_TOKENfirst_aio; posix_aio_state-GREATER_TOKENfirst_aio = acb; trace_paio_submit(acb, [[sally]], sector_num, [[mckinnon]], type); qemu_paio_submit(acb); return &acb-GREATER_TOKENcommon; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 35 ---------------------------------------------
[[0 (87%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int qemu_cpu_self(void *[[env]]) OPEN_CURLY_TOKEN return 1; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int qemu_cpu_self(void *[[finishes]]) OPEN_CURLY_TOKEN return 1; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 36 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint32_t gic_dist_readw(void *[[opaque]], target_phys_addr_t [[offset]]) OPEN_CURLY_TOKEN uint32_t [[val]]; [[val]] = gic_dist_readb([[opaque]], [[offset]]); [[val]] |= gic_dist_readb([[opaque]], [[offset]] + 1) SMALLER_TOKENSMALLER_TOKEN 8; return [[val]]; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static uint32_t gic_dist_readw(void *[[frederica]], target_phys_addr_t [[inseminate]]) OPEN_CURLY_TOKEN uint32_t [[unexploded]]; [[unexploded]] = gic_dist_readb([[frederica]], [[inseminate]]); [[unexploded]] |= gic_dist_readb([[frederica]], [[inseminate]] + 1) SMALLER_TOKENSMALLER_TOKEN 8; return [[unexploded]]; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 37 ---------------------------------------------
[[1 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw) OPEN_CURLY_TOKEN int i; uint16_t stctl = src-GREATER_TOKENscsw.ctrl & SCSW_CTRL_MASK_STCTL; uint16_t actl = src-GREATER_TOKENscsw.ctrl & SCSW_CTRL_MASK_ACTL; copy_scsw_to_guest(&dest-GREATER_TOKENscsw, &src-GREATER_TOKENscsw); for (i = 0; i SMALLER_TOKEN ARRAY_SIZE(dest-GREATER_TOKENesw); i++) OPEN_CURLY_TOKEN dest-GREATER_TOKENeswOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = cpu_to_be32(src-GREATER_TOKENeswOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN ARRAY_SIZE(dest-GREATER_TOKENecw); i++) OPEN_CURLY_TOKEN dest-GREATER_TOKENecwOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = cpu_to_be32(src-GREATER_TOKENecwOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN if ((src-GREATER_TOKENscsw.flags & SCSW_FLAGS_MASK_ESWF) || !(pmcw-GREATER_TOKENflags & PMCW_FLAGS_MASK_TF) || !(pmcw-GREATER_TOKENchars & PMCW_CHARS_MASK_XMWME)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN if (!(stctl & SCSW_STCTL_STATUS_PEND)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN if ((stctl & SCSW_STCTL_PRIMARY) || (stctl == SCSW_STCTL_SECONDARY) || ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN ARRAY_SIZE(dest-GREATER_TOKENemw); i++) OPEN_CURLY_TOKEN dest-GREATER_TOKENemwOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = cpu_to_be32(src-GREATER_TOKENemwOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 38 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 8 / 18 / 38:   1%|         | 38/2690 [00:00<00:00, 2860.95it/s][Succeeded / Failed / Skipped / Total] 13 / 8 / 18 / 39:   1%|         | 39/2690 [00:00<00:00, 2868.88it/s][Succeeded / Failed / Skipped / Total] 13 / 8 / 19 / 40:   1%|         | 40/2690 [00:00<00:00, 2901.28it/s][[1 (77%)]] --> [[0 (65%)]] --> Socre: 0.6549146175384521

[[[[Adv]]]]: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt, const void *pkt_data, size_t pkt_len) OPEN_CURLY_TOKEN struct virtio_net_hdr *[[vhdr]]; bool isip4, isip6, istcp, isudp; uint8_t *data; int len; if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN [[vhdr]] = vmxnet_rx_pkt_get_vhdr(pkt); if (!VMXNET_FLAG_IS_SET([[vhdr]]-GREATER_TOKENflags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp); if (!(isip4 || isip6) || !(istcp || isudp)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN vmxnet3_dump_virt_hdr([[vhdr]]); if (pkt_len SMALLER_TOKEN ([[vhdr]]-GREATER_TOKENcsum_start + [[vhdr]]-GREATER_TOKENcsum_offset + 2)) OPEN_CURLY_TOKEN VMW_PKPRN("packet len:%d SMALLER_TOKEN csum_start(%d) + csum_offset(%d) + 2, " "cannot calculate checksum", len, [[vhdr]]-GREATER_TOKENcsum_start, [[vhdr]]-GREATER_TOKENcsum_offset); return; CLOSE_CURLY_TOKEN data = (uint8_t *)pkt_data + [[vhdr]]-GREATER_TOKENcsum_start; len = pkt_len - [[vhdr]]-GREATER_TOKENcsum_start; stw_be_p(data + [[vhdr]]-GREATER_TOKENcsum_offset, net_raw_checksum(data, len)); [[vhdr]]-GREATER_TOKENflags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM; [[vhdr]]-GREATER_TOKENflags |= VIRTIO_NET_HDR_F_DATA_VALID; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt, const void *pkt_data, size_t pkt_len) OPEN_CURLY_TOKEN struct virtio_net_hdr *[[zuzana]]; bool isip4, isip6, istcp, isudp; uint8_t *data; int len; if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN [[zuzana]] = vmxnet_rx_pkt_get_vhdr(pkt); if (!VMXNET_FLAG_IS_SET([[zuzana]]-GREATER_TOKENflags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp); if (!(isip4 || isip6) || !(istcp || isudp)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN vmxnet3_dump_virt_hdr([[zuzana]]); if (pkt_len SMALLER_TOKEN ([[zuzana]]-GREATER_TOKENcsum_start + [[zuzana]]-GREATER_TOKENcsum_offset + 2)) OPEN_CURLY_TOKEN VMW_PKPRN("packet len:%d SMALLER_TOKEN csum_start(%d) + csum_offset(%d) + 2, " "cannot calculate checksum", len, [[zuzana]]-GREATER_TOKENcsum_start, [[zuzana]]-GREATER_TOKENcsum_offset); return; CLOSE_CURLY_TOKEN data = (uint8_t *)pkt_data + [[zuzana]]-GREATER_TOKENcsum_start; len = pkt_len - [[zuzana]]-GREATER_TOKENcsum_start; stw_be_p(data + [[zuzana]]-GREATER_TOKENcsum_offset, net_raw_checksum(data, len)); [[zuzana]]-GREATER_TOKENflags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM; [[zuzana]]-GREATER_TOKENflags |= VIRTIO_NET_HDR_F_DATA_VALID; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 39 ---------------------------------------------
[[0 (97%)]] --> [[1 (82%)]] --> Socre: 0.8159254789352417

[[[[Adv]]]]: static void mem_begin(MemoryListener *[[listener]]) OPEN_CURLY_TOKEN AddressSpaceDispatch *[[d]] = container_of([[listener]], AddressSpaceDispatch, [[listener]]); [[d]]-GREATER_TOKENphys_map.ptr = PHYS_MAP_NODE_NIL; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void mem_begin(MemoryListener *[[re]]) OPEN_CURLY_TOKEN AddressSpaceDispatch *[[column]] = container_of([[re]], AddressSpaceDispatch, [[re]]); [[column]]-GREATER_TOKENphys_map.ptr = PHYS_MAP_NODE_NIL; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 40 ---------------------------------------------
[[1 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf) OPEN_CURLY_TOKEN uint32_t rgb = 0; if (bpp == 32) OPEN_CURLY_TOKEN rgb |= ((bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN & ~1) | !((bufOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 3) & 1)) SMALLER_TOKENSMALLER_TOKEN 24; rgb |= ((bufOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN & ~1) | !((bufOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 2) & 1)) SMALLER_TOKENSMALLER_TOKEN 16; rgb |= ((bufOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN & ~1) | !((bufOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 1) & 1)) SMALLER_TOKENSMALLER_TOKEN 8; rgb |= ((bufOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN & ~1) | !((bufOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 0) & 1)) SMALLER_TOKENSMALLER_TOKEN 0; CLOSE_CURLY_TOKEN if (bpp == 16) OPEN_CURLY_TOKEN rgb |= ((bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN & ~1) | !((bufOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 1) & 1)) SMALLER_TOKENSMALLER_TOKEN 8; rgb |= ((bufOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN & ~1) | !((bufOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 0) & 1)) SMALLER_TOKENSMALLER_TOKEN 0; CLOSE_CURLY_TOKEN return rgb; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 41 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 13 / 8 / 20 / 41:   2%|         | 41/2690 [00:00<00:00, 2928.33it/s][Succeeded / Failed / Skipped / Total] 13 / 8 / 21 / 42:   2%|         | 42/2690 [00:00<00:00, 2960.49it/s][[1 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rv34_decode_mv(RV34DecContext *r, int block_type) OPEN_CURLY_TOKEN MpegEncContext *s = &r-GREATER_TOKENs; GetBitContext *gb = &s-GREATER_TOKENgb; int i, j, k, l; int mv_pos = s-GREATER_TOKENmb_x * 2 + s-GREATER_TOKENmb_y * 2 * s-GREATER_TOKENb8_stride; int next_bt; memset(r-GREATER_TOKENdmv, 0, sizeof(r-GREATER_TOKENdmv)); for(i = 0; i SMALLER_TOKEN num_mvsOPEN_SQUARE_TOKENblock_typeCLOSE_SQUARE_TOKEN; i++)OPEN_CURLY_TOKEN r-GREATER_TOKENdmvOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = svq3_get_se_golomb(gb); r-GREATER_TOKENdmvOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = svq3_get_se_golomb(gb); CLOSE_CURLY_TOKEN switch(block_type)OPEN_CURLY_TOKEN case RV34_MB_TYPE_INTRA: case RV34_MB_TYPE_INTRA16x16: ZERO8x2(s-GREATER_TOKENcurrent_picture_ptr-GREATER_TOKENf.motion_valOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENs-GREATER_TOKENmb_x * 2 + s-GREATER_TOKENmb_y * 2 * s-GREATER_TOKENb8_strideCLOSE_SQUARE_TOKEN, s-GREATER_TOKENb8_stride); return 0; case RV34_MB_SKIP: if(s-GREATER_TOKENpict_type == AV_PICTURE_TYPE_P)OPEN_CURLY_TOKEN ZERO8x2(s-GREATER_TOKENcurrent_picture_ptr-GREATER_TOKENf.motion_valOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENs-GREATER_TOKENmb_x * 2 + s-GREATER_TOKENmb_y * 2 * s-GREATER_TOKENb8_strideCLOSE_SQUARE_TOKEN, s-GREATER_TOKENb8_stride); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; CLOSE_CURLY_TOKEN case RV34_MB_B_DIRECT: if (HAVE_THREADS && (s-GREATER_TOKENavctx-GREATER_TOKENactive_thread_type & FF_THREAD_FRAME)) ff_thread_await_progress(&s-GREATER_TOKENnext_picture_ptr-GREATER_TOKENf, s-GREATER_TOKENmb_y - 1, 0); next_bt = s-GREATER_TOKENnext_picture_ptr-GREATER_TOKENf.mb_typeOPEN_SQUARE_TOKENs-GREATER_TOKENmb_x + s-GREATER_TOKENmb_y * s-GREATER_TOKENmb_strideCLOSE_SQUARE_TOKEN; if(IS_INTRA(next_bt) || IS_SKIP(next_bt))OPEN_CURLY_TOKEN ZERO8x2(s-GREATER_TOKENcurrent_picture_ptr-GREATER_TOKENf.motion_valOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENs-GREATER_TOKENmb_x * 2 + s-GREATER_TOKENmb_y * 2 * s-GREATER_TOKENb8_strideCLOSE_SQUARE_TOKEN, s-GREATER_TOKENb8_stride); ZERO8x2(s-GREATER_TOKENcurrent_picture_ptr-GREATER_TOKENf.motion_valOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENs-GREATER_TOKENmb_x * 2 + s-GREATER_TOKENmb_y * 2 * s-GREATER_TOKENb8_strideCLOSE_SQUARE_TOKEN, s-GREATER_TOKENb8_stride); CLOSE_CURLY_TOKENelse for(j = 0; j SMALLER_TOKEN 2; j++) for(i = 0; i SMALLER_TOKEN 2; i++) for(k = 0; k SMALLER_TOKEN 2; k++) for(l = 0; l SMALLER_TOKEN 2; l++) s-GREATER_TOKENcurrent_picture_ptr-GREATER_TOKENf.motion_valOPEN_SQUARE_TOKENlCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENmv_pos + i + j*s-GREATER_TOKENb8_strideCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENkCLOSE_SQUARE_TOKEN = calc_add_mv(r, l, s-GREATER_TOKENnext_picture_ptr-GREATER_TOKENf.motion_valOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENmv_pos + i + j*s-GREATER_TOKENb8_strideCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENkCLOSE_SQUARE_TOKEN); if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) rv34_mc_2mv(r, block_type); else rv34_mc_2mv_skip(r); ZERO8x2(s-GREATER_TOKENcurrent_picture_ptr-GREATER_TOKENf.motion_valOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENs-GREATER_TOKENmb_x * 2 + s-GREATER_TOKENmb_y * 2 * s-GREATER_TOKENb8_strideCLOSE_SQUARE_TOKEN, s-GREATER_TOKENb8_stride); break; case RV34_MB_P_16x16: case RV34_MB_P_MIX16x16: rv34_pred_mv(r, block_type, 0, 0); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; case RV34_MB_B_FORWARD: case RV34_MB_B_BACKWARD: r-GREATER_TOKENdmvOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = r-GREATER_TOKENdmvOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; r-GREATER_TOKENdmvOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = r-GREATER_TOKENdmvOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; if(r-GREATER_TOKENrv30) rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD); else rv34_pred_mv_b (r, block_type, block_type == RV34_MB_B_BACKWARD); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD); break; case RV34_MB_P_16x8: case RV34_MB_P_8x16: rv34_pred_mv(r, block_type, 0, 0); rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1); if(block_type == RV34_MB_P_16x8)OPEN_CURLY_TOKEN rv34_mc_1mv(r, block_type, 0, 0, 0, 2, 1, 0); rv34_mc_1mv(r, block_type, 0, 8, s-GREATER_TOKENb8_stride, 2, 1, 0); CLOSE_CURLY_TOKEN if(block_type == RV34_MB_P_8x16)OPEN_CURLY_TOKEN rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0); rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0); CLOSE_CURLY_TOKEN break; case RV34_MB_B_BIDIR: rv34_pred_mv_b (r, block_type, 0); rv34_pred_mv_b (r, block_type, 1); rv34_mc_2mv (r, block_type); break; case RV34_MB_P_8x8: for(i=0;iSMALLER_TOKEN 4;i++)OPEN_CURLY_TOKEN rv34_pred_mv(r, block_type, i, i); rv34_mc_1mv (r, block_type, (i&1)SMALLER_TOKENSMALLER_TOKEN3, (i&2)SMALLER_TOKENSMALLER_TOKEN2, (i&1)+(iGREATER_TOKENGREATER_TOKEN1)*s-GREATER_TOKENb8_stride, 1, 1, 0); CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 42 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void tcp_start_incoming_migration(const char *host_port, Error **errp) OPEN_CURLY_TOKEN int s; s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp); if (s SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL, (void *)(intptr_t)s); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 43 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 13 / 8 / 22 / 43:   2%|         | 43/2690 [00:00<00:00, 2986.90it/s][Succeeded / Failed / Skipped / Total] 14 / 8 / 22 / 44:   2%|         | 44/2690 [00:00<00:00, 2946.28it/s][[1 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int process_input_packet(InputStream *ist, const AVPacket *pkt) OPEN_CURLY_TOKEN int i; int got_output; AVPacket avpkt; if (ist-GREATER_TOKENnext_dts == AV_NOPTS_VALUE) ist-GREATER_TOKENnext_dts = ist-GREATER_TOKENlast_dts; if (pkt == NULL) OPEN_CURLY_TOKEN av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN avpkt = *pkt; CLOSE_CURLY_TOKEN if (pkt-GREATER_TOKENdts != AV_NOPTS_VALUE) ist-GREATER_TOKENnext_dts = ist-GREATER_TOKENlast_dts = av_rescale_q(pkt-GREATER_TOKENdts, ist-GREATER_TOKENst-GREATER_TOKENtime_base, AV_TIME_BASE_Q); while (ist-GREATER_TOKENdecoding_needed && (avpkt.size GREATER_TOKEN 0 || (!pkt && got_output))) OPEN_CURLY_TOKEN int ret = 0; handle_eof: ist-GREATER_TOKENlast_dts = ist-GREATER_TOKENnext_dts; if (avpkt.size && avpkt.size != pkt-GREATER_TOKENsize && !(ist-GREATER_TOKENdec-GREATER_TOKENcapabilities & CODEC_CAP_SUBFRAMES)) OPEN_CURLY_TOKEN av_log(NULL, ist-GREATER_TOKENshowed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, "Multiple frames in a packet from stream %d\n", pkt-GREATER_TOKENstream_index); ist-GREATER_TOKENshowed_multi_packet_warning = 1; CLOSE_CURLY_TOKEN switch (ist-GREATER_TOKENdec_ctx-GREATER_TOKENcodec_type) OPEN_CURLY_TOKEN case AVMEDIA_TYPE_AUDIO: ret = decode_audio (ist, &avpkt, &got_output); break; case AVMEDIA_TYPE_VIDEO: ret = decode_video (ist, &avpkt, &got_output); if (avpkt.duration) ist-GREATER_TOKENnext_dts += av_rescale_q(avpkt.duration, ist-GREATER_TOKENst-GREATER_TOKENtime_base, AV_TIME_BASE_Q); else if (ist-GREATER_TOKENst-GREATER_TOKENavg_frame_rate.num) ist-GREATER_TOKENnext_dts += av_rescale_q(1, av_inv_q(ist-GREATER_TOKENst-GREATER_TOKENavg_frame_rate), AV_TIME_BASE_Q); else if (ist-GREATER_TOKENdec_ctx-GREATER_TOKENtime_base.num != 0) OPEN_CURLY_TOKEN int ticks = ist-GREATER_TOKENst-GREATER_TOKENparser ? ist-GREATER_TOKENst-GREATER_TOKENparser-GREATER_TOKENrepeat_pict + 1 : ist-GREATER_TOKENdec_ctx-GREATER_TOKENticks_per_frame; ist-GREATER_TOKENnext_dts += av_rescale_q(ticks, ist-GREATER_TOKENdec_ctx-GREATER_TOKENtime_base, AV_TIME_BASE_Q); CLOSE_CURLY_TOKEN break; case AVMEDIA_TYPE_SUBTITLE: ret = transcode_subtitles(ist, &avpkt, &got_output); break; default: return -1; CLOSE_CURLY_TOKEN if (ret SMALLER_TOKEN 0) return ret; if (pkt) OPEN_CURLY_TOKEN avpkt.data += ret; avpkt.size -= ret; CLOSE_CURLY_TOKEN if (!got_output) OPEN_CURLY_TOKEN continue; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (!ist-GREATER_TOKENdecoding_needed) OPEN_CURLY_TOKEN ist-GREATER_TOKENlast_dts = ist-GREATER_TOKENnext_dts; switch (ist-GREATER_TOKENdec_ctx-GREATER_TOKENcodec_type) OPEN_CURLY_TOKEN case AVMEDIA_TYPE_AUDIO: ist-GREATER_TOKENnext_dts += ((int64_t)AV_TIME_BASE * ist-GREATER_TOKENdec_ctx-GREATER_TOKENframe_size) / ist-GREATER_TOKENdec_ctx-GREATER_TOKENsample_rate; break; case AVMEDIA_TYPE_VIDEO: if (ist-GREATER_TOKENdec_ctx-GREATER_TOKENtime_base.num != 0) OPEN_CURLY_TOKEN int ticks = ist-GREATER_TOKENst-GREATER_TOKENparser ? ist-GREATER_TOKENst-GREATER_TOKENparser-GREATER_TOKENrepeat_pict + 1 : ist-GREATER_TOKENdec_ctx-GREATER_TOKENticks_per_frame; ist-GREATER_TOKENnext_dts += ((int64_t)AV_TIME_BASE * ist-GREATER_TOKENdec_ctx-GREATER_TOKENtime_base.num * ticks) / ist-GREATER_TOKENdec_ctx-GREATER_TOKENtime_base.den; CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (i = 0; pkt && i SMALLER_TOKEN nb_output_streams; i++) OPEN_CURLY_TOKEN OutputStream *ost = output_streamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; if (!check_output_constraints(ist, ost) || ost-GREATER_TOKENencoding_needed) continue; do_streamcopy(ist, ost, pkt); CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 44 ---------------------------------------------
[[0 (55%)]] --> [[1 (67%)]] --> Socre: 0.6701654195785522

[[[[Adv]]]]: static int write_f(int argc, char **argv) OPEN_CURLY_TOKEN struct timeval t1, t2; int Cflag = 0, pflag = 0, qflag = 0, bflag = 0; int c, cnt; char *buf; int64_t offset; int [[count]]; int total = 0; int pattern = 0xcd; while ((c = getopt(argc, argv, "bCpP:q")) != EOF) OPEN_CURLY_TOKEN switch (c) OPEN_CURLY_TOKEN case 'b': bflag = 1; break; case 'C': Cflag = 1; break; case 'p': pflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN break; case 'q': qflag = 1; break; default: return command_usage(&write_cmd); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (optind != argc - 2) OPEN_CURLY_TOKEN return command_usage(&write_cmd); CLOSE_CURLY_TOKEN if (bflag && pflag) OPEN_CURLY_TOKEN printf("-b and -p cannot be specified at the same time\n"); return 0; CLOSE_CURLY_TOKEN offset = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if (offset SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("non-numeric length argument -- %s\n", argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN optind++; [[count]] = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if ([[count]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("non-numeric length argument -- %s\n", argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN if (!pflag) OPEN_CURLY_TOKEN if (offset & 0x1ff) OPEN_CURLY_TOKEN printf("offset %" PRId64 " is not sector aligned\n", offset); return 0; CLOSE_CURLY_TOKEN if ([[count]] & 0x1ff) OPEN_CURLY_TOKEN printf("count %d is not sector aligned\n", [[count]]); return 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN buf = qemu_io_alloc([[count]], pattern); gettimeofday(&t1, NULL); if (pflag) OPEN_CURLY_TOKEN cnt = do_pwrite(buf, offset, [[count]], &total); CLOSE_CURLY_TOKEN else if (bflag) OPEN_CURLY_TOKEN cnt = do_save_vmstate(buf, offset, [[count]], &total); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN cnt = do_write(buf, offset, [[count]], &total); CLOSE_CURLY_TOKEN gettimeofday(&t2, NULL); if (cnt SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("write failed: %s\n", strerror(-cnt)); goto out; CLOSE_CURLY_TOKEN if (qflag) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN t2 = tsub(t2, t1); print_report("wrote", &t2, offset, [[count]], total, cnt, Cflag); out: qemu_io_free(buf); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int write_f(int argc, char **argv) OPEN_CURLY_TOKEN struct timeval t1, t2; int Cflag = 0, pflag = 0, qflag = 0, bflag = 0; int c, cnt; char *buf; int64_t offset; int [[pteranodon]]; int total = 0; int pattern = 0xcd; while ((c = getopt(argc, argv, "bCpP:q")) != EOF) OPEN_CURLY_TOKEN switch (c) OPEN_CURLY_TOKEN case 'b': bflag = 1; break; case 'C': Cflag = 1; break; case 'p': pflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN break; case 'q': qflag = 1; break; default: return command_usage(&write_cmd); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (optind != argc - 2) OPEN_CURLY_TOKEN return command_usage(&write_cmd); CLOSE_CURLY_TOKEN if (bflag && pflag) OPEN_CURLY_TOKEN printf("-b and -p cannot be specified at the same time\n"); return 0; CLOSE_CURLY_TOKEN offset = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if (offset SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("non-numeric length argument -- %s\n", argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN optind++; [[pteranodon]] = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if ([[pteranodon]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("non-numeric length argument -- %s\n", argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN if (!pflag) OPEN_CURLY_TOKEN if (offset & 0x1ff) OPEN_CURLY_TOKEN printf("offset %" PRId64 " is not sector aligned\n", offset); return 0; CLOSE_CURLY_TOKEN if ([[pteranodon]] & 0x1ff) OPEN_CURLY_TOKEN printf("count %d is not sector aligned\n", [[pteranodon]]); return 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN buf = qemu_io_alloc([[pteranodon]], pattern); gettimeofday(&t1, NULL); if (pflag) OPEN_CURLY_TOKEN cnt = do_pwrite(buf, offset, [[pteranodon]], &total); CLOSE_CURLY_TOKEN else if (bflag) OPEN_CURLY_TOKEN cnt = do_save_vmstate(buf, offset, [[pteranodon]], &total); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN cnt = do_write(buf, offset, [[pteranodon]], &total); CLOSE_CURLY_TOKEN gettimeofday(&t2, NULL); if (cnt SMALLER_TOKEN 0) OPEN_CURLY_TOKEN printf("write failed: %s\n", strerror(-cnt)); goto out; CLOSE_CURLY_TOKEN if (qflag) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN t2 = tsub(t2, t1); print_report("wrote", &t2, offset, [[pteranodon]], total, cnt, Cflag); out: qemu_io_free(buf); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 45 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 14 / 8 / 23 / 45:   2%|         | 45/2690 [00:00<00:00, 2962.40it/s][[1 (75%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void build_feed_streams(void) OPEN_CURLY_TOKEN FFStream *stream, *feed; int i; for(stream = first_stream; stream != NULL; stream = stream-GREATER_TOKENnext) OPEN_CURLY_TOKEN feed = stream-GREATER_TOKENfeed; if (feed) OPEN_CURLY_TOKEN if (!stream-GREATER_TOKENis_feed) OPEN_CURLY_TOKEN for(i=0;iSMALLER_TOKENstream-GREATER_TOKENnb_streams;i++) stream-GREATER_TOKENfeed_streamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = add_av_stream(feed, stream-GREATER_TOKENstreamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for(stream = first_stream; stream != NULL; stream = stream-GREATER_TOKENnext) OPEN_CURLY_TOKEN feed = stream-GREATER_TOKENfeed; if (feed) OPEN_CURLY_TOKEN if (stream-GREATER_TOKENis_feed) OPEN_CURLY_TOKEN for(i=0;iSMALLER_TOKENstream-GREATER_TOKENnb_streams;i++) stream-GREATER_TOKENfeed_streamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = i; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for(feed = first_feed; feed != NULL; feed = feed-GREATER_TOKENnext_feed) OPEN_CURLY_TOKEN int fd; if (url_exist(feed-GREATER_TOKENfeed_filename)) OPEN_CURLY_TOKEN AVFormatContext *s; int matches = 0; if (av_open_input_file(&s, feed-GREATER_TOKENfeed_filename, NULL, FFM_PACKET_SIZE, NULL) GREATER_TOKEN= 0) OPEN_CURLY_TOKEN if (s-GREATER_TOKENnb_streams == feed-GREATER_TOKENnb_streams) OPEN_CURLY_TOKEN matches = 1; for(i=0;iSMALLER_TOKENs-GREATER_TOKENnb_streams;i++) OPEN_CURLY_TOKEN AVStream *sf, *ss; sf = feed-GREATER_TOKENstreamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; ss = s-GREATER_TOKENstreamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; if (sf-GREATER_TOKENindex != ss-GREATER_TOKENindex || sf-GREATER_TOKENid != ss-GREATER_TOKENid) OPEN_CURLY_TOKEN http_log("Index & Id do not match for stream %d (%s)\n", i, feed-GREATER_TOKENfeed_filename); matches = 0; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN AVCodecContext *ccf, *ccs; ccf = sf-GREATER_TOKENcodec; ccs = ss-GREATER_TOKENcodec; #define CHECK_CODEC(x) (ccf-GREATER_TOKENx != ccs-GREATER_TOKENx) if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) OPEN_CURLY_TOKEN http_log("Codecs do not match for stream %d\n", i); matches = 0; CLOSE_CURLY_TOKEN else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) OPEN_CURLY_TOKEN http_log("Codec bitrates do not match for stream %d\n", i); matches = 0; CLOSE_CURLY_TOKEN else if (ccf-GREATER_TOKENcodec_type == AVMEDIA_TYPE_VIDEO) OPEN_CURLY_TOKEN if (CHECK_CODEC(time_base.den) || CHECK_CODEC(time_base.num) || CHECK_CODEC(width) || CHECK_CODEC(height)) OPEN_CURLY_TOKEN http_log("Codec width, height and framerate do not match for stream %d\n", i); matches = 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (ccf-GREATER_TOKENcodec_type == AVMEDIA_TYPE_AUDIO) OPEN_CURLY_TOKEN if (CHECK_CODEC(sample_rate) || CHECK_CODEC(channels) || CHECK_CODEC(frame_size)) OPEN_CURLY_TOKEN http_log("Codec sample_rate, channels, frame_size do not match for stream %d\n", i); matches = 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN http_log("Unknown codec type\n"); matches = 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (!matches) break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else http_log("Deleting feed file '%s' as stream counts differ (%d != %d)\n", feed-GREATER_TOKENfeed_filename, s-GREATER_TOKENnb_streams, feed-GREATER_TOKENnb_streams); av_close_input_file(s); CLOSE_CURLY_TOKEN else http_log("Deleting feed file '%s' as it appears to be corrupt\n", feed-GREATER_TOKENfeed_filename); if (!matches) OPEN_CURLY_TOKEN if (feed-GREATER_TOKENreadonly) OPEN_CURLY_TOKEN http_log("Unable to delete feed file '%s' as it is marked readonly\n", feed-GREATER_TOKENfeed_filename); exit(1); CLOSE_CURLY_TOKEN unlink(feed-GREATER_TOKENfeed_filename); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (!url_exist(feed-GREATER_TOKENfeed_filename)) OPEN_CURLY_TOKEN AVFormatContext s1 = OPEN_CURLY_TOKEN0CLOSE_CURLY_TOKEN, *s = &s1; if (feed-GREATER_TOKENreadonly) OPEN_CURLY_TOKEN http_log("Unable to create feed file '%s' as it is marked readonly\n", feed-GREATER_TOKENfeed_filename); exit(1); CLOSE_CURLY_TOKEN if (avio_open(&s-GREATER_TOKENpb, feed-GREATER_TOKENfeed_filename, AVIO_FLAG_WRITE) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN http_log("Could not open output feed file '%s'\n", feed-GREATER_TOKENfeed_filename); exit(1); CLOSE_CURLY_TOKEN s-GREATER_TOKENoformat = feed-GREATER_TOKENfmt; s-GREATER_TOKENnb_streams = feed-GREATER_TOKENnb_streams; for(i=0;iSMALLER_TOKENs-GREATER_TOKENnb_streams;i++) OPEN_CURLY_TOKEN AVStream *st; st = feed-GREATER_TOKENstreamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; s-GREATER_TOKENstreamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = st; CLOSE_CURLY_TOKEN av_set_parameters(s, NULL); if (av_write_header(s) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN http_log("Container doesn't supports the required parameters\n"); exit(1); CLOSE_CURLY_TOKEN av_freep(&s-GREATER_TOKENpriv_data); avio_close(s-GREATER_TOKENpb); CLOSE_CURLY_TOKEN fd = open(feed-GREATER_TOKENfeed_filename, O_RDONLY); if (fd SMALLER_TOKEN 0) OPEN_CURLY_TOKEN http_log("Could not open output feed file '%s'\n", feed-GREATER_TOKENfeed_filename); exit(1); CLOSE_CURLY_TOKEN feed-GREATER_TOKENfeed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE); feed-GREATER_TOKENfeed_size = lseek(fd, 0, SEEK_END); if (feed-GREATER_TOKENfeed_max_size && feed-GREATER_TOKENfeed_max_size SMALLER_TOKEN feed-GREATER_TOKENfeed_size) feed-GREATER_TOKENfeed_max_size = feed-GREATER_TOKENfeed_size; close(fd); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 46 ---------------------------------------------
[[1 (63%)]] --> [[0 (59%)]] --> Socre: 0.5861698389053345

[[[[Adv]]]]: int net_init_tap(const Netdev *netdev, const char *name, NetClientState *peer, Error **[[errp]]) OPEN_CURLY_TOKEN const NetdevTapOptions *tap; int fd, vnet_hdr = 0, i = 0, queues; const char *script = NULL; const char *downscript = NULL; Error *err = NULL; const char *vhostfdname; char ifnameOPEN_SQUARE_TOKEN128CLOSE_SQUARE_TOKEN; assert(netdev-GREATER_TOKENtype == NET_CLIENT_DRIVER_TAP); tap = &netdev-GREATER_TOKENu.tap; queues = tap-GREATER_TOKENhas_queues ? tap-GREATER_TOKENqueues : 1; vhostfdname = tap-GREATER_TOKENhas_vhostfd ? tap-GREATER_TOKENvhostfd : NULL; if (peer && (tap-GREATER_TOKENhas_queues || tap-GREATER_TOKENhas_fds || tap-GREATER_TOKENhas_vhostfds)) OPEN_CURLY_TOKEN error_setg([[errp]], "Multiqueue tap cannot be used with QEMU vlans"); return -1; CLOSE_CURLY_TOKEN if (tap-GREATER_TOKENhas_fd) OPEN_CURLY_TOKEN if (tap-GREATER_TOKENhas_ifname || tap-GREATER_TOKENhas_script || tap-GREATER_TOKENhas_downscript || tap-GREATER_TOKENhas_vnet_hdr || tap-GREATER_TOKENhas_helper || tap-GREATER_TOKENhas_queues || tap-GREATER_TOKENhas_fds || tap-GREATER_TOKENhas_vhostfds) OPEN_CURLY_TOKEN error_setg([[errp]], "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, fds=, and vhostfds= " "are invalid with fd="); return -1; CLOSE_CURLY_TOKEN fd = monitor_fd_param(cur_mon, tap-GREATER_TOKENfd, &err); if (fd == -1) OPEN_CURLY_TOKEN error_propagate([[errp]], err); return -1; CLOSE_CURLY_TOKEN fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "tap", name, NULL, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) OPEN_CURLY_TOKEN error_propagate([[errp]], err); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (tap-GREATER_TOKENhas_fds) OPEN_CURLY_TOKEN char **fds = g_new0(char *, MAX_TAP_QUEUES); char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES); int nfds, nvhosts; if (tap-GREATER_TOKENhas_ifname || tap-GREATER_TOKENhas_script || tap-GREATER_TOKENhas_downscript || tap-GREATER_TOKENhas_vnet_hdr || tap-GREATER_TOKENhas_helper || tap-GREATER_TOKENhas_queues || tap-GREATER_TOKENhas_vhostfd) OPEN_CURLY_TOKEN error_setg([[errp]], "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, and vhostfd= " "are invalid with fds="); return -1; CLOSE_CURLY_TOKEN nfds = get_fds(tap-GREATER_TOKENfds, fds, MAX_TAP_QUEUES); if (tap-GREATER_TOKENhas_vhostfds) OPEN_CURLY_TOKEN nvhosts = get_fds(tap-GREATER_TOKENvhostfds, vhost_fds, MAX_TAP_QUEUES); if (nfds != nvhosts) OPEN_CURLY_TOKEN error_setg([[errp]], "The number of fds passed does not match " "the number of vhostfds passed"); goto free_fail; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN nfds; i++) OPEN_CURLY_TOKEN fd = monitor_fd_param(cur_mon, fdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, &err); if (fd == -1) OPEN_CURLY_TOKEN error_propagate([[errp]], err); goto free_fail; CLOSE_CURLY_TOKEN fcntl(fd, F_SETFL, O_NONBLOCK); if (i == 0) OPEN_CURLY_TOKEN vnet_hdr = tap_probe_vnet_hdr(fd); CLOSE_CURLY_TOKEN else if (vnet_hdr != tap_probe_vnet_hdr(fd)) OPEN_CURLY_TOKEN error_setg([[errp]], "vnet_hdr not consistent across given tap fds"); goto free_fail; CLOSE_CURLY_TOKEN net_init_tap_one(tap, peer, "tap", name, ifname, script, downscript, tap-GREATER_TOKENhas_vhostfds ? vhost_fdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN : NULL, vnet_hdr, fd, &err); if (err) OPEN_CURLY_TOKEN error_propagate([[errp]], err); goto free_fail; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN g_free(fds); g_free(vhost_fds); return 0; free_fail: for (i = 0; i SMALLER_TOKEN nfds; i++) OPEN_CURLY_TOKEN g_free(fdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); g_free(vhost_fdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN g_free(fds); g_free(vhost_fds); return -1; CLOSE_CURLY_TOKEN else if (tap-GREATER_TOKENhas_helper) OPEN_CURLY_TOKEN if (tap-GREATER_TOKENhas_ifname || tap-GREATER_TOKENhas_script || tap-GREATER_TOKENhas_downscript || tap-GREATER_TOKENhas_vnet_hdr || tap-GREATER_TOKENhas_queues || tap-GREATER_TOKENhas_vhostfds) OPEN_CURLY_TOKEN error_setg([[errp]], "ifname=, script=, downscript=, vnet_hdr=, " "queues=, and vhostfds= are invalid with helper="); return -1; CLOSE_CURLY_TOKEN fd = net_bridge_run_helper(tap-GREATER_TOKENhelper, tap-GREATER_TOKENhas_br ? tap-GREATER_TOKENbr : DEFAULT_BRIDGE_INTERFACE, [[errp]]); if (fd == -1) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "bridge", name, ifname, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) OPEN_CURLY_TOKEN error_propagate([[errp]], err); close(fd); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (tap-GREATER_TOKENhas_vhostfds) OPEN_CURLY_TOKEN error_setg([[errp]], "vhostfds= is invalid if fds= wasn't specified"); return -1; CLOSE_CURLY_TOKEN script = tap-GREATER_TOKENhas_script ? tap-GREATER_TOKENscript : DEFAULT_NETWORK_SCRIPT; downscript = tap-GREATER_TOKENhas_downscript ? tap-GREATER_TOKENdownscript : DEFAULT_NETWORK_DOWN_SCRIPT; if (tap-GREATER_TOKENhas_ifname) OPEN_CURLY_TOKEN pstrcpy(ifname, sizeof ifname, tap-GREATER_TOKENifname); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ifnameOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = '\0'; CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN queues; i++) OPEN_CURLY_TOKEN fd = net_tap_init(tap, &vnet_hdr, i GREATER_TOKEN= 1 ? "no" : script, ifname, sizeof ifname, queues GREATER_TOKEN 1, [[errp]]); if (fd == -1) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN if (queues GREATER_TOKEN 1 && i == 0 && !tap-GREATER_TOKENhas_ifname) OPEN_CURLY_TOKEN if (tap_fd_get_ifname(fd, ifname)) OPEN_CURLY_TOKEN error_setg([[errp]], "Fail to get ifname"); close(fd); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN net_init_tap_one(tap, peer, "tap", name, ifname, i GREATER_TOKEN= 1 ? "no" : script, i GREATER_TOKEN= 1 ? "no" : downscript, vhostfdname, vnet_hdr, fd, &err); if (err) OPEN_CURLY_TOKEN error_propagate([[errp]], err); close(fd); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int net_init_tap(const Netdev *netdev, const char *name, NetClientState *peer, Error **[[sunnyside]]) OPEN_CURLY_TOKEN const NetdevTapOptions *tap; int fd, vnet_hdr = 0, i = 0, queues; const char *script = NULL; const char *downscript = NULL; Error *err = NULL; const char *vhostfdname; char ifnameOPEN_SQUARE_TOKEN128CLOSE_SQUARE_TOKEN; assert(netdev-GREATER_TOKENtype == NET_CLIENT_DRIVER_TAP); tap = &netdev-GREATER_TOKENu.tap; queues = tap-GREATER_TOKENhas_queues ? tap-GREATER_TOKENqueues : 1; vhostfdname = tap-GREATER_TOKENhas_vhostfd ? tap-GREATER_TOKENvhostfd : NULL; if (peer && (tap-GREATER_TOKENhas_queues || tap-GREATER_TOKENhas_fds || tap-GREATER_TOKENhas_vhostfds)) OPEN_CURLY_TOKEN error_setg([[sunnyside]], "Multiqueue tap cannot be used with QEMU vlans"); return -1; CLOSE_CURLY_TOKEN if (tap-GREATER_TOKENhas_fd) OPEN_CURLY_TOKEN if (tap-GREATER_TOKENhas_ifname || tap-GREATER_TOKENhas_script || tap-GREATER_TOKENhas_downscript || tap-GREATER_TOKENhas_vnet_hdr || tap-GREATER_TOKENhas_helper || tap-GREATER_TOKENhas_queues || tap-GREATER_TOKENhas_fds || tap-GREATER_TOKENhas_vhostfds) OPEN_CURLY_TOKEN error_setg([[sunnyside]], "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, fds=, and vhostfds= " "are invalid with fd="); return -1; CLOSE_CURLY_TOKEN fd = monitor_fd_param(cur_mon, tap-GREATER_TOKENfd, &err); if (fd == -1) OPEN_CURLY_TOKEN error_propagate([[sunnyside]], err); return -1; CLOSE_CURLY_TOKEN fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "tap", name, NULL, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) OPEN_CURLY_TOKEN error_propagate([[sunnyside]], err); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (tap-GREATER_TOKENhas_fds) OPEN_CURLY_TOKEN char **fds = g_new0(char *, MAX_TAP_QUEUES); char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES); int nfds, nvhosts; if (tap-GREATER_TOKENhas_ifname || tap-GREATER_TOKENhas_script || tap-GREATER_TOKENhas_downscript || tap-GREATER_TOKENhas_vnet_hdr || tap-GREATER_TOKENhas_helper || tap-GREATER_TOKENhas_queues || tap-GREATER_TOKENhas_vhostfd) OPEN_CURLY_TOKEN error_setg([[sunnyside]], "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, and vhostfd= " "are invalid with fds="); return -1; CLOSE_CURLY_TOKEN nfds = get_fds(tap-GREATER_TOKENfds, fds, MAX_TAP_QUEUES); if (tap-GREATER_TOKENhas_vhostfds) OPEN_CURLY_TOKEN nvhosts = get_fds(tap-GREATER_TOKENvhostfds, vhost_fds, MAX_TAP_QUEUES); if (nfds != nvhosts) OPEN_CURLY_TOKEN error_setg([[sunnyside]], "The number of fds passed does not match " "the number of vhostfds passed"); goto free_fail; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN nfds; i++) OPEN_CURLY_TOKEN fd = monitor_fd_param(cur_mon, fdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, &err); if (fd == -1) OPEN_CURLY_TOKEN error_propagate([[sunnyside]], err); goto free_fail; CLOSE_CURLY_TOKEN fcntl(fd, F_SETFL, O_NONBLOCK); if (i == 0) OPEN_CURLY_TOKEN vnet_hdr = tap_probe_vnet_hdr(fd); CLOSE_CURLY_TOKEN else if (vnet_hdr != tap_probe_vnet_hdr(fd)) OPEN_CURLY_TOKEN error_setg([[sunnyside]], "vnet_hdr not consistent across given tap fds"); goto free_fail; CLOSE_CURLY_TOKEN net_init_tap_one(tap, peer, "tap", name, ifname, script, downscript, tap-GREATER_TOKENhas_vhostfds ? vhost_fdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN : NULL, vnet_hdr, fd, &err); if (err) OPEN_CURLY_TOKEN error_propagate([[sunnyside]], err); goto free_fail; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN g_free(fds); g_free(vhost_fds); return 0; free_fail: for (i = 0; i SMALLER_TOKEN nfds; i++) OPEN_CURLY_TOKEN g_free(fdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); g_free(vhost_fdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN g_free(fds); g_free(vhost_fds); return -1; CLOSE_CURLY_TOKEN else if (tap-GREATER_TOKENhas_helper) OPEN_CURLY_TOKEN if (tap-GREATER_TOKENhas_ifname || tap-GREATER_TOKENhas_script || tap-GREATER_TOKENhas_downscript || tap-GREATER_TOKENhas_vnet_hdr || tap-GREATER_TOKENhas_queues || tap-GREATER_TOKENhas_vhostfds) OPEN_CURLY_TOKEN error_setg([[sunnyside]], "ifname=, script=, downscript=, vnet_hdr=, " "queues=, and vhostfds= are invalid with helper="); return -1; CLOSE_CURLY_TOKEN fd = net_bridge_run_helper(tap-GREATER_TOKENhelper, tap-GREATER_TOKENhas_br ? tap-GREATER_TOKENbr : DEFAULT_BRIDGE_INTERFACE, [[sunnyside]]); if (fd == -1) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "bridge", name, ifname, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) OPEN_CURLY_TOKEN error_propagate([[sunnyside]], err); close(fd); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (tap-GREATER_TOKENhas_vhostfds) OPEN_CURLY_TOKEN error_setg([[sunnyside]], "vhostfds= is invalid if fds= wasn't specified"); return -1; CLOSE_CURLY_TOKEN script = tap-GREATER_TOKENhas_script ? tap-GREATER_TOKENscript : DEFAULT_NETWORK_SCRIPT; downscript = tap-GREATER_TOKENhas_downscript ? tap-GREATER_TOKENdownscript : DEFAULT_NETWORK_DOWN_SCRIPT; if (tap-GREATER_TOKENhas_ifname) OPEN_CURLY_TOKEN pstrcpy(ifname, sizeof ifname, tap-GREATER_TOKENifname); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ifnameOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = '\0'; CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN queues; i++) OPEN_CURLY_TOKEN fd = net_tap_init(tap, &vnet_hdr, i GREATER_TOKEN= 1 ? "no" : script, ifname, sizeof ifname, queues GREATER_TOKEN 1, [[sunnyside]]); if (fd == -1) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN if (queues GREATER_TOKEN 1 && i == 0 && !tap-GREATER_TOKENhas_ifname) OPEN_CURLY_TOKEN if (tap_fd_get_ifname(fd, ifname)) OPEN_CURLY_TOKEN error_setg([[sunnyside]], "Fail to get ifname"); close(fd); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN net_init_tap_one(tap, peer, "tap", name, ifname, i GREATER_TOKEN= 1 ? "no" : script, i GREATER_TOKEN= 1 ? "no" : downscript, vhostfdname, vnet_hdr, fd, &err); if (err) OPEN_CURLY_TOKEN error_propagate([[sunnyside]], err); close(fd); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 15 / 8 / 23 / 46:   2%|         | 46/2690 [00:00<00:00, 2881.48it/s][Succeeded / Failed / Skipped / Total] 15 / 8 / 24 / 47:   2%|         | 47/2690 [00:00<00:00, 2901.65it/s][Succeeded / Failed / Skipped / Total] 15 / 8 / 25 / 48:   2%|         | 48/2690 [00:00<00:00, 2925.41it/s]
--------------------------------------------- Result 47 ---------------------------------------------
[[0 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target, const char *replaces, int64_t speed, uint32_t granularity, int64_t buf_size, BlockdevOnError on_source_error, BlockdevOnError on_target_error, bool unmap, BlockCompletionFunc *cb, void *opaque, Error **errp, const BlockJobDriver *driver, bool is_none_mode, BlockDriverState *base) OPEN_CURLY_TOKEN MirrorBlockJob *s; if (granularity == 0) OPEN_CURLY_TOKEN granularity = bdrv_get_default_bitmap_granularity(target); CLOSE_CURLY_TOKEN assert ((granularity & (granularity - 1)) == 0); if ((on_source_error == BLOCKDEV_ON_ERROR_STOP || on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) && (!bs-GREATER_TOKENblk || !blk_iostatus_is_enabled(bs-GREATER_TOKENblk))) OPEN_CURLY_TOKEN error_setg(errp, QERR_INVALID_PARAMETER, "on-source-error"); return; CLOSE_CURLY_TOKEN if (buf_size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN error_setg(errp, "Invalid parameter 'buf-size'"); return; CLOSE_CURLY_TOKEN if (buf_size == 0) OPEN_CURLY_TOKEN buf_size = DEFAULT_MIRROR_BUF_SIZE; CLOSE_CURLY_TOKEN if (replaces) OPEN_CURLY_TOKEN replaced_bs = bdrv_lookup_bs(replaces, replaces, errp); if (replaced_bs == NULL) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN replaced_bs = bs; CLOSE_CURLY_TOKEN if (replaced_bs-GREATER_TOKENblk && target-GREATER_TOKENblk) OPEN_CURLY_TOKEN error_setg(errp, "Can't create node with two BlockBackends"); return; CLOSE_CURLY_TOKEN s = block_job_create(driver, bs, speed, cb, opaque, errp); if (!s) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN s-GREATER_TOKENreplaces = g_strdup(replaces); s-GREATER_TOKENon_source_error = on_source_error; s-GREATER_TOKENon_target_error = on_target_error; s-GREATER_TOKENtarget = target; s-GREATER_TOKENis_none_mode = is_none_mode; s-GREATER_TOKENbase = base; s-GREATER_TOKENgranularity = granularity; s-GREATER_TOKENbuf_size = ROUND_UP(buf_size, granularity); s-GREATER_TOKENunmap = unmap; s-GREATER_TOKENdirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp); if (!s-GREATER_TOKENdirty_bitmap) OPEN_CURLY_TOKEN g_free(s-GREATER_TOKENreplaces); block_job_unref(&s-GREATER_TOKENcommon); return; CLOSE_CURLY_TOKEN bdrv_op_block_all(s-GREATER_TOKENtarget, s-GREATER_TOKENcommon.blocker); bdrv_set_enable_write_cache(s-GREATER_TOKENtarget, "True" == "True"); if (s-GREATER_TOKENtarget-GREATER_TOKENblk) OPEN_CURLY_TOKEN blk_set_on_error(s-GREATER_TOKENtarget-GREATER_TOKENblk, on_target_error, on_target_error); blk_iostatus_enable(s-GREATER_TOKENtarget-GREATER_TOKENblk); CLOSE_CURLY_TOKEN s-GREATER_TOKENcommon.co = qemu_coroutine_create(mirror_run); trace_mirror_start(bs, s, s-GREATER_TOKENcommon.co, opaque); qemu_coroutine_enter(s-GREATER_TOKENcommon.co, s); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 48 ---------------------------------------------
[[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset, sPAPRPHBState *sphb) OPEN_CURLY_TOKEN ResourceProps rp; bool is_bridge = "False" != "False"; int pci_status, err; char *buf = NULL; uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev); uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3); uint32_t max_msi, max_msix; if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) == PCI_HEADER_TYPE_BRIDGE) OPEN_CURLY_TOKEN is_bridge = "True" == "True"; CLOSE_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "vendor-id", pci_default_read_config(dev, PCI_VENDOR_ID, 2))); _FDT(fdt_setprop_cell(fdt, offset, "device-id", pci_default_read_config(dev, PCI_DEVICE_ID, 2))); _FDT(fdt_setprop_cell(fdt, offset, "revision-id", pci_default_read_config(dev, PCI_REVISION_ID, 1))); _FDT(fdt_setprop_cell(fdt, offset, "class-code", ccode)); if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) OPEN_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "interrupts", pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1))); CLOSE_CURLY_TOKEN if (!is_bridge) OPEN_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "min-grant", pci_default_read_config(dev, PCI_MIN_GNT, 1))); _FDT(fdt_setprop_cell(fdt, offset, "max-latency", pci_default_read_config(dev, PCI_MAX_LAT, 1))); CLOSE_CURLY_TOKEN if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) OPEN_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "subsystem-id", pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2))); CLOSE_CURLY_TOKEN if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) OPEN_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "subsystem-vendor-id", pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2))); CLOSE_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "cache-line-size", pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1))); pci_status = pci_default_read_config(dev, PCI_STATUS, 2); _FDT(fdt_setprop_cell(fdt, offset, "devsel-speed", PCI_STATUS_DEVSEL_MASK & pci_status)); if (pci_status & PCI_STATUS_FAST_BACK) OPEN_CURLY_TOKEN _FDT(fdt_setprop(fdt, offset, "fast-back-to-back", NULL, 0)); CLOSE_CURLY_TOKEN if (pci_status & PCI_STATUS_66MHZ) OPEN_CURLY_TOKEN _FDT(fdt_setprop(fdt, offset, "66mhz-capable", NULL, 0)); CLOSE_CURLY_TOKEN if (pci_status & PCI_STATUS_UDF) OPEN_CURLY_TOKEN _FDT(fdt_setprop(fdt, offset, "udf-supported", NULL, 0)); CLOSE_CURLY_TOKEN _FDT(fdt_setprop_string(fdt, offset, "name", pci_find_device_name((ccode GREATER_TOKENGREATER_TOKEN 16) & 0xff, (ccode GREATER_TOKENGREATER_TOKEN 8) & 0xff, ccode & 0xff))); buf = spapr_phb_get_loc_code(sphb, dev); if (!buf) OPEN_CURLY_TOKEN error_report("Failed setting the ibm,loc-code"); return -1; CLOSE_CURLY_TOKEN err = fdt_setprop_string(fdt, offset, "ibm,loc-code", buf); g_free(buf); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return err; CLOSE_CURLY_TOKEN if (drc_index) OPEN_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "ibm,my-drc-index", drc_index)); CLOSE_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "#address-cells", RESOURCE_CELLS_ADDRESS)); _FDT(fdt_setprop_cell(fdt, offset, "#size-cells", RESOURCE_CELLS_SIZE)); max_msi = msi_nr_vectors_allocated(dev); if (max_msi) OPEN_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "ibm,req#msi", max_msi)); CLOSE_CURLY_TOKEN max_msix = dev-GREATER_TOKENmsix_entries_nr; if (max_msix) OPEN_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "ibm,req#msi-x", max_msix)); CLOSE_CURLY_TOKEN populate_resource_props(dev, &rp); _FDT(fdt_setprop(fdt, offset, "reg", (uint8_t *)rp.reg, rp.reg_len)); _FDT(fdt_setprop(fdt, offset, "assigned-addresses", (uint8_t *)rp.assigned, rp.assigned_len)); if (sphb-GREATER_TOKENpcie_ecs && pci_is_express(dev)) OPEN_CURLY_TOKEN _FDT(fdt_setprop_cell(fdt, offset, "ibm,pci-config-space-type", 0x1)); CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 49 ---------------------------------------------
[[0 (74%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong disas_insn(DisasContext *s, CPUState *cpu) OPEN_CURLY_TOKEN CPUX86State *env = cpu-GREATER_TOKENenv_ptr; int b, prefixes; int shift; TCGMemOp ot, aflag, dflag; int modrm, reg, rm, mod, op, opreg, val; target_ulong next_eip, tval; int rex_w, rex_r; target_ulong pc_start = s-GREATER_TOKENbase.pc_next; s-GREATER_TOKENpc_start = s-GREATER_TOKENpc = pc_start; prefixes = 0; s-GREATER_TOKENoverride = -1; rex_w = -1; rex_r = 0; #ifdef TARGET_X86_64 s-GREATER_TOKENrex_x = 0; s-GREATER_TOKENrex_b = 0; x86_64_hregs = 0; #endif s-GREATER_TOKENrip_offset = 0; s-GREATER_TOKENvex_l = 0; s-GREATER_TOKENvex_v = 0; if (sigsetjmp(s-GREATER_TOKENjmpbuf, 0) != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); return s-GREATER_TOKENpc; CLOSE_CURLY_TOKEN next_byte: b = x86_ldub_code(env, s); switch (b) OPEN_CURLY_TOKEN case 0xf3: prefixes |= PREFIX_REPZ; goto next_byte; case 0xf2: prefixes |= PREFIX_REPNZ; goto next_byte; case 0xf0: prefixes |= PREFIX_LOCK; goto next_byte; case 0x2e: s-GREATER_TOKENoverride = R_CS; goto next_byte; case 0x36: s-GREATER_TOKENoverride = R_SS; goto next_byte; case 0x3e: s-GREATER_TOKENoverride = R_DS; goto next_byte; case 0x26: s-GREATER_TOKENoverride = R_ES; goto next_byte; case 0x64: s-GREATER_TOKENoverride = R_FS; goto next_byte; case 0x65: s-GREATER_TOKENoverride = R_GS; goto next_byte; case 0x66: prefixes |= PREFIX_DATA; goto next_byte; case 0x67: prefixes |= PREFIX_ADR; goto next_byte; #ifdef TARGET_X86_64 case 0x40 ... 0x4f: if (CODE64(s)) OPEN_CURLY_TOKEN rex_w = (b GREATER_TOKENGREATER_TOKEN 3) & 1; rex_r = (b & 0x4) SMALLER_TOKENSMALLER_TOKEN 1; s-GREATER_TOKENrex_x = (b & 0x2) SMALLER_TOKENSMALLER_TOKEN 2; REX_B(s) = (b & 0x1) SMALLER_TOKENSMALLER_TOKEN 3; x86_64_hregs = 1; goto next_byte; CLOSE_CURLY_TOKEN break; #endif case 0xc5: case 0xc4: if (s-GREATER_TOKENcode32 && !s-GREATER_TOKENvm86) OPEN_CURLY_TOKEN static const int pp_prefixOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN 0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ CLOSE_CURLY_TOKEN; int vex3, vex2 = x86_ldub_code(env, s); if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN s-GREATER_TOKENpc++; if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ | PREFIX_LOCK | PREFIX_DATA)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN #ifdef TARGET_X86_64 if (x86_64_hregs) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN #endif rex_r = (~vex2 GREATER_TOKENGREATER_TOKEN 4) & 8; if (b == 0xc5) OPEN_CURLY_TOKEN vex3 = vex2; b = x86_ldub_code(env, s); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN #ifdef TARGET_X86_64 s-GREATER_TOKENrex_x = (~vex2 GREATER_TOKENGREATER_TOKEN 3) & 8; s-GREATER_TOKENrex_b = (~vex2 GREATER_TOKENGREATER_TOKEN 2) & 8; #endif vex3 = x86_ldub_code(env, s); rex_w = (vex3 GREATER_TOKENGREATER_TOKEN 7) & 1; switch (vex2 & 0x1f) OPEN_CURLY_TOKEN case 0x01: b = x86_ldub_code(env, s) | 0x100; break; case 0x02: b = 0x138; break; case 0x03: b = 0x13a; break; default: goto unknown_op; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN s-GREATER_TOKENvex_v = (~vex3 GREATER_TOKENGREATER_TOKEN 3) & 0xf; s-GREATER_TOKENvex_l = (vex3 GREATER_TOKENGREATER_TOKEN 2) & 1; prefixes |= pp_prefixOPEN_SQUARE_TOKENvex3 & 3CLOSE_SQUARE_TOKEN | PREFIX_VEX; CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN if (CODE64(s)) OPEN_CURLY_TOKEN dflag = (rex_w GREATER_TOKEN 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32); aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (s-GREATER_TOKENcode32 ^ ((prefixes & PREFIX_DATA) != 0)) OPEN_CURLY_TOKEN dflag = MO_32; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN dflag = MO_16; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcode32 ^ ((prefixes & PREFIX_ADR) != 0)) OPEN_CURLY_TOKEN aflag = MO_32; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN aflag = MO_16; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN s-GREATER_TOKENprefix = prefixes; s-GREATER_TOKENaflag = aflag; s-GREATER_TOKENdflag = dflag; reswitch: switch(b) OPEN_CURLY_TOKEN case 0x0f: b = x86_ldub_code(env, s) | 0x100; goto reswitch; case 0x00 ... 0x05: case 0x08 ... 0x0d: case 0x10 ... 0x15: case 0x18 ... 0x1d: case 0x20 ... 0x25: case 0x28 ... 0x2d: case 0x30 ... 0x35: case 0x38 ... 0x3d: OPEN_CURLY_TOKEN int op, f, val; op = (b GREATER_TOKENGREATER_TOKEN 3) & 7; f = (b GREATER_TOKENGREATER_TOKEN 1) & 3; ot = mo_b_d(b, dflag); switch(f) OPEN_CURLY_TOKEN case 0: modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod != 3) OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; CLOSE_CURLY_TOKEN else if (op == OP_XORL && rm == reg) OPEN_CURLY_TOKEN xor_zero: set_cc_op(s, CC_OP_CLR); tcg_gen_movi_tl(cpu_T0, 0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN opreg = rm; CLOSE_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T1, reg); gen_op(s, op, ot, opreg); break; case 1: modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; rm = (modrm & 7) | REX_B(s); if (mod != 3) OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, cpu_T1, cpu_A0); CLOSE_CURLY_TOKEN else if (op == OP_XORL && rm == reg) OPEN_CURLY_TOKEN goto xor_zero; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T1, rm); CLOSE_CURLY_TOKEN gen_op(s, op, ot, reg); break; case 2: val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); gen_op(s, op, ot, OR_EAX); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x82: if (CODE64(s)) goto illegal_op; case 0x80: case 0x81: case 0x83: OPEN_CURLY_TOKEN int val; ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; if (mod != 3) OPEN_CURLY_TOKEN if (b == 0x83) s-GREATER_TOKENrip_offset = 1; else s-GREATER_TOKENrip_offset = insn_const_size(ot); gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN opreg = rm; CLOSE_CURLY_TOKEN switch(b) OPEN_CURLY_TOKEN default: case 0x80: case 0x81: case 0x82: val = insn_get(env, s, ot); break; case 0x83: val = (int8_t)insn_get(env, s, MO_8); break; CLOSE_CURLY_TOKEN tcg_gen_movi_tl(cpu_T1, val); gen_op(s, op, ot, opreg); CLOSE_CURLY_TOKEN break; case 0x40 ... 0x47: ot = dflag; gen_inc(s, ot, OR_EAX + (b & 7), 1); break; case 0x48 ... 0x4f: ot = dflag; gen_inc(s, ot, OR_EAX + (b & 7), -1); break; case 0xf6: case 0xf7: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; if (mod != 3) OPEN_CURLY_TOKEN if (op == 0) OPEN_CURLY_TOKEN s-GREATER_TOKENrip_offset = insn_const_size(ot); CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); if (!(s-GREATER_TOKENprefix & PREFIX_LOCK) || op != 2) OPEN_CURLY_TOKEN gen_op_ld_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T0, rm); CLOSE_CURLY_TOKEN switch(op) OPEN_CURLY_TOKEN case 0: val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 2: if (s-GREATER_TOKENprefix & PREFIX_LOCK) OPEN_CURLY_TOKEN if (mod == 3) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN tcg_gen_movi_tl(cpu_T0, ~0); tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0, s-GREATER_TOKENmem_index, ot | MO_LE); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_not_tl(cpu_T0, cpu_T0); if (mod != 3) OPEN_CURLY_TOKEN gen_op_st_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_reg_v(ot, rm, cpu_T0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 3: if (s-GREATER_TOKENprefix & PREFIX_LOCK) OPEN_CURLY_TOKEN TCGLabel *label1; TCGv a0, t0, t1, t2; if (mod == 3) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN a0 = tcg_temp_local_new(); t0 = tcg_temp_local_new(); label1 = gen_new_label(); tcg_gen_mov_tl(a0, cpu_A0); tcg_gen_mov_tl(t0, cpu_T0); gen_set_label(label1); t1 = tcg_temp_new(); t2 = tcg_temp_new(); tcg_gen_mov_tl(t2, t0); tcg_gen_neg_tl(t1, t0); tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1, s-GREATER_TOKENmem_index, ot | MO_LE); tcg_temp_free(t1); tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1); tcg_temp_free(t2); tcg_temp_free(a0); tcg_gen_mov_tl(cpu_T0, t0); tcg_temp_free(t0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_neg_tl(cpu_T0, cpu_T0); if (mod != 3) OPEN_CURLY_TOKEN gen_op_st_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_reg_v(ot, rm, cpu_T0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN gen_op_update_neg_cc(); set_cc_op(s, CC_OP_SUBB + ot); break; case 4: switch(ot) OPEN_CURLY_TOKEN case MO_8: gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX); tcg_gen_ext8u_tl(cpu_T0, cpu_T0); tcg_gen_ext8u_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00); set_cc_op(s, CC_OP_MULB); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX); tcg_gen_ext16u_tl(cpu_T0, cpu_T0); tcg_gen_ext16u_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_shri_tl(cpu_T0, cpu_T0, 16); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); tcg_gen_mov_tl(cpu_cc_src, cpu_T0); set_cc_op(s, CC_OP_MULW); break; default: case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_tmp2_i32); tcg_gen_extu_i32_tl(cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN, cpu_tmp3_i32); tcg_gen_mov_tl(cpu_cc_dst, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_mov_tl(cpu_cc_src, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); set_cc_op(s, CC_OP_MULL); break; #ifdef TARGET_X86_64 case MO_64: tcg_gen_mulu2_i64(cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN, cpu_T0, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_mov_tl(cpu_cc_dst, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_mov_tl(cpu_cc_src, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); set_cc_op(s, CC_OP_MULQ); break; #endif CLOSE_CURLY_TOKEN break; case 5: switch(ot) OPEN_CURLY_TOKEN case MO_8: gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX); tcg_gen_ext8s_tl(cpu_T0, cpu_T0); tcg_gen_ext8s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); set_cc_op(s, CC_OP_MULB); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_ext16s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); tcg_gen_shri_tl(cpu_T0, cpu_T0, 16); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); set_cc_op(s, CC_OP_MULW); break; default: case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_tmp2_i32); tcg_gen_extu_i32_tl(cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN, cpu_tmp3_i32); tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31); tcg_gen_mov_tl(cpu_cc_dst, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32); set_cc_op(s, CC_OP_MULL); break; #ifdef TARGET_X86_64 case MO_64: tcg_gen_muls2_i64(cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN, cpu_T0, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_mov_tl(cpu_cc_dst, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_sari_tl(cpu_cc_src, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, 63); tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); set_cc_op(s, CC_OP_MULQ); break; #endif CLOSE_CURLY_TOKEN break; case 6: switch(ot) OPEN_CURLY_TOKEN case MO_8: gen_helper_divb_AL(cpu_env, cpu_T0); break; case MO_16: gen_helper_divw_AX(cpu_env, cpu_T0); break; default: case MO_32: gen_helper_divl_EAX(cpu_env, cpu_T0); break; #ifdef TARGET_X86_64 case MO_64: gen_helper_divq_EAX(cpu_env, cpu_T0); break; #endif CLOSE_CURLY_TOKEN break; case 7: switch(ot) OPEN_CURLY_TOKEN case MO_8: gen_helper_idivb_AL(cpu_env, cpu_T0); break; case MO_16: gen_helper_idivw_AX(cpu_env, cpu_T0); break; default: case MO_32: gen_helper_idivl_EAX(cpu_env, cpu_T0); break; #ifdef TARGET_X86_64 case MO_64: gen_helper_idivq_EAX(cpu_env, cpu_T0); break; #endif CLOSE_CURLY_TOKEN break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0xfe: case 0xff: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; if (op GREATER_TOKEN= 2 && b == 0xfe) OPEN_CURLY_TOKEN goto unknown_op; CLOSE_CURLY_TOKEN if (CODE64(s)) OPEN_CURLY_TOKEN if (op == 2 || op == 4) OPEN_CURLY_TOKEN ot = MO_64; CLOSE_CURLY_TOKEN else if (op == 3 || op == 5) OPEN_CURLY_TOKEN ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16; CLOSE_CURLY_TOKEN else if (op == 6) OPEN_CURLY_TOKEN ot = mo_pushpop(s, dflag); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (mod != 3) OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); if (op GREATER_TOKEN= 2 && op != 3 && op != 5) gen_op_ld_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T0, rm); CLOSE_CURLY_TOKEN switch(op) OPEN_CURLY_TOKEN case 0: if (mod != 3) opreg = OR_TMP0; else opreg = rm; gen_inc(s, ot, opreg, 1); break; case 1: if (mod != 3) opreg = OR_TMP0; else opreg = rm; gen_inc(s, ot, opreg, -1); break; case 2: if (dflag == MO_16) OPEN_CURLY_TOKEN tcg_gen_ext16u_tl(cpu_T0, cpu_T0); CLOSE_CURLY_TOKEN next_eip = s-GREATER_TOKENpc - s-GREATER_TOKENcs_base; tcg_gen_movi_tl(cpu_T1, next_eip); gen_push_v(s, cpu_T1); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 3: gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 SMALLER_TOKENSMALLER_TOKEN ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); do_lcall: if (s-GREATER_TOKENpe && !s-GREATER_TOKENvm86) OPEN_CURLY_TOKEN tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_i32(dflag - 1), tcg_const_tl(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base)); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_i32(dflag - 1), tcg_const_i32(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base)); CLOSE_CURLY_TOKEN tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip)); gen_jr(s, cpu_tmp4); break; case 4: if (dflag == MO_16) OPEN_CURLY_TOKEN tcg_gen_ext16u_tl(cpu_T0, cpu_T0); CLOSE_CURLY_TOKEN gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 5: gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 SMALLER_TOKENSMALLER_TOKEN ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); do_ljmp: if (s-GREATER_TOKENpe && !s-GREATER_TOKENvm86) OPEN_CURLY_TOKEN tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_tl(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base)); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_movl_seg_T0_vm(R_CS); gen_op_jmp_v(cpu_T1); CLOSE_CURLY_TOKEN tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip)); gen_jr(s, cpu_tmp4); break; case 6: gen_push_v(s, cpu_T0); break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x84: case 0x85: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_op_mov_v_reg(ot, cpu_T1, reg); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 0xa8: case 0xa9: ot = mo_b_d(b, dflag); val = insn_get(env, s, ot); gen_op_mov_v_reg(ot, cpu_T0, OR_EAX); tcg_gen_movi_tl(cpu_T1, val); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 0x98: switch (dflag) OPEN_CURLY_TOKEN #ifdef TARGET_X86_64 case MO_64: gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX); tcg_gen_ext32s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0); break; #endif case MO_32: gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0); break; case MO_16: gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX); tcg_gen_ext8s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); break; default: tcg_abort(); CLOSE_CURLY_TOKEN break; case 0x99: switch (dflag) OPEN_CURLY_TOKEN #ifdef TARGET_X86_64 case MO_64: gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX); tcg_gen_sari_tl(cpu_T0, cpu_T0, 63); gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0); break; #endif case MO_32: gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX); tcg_gen_ext32s_tl(cpu_T0, cpu_T0); tcg_gen_sari_tl(cpu_T0, cpu_T0, 31); gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_sari_tl(cpu_T0, cpu_T0, 15); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); break; default: tcg_abort(); CLOSE_CURLY_TOKEN break; case 0x1af: case 0x69: case 0x6b: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; if (b == 0x69) s-GREATER_TOKENrip_offset = insn_const_size(ot); else if (b == 0x6b) s-GREATER_TOKENrip_offset = 1; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); if (b == 0x69) OPEN_CURLY_TOKEN val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); CLOSE_CURLY_TOKEN else if (b == 0x6b) OPEN_CURLY_TOKEN val = (int8_t)insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T1, val); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T1, reg); CLOSE_CURLY_TOKEN switch (ot) OPEN_CURLY_TOKEN #ifdef TARGET_X86_64 case MO_64: tcg_gen_muls2_i64(cpu_regsOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_T1, cpu_T0, cpu_T1); tcg_gen_mov_tl(cpu_cc_dst, cpu_regsOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63); tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1); break; #endif case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regsOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_tmp2_i32); tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31); tcg_gen_mov_tl(cpu_cc_dst, cpu_regsOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32); break; default: tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_ext16s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; CLOSE_CURLY_TOKEN set_cc_op(s, CC_OP_MULB + ot); break; case 0x1c0: case 0x1c1: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; gen_op_mov_v_reg(ot, cpu_T0, reg); if (mod == 3) OPEN_CURLY_TOKEN rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(ot, cpu_T1, rm); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(ot, reg, cpu_T1); gen_op_mov_reg_v(ot, rm, cpu_T0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); if (s-GREATER_TOKENprefix & PREFIX_LOCK) OPEN_CURLY_TOKEN tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0, s-GREATER_TOKENmem_index, ot | MO_LE); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_ld_v(s, ot, cpu_T1, cpu_A0); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_st_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN gen_op_mov_reg_v(ot, reg, cpu_T1); CLOSE_CURLY_TOKEN gen_op_update2_cc(); set_cc_op(s, CC_OP_ADDB + ot); break; case 0x1b0: case 0x1b1: OPEN_CURLY_TOKEN TCGv oldv, newv, cmpv; ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; oldv = tcg_temp_new(); newv = tcg_temp_new(); cmpv = tcg_temp_new(); gen_op_mov_v_reg(ot, newv, reg); tcg_gen_mov_tl(cmpv, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); if (s-GREATER_TOKENprefix & PREFIX_LOCK) OPEN_CURLY_TOKEN if (mod == 3) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv, s-GREATER_TOKENmem_index, ot | MO_LE); gen_op_mov_reg_v(ot, R_EAX, oldv); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (mod == 3) OPEN_CURLY_TOKEN rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(ot, oldv, rm); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, oldv, cpu_A0); rm = 0; CLOSE_CURLY_TOKEN gen_extu(ot, oldv); gen_extu(ot, cmpv); tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv); if (mod == 3) OPEN_CURLY_TOKEN gen_op_mov_reg_v(ot, R_EAX, oldv); gen_op_mov_reg_v(ot, rm, newv); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_st_v(s, ot, newv, cpu_A0); gen_op_mov_reg_v(ot, R_EAX, oldv); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN tcg_gen_mov_tl(cpu_cc_src, oldv); tcg_gen_mov_tl(cpu_cc_srcT, cmpv); tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv); set_cc_op(s, CC_OP_SUBB + ot); tcg_temp_free(oldv); tcg_temp_free(newv); tcg_temp_free(cmpv); CLOSE_CURLY_TOKEN break; case 0x1c7: modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if ((mod == 3) || ((modrm & 0x38) != 0x8)) goto illegal_op; #ifdef TARGET_X86_64 if (dflag == MO_64) OPEN_CURLY_TOKEN if (!(s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_CX16)) goto illegal_op; gen_lea_modrm(env, s, modrm); if ((s-GREATER_TOKENprefix & PREFIX_LOCK) && parallel_cpus) OPEN_CURLY_TOKEN gen_helper_cmpxchg16b(cpu_env, cpu_A0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else #endif OPEN_CURLY_TOKEN if (!(s-GREATER_TOKENcpuid_features & CPUID_CX8)) goto illegal_op; gen_lea_modrm(env, s, modrm); if ((s-GREATER_TOKENprefix & PREFIX_LOCK) && parallel_cpus) OPEN_CURLY_TOKEN gen_helper_cmpxchg8b(cpu_env, cpu_A0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN set_cc_op(s, CC_OP_EFLAGS); break; case 0x50 ... 0x57: gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s)); gen_push_v(s, cpu_T0); break; case 0x58 ... 0x5f: ot = gen_pop_T0(s); gen_pop_update(s, ot); gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0); break; case 0x60: if (CODE64(s)) goto illegal_op; gen_pusha(s); break; case 0x61: if (CODE64(s)) goto illegal_op; gen_popa(s); break; case 0x68: case 0x6a: ot = mo_pushpop(s, dflag); if (b == 0x68) val = insn_get(env, s, ot); else val = (int8_t)insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T0, val); gen_push_v(s, cpu_T0); break; case 0x8f: modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; ot = gen_pop_T0(s); if (mod == 3) OPEN_CURLY_TOKEN gen_pop_update(s, ot); rm = (modrm & 7) | REX_B(s); gen_op_mov_reg_v(ot, rm, cpu_T0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN s-GREATER_TOKENpopl_esp_hack = 1 SMALLER_TOKENSMALLER_TOKEN ot; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); s-GREATER_TOKENpopl_esp_hack = 0; gen_pop_update(s, ot); CLOSE_CURLY_TOKEN break; case 0xc8: OPEN_CURLY_TOKEN int level; val = x86_lduw_code(env, s); level = x86_ldub_code(env, s); gen_enter(s, val, level); CLOSE_CURLY_TOKEN break; case 0xc9: gen_leave(s); break; case 0x06: case 0x0e: case 0x16: case 0x1e: if (CODE64(s)) goto illegal_op; gen_op_movl_T0_seg(b GREATER_TOKENGREATER_TOKEN 3); gen_push_v(s, cpu_T0); break; case 0x1a0: case 0x1a8: gen_op_movl_T0_seg((b GREATER_TOKENGREATER_TOKEN 3) & 7); gen_push_v(s, cpu_T0); break; case 0x07: case 0x17: case 0x1f: if (CODE64(s)) goto illegal_op; reg = b GREATER_TOKENGREATER_TOKEN 3; ot = gen_pop_T0(s); gen_movl_seg_T0(s, reg); gen_pop_update(s, ot); if (s-GREATER_TOKENbase.is_jmp) OPEN_CURLY_TOKEN gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); if (reg == R_SS) OPEN_CURLY_TOKEN s-GREATER_TOKENtf = 0; gen_eob_inhibit_irq(s, "True" == "True"); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_eob(s); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x1a1: case 0x1a9: ot = gen_pop_T0(s); gen_movl_seg_T0(s, (b GREATER_TOKENGREATER_TOKEN 3) & 7); gen_pop_update(s, ot); if (s-GREATER_TOKENbase.is_jmp) OPEN_CURLY_TOKEN gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); CLOSE_CURLY_TOKEN break; case 0x88: case 0x89: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, reg, 1); break; case 0xc6: case 0xc7: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if (mod != 3) OPEN_CURLY_TOKEN s-GREATER_TOKENrip_offset = insn_const_size(ot); gen_lea_modrm(env, s, modrm); CLOSE_CURLY_TOKEN val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T0, val); if (mod != 3) OPEN_CURLY_TOKEN gen_op_st_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0); CLOSE_CURLY_TOKEN break; case 0x8a: case 0x8b: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; case 0x8e: modrm = x86_ldub_code(env, s); reg = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; if (reg GREATER_TOKEN= 6 || reg == R_CS) goto illegal_op; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_movl_seg_T0(s, reg); if (s-GREATER_TOKENbase.is_jmp) OPEN_CURLY_TOKEN gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); if (reg == R_SS) OPEN_CURLY_TOKEN s-GREATER_TOKENtf = 0; gen_eob_inhibit_irq(s, "True" == "True"); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_eob(s); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x8c: modrm = x86_ldub_code(env, s); reg = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if (reg GREATER_TOKEN= 6) goto illegal_op; gen_op_movl_T0_seg(reg); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 0x1b6: case 0x1b7: case 0x1be: case 0x1bf: OPEN_CURLY_TOKEN TCGMemOp d_ot; TCGMemOp s_ot; d_ot = dflag; ot = (b & 1) + MO_8; s_ot = b & 8 ? MO_SIGN | ot : ot; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod == 3) OPEN_CURLY_TOKEN if (s_ot == MO_SB && byte_reg_is_xH(rm)) OPEN_CURLY_TOKEN tcg_gen_sextract_tl(cpu_T0, cpu_regsOPEN_SQUARE_TOKENrm - 4CLOSE_SQUARE_TOKEN, 8, 8); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T0, rm); switch (s_ot) OPEN_CURLY_TOKEN case MO_UB: tcg_gen_ext8u_tl(cpu_T0, cpu_T0); break; case MO_SB: tcg_gen_ext8s_tl(cpu_T0, cpu_T0); break; case MO_UW: tcg_gen_ext16u_tl(cpu_T0, cpu_T0); break; default: case MO_SW: tcg_gen_ext16s_tl(cpu_T0, cpu_T0); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN gen_op_mov_reg_v(d_ot, reg, cpu_T0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0); gen_op_mov_reg_v(d_ot, reg, cpu_T0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x8d: modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if (mod == 3) goto illegal_op; reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; OPEN_CURLY_TOKEN AddressParts a = gen_lea_modrm_0(env, s, modrm); TCGv ea = gen_lea_modrm_1(a); gen_lea_v_seg(s, s-GREATER_TOKENaflag, ea, -1, -1); gen_op_mov_reg_v(dflag, reg, cpu_A0); CLOSE_CURLY_TOKEN break; case 0xa0: case 0xa1: case 0xa2: case 0xa3: OPEN_CURLY_TOKEN target_ulong offset_addr; ot = mo_b_d(b, dflag); switch (s-GREATER_TOKENaflag) OPEN_CURLY_TOKEN #ifdef TARGET_X86_64 case MO_64: offset_addr = x86_ldq_code(env, s); break; #endif default: offset_addr = insn_get(env, s, s-GREATER_TOKENaflag); break; CLOSE_CURLY_TOKEN tcg_gen_movi_tl(cpu_A0, offset_addr); gen_add_A0_ds_seg(s); if ((b & 2) == 0) OPEN_CURLY_TOKEN gen_op_ld_v(s, ot, cpu_T0, cpu_A0); gen_op_mov_reg_v(ot, R_EAX, cpu_T0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T0, R_EAX); gen_op_st_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0xd7: tcg_gen_mov_tl(cpu_A0, cpu_regsOPEN_SQUARE_TOKENR_EBXCLOSE_SQUARE_TOKEN); tcg_gen_ext8u_tl(cpu_T0, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0); gen_extu(s-GREATER_TOKENaflag, cpu_A0); gen_add_A0_ds_seg(s); gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0); gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0); break; case 0xb0 ... 0xb7: val = insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T0, val); gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0); break; case 0xb8 ... 0xbf: #ifdef TARGET_X86_64 if (dflag == MO_64) OPEN_CURLY_TOKEN uint64_t tmp; tmp = x86_ldq_code(env, s); reg = (b & 7) | REX_B(s); tcg_gen_movi_tl(cpu_T0, tmp); gen_op_mov_reg_v(MO_64, reg, cpu_T0); CLOSE_CURLY_TOKEN else #endif OPEN_CURLY_TOKEN ot = dflag; val = insn_get(env, s, ot); reg = (b & 7) | REX_B(s); tcg_gen_movi_tl(cpu_T0, val); gen_op_mov_reg_v(ot, reg, cpu_T0); CLOSE_CURLY_TOKEN break; case 0x91 ... 0x97: do_xchg_reg_eax: ot = dflag; reg = (b & 7) | REX_B(s); rm = R_EAX; goto do_xchg_reg; case 0x86: case 0x87: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if (mod == 3) OPEN_CURLY_TOKEN rm = (modrm & 7) | REX_B(s); do_xchg_reg: gen_op_mov_v_reg(ot, cpu_T0, reg); gen_op_mov_v_reg(ot, cpu_T1, rm); gen_op_mov_reg_v(ot, rm, cpu_T0); gen_op_mov_reg_v(ot, reg, cpu_T1); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); gen_op_mov_v_reg(ot, cpu_T0, reg); tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0, s-GREATER_TOKENmem_index, ot | MO_LE); gen_op_mov_reg_v(ot, reg, cpu_T1); CLOSE_CURLY_TOKEN break; case 0xc4: op = R_ES; goto do_lxx; case 0xc5: op = R_DS; goto do_lxx; case 0x1b2: op = R_SS; goto do_lxx; case 0x1b4: op = R_FS; goto do_lxx; case 0x1b5: op = R_GS; do_lxx: ot = dflag != MO_16 ? MO_32 : MO_16; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if (mod == 3) goto illegal_op; gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 SMALLER_TOKENSMALLER_TOKEN ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); gen_movl_seg_T0(s, op); gen_op_mov_reg_v(ot, reg, cpu_T1); if (s-GREATER_TOKENbase.is_jmp) OPEN_CURLY_TOKEN gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); CLOSE_CURLY_TOKEN break; case 0xc0: case 0xc1: shift = 2; grp2: OPEN_CURLY_TOKEN ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; op = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; if (mod != 3) OPEN_CURLY_TOKEN if (shift == 2) OPEN_CURLY_TOKEN s-GREATER_TOKENrip_offset = 1; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN opreg = (modrm & 7) | REX_B(s); CLOSE_CURLY_TOKEN if (shift == 0) OPEN_CURLY_TOKEN gen_shift(s, op, ot, opreg, OR_ECX); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (shift == 2) OPEN_CURLY_TOKEN shift = x86_ldub_code(env, s); CLOSE_CURLY_TOKEN gen_shifti(s, op, ot, opreg, shift); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0xd0: case 0xd1: shift = 1; goto grp2; case 0xd2: case 0xd3: shift = 0; goto grp2; case 0x1a4: op = 0; shift = 1; goto do_shiftd; case 0x1a5: op = 0; shift = 0; goto do_shiftd; case 0x1ac: op = 1; shift = 1; goto do_shiftd; case 0x1ad: op = 1; shift = 0; do_shiftd: ot = dflag; modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; if (mod != 3) OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN opreg = rm; CLOSE_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T1, reg); if (shift) OPEN_CURLY_TOKEN TCGv imm = tcg_const_tl(x86_ldub_code(env, s)); gen_shiftd_rm_T1(s, ot, opreg, op, imm); tcg_temp_free(imm); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regsOPEN_SQUARE_TOKENR_ECXCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN break; case 0xd8 ... 0xdf: if (s-GREATER_TOKENflags & (HF_EM_MASK | HF_TS_MASK)) OPEN_CURLY_TOKEN gen_exception(s, EXCP07_PREX, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = modrm & 7; op = ((b & 7) SMALLER_TOKENSMALLER_TOKEN 3) | ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7); if (mod != 3) OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); switch(op) OPEN_CURLY_TOKEN case 0x00 ... 0x07: case 0x10 ... 0x17: case 0x20 ... 0x27: case 0x30 ... 0x37: OPEN_CURLY_TOKEN int op1; op1 = op & 7; switch(op GREATER_TOKENGREATER_TOKEN 4) OPEN_CURLY_TOKEN case 0: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32); break; case 1: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32); break; case 2: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64); break; case 3: default: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LESW); gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32); break; CLOSE_CURLY_TOKEN gen_helper_fp_arith_ST0_FT0(op1); if (op1 == 3) OPEN_CURLY_TOKEN gen_helper_fpop(cpu_env); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x08: case 0x0a: case 0x0b: case 0x18 ... 0x1b: case 0x28 ... 0x2b: case 0x38 ... 0x3b: switch(op & 7) OPEN_CURLY_TOKEN case 0: switch(op GREATER_TOKENGREATER_TOKEN 4) OPEN_CURLY_TOKEN case 0: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32); break; case 1: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32); break; case 2: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64); break; case 3: default: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LESW); gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32); break; CLOSE_CURLY_TOKEN break; case 1: switch(op GREATER_TOKENGREATER_TOKEN 4) OPEN_CURLY_TOKEN case 1: gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); break; case 2: gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); break; case 3: default: gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUW); break; CLOSE_CURLY_TOKEN gen_helper_fpop(cpu_env); break; default: switch(op GREATER_TOKENGREATER_TOKEN 4) OPEN_CURLY_TOKEN case 0: gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); break; case 1: gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); break; case 2: gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); break; case 3: default: gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUW); break; CLOSE_CURLY_TOKEN if ((op & 7) == 3) gen_helper_fpop(cpu_env); break; CLOSE_CURLY_TOKEN break; case 0x0c: gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x0d: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUW); gen_helper_fldcw(cpu_env, cpu_tmp2_i32); break; case 0x0e: gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x0f: gen_helper_fnstcw(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUW); break; case 0x1d: gen_helper_fldt_ST0(cpu_env, cpu_A0); break; case 0x1f: gen_helper_fstt_ST0(cpu_env, cpu_A0); gen_helper_fpop(cpu_env); break; case 0x2c: gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x2e: gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x2f: gen_helper_fnstsw(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUW); break; case 0x3c: gen_helper_fbld_ST0(cpu_env, cpu_A0); break; case 0x3e: gen_helper_fbst_ST0(cpu_env, cpu_A0); gen_helper_fpop(cpu_env); break; case 0x3d: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64); break; case 0x3f: gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); gen_helper_fpop(cpu_env); break; default: goto unknown_op; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN opreg = rm; switch(op) OPEN_CURLY_TOKEN case 0x08: gen_helper_fpush(cpu_env); gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32((opreg + 1) & 7)); break; case 0x09: case 0x29: case 0x39: gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg)); break; case 0x0a: switch(rm) OPEN_CURLY_TOKEN case 0: gen_helper_fwait(cpu_env); break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x0c: switch(rm) OPEN_CURLY_TOKEN case 0: gen_helper_fchs_ST0(cpu_env); break; case 1: gen_helper_fabs_ST0(cpu_env); break; case 4: gen_helper_fldz_FT0(cpu_env); gen_helper_fcom_ST0_FT0(cpu_env); break; case 5: gen_helper_fxam_ST0(cpu_env); break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x0d: OPEN_CURLY_TOKEN switch(rm) OPEN_CURLY_TOKEN case 0: gen_helper_fpush(cpu_env); gen_helper_fld1_ST0(cpu_env); break; case 1: gen_helper_fpush(cpu_env); gen_helper_fldl2t_ST0(cpu_env); break; case 2: gen_helper_fpush(cpu_env); gen_helper_fldl2e_ST0(cpu_env); break; case 3: gen_helper_fpush(cpu_env); gen_helper_fldpi_ST0(cpu_env); break; case 4: gen_helper_fpush(cpu_env); gen_helper_fldlg2_ST0(cpu_env); break; case 5: gen_helper_fpush(cpu_env); gen_helper_fldln2_ST0(cpu_env); break; case 6: gen_helper_fpush(cpu_env); gen_helper_fldz_ST0(cpu_env); break; default: goto unknown_op; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x0e: switch(rm) OPEN_CURLY_TOKEN case 0: gen_helper_f2xm1(cpu_env); break; case 1: gen_helper_fyl2x(cpu_env); break; case 2: gen_helper_fptan(cpu_env); break; case 3: gen_helper_fpatan(cpu_env); break; case 4: gen_helper_fxtract(cpu_env); break; case 5: gen_helper_fprem1(cpu_env); break; case 6: gen_helper_fdecstp(cpu_env); break; default: case 7: gen_helper_fincstp(cpu_env); break; CLOSE_CURLY_TOKEN break; case 0x0f: switch(rm) OPEN_CURLY_TOKEN case 0: gen_helper_fprem(cpu_env); break; case 1: gen_helper_fyl2xp1(cpu_env); break; case 2: gen_helper_fsqrt(cpu_env); break; case 3: gen_helper_fsincos(cpu_env); break; case 5: gen_helper_fscale(cpu_env); break; case 4: gen_helper_frndint(cpu_env); break; case 6: gen_helper_fsin(cpu_env); break; default: case 7: gen_helper_fcos(cpu_env); break; CLOSE_CURLY_TOKEN break; case 0x00: case 0x01: case 0x04 ... 0x07: case 0x20: case 0x21: case 0x24 ... 0x27: case 0x30: case 0x31: case 0x34 ... 0x37: OPEN_CURLY_TOKEN int op1; op1 = op & 7; if (op GREATER_TOKEN= 0x20) OPEN_CURLY_TOKEN gen_helper_fp_arith_STN_ST0(op1, opreg); if (op GREATER_TOKEN= 0x30) gen_helper_fpop(cpu_env); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fp_arith_ST0_FT0(op1); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x02: case 0x22: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcom_ST0_FT0(cpu_env); break; case 0x03: case 0x23: case 0x32: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); break; case 0x15: switch(rm) OPEN_CURLY_TOKEN case 1: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1)); gen_helper_fucom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); gen_helper_fpop(cpu_env); break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x1c: switch(rm) OPEN_CURLY_TOKEN case 0: break; case 1: break; case 2: gen_helper_fclex(cpu_env); break; case 3: gen_helper_fninit(cpu_env); break; case 4: break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x1d: if (!(s-GREATER_TOKENcpuid_features & CPUID_CMOV)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucomi_ST0_FT0(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x1e: if (!(s-GREATER_TOKENcpuid_features & CPUID_CMOV)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcomi_ST0_FT0(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x28: gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg)); break; case 0x2a: gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg)); break; case 0x2b: case 0x0b: case 0x3a: case 0x3b: gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg)); gen_helper_fpop(cpu_env); break; case 0x2c: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucom_ST0_FT0(cpu_env); break; case 0x2d: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); break; case 0x33: switch(rm) OPEN_CURLY_TOKEN case 1: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1)); gen_helper_fcom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); gen_helper_fpop(cpu_env); break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x38: gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fpop(cpu_env); break; case 0x3c: switch(rm) OPEN_CURLY_TOKEN case 0: gen_helper_fnstsw(cpu_tmp2_i32, cpu_env); tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x3d: if (!(s-GREATER_TOKENcpuid_features & CPUID_CMOV)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucomi_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x3e: if (!(s-GREATER_TOKENcpuid_features & CPUID_CMOV)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcomi_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x10 ... 0x13: case 0x18 ... 0x1b: OPEN_CURLY_TOKEN int op1; TCGLabel *l1; static const uint8_t fcmov_ccOPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN (JCC_B SMALLER_TOKENSMALLER_TOKEN 1), (JCC_Z SMALLER_TOKENSMALLER_TOKEN 1), (JCC_BE SMALLER_TOKENSMALLER_TOKEN 1), (JCC_P SMALLER_TOKENSMALLER_TOKEN 1), CLOSE_CURLY_TOKEN; if (!(s-GREATER_TOKENcpuid_features & CPUID_CMOV)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN op1 = fcmov_ccOPEN_SQUARE_TOKENop & 3CLOSE_SQUARE_TOKEN | (((op GREATER_TOKENGREATER_TOKEN 3) & 1) ^ 1); l1 = gen_new_label(); gen_jcc1_noeob(s, op1, l1); gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg)); gen_set_label(l1); CLOSE_CURLY_TOKEN break; default: goto unknown_op; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0xa4: case 0xa5: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) OPEN_CURLY_TOKEN gen_repz_movs(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_movs(s, ot); CLOSE_CURLY_TOKEN break; case 0xaa: case 0xab: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) OPEN_CURLY_TOKEN gen_repz_stos(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_stos(s, ot); CLOSE_CURLY_TOKEN break; case 0xac: case 0xad: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) OPEN_CURLY_TOKEN gen_repz_lods(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_lods(s, ot); CLOSE_CURLY_TOKEN break; case 0xae: case 0xaf: ot = mo_b_d(b, dflag); if (prefixes & PREFIX_REPNZ) OPEN_CURLY_TOKEN gen_repz_scas(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base, 1); CLOSE_CURLY_TOKEN else if (prefixes & PREFIX_REPZ) OPEN_CURLY_TOKEN gen_repz_scas(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base, 0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_scas(s, ot); CLOSE_CURLY_TOKEN break; case 0xa6: case 0xa7: ot = mo_b_d(b, dflag); if (prefixes & PREFIX_REPNZ) OPEN_CURLY_TOKEN gen_repz_cmps(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base, 1); CLOSE_CURLY_TOKEN else if (prefixes & PREFIX_REPZ) OPEN_CURLY_TOKEN gen_repz_cmps(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base, 0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_cmps(s, ot); CLOSE_CURLY_TOKEN break; case 0x6c: case 0x6d: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); gen_check_io(s, ot, pc_start - s-GREATER_TOKENcs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) OPEN_CURLY_TOKEN gen_repz_ins(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_ins(s, ot); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_jmp(s, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x6e: case 0x6f: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); gen_check_io(s, ot, pc_start - s-GREATER_TOKENcs_base, svm_is_rep(prefixes) | 4); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) OPEN_CURLY_TOKEN gen_repz_outs(s, ot, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_outs(s, ot); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_jmp(s, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0xe4: case 0xe5: ot = mo_b_d32(b, dflag); val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T0, val); gen_check_io(s, ot, pc_start - s-GREATER_TOKENcs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes)); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_start(); CLOSE_CURLY_TOKEN tcg_gen_movi_i32(cpu_tmp2_i32, val); gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32); gen_op_mov_reg_v(ot, R_EAX, cpu_T1); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_end(); gen_jmp(s, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN break; case 0xe6: case 0xe7: ot = mo_b_d32(b, dflag); val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T0, val); gen_check_io(s, ot, pc_start - s-GREATER_TOKENcs_base, svm_is_rep(prefixes)); gen_op_mov_v_reg(ot, cpu_T1, R_EAX); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_start(); CLOSE_CURLY_TOKEN tcg_gen_movi_i32(cpu_tmp2_i32, val); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_end(); gen_jmp(s, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN break; case 0xec: case 0xed: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); gen_check_io(s, ot, pc_start - s-GREATER_TOKENcs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes)); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_start(); CLOSE_CURLY_TOKEN tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32); gen_op_mov_reg_v(ot, R_EAX, cpu_T1); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_end(); gen_jmp(s, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN break; case 0xee: case 0xef: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); gen_check_io(s, ot, pc_start - s-GREATER_TOKENcs_base, svm_is_rep(prefixes)); gen_op_mov_v_reg(ot, cpu_T1, R_EAX); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_start(); CLOSE_CURLY_TOKEN tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_end(); gen_jmp(s, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN break; case 0xc2: val = x86_ldsw_code(env, s); ot = gen_pop_T0(s); gen_stack_update(s, val + (1 SMALLER_TOKENSMALLER_TOKEN ot)); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 0xc3: ot = gen_pop_T0(s); gen_pop_update(s, ot); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 0xca: val = x86_ldsw_code(env, s); do_lret: if (s-GREATER_TOKENpe && !s-GREATER_TOKENvm86) OPEN_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1), tcg_const_i32(val)); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_stack_A0(s); gen_op_ld_v(s, dflag, cpu_T0, cpu_A0); gen_op_jmp_v(cpu_T0); gen_add_A0_im(s, 1 SMALLER_TOKENSMALLER_TOKEN dflag); gen_op_ld_v(s, dflag, cpu_T0, cpu_A0); gen_op_movl_seg_T0_vm(R_CS); gen_stack_update(s, val + (2 SMALLER_TOKENSMALLER_TOKEN dflag)); CLOSE_CURLY_TOKEN gen_eob(s); break; case 0xcb: val = 0; goto do_lret; case 0xcf: gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET); if (!s-GREATER_TOKENpe) OPEN_CURLY_TOKEN gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1)); set_cc_op(s, CC_OP_EFLAGS); CLOSE_CURLY_TOKEN else if (s-GREATER_TOKENvm86) OPEN_CURLY_TOKEN if (s-GREATER_TOKENiopl != 3) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1)); set_cc_op(s, CC_OP_EFLAGS); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1), tcg_const_i32(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base)); set_cc_op(s, CC_OP_EFLAGS); CLOSE_CURLY_TOKEN gen_eob(s); break; case 0xe8: OPEN_CURLY_TOKEN if (dflag != MO_16) OPEN_CURLY_TOKEN tval = (int32_t)insn_get(env, s, MO_32); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tval = (int16_t)insn_get(env, s, MO_16); CLOSE_CURLY_TOKEN next_eip = s-GREATER_TOKENpc - s-GREATER_TOKENcs_base; tval += next_eip; if (dflag == MO_16) OPEN_CURLY_TOKEN tval &= 0xffff; CLOSE_CURLY_TOKEN else if (!CODE64(s)) OPEN_CURLY_TOKEN tval &= 0xffffffff; CLOSE_CURLY_TOKEN tcg_gen_movi_tl(cpu_T0, next_eip); gen_push_v(s, cpu_T0); gen_bnd_jmp(s); gen_jmp(s, tval); CLOSE_CURLY_TOKEN break; case 0x9a: OPEN_CURLY_TOKEN unsigned int selector, offset; if (CODE64(s)) goto illegal_op; ot = dflag; offset = insn_get(env, s, ot); selector = insn_get(env, s, MO_16); tcg_gen_movi_tl(cpu_T0, selector); tcg_gen_movi_tl(cpu_T1, offset); CLOSE_CURLY_TOKEN goto do_lcall; case 0xe9: if (dflag != MO_16) OPEN_CURLY_TOKEN tval = (int32_t)insn_get(env, s, MO_32); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tval = (int16_t)insn_get(env, s, MO_16); CLOSE_CURLY_TOKEN tval += s-GREATER_TOKENpc - s-GREATER_TOKENcs_base; if (dflag == MO_16) OPEN_CURLY_TOKEN tval &= 0xffff; CLOSE_CURLY_TOKEN else if (!CODE64(s)) OPEN_CURLY_TOKEN tval &= 0xffffffff; CLOSE_CURLY_TOKEN gen_bnd_jmp(s); gen_jmp(s, tval); break; case 0xea: OPEN_CURLY_TOKEN unsigned int selector, offset; if (CODE64(s)) goto illegal_op; ot = dflag; offset = insn_get(env, s, ot); selector = insn_get(env, s, MO_16); tcg_gen_movi_tl(cpu_T0, selector); tcg_gen_movi_tl(cpu_T1, offset); CLOSE_CURLY_TOKEN goto do_ljmp; case 0xeb: tval = (int8_t)insn_get(env, s, MO_8); tval += s-GREATER_TOKENpc - s-GREATER_TOKENcs_base; if (dflag == MO_16) OPEN_CURLY_TOKEN tval &= 0xffff; CLOSE_CURLY_TOKEN gen_jmp(s, tval); break; case 0x70 ... 0x7f: tval = (int8_t)insn_get(env, s, MO_8); goto do_jcc; case 0x180 ... 0x18f: if (dflag != MO_16) OPEN_CURLY_TOKEN tval = (int32_t)insn_get(env, s, MO_32); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tval = (int16_t)insn_get(env, s, MO_16); CLOSE_CURLY_TOKEN do_jcc: next_eip = s-GREATER_TOKENpc - s-GREATER_TOKENcs_base; tval += next_eip; if (dflag == MO_16) OPEN_CURLY_TOKEN tval &= 0xffff; CLOSE_CURLY_TOKEN gen_bnd_jmp(s); gen_jcc(s, b, tval, next_eip); break; case 0x190 ... 0x19f: modrm = x86_ldub_code(env, s); gen_setcc1(s, b, cpu_T0); gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1); break; case 0x140 ... 0x14f: if (!(s-GREATER_TOKENcpuid_features & CPUID_CMOV)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; gen_cmovcc1(env, s, ot, b, modrm, reg); break; case 0x9c: gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF); if (s-GREATER_TOKENvm86 && s-GREATER_TOKENiopl != 3) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_update_cc_op(s); gen_helper_read_eflags(cpu_T0, cpu_env); gen_push_v(s, cpu_T0); CLOSE_CURLY_TOKEN break; case 0x9d: gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF); if (s-GREATER_TOKENvm86 && s-GREATER_TOKENiopl != 3) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ot = gen_pop_T0(s); if (s-GREATER_TOKENcpl == 0) OPEN_CURLY_TOKEN if (dflag != MO_16) OPEN_CURLY_TOKEN gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK))); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK) & 0xffff)); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (s-GREATER_TOKENcpl SMALLER_TOKEN= s-GREATER_TOKENiopl) OPEN_CURLY_TOKEN if (dflag != MO_16) OPEN_CURLY_TOKEN gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK))); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK) & 0xffff)); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (dflag != MO_16) OPEN_CURLY_TOKEN gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK))); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK) & 0xffff)); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN gen_pop_update(s, ot); set_cc_op(s, CC_OP_EFLAGS); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); CLOSE_CURLY_TOKEN break; case 0x9e: if (CODE64(s) && !(s-GREATER_TOKENcpuid_ext3_features & CPUID_EXT3_LAHF_LM)) goto illegal_op; gen_op_mov_v_reg(MO_8, cpu_T0, R_AH); gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O); tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C); tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0); break; case 0x9f: if (CODE64(s) && !(s-GREATER_TOKENcpuid_ext3_features & CPUID_EXT3_LAHF_LM)) goto illegal_op; gen_compute_eflags(s); tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02); gen_op_mov_reg_v(MO_8, R_AH, cpu_T0); break; case 0xf5: gen_compute_eflags(s); tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C); break; case 0xf8: gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C); break; case 0xf9: gen_compute_eflags(s); tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C); break; case 0xfc: tcg_gen_movi_i32(cpu_tmp2_i32, 1); tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df)); break; case 0xfd: tcg_gen_movi_i32(cpu_tmp2_i32, -1); tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df)); break; case 0x1ba: ot = dflag; modrm = x86_ldub_code(env, s); op = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod != 3) OPEN_CURLY_TOKEN s-GREATER_TOKENrip_offset = 1; gen_lea_modrm(env, s, modrm); if (!(s-GREATER_TOKENprefix & PREFIX_LOCK)) OPEN_CURLY_TOKEN gen_op_ld_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T0, rm); CLOSE_CURLY_TOKEN val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T1, val); if (op SMALLER_TOKEN 4) goto unknown_op; op -= 4; goto bt_op; case 0x1a3: op = 0; goto do_btx; case 0x1ab: op = 1; goto do_btx; case 0x1b3: op = 2; goto do_btx; case 0x1bb: op = 3; do_btx: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(MO_32, cpu_T1, reg); if (mod != 3) OPEN_CURLY_TOKEN AddressParts a = gen_lea_modrm_0(env, s, modrm); gen_exts(ot, cpu_T1); tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot); tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot); tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0); gen_lea_v_seg(s, s-GREATER_TOKENaflag, cpu_A0, a.def_seg, s-GREATER_TOKENoverride); if (!(s-GREATER_TOKENprefix & PREFIX_LOCK)) OPEN_CURLY_TOKEN gen_op_ld_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T0, rm); CLOSE_CURLY_TOKEN bt_op: tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 SMALLER_TOKENSMALLER_TOKEN (3 + ot)) - 1); tcg_gen_movi_tl(cpu_tmp0, 1); tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1); if (s-GREATER_TOKENprefix & PREFIX_LOCK) OPEN_CURLY_TOKEN switch (op) OPEN_CURLY_TOKEN case 0: gen_op_ld_v(s, ot, cpu_T0, cpu_A0); break; case 1: tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0, s-GREATER_TOKENmem_index, ot | MO_LE); break; case 2: tcg_gen_not_tl(cpu_tmp0, cpu_tmp0); tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0, s-GREATER_TOKENmem_index, ot | MO_LE); break; default: case 3: tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0, s-GREATER_TOKENmem_index, ot | MO_LE); break; CLOSE_CURLY_TOKEN tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1); switch (op) OPEN_CURLY_TOKEN case 0: break; case 1: tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0); break; case 2: tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0); break; default: case 3: tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0); break; CLOSE_CURLY_TOKEN if (op != 0) OPEN_CURLY_TOKEN if (mod != 3) OPEN_CURLY_TOKEN gen_op_st_v(s, ot, cpu_T0, cpu_A0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_reg_v(ot, rm, cpu_T0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN switch (s-GREATER_TOKENcc_op) OPEN_CURLY_TOKEN case CC_OP_MULB ... CC_OP_MULQ: case CC_OP_ADDB ... CC_OP_ADDQ: case CC_OP_ADCB ... CC_OP_ADCQ: case CC_OP_SUBB ... CC_OP_SUBQ: case CC_OP_SBBB ... CC_OP_SBBQ: case CC_OP_LOGICB ... CC_OP_LOGICQ: case CC_OP_INCB ... CC_OP_INCQ: case CC_OP_DECB ... CC_OP_DECQ: case CC_OP_SHLB ... CC_OP_SHLQ: case CC_OP_SARB ... CC_OP_SARQ: case CC_OP_BMILGB ... CC_OP_BMILGQ: tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4); set_cc_op(s, ((s-GREATER_TOKENcc_op - CC_OP_MULB) & 3) + CC_OP_SARB); break; default: gen_compute_eflags(s); tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4, ctz32(CC_C), 1); break; CLOSE_CURLY_TOKEN break; case 0x1bc: case 0x1bd: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_extu(ot, cpu_T0); if ((prefixes & PREFIX_REPZ) && (b & 1 ? s-GREATER_TOKENcpuid_ext3_features & CPUID_EXT3_ABM : s-GREATER_TOKENcpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) OPEN_CURLY_TOKEN int size = 8 SMALLER_TOKENSMALLER_TOKEN ot; tcg_gen_mov_tl(cpu_cc_src, cpu_T0); if (b & 1) OPEN_CURLY_TOKEN tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS); tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size); CLOSE_CURLY_TOKEN gen_op_update1_cc(); set_cc_op(s, CC_OP_BMILGB + ot); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); set_cc_op(s, CC_OP_LOGICB + ot); if (b & 1) OPEN_CURLY_TOKEN tcg_gen_xori_tl(cpu_T1, cpu_regsOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, TARGET_LONG_BITS - 1); tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1); tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regsOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN gen_op_mov_reg_v(ot, reg, cpu_T0); break; case 0x27: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_daa(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x2f: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_das(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x37: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_aaa(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x3f: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_aas(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0xd4: if (CODE64(s)) goto illegal_op; val = x86_ldub_code(env, s); if (val == 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP00_DIVZ, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_aam(cpu_env, tcg_const_i32(val)); set_cc_op(s, CC_OP_LOGICB); CLOSE_CURLY_TOKEN break; case 0xd5: if (CODE64(s)) goto illegal_op; val = x86_ldub_code(env, s); gen_helper_aad(cpu_env, tcg_const_i32(val)); set_cc_op(s, CC_OP_LOGICB); break; case 0x90: if (prefixes & PREFIX_LOCK) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (REX_B(s)) OPEN_CURLY_TOKEN goto do_xchg_reg_eax; CLOSE_CURLY_TOKEN if (prefixes & PREFIX_REPZ) OPEN_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_pause(cpu_env, tcg_const_i32(s-GREATER_TOKENpc - pc_start)); s-GREATER_TOKENbase.is_jmp = DISAS_NORETURN; CLOSE_CURLY_TOKEN break; case 0x9b: if ((s-GREATER_TOKENflags & (HF_MP_MASK | HF_TS_MASK)) == (HF_MP_MASK | HF_TS_MASK)) OPEN_CURLY_TOKEN gen_exception(s, EXCP07_PREX, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_fwait(cpu_env); CLOSE_CURLY_TOKEN break; case 0xcc: gen_interrupt(s, EXCP03_INT3, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); break; case 0xcd: val = x86_ldub_code(env, s); if (s-GREATER_TOKENvm86 && s-GREATER_TOKENiopl != 3) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_interrupt(s, val, pc_start - s-GREATER_TOKENcs_base, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN break; case 0xce: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_into(cpu_env, tcg_const_i32(s-GREATER_TOKENpc - pc_start)); break; #ifdef WANT_ICEBP case 0xf1: gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP); #if 1 gen_debug(s, pc_start - s-GREATER_TOKENcs_base); #else tb_flush(CPU(x86_env_get_cpu(env))); qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM); #endif break; #endif case 0xfa: if (!s-GREATER_TOKENvm86) OPEN_CURLY_TOKEN if (s-GREATER_TOKENcpl SMALLER_TOKEN= s-GREATER_TOKENiopl) OPEN_CURLY_TOKEN gen_helper_cli(cpu_env); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (s-GREATER_TOKENiopl == 3) OPEN_CURLY_TOKEN gen_helper_cli(cpu_env); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0xfb: if (s-GREATER_TOKENvm86 ? s-GREATER_TOKENiopl == 3 : s-GREATER_TOKENcpl SMALLER_TOKEN= s-GREATER_TOKENiopl) OPEN_CURLY_TOKEN gen_helper_sti(cpu_env); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob_inhibit_irq(s, "True" == "True"); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN break; case 0x62: if (CODE64(s)) goto illegal_op; ot = dflag; modrm = x86_ldub_code(env, s); reg = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if (mod == 3) goto illegal_op; gen_op_mov_v_reg(ot, cpu_T0, reg); gen_lea_modrm(env, s, modrm); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); if (ot == MO_16) OPEN_CURLY_TOKEN gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32); CLOSE_CURLY_TOKEN break; case 0x1c8 ... 0x1cf: reg = (b & 7) | REX_B(s); #ifdef TARGET_X86_64 if (dflag == MO_64) OPEN_CURLY_TOKEN gen_op_mov_v_reg(MO_64, cpu_T0, reg); tcg_gen_bswap64_i64(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_64, reg, cpu_T0); CLOSE_CURLY_TOKEN else #endif OPEN_CURLY_TOKEN gen_op_mov_v_reg(MO_32, cpu_T0, reg); tcg_gen_ext32u_tl(cpu_T0, cpu_T0); tcg_gen_bswap32_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_32, reg, cpu_T0); CLOSE_CURLY_TOKEN break; case 0xd6: if (CODE64(s)) goto illegal_op; gen_compute_eflags_c(s, cpu_T0); tcg_gen_neg_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0); break; case 0xe0: case 0xe1: case 0xe2: case 0xe3: OPEN_CURLY_TOKEN TCGLabel *l1, *l2, *l3; tval = (int8_t)insn_get(env, s, MO_8); next_eip = s-GREATER_TOKENpc - s-GREATER_TOKENcs_base; tval += next_eip; if (dflag == MO_16) OPEN_CURLY_TOKEN tval &= 0xffff; CLOSE_CURLY_TOKEN l1 = gen_new_label(); l2 = gen_new_label(); l3 = gen_new_label(); b &= 3; switch(b) OPEN_CURLY_TOKEN case 0: case 1: gen_op_add_reg_im(s-GREATER_TOKENaflag, R_ECX, -1); gen_op_jz_ecx(s-GREATER_TOKENaflag, l3); gen_jcc1(s, (JCC_Z SMALLER_TOKENSMALLER_TOKEN 1) | (b ^ 1), l1); break; case 2: gen_op_add_reg_im(s-GREATER_TOKENaflag, R_ECX, -1); gen_op_jnz_ecx(s-GREATER_TOKENaflag, l1); break; default: case 3: gen_op_jz_ecx(s-GREATER_TOKENaflag, l1); break; CLOSE_CURLY_TOKEN gen_set_label(l3); gen_jmp_im(next_eip); tcg_gen_br(l2); gen_set_label(l1); gen_jmp_im(tval); gen_set_label(l2); gen_eob(s); CLOSE_CURLY_TOKEN break; case 0x130: case 0x132: if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); if (b & 2) OPEN_CURLY_TOKEN gen_helper_rdmsr(cpu_env); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_wrmsr(cpu_env); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x131: gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_start(); CLOSE_CURLY_TOKEN gen_helper_rdtsc(cpu_env); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_end(); gen_jmp(s, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN break; case 0x133: gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_rdpmc(cpu_env); break; case 0x134: if (CODE64(s) && env-GREATER_TOKENcpuid_vendor1 != CPUID_VENDOR_INTEL_1) goto illegal_op; if (!s-GREATER_TOKENpe) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_sysenter(cpu_env); gen_eob(s); CLOSE_CURLY_TOKEN break; case 0x135: if (CODE64(s) && env-GREATER_TOKENcpuid_vendor1 != CPUID_VENDOR_INTEL_1) goto illegal_op; if (!s-GREATER_TOKENpe) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1)); gen_eob(s); CLOSE_CURLY_TOKEN break; #ifdef TARGET_X86_64 case 0x105: gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_syscall(cpu_env, tcg_const_i32(s-GREATER_TOKENpc - pc_start)); gen_eob_worker(s, "False" != "False", "True" == "True"); break; case 0x107: if (!s-GREATER_TOKENpe) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1)); if (s-GREATER_TOKENlma) OPEN_CURLY_TOKEN set_cc_op(s, CC_OP_EFLAGS); CLOSE_CURLY_TOKEN gen_eob_worker(s, "False" != "False", "True" == "True"); CLOSE_CURLY_TOKEN break; #endif case 0x1a2: gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_cpuid(cpu_env); break; case 0xf4: if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_hlt(cpu_env, tcg_const_i32(s-GREATER_TOKENpc - pc_start)); s-GREATER_TOKENbase.is_jmp = DISAS_NORETURN; CLOSE_CURLY_TOKEN break; case 0x100: modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; op = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; switch(op) OPEN_CURLY_TOKEN case 0: if (!s-GREATER_TOKENpe || s-GREATER_TOKENvm86) goto illegal_op; gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, ldt.selector)); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 2: if (!s-GREATER_TOKENpe || s-GREATER_TOKENvm86) goto illegal_op; if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lldt(cpu_env, cpu_tmp2_i32); CLOSE_CURLY_TOKEN break; case 1: if (!s-GREATER_TOKENpe || s-GREATER_TOKENvm86) goto illegal_op; gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, tr.selector)); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 3: if (!s-GREATER_TOKENpe || s-GREATER_TOKENvm86) goto illegal_op; if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_ltr(cpu_env, cpu_tmp2_i32); CLOSE_CURLY_TOKEN break; case 4: case 5: if (!s-GREATER_TOKENpe || s-GREATER_TOKENvm86) goto illegal_op; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_update_cc_op(s); if (op == 4) OPEN_CURLY_TOKEN gen_helper_verr(cpu_env, cpu_T0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_verw(cpu_env, cpu_T0); CLOSE_CURLY_TOKEN set_cc_op(s, CC_OP_EFLAGS); break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x101: modrm = x86_ldub_code(env, s); switch (modrm) OPEN_CURLY_TOKEN CASE_MODRM_MEM_OP(0): gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ); gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.limit)); gen_op_st_v(s, MO_16, cpu_T0, cpu_A0); gen_add_A0_im(s, 2); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base)); if (dflag == MO_16) OPEN_CURLY_TOKEN tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); CLOSE_CURLY_TOKEN gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); break; case 0xc8: if (!(s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_MONITOR) || s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); tcg_gen_mov_tl(cpu_A0, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN); gen_extu(s-GREATER_TOKENaflag, cpu_A0); gen_add_A0_ds_seg(s); gen_helper_monitor(cpu_env, cpu_A0); break; case 0xc9: if (!(s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_MONITOR) || s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_mwait(cpu_env, tcg_const_i32(s-GREATER_TOKENpc - pc_start)); gen_eob(s); break; case 0xca: if (!(s-GREATER_TOKENcpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP) || s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_helper_clac(cpu_env); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); break; case 0xcb: if (!(s-GREATER_TOKENcpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP) || s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_helper_stac(cpu_env); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(1): gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ); gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit)); gen_op_st_v(s, MO_16, cpu_T0, cpu_A0); gen_add_A0_im(s, 2); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base)); if (dflag == MO_16) OPEN_CURLY_TOKEN tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); CLOSE_CURLY_TOKEN gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); break; case 0xd0: if ((s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s-GREATER_TOKENprefix & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regsOPEN_SQUARE_TOKENR_ECXCLOSE_SQUARE_TOKEN); gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32); tcg_gen_extr_i64_tl(cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN, cpu_tmp1_i64); break; case 0xd1: if ((s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s-GREATER_TOKENprefix & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regsOPEN_SQUARE_TOKENR_ECXCLOSE_SQUARE_TOKEN); gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); break; case 0xd8: if (!(s-GREATER_TOKENflags & HF_SVME_MASK) || !s-GREATER_TOKENpe) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_vmrun(cpu_env, tcg_const_i32(s-GREATER_TOKENaflag - 1), tcg_const_i32(s-GREATER_TOKENpc - pc_start)); tcg_gen_exit_tb(0); s-GREATER_TOKENbase.is_jmp = DISAS_NORETURN; break; case 0xd9: if (!(s-GREATER_TOKENflags & HF_SVME_MASK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_vmmcall(cpu_env); break; case 0xda: if (!(s-GREATER_TOKENflags & HF_SVME_MASK) || !s-GREATER_TOKENpe) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_vmload(cpu_env, tcg_const_i32(s-GREATER_TOKENaflag - 1)); break; case 0xdb: if (!(s-GREATER_TOKENflags & HF_SVME_MASK) || !s-GREATER_TOKENpe) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_vmsave(cpu_env, tcg_const_i32(s-GREATER_TOKENaflag - 1)); break; case 0xdc: if ((!(s-GREATER_TOKENflags & HF_SVME_MASK) && !(s-GREATER_TOKENcpuid_ext3_features & CPUID_EXT3_SKINIT)) || !s-GREATER_TOKENpe) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_stgi(cpu_env); break; case 0xdd: if (!(s-GREATER_TOKENflags & HF_SVME_MASK) || !s-GREATER_TOKENpe) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_clgi(cpu_env); break; case 0xde: if ((!(s-GREATER_TOKENflags & HF_SVME_MASK) && !(s-GREATER_TOKENcpuid_ext3_features & CPUID_EXT3_SKINIT)) || !s-GREATER_TOKENpe) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_skinit(cpu_env); break; case 0xdf: if (!(s-GREATER_TOKENflags & HF_SVME_MASK) || !s-GREATER_TOKENpe) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_helper_invlpga(cpu_env, tcg_const_i32(s-GREATER_TOKENaflag - 1)); break; CASE_MODRM_MEM_OP(2): if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE); gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0); gen_add_A0_im(s, 2); gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); if (dflag == MO_16) OPEN_CURLY_TOKEN tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); CLOSE_CURLY_TOKEN tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base)); tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit)); break; CASE_MODRM_MEM_OP(3): if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE); gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0); gen_add_A0_im(s, 2); gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); if (dflag == MO_16) OPEN_CURLY_TOKEN tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); CLOSE_CURLY_TOKEN tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base)); tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit)); break; CASE_MODRM_OP(4): gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, crOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN)); if (CODE64(s)) OPEN_CURLY_TOKEN mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; ot = (mod != 3 ? MO_16 : s-GREATER_TOKENdflag); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ot = MO_16; CLOSE_CURLY_TOKEN gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 0xee: if (prefixes & PREFIX_LOCK) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regsOPEN_SQUARE_TOKENR_ECXCLOSE_SQUARE_TOKEN); gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32); tcg_gen_extr_i64_tl(cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN, cpu_tmp1_i64); break; case 0xef: if (prefixes & PREFIX_LOCK) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regsOPEN_SQUARE_TOKENR_ECXCLOSE_SQUARE_TOKEN); gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64); break; CASE_MODRM_OP(6): if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_helper_lmsw(cpu_env, cpu_T0); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(7): if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); gen_lea_modrm(env, s, modrm); gen_helper_invlpg(cpu_env, cpu_A0); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); break; case 0xf8: #ifdef TARGET_X86_64 if (CODE64(s)) OPEN_CURLY_TOKEN if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_mov_tl(cpu_T0, cpu_seg_baseOPEN_SQUARE_TOKENR_GSCLOSE_SQUARE_TOKEN); tcg_gen_ld_tl(cpu_seg_baseOPEN_SQUARE_TOKENR_GSCLOSE_SQUARE_TOKEN, cpu_env, offsetof(CPUX86State, kernelgsbase)); tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, kernelgsbase)); CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN #endif goto illegal_op; case 0xf9: if (!(s-GREATER_TOKENcpuid_ext2_features & CPUID_EXT2_RDTSCP)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_start(); CLOSE_CURLY_TOKEN gen_helper_rdtscp(cpu_env); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_end(); gen_jmp(s, s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x108: case 0x109: if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD); CLOSE_CURLY_TOKEN break; case 0x63: #ifdef TARGET_X86_64 if (CODE64(s)) OPEN_CURLY_TOKEN int d_ot; d_ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod == 3) OPEN_CURLY_TOKEN gen_op_mov_v_reg(MO_32, cpu_T0, rm); if (d_ot == MO_64) OPEN_CURLY_TOKEN tcg_gen_ext32s_tl(cpu_T0, cpu_T0); CLOSE_CURLY_TOKEN gen_op_mov_reg_v(d_ot, reg, cpu_T0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0); gen_op_mov_reg_v(d_ot, reg, cpu_T0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else #endif OPEN_CURLY_TOKEN TCGLabel *label1; TCGv t0, t1, t2, a0; if (!s-GREATER_TOKENpe || s-GREATER_TOKENvm86) goto illegal_op; t0 = tcg_temp_local_new(); t1 = tcg_temp_local_new(); t2 = tcg_temp_local_new(); ot = MO_16; modrm = x86_ldub_code(env, s); reg = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; rm = modrm & 7; if (mod != 3) OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, t0, cpu_A0); a0 = tcg_temp_local_new(); tcg_gen_mov_tl(a0, cpu_A0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_v_reg(ot, t0, rm); TCGV_UNUSED(a0); CLOSE_CURLY_TOKEN gen_op_mov_v_reg(ot, t1, reg); tcg_gen_andi_tl(cpu_tmp0, t0, 3); tcg_gen_andi_tl(t1, t1, 3); tcg_gen_movi_tl(t2, 0); label1 = gen_new_label(); tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1); tcg_gen_andi_tl(t0, t0, ~3); tcg_gen_or_tl(t0, t0, t1); tcg_gen_movi_tl(t2, CC_Z); gen_set_label(label1); if (mod != 3) OPEN_CURLY_TOKEN gen_op_st_v(s, ot, t0, a0); tcg_temp_free(a0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_op_mov_reg_v(ot, rm, t0); CLOSE_CURLY_TOKEN gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z); tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2); tcg_temp_free(t0); tcg_temp_free(t1); tcg_temp_free(t2); CLOSE_CURLY_TOKEN break; case 0x102: case 0x103: OPEN_CURLY_TOKEN TCGLabel *label1; TCGv t0; if (!s-GREATER_TOKENpe || s-GREATER_TOKENvm86) goto illegal_op; ot = dflag != MO_16 ? MO_32 : MO_16; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); t0 = tcg_temp_local_new(); gen_update_cc_op(s); if (b == 0x102) OPEN_CURLY_TOKEN gen_helper_lar(t0, cpu_env, cpu_T0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_lsl(t0, cpu_env, cpu_T0); CLOSE_CURLY_TOKEN tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z); label1 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1); gen_op_mov_reg_v(ot, reg, t0); gen_set_label(label1); set_cc_op(s, CC_OP_EFLAGS); tcg_temp_free(t0); CLOSE_CURLY_TOKEN break; case 0x118: modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; op = (modrm GREATER_TOKENGREATER_TOKEN 3) & 7; switch(op) OPEN_CURLY_TOKEN case 0: case 1: case 2: case 3: if (mod == 3) goto illegal_op; gen_nop_modrm(env, s, modrm); break; default: gen_nop_modrm(env, s, modrm); break; CLOSE_CURLY_TOKEN break; case 0x11a: modrm = x86_ldub_code(env, s); if (s-GREATER_TOKENflags & HF_MPX_EN_MASK) OPEN_CURLY_TOKEN mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; if (prefixes & PREFIX_REPZ) OPEN_CURLY_TOKEN if (reg GREATER_TOKEN= 4 || (prefixes & PREFIX_LOCK) || s-GREATER_TOKENaflag == MO_16) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN else if (prefixes & PREFIX_REPNZ) OPEN_CURLY_TOKEN if (reg GREATER_TOKEN= 4 || (prefixes & PREFIX_LOCK) || s-GREATER_TOKENaflag == MO_16) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN TCGv_i64 notu = tcg_temp_new_i64(); tcg_gen_not_i64(notu, cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); gen_bndck(env, s, modrm, TCG_COND_GTU, notu); tcg_temp_free_i64(notu); CLOSE_CURLY_TOKEN else if (prefixes & PREFIX_DATA) OPEN_CURLY_TOKEN if (reg GREATER_TOKEN= 4 || s-GREATER_TOKENaflag == MO_16) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (mod == 3) OPEN_CURLY_TOKEN int reg2 = (modrm & 7) | REX_B(s); if (reg2 GREATER_TOKEN= 4 || (prefixes & PREFIX_LOCK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENflags & HF_MPX_IU_MASK) OPEN_CURLY_TOKEN tcg_gen_mov_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_bndlOPEN_SQUARE_TOKENreg2CLOSE_SQUARE_TOKEN); tcg_gen_mov_i64(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_bnduOPEN_SQUARE_TOKENreg2CLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); if (CODE64(s)) OPEN_CURLY_TOKEN tcg_gen_qemu_ld_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); tcg_gen_addi_tl(cpu_A0, cpu_A0, 8); tcg_gen_qemu_ld_i64(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_qemu_ld_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); tcg_gen_addi_tl(cpu_A0, cpu_A0, 4); tcg_gen_qemu_ld_i64(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); CLOSE_CURLY_TOKEN gen_set_hflag(s, HF_MPX_IU_MASK); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (mod != 3) OPEN_CURLY_TOKEN AddressParts a = gen_lea_modrm_0(env, s, modrm); if (reg GREATER_TOKEN= 4 || (prefixes & PREFIX_LOCK) || s-GREATER_TOKENaflag == MO_16 || a.base SMALLER_TOKEN -1) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (a.base GREATER_TOKEN= 0) OPEN_CURLY_TOKEN tcg_gen_addi_tl(cpu_A0, cpu_regsOPEN_SQUARE_TOKENa.baseCLOSE_SQUARE_TOKEN, a.disp); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_movi_tl(cpu_A0, 0); CLOSE_CURLY_TOKEN gen_lea_v_seg(s, s-GREATER_TOKENaflag, cpu_A0, a.def_seg, s-GREATER_TOKENoverride); if (a.index GREATER_TOKEN= 0) OPEN_CURLY_TOKEN tcg_gen_mov_tl(cpu_T0, cpu_regsOPEN_SQUARE_TOKENa.indexCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_movi_tl(cpu_T0, 0); CLOSE_CURLY_TOKEN if (CODE64(s)) OPEN_CURLY_TOKEN gen_helper_bndldx64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_env, cpu_A0, cpu_T0); tcg_gen_ld_i64(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_env, offsetof(CPUX86State, mmx_t0.MMX_Q(0))); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_bndldx32(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_env, cpu_A0, cpu_T0); tcg_gen_ext32u_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); tcg_gen_shri_i64(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, 32); CLOSE_CURLY_TOKEN gen_set_hflag(s, HF_MPX_IU_MASK); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN gen_nop_modrm(env, s, modrm); break; case 0x11b: modrm = x86_ldub_code(env, s); if (s-GREATER_TOKENflags & HF_MPX_EN_MASK) OPEN_CURLY_TOKEN mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; if (mod != 3 && (prefixes & PREFIX_REPZ)) OPEN_CURLY_TOKEN if (reg GREATER_TOKEN= 4 || (prefixes & PREFIX_LOCK) || s-GREATER_TOKENaflag == MO_16) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN AddressParts a = gen_lea_modrm_0(env, s, modrm); if (a.base GREATER_TOKEN= 0) OPEN_CURLY_TOKEN tcg_gen_extu_tl_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENa.baseCLOSE_SQUARE_TOKEN); if (!CODE64(s)) OPEN_CURLY_TOKEN tcg_gen_ext32u_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (a.base == -1) OPEN_CURLY_TOKEN tcg_gen_movi_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, 0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a)); if (!CODE64(s)) OPEN_CURLY_TOKEN tcg_gen_ext32u_tl(cpu_A0, cpu_A0); CLOSE_CURLY_TOKEN tcg_gen_extu_tl_i64(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0); gen_set_hflag(s, HF_MPX_IU_MASK); break; CLOSE_CURLY_TOKEN else if (prefixes & PREFIX_REPNZ) OPEN_CURLY_TOKEN if (reg GREATER_TOKEN= 4 || (prefixes & PREFIX_LOCK) || s-GREATER_TOKENaflag == MO_16) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN else if (prefixes & PREFIX_DATA) OPEN_CURLY_TOKEN if (reg GREATER_TOKEN= 4 || s-GREATER_TOKENaflag == MO_16) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (mod == 3) OPEN_CURLY_TOKEN int reg2 = (modrm & 7) | REX_B(s); if (reg2 GREATER_TOKEN= 4 || (prefixes & PREFIX_LOCK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENflags & HF_MPX_IU_MASK) OPEN_CURLY_TOKEN tcg_gen_mov_i64(cpu_bndlOPEN_SQUARE_TOKENreg2CLOSE_SQUARE_TOKEN, cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); tcg_gen_mov_i64(cpu_bnduOPEN_SQUARE_TOKENreg2CLOSE_SQUARE_TOKEN, cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_lea_modrm(env, s, modrm); if (CODE64(s)) OPEN_CURLY_TOKEN tcg_gen_qemu_st_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); tcg_gen_addi_tl(cpu_A0, cpu_A0, 8); tcg_gen_qemu_st_i64(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0, s-GREATER_TOKENmem_index, MO_LEQ); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_qemu_st_i64(cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); tcg_gen_addi_tl(cpu_A0, cpu_A0, 4); tcg_gen_qemu_st_i64(cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (mod != 3) OPEN_CURLY_TOKEN AddressParts a = gen_lea_modrm_0(env, s, modrm); if (reg GREATER_TOKEN= 4 || (prefixes & PREFIX_LOCK) || s-GREATER_TOKENaflag == MO_16 || a.base SMALLER_TOKEN -1) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (a.base GREATER_TOKEN= 0) OPEN_CURLY_TOKEN tcg_gen_addi_tl(cpu_A0, cpu_regsOPEN_SQUARE_TOKENa.baseCLOSE_SQUARE_TOKEN, a.disp); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_movi_tl(cpu_A0, 0); CLOSE_CURLY_TOKEN gen_lea_v_seg(s, s-GREATER_TOKENaflag, cpu_A0, a.def_seg, s-GREATER_TOKENoverride); if (a.index GREATER_TOKEN= 0) OPEN_CURLY_TOKEN tcg_gen_mov_tl(cpu_T0, cpu_regsOPEN_SQUARE_TOKENa.indexCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_movi_tl(cpu_T0, 0); CLOSE_CURLY_TOKEN if (CODE64(s)) OPEN_CURLY_TOKEN gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0, cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0, cpu_bndlOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN, cpu_bnduOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN gen_nop_modrm(env, s, modrm); break; case 0x119: case 0x11c ... 0x11f: modrm = x86_ldub_code(env, s); gen_nop_modrm(env, s, modrm); break; case 0x120: case 0x122: if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN modrm = x86_ldub_code(env, s); rm = (modrm & 7) | REX_B(s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; if (CODE64(s)) ot = MO_64; else ot = MO_32; if ((prefixes & PREFIX_LOCK) && (reg == 0) && (s-GREATER_TOKENcpuid_ext3_features & CPUID_EXT3_CR8LEG)) OPEN_CURLY_TOKEN reg = 8; CLOSE_CURLY_TOKEN switch(reg) OPEN_CURLY_TOKEN case 0: case 2: case 3: case 4: case 8: gen_update_cc_op(s); gen_jmp_im(pc_start - s-GREATER_TOKENcs_base); if (b & 2) OPEN_CURLY_TOKEN if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_start(); CLOSE_CURLY_TOKEN gen_op_mov_v_reg(ot, cpu_T0, rm); gen_helper_write_crN(cpu_env, tcg_const_i32(reg), cpu_T0); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_end(); CLOSE_CURLY_TOKEN gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_start(); CLOSE_CURLY_TOKEN gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg)); gen_op_mov_reg_v(ot, rm, cpu_T0); if (s-GREATER_TOKENbase.tb-GREATER_TOKENcflags & CF_USE_ICOUNT) OPEN_CURLY_TOKEN gen_io_end(); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; default: goto unknown_op; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x121: case 0x123: if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN modrm = x86_ldub_code(env, s); rm = (modrm & 7) | REX_B(s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; if (CODE64(s)) ot = MO_64; else ot = MO_32; if (reg GREATER_TOKEN= 8) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (b & 2) OPEN_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg); gen_op_mov_v_reg(ot, cpu_T0, rm); tcg_gen_movi_i32(cpu_tmp2_i32, reg); gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg); tcg_gen_movi_i32(cpu_tmp2_i32, reg); gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32); gen_op_mov_reg_v(ot, rm, cpu_T0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 0x106: if (s-GREATER_TOKENcpl != 0) OPEN_CURLY_TOKEN gen_exception(s, EXCP0D_GPF, pc_start - s-GREATER_TOKENcs_base); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0); gen_helper_clts(cpu_env); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); CLOSE_CURLY_TOKEN break; case 0x1c3: if (!(s-GREATER_TOKENcpuid_features & CPUID_SSE2)) goto illegal_op; ot = mo_64_32(dflag); modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if (mod == 3) goto illegal_op; reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, reg, 1); break; case 0x1ae: modrm = x86_ldub_code(env, s); switch (modrm) OPEN_CURLY_TOKEN CASE_MODRM_MEM_OP(0): if (!(s-GREATER_TOKENcpuid_features & CPUID_FXSR) || (prefixes & PREFIX_LOCK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if ((s-GREATER_TOKENflags & HF_EM_MASK) || (s-GREATER_TOKENflags & HF_TS_MASK)) OPEN_CURLY_TOKEN gen_exception(s, EXCP07_PREX, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); gen_helper_fxsave(cpu_env, cpu_A0); break; CASE_MODRM_MEM_OP(1): if (!(s-GREATER_TOKENcpuid_features & CPUID_FXSR) || (prefixes & PREFIX_LOCK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if ((s-GREATER_TOKENflags & HF_EM_MASK) || (s-GREATER_TOKENflags & HF_TS_MASK)) OPEN_CURLY_TOKEN gen_exception(s, EXCP07_PREX, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); gen_helper_fxrstor(cpu_env, cpu_A0); break; CASE_MODRM_MEM_OP(2): if ((s-GREATER_TOKENflags & HF_EM_MASK) || !(s-GREATER_TOKENflags & HF_OSFXSR_MASK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENflags & HF_TS_MASK) OPEN_CURLY_TOKEN gen_exception(s, EXCP07_PREX, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s-GREATER_TOKENmem_index, MO_LEUL); gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32); break; CASE_MODRM_MEM_OP(3): if ((s-GREATER_TOKENflags & HF_EM_MASK) || !(s-GREATER_TOKENflags & HF_OSFXSR_MASK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENflags & HF_TS_MASK) OPEN_CURLY_TOKEN gen_exception(s, EXCP07_PREX, pc_start - s-GREATER_TOKENcs_base); break; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr)); gen_op_st_v(s, MO_32, cpu_T0, cpu_A0); break; CASE_MODRM_MEM_OP(4): if ((s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (prefixes & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64); break; CASE_MODRM_MEM_OP(5): if ((s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (prefixes & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64); gen_update_cc_op(s); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(6): if (prefixes & PREFIX_LOCK) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (prefixes & PREFIX_DATA) OPEN_CURLY_TOKEN if (!(s-GREATER_TOKENcpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_nop_modrm(env, s, modrm); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if ((s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s-GREATER_TOKENcpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0 || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regsOPEN_SQUARE_TOKENR_EAXCLOSE_SQUARE_TOKEN, cpu_regsOPEN_SQUARE_TOKENR_EDXCLOSE_SQUARE_TOKEN); gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64); CLOSE_CURLY_TOKEN break; CASE_MODRM_MEM_OP(7): if (prefixes & PREFIX_LOCK) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN if (prefixes & PREFIX_DATA) OPEN_CURLY_TOKEN if (!(s-GREATER_TOKENcpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if ((s-GREATER_TOKENprefix & (PREFIX_REPZ | PREFIX_REPNZ)) || !(s-GREATER_TOKENcpuid_features & CPUID_CLFLUSH)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN gen_nop_modrm(env, s, modrm); break; case 0xc0 ... 0xc7: case 0xc8 ... 0xcf: case 0xd0 ... 0xd7: case 0xd8 ... 0xdf: if (CODE64(s) && (prefixes & PREFIX_REPZ) && !(prefixes & PREFIX_LOCK) && (s-GREATER_TOKENcpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) OPEN_CURLY_TOKEN TCGv base, treg, src, dst; tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK); gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32); base = cpu_seg_baseOPEN_SQUARE_TOKENmodrm & 8 ? R_GS : R_FSCLOSE_SQUARE_TOKEN; treg = cpu_regsOPEN_SQUARE_TOKEN(modrm & 7) | REX_B(s)CLOSE_SQUARE_TOKEN; if (modrm & 0x10) OPEN_CURLY_TOKEN dst = base, src = treg; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN dst = treg, src = base; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENdflag == MO_32) OPEN_CURLY_TOKEN tcg_gen_ext32u_tl(dst, src); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_gen_mov_tl(dst, src); CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN goto unknown_op; case 0xf8: if (prefixes & PREFIX_DATA) OPEN_CURLY_TOKEN if (!(s-GREATER_TOKENcpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT) || (prefixes & PREFIX_LOCK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN case 0xf9 ... 0xff: if (!(s-GREATER_TOKENcpuid_features & CPUID_SSE) || (prefixes & PREFIX_LOCK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC); break; case 0xe8 ... 0xef: if (!(s-GREATER_TOKENcpuid_features & CPUID_SSE) || (prefixes & PREFIX_LOCK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC); break; case 0xf0 ... 0xf7: if (!(s-GREATER_TOKENcpuid_features & CPUID_SSE2) || (prefixes & PREFIX_LOCK)) OPEN_CURLY_TOKEN goto illegal_op; CLOSE_CURLY_TOKEN tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC); break; default: goto unknown_op; CLOSE_CURLY_TOKEN break; case 0x10d: modrm = x86_ldub_code(env, s); mod = (modrm GREATER_TOKENGREATER_TOKEN 6) & 3; if (mod == 3) goto illegal_op; gen_nop_modrm(env, s, modrm); break; case 0x1aa: gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM); if (!(s-GREATER_TOKENflags & HF_SMM_MASK)) goto illegal_op; gen_update_cc_op(s); gen_jmp_im(s-GREATER_TOKENpc - s-GREATER_TOKENcs_base); gen_helper_rsm(cpu_env); gen_eob(s); break; case 0x1b8: if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) != PREFIX_REPZ) goto illegal_op; if (!(s-GREATER_TOKENcpuid_ext_features & CPUID_EXT_POPCNT)) goto illegal_op; modrm = x86_ldub_code(env, s); reg = ((modrm GREATER_TOKENGREATER_TOKEN 3) & 7) | rex_r; if (s-GREATER_TOKENprefix & PREFIX_DATA) OPEN_CURLY_TOKEN ot = MO_16; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ot = mo_64_32(dflag); CLOSE_CURLY_TOKEN gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_extu(ot, cpu_T0); tcg_gen_mov_tl(cpu_cc_src, cpu_T0); tcg_gen_ctpop_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(ot, reg, cpu_T0); set_cc_op(s, CC_OP_POPCNT); break; case 0x10e ... 0x10f: s-GREATER_TOKENprefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA); case 0x110 ... 0x117: case 0x128 ... 0x12f: case 0x138 ... 0x13a: case 0x150 ... 0x179: case 0x17c ... 0x17f: case 0x1c2: case 0x1c4 ... 0x1c6: case 0x1d0 ... 0x1fe: gen_sse(env, s, b, pc_start, rex_r); break; default: goto unknown_op; CLOSE_CURLY_TOKEN return s-GREATER_TOKENpc; illegal_op: gen_illegal_opcode(s); return s-GREATER_TOKENpc; unknown_op: gen_unknown_opcode(env, s); return s-GREATER_TOKENpc; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 15 / 8 / 26 / 49:   2%|         | 49/2690 [00:00<00:00, 2641.96it/s]
--------------------------------------------- Result 50 ---------------------------------------------
[[1 (88%)]] --> [[0 (59%)]] --> Socre: 0.5909097790718079

[[[[Adv]]]]: static int alac_decode_frame(AVCodecContext *avctx, void *outbuffer, int *outputsize, const uint8_t *inbuffer, int [[input_buffer_size]]) OPEN_CURLY_TOKEN ALACContext *alac = avctx-GREATER_TOKENpriv_data; int channels; unsigned int [[outputsamples]]; int hassize; int readsamplesize; int wasted_bytes; int isnotcompressed; uint8_t interlacing_shift; uint8_t interlacing_leftweight; if (!inbuffer || ![[input_buffer_size]]) return [[input_buffer_size]]; if (!alac-GREATER_TOKENcontext_initialized) OPEN_CURLY_TOKEN if (alac-GREATER_TOKENavctx-GREATER_TOKENextradata_size != ALAC_EXTRADATA_SIZE) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "alac: expected %d extradata bytes\n", ALAC_EXTRADATA_SIZE); return [[input_buffer_size]]; CLOSE_CURLY_TOKEN if (alac_set_info(alac)) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "alac: set_info failed\n"); return [[input_buffer_size]]; CLOSE_CURLY_TOKEN alac-GREATER_TOKENcontext_initialized = 1; CLOSE_CURLY_TOKEN init_get_bits(&alac-GREATER_TOKENgb, inbuffer, [[input_buffer_size]] * 8); channels = get_bits(&alac-GREATER_TOKENgb, 3) + 1; if (channels GREATER_TOKEN MAX_CHANNELS) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "channels GREATER_TOKEN %d not supported\n", MAX_CHANNELS); return [[input_buffer_size]]; CLOSE_CURLY_TOKEN skip_bits(&alac-GREATER_TOKENgb, 4); skip_bits(&alac-GREATER_TOKENgb, 12); hassize = get_bits1(&alac-GREATER_TOKENgb); wasted_bytes = get_bits(&alac-GREATER_TOKENgb, 2); isnotcompressed = get_bits1(&alac-GREATER_TOKENgb); if (hassize) OPEN_CURLY_TOKEN [[outputsamples]] = get_bits_long(&alac-GREATER_TOKENgb, 32); if([[outputsamples]] GREATER_TOKEN alac-GREATER_TOKENsetinfo_max_samples_per_frame)OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "outputsamples %d GREATER_TOKEN %d\n", [[outputsamples]], alac-GREATER_TOKENsetinfo_max_samples_per_frame); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else [[outputsamples]] = alac-GREATER_TOKENsetinfo_max_samples_per_frame; if([[outputsamples]] GREATER_TOKEN *outputsize / alac-GREATER_TOKENbytespersample)OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "sample buffer too small\n"); return -1; CLOSE_CURLY_TOKEN *outputsize = [[outputsamples]] * alac-GREATER_TOKENbytespersample; readsamplesize = alac-GREATER_TOKENsetinfo_sample_size - (wasted_bytes * 8) + channels - 1; if (!isnotcompressed) OPEN_CURLY_TOKEN int16_t predictor_coef_tableOPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN32CLOSE_SQUARE_TOKEN; int predictor_coef_numOPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKEN; int [[prediction_type]]OPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKEN; int prediction_quantitizationOPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKEN; int ricemodifierOPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKEN; int i, chan; interlacing_shift = get_bits(&alac-GREATER_TOKENgb, 8); interlacing_leftweight = get_bits(&alac-GREATER_TOKENgb, 8); for (chan = 0; chan SMALLER_TOKEN channels; chan++) OPEN_CURLY_TOKEN [[prediction_type]]OPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN = get_bits(&alac-GREATER_TOKENgb, 4); prediction_quantitizationOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN = get_bits(&alac-GREATER_TOKENgb, 4); ricemodifierOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN = get_bits(&alac-GREATER_TOKENgb, 3); predictor_coef_numOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN = get_bits(&alac-GREATER_TOKENgb, 5); for (i = 0; i SMALLER_TOKEN predictor_coef_numOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN; i++) predictor_coef_tableOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = (int16_t)get_bits(&alac-GREATER_TOKENgb, 16); CLOSE_CURLY_TOKEN if (wasted_bytes) av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented, unhandling of wasted_bytes\n"); for (chan = 0; chan SMALLER_TOKEN channels; chan++) OPEN_CURLY_TOKEN bastardized_rice_decompress(alac, alac-GREATER_TOKENpredicterror_bufferOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, [[outputsamples]], readsamplesize, alac-GREATER_TOKENsetinfo_rice_initialhistory, alac-GREATER_TOKENsetinfo_rice_kmodifier, ricemodifierOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN * alac-GREATER_TOKENsetinfo_rice_historymult / 4, (1 SMALLER_TOKENSMALLER_TOKEN alac-GREATER_TOKENsetinfo_rice_kmodifier) - 1); if ([[prediction_type]]OPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN == 0) OPEN_CURLY_TOKEN predictor_decompress_fir_adapt(alac-GREATER_TOKENpredicterror_bufferOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, alac-GREATER_TOKENoutputsamples_bufferOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, [[outputsamples]], readsamplesize, predictor_coef_tableOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, predictor_coef_numOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, prediction_quantitizationOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "FIXME: unhandled prediction type: %i\n", [[prediction_type]]OPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN int i, chan; for (i = 0; i SMALLER_TOKEN [[outputsamples]]; i++) for (chan = 0; chan SMALLER_TOKEN channels; chan++) OPEN_CURLY_TOKEN int32_t audiobits; audiobits = get_bits_long(&alac-GREATER_TOKENgb, alac-GREATER_TOKENsetinfo_sample_size); audiobits = extend_sign32(audiobits, alac-GREATER_TOKENsetinfo_sample_size); alac-GREATER_TOKENoutputsamples_bufferOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = audiobits; CLOSE_CURLY_TOKEN interlacing_shift = 0; interlacing_leftweight = 0; CLOSE_CURLY_TOKEN if (get_bits(&alac-GREATER_TOKENgb, 3) != 7) av_log(avctx, AV_LOG_ERROR, "Error : Wrong End Of Frame\n"); switch(alac-GREATER_TOKENsetinfo_sample_size) OPEN_CURLY_TOKEN case 16: if (channels == 2) OPEN_CURLY_TOKEN reconstruct_stereo_16(alac-GREATER_TOKENoutputsamples_buffer, (int16_t*)outbuffer, alac-GREATER_TOKENnumchannels, [[outputsamples]], interlacing_shift, interlacing_leftweight); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN int i; for (i = 0; i SMALLER_TOKEN [[outputsamples]]; i++) OPEN_CURLY_TOKEN int16_t sample = alac-GREATER_TOKENoutputsamples_bufferOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; ((int16_t*)outbuffer)OPEN_SQUARE_TOKENi * alac-GREATER_TOKENnumchannelsCLOSE_SQUARE_TOKEN = sample; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 20: case 24: case 32: av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented sample size %i\n", alac-GREATER_TOKENsetinfo_sample_size); break; default: break; CLOSE_CURLY_TOKEN if ([[input_buffer_size]] * 8 - get_bits_count(&alac-GREATER_TOKENgb) GREATER_TOKEN 8) av_log(avctx, AV_LOG_ERROR, "Error : %d bits left\n", [[input_buffer_size]] * 8 - get_bits_count(&alac-GREATER_TOKENgb)); return [[input_buffer_size]]; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int alac_decode_frame(AVCodecContext *avctx, void *outbuffer, int *outputsize, const uint8_t *inbuffer, int [[affiliations]]) OPEN_CURLY_TOKEN ALACContext *alac = avctx-GREATER_TOKENpriv_data; int channels; unsigned int [[danger]]; int hassize; int readsamplesize; int wasted_bytes; int isnotcompressed; uint8_t interlacing_shift; uint8_t interlacing_leftweight; if (!inbuffer || ![[affiliations]]) return [[affiliations]]; if (!alac-GREATER_TOKENcontext_initialized) OPEN_CURLY_TOKEN if (alac-GREATER_TOKENavctx-GREATER_TOKENextradata_size != ALAC_EXTRADATA_SIZE) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "alac: expected %d extradata bytes\n", ALAC_EXTRADATA_SIZE); return [[affiliations]]; CLOSE_CURLY_TOKEN if (alac_set_info(alac)) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "alac: set_info failed\n"); return [[affiliations]]; CLOSE_CURLY_TOKEN alac-GREATER_TOKENcontext_initialized = 1; CLOSE_CURLY_TOKEN init_get_bits(&alac-GREATER_TOKENgb, inbuffer, [[affiliations]] * 8); channels = get_bits(&alac-GREATER_TOKENgb, 3) + 1; if (channels GREATER_TOKEN MAX_CHANNELS) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "channels GREATER_TOKEN %d not supported\n", MAX_CHANNELS); return [[affiliations]]; CLOSE_CURLY_TOKEN skip_bits(&alac-GREATER_TOKENgb, 4); skip_bits(&alac-GREATER_TOKENgb, 12); hassize = get_bits1(&alac-GREATER_TOKENgb); wasted_bytes = get_bits(&alac-GREATER_TOKENgb, 2); isnotcompressed = get_bits1(&alac-GREATER_TOKENgb); if (hassize) OPEN_CURLY_TOKEN [[danger]] = get_bits_long(&alac-GREATER_TOKENgb, 32); if([[danger]] GREATER_TOKEN alac-GREATER_TOKENsetinfo_max_samples_per_frame)OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "outputsamples %d GREATER_TOKEN %d\n", [[danger]], alac-GREATER_TOKENsetinfo_max_samples_per_frame); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else [[danger]] = alac-GREATER_TOKENsetinfo_max_samples_per_frame; if([[danger]] GREATER_TOKEN *outputsize / alac-GREATER_TOKENbytespersample)OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "sample buffer too small\n"); return -1; CLOSE_CURLY_TOKEN *outputsize = [[danger]] * alac-GREATER_TOKENbytespersample; readsamplesize = alac-GREATER_TOKENsetinfo_sample_size - (wasted_bytes * 8) + channels - 1; if (!isnotcompressed) OPEN_CURLY_TOKEN int16_t predictor_coef_tableOPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN32CLOSE_SQUARE_TOKEN; int predictor_coef_numOPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKEN; int [[zora]]OPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKEN; int prediction_quantitizationOPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKEN; int ricemodifierOPEN_SQUARE_TOKENchannelsCLOSE_SQUARE_TOKEN; int i, chan; interlacing_shift = get_bits(&alac-GREATER_TOKENgb, 8); interlacing_leftweight = get_bits(&alac-GREATER_TOKENgb, 8); for (chan = 0; chan SMALLER_TOKEN channels; chan++) OPEN_CURLY_TOKEN [[zora]]OPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN = get_bits(&alac-GREATER_TOKENgb, 4); prediction_quantitizationOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN = get_bits(&alac-GREATER_TOKENgb, 4); ricemodifierOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN = get_bits(&alac-GREATER_TOKENgb, 3); predictor_coef_numOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN = get_bits(&alac-GREATER_TOKENgb, 5); for (i = 0; i SMALLER_TOKEN predictor_coef_numOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN; i++) predictor_coef_tableOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = (int16_t)get_bits(&alac-GREATER_TOKENgb, 16); CLOSE_CURLY_TOKEN if (wasted_bytes) av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented, unhandling of wasted_bytes\n"); for (chan = 0; chan SMALLER_TOKEN channels; chan++) OPEN_CURLY_TOKEN bastardized_rice_decompress(alac, alac-GREATER_TOKENpredicterror_bufferOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, [[danger]], readsamplesize, alac-GREATER_TOKENsetinfo_rice_initialhistory, alac-GREATER_TOKENsetinfo_rice_kmodifier, ricemodifierOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN * alac-GREATER_TOKENsetinfo_rice_historymult / 4, (1 SMALLER_TOKENSMALLER_TOKEN alac-GREATER_TOKENsetinfo_rice_kmodifier) - 1); if ([[zora]]OPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN == 0) OPEN_CURLY_TOKEN predictor_decompress_fir_adapt(alac-GREATER_TOKENpredicterror_bufferOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, alac-GREATER_TOKENoutputsamples_bufferOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, [[danger]], readsamplesize, predictor_coef_tableOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, predictor_coef_numOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN, prediction_quantitizationOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "FIXME: unhandled prediction type: %i\n", [[zora]]OPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN int i, chan; for (i = 0; i SMALLER_TOKEN [[danger]]; i++) for (chan = 0; chan SMALLER_TOKEN channels; chan++) OPEN_CURLY_TOKEN int32_t audiobits; audiobits = get_bits_long(&alac-GREATER_TOKENgb, alac-GREATER_TOKENsetinfo_sample_size); audiobits = extend_sign32(audiobits, alac-GREATER_TOKENsetinfo_sample_size); alac-GREATER_TOKENoutputsamples_bufferOPEN_SQUARE_TOKENchanCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = audiobits; CLOSE_CURLY_TOKEN interlacing_shift = 0; interlacing_leftweight = 0; CLOSE_CURLY_TOKEN if (get_bits(&alac-GREATER_TOKENgb, 3) != 7) av_log(avctx, AV_LOG_ERROR, "Error : Wrong End Of Frame\n"); switch(alac-GREATER_TOKENsetinfo_sample_size) OPEN_CURLY_TOKEN case 16: if (channels == 2) OPEN_CURLY_TOKEN reconstruct_stereo_16(alac-GREATER_TOKENoutputsamples_buffer, (int16_t*)outbuffer, alac-GREATER_TOKENnumchannels, [[danger]], interlacing_shift, interlacing_leftweight); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN int i; for (i = 0; i SMALLER_TOKEN [[danger]]; i++) OPEN_CURLY_TOKEN int16_t sample = alac-GREATER_TOKENoutputsamples_bufferOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; ((int16_t*)outbuffer)OPEN_SQUARE_TOKENi * alac-GREATER_TOKENnumchannelsCLOSE_SQUARE_TOKEN = sample; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case 20: case 24: case 32: av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented sample size %i\n", alac-GREATER_TOKENsetinfo_sample_size); break; default: break; CLOSE_CURLY_TOKEN if ([[affiliations]] * 8 - get_bits_count(&alac-GREATER_TOKENgb) GREATER_TOKEN 8) av_log(avctx, AV_LOG_ERROR, "Error : %d bits left\n", [[affiliations]] * 8 - get_bits_count(&alac-GREATER_TOKENgb)); return [[affiliations]]; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 16 / 8 / 26 / 50:   2%|         | 50/2690 [00:00<00:01, 2534.45it/s][Succeeded / Failed / Skipped / Total] 16 / 8 / 27 / 51:   2%|         | 51/2690 [00:00<00:01, 2558.66it/s][Succeeded / Failed / Skipped / Total] 17 / 8 / 27 / 52:   2%|         | 52/2690 [00:00<00:01, 2547.02it/s][Succeeded / Failed / Skipped / Total] 17 / 9 / 27 / 53:   2%|         | 53/2690 [00:00<00:01, 2547.10it/s]
--------------------------------------------- Result 51 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CommandInfoList *qmp_query_commands(Error **errp) OPEN_CURLY_TOKEN CommandInfoList *list = NULL; qmp_for_each_command(&qmp_commands, query_commands_cb, &list); return list; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 52 ---------------------------------------------
[[1 (63%)]] --> [[0 (53%)]] --> Socre: 0.5267582535743713

[[[[Adv]]]]: void stream_start(const char *[[job_id]], BlockDriverState *bs, BlockDriverState *[[base]], const char *backing_file_str, int64_t speed, BlockdevOnError on_error, BlockCompletionFunc *cb, void *opaque, Error **errp) OPEN_CURLY_TOKEN StreamBlockJob *s; s = block_job_create([[job_id]], &stream_job_driver, bs, speed, cb, opaque, errp); if (!s) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN s-GREATER_TOKENbase = [[base]]; s-GREATER_TOKENbacking_file_str = g_strdup(backing_file_str); s-GREATER_TOKENon_error = on_error; s-GREATER_TOKENcommon.co = qemu_coroutine_create(stream_run); trace_stream_start(bs, [[base]], s, s-GREATER_TOKENcommon.co, opaque); qemu_coroutine_enter(s-GREATER_TOKENcommon.co, s); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void stream_start(const char *[[newborns]], BlockDriverState *bs, BlockDriverState *[[basanti]], const char *backing_file_str, int64_t speed, BlockdevOnError on_error, BlockCompletionFunc *cb, void *opaque, Error **errp) OPEN_CURLY_TOKEN StreamBlockJob *s; s = block_job_create([[newborns]], &stream_job_driver, bs, speed, cb, opaque, errp); if (!s) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN s-GREATER_TOKENbase = [[basanti]]; s-GREATER_TOKENbacking_file_str = g_strdup(backing_file_str); s-GREATER_TOKENon_error = on_error; s-GREATER_TOKENcommon.co = qemu_coroutine_create(stream_run); trace_stream_start(bs, [[basanti]], s, s-GREATER_TOKENcommon.co, opaque); qemu_coroutine_enter(s-GREATER_TOKENcommon.co, s); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 53 ---------------------------------------------
[[0 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: START_TEST(qint_get_int_test) OPEN_CURLY_TOKEN QInt *[[qi]]; const int [[value]] = 123456; [[qi]] = qint_from_int([[value]]); fail_unless(qint_get_int([[qi]]) == [[value]]); QDECREF([[qi]]); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: START_TEST(qint_get_int_test) OPEN_CURLY_TOKEN QInt *[[gallops]]; const int [[pinpoint]] = 123456; [[gallops]] = qint_from_int([[pinpoint]]); fail_unless(qint_get_int([[gallops]]) == [[pinpoint]]); QDECREF([[gallops]]); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 54 ---------------------------------------------
[[1 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int read_major_sync(MLPDecodeContext *[[m]], GetBitContext *[[gb]]) OPEN_CURLY_TOKEN MLPHeaderInfo [[mh]]; int [[substr]], ret; if ((ret = ff_mlp_read_major_sync([[m]]-GREATER_TOKENavctx, &[[mh]], [[gb]])) != 0) return ret; if ([[mh]].group1_bits == 0) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n"); return AVERROR_INVALIDDATA; if ([[mh]].group2_bits GREATER_TOKEN [[mh]].group1_bits) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Channel group 2 cannot have more bits per sample than group 1.\n"); return AVERROR_INVALIDDATA; if ([[mh]].group2_samplerate && [[mh]].group2_samplerate != [[mh]].group1_samplerate) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Channel groups with differing sample rates are not currently supported.\n"); return AVERROR_INVALIDDATA; if ([[mh]].group1_samplerate == 0) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n"); return AVERROR_INVALIDDATA; if ([[mh]].group1_samplerate GREATER_TOKEN MAX_SAMPLERATE) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Sampling rate %d is greater than the supported maximum (%d).\n", [[mh]].group1_samplerate, MAX_SAMPLERATE); return AVERROR_INVALIDDATA; if ([[mh]].access_unit_size GREATER_TOKEN MAX_BLOCKSIZE) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Block size %d is greater than the supported maximum (%d).\n", [[mh]].access_unit_size, MAX_BLOCKSIZE); return AVERROR_INVALIDDATA; if ([[mh]].access_unit_size_pow2 GREATER_TOKEN MAX_BLOCKSIZE_POW2) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Block size pow2 %d is greater than the supported maximum (%d).\n", [[mh]].access_unit_size_pow2, MAX_BLOCKSIZE_POW2); return AVERROR_INVALIDDATA; if ([[mh]].num_substreams == 0) return AVERROR_INVALIDDATA; if ([[m]]-GREATER_TOKENavctx-GREATER_TOKENcodec_id == AV_CODEC_ID_MLP && [[mh]].num_substreams GREATER_TOKEN 2) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n"); return AVERROR_INVALIDDATA; if ([[mh]].num_substreams GREATER_TOKEN MAX_SUBSTREAMS) OPEN_CURLY_TOKEN "%d substreams (more than the " "maximum supported by the decoder)", [[mh]].num_substreams); [[m]]-GREATER_TOKENaccess_unit_size = [[mh]].access_unit_size; [[m]]-GREATER_TOKENaccess_unit_size_pow2 = [[mh]].access_unit_size_pow2; [[m]]-GREATER_TOKENnum_substreams = [[mh]].num_substreams; [[m]]-GREATER_TOKENmax_decoded_substream = [[m]]-GREATER_TOKENnum_substreams - 1; [[m]]-GREATER_TOKENavctx-GREATER_TOKENsample_rate = [[mh]].group1_samplerate; [[m]]-GREATER_TOKENavctx-GREATER_TOKENframe_size = [[mh]].access_unit_size; [[m]]-GREATER_TOKENavctx-GREATER_TOKENbits_per_raw_sample = [[mh]].group1_bits; if ([[mh]].group1_bits GREATER_TOKEN 16) [[m]]-GREATER_TOKENavctx-GREATER_TOKENsample_fmt = AV_SAMPLE_FMT_S32; else [[m]]-GREATER_TOKENavctx-GREATER_TOKENsample_fmt = AV_SAMPLE_FMT_S16; [[m]]-GREATER_TOKENparams_valid = 1; for ([[substr]] = 0; [[substr]] SMALLER_TOKEN MAX_SUBSTREAMS; [[substr]]++) [[m]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN[[substr]]CLOSE_SQUARE_TOKEN.restart_seen = 0; if ([[m]]-GREATER_TOKENavctx-GREATER_TOKENcodec_id == AV_CODEC_ID_MLP) OPEN_CURLY_TOKEN if (([[substr]] = ([[mh]].num_substreams GREATER_TOKEN 1))) [[m]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ch_layout = AV_CH_LAYOUT_STEREO; [[m]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN[[substr]]CLOSE_SQUARE_TOKEN.ch_layout = [[mh]].channel_layout_mlp; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (([[substr]] = ([[mh]].num_substreams GREATER_TOKEN 1))) [[m]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ch_layout = AV_CH_LAYOUT_STEREO; if ([[mh]].num_substreams GREATER_TOKEN 2) if ([[mh]].channel_layout_thd_stream2) [[m]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN.ch_layout = [[mh]].channel_layout_thd_stream2; else [[m]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN.ch_layout = [[mh]].channel_layout_thd_stream1; [[m]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN[[substr]]CLOSE_SQUARE_TOKEN.ch_layout = [[mh]].channel_layout_thd_stream1; if ([[m]]-GREATER_TOKENavctx-GREATER_TOKENchannelsSMALLER_TOKEN=2 && [[m]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN[[substr]]CLOSE_SQUARE_TOKEN.ch_layout == AV_CH_LAYOUT_MONO && [[m]]-GREATER_TOKENmax_decoded_substream == 1) OPEN_CURLY_TOKEN av_log([[m]]-GREATER_TOKENavctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n"); [[m]]-GREATER_TOKENmax_decoded_substream = 0; if ([[m]]-GREATER_TOKENavctx-GREATER_TOKENchannels==2) [[m]]-GREATER_TOKENavctx-GREATER_TOKENchannel_layout = AV_CH_LAYOUT_STEREO; [[m]]-GREATER_TOKENneeds_reordering = [[mh]].channel_arrangement GREATER_TOKEN= 18 && [[mh]].channel_arrangement SMALLER_TOKEN= 20; return 0;

[[[[Adv]]]]: static int read_major_sync(MLPDecodeContext *[[erp]], GetBitContext *[[stormtrooper]]) OPEN_CURLY_TOKEN MLPHeaderInfo [[emphasized]]; int [[jacqueline]], ret; if ((ret = ff_mlp_read_major_sync([[erp]]-GREATER_TOKENavctx, &[[emphasized]], [[stormtrooper]])) != 0) return ret; if ([[emphasized]].group1_bits == 0) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n"); return AVERROR_INVALIDDATA; if ([[emphasized]].group2_bits GREATER_TOKEN [[emphasized]].group1_bits) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Channel group 2 cannot have more bits per sample than group 1.\n"); return AVERROR_INVALIDDATA; if ([[emphasized]].group2_samplerate && [[emphasized]].group2_samplerate != [[emphasized]].group1_samplerate) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Channel groups with differing sample rates are not currently supported.\n"); return AVERROR_INVALIDDATA; if ([[emphasized]].group1_samplerate == 0) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n"); return AVERROR_INVALIDDATA; if ([[emphasized]].group1_samplerate GREATER_TOKEN MAX_SAMPLERATE) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Sampling rate %d is greater than the supported maximum (%d).\n", [[emphasized]].group1_samplerate, MAX_SAMPLERATE); return AVERROR_INVALIDDATA; if ([[emphasized]].access_unit_size GREATER_TOKEN MAX_BLOCKSIZE) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Block size %d is greater than the supported maximum (%d).\n", [[emphasized]].access_unit_size, MAX_BLOCKSIZE); return AVERROR_INVALIDDATA; if ([[emphasized]].access_unit_size_pow2 GREATER_TOKEN MAX_BLOCKSIZE_POW2) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Block size pow2 %d is greater than the supported maximum (%d).\n", [[emphasized]].access_unit_size_pow2, MAX_BLOCKSIZE_POW2); return AVERROR_INVALIDDATA; if ([[emphasized]].num_substreams == 0) return AVERROR_INVALIDDATA; if ([[erp]]-GREATER_TOKENavctx-GREATER_TOKENcodec_id == AV_CODEC_ID_MLP && [[emphasized]].num_substreams GREATER_TOKEN 2) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n"); return AVERROR_INVALIDDATA; if ([[emphasized]].num_substreams GREATER_TOKEN MAX_SUBSTREAMS) OPEN_CURLY_TOKEN "%d substreams (more than the " "maximum supported by the decoder)", [[emphasized]].num_substreams); [[erp]]-GREATER_TOKENaccess_unit_size = [[emphasized]].access_unit_size; [[erp]]-GREATER_TOKENaccess_unit_size_pow2 = [[emphasized]].access_unit_size_pow2; [[erp]]-GREATER_TOKENnum_substreams = [[emphasized]].num_substreams; [[erp]]-GREATER_TOKENmax_decoded_substream = [[erp]]-GREATER_TOKENnum_substreams - 1; [[erp]]-GREATER_TOKENavctx-GREATER_TOKENsample_rate = [[emphasized]].group1_samplerate; [[erp]]-GREATER_TOKENavctx-GREATER_TOKENframe_size = [[emphasized]].access_unit_size; [[erp]]-GREATER_TOKENavctx-GREATER_TOKENbits_per_raw_sample = [[emphasized]].group1_bits; if ([[emphasized]].group1_bits GREATER_TOKEN 16) [[erp]]-GREATER_TOKENavctx-GREATER_TOKENsample_fmt = AV_SAMPLE_FMT_S32; else [[erp]]-GREATER_TOKENavctx-GREATER_TOKENsample_fmt = AV_SAMPLE_FMT_S16; [[erp]]-GREATER_TOKENparams_valid = 1; for ([[jacqueline]] = 0; [[jacqueline]] SMALLER_TOKEN MAX_SUBSTREAMS; [[jacqueline]]++) [[erp]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN[[jacqueline]]CLOSE_SQUARE_TOKEN.restart_seen = 0; if ([[erp]]-GREATER_TOKENavctx-GREATER_TOKENcodec_id == AV_CODEC_ID_MLP) OPEN_CURLY_TOKEN if (([[jacqueline]] = ([[emphasized]].num_substreams GREATER_TOKEN 1))) [[erp]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ch_layout = AV_CH_LAYOUT_STEREO; [[erp]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN[[jacqueline]]CLOSE_SQUARE_TOKEN.ch_layout = [[emphasized]].channel_layout_mlp; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (([[jacqueline]] = ([[emphasized]].num_substreams GREATER_TOKEN 1))) [[erp]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ch_layout = AV_CH_LAYOUT_STEREO; if ([[emphasized]].num_substreams GREATER_TOKEN 2) if ([[emphasized]].channel_layout_thd_stream2) [[erp]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN.ch_layout = [[emphasized]].channel_layout_thd_stream2; else [[erp]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN.ch_layout = [[emphasized]].channel_layout_thd_stream1; [[erp]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN[[jacqueline]]CLOSE_SQUARE_TOKEN.ch_layout = [[emphasized]].channel_layout_thd_stream1; if ([[erp]]-GREATER_TOKENavctx-GREATER_TOKENchannelsSMALLER_TOKEN=2 && [[erp]]-GREATER_TOKENsubstreamOPEN_SQUARE_TOKEN[[jacqueline]]CLOSE_SQUARE_TOKEN.ch_layout == AV_CH_LAYOUT_MONO && [[erp]]-GREATER_TOKENmax_decoded_substream == 1) OPEN_CURLY_TOKEN av_log([[erp]]-GREATER_TOKENavctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n"); [[erp]]-GREATER_TOKENmax_decoded_substream = 0; if ([[erp]]-GREATER_TOKENavctx-GREATER_TOKENchannels==2) [[erp]]-GREATER_TOKENavctx-GREATER_TOKENchannel_layout = AV_CH_LAYOUT_STEREO; [[erp]]-GREATER_TOKENneeds_reordering = [[emphasized]].channel_arrangement GREATER_TOKEN= 18 && [[emphasized]].channel_arrangement SMALLER_TOKEN= 20; return 0;[Succeeded / Failed / Skipped / Total] 17 / 10 / 27 / 54:   2%|         | 54/2690 [00:00<00:01, 2539.52it/s][Succeeded / Failed / Skipped / Total] 17 / 11 / 27 / 55:   2%|         | 55/2690 [00:00<00:01, 2543.94it/s][Succeeded / Failed / Skipped / Total] 18 / 11 / 27 / 56:   2%|         | 56/2690 [00:00<00:01, 2538.95it/s][Succeeded / Failed / Skipped / Total] 19 / 11 / 27 / 57:   2%|         | 57/2690 [00:00<00:01, 2515.92it/s]
--------------------------------------------- Result 55 ---------------------------------------------
[[0 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int floatx80_eq(floatx80 [[a]], floatx80 [[b]], float_status *status) OPEN_CURLY_TOKEN if ( ( ( extractFloatx80Exp( [[a]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[a]] )SMALLER_TOKENSMALLER_TOKEN1 ) ) || ( ( extractFloatx80Exp( [[b]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[b]] )SMALLER_TOKENSMALLER_TOKEN1 ) ) ) OPEN_CURLY_TOKEN float_raise(float_flag_invalid, status); return 0; CLOSE_CURLY_TOKEN return ( [[a]].low == [[b]].low ) && ( ( [[a]].high == [[b]].high ) || ( ( [[a]].low == 0 ) && ( (uint16_t) ( ( [[a]].high | [[b]].high )SMALLER_TOKENSMALLER_TOKEN1 ) == 0 ) ) ); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int floatx80_eq(floatx80 [[risers]], floatx80 [[immemorial]], float_status *status) OPEN_CURLY_TOKEN if ( ( ( extractFloatx80Exp( [[risers]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[risers]] )SMALLER_TOKENSMALLER_TOKEN1 ) ) || ( ( extractFloatx80Exp( [[immemorial]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[immemorial]] )SMALLER_TOKENSMALLER_TOKEN1 ) ) ) OPEN_CURLY_TOKEN float_raise(float_flag_invalid, status); return 0; CLOSE_CURLY_TOKEN return ( [[risers]].low == [[immemorial]].low ) && ( ( [[risers]].high == [[immemorial]].high ) || ( ( [[risers]].low == 0 ) && ( (uint16_t) ( ( [[risers]].high | [[immemorial]].high )SMALLER_TOKENSMALLER_TOKEN1 ) == 0 ) ) ); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 56 ---------------------------------------------
[[0 (84%)]] --> [[1 (55%)]] --> Socre: 0.5520939826965332

[[[[Adv]]]]: static char *enumerate_cpus(unsigned long *cpus, int max_cpus) OPEN_CURLY_TOKEN int [[cpu]]; bool first = "[[True]]" == "[[True]]"; GString *[[s]] = g_string_new(NULL); for ([[cpu]] = find_first_bit(cpus, max_cpus); [[cpu]] SMALLER_TOKEN max_cpus; [[cpu]] = find_next_bit(cpus, max_cpus, [[cpu]] + 1)) OPEN_CURLY_TOKEN g_string_append_printf([[s]], "%s%d", first ? "" : " ", [[cpu]]); first = "False" != "False"; CLOSE_CURLY_TOKEN return g_string_free([[s]], "[[False]]" != "[[False]]"); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static char *enumerate_cpus(unsigned long *cpus, int max_cpus) OPEN_CURLY_TOKEN int [[sabbatical]]; bool first = "[[Loudspeakers]]" == "[[Loudspeakers]]"; GString *[[downstream]] = g_string_new(NULL); for ([[sabbatical]] = find_first_bit(cpus, max_cpus); [[sabbatical]] SMALLER_TOKEN max_cpus; [[sabbatical]] = find_next_bit(cpus, max_cpus, [[sabbatical]] + 1)) OPEN_CURLY_TOKEN g_string_append_printf([[downstream]], "%s%d", first ? "" : " ", [[sabbatical]]); first = "False" != "False"; CLOSE_CURLY_TOKEN return g_string_free([[downstream]], "[[Overtakes]]" != "[[Overtakes]]"); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 57 ---------------------------------------------
[[1 (91%)]] --> [[0 (52%)]] --> Socre: 0.5213578939437866

[[[[Adv]]]]: static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx, CodedBitstreamUnit *unit) OPEN_CURLY_TOKEN BitstreamContext [[bc]]; int err; err = bitstream_init(&[[bc]], unit-GREATER_TOKENdata, 8 * unit-GREATER_TOKENdata_size); if (err SMALLER_TOKEN 0) return err; switch (unit-GREATER_TOKENtype) OPEN_CURLY_TOKEN case HEVC_NAL_VPS: OPEN_CURLY_TOKEN H265RawVPS *vps; vps = av_mallocz(sizeof(*vps)); if (!vps) return AVERROR(ENOMEM); err = cbs_h265_read_vps(ctx, &[[bc]], vps); if (err GREATER_TOKEN= 0) err = cbs_h265_replace_vps(ctx, vps); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(vps); return err; CLOSE_CURLY_TOKEN unit-GREATER_TOKENcontent = vps; CLOSE_CURLY_TOKEN break; case HEVC_NAL_SPS: OPEN_CURLY_TOKEN H265RawSPS *sps; sps = av_mallocz(sizeof(*sps)); if (!sps) return AVERROR(ENOMEM); err = cbs_h265_read_sps(ctx, &[[bc]], sps); if (err GREATER_TOKEN= 0) err = cbs_h265_replace_sps(ctx, sps); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(sps); return err; CLOSE_CURLY_TOKEN unit-GREATER_TOKENcontent = sps; CLOSE_CURLY_TOKEN break; case HEVC_NAL_PPS: OPEN_CURLY_TOKEN H265RawPPS *pps; pps = av_mallocz(sizeof(*pps)); if (!pps) return AVERROR(ENOMEM); err = cbs_h265_read_pps(ctx, &[[bc]], pps); if (err GREATER_TOKEN= 0) err = cbs_h265_replace_pps(ctx, pps); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(pps); return err; CLOSE_CURLY_TOKEN unit-GREATER_TOKENcontent = pps; CLOSE_CURLY_TOKEN break; case HEVC_NAL_TRAIL_N: case HEVC_NAL_TRAIL_R: case HEVC_NAL_TSA_N: case HEVC_NAL_TSA_R: case HEVC_NAL_STSA_N: case HEVC_NAL_STSA_R: case HEVC_NAL_RADL_N: case HEVC_NAL_RADL_R: case HEVC_NAL_RASL_N: case HEVC_NAL_RASL_R: case HEVC_NAL_BLA_W_LP: case HEVC_NAL_BLA_W_RADL: case HEVC_NAL_BLA_N_LP: case HEVC_NAL_IDR_W_RADL: case HEVC_NAL_IDR_N_LP: case HEVC_NAL_CRA_NUT: OPEN_CURLY_TOKEN H265RawSlice *slice; int pos, len; slice = av_mallocz(sizeof(*slice)); if (!slice) return AVERROR(ENOMEM); err = cbs_h265_read_slice_segment_header(ctx, &[[bc]], &slice-GREATER_TOKENheader); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(slice); return err; CLOSE_CURLY_TOKEN pos = bitstream_tell(&[[bc]]); len = unit-GREATER_TOKENdata_size; if (!unit-GREATER_TOKENdataOPEN_SQUARE_TOKENlen - 1CLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN int z; for (z = 0; z SMALLER_TOKEN len && !unit-GREATER_TOKENdataOPEN_SQUARE_TOKENlen - z - 1CLOSE_SQUARE_TOKEN; z++); av_log(ctx-GREATER_TOKENlog_ctx, AV_LOG_DEBUG, "Deleted %d trailing zeroes " "from slice data.\n", z); len -= z; CLOSE_CURLY_TOKEN slice-GREATER_TOKENdata_size = len - pos / 8; slice-GREATER_TOKENdata = av_malloc(slice-GREATER_TOKENdata_size); if (!slice-GREATER_TOKENdata) OPEN_CURLY_TOKEN av_free(slice); return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN memcpy(slice-GREATER_TOKENdata, unit-GREATER_TOKENdata + pos / 8, slice-GREATER_TOKENdata_size); slice-GREATER_TOKENdata_bit_start = pos % 8; unit-GREATER_TOKENcontent = slice; CLOSE_CURLY_TOKEN break; case HEVC_NAL_AUD: OPEN_CURLY_TOKEN H265RawAUD *aud; aud = av_mallocz(sizeof(*aud)); if (!aud) return AVERROR(ENOMEM); err = cbs_h265_read_aud(ctx, &[[bc]], aud); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(aud); return err; CLOSE_CURLY_TOKEN unit-GREATER_TOKENcontent = aud; CLOSE_CURLY_TOKEN break; default: return AVERROR(ENOSYS); CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx, CodedBitstreamUnit *unit) OPEN_CURLY_TOKEN BitstreamContext [[cola]]; int err; err = bitstream_init(&[[cola]], unit-GREATER_TOKENdata, 8 * unit-GREATER_TOKENdata_size); if (err SMALLER_TOKEN 0) return err; switch (unit-GREATER_TOKENtype) OPEN_CURLY_TOKEN case HEVC_NAL_VPS: OPEN_CURLY_TOKEN H265RawVPS *vps; vps = av_mallocz(sizeof(*vps)); if (!vps) return AVERROR(ENOMEM); err = cbs_h265_read_vps(ctx, &[[cola]], vps); if (err GREATER_TOKEN= 0) err = cbs_h265_replace_vps(ctx, vps); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(vps); return err; CLOSE_CURLY_TOKEN unit-GREATER_TOKENcontent = vps; CLOSE_CURLY_TOKEN break; case HEVC_NAL_SPS: OPEN_CURLY_TOKEN H265RawSPS *sps; sps = av_mallocz(sizeof(*sps)); if (!sps) return AVERROR(ENOMEM); err = cbs_h265_read_sps(ctx, &[[cola]], sps); if (err GREATER_TOKEN= 0) err = cbs_h265_replace_sps(ctx, sps); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(sps); return err; CLOSE_CURLY_TOKEN unit-GREATER_TOKENcontent = sps; CLOSE_CURLY_TOKEN break; case HEVC_NAL_PPS: OPEN_CURLY_TOKEN H265RawPPS *pps; pps = av_mallocz(sizeof(*pps)); if (!pps) return AVERROR(ENOMEM); err = cbs_h265_read_pps(ctx, &[[cola]], pps); if (err GREATER_TOKEN= 0) err = cbs_h265_replace_pps(ctx, pps); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(pps); return err; CLOSE_CURLY_TOKEN unit-GREATER_TOKENcontent = pps; CLOSE_CURLY_TOKEN break; case HEVC_NAL_TRAIL_N: case HEVC_NAL_TRAIL_R: case HEVC_NAL_TSA_N: case HEVC_NAL_TSA_R: case HEVC_NAL_STSA_N: case HEVC_NAL_STSA_R: case HEVC_NAL_RADL_N: case HEVC_NAL_RADL_R: case HEVC_NAL_RASL_N: case HEVC_NAL_RASL_R: case HEVC_NAL_BLA_W_LP: case HEVC_NAL_BLA_W_RADL: case HEVC_NAL_BLA_N_LP: case HEVC_NAL_IDR_W_RADL: case HEVC_NAL_IDR_N_LP: case HEVC_NAL_CRA_NUT: OPEN_CURLY_TOKEN H265RawSlice *slice; int pos, len; slice = av_mallocz(sizeof(*slice)); if (!slice) return AVERROR(ENOMEM); err = cbs_h265_read_slice_segment_header(ctx, &[[cola]], &slice-GREATER_TOKENheader); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(slice); return err; CLOSE_CURLY_TOKEN pos = bitstream_tell(&[[cola]]); len = unit-GREATER_TOKENdata_size; if (!unit-GREATER_TOKENdataOPEN_SQUARE_TOKENlen - 1CLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN int z; for (z = 0; z SMALLER_TOKEN len && !unit-GREATER_TOKENdataOPEN_SQUARE_TOKENlen - z - 1CLOSE_SQUARE_TOKEN; z++); av_log(ctx-GREATER_TOKENlog_ctx, AV_LOG_DEBUG, "Deleted %d trailing zeroes " "from slice data.\n", z); len -= z; CLOSE_CURLY_TOKEN slice-GREATER_TOKENdata_size = len - pos / 8; slice-GREATER_TOKENdata = av_malloc(slice-GREATER_TOKENdata_size); if (!slice-GREATER_TOKENdata) OPEN_CURLY_TOKEN av_free(slice); return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN memcpy(slice-GREATER_TOKENdata, unit-GREATER_TOKENdata + pos / 8, slice-GREATER_TOKENdata_size); slice-GREATER_TOKENdata_bit_start = pos % 8; unit-GREATER_TOKENcontent = slice; CLOSE_CURLY_TOKEN break; case HEVC_NAL_AUD: OPEN_CURLY_TOKEN H265RawAUD *aud; aud = av_mallocz(sizeof(*aud)); if (!aud) return AVERROR(ENOMEM); err = cbs_h265_read_aud(ctx, &[[cola]], aud); if (err SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_free(aud); return err; CLOSE_CURLY_TOKEN unit-GREATER_TOKENcontent = aud; CLOSE_CURLY_TOKEN break; default: return AVERROR(ENOSYS); CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 58 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 11 / 27 / 58:   2%|         | 58/2690 [00:00<00:01, 2517.07it/s][Succeeded / Failed / Skipped / Total] 21 / 11 / 27 / 59:   2%|         | 59/2690 [00:00<00:01, 2516.34it/s][Succeeded / Failed / Skipped / Total] 21 / 11 / 28 / 60:   2%|         | 60/2690 [00:00<00:01, 2538.69it/s][Succeeded / Failed / Skipped / Total] 22 / 11 / 28 / 61:   2%|         | 61/2690 [00:00<00:01, 2530.36it/s][[0 (82%)]] --> [[1 (53%)]] --> Socre: 0.5323007702827454

[[[[Adv]]]]: static void fpu_init (CPUMIPSState *env, const mips_def_t *def) OPEN_CURLY_TOKEN int [[i]]; for ([[i]] = 0; [[i]] SMALLER_TOKEN MIPS_FPU_MAX; [[i]]++) env-GREATER_TOKENfpusOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN.fcr0 = def-GREATER_TOKENCP1_fcr0; memcpy(&env-GREATER_TOKENactive_fpu, &env-GREATER_TOKENfpusOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, sizeof(env-GREATER_TOKENactive_fpu)); if (env-GREATER_TOKENuser_mode_only) OPEN_CURLY_TOKEN if (env-GREATER_TOKENCP0_Config1 & (1 SMALLER_TOKENSMALLER_TOKEN CP0C1_FP)) env-GREATER_TOKENhflags |= MIPS_HFLAG_FPU; #ifdef TARGET_MIPS64 if (env-GREATER_TOKENactive_fpu.fcr0 & (1 SMALLER_TOKENSMALLER_TOKEN FCR0_F64)) env-GREATER_TOKENhflags |= MIPS_HFLAG_F64; #endif CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void fpu_init (CPUMIPSState *env, const mips_def_t *def) OPEN_CURLY_TOKEN int [[windshield]]; for ([[windshield]] = 0; [[windshield]] SMALLER_TOKEN MIPS_FPU_MAX; [[windshield]]++) env-GREATER_TOKENfpusOPEN_SQUARE_TOKEN[[windshield]]CLOSE_SQUARE_TOKEN.fcr0 = def-GREATER_TOKENCP1_fcr0; memcpy(&env-GREATER_TOKENactive_fpu, &env-GREATER_TOKENfpusOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, sizeof(env-GREATER_TOKENactive_fpu)); if (env-GREATER_TOKENuser_mode_only) OPEN_CURLY_TOKEN if (env-GREATER_TOKENCP0_Config1 & (1 SMALLER_TOKENSMALLER_TOKEN CP0C1_FP)) env-GREATER_TOKENhflags |= MIPS_HFLAG_FPU; #ifdef TARGET_MIPS64 if (env-GREATER_TOKENactive_fpu.fcr0 & (1 SMALLER_TOKENSMALLER_TOKEN FCR0_F64)) env-GREATER_TOKENhflags |= MIPS_HFLAG_F64; #endif CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 59 ---------------------------------------------
[[0 (89%)]] --> [[1 (66%)]] --> Socre: 0.6600576639175415

[[[[Adv]]]]: static void test_qemu_strtoull_overflow(void) OPEN_CURLY_TOKEN const char *[[str]] = "99999999999999999999999999999999999999999999"; char [[f]] = 'X'; const char *[[endptr]] = &[[f]]; uint64_t [[res]] = 999; int err; err = qemu_strtoull([[str]], &[[endptr]], 0, &[[res]]); g_assert_cmpint(err, ==, -ERANGE); g_assert_cmpint([[res]], ==, ULLONG_MAX); g_assert([[endptr]] == [[str]] + strlen([[str]])); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void test_qemu_strtoull_overflow(void) OPEN_CURLY_TOKEN const char *[[bertolucci]] = "99999999999999999999999999999999999999999999"; char [[repayment]] = 'X'; const char *[[effectively]] = &[[repayment]]; uint64_t [[beaumont]] = 999; int err; err = qemu_strtoull([[bertolucci]], &[[effectively]], 0, &[[beaumont]]); g_assert_cmpint(err, ==, -ERANGE); g_assert_cmpint([[beaumont]], ==, ULLONG_MAX); g_assert([[effectively]] == [[bertolucci]] + strlen([[bertolucci]])); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 60 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qpa_audio_fini (void *opaque) OPEN_CURLY_TOKEN (void) opaque; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 61 ---------------------------------------------
[[0 (98%)]] --> [[1 (74%)]] --> Socre: 0.7446870803833008

[[[[Adv]]]]: static void slavio_timer_mem_writel(void *[[opaque]], target_phys_addr_t addr, uint32_t [[val]]) OPEN_CURLY_TOKEN SLAVIO_TIMERState *s = [[opaque]]; uint32_t saddr; int reload = 0; DPRINTF("write " TARGET_FMT_plx " %08x\n", addr, [[val]]); saddr = (addr & TIMER_MAXADDR) GREATER_TOKENGREATER_TOKEN 2; switch (saddr) OPEN_CURLY_TOKEN case TIMER_LIMIT: if (slavio_timer_is_user(s)) OPEN_CURLY_TOKEN qemu_irq_lower(s-GREATER_TOKENirq); s-GREATER_TOKENlimit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s-GREATER_TOKENslave_index); ptimer_set_limit(s-GREATER_TOKENtimer, LIMIT_TO_PERIODS(s-GREATER_TOKENlimit), 1); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN qemu_irq_lower(s-GREATER_TOKENirq); s-GREATER_TOKENlimit = [[val]] & TIMER_MAX_COUNT32; if (!s-GREATER_TOKENlimit) s-GREATER_TOKENlimit = TIMER_MAX_COUNT32; ptimer_set_limit(s-GREATER_TOKENtimer, s-GREATER_TOKENlimit GREATER_TOKENGREATER_TOKEN 9, 1); CLOSE_CURLY_TOKEN break; case TIMER_COUNTER: if (slavio_timer_is_user(s)) OPEN_CURLY_TOKEN qemu_irq_lower(s-GREATER_TOKENirq); s-GREATER_TOKENlimit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s-GREATER_TOKENslave_index); ptimer_set_limit(s-GREATER_TOKENtimer, LIMIT_TO_PERIODS(s-GREATER_TOKENlimit), 1); CLOSE_CURLY_TOKEN else DPRINTF("not user timer\n"); break; case TIMER_COUNTER_NORST: s-GREATER_TOKENlimit = [[val]] & TIMER_MAX_COUNT32; if (!s-GREATER_TOKENlimit) s-GREATER_TOKENlimit = TIMER_MAX_COUNT32; ptimer_set_limit(s-GREATER_TOKENtimer, LIMIT_TO_PERIODS(s-GREATER_TOKENlimit), reload); break; case TIMER_STATUS: if (slavio_timer_is_user(s)) OPEN_CURLY_TOKEN if (([[val]] & 1) && !s-GREATER_TOKENrunning) OPEN_CURLY_TOKEN DPRINTF("processor %d user timer started\n", s-GREATER_TOKENslave_index); ptimer_run(s-GREATER_TOKENtimer, 0); s-GREATER_TOKENrunning = 1; CLOSE_CURLY_TOKEN else if (!([[val]] & 1) && s-GREATER_TOKENrunning) OPEN_CURLY_TOKEN DPRINTF("processor %d user timer stopped\n", s-GREATER_TOKENslave_index); ptimer_stop(s-GREATER_TOKENtimer); s-GREATER_TOKENrunning = 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case TIMER_MODE: if (s-GREATER_TOKENmaster == NULL) OPEN_CURLY_TOKEN unsigned int i; for (i = 0; i SMALLER_TOKEN s-GREATER_TOKENnum_slaves; i++) OPEN_CURLY_TOKEN if ([[val]] & (1 SMALLER_TOKENSMALLER_TOKEN i)) OPEN_CURLY_TOKEN qemu_irq_lower(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENirq); s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENlimit = -1ULL; CLOSE_CURLY_TOKEN if (([[val]] & (1 SMALLER_TOKENSMALLER_TOKEN i)) != (s-GREATER_TOKENslave_mode & (1 SMALLER_TOKENSMALLER_TOKEN i))) OPEN_CURLY_TOKEN ptimer_stop(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENtimer); ptimer_set_limit(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENtimer, LIMIT_TO_PERIODS(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENlimit), 1); DPRINTF("processor %d timer changed\n", s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENslave_index); ptimer_run(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENtimer, 0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN s-GREATER_TOKENslave_mode = [[val]] & ((1 SMALLER_TOKENSMALLER_TOKEN s-GREATER_TOKENnum_slaves) - 1); CLOSE_CURLY_TOKEN else DPRINTF("not system timer\n"); break; default: DPRINTF("invalid write address " TARGET_FMT_plx "\n", addr); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void slavio_timer_mem_writel(void *[[thatl]], target_phys_addr_t addr, uint32_t [[sellers]]) OPEN_CURLY_TOKEN SLAVIO_TIMERState *s = [[thatl]]; uint32_t saddr; int reload = 0; DPRINTF("write " TARGET_FMT_plx " %08x\n", addr, [[sellers]]); saddr = (addr & TIMER_MAXADDR) GREATER_TOKENGREATER_TOKEN 2; switch (saddr) OPEN_CURLY_TOKEN case TIMER_LIMIT: if (slavio_timer_is_user(s)) OPEN_CURLY_TOKEN qemu_irq_lower(s-GREATER_TOKENirq); s-GREATER_TOKENlimit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s-GREATER_TOKENslave_index); ptimer_set_limit(s-GREATER_TOKENtimer, LIMIT_TO_PERIODS(s-GREATER_TOKENlimit), 1); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN qemu_irq_lower(s-GREATER_TOKENirq); s-GREATER_TOKENlimit = [[sellers]] & TIMER_MAX_COUNT32; if (!s-GREATER_TOKENlimit) s-GREATER_TOKENlimit = TIMER_MAX_COUNT32; ptimer_set_limit(s-GREATER_TOKENtimer, s-GREATER_TOKENlimit GREATER_TOKENGREATER_TOKEN 9, 1); CLOSE_CURLY_TOKEN break; case TIMER_COUNTER: if (slavio_timer_is_user(s)) OPEN_CURLY_TOKEN qemu_irq_lower(s-GREATER_TOKENirq); s-GREATER_TOKENlimit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s-GREATER_TOKENslave_index); ptimer_set_limit(s-GREATER_TOKENtimer, LIMIT_TO_PERIODS(s-GREATER_TOKENlimit), 1); CLOSE_CURLY_TOKEN else DPRINTF("not user timer\n"); break; case TIMER_COUNTER_NORST: s-GREATER_TOKENlimit = [[sellers]] & TIMER_MAX_COUNT32; if (!s-GREATER_TOKENlimit) s-GREATER_TOKENlimit = TIMER_MAX_COUNT32; ptimer_set_limit(s-GREATER_TOKENtimer, LIMIT_TO_PERIODS(s-GREATER_TOKENlimit), reload); break; case TIMER_STATUS: if (slavio_timer_is_user(s)) OPEN_CURLY_TOKEN if (([[sellers]] & 1) && !s-GREATER_TOKENrunning) OPEN_CURLY_TOKEN DPRINTF("processor %d user timer started\n", s-GREATER_TOKENslave_index); ptimer_run(s-GREATER_TOKENtimer, 0); s-GREATER_TOKENrunning = 1; CLOSE_CURLY_TOKEN else if (!([[sellers]] & 1) && s-GREATER_TOKENrunning) OPEN_CURLY_TOKEN DPRINTF("processor %d user timer stopped\n", s-GREATER_TOKENslave_index); ptimer_stop(s-GREATER_TOKENtimer); s-GREATER_TOKENrunning = 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN break; case TIMER_MODE: if (s-GREATER_TOKENmaster == NULL) OPEN_CURLY_TOKEN unsigned int i; for (i = 0; i SMALLER_TOKEN s-GREATER_TOKENnum_slaves; i++) OPEN_CURLY_TOKEN if ([[sellers]] & (1 SMALLER_TOKENSMALLER_TOKEN i)) OPEN_CURLY_TOKEN qemu_irq_lower(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENirq); s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENlimit = -1ULL; CLOSE_CURLY_TOKEN if (([[sellers]] & (1 SMALLER_TOKENSMALLER_TOKEN i)) != (s-GREATER_TOKENslave_mode & (1 SMALLER_TOKENSMALLER_TOKEN i))) OPEN_CURLY_TOKEN ptimer_stop(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENtimer); ptimer_set_limit(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENtimer, LIMIT_TO_PERIODS(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENlimit), 1); DPRINTF("processor %d timer changed\n", s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENslave_index); ptimer_run(s-GREATER_TOKENslaveOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENtimer, 0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN s-GREATER_TOKENslave_mode = [[sellers]] & ((1 SMALLER_TOKENSMALLER_TOKEN s-GREATER_TOKENnum_slaves) - 1); CLOSE_CURLY_TOKEN else DPRINTF("not system timer\n"); break; default: DPRINTF("invalid write address " TARGET_FMT_plx "\n", addr); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 62 ---------------------------------------------
[[1 (65%)]] --> [[0 (50%)]] --> Socre: 0.5002342462539673

[[[[Adv]]]]: static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame, unsigned int c, const unsigned int *[[div_blocks]], unsigned int *js_blocks) OPEN_CURLY_TOKEN ALSSpecificConfig *sconf = &ctx-GREATER_TOKENsconf; unsigned int offset = 0; unsigned int [[b]]; ALSBlockData bdOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN OPEN_CURLY_TOKEN 0 CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ra_block = ra_frame; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.const_block = ctx-GREATER_TOKENconst_block; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.shift_lsbs = ctx-GREATER_TOKENshift_lsbs; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.opt_order = ctx-GREATER_TOKENopt_order; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.store_prev_samples = ctx-GREATER_TOKENstore_prev_samples; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.use_ltp = ctx-GREATER_TOKENuse_ltp; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ltp_lag = ctx-GREATER_TOKENltp_lag; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ltp_gain = ctx-GREATER_TOKENltp_gainOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.quant_cof = ctx-GREATER_TOKENquant_cofOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.lpc_cof = ctx-GREATER_TOKENlpc_cofOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.prev_raw_samples = ctx-GREATER_TOKENprev_raw_samples; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.js_blocks = *js_blocks; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.ra_block = ra_frame; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.const_block = ctx-GREATER_TOKENconst_block; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.shift_lsbs = ctx-GREATER_TOKENshift_lsbs; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.opt_order = ctx-GREATER_TOKENopt_order; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.store_prev_samples = ctx-GREATER_TOKENstore_prev_samples; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.use_ltp = ctx-GREATER_TOKENuse_ltp; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.ltp_lag = ctx-GREATER_TOKENltp_lag; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.ltp_gain = ctx-GREATER_TOKENltp_gainOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.quant_cof = ctx-GREATER_TOKENquant_cofOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.lpc_cof = ctx-GREATER_TOKENlpc_cofOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.prev_raw_samples = ctx-GREATER_TOKENprev_raw_samples; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.js_blocks = *(js_blocks + 1); for ([[b]] = 0; [[b]] SMALLER_TOKEN ctx-GREATER_TOKENnum_blocks; [[b]]++) OPEN_CURLY_TOKEN unsigned int s; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.block_length = [[div_blocks]]OPEN_SQUARE_TOKEN[[b]]CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.block_length = [[div_blocks]]OPEN_SQUARE_TOKEN[[b]]CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samples = ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENc CLOSE_SQUARE_TOKEN + offset; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samples = ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENc + 1CLOSE_SQUARE_TOKEN + offset; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_other = bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samples; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_other = bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samples; if(read_decode_block(ctx, &bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) || read_decode_block(ctx, &bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN)) OPEN_CURLY_TOKEN zero_remaining([[b]], ctx-GREATER_TOKENnum_blocks, [[div_blocks]], bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samples); zero_remaining([[b]], ctx-GREATER_TOKENnum_blocks, [[div_blocks]], bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samples); return -1; CLOSE_CURLY_TOKEN if (bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.js_blocks) OPEN_CURLY_TOKEN if (bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.js_blocks) av_log(ctx-GREATER_TOKENavctx, AV_LOG_WARNING, "Invalid channel pair!\n"); for (s = 0; s SMALLER_TOKEN [[div_blocks]]OPEN_SQUARE_TOKEN[[b]]CLOSE_SQUARE_TOKEN; s++) bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN = bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN - bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN else if (bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.js_blocks) OPEN_CURLY_TOKEN for (s = 0; s SMALLER_TOKEN [[div_blocks]]OPEN_SQUARE_TOKEN[[b]]CLOSE_SQUARE_TOKEN; s++) bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN = bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN + bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN offset += [[div_blocks]]OPEN_SQUARE_TOKEN[[b]]CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ra_block = 0; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.ra_block = 0; CLOSE_CURLY_TOKEN memmove(ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENcCLOSE_SQUARE_TOKEN - sconf-GREATER_TOKENmax_order, ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENcCLOSE_SQUARE_TOKEN - sconf-GREATER_TOKENmax_order + sconf-GREATER_TOKENframe_length, sizeof(*ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENcCLOSE_SQUARE_TOKEN) * sconf-GREATER_TOKENmax_order); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame, unsigned int c, const unsigned int *[[mahogany]], unsigned int *js_blocks) OPEN_CURLY_TOKEN ALSSpecificConfig *sconf = &ctx-GREATER_TOKENsconf; unsigned int offset = 0; unsigned int [[gallon]]; ALSBlockData bdOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN OPEN_CURLY_TOKEN 0 CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ra_block = ra_frame; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.const_block = ctx-GREATER_TOKENconst_block; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.shift_lsbs = ctx-GREATER_TOKENshift_lsbs; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.opt_order = ctx-GREATER_TOKENopt_order; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.store_prev_samples = ctx-GREATER_TOKENstore_prev_samples; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.use_ltp = ctx-GREATER_TOKENuse_ltp; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ltp_lag = ctx-GREATER_TOKENltp_lag; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ltp_gain = ctx-GREATER_TOKENltp_gainOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.quant_cof = ctx-GREATER_TOKENquant_cofOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.lpc_cof = ctx-GREATER_TOKENlpc_cofOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.prev_raw_samples = ctx-GREATER_TOKENprev_raw_samples; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.js_blocks = *js_blocks; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.ra_block = ra_frame; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.const_block = ctx-GREATER_TOKENconst_block; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.shift_lsbs = ctx-GREATER_TOKENshift_lsbs; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.opt_order = ctx-GREATER_TOKENopt_order; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.store_prev_samples = ctx-GREATER_TOKENstore_prev_samples; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.use_ltp = ctx-GREATER_TOKENuse_ltp; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.ltp_lag = ctx-GREATER_TOKENltp_lag; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.ltp_gain = ctx-GREATER_TOKENltp_gainOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.quant_cof = ctx-GREATER_TOKENquant_cofOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.lpc_cof = ctx-GREATER_TOKENlpc_cofOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.prev_raw_samples = ctx-GREATER_TOKENprev_raw_samples; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.js_blocks = *(js_blocks + 1); for ([[gallon]] = 0; [[gallon]] SMALLER_TOKEN ctx-GREATER_TOKENnum_blocks; [[gallon]]++) OPEN_CURLY_TOKEN unsigned int s; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.block_length = [[mahogany]]OPEN_SQUARE_TOKEN[[gallon]]CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.block_length = [[mahogany]]OPEN_SQUARE_TOKEN[[gallon]]CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samples = ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENc CLOSE_SQUARE_TOKEN + offset; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samples = ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENc + 1CLOSE_SQUARE_TOKEN + offset; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_other = bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samples; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_other = bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samples; if(read_decode_block(ctx, &bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) || read_decode_block(ctx, &bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN)) OPEN_CURLY_TOKEN zero_remaining([[gallon]], ctx-GREATER_TOKENnum_blocks, [[mahogany]], bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samples); zero_remaining([[gallon]], ctx-GREATER_TOKENnum_blocks, [[mahogany]], bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samples); return -1; CLOSE_CURLY_TOKEN if (bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.js_blocks) OPEN_CURLY_TOKEN if (bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.js_blocks) av_log(ctx-GREATER_TOKENavctx, AV_LOG_WARNING, "Invalid channel pair!\n"); for (s = 0; s SMALLER_TOKEN [[mahogany]]OPEN_SQUARE_TOKEN[[gallon]]CLOSE_SQUARE_TOKEN; s++) bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN = bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN - bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN else if (bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.js_blocks) OPEN_CURLY_TOKEN for (s = 0; s SMALLER_TOKEN [[mahogany]]OPEN_SQUARE_TOKEN[[gallon]]CLOSE_SQUARE_TOKEN; s++) bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN = bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN + bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.raw_samplesOPEN_SQUARE_TOKENsCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN offset += [[mahogany]]OPEN_SQUARE_TOKEN[[gallon]]CLOSE_SQUARE_TOKEN; bdOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.ra_block = 0; bdOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.ra_block = 0; CLOSE_CURLY_TOKEN memmove(ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENcCLOSE_SQUARE_TOKEN - sconf-GREATER_TOKENmax_order, ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENcCLOSE_SQUARE_TOKEN - sconf-GREATER_TOKENmax_order + sconf-GREATER_TOKENframe_length, sizeof(*ctx-GREATER_TOKENraw_samplesOPEN_SQUARE_TOKENcCLOSE_SQUARE_TOKEN) * sconf-GREATER_TOKENmax_order); return 0; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 23 / 11 / 28 / 62:   2%|         | 62/2690 [00:00<00:01, 2504.91it/s][Succeeded / Failed / Skipped / Total] 24 / 11 / 28 / 63:   2%|         | 63/2690 [00:00<00:01, 2502.19it/s][Succeeded / Failed / Skipped / Total] 25 / 11 / 28 / 64:   2%|         | 64/2690 [00:00<00:01, 2493.97it/s]
--------------------------------------------- Result 63 ---------------------------------------------
[[1 (69%)]] --> [[0 (52%)]] --> Socre: 0.5229902267456055

[[[[Adv]]]]: int cpu_exec(CPUState *[[cpu]]) OPEN_CURLY_TOKEN CPUClass *[[cc]] = CPU_GET_CLASS([[cpu]]); int ret; SyncClocks sc; current_cpu = [[cpu]]; if (cpu_handle_halt([[cpu]])) OPEN_CURLY_TOKEN return EXCP_HALTED; CLOSE_CURLY_TOKEN rcu_read_lock(); [[cc]]-GREATER_TOKENcpu_exec_enter([[cpu]]); init_delay_params(&sc, [[cpu]]); if (sigsetjmp([[cpu]]-GREATER_TOKENjmp_env, 0) != 0) OPEN_CURLY_TOKEN #if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6) [[cpu]] = current_cpu; [[cc]] = CPU_GET_CLASS([[cpu]]); #else g_assert([[cpu]] == current_cpu); g_assert([[cc]] == CPU_GET_CLASS([[cpu]])); #endif [[cpu]]-GREATER_TOKENcan_do_io = 1; tb_lock_reset(); if (qemu_mutex_iothread_locked()) OPEN_CURLY_TOKEN qemu_mutex_unlock_iothread(); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN while (!cpu_handle_exception([[cpu]], &ret)) OPEN_CURLY_TOKEN TranslationBlock *last_tb = NULL; int tb_exit = 0; while (!cpu_handle_interrupt([[cpu]], &last_tb)) OPEN_CURLY_TOKEN TranslationBlock *tb = tb_find([[cpu]], last_tb, tb_exit); cpu_loop_exec_tb([[cpu]], tb, &last_tb, &tb_exit, &sc); align_clocks(&sc, [[cpu]]); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN [[cc]]-GREATER_TOKENcpu_exec_exit([[cpu]]); rcu_read_unlock(); current_cpu = NULL; return ret; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int cpu_exec(CPUState *[[hut]]) OPEN_CURLY_TOKEN CPUClass *[[advertised]] = CPU_GET_CLASS([[hut]]); int ret; SyncClocks sc; current_cpu = [[hut]]; if (cpu_handle_halt([[hut]])) OPEN_CURLY_TOKEN return EXCP_HALTED; CLOSE_CURLY_TOKEN rcu_read_lock(); [[advertised]]-GREATER_TOKENcpu_exec_enter([[hut]]); init_delay_params(&sc, [[hut]]); if (sigsetjmp([[hut]]-GREATER_TOKENjmp_env, 0) != 0) OPEN_CURLY_TOKEN #if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6) [[hut]] = current_cpu; [[advertised]] = CPU_GET_CLASS([[hut]]); #else g_assert([[hut]] == current_cpu); g_assert([[advertised]] == CPU_GET_CLASS([[hut]])); #endif [[hut]]-GREATER_TOKENcan_do_io = 1; tb_lock_reset(); if (qemu_mutex_iothread_locked()) OPEN_CURLY_TOKEN qemu_mutex_unlock_iothread(); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN while (!cpu_handle_exception([[hut]], &ret)) OPEN_CURLY_TOKEN TranslationBlock *last_tb = NULL; int tb_exit = 0; while (!cpu_handle_interrupt([[hut]], &last_tb)) OPEN_CURLY_TOKEN TranslationBlock *tb = tb_find([[hut]], last_tb, tb_exit); cpu_loop_exec_tb([[hut]], tb, &last_tb, &tb_exit, &sc); align_clocks(&sc, [[hut]]); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN [[advertised]]-GREATER_TOKENcpu_exec_exit([[hut]]); rcu_read_unlock(); current_cpu = NULL; return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 64 ---------------------------------------------
[[1 (65%)]] --> [[0 (54%)]] --> Socre: 0.5392879247665405

[[[[Adv]]]]: static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int [[channelNum]], int codingMode) OPEN_CURLY_TOKEN int band, result=0, numSubbands, lastTonal, numBands; if (codingMode == JOINT_STEREO && [[channelNum]] == 1) OPEN_CURLY_TOKEN if (get_bits(gb,2) != 3) OPEN_CURLY_TOKEN av_log(NULL,AV_LOG_ERROR,"JS mono Sound Unit id != 3.\n"); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (get_bits(gb,6) != 0x28) OPEN_CURLY_TOKEN av_log(NULL,AV_LOG_ERROR,"Sound Unit id != 0x28.\n"); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN pSnd-GREATER_TOKENbandsCoded = get_bits(gb,2); result = decodeGainControl (gb, &(pSnd-GREATER_TOKENgainBlockOPEN_SQUARE_TOKENpSnd-GREATER_TOKENgcBlkSwitchCLOSE_SQUARE_TOKEN), pSnd-GREATER_TOKENbandsCoded); if (result) return result; pSnd-GREATER_TOKENnumComponents = decodeTonalComponents (gb, pSnd-GREATER_TOKENcomponents, pSnd-GREATER_TOKENbandsCoded); if (pSnd-GREATER_TOKENnumComponents == -1) return -1; numSubbands = decodeSpectrum (gb, pSnd-GREATER_TOKENspectrum); lastTonal = addTonalComponents (pSnd-GREATER_TOKENspectrum, pSnd-GREATER_TOKENnumComponents, pSnd-GREATER_TOKENcomponents); numBands = (subbandTabOPEN_SQUARE_TOKENnumSubbandsCLOSE_SQUARE_TOKEN - 1) GREATER_TOKENGREATER_TOKEN 8; if (lastTonal GREATER_TOKEN= 0) numBands = FFMAX((lastTonal + 256) GREATER_TOKENGREATER_TOKEN 8, numBands); for (band=0; bandSMALLER_TOKEN4; band++) OPEN_CURLY_TOKEN if (band SMALLER_TOKEN= numBands) OPEN_CURLY_TOKEN IMLT(&(pSnd-GREATER_TOKENspectrumOPEN_SQUARE_TOKENband*256CLOSE_SQUARE_TOKEN), pSnd-GREATER_TOKENIMDCT_buf, band&1); CLOSE_CURLY_TOKEN else memset(pSnd-GREATER_TOKENIMDCT_buf, 0, 512 * sizeof(float)); gainCompensateAndOverlap (pSnd-GREATER_TOKENIMDCT_buf, &(pSnd-GREATER_TOKENprevFrameOPEN_SQUARE_TOKENband*256CLOSE_SQUARE_TOKEN), &(pOutOPEN_SQUARE_TOKENband*256CLOSE_SQUARE_TOKEN), &((pSnd-GREATER_TOKENgainBlockOPEN_SQUARE_TOKEN1 - (pSnd-GREATER_TOKENgcBlkSwitch)CLOSE_SQUARE_TOKEN).gBlockOPEN_SQUARE_TOKENbandCLOSE_SQUARE_TOKEN), &((pSnd-GREATER_TOKENgainBlockOPEN_SQUARE_TOKENpSnd-GREATER_TOKENgcBlkSwitchCLOSE_SQUARE_TOKEN).gBlockOPEN_SQUARE_TOKENbandCLOSE_SQUARE_TOKEN)); CLOSE_CURLY_TOKEN pSnd-GREATER_TOKENgcBlkSwitch ^= 1; return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int [[optimal]], int codingMode) OPEN_CURLY_TOKEN int band, result=0, numSubbands, lastTonal, numBands; if (codingMode == JOINT_STEREO && [[optimal]] == 1) OPEN_CURLY_TOKEN if (get_bits(gb,2) != 3) OPEN_CURLY_TOKEN av_log(NULL,AV_LOG_ERROR,"JS mono Sound Unit id != 3.\n"); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (get_bits(gb,6) != 0x28) OPEN_CURLY_TOKEN av_log(NULL,AV_LOG_ERROR,"Sound Unit id != 0x28.\n"); return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN pSnd-GREATER_TOKENbandsCoded = get_bits(gb,2); result = decodeGainControl (gb, &(pSnd-GREATER_TOKENgainBlockOPEN_SQUARE_TOKENpSnd-GREATER_TOKENgcBlkSwitchCLOSE_SQUARE_TOKEN), pSnd-GREATER_TOKENbandsCoded); if (result) return result; pSnd-GREATER_TOKENnumComponents = decodeTonalComponents (gb, pSnd-GREATER_TOKENcomponents, pSnd-GREATER_TOKENbandsCoded); if (pSnd-GREATER_TOKENnumComponents == -1) return -1; numSubbands = decodeSpectrum (gb, pSnd-GREATER_TOKENspectrum); lastTonal = addTonalComponents (pSnd-GREATER_TOKENspectrum, pSnd-GREATER_TOKENnumComponents, pSnd-GREATER_TOKENcomponents); numBands = (subbandTabOPEN_SQUARE_TOKENnumSubbandsCLOSE_SQUARE_TOKEN - 1) GREATER_TOKENGREATER_TOKEN 8; if (lastTonal GREATER_TOKEN= 0) numBands = FFMAX((lastTonal + 256) GREATER_TOKENGREATER_TOKEN 8, numBands); for (band=0; bandSMALLER_TOKEN4; band++) OPEN_CURLY_TOKEN if (band SMALLER_TOKEN= numBands) OPEN_CURLY_TOKEN IMLT(&(pSnd-GREATER_TOKENspectrumOPEN_SQUARE_TOKENband*256CLOSE_SQUARE_TOKEN), pSnd-GREATER_TOKENIMDCT_buf, band&1); CLOSE_CURLY_TOKEN else memset(pSnd-GREATER_TOKENIMDCT_buf, 0, 512 * sizeof(float)); gainCompensateAndOverlap (pSnd-GREATER_TOKENIMDCT_buf, &(pSnd-GREATER_TOKENprevFrameOPEN_SQUARE_TOKENband*256CLOSE_SQUARE_TOKEN), &(pOutOPEN_SQUARE_TOKENband*256CLOSE_SQUARE_TOKEN), &((pSnd-GREATER_TOKENgainBlockOPEN_SQUARE_TOKEN1 - (pSnd-GREATER_TOKENgcBlkSwitch)CLOSE_SQUARE_TOKEN).gBlockOPEN_SQUARE_TOKENbandCLOSE_SQUARE_TOKEN), &((pSnd-GREATER_TOKENgainBlockOPEN_SQUARE_TOKENpSnd-GREATER_TOKENgcBlkSwitchCLOSE_SQUARE_TOKEN).gBlockOPEN_SQUARE_TOKENbandCLOSE_SQUARE_TOKEN)); CLOSE_CURLY_TOKEN pSnd-GREATER_TOKENgcBlkSwitch ^= 1; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 65 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 11 / 29 / 65:   2%|         | 65/2690 [00:00<00:01, 2508.05it/s][Succeeded / Failed / Skipped / Total] 26 / 11 / 29 / 66:   2%|         | 66/2690 [00:00<00:01, 2499.56it/s][Succeeded / Failed / Skipped / Total] 26 / 11 / 30 / 67:   2%|         | 67/2690 [00:00<00:01, 2517.25it/s][[0 (90%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_interrupt64(CPUX86State *env, int intno, int is_int, int error_code, target_ulong next_eip, int is_hw) OPEN_CURLY_TOKEN SegmentCache *dt; target_ulong ptr; int type, dpl, selector, cpl, ist; int has_error_code, new_stack; uint32_t e1, e2, e3, ss; target_ulong old_eip, esp, offset; has_error_code = 0; if (!is_int && !is_hw) OPEN_CURLY_TOKEN has_error_code = exception_has_error_code(intno); CLOSE_CURLY_TOKEN if (is_int) OPEN_CURLY_TOKEN old_eip = next_eip; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN old_eip = env-GREATER_TOKENeip; CLOSE_CURLY_TOKEN dt = &env-GREATER_TOKENidt; if (intno * 16 + 15 GREATER_TOKEN dt-GREATER_TOKENlimit) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); CLOSE_CURLY_TOKEN ptr = dt-GREATER_TOKENbase + intno * 16; e1 = cpu_ldl_kernel(env, ptr); e2 = cpu_ldl_kernel(env, ptr + 4); e3 = cpu_ldl_kernel(env, ptr + 8); type = (e2 GREATER_TOKENGREATER_TOKEN DESC_TYPE_SHIFT) & 0x1f; switch (type) OPEN_CURLY_TOKEN case 14: case 15: break; default: raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); break; CLOSE_CURLY_TOKEN dpl = (e2 GREATER_TOKENGREATER_TOKEN DESC_DPL_SHIFT) & 3; cpl = env-GREATER_TOKENhflags & HF_CPL_MASK; if (is_int && dpl SMALLER_TOKEN cpl) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); CLOSE_CURLY_TOKEN if (!(e2 & DESC_P_MASK)) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2); CLOSE_CURLY_TOKEN selector = e1 GREATER_TOKENGREATER_TOKEN 16; offset = ((target_ulong)e3 SMALLER_TOKENSMALLER_TOKEN 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff); ist = e2 & 7; if ((selector & 0xfffc) == 0) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, 0); CLOSE_CURLY_TOKEN if (load_segment(env, &e1, &e2, selector) != 0) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); CLOSE_CURLY_TOKEN if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); CLOSE_CURLY_TOKEN dpl = (e2 GREATER_TOKENGREATER_TOKEN DESC_DPL_SHIFT) & 3; if (dpl GREATER_TOKEN cpl) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); CLOSE_CURLY_TOKEN if (!(e2 & DESC_P_MASK)) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc); CLOSE_CURLY_TOKEN if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); CLOSE_CURLY_TOKEN if ((!(e2 & DESC_C_MASK) && dpl SMALLER_TOKEN cpl) || ist != 0) OPEN_CURLY_TOKEN new_stack = 1; esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl); ss = 0; CLOSE_CURLY_TOKEN else if ((e2 & DESC_C_MASK) || dpl == cpl) OPEN_CURLY_TOKEN if (env-GREATER_TOKENeflags & VM_MASK) OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); CLOSE_CURLY_TOKEN new_stack = 0; esp = env-GREATER_TOKENregsOPEN_SQUARE_TOKENR_ESPCLOSE_SQUARE_TOKEN; dpl = cpl; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); new_stack = 0; esp = 0; CLOSE_CURLY_TOKEN esp &= ~0xfLL; PUSHQ(esp, env-GREATER_TOKENsegsOPEN_SQUARE_TOKENR_SSCLOSE_SQUARE_TOKEN.selector); PUSHQ(esp, env-GREATER_TOKENregsOPEN_SQUARE_TOKENR_ESPCLOSE_SQUARE_TOKEN); PUSHQ(esp, cpu_compute_eflags(env)); PUSHQ(esp, env-GREATER_TOKENsegsOPEN_SQUARE_TOKENR_CSCLOSE_SQUARE_TOKEN.selector); PUSHQ(esp, old_eip); if (has_error_code) OPEN_CURLY_TOKEN PUSHQ(esp, error_code); CLOSE_CURLY_TOKEN if ((type & 1) == 0) OPEN_CURLY_TOKEN env-GREATER_TOKENeflags &= ~IF_MASK; CLOSE_CURLY_TOKEN env-GREATER_TOKENeflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK); if (new_stack) OPEN_CURLY_TOKEN ss = 0 | dpl; cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0); CLOSE_CURLY_TOKEN env-GREATER_TOKENregsOPEN_SQUARE_TOKENR_ESPCLOSE_SQUARE_TOKEN = esp; selector = (selector & ~3) | dpl; cpu_x86_load_seg_cache(env, R_CS, selector, get_seg_base(e1, e2), get_seg_limit(e1, e2), e2); env-GREATER_TOKENeip = offset; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 66 ---------------------------------------------
[[1 (88%)]] --> [[0 (66%)]] --> Socre: 0.6610017418861389

[[[[Adv]]]]: static void usbredir_bulk_packet(void *priv, uint32_t id, struct usb_redir_bulk_packet_header *[[bulk_packet]], uint8_t *[[data]], int data_len) OPEN_CURLY_TOKEN USBRedirDevice *dev = priv; uint8_t ep = [[bulk_packet]]-GREATER_TOKENendpoint; int len = [[bulk_packet]]-GREATER_TOKENlength; AsyncURB *aurb; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", [[bulk_packet]]-GREATER_TOKENstatus, ep, len, id); aurb = async_find(dev, id); if (!aurb) OPEN_CURLY_TOKEN free([[data]]); return; CLOSE_CURLY_TOKEN if (aurb-GREATER_TOKENbulk_packet.endpoint != [[bulk_packet]]-GREATER_TOKENendpoint || aurb-GREATER_TOKENbulk_packet.stream_id != [[bulk_packet]]-GREATER_TOKENstream_id) OPEN_CURLY_TOKEN ERROR("return bulk packet mismatch, please report this!\n"); len = USB_RET_NAK; CLOSE_CURLY_TOKEN if (aurb-GREATER_TOKENpacket) OPEN_CURLY_TOKEN len = usbredir_handle_status(dev, [[bulk_packet]]-GREATER_TOKENstatus, len); if (len GREATER_TOKEN 0) OPEN_CURLY_TOKEN usbredir_log_data(dev, "bulk data in:", [[data]], data_len); if (data_len SMALLER_TOKEN= aurb-GREATER_TOKENpacket-GREATER_TOKENlen) OPEN_CURLY_TOKEN memcpy(aurb-GREATER_TOKENpacket-GREATER_TOKENdata, [[data]], data_len); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ERROR("bulk buffer too small (%d GREATER_TOKEN %d)\n", data_len, aurb-GREATER_TOKENpacket-GREATER_TOKENlen); len = USB_RET_STALL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN aurb-GREATER_TOKENpacket-GREATER_TOKENlen = len; usb_packet_complete(&dev-GREATER_TOKENdev, aurb-GREATER_TOKENpacket); CLOSE_CURLY_TOKEN async_free(dev, aurb); free([[data]]); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void usbredir_bulk_packet(void *priv, uint32_t id, struct usb_redir_bulk_packet_header *[[ccs]], uint8_t *[[solaris]], int data_len) OPEN_CURLY_TOKEN USBRedirDevice *dev = priv; uint8_t ep = [[ccs]]-GREATER_TOKENendpoint; int len = [[ccs]]-GREATER_TOKENlength; AsyncURB *aurb; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", [[ccs]]-GREATER_TOKENstatus, ep, len, id); aurb = async_find(dev, id); if (!aurb) OPEN_CURLY_TOKEN free([[solaris]]); return; CLOSE_CURLY_TOKEN if (aurb-GREATER_TOKENbulk_packet.endpoint != [[ccs]]-GREATER_TOKENendpoint || aurb-GREATER_TOKENbulk_packet.stream_id != [[ccs]]-GREATER_TOKENstream_id) OPEN_CURLY_TOKEN ERROR("return bulk packet mismatch, please report this!\n"); len = USB_RET_NAK; CLOSE_CURLY_TOKEN if (aurb-GREATER_TOKENpacket) OPEN_CURLY_TOKEN len = usbredir_handle_status(dev, [[ccs]]-GREATER_TOKENstatus, len); if (len GREATER_TOKEN 0) OPEN_CURLY_TOKEN usbredir_log_data(dev, "bulk data in:", [[solaris]], data_len); if (data_len SMALLER_TOKEN= aurb-GREATER_TOKENpacket-GREATER_TOKENlen) OPEN_CURLY_TOKEN memcpy(aurb-GREATER_TOKENpacket-GREATER_TOKENdata, [[solaris]], data_len); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ERROR("bulk buffer too small (%d GREATER_TOKEN %d)\n", data_len, aurb-GREATER_TOKENpacket-GREATER_TOKENlen); len = USB_RET_STALL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN aurb-GREATER_TOKENpacket-GREATER_TOKENlen = len; usb_packet_complete(&dev-GREATER_TOKENdev, aurb-GREATER_TOKENpacket); CLOSE_CURLY_TOKEN async_free(dev, aurb); free([[solaris]]); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 67 ---------------------------------------------
[[1 (68%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline int num_effective_busses(XilinxSPIPS *s) OPEN_CURLY_TOKEN return (s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_LQSPI_STSCLOSE_SQUARE_TOKEN & LQSPI_CFG_SEP_BUS && s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_LQSPI_STSCLOSE_SQUARE_TOKEN & LQSPI_CFG_TWO_MEM) ? s-GREATER_TOKENnum_busses : 1; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 68 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 27 / 11 / 30 / 68:   3%|         | 68/2690 [00:00<00:01, 2498.97it/s][Succeeded / Failed / Skipped / Total] 28 / 11 / 30 / 69:   3%|         | 69/2690 [00:00<00:01, 2477.82it/s][[0 (78%)]] --> [[1 (58%)]] --> Socre: 0.576429545879364

[[[[Adv]]]]: static inline void codeblock(DiracContext *s, SubBand *b, GetBitContext *gb, DiracArith *c, int left, int right, int top, int bottom, int blockcnt_one, int [[is_arith]]) OPEN_CURLY_TOKEN int x, y, zero_block; int qoffset, qfactor; IDWTELEM *buf; if (!blockcnt_one) OPEN_CURLY_TOKEN if ([[is_arith]]) zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK); else zero_block = get_bits1(gb); if (zero_block) return; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcodeblock_mode && !(s-GREATER_TOKENold_delta_quant && blockcnt_one)) OPEN_CURLY_TOKEN if ([[is_arith]]) b-GREATER_TOKENquant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA); else b-GREATER_TOKENquant += dirac_get_se_golomb(gb); CLOSE_CURLY_TOKEN b-GREATER_TOKENquant = FFMIN(b-GREATER_TOKENquant, MAX_QUANT); qfactor = qscale_tabOPEN_SQUARE_TOKENb-GREATER_TOKENquantCLOSE_SQUARE_TOKEN; if (!s-GREATER_TOKENnum_refs) qoffset = qoffset_intra_tabOPEN_SQUARE_TOKENb-GREATER_TOKENquantCLOSE_SQUARE_TOKEN; else qoffset = qoffset_inter_tabOPEN_SQUARE_TOKENb-GREATER_TOKENquantCLOSE_SQUARE_TOKEN; buf = b-GREATER_TOKENibuf + top * b-GREATER_TOKENstride; for (y = top; y SMALLER_TOKEN bottom; y++) OPEN_CURLY_TOKEN for (x = left; x SMALLER_TOKEN right; x++) OPEN_CURLY_TOKEN if ([[is_arith]]) coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y); else bufOPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = coeff_unpack_golomb(gb, qfactor, qoffset); CLOSE_CURLY_TOKEN buf += b-GREATER_TOKENstride; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static inline void codeblock(DiracContext *s, SubBand *b, GetBitContext *gb, DiracArith *c, int left, int right, int top, int bottom, int blockcnt_one, int [[overhang]]) OPEN_CURLY_TOKEN int x, y, zero_block; int qoffset, qfactor; IDWTELEM *buf; if (!blockcnt_one) OPEN_CURLY_TOKEN if ([[overhang]]) zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK); else zero_block = get_bits1(gb); if (zero_block) return; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENcodeblock_mode && !(s-GREATER_TOKENold_delta_quant && blockcnt_one)) OPEN_CURLY_TOKEN if ([[overhang]]) b-GREATER_TOKENquant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA); else b-GREATER_TOKENquant += dirac_get_se_golomb(gb); CLOSE_CURLY_TOKEN b-GREATER_TOKENquant = FFMIN(b-GREATER_TOKENquant, MAX_QUANT); qfactor = qscale_tabOPEN_SQUARE_TOKENb-GREATER_TOKENquantCLOSE_SQUARE_TOKEN; if (!s-GREATER_TOKENnum_refs) qoffset = qoffset_intra_tabOPEN_SQUARE_TOKENb-GREATER_TOKENquantCLOSE_SQUARE_TOKEN; else qoffset = qoffset_inter_tabOPEN_SQUARE_TOKENb-GREATER_TOKENquantCLOSE_SQUARE_TOKEN; buf = b-GREATER_TOKENibuf + top * b-GREATER_TOKENstride; for (y = top; y SMALLER_TOKEN bottom; y++) OPEN_CURLY_TOKEN for (x = left; x SMALLER_TOKEN right; x++) OPEN_CURLY_TOKEN if ([[overhang]]) coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y); else bufOPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = coeff_unpack_golomb(gb, qfactor, qoffset); CLOSE_CURLY_TOKEN buf += b-GREATER_TOKENstride; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 69 ---------------------------------------------
[[1 (67%)]] --> [[0 (61%)]] --> Socre: 0.6136366128921509

[[[[Adv]]]]: static int iscsi_open(BlockDriverState *bs, const char *[[filename]], int flags) OPEN_CURLY_TOKEN IscsiLun *iscsilun = bs-GREATER_TOKENopaque; struct iscsi_context *iscsi = NULL; struct iscsi_url *iscsi_url = NULL; struct IscsiTask task; char *initiator_name = NULL; int ret; if ((BDRV_SECTOR_SIZE % 512) != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Invalid BDRV_SECTOR_SIZE. " "BDRV_SECTOR_SIZE(%lld) is not a multiple " "of 512", BDRV_SECTOR_SIZE); return -EINVAL; CLOSE_CURLY_TOKEN iscsi_url = iscsi_parse_full_url(iscsi, [[filename]]); if (iscsi_url == NULL) OPEN_CURLY_TOKEN error_report("Failed to parse URL : %s %s", [[filename]], iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN memset(iscsilun, 0, sizeof(IscsiLun)); initiator_name = parse_initiator_name(iscsi_url-GREATER_TOKENtarget); iscsi = iscsi_create_context(initiator_name); if (iscsi == NULL) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to create iSCSI context."); ret = -ENOMEM; goto failed; CLOSE_CURLY_TOKEN if (iscsi_set_targetname(iscsi, iscsi_url-GREATER_TOKENtarget)) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to set target name."); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN if (iscsi_url-GREATER_TOKENuser != NULL) OPEN_CURLY_TOKEN ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url-GREATER_TOKENuser, iscsi_url-GREATER_TOKENpasswd); if (ret != 0) OPEN_CURLY_TOKEN error_report("Failed to set initiator username and password"); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (parse_chap(iscsi, iscsi_url-GREATER_TOKENtarget) != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to set CHAP user/password"); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to set session type to normal."); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C); parse_header_digest(iscsi, iscsi_url-GREATER_TOKENtarget); task.iscsilun = iscsilun; task.status = 0; task.complete = 0; task.bs = bs; iscsilun-GREATER_TOKENiscsi = iscsi; iscsilun-GREATER_TOKENlun = iscsi_url-GREATER_TOKENlun; if (iscsi_full_connect_async(iscsi, iscsi_url-GREATER_TOKENportal, iscsi_url-GREATER_TOKENlun, iscsi_connect_cb, &task) != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to start async connect."); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN while (!task.complete) OPEN_CURLY_TOKEN iscsi_set_events(iscsilun); qemu_aio_wait(); CLOSE_CURLY_TOKEN if (task.status != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to connect to LUN : %s", iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN if (iscsi_url != NULL) OPEN_CURLY_TOKEN iscsi_destroy_url(iscsi_url); CLOSE_CURLY_TOKEN if (iscsilun-GREATER_TOKENtype == TYPE_MEDIUM_CHANGER || iscsilun-GREATER_TOKENtype == TYPE_TAPE) OPEN_CURLY_TOKEN bs-GREATER_TOKENsg = 1; CLOSE_CURLY_TOKEN return 0; failed: if (initiator_name != NULL) OPEN_CURLY_TOKEN g_free(initiator_name); CLOSE_CURLY_TOKEN if (iscsi_url != NULL) OPEN_CURLY_TOKEN iscsi_destroy_url(iscsi_url); CLOSE_CURLY_TOKEN if (iscsi != NULL) OPEN_CURLY_TOKEN iscsi_destroy_context(iscsi); CLOSE_CURLY_TOKEN memset(iscsilun, 0, sizeof(IscsiLun)); return ret; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int iscsi_open(BlockDriverState *bs, const char *[[vidia]], int flags) OPEN_CURLY_TOKEN IscsiLun *iscsilun = bs-GREATER_TOKENopaque; struct iscsi_context *iscsi = NULL; struct iscsi_url *iscsi_url = NULL; struct IscsiTask task; char *initiator_name = NULL; int ret; if ((BDRV_SECTOR_SIZE % 512) != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Invalid BDRV_SECTOR_SIZE. " "BDRV_SECTOR_SIZE(%lld) is not a multiple " "of 512", BDRV_SECTOR_SIZE); return -EINVAL; CLOSE_CURLY_TOKEN iscsi_url = iscsi_parse_full_url(iscsi, [[vidia]]); if (iscsi_url == NULL) OPEN_CURLY_TOKEN error_report("Failed to parse URL : %s %s", [[vidia]], iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN memset(iscsilun, 0, sizeof(IscsiLun)); initiator_name = parse_initiator_name(iscsi_url-GREATER_TOKENtarget); iscsi = iscsi_create_context(initiator_name); if (iscsi == NULL) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to create iSCSI context."); ret = -ENOMEM; goto failed; CLOSE_CURLY_TOKEN if (iscsi_set_targetname(iscsi, iscsi_url-GREATER_TOKENtarget)) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to set target name."); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN if (iscsi_url-GREATER_TOKENuser != NULL) OPEN_CURLY_TOKEN ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url-GREATER_TOKENuser, iscsi_url-GREATER_TOKENpasswd); if (ret != 0) OPEN_CURLY_TOKEN error_report("Failed to set initiator username and password"); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (parse_chap(iscsi, iscsi_url-GREATER_TOKENtarget) != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to set CHAP user/password"); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to set session type to normal."); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C); parse_header_digest(iscsi, iscsi_url-GREATER_TOKENtarget); task.iscsilun = iscsilun; task.status = 0; task.complete = 0; task.bs = bs; iscsilun-GREATER_TOKENiscsi = iscsi; iscsilun-GREATER_TOKENlun = iscsi_url-GREATER_TOKENlun; if (iscsi_full_connect_async(iscsi, iscsi_url-GREATER_TOKENportal, iscsi_url-GREATER_TOKENlun, iscsi_connect_cb, &task) != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to start async connect."); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN while (!task.complete) OPEN_CURLY_TOKEN iscsi_set_events(iscsilun); qemu_aio_wait(); CLOSE_CURLY_TOKEN if (task.status != 0) OPEN_CURLY_TOKEN error_report("iSCSI: Failed to connect to LUN : %s", iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; CLOSE_CURLY_TOKEN if (iscsi_url != NULL) OPEN_CURLY_TOKEN iscsi_destroy_url(iscsi_url); CLOSE_CURLY_TOKEN if (iscsilun-GREATER_TOKENtype == TYPE_MEDIUM_CHANGER || iscsilun-GREATER_TOKENtype == TYPE_TAPE) OPEN_CURLY_TOKEN bs-GREATER_TOKENsg = 1; CLOSE_CURLY_TOKEN return 0; failed: if (initiator_name != NULL) OPEN_CURLY_TOKEN g_free(initiator_name); CLOSE_CURLY_TOKEN if (iscsi_url != NULL) OPEN_CURLY_TOKEN iscsi_destroy_url(iscsi_url); CLOSE_CURLY_TOKEN if (iscsi != NULL) OPEN_CURLY_TOKEN iscsi_destroy_context(iscsi); CLOSE_CURLY_TOKEN memset(iscsilun, 0, sizeof(IscsiLun)); return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 70 ---------------------------------------------
[[1 (97%)]] --> [[0 (54%)]] --> Socre: 0.5360597372055054

[[[[Adv]]]]: void palette8tobgr24(const uint8_t *src, uint8_t *[[dst]], long [[num_pixels]], const uint8_t *palette) OPEN_CURLY_TOKEN long [[i]]; for([[i]]=0; [[i]]SMALLER_TOKEN[[num_pixels]]; [[i]]++) OPEN_CURLY_TOKEN [[dst]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN= paletteOPEN_SQUARE_TOKEN srcOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN*4+0 CLOSE_SQUARE_TOKEN; [[dst]]OPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN= paletteOPEN_SQUARE_TOKEN srcOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN*4+1 CLOSE_SQUARE_TOKEN; [[dst]]OPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN= paletteOPEN_SQUARE_TOKEN srcOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN*4+2 CLOSE_SQUARE_TOKEN; [[dst]]+= 3; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void palette8tobgr24(const uint8_t *src, uint8_t *[[geologic]], long [[trendy]], const uint8_t *palette) OPEN_CURLY_TOKEN long [[snobbish]]; for([[snobbish]]=0; [[snobbish]]SMALLER_TOKEN[[trendy]]; [[snobbish]]++) OPEN_CURLY_TOKEN [[geologic]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN= paletteOPEN_SQUARE_TOKEN srcOPEN_SQUARE_TOKEN[[snobbish]]CLOSE_SQUARE_TOKEN*4+0 CLOSE_SQUARE_TOKEN; [[geologic]]OPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN= paletteOPEN_SQUARE_TOKEN srcOPEN_SQUARE_TOKEN[[snobbish]]CLOSE_SQUARE_TOKEN*4+1 CLOSE_SQUARE_TOKEN; [[geologic]]OPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN= paletteOPEN_SQUARE_TOKEN srcOPEN_SQUARE_TOKEN[[snobbish]]CLOSE_SQUARE_TOKEN*4+2 CLOSE_SQUARE_TOKEN; [[geologic]]+= 3; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 29 / 11 / 30 / 70:   3%|         | 70/2690 [00:00<00:01, 2475.33it/s][Succeeded / Failed / Skipped / Total] 29 / 11 / 31 / 71:   3%|         | 71/2690 [00:00<00:01, 2491.08it/s][Succeeded / Failed / Skipped / Total] 30 / 11 / 31 / 72:   3%|         | 72/2690 [00:00<00:01, 2494.20it/s]
--------------------------------------------- Result 71 ---------------------------------------------
[[0 (89%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data)OPEN_CURLY_TOKEN FFV1Context *f = avctx-GREATER_TOKENpriv_data; CABACContext * const c= &f-GREATER_TOKENc; AVFrame *pict = data; const int width= f-GREATER_TOKENwidth; const int height= f-GREATER_TOKENheight; AVFrame * const p= &f-GREATER_TOKENpicture; int used_count= 0; if(avctx-GREATER_TOKENstrict_std_compliance GREATER_TOKEN= 0)OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "this codec is under development, files encoded with it wont be decodeable with future versions!!!\n" "use vstrict=-1 to use it anyway\n"); return -1; CLOSE_CURLY_TOKEN ff_init_cabac_encoder(c, buf, buf_size); ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64); c-GREATER_TOKENlps_stateOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = 1; c-GREATER_TOKENlps_stateOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = 0; *p = *pict; p-GREATER_TOKENpict_type= FF_I_TYPE; if(avctx-GREATER_TOKENgop_size==0 || f-GREATER_TOKENpicture_number % avctx-GREATER_TOKENgop_size == 0)OPEN_CURLY_TOKEN put_cabac_bypass(c, 1); p-GREATER_TOKENkey_frame= 1; write_header(f); clear_state(f); CLOSE_CURLY_TOKENelseOPEN_CURLY_TOKEN put_cabac_bypass(c, 0); p-GREATER_TOKENkey_frame= 0; CLOSE_CURLY_TOKEN if(!f-GREATER_TOKENac)OPEN_CURLY_TOKEN used_count += put_cabac_terminate(c, 1); init_put_bits(&f-GREATER_TOKENpb, buf + used_count, buf_size - used_count); CLOSE_CURLY_TOKEN if(f-GREATER_TOKENcolorspace==0)OPEN_CURLY_TOKEN const int chroma_width = -((-width )GREATER_TOKENGREATER_TOKENf-GREATER_TOKENchroma_h_shift); const int chroma_height= -((-height)GREATER_TOKENGREATER_TOKENf-GREATER_TOKENchroma_v_shift); encode_plane(f, p-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, width, height, p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, 0); encode_plane(f, p-GREATER_TOKENdataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN, chroma_width, chroma_height, p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN, 1); encode_plane(f, p-GREATER_TOKENdataOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN, chroma_width, chroma_height, p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN, 1); CLOSE_CURLY_TOKENelseOPEN_CURLY_TOKEN encode_rgb_frame(f, (uint32_t*)(p-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN), width, height, p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN/4); CLOSE_CURLY_TOKEN emms_c(); f-GREATER_TOKENpicture_number++; if(f-GREATER_TOKENac)OPEN_CURLY_TOKEN return put_cabac_terminate(c, 1); CLOSE_CURLY_TOKENelseOPEN_CURLY_TOKEN flush_put_bits(&f-GREATER_TOKENpb); return used_count + (put_bits_count(&f-GREATER_TOKENpb)+7)/8; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 72 ---------------------------------------------
[[1 (76%)]] --> [[0 (51%)]] --> Socre: 0.5060057640075684

[[[[Adv]]]]: static av_cold int hevc_init_context(AVCodecContext *[[avctx]]) OPEN_CURLY_TOKEN HEVCContext *[[s]] = [[avctx]]-GREATER_TOKENpriv_data; int i; [[s]]-GREATER_TOKENavctx = [[avctx]]; [[s]]-GREATER_TOKENHEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (![[s]]-GREATER_TOKENHEVClc) goto fail; [[s]]-GREATER_TOKENHEVClcListOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = [[s]]-GREATER_TOKENHEVClc; [[s]]-GREATER_TOKENsListOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = [[s]]; [[s]]-GREATER_TOKENcabac_state = av_malloc(HEVC_CONTEXTS); if (![[s]]-GREATER_TOKENcabac_state) goto fail; [[s]]-GREATER_TOKENoutput_frame = av_frame_alloc(); if (![[s]]-GREATER_TOKENoutput_frame) goto fail; for (i = 0; i SMALLER_TOKEN FF_ARRAY_ELEMS([[s]]-GREATER_TOKENDPB); i++) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENDPBOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.frame = av_frame_alloc(); if (![[s]]-GREATER_TOKENDPBOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.frame) goto fail; [[s]]-GREATER_TOKENDPBOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.tf.f = [[s]]-GREATER_TOKENDPBOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.frame; CLOSE_CURLY_TOKEN [[s]]-GREATER_TOKENmax_ra = INT_MAX; [[s]]-GREATER_TOKENmd5_ctx = av_md5_alloc(); if (![[s]]-GREATER_TOKENmd5_ctx) goto fail; ff_bswapdsp_init(&[[s]]-GREATER_TOKENbdsp); [[s]]-GREATER_TOKENcontext_initialized = 1; [[s]]-GREATER_TOKENeos = 0; return 0; fail: hevc_decode_free([[avctx]]); return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static av_cold int hevc_init_context(AVCodecContext *[[stockbroker]]) OPEN_CURLY_TOKEN HEVCContext *[[valued]] = [[stockbroker]]-GREATER_TOKENpriv_data; int i; [[valued]]-GREATER_TOKENavctx = [[stockbroker]]; [[valued]]-GREATER_TOKENHEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (![[valued]]-GREATER_TOKENHEVClc) goto fail; [[valued]]-GREATER_TOKENHEVClcListOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = [[valued]]-GREATER_TOKENHEVClc; [[valued]]-GREATER_TOKENsListOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = [[valued]]; [[valued]]-GREATER_TOKENcabac_state = av_malloc(HEVC_CONTEXTS); if (![[valued]]-GREATER_TOKENcabac_state) goto fail; [[valued]]-GREATER_TOKENoutput_frame = av_frame_alloc(); if (![[valued]]-GREATER_TOKENoutput_frame) goto fail; for (i = 0; i SMALLER_TOKEN FF_ARRAY_ELEMS([[valued]]-GREATER_TOKENDPB); i++) OPEN_CURLY_TOKEN [[valued]]-GREATER_TOKENDPBOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.frame = av_frame_alloc(); if (![[valued]]-GREATER_TOKENDPBOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.frame) goto fail; [[valued]]-GREATER_TOKENDPBOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.tf.f = [[valued]]-GREATER_TOKENDPBOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.frame; CLOSE_CURLY_TOKEN [[valued]]-GREATER_TOKENmax_ra = INT_MAX; [[valued]]-GREATER_TOKENmd5_ctx = av_md5_alloc(); if (![[valued]]-GREATER_TOKENmd5_ctx) goto fail; ff_bswapdsp_init(&[[valued]]-GREATER_TOKENbdsp); [[valued]]-GREATER_TOKENcontext_initialized = 1; [[valued]]-GREATER_TOKENeos = 0; return 0; fail: hevc_decode_free([[stockbroker]]); return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 73 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 31 / 11 / 31 / 73:   3%|         | 73/2690 [00:00<00:01, 2482.18it/s][[1 (85%)]] --> [[0 (63%)]] --> Socre: 0.6263489723205566

[[[[Adv]]]]: static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *[[frame]], opj_image_t *image) OPEN_CURLY_TOKEN int compno; int x, y; int *[[image_line]]; int [[frame_index]]; const int numcomps = image-GREATER_TOKENnumcomps; uint16_t *[[frame_ptr]] = (uint16_t *)[[frame]]-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; for (compno = 0; compno SMALLER_TOKEN numcomps; ++compno) OPEN_CURLY_TOKEN if (image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w GREATER_TOKEN [[frame]]-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN / numcomps) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n"); return 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (compno = 0; compno SMALLER_TOKEN numcomps; ++compno) OPEN_CURLY_TOKEN for (y = 0; y SMALLER_TOKEN avctx-GREATER_TOKENheight; ++y) OPEN_CURLY_TOKEN [[image_line]] = image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.data + y * image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w; [[frame_index]] = y * ([[frame]]-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN / 2) + compno; for (x = 0; x SMALLER_TOKEN avctx-GREATER_TOKENwidth; ++x) OPEN_CURLY_TOKEN [[image_line]]OPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = [[frame_ptr]]OPEN_SQUARE_TOKEN[[frame_index]]CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 4; [[frame_index]] += numcomps; CLOSE_CURLY_TOKEN for (; x SMALLER_TOKEN image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w; ++x) OPEN_CURLY_TOKEN [[image_line]]OPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = [[image_line]]OPEN_SQUARE_TOKENx - 1CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (; y SMALLER_TOKEN image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.h; ++y) OPEN_CURLY_TOKEN [[image_line]] = image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.data + y * image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w; for (x = 0; x SMALLER_TOKEN image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w; ++x) OPEN_CURLY_TOKEN [[image_line]]OPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = [[image_line]]OPEN_SQUARE_TOKENx - image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.wCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return 1; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *[[geeks]], opj_image_t *image) OPEN_CURLY_TOKEN int compno; int x, y; int *[[smartass]]; int [[vicissitudes]]; const int numcomps = image-GREATER_TOKENnumcomps; uint16_t *[[kindhearted]] = (uint16_t *)[[geeks]]-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; for (compno = 0; compno SMALLER_TOKEN numcomps; ++compno) OPEN_CURLY_TOKEN if (image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w GREATER_TOKEN [[geeks]]-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN / numcomps) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n"); return 0; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (compno = 0; compno SMALLER_TOKEN numcomps; ++compno) OPEN_CURLY_TOKEN for (y = 0; y SMALLER_TOKEN avctx-GREATER_TOKENheight; ++y) OPEN_CURLY_TOKEN [[smartass]] = image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.data + y * image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w; [[vicissitudes]] = y * ([[geeks]]-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN / 2) + compno; for (x = 0; x SMALLER_TOKEN avctx-GREATER_TOKENwidth; ++x) OPEN_CURLY_TOKEN [[smartass]]OPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = [[kindhearted]]OPEN_SQUARE_TOKEN[[vicissitudes]]CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 4; [[vicissitudes]] += numcomps; CLOSE_CURLY_TOKEN for (; x SMALLER_TOKEN image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w; ++x) OPEN_CURLY_TOKEN [[smartass]]OPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = [[smartass]]OPEN_SQUARE_TOKENx - 1CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (; y SMALLER_TOKEN image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.h; ++y) OPEN_CURLY_TOKEN [[smartass]] = image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.data + y * image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w; for (x = 0; x SMALLER_TOKEN image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.w; ++x) OPEN_CURLY_TOKEN [[smartass]]OPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = [[smartass]]OPEN_SQUARE_TOKENx - image-GREATER_TOKENcompsOPEN_SQUARE_TOKENcompnoCLOSE_SQUARE_TOKEN.wCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return 1; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 74 ---------------------------------------------
[[1 (59%)]] --> [[0 (59%)]] --> Socre: 0.5947118997573853

[[[[Adv]]]]: int qcow2_update_header(BlockDriverState *bs) OPEN_CURLY_TOKEN BDRVQcowState *s = bs-GREATER_TOKENopaque; QCowHeader *header; char *buf; size_t [[buflen]] = s-GREATER_TOKENcluster_size; int ret; uint64_t total_size; uint32_t refcount_table_clusters; size_t header_length; Qcow2UnknownHeaderExtension *uext; buf = qemu_blockalign(bs, [[buflen]]); header = (QCowHeader*) buf; if ([[buflen]] SMALLER_TOKEN sizeof(*header)) OPEN_CURLY_TOKEN ret = -ENOSPC; goto fail; CLOSE_CURLY_TOKEN header_length = sizeof(*header) + s-GREATER_TOKENunknown_header_fields_size; total_size = bs-GREATER_TOKENtotal_sectors * BDRV_SECTOR_SIZE; refcount_table_clusters = s-GREATER_TOKENrefcount_table_size GREATER_TOKENGREATER_TOKEN (s-GREATER_TOKENcluster_bits - 3); *header = (QCowHeader) OPEN_CURLY_TOKEN .magic = cpu_to_be32(QCOW_MAGIC), .version = cpu_to_be32(s-GREATER_TOKENqcow_version), .backing_file_offset = 0, .backing_file_size = 0, .cluster_bits = cpu_to_be32(s-GREATER_TOKENcluster_bits), .size = cpu_to_be64(total_size), .crypt_method = cpu_to_be32(s-GREATER_TOKENcrypt_method_header), .l1_size = cpu_to_be32(s-GREATER_TOKENl1_size), .l1_table_offset = cpu_to_be64(s-GREATER_TOKENl1_table_offset), .refcount_table_offset = cpu_to_be64(s-GREATER_TOKENrefcount_table_offset), .refcount_table_clusters = cpu_to_be32(refcount_table_clusters), .nb_snapshots = cpu_to_be32(s-GREATER_TOKENnb_snapshots), .snapshots_offset = cpu_to_be64(s-GREATER_TOKENsnapshots_offset), .incompatible_features = cpu_to_be64(s-GREATER_TOKENincompatible_features), .compatible_features = cpu_to_be64(s-GREATER_TOKENcompatible_features), .autoclear_features = cpu_to_be64(s-GREATER_TOKENautoclear_features), .refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT), .header_length = cpu_to_be32(header_length), CLOSE_CURLY_TOKEN; switch (s-GREATER_TOKENqcow_version) OPEN_CURLY_TOKEN case 2: ret = offsetof(QCowHeader, incompatible_features); break; case 3: ret = sizeof(*header); break; default: return -EINVAL; CLOSE_CURLY_TOKEN buf += ret; [[buflen]] -= ret; memset(buf, 0, [[buflen]]); if (s-GREATER_TOKENunknown_header_fields_size) OPEN_CURLY_TOKEN if ([[buflen]] SMALLER_TOKEN s-GREATER_TOKENunknown_header_fields_size) OPEN_CURLY_TOKEN ret = -ENOSPC; goto fail; CLOSE_CURLY_TOKEN memcpy(buf, s-GREATER_TOKENunknown_header_fields, s-GREATER_TOKENunknown_header_fields_size); buf += s-GREATER_TOKENunknown_header_fields_size; [[buflen]] -= s-GREATER_TOKENunknown_header_fields_size; CLOSE_CURLY_TOKEN if (*bs-GREATER_TOKENbacking_format) OPEN_CURLY_TOKEN ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT, bs-GREATER_TOKENbacking_format, strlen(bs-GREATER_TOKENbacking_format), [[buflen]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN buf += ret; [[buflen]] -= ret; CLOSE_CURLY_TOKEN Qcow2Feature [[features]]OPEN_SQUARE_TOKENCLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN; ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE, [[features]], sizeof([[features]]), [[buflen]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN buf += ret; [[buflen]] -= ret; QLIST_FOREACH(uext, &s-GREATER_TOKENunknown_header_ext, next) OPEN_CURLY_TOKEN ret = header_ext_add(buf, uext-GREATER_TOKENmagic, uext-GREATER_TOKENdata, uext-GREATER_TOKENlen, [[buflen]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN buf += ret; [[buflen]] -= ret; CLOSE_CURLY_TOKEN ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, [[buflen]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN buf += ret; [[buflen]] -= ret; if (*bs-GREATER_TOKENbacking_file) OPEN_CURLY_TOKEN size_t backing_file_len = strlen(bs-GREATER_TOKENbacking_file); if ([[buflen]] SMALLER_TOKEN backing_file_len) OPEN_CURLY_TOKEN ret = -ENOSPC; goto fail; CLOSE_CURLY_TOKEN strncpy(buf, bs-GREATER_TOKENbacking_file, [[buflen]]); header-GREATER_TOKENbacking_file_offset = cpu_to_be64(buf - ((char*) header)); header-GREATER_TOKENbacking_file_size = cpu_to_be32(backing_file_len); CLOSE_CURLY_TOKEN ret = bdrv_pwrite(bs-GREATER_TOKENfile, 0, header, s-GREATER_TOKENcluster_size); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN ret = 0; fail: qemu_vfree(header); return ret; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int qcow2_update_header(BlockDriverState *bs) OPEN_CURLY_TOKEN BDRVQcowState *s = bs-GREATER_TOKENopaque; QCowHeader *header; char *buf; size_t [[painstaking]] = s-GREATER_TOKENcluster_size; int ret; uint64_t total_size; uint32_t refcount_table_clusters; size_t header_length; Qcow2UnknownHeaderExtension *uext; buf = qemu_blockalign(bs, [[painstaking]]); header = (QCowHeader*) buf; if ([[painstaking]] SMALLER_TOKEN sizeof(*header)) OPEN_CURLY_TOKEN ret = -ENOSPC; goto fail; CLOSE_CURLY_TOKEN header_length = sizeof(*header) + s-GREATER_TOKENunknown_header_fields_size; total_size = bs-GREATER_TOKENtotal_sectors * BDRV_SECTOR_SIZE; refcount_table_clusters = s-GREATER_TOKENrefcount_table_size GREATER_TOKENGREATER_TOKEN (s-GREATER_TOKENcluster_bits - 3); *header = (QCowHeader) OPEN_CURLY_TOKEN .magic = cpu_to_be32(QCOW_MAGIC), .version = cpu_to_be32(s-GREATER_TOKENqcow_version), .backing_file_offset = 0, .backing_file_size = 0, .cluster_bits = cpu_to_be32(s-GREATER_TOKENcluster_bits), .size = cpu_to_be64(total_size), .crypt_method = cpu_to_be32(s-GREATER_TOKENcrypt_method_header), .l1_size = cpu_to_be32(s-GREATER_TOKENl1_size), .l1_table_offset = cpu_to_be64(s-GREATER_TOKENl1_table_offset), .refcount_table_offset = cpu_to_be64(s-GREATER_TOKENrefcount_table_offset), .refcount_table_clusters = cpu_to_be32(refcount_table_clusters), .nb_snapshots = cpu_to_be32(s-GREATER_TOKENnb_snapshots), .snapshots_offset = cpu_to_be64(s-GREATER_TOKENsnapshots_offset), .incompatible_features = cpu_to_be64(s-GREATER_TOKENincompatible_features), .compatible_features = cpu_to_be64(s-GREATER_TOKENcompatible_features), .autoclear_features = cpu_to_be64(s-GREATER_TOKENautoclear_features), .refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT), .header_length = cpu_to_be32(header_length), CLOSE_CURLY_TOKEN; switch (s-GREATER_TOKENqcow_version) OPEN_CURLY_TOKEN case 2: ret = offsetof(QCowHeader, incompatible_features); break; case 3: ret = sizeof(*header); break; default: return -EINVAL; CLOSE_CURLY_TOKEN buf += ret; [[painstaking]] -= ret; memset(buf, 0, [[painstaking]]); if (s-GREATER_TOKENunknown_header_fields_size) OPEN_CURLY_TOKEN if ([[painstaking]] SMALLER_TOKEN s-GREATER_TOKENunknown_header_fields_size) OPEN_CURLY_TOKEN ret = -ENOSPC; goto fail; CLOSE_CURLY_TOKEN memcpy(buf, s-GREATER_TOKENunknown_header_fields, s-GREATER_TOKENunknown_header_fields_size); buf += s-GREATER_TOKENunknown_header_fields_size; [[painstaking]] -= s-GREATER_TOKENunknown_header_fields_size; CLOSE_CURLY_TOKEN if (*bs-GREATER_TOKENbacking_format) OPEN_CURLY_TOKEN ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT, bs-GREATER_TOKENbacking_format, strlen(bs-GREATER_TOKENbacking_format), [[painstaking]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN buf += ret; [[painstaking]] -= ret; CLOSE_CURLY_TOKEN Qcow2Feature [[untiring]]OPEN_SQUARE_TOKENCLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN; ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE, [[untiring]], sizeof([[untiring]]), [[painstaking]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN buf += ret; [[painstaking]] -= ret; QLIST_FOREACH(uext, &s-GREATER_TOKENunknown_header_ext, next) OPEN_CURLY_TOKEN ret = header_ext_add(buf, uext-GREATER_TOKENmagic, uext-GREATER_TOKENdata, uext-GREATER_TOKENlen, [[painstaking]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN buf += ret; [[painstaking]] -= ret; CLOSE_CURLY_TOKEN ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, [[painstaking]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN buf += ret; [[painstaking]] -= ret; if (*bs-GREATER_TOKENbacking_file) OPEN_CURLY_TOKEN size_t backing_file_len = strlen(bs-GREATER_TOKENbacking_file); if ([[painstaking]] SMALLER_TOKEN backing_file_len) OPEN_CURLY_TOKEN ret = -ENOSPC; goto fail; CLOSE_CURLY_TOKEN strncpy(buf, bs-GREATER_TOKENbacking_file, [[painstaking]]); header-GREATER_TOKENbacking_file_offset = cpu_to_be64(buf - ((char*) header)); header-GREATER_TOKENbacking_file_size = cpu_to_be32(backing_file_len); CLOSE_CURLY_TOKEN ret = bdrv_pwrite(bs-GREATER_TOKENfile, 0, header, s-GREATER_TOKENcluster_size); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; CLOSE_CURLY_TOKEN ret = 0; fail: qemu_vfree(header); return ret; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 32 / 11 / 31 / 74:   3%|         | 74/2690 [00:00<00:01, 2458.62it/s][Succeeded / Failed / Skipped / Total] 32 / 11 / 32 / 75:   3%|         | 75/2690 [00:00<00:01, 2474.28it/s][Succeeded / Failed / Skipped / Total] 32 / 12 / 32 / 76:   3%|         | 76/2690 [00:00<00:01, 2482.67it/s][Succeeded / Failed / Skipped / Total] 32 / 12 / 33 / 77:   3%|         | 77/2690 [00:00<00:01, 2498.83it/s][Succeeded / Failed / Skipped / Total] 32 / 12 / 34 / 78:   3%|         | 78/2690 [00:00<00:01, 2513.89it/s][Succeeded / Failed / Skipped / Total] 33 / 12 / 34 / 79:   3%|         | 79/2690 [00:00<00:01, 2518.28it/s][Succeeded / Failed / Skipped / Total] 34 / 12 / 34 / 80:   3%|         | 80/2690 [00:00<00:01, 2520.33it/s]
--------------------------------------------- Result 75 ---------------------------------------------
[[0 (97%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bios_linker_loader_alloc(GArray *linker, const char *file, uint32_t alloc_align, bool alloc_fseg) OPEN_CURLY_TOKEN BiosLinkerLoaderEntry entry; assert(!(alloc_align & (alloc_align - 1))); memset(&entry, 0, sizeof entry); strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1); entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE); entry.alloc.align = cpu_to_le32(alloc_align); entry.alloc.zone = cpu_to_le32(alloc_fseg ? BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG : BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH); g_array_prepend_vals(linker, &entry, sizeof entry); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 76 ---------------------------------------------
[[1 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void do_POWER_maskg (void) OPEN_CURLY_TOKEN uint32_t [[ret]]; if ((uint32_t)T0 == (uint32_t)(T1 + 1)) OPEN_CURLY_TOKEN [[ret]] = -1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN [[ret]] = (((uint32_t)(-1)) GREATER_TOKENGREATER_TOKEN ((uint32_t)T0)) ^ (((uint32_t)(-1) GREATER_TOKENGREATER_TOKEN ((uint32_t)T1)) GREATER_TOKENGREATER_TOKEN 1); if ((uint32_t)T0 GREATER_TOKEN (uint32_t)T1) [[ret]] = ~[[ret]]; CLOSE_CURLY_TOKEN T0 = [[ret]]; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void do_POWER_maskg (void) OPEN_CURLY_TOKEN uint32_t [[contractors]]; if ((uint32_t)T0 == (uint32_t)(T1 + 1)) OPEN_CURLY_TOKEN [[contractors]] = -1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN [[contractors]] = (((uint32_t)(-1)) GREATER_TOKENGREATER_TOKEN ((uint32_t)T0)) ^ (((uint32_t)(-1) GREATER_TOKENGREATER_TOKEN ((uint32_t)T1)) GREATER_TOKENGREATER_TOKEN 1); if ((uint32_t)T0 GREATER_TOKEN (uint32_t)T1) [[contractors]] = ~[[contractors]]; CLOSE_CURLY_TOKEN T0 = [[contractors]]; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 77 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr, uint64_t value, unsigned size, MemTxAttrs attrs) OPEN_CURLY_TOKEN int ret = 0; MSIMessage from = OPEN_CURLY_TOKEN0CLOSE_CURLY_TOKEN, to = OPEN_CURLY_TOKEN0CLOSE_CURLY_TOKEN; from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST; from.data = (uint32_t) value; ret = vtd_interrupt_remap_msi(opaque, &from, &to); if (ret) OPEN_CURLY_TOKEN VTD_DPRINTF(GENERAL, "int remap fail for addr 0x%"PRIx64 " data 0x%"PRIx32, from.address, from.data); return MEMTX_ERROR; CLOSE_CURLY_TOKEN VTD_DPRINTF(IR, "delivering MSI 0x%"PRIx64":0x%"PRIx32 " for device sid 0x%04x", to.address, to.data, sid); if (dma_memory_write(&address_space_memory, to.address, &to.data, size)) OPEN_CURLY_TOKEN VTD_DPRINTF(GENERAL, "error: fail to write 0x%"PRIx64 " value 0x%"PRIx32, to.address, to.data); CLOSE_CURLY_TOKEN return MEMTX_OK; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 78 ---------------------------------------------
[[0 (79%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_write_data(SCSIRequest *req) OPEN_CURLY_TOKEN SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r-GREATER_TOKENreq.dev); uint32_t n; assert(r-GREATER_TOKENreq.aiocb == NULL); scsi_req_ref(&r-GREATER_TOKENreq); if (r-GREATER_TOKENreq.cmd.mode != SCSI_XFER_TO_DEV) OPEN_CURLY_TOKEN DPRINTF("Data transfer direction invalid\n"); scsi_write_complete(r, -EINVAL); return; CLOSE_CURLY_TOKEN if (!r-GREATER_TOKENreq.sg && !r-GREATER_TOKENqiov.size) OPEN_CURLY_TOKEN r-GREATER_TOKENstarted = "True" == "True"; scsi_write_complete(r, 0); return; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENtray_open) OPEN_CURLY_TOKEN scsi_write_complete(r, -ENOMEDIUM); return; CLOSE_CURLY_TOKEN if (r-GREATER_TOKENreq.cmd.bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == VERIFY_10 || r-GREATER_TOKENreq.cmd.bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == VERIFY_12 || r-GREATER_TOKENreq.cmd.bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == VERIFY_16) OPEN_CURLY_TOKEN if (r-GREATER_TOKENreq.sg) OPEN_CURLY_TOKEN scsi_dma_complete(r, 0); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN scsi_write_complete(r, 0); CLOSE_CURLY_TOKEN return; CLOSE_CURLY_TOKEN if (r-GREATER_TOKENreq.sg) OPEN_CURLY_TOKEN dma_acct_start(s-GREATER_TOKENqdev.conf.bs, &r-GREATER_TOKENacct, r-GREATER_TOKENreq.sg, BDRV_ACCT_WRITE); r-GREATER_TOKENreq.resid -= r-GREATER_TOKENreq.sg-GREATER_TOKENsize; r-GREATER_TOKENreq.aiocb = dma_bdrv_write(s-GREATER_TOKENqdev.conf.bs, r-GREATER_TOKENreq.sg, r-GREATER_TOKENsector, scsi_dma_complete, r); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN n = r-GREATER_TOKENqiov.size / 512; bdrv_acct_start(s-GREATER_TOKENqdev.conf.bs, &r-GREATER_TOKENacct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE); r-GREATER_TOKENreq.aiocb = bdrv_aio_writev(s-GREATER_TOKENqdev.conf.bs, r-GREATER_TOKENsector, &r-GREATER_TOKENqiov, n, scsi_write_complete, r); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 79 ---------------------------------------------
[[1 (58%)]] --> [[0 (66%)]] --> Socre: 0.6637418866157532

[[[[Adv]]]]: FFTContext *av_fft_init(int [[nbits]], int inverse) OPEN_CURLY_TOKEN FFTContext *s = av_malloc(sizeof(*s)); if (s && ff_fft_init(s, [[nbits]], inverse)) av_freep(&s); return s; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: FFTContext *av_fft_init(int [[tycoon]], int inverse) OPEN_CURLY_TOKEN FFTContext *s = av_malloc(sizeof(*s)); if (s && ff_fft_init(s, [[tycoon]], inverse)) av_freep(&s); return s; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 80 ---------------------------------------------
[[1 (95%)]] --> [[0 (56%)]] --> Socre: 0.5620265007019043

[[[[Adv]]]]: static void idiv64(uint64_t *[[plow]], uint64_t *[[phigh]], int64_t [[b]]) OPEN_CURLY_TOKEN int [[sa]], sb; [[sa]] = ((int64_t)*[[phigh]] SMALLER_TOKEN 0); if ([[sa]]) neg128([[plow]], [[phigh]]); sb = ([[b]] SMALLER_TOKEN 0); if (sb) [[b]] = -[[b]]; div64([[plow]], [[phigh]], [[b]]); if ([[sa]] ^ sb) *[[plow]] = - *[[plow]]; if ([[sa]]) *[[phigh]] = - *[[phigh]]; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void idiv64(uint64_t *[[methyl]], uint64_t *[[are]], int64_t [[evidence]]) OPEN_CURLY_TOKEN int [[saso]], sb; [[saso]] = ((int64_t)*[[are]] SMALLER_TOKEN 0); if ([[saso]]) neg128([[methyl]], [[are]]); sb = ([[evidence]] SMALLER_TOKEN 0); if (sb) [[evidence]] = -[[evidence]]; div64([[methyl]], [[are]], [[evidence]]); if ([[saso]] ^ sb) *[[methyl]] = - *[[methyl]]; if ([[saso]]) *[[are]] = - *[[are]]; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 81 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 35 / 12 / 34 / 81:   3%|         | 81/2690 [00:00<00:01, 2515.73it/s][Succeeded / Failed / Skipped / Total] 35 / 13 / 34 / 82:   3%|         | 82/2690 [00:00<00:01, 2521.28it/s][Succeeded / Failed / Skipped / Total] 35 / 13 / 35 / 83:   3%|         | 83/2690 [00:00<00:01, 2536.93it/s][Succeeded / Failed / Skipped / Total] 36 / 13 / 35 / 84:   3%|         | 84/2690 [00:00<00:01, 2533.03it/s][[1 (75%)]] --> [[0 (53%)]] --> Socre: 0.5287928581237793

[[[[Adv]]]]: static void qed_aio_read_data(void *opaque, int ret, uint64_t offset, size_t [[len]]) OPEN_CURLY_TOKEN QEDAIOCB *acb = opaque; BDRVQEDState *s = acb_to_s(acb); BlockDriverState *bs = acb-GREATER_TOKENcommon.bs; offset += qed_offset_into_cluster(s, acb-GREATER_TOKENcur_pos); trace_qed_aio_read_data(s, acb, ret, offset, [[len]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto err; CLOSE_CURLY_TOKEN qemu_iovec_concat(&acb-GREATER_TOKENcur_qiov, acb-GREATER_TOKENqiov, acb-GREATER_TOKENqiov_offset, [[len]]); if (ret == QED_CLUSTER_ZERO) OPEN_CURLY_TOKEN qemu_iovec_memset(&acb-GREATER_TOKENcur_qiov, 0, 0, acb-GREATER_TOKENcur_qiov.size); qed_aio_next_io(acb, 0); return; CLOSE_CURLY_TOKEN else if (ret != QED_CLUSTER_FOUND) OPEN_CURLY_TOKEN qed_read_backing_file(s, acb-GREATER_TOKENcur_pos, &acb-GREATER_TOKENcur_qiov, qed_aio_next_io, acb); return; CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_READ_AIO); bdrv_aio_readv(bs-GREATER_TOKENfile, offset / BDRV_SECTOR_SIZE, &acb-GREATER_TOKENcur_qiov, acb-GREATER_TOKENcur_qiov.size / BDRV_SECTOR_SIZE, qed_aio_next_io, acb); return; err: qed_aio_complete(acb, ret); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void qed_aio_read_data(void *opaque, int ret, uint64_t offset, size_t [[ntl]]) OPEN_CURLY_TOKEN QEDAIOCB *acb = opaque; BDRVQEDState *s = acb_to_s(acb); BlockDriverState *bs = acb-GREATER_TOKENcommon.bs; offset += qed_offset_into_cluster(s, acb-GREATER_TOKENcur_pos); trace_qed_aio_read_data(s, acb, ret, offset, [[ntl]]); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto err; CLOSE_CURLY_TOKEN qemu_iovec_concat(&acb-GREATER_TOKENcur_qiov, acb-GREATER_TOKENqiov, acb-GREATER_TOKENqiov_offset, [[ntl]]); if (ret == QED_CLUSTER_ZERO) OPEN_CURLY_TOKEN qemu_iovec_memset(&acb-GREATER_TOKENcur_qiov, 0, 0, acb-GREATER_TOKENcur_qiov.size); qed_aio_next_io(acb, 0); return; CLOSE_CURLY_TOKEN else if (ret != QED_CLUSTER_FOUND) OPEN_CURLY_TOKEN qed_read_backing_file(s, acb-GREATER_TOKENcur_pos, &acb-GREATER_TOKENcur_qiov, qed_aio_next_io, acb); return; CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_READ_AIO); bdrv_aio_readv(bs-GREATER_TOKENfile, offset / BDRV_SECTOR_SIZE, &acb-GREATER_TOKENcur_qiov, acb-GREATER_TOKENcur_qiov.size / BDRV_SECTOR_SIZE, qed_aio_next_io, acb); return; err: qed_aio_complete(acb, ret); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 82 ---------------------------------------------
[[1 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void gen_set_CF_bit31(TCGv [[var]]) OPEN_CURLY_TOKEN TCGv [[tmp]] = new_tmp(); tcg_gen_shri_i32([[tmp]], [[var]], 31); gen_set_CF([[tmp]]); dead_tmp([[tmp]]); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void gen_set_CF_bit31(TCGv [[pena]]) OPEN_CURLY_TOKEN TCGv [[organize]] = new_tmp(); tcg_gen_shri_i32([[organize]], [[pena]], 31); gen_set_CF([[organize]]); dead_tmp([[organize]]); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 83 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static AVStream * init_stream(AVFormatContext *s) OPEN_CURLY_TOKEN BinDemuxContext *bin = s-GREATER_TOKENpriv_data; AVStream *st = avformat_new_stream(s, NULL); if (!st) return NULL; st-GREATER_TOKENcodec-GREATER_TOKENcodec_tag = 0; st-GREATER_TOKENcodec-GREATER_TOKENcodec_type = AVMEDIA_TYPE_VIDEO; if (!bin-GREATER_TOKENwidth) OPEN_CURLY_TOKEN st-GREATER_TOKENcodec-GREATER_TOKENwidth = (80SMALLER_TOKENSMALLER_TOKEN3); st-GREATER_TOKENcodec-GREATER_TOKENheight = (25SMALLER_TOKENSMALLER_TOKEN4); CLOSE_CURLY_TOKEN avpriv_set_pts_info(st, 60, bin-GREATER_TOKENframerate.den, bin-GREATER_TOKENframerate.num); bin-GREATER_TOKENchars_per_frame = FFMAX(av_q2d(st-GREATER_TOKENtime_base) * bin-GREATER_TOKENchars_per_frame, 1); return st; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 84 ---------------------------------------------
[[0 (74%)]] --> [[1 (56%)]] --> Socre: 0.5614638924598694

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *[[dev]], BlockConf *[[conf]], char **[[serial]]) OPEN_CURLY_TOKEN VirtIOBlock *s; int [[cylinders]], heads, secs; static int virtio_blk_id; DriveInfo *[[dinfo]]; if (![[conf]]-GREATER_TOKENbs) OPEN_CURLY_TOKEN error_report("virtio-blk-pci: drive property not set"); return NULL; CLOSE_CURLY_TOKEN if (!bdrv_is_inserted([[conf]]-GREATER_TOKENbs)) OPEN_CURLY_TOKEN error_report("Device needs media, but drive is empty"); return NULL; CLOSE_CURLY_TOKEN if (!*[[serial]]) OPEN_CURLY_TOKEN [[dinfo]] = drive_get_by_blockdev([[conf]]-GREATER_TOKENbs); if (*[[dinfo]]-GREATER_TOKENserial) OPEN_CURLY_TOKEN *[[serial]] = strdup([[dinfo]]-GREATER_TOKENserial); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); s-GREATER_TOKENvdev.get_config = virtio_blk_update_config; s-GREATER_TOKENvdev.get_features = virtio_blk_get_features; s-GREATER_TOKENvdev.reset = virtio_blk_reset; s-GREATER_TOKENbs = [[conf]]-GREATER_TOKENbs; s-GREATER_TOKENconf = [[conf]]; s-GREATER_TOKENserial = *[[serial]]; s-GREATER_TOKENrq = NULL; s-GREATER_TOKENsector_mask = (s-GREATER_TOKENconf-GREATER_TOKENlogical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry(s-GREATER_TOKENbs, &[[cylinders]], &heads, &secs); s-GREATER_TOKENvq = virtio_add_queue(&s-GREATER_TOKENvdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s); s-GREATER_TOKENqdev = [[dev]]; register_savevm([[dev]], "virtio-blk", virtio_blk_id++, 2, virtio_blk_save, virtio_blk_load, s); bdrv_set_dev_ops(s-GREATER_TOKENbs, &virtio_block_ops, s); bdrv_set_buffer_alignment(s-GREATER_TOKENbs, [[conf]]-GREATER_TOKENlogical_block_size); bdrv_iostatus_enable(s-GREATER_TOKENbs); add_boot_device_path([[conf]]-GREATER_TOKENbootindex, [[dev]], "/disk@0,0"); return &s-GREATER_TOKENvdev; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *[[presenting]], BlockConf *[[uri]], char **[[thwart]]) OPEN_CURLY_TOKEN VirtIOBlock *s; int [[backfires]], heads, secs; static int virtio_blk_id; DriveInfo *[[scammed]]; if (![[uri]]-GREATER_TOKENbs) OPEN_CURLY_TOKEN error_report("virtio-blk-pci: drive property not set"); return NULL; CLOSE_CURLY_TOKEN if (!bdrv_is_inserted([[uri]]-GREATER_TOKENbs)) OPEN_CURLY_TOKEN error_report("Device needs media, but drive is empty"); return NULL; CLOSE_CURLY_TOKEN if (!*[[thwart]]) OPEN_CURLY_TOKEN [[scammed]] = drive_get_by_blockdev([[uri]]-GREATER_TOKENbs); if (*[[scammed]]-GREATER_TOKENserial) OPEN_CURLY_TOKEN *[[thwart]] = strdup([[scammed]]-GREATER_TOKENserial); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); s-GREATER_TOKENvdev.get_config = virtio_blk_update_config; s-GREATER_TOKENvdev.get_features = virtio_blk_get_features; s-GREATER_TOKENvdev.reset = virtio_blk_reset; s-GREATER_TOKENbs = [[uri]]-GREATER_TOKENbs; s-GREATER_TOKENconf = [[uri]]; s-GREATER_TOKENserial = *[[thwart]]; s-GREATER_TOKENrq = NULL; s-GREATER_TOKENsector_mask = (s-GREATER_TOKENconf-GREATER_TOKENlogical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry(s-GREATER_TOKENbs, &[[backfires]], &heads, &secs); s-GREATER_TOKENvq = virtio_add_queue(&s-GREATER_TOKENvdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s); s-GREATER_TOKENqdev = [[presenting]]; register_savevm([[presenting]], "virtio-blk", virtio_blk_id++, 2, virtio_blk_save, virtio_blk_load, s); bdrv_set_dev_ops(s-GREATER_TOKENbs, &virtio_block_ops, s); bdrv_set_buffer_alignment(s-GREATER_TOKENbs, [[uri]]-GREATER_TOKENlogical_block_size); bdrv_iostatus_enable(s-GREATER_TOKENbs); add_boot_device_path([[uri]]-GREATER_TOKENbootindex, [[presenting]], "/disk@0,0"); return &s-GREATER_TOKENvdev; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 85 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 36 / 13 / 36 / 85:   3%|         | 85/2690 [00:00<00:01, 2545.40it/s][Succeeded / Failed / Skipped / Total] 37 / 13 / 36 / 86:   3%|         | 86/2690 [00:00<00:01, 2546.99it/s][Succeeded / Failed / Skipped / Total] 38 / 13 / 36 / 87:   3%|         | 87/2690 [00:00<00:01, 2543.10it/s][Succeeded / Failed / Skipped / Total] 38 / 13 / 37 / 88:   3%|         | 88/2690 [00:00<00:01, 2556.30it/s][[1 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info) OPEN_CURLY_TOKEN BDRVSheepdogState *s = bs-GREATER_TOKENopaque; int ret, fd; uint32_t new_vid; SheepdogInode *inode; unsigned int datalen; dprintf("sn_info: name %s id_str %s s: name %s vm_state_size %" PRId64 " " "is_snapshot %d\n", sn_info-GREATER_TOKENname, sn_info-GREATER_TOKENid_str, s-GREATER_TOKENname, sn_info-GREATER_TOKENvm_state_size, s-GREATER_TOKENis_snapshot); if (s-GREATER_TOKENis_snapshot) OPEN_CURLY_TOKEN error_report("You can't create a snapshot of a snapshot VDI, " "%s (%" PRIu32 ").", s-GREATER_TOKENname, s-GREATER_TOKENinode.vdi_id); return -EINVAL; CLOSE_CURLY_TOKEN dprintf("%s %s\n", sn_info-GREATER_TOKENname, sn_info-GREATER_TOKENid_str); s-GREATER_TOKENinode.vm_state_size = sn_info-GREATER_TOKENvm_state_size; s-GREATER_TOKENinode.vm_clock_nsec = sn_info-GREATER_TOKENvm_clock_nsec; strncpy(s-GREATER_TOKENinode.tag, sn_info-GREATER_TOKENname, sizeof(s-GREATER_TOKENinode.tag)); datalen = SD_INODE_SIZE - sizeof(s-GREATER_TOKENinode.data_vdi_id); fd = connect_to_sdog(s-GREATER_TOKENaddr, s-GREATER_TOKENport); if (fd SMALLER_TOKEN 0) OPEN_CURLY_TOKEN ret = fd; goto cleanup; CLOSE_CURLY_TOKEN ret = write_object(fd, (char *)&s-GREATER_TOKENinode, vid_to_vdi_oid(s-GREATER_TOKENinode.vdi_id), s-GREATER_TOKENinode.nr_copies, datalen, 0, "False" != "False", s-GREATER_TOKENcache_enabled); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN error_report("failed to write snapshot's inode."); goto cleanup; CLOSE_CURLY_TOKEN ret = do_sd_create(s-GREATER_TOKENname, s-GREATER_TOKENinode.vdi_size, s-GREATER_TOKENinode.vdi_id, &new_vid, 1, s-GREATER_TOKENaddr, s-GREATER_TOKENport); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN error_report("failed to create inode for snapshot. %s", strerror(errno)); goto cleanup; CLOSE_CURLY_TOKEN inode = (SheepdogInode *)g_malloc(datalen); ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid), s-GREATER_TOKENinode.nr_copies, datalen, 0, s-GREATER_TOKENcache_enabled); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN error_report("failed to read new inode info. %s", strerror(errno)); goto cleanup; CLOSE_CURLY_TOKEN memcpy(&s-GREATER_TOKENinode, inode, datalen); dprintf("s-GREATER_TOKENinode: name %s snap_id %x oid %x\n", s-GREATER_TOKENinode.name, s-GREATER_TOKENinode.snap_id, s-GREATER_TOKENinode.vdi_id); cleanup: closesocket(fd); return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 86 ---------------------------------------------
[[0 (95%)]] --> [[1 (53%)]] --> Socre: 0.5294671058654785

[[[[Adv]]]]: static void virtio_9p_device_unrealize(DeviceState *dev, Error **[[errp]]) OPEN_CURLY_TOKEN VirtIODevice *vdev = VIRTIO_DEVICE(dev); V9fsVirtioState *v = VIRTIO_9P(dev); V9fsState *[[s]] = &v-GREATER_TOKENstate; virtio_cleanup(vdev); v9fs_device_unrealize_common([[s]], [[errp]]); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void virtio_9p_device_unrealize(DeviceState *dev, Error **[[incorrigible]]) OPEN_CURLY_TOKEN VirtIODevice *vdev = VIRTIO_DEVICE(dev); V9fsVirtioState *v = VIRTIO_9P(dev); V9fsState *[[tomorrow]] = &v-GREATER_TOKENstate; virtio_cleanup(vdev); v9fs_device_unrealize_common([[tomorrow]], [[incorrigible]]); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 87 ---------------------------------------------
[[0 (58%)]] --> [[1 (61%)]] --> Socre: 0.6064567565917969

[[[[Adv]]]]: static int vnc_display_listen(VncDisplay *vd, SocketAddress **saddr, size_t nsaddr, SocketAddress **wsaddr, size_t nwsaddr, Error **errp) OPEN_CURLY_TOKEN size_t [[i]]; for ([[i]] = 0; [[i]] SMALLER_TOKEN nsaddr; [[i]]++) OPEN_CURLY_TOKEN if (vnc_display_listen_addr(vd, saddrOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN, "vnc-listen", &vd-GREATER_TOKENlsock, &vd-GREATER_TOKENlsock_tag, &vd-GREATER_TOKENnlsock, errp) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for ([[i]] = 0; [[i]] SMALLER_TOKEN nwsaddr; [[i]]++) OPEN_CURLY_TOKEN if (vnc_display_listen_addr(vd, wsaddrOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN, "vnc-ws-listen", &vd-GREATER_TOKENlwebsock, &vd-GREATER_TOKENlwebsock_tag, &vd-GREATER_TOKENnlwebsock, errp) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int vnc_display_listen(VncDisplay *vd, SocketAddress **saddr, size_t nsaddr, SocketAddress **wsaddr, size_t nwsaddr, Error **errp) OPEN_CURLY_TOKEN size_t [[horseshoes]]; for ([[horseshoes]] = 0; [[horseshoes]] SMALLER_TOKEN nsaddr; [[horseshoes]]++) OPEN_CURLY_TOKEN if (vnc_display_listen_addr(vd, saddrOPEN_SQUARE_TOKEN[[horseshoes]]CLOSE_SQUARE_TOKEN, "vnc-listen", &vd-GREATER_TOKENlsock, &vd-GREATER_TOKENlsock_tag, &vd-GREATER_TOKENnlsock, errp) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for ([[horseshoes]] = 0; [[horseshoes]] SMALLER_TOKEN nwsaddr; [[horseshoes]]++) OPEN_CURLY_TOKEN if (vnc_display_listen_addr(vd, wsaddrOPEN_SQUARE_TOKEN[[horseshoes]]CLOSE_SQUARE_TOKEN, "vnc-ws-listen", &vd-GREATER_TOKENlwebsock, &vd-GREATER_TOKENlwebsock_tag, &vd-GREATER_TOKENnlwebsock, errp) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 88 ---------------------------------------------
[[0 (92%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num, int nb_sectors, QEMUIOVector *qiov) OPEN_CURLY_TOKEN SheepdogAIOCB *acb; int ret; if (bs-GREATER_TOKENgrowable && sector_num + nb_sectors GREATER_TOKEN bs-GREATER_TOKENtotal_sectors) OPEN_CURLY_TOKEN ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN bs-GREATER_TOKENtotal_sectors = sector_num + nb_sectors; CLOSE_CURLY_TOKEN acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors); acb-GREATER_TOKENaio_done_func = sd_write_done; acb-GREATER_TOKENaiocb_type = AIOCB_WRITE_UDATA; ret = sd_co_rw_vector(acb); if (ret SMALLER_TOKEN= 0) OPEN_CURLY_TOKEN qemu_aio_release(acb); return ret; CLOSE_CURLY_TOKEN qemu_coroutine_yield(); return acb-GREATER_TOKENret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 89 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 39 / 13 / 37 / 89:   3%|         | 89/2690 [00:00<00:01, 2530.39it/s][Succeeded / Failed / Skipped / Total] 39 / 13 / 38 / 90:   3%|         | 90/2690 [00:00<00:01, 2543.08it/s][[1 (89%)]] --> [[0 (53%)]] --> Socre: 0.5278473496437073

[[[[Adv]]]]: static void integratorcp_init(QEMUMachineInitArgs *args) OPEN_CURLY_TOKEN ram_addr_t ram_size = args-GREATER_TOKENram_size; const char *cpu_model = args-GREATER_TOKENcpu_model; const char *kernel_filename = args-GREATER_TOKENkernel_filename; const char *kernel_cmdline = args-GREATER_TOKENkernel_cmdline; const char *initrd_filename = args-GREATER_TOKENinitrd_filename; ARMCPU *[[cpu]]; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *ram_alias = g_new(MemoryRegion, 1); qemu_irq picOPEN_SQUARE_TOKEN32CLOSE_SQUARE_TOKEN; DeviceState *dev; int i; if (!cpu_model) OPEN_CURLY_TOKEN cpu_model = "arm926"; CLOSE_CURLY_TOKEN [[cpu]] = cpu_arm_init(cpu_model); if (![[cpu]]) OPEN_CURLY_TOKEN fprintf(stderr, "Unable to find CPU definition\n"); exit(1); CLOSE_CURLY_TOKEN memory_region_init_ram(ram, NULL, "integrator.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0, ram); memory_region_init_alias(ram_alias, NULL, "ram.alias", ram, 0, ram_size); memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias); dev = qdev_create(NULL, TYPE_INTEGRATOR_CM); qdev_prop_set_uint32(dev, "memsz", ram_size GREATER_TOKENGREATER_TOKEN 20); qdev_init_nofail(dev); sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000); dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000, qdev_get_gpio_in(DEVICE([[cpu]]), ARM_CPU_IRQ), qdev_get_gpio_in(DEVICE([[cpu]]), ARM_CPU_FIQ), NULL); for (i = 0; i SMALLER_TOKEN 32; i++) OPEN_CURLY_TOKEN picOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = qdev_get_gpio_in(dev, i); CLOSE_CURLY_TOKEN sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, picOPEN_SQUARE_TOKEN26CLOSE_SQUARE_TOKEN); sysbus_create_varargs("integrator_pit", 0x13000000, picOPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN, picOPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN, picOPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKEN, NULL); sysbus_create_simple("pl031", 0x15000000, picOPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN); sysbus_create_simple("pl011", 0x16000000, picOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN); sysbus_create_simple("pl011", 0x17000000, picOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN); icp_control_init(0xcb000000); sysbus_create_simple("pl050_keyboard", 0x18000000, picOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN); sysbus_create_simple("pl050_mouse", 0x19000000, picOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN); sysbus_create_varargs("pl181", 0x1c000000, picOPEN_SQUARE_TOKEN23CLOSE_SQUARE_TOKEN, picOPEN_SQUARE_TOKEN24CLOSE_SQUARE_TOKEN, NULL); if (nd_tableOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.used) smc91c111_init(&nd_tableOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, 0xc8000000, picOPEN_SQUARE_TOKEN27CLOSE_SQUARE_TOKEN); sysbus_create_simple("pl110", 0xc0000000, picOPEN_SQUARE_TOKEN22CLOSE_SQUARE_TOKEN); integrator_binfo.ram_size = ram_size; integrator_binfo.kernel_filename = kernel_filename; integrator_binfo.kernel_cmdline = kernel_cmdline; integrator_binfo.initrd_filename = initrd_filename; arm_load_kernel([[cpu]], &integrator_binfo); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void integratorcp_init(QEMUMachineInitArgs *args) OPEN_CURLY_TOKEN ram_addr_t ram_size = args-GREATER_TOKENram_size; const char *cpu_model = args-GREATER_TOKENcpu_model; const char *kernel_filename = args-GREATER_TOKENkernel_filename; const char *kernel_cmdline = args-GREATER_TOKENkernel_cmdline; const char *initrd_filename = args-GREATER_TOKENinitrd_filename; ARMCPU *[[snappy]]; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *ram_alias = g_new(MemoryRegion, 1); qemu_irq picOPEN_SQUARE_TOKEN32CLOSE_SQUARE_TOKEN; DeviceState *dev; int i; if (!cpu_model) OPEN_CURLY_TOKEN cpu_model = "arm926"; CLOSE_CURLY_TOKEN [[snappy]] = cpu_arm_init(cpu_model); if (![[snappy]]) OPEN_CURLY_TOKEN fprintf(stderr, "Unable to find CPU definition\n"); exit(1); CLOSE_CURLY_TOKEN memory_region_init_ram(ram, NULL, "integrator.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0, ram); memory_region_init_alias(ram_alias, NULL, "ram.alias", ram, 0, ram_size); memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias); dev = qdev_create(NULL, TYPE_INTEGRATOR_CM); qdev_prop_set_uint32(dev, "memsz", ram_size GREATER_TOKENGREATER_TOKEN 20); qdev_init_nofail(dev); sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000); dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000, qdev_get_gpio_in(DEVICE([[snappy]]), ARM_CPU_IRQ), qdev_get_gpio_in(DEVICE([[snappy]]), ARM_CPU_FIQ), NULL); for (i = 0; i SMALLER_TOKEN 32; i++) OPEN_CURLY_TOKEN picOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = qdev_get_gpio_in(dev, i); CLOSE_CURLY_TOKEN sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, picOPEN_SQUARE_TOKEN26CLOSE_SQUARE_TOKEN); sysbus_create_varargs("integrator_pit", 0x13000000, picOPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN, picOPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN, picOPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKEN, NULL); sysbus_create_simple("pl031", 0x15000000, picOPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN); sysbus_create_simple("pl011", 0x16000000, picOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN); sysbus_create_simple("pl011", 0x17000000, picOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN); icp_control_init(0xcb000000); sysbus_create_simple("pl050_keyboard", 0x18000000, picOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN); sysbus_create_simple("pl050_mouse", 0x19000000, picOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN); sysbus_create_varargs("pl181", 0x1c000000, picOPEN_SQUARE_TOKEN23CLOSE_SQUARE_TOKEN, picOPEN_SQUARE_TOKEN24CLOSE_SQUARE_TOKEN, NULL); if (nd_tableOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.used) smc91c111_init(&nd_tableOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, 0xc8000000, picOPEN_SQUARE_TOKEN27CLOSE_SQUARE_TOKEN); sysbus_create_simple("pl110", 0xc0000000, picOPEN_SQUARE_TOKEN22CLOSE_SQUARE_TOKEN); integrator_binfo.ram_size = ram_size; integrator_binfo.kernel_filename = kernel_filename; integrator_binfo.kernel_cmdline = kernel_cmdline; integrator_binfo.initrd_filename = initrd_filename; arm_load_kernel([[snappy]], &integrator_binfo); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 90 ---------------------------------------------
[[0 (94%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void fd_chr_update_read_handler(CharDriverState *chr) OPEN_CURLY_TOKEN FDCharDriver *s = chr-GREATER_TOKENopaque; if (s-GREATER_TOKENfd_in_tag) OPEN_CURLY_TOKEN g_source_remove(s-GREATER_TOKENfd_in_tag); s-GREATER_TOKENfd_in_tag = 0; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENfd_in) OPEN_CURLY_TOKEN s-GREATER_TOKENfd_in_tag = io_add_watch_poll(s-GREATER_TOKENfd_in, fd_chr_read_poll, fd_chr_read, chr); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 91 ---------------------------------------------
[[1 (95%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int bfi_decode_frame(AVCodecContext *avctx, void *[[data]], int *data_size, AVPacket *avpkt) OPEN_CURLY_TOKEN const uint8_t *[[buf]] = avpkt-GREATER_TOKENdata, *buf_end = avpkt-GREATER_TOKENdata + avpkt-GREATER_TOKENsize; int buf_size = avpkt-GREATER_TOKENsize; BFIContext *bfi = avctx-GREATER_TOKENpriv_data; uint8_t *[[dst]] = bfi-GREATER_TOKENdst; uint8_t *src, *dst_offset, colour1, colour2; uint8_t *frame_end = bfi-GREATER_TOKENdst + avctx-GREATER_TOKENwidth * avctx-GREATER_TOKENheight; uint32_t *[[pal]]; int i, j, height = avctx-GREATER_TOKENheight; if (bfi-GREATER_TOKENframe.dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) avctx-GREATER_TOKENrelease_buffer(avctx, &bfi-GREATER_TOKENframe); bfi-GREATER_TOKENframe.reference = 1; if (avctx-GREATER_TOKENget_buffer(avctx, &bfi-GREATER_TOKENframe) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; CLOSE_CURLY_TOKEN if (!avctx-GREATER_TOKENframe_number) OPEN_CURLY_TOKEN bfi-GREATER_TOKENframe.pict_type = AV_PICTURE_TYPE_I; bfi-GREATER_TOKENframe.key_frame = 1; if (avctx-GREATER_TOKENextradata_size GREATER_TOKEN 768) OPEN_CURLY_TOKEN av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n"); return -1; CLOSE_CURLY_TOKEN [[pal]] = (uint32_t *)bfi-GREATER_TOKENframe.dataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; for (i = 0; i SMALLER_TOKEN avctx-GREATER_TOKENextradata_size / 3; i++) OPEN_CURLY_TOKEN int shift = 16; *[[pal]] = 0; for (j = 0; j SMALLER_TOKEN 3; j++, shift -= 8) *[[pal]] += ((avctx-GREATER_TOKENextradataOPEN_SQUARE_TOKENi * 3 + jCLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 2) | (avctx-GREATER_TOKENextradataOPEN_SQUARE_TOKENi * 3 + jCLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 4)) SMALLER_TOKENSMALLER_TOKEN shift; [[pal]]++; CLOSE_CURLY_TOKEN bfi-GREATER_TOKENframe.palette_has_changed = 1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN bfi-GREATER_TOKENframe.pict_type = AV_PICTURE_TYPE_P; bfi-GREATER_TOKENframe.key_frame = 0; CLOSE_CURLY_TOKEN [[buf]] += 4; while ([[dst]] != frame_end) OPEN_CURLY_TOKEN static const uint8_t lentabOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN 0, 2, 0, 1 CLOSE_CURLY_TOKEN; unsigned int [[byte]] = *[[buf]]++, av_uninit(offset); unsigned int code = [[byte]] GREATER_TOKENGREATER_TOKEN 6; unsigned int length = [[byte]] & ~0xC0; if ([[buf]] GREATER_TOKEN= buf_end) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Input resolution larger than actual frame.\n"); return -1; CLOSE_CURLY_TOKEN if (length == 0) OPEN_CURLY_TOKEN if (code == 1) OPEN_CURLY_TOKEN length = bytestream_get_byte(&[[buf]]); offset = bytestream_get_le16(&[[buf]]); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN length = bytestream_get_le16(&[[buf]]); if (code == 2 && length == 0) break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (code == 1) offset = bytestream_get_byte(&[[buf]]); CLOSE_CURLY_TOKEN if ([[dst]] + (length SMALLER_TOKENSMALLER_TOKEN lentabOPEN_SQUARE_TOKENcodeCLOSE_SQUARE_TOKEN) GREATER_TOKEN frame_end) break; switch (code) OPEN_CURLY_TOKEN case 0: if (length GREATER_TOKEN= buf_end - [[buf]]) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Frame larger than buffer.\n"); return -1; CLOSE_CURLY_TOKEN bytestream_get_buffer(&[[buf]], [[dst]], length); [[dst]] += length; break; case 1: dst_offset = [[dst]] - offset; length *= 4; if (dst_offset SMALLER_TOKEN bfi-GREATER_TOKENdst) break; while (length--) *[[dst]]++ = *dst_offset++; break; case 2: [[dst]] += length; break; case 3: colour1 = bytestream_get_byte(&[[buf]]); colour2 = bytestream_get_byte(&[[buf]]); while (length--) OPEN_CURLY_TOKEN *[[dst]]++ = colour1; *[[dst]]++ = colour2; CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN src = bfi-GREATER_TOKENdst; [[dst]] = bfi-GREATER_TOKENframe.dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; while (height--) OPEN_CURLY_TOKEN memcpy([[dst]], src, avctx-GREATER_TOKENwidth); src += avctx-GREATER_TOKENwidth; [[dst]] += bfi-GREATER_TOKENframe.linesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN *data_size = sizeof(AVFrame); *(AVFrame *)[[data]] = bfi-GREATER_TOKENframe; return buf_size; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int bfi_decode_frame(AVCodecContext *avctx, void *[[aloysius]], int *data_size, AVPacket *avpkt) OPEN_CURLY_TOKEN const uint8_t *[[hiccups]] = avpkt-GREATER_TOKENdata, *buf_end = avpkt-GREATER_TOKENdata + avpkt-GREATER_TOKENsize; int buf_size = avpkt-GREATER_TOKENsize; BFIContext *bfi = avctx-GREATER_TOKENpriv_data; uint8_t *[[theoretically]] = bfi-GREATER_TOKENdst; uint8_t *src, *dst_offset, colour1, colour2; uint8_t *frame_end = bfi-GREATER_TOKENdst + avctx-GREATER_TOKENwidth * avctx-GREATER_TOKENheight; uint32_t *[[specialness]]; int i, j, height = avctx-GREATER_TOKENheight; if (bfi-GREATER_TOKENframe.dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) avctx-GREATER_TOKENrelease_buffer(avctx, &bfi-GREATER_TOKENframe); bfi-GREATER_TOKENframe.reference = 1; if (avctx-GREATER_TOKENget_buffer(avctx, &bfi-GREATER_TOKENframe) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; CLOSE_CURLY_TOKEN if (!avctx-GREATER_TOKENframe_number) OPEN_CURLY_TOKEN bfi-GREATER_TOKENframe.pict_type = AV_PICTURE_TYPE_I; bfi-GREATER_TOKENframe.key_frame = 1; if (avctx-GREATER_TOKENextradata_size GREATER_TOKEN 768) OPEN_CURLY_TOKEN av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n"); return -1; CLOSE_CURLY_TOKEN [[specialness]] = (uint32_t *)bfi-GREATER_TOKENframe.dataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; for (i = 0; i SMALLER_TOKEN avctx-GREATER_TOKENextradata_size / 3; i++) OPEN_CURLY_TOKEN int shift = 16; *[[specialness]] = 0; for (j = 0; j SMALLER_TOKEN 3; j++, shift -= 8) *[[specialness]] += ((avctx-GREATER_TOKENextradataOPEN_SQUARE_TOKENi * 3 + jCLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 2) | (avctx-GREATER_TOKENextradataOPEN_SQUARE_TOKENi * 3 + jCLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 4)) SMALLER_TOKENSMALLER_TOKEN shift; [[specialness]]++; CLOSE_CURLY_TOKEN bfi-GREATER_TOKENframe.palette_has_changed = 1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN bfi-GREATER_TOKENframe.pict_type = AV_PICTURE_TYPE_P; bfi-GREATER_TOKENframe.key_frame = 0; CLOSE_CURLY_TOKEN [[hiccups]] += 4; while ([[theoretically]] != frame_end) OPEN_CURLY_TOKEN static const uint8_t lentabOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN 0, 2, 0, 1 CLOSE_CURLY_TOKEN; unsigned int [[wickedest]] = *[[hiccups]]++, av_uninit(offset); unsigned int code = [[wickedest]] GREATER_TOKENGREATER_TOKEN 6; unsigned int length = [[wickedest]] & ~0xC0; if ([[hiccups]] GREATER_TOKEN= buf_end) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Input resolution larger than actual frame.\n"); return -1; CLOSE_CURLY_TOKEN if (length == 0) OPEN_CURLY_TOKEN if (code == 1) OPEN_CURLY_TOKEN length = bytestream_get_byte(&[[hiccups]]); offset = bytestream_get_le16(&[[hiccups]]); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN length = bytestream_get_le16(&[[hiccups]]); if (code == 2 && length == 0) break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (code == 1) offset = bytestream_get_byte(&[[hiccups]]); CLOSE_CURLY_TOKEN if ([[theoretically]] + (length SMALLER_TOKENSMALLER_TOKEN lentabOPEN_SQUARE_TOKENcodeCLOSE_SQUARE_TOKEN) GREATER_TOKEN frame_end) break; switch (code) OPEN_CURLY_TOKEN case 0: if (length GREATER_TOKEN= buf_end - [[hiccups]]) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Frame larger than buffer.\n"); return -1; CLOSE_CURLY_TOKEN bytestream_get_buffer(&[[hiccups]], [[theoretically]], length); [[theoretically]] += length; break; case 1: dst_offset = [[theoretically]] - offset; length *= 4; if (dst_offset SMALLER_TOKEN bfi-GREATER_TOKENdst) break; while (length--) *[[theoretically]]++ = *dst_offset++; break; case 2: [[theoretically]] += length; break; case 3: colour1 = bytestream_get_byte(&[[hiccups]]); colour2 = bytestream_get_byte(&[[hiccups]]); while (length--) OPEN_CURLY_TOKEN *[[theoretically]]++ = colour1; *[[theoretically]]++ = colour2; CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN src = bfi-GREATER_TOKENdst; [[theoretically]] = bfi-GREATER_TOKENframe.dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; while (height--) OPEN_CURLY_TOKEN memcpy([[theoretically]], src, avctx-GREATER_TOKENwidth); src += avctx-GREATER_TOKENwidth; [[theoretically]] += bfi-GREATER_TOKENframe.linesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN *data_size = sizeof(AVFrame); *(AVFrame *)[[aloysius]] = bfi-GREATER_TOKENframe; return buf_size; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 39 / 14 / 38 / 91:   3%|         | 91/2690 [00:00<00:01, 2515.55it/s][Succeeded / Failed / Skipped / Total] 39 / 14 / 39 / 92:   3%|         | 92/2690 [00:00<00:01, 2528.78it/s][Succeeded / Failed / Skipped / Total] 40 / 14 / 39 / 93:   3%|         | 93/2690 [00:00<00:01, 2531.23it/s][Succeeded / Failed / Skipped / Total] 40 / 14 / 40 / 94:   3%|         | 94/2690 [00:00<00:01, 2543.56it/s][Succeeded / Failed / Skipped / Total] 41 / 14 / 40 / 95:   4%|         | 95/2690 [00:00<00:01, 2545.20it/s]
--------------------------------------------- Result 92 ---------------------------------------------
[[0 (70%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void cpu_tick_set_count(CPUTimer *timer, uint64_t count) OPEN_CURLY_TOKEN uint64_t real_count = count & ~timer-GREATER_TOKENdisabled_mask; uint64_t disabled_bit = count & timer-GREATER_TOKENdisabled_mask; int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - cpu_to_timer_ticks(real_count, timer-GREATER_TOKENfrequency); TIMER_DPRINTF("%s set_count count=0x%016lx (%s) p=%p\n", timer-GREATER_TOKENname, real_count, timer-GREATER_TOKENdisabled?"disabled":"enabled", timer); timer-GREATER_TOKENdisabled = disabled_bit ? 1 : 0; timer-GREATER_TOKENclock_offset = vm_clock_offset; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 93 ---------------------------------------------
[[0 (66%)]] --> [[1 (55%)]] --> Socre: 0.5541716814041138

[[[[Adv]]]]: static void device_initfn(Object *obj) OPEN_CURLY_TOKEN DeviceState *[[dev]] = DEVICE(obj); Property *[[prop]]; if (qdev_hotplug) OPEN_CURLY_TOKEN [[dev]]-GREATER_TOKENhotplugged = 1; qdev_hot_added = "True" == "True"; CLOSE_CURLY_TOKEN [[dev]]-GREATER_TOKENinstance_id_alias = -1; [[dev]]-GREATER_TOKENstate = DEV_STATE_CREATED; qdev_prop_set_defaults([[dev]], qdev_get_props([[dev]])); for ([[prop]] = qdev_get_props([[dev]]); [[prop]] && [[prop]]-GREATER_TOKENname; [[prop]]++) OPEN_CURLY_TOKEN qdev_property_add_legacy([[dev]], [[prop]], NULL); qdev_property_add_static([[dev]], [[prop]], NULL); CLOSE_CURLY_TOKEN object_property_add_str(OBJECT([[dev]]), "type", qdev_get_type, NULL, NULL); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void device_initfn(Object *obj) OPEN_CURLY_TOKEN DeviceState *[[brained]] = DEVICE(obj); Property *[[leopards]]; if (qdev_hotplug) OPEN_CURLY_TOKEN [[brained]]-GREATER_TOKENhotplugged = 1; qdev_hot_added = "True" == "True"; CLOSE_CURLY_TOKEN [[brained]]-GREATER_TOKENinstance_id_alias = -1; [[brained]]-GREATER_TOKENstate = DEV_STATE_CREATED; qdev_prop_set_defaults([[brained]], qdev_get_props([[brained]])); for ([[leopards]] = qdev_get_props([[brained]]); [[leopards]] && [[leopards]]-GREATER_TOKENname; [[leopards]]++) OPEN_CURLY_TOKEN qdev_property_add_legacy([[brained]], [[leopards]], NULL); qdev_property_add_static([[brained]], [[leopards]], NULL); CLOSE_CURLY_TOKEN object_property_add_str(OBJECT([[brained]]), "type", qdev_get_type, NULL, NULL); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 94 ---------------------------------------------
[[0 (92%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp) OPEN_CURLY_TOKEN IscsiLun *iscsilun = bs-GREATER_TOKENopaque; uint64_t max_xfer_len = iscsilun-GREATER_TOKENuse_16_for_rw ? 0xffffffff : 0xffff; bs-GREATER_TOKENbl.request_alignment = iscsilun-GREATER_TOKENblock_size; if (iscsilun-GREATER_TOKENbl.max_xfer_len) OPEN_CURLY_TOKEN max_xfer_len = MIN(max_xfer_len, iscsilun-GREATER_TOKENbl.max_xfer_len); CLOSE_CURLY_TOKEN if (max_xfer_len * iscsilun-GREATER_TOKENblock_size SMALLER_TOKEN INT_MAX) OPEN_CURLY_TOKEN bs-GREATER_TOKENbl.max_transfer = max_xfer_len * iscsilun-GREATER_TOKENblock_size; CLOSE_CURLY_TOKEN if (iscsilun-GREATER_TOKENlbp.lbpu) OPEN_CURLY_TOKEN if (iscsilun-GREATER_TOKENbl.max_unmap SMALLER_TOKEN 0xffffffff / iscsilun-GREATER_TOKENblock_size) OPEN_CURLY_TOKEN bs-GREATER_TOKENbl.max_pdiscard = iscsilun-GREATER_TOKENbl.max_unmap * iscsilun-GREATER_TOKENblock_size; CLOSE_CURLY_TOKEN bs-GREATER_TOKENbl.pdiscard_alignment = iscsilun-GREATER_TOKENbl.opt_unmap_gran * iscsilun-GREATER_TOKENblock_size; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN bs-GREATER_TOKENbl.pdiscard_alignment = iscsilun-GREATER_TOKENblock_size; CLOSE_CURLY_TOKEN if (iscsilun-GREATER_TOKENbl.max_ws_len SMALLER_TOKEN 0xffffffff / iscsilun-GREATER_TOKENblock_size) OPEN_CURLY_TOKEN bs-GREATER_TOKENbl.max_pwrite_zeroes = iscsilun-GREATER_TOKENbl.max_ws_len * iscsilun-GREATER_TOKENblock_size; CLOSE_CURLY_TOKEN if (iscsilun-GREATER_TOKENlbp.lbpws) OPEN_CURLY_TOKEN bs-GREATER_TOKENbl.pwrite_zeroes_alignment = iscsilun-GREATER_TOKENbl.opt_unmap_gran * iscsilun-GREATER_TOKENblock_size; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN bs-GREATER_TOKENbl.pwrite_zeroes_alignment = iscsilun-GREATER_TOKENblock_size; CLOSE_CURLY_TOKEN if (iscsilun-GREATER_TOKENbl.opt_xfer_len && iscsilun-GREATER_TOKENbl.opt_xfer_len SMALLER_TOKEN INT_MAX / iscsilun-GREATER_TOKENblock_size) OPEN_CURLY_TOKEN bs-GREATER_TOKENbl.opt_transfer = pow2floor(iscsilun-GREATER_TOKENbl.opt_xfer_len * iscsilun-GREATER_TOKENblock_size); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 95 ---------------------------------------------
[[0 (85%)]] --> [[1 (52%)]] --> Socre: 0.5160735845565796

[[[[Adv]]]]: static void tap_receive(void *opaque, const uint8_t *[[buf]], size_t size) OPEN_CURLY_TOKEN TAPState *[[s]] = opaque; int [[ret]]; for(;;) OPEN_CURLY_TOKEN [[ret]] = write([[s]]-GREATER_TOKENfd, [[buf]], size); if ([[ret]] SMALLER_TOKEN 0 && (errno == EINTR || errno == EAGAIN)) OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void tap_receive(void *opaque, const uint8_t *[[preppy]], size_t size) OPEN_CURLY_TOKEN TAPState *[[downstream]] = opaque; int [[annoyances]]; for(;;) OPEN_CURLY_TOKEN [[annoyances]] = write([[downstream]]-GREATER_TOKENfd, [[preppy]], size); if ([[annoyances]] SMALLER_TOKEN 0 && (errno == EINTR || errno == EAGAIN)) OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 96 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 14 / 40 / 96:   4%|         | 96/2690 [00:00<00:01, 2540.75it/s][[0 (85%)]] --> [[1 (52%)]] --> Socre: 0.5160293579101562

[[[[Adv]]]]: static void sdl_send_mouse_event(int [[dx]], int [[dy]], int x, int y, int [[state]]) OPEN_CURLY_TOKEN static uint32_t [[bmap]]OPEN_SQUARE_TOKENINPUT_BUTTON__MAXCLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN OPEN_SQUARE_TOKENINPUT_BUTTON_LEFTCLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_LEFT), OPEN_SQUARE_TOKENINPUT_BUTTON_MIDDLECLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_MIDDLE), OPEN_SQUARE_TOKENINPUT_BUTTON_RIGHTCLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_RIGHT), OPEN_SQUARE_TOKENINPUT_BUTTON_WHEEL_UPCLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_WHEELUP), OPEN_SQUARE_TOKENINPUT_BUTTON_WHEEL_DOWNCLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_WHEELDOWN), CLOSE_CURLY_TOKEN; static uint32_t prev_state; if (prev_state != [[state]]) OPEN_CURLY_TOKEN qemu_input_update_buttons(dcl-GREATER_TOKENcon, [[bmap]], prev_state, [[state]]); prev_state = [[state]]; CLOSE_CURLY_TOKEN if (qemu_input_is_absolute()) OPEN_CURLY_TOKEN qemu_input_queue_abs(dcl-GREATER_TOKENcon, INPUT_AXIS_X, x, real_screen-GREATER_TOKENw); qemu_input_queue_abs(dcl-GREATER_TOKENcon, INPUT_AXIS_Y, y, real_screen-GREATER_TOKENh); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (guest_cursor) OPEN_CURLY_TOKEN x -= guest_x; y -= guest_y; guest_x += x; guest_y += y; [[dx]] = x; [[dy]] = y; CLOSE_CURLY_TOKEN qemu_input_queue_rel(dcl-GREATER_TOKENcon, INPUT_AXIS_X, [[dx]]); qemu_input_queue_rel(dcl-GREATER_TOKENcon, INPUT_AXIS_Y, [[dy]]); CLOSE_CURLY_TOKEN qemu_input_event_sync(); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void sdl_send_mouse_event(int [[bengt]], int [[ogres]], int x, int y, int [[discover]]) OPEN_CURLY_TOKEN static uint32_t [[jeeze]]OPEN_SQUARE_TOKENINPUT_BUTTON__MAXCLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN OPEN_SQUARE_TOKENINPUT_BUTTON_LEFTCLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_LEFT), OPEN_SQUARE_TOKENINPUT_BUTTON_MIDDLECLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_MIDDLE), OPEN_SQUARE_TOKENINPUT_BUTTON_RIGHTCLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_RIGHT), OPEN_SQUARE_TOKENINPUT_BUTTON_WHEEL_UPCLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_WHEELUP), OPEN_SQUARE_TOKENINPUT_BUTTON_WHEEL_DOWNCLOSE_SQUARE_TOKEN = SDL_BUTTON(SDL_BUTTON_WHEELDOWN), CLOSE_CURLY_TOKEN; static uint32_t prev_state; if (prev_state != [[discover]]) OPEN_CURLY_TOKEN qemu_input_update_buttons(dcl-GREATER_TOKENcon, [[jeeze]], prev_state, [[discover]]); prev_state = [[discover]]; CLOSE_CURLY_TOKEN if (qemu_input_is_absolute()) OPEN_CURLY_TOKEN qemu_input_queue_abs(dcl-GREATER_TOKENcon, INPUT_AXIS_X, x, real_screen-GREATER_TOKENw); qemu_input_queue_abs(dcl-GREATER_TOKENcon, INPUT_AXIS_Y, y, real_screen-GREATER_TOKENh); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (guest_cursor) OPEN_CURLY_TOKEN x -= guest_x; y -= guest_y; guest_x += x; guest_y += y; [[bengt]] = x; [[ogres]] = y; CLOSE_CURLY_TOKEN qemu_input_queue_rel(dcl-GREATER_TOKENcon, INPUT_AXIS_X, [[bengt]]); qemu_input_queue_rel(dcl-GREATER_TOKENcon, INPUT_AXIS_Y, [[ogres]]); CLOSE_CURLY_TOKEN qemu_input_event_sync(); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 97 ---------------------------------------------
[[1 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void commit_start(const char *[[job_id]], BlockDriverState *bs, BlockDriverState *[[base]], BlockDriverState *top, int64_t speed, BlockdevOnError on_error, const char *backing_file_str, const char *[[filter_node_name]], Error **errp) OPEN_CURLY_TOKEN CommitBlockJob *[[s]]; BlockReopenQueue *reopen_queue = NULL; int orig_overlay_flags; int orig_base_flags; BlockDriverState *iter; BlockDriverState *overlay_bs; BlockDriverState *commit_top_bs = NULL; Error *local_err = NULL; int [[ret]]; assert(top != bs); if (top == [[base]]) OPEN_CURLY_TOKEN error_setg(errp, "Invalid files for merge: top and base are the same"); return; overlay_bs = bdrv_find_overlay(bs, top); if (overlay_bs == NULL) OPEN_CURLY_TOKEN error_setg(errp, "Could not find overlay image for %s:", top-GREATER_TOKENfilename); return; [[s]] = block_job_create([[job_id]], &commit_job_driver, bs, 0, BLK_PERM_ALL, speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp); if (![[s]]) OPEN_CURLY_TOKEN return; orig_base_flags = bdrv_get_flags([[base]]); orig_overlay_flags = bdrv_get_flags(overlay_bs); if (!(orig_base_flags & BDRV_O_RDWR)) OPEN_CURLY_TOKEN reopen_queue = bdrv_reopen_queue(reopen_queue, [[base]], NULL, orig_base_flags | BDRV_O_RDWR); if (!(orig_overlay_flags & BDRV_O_RDWR)) OPEN_CURLY_TOKEN reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL, orig_overlay_flags | BDRV_O_RDWR); if (reopen_queue) OPEN_CURLY_TOKEN bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err); if (local_err != NULL) OPEN_CURLY_TOKEN error_propagate(errp, local_err); goto fail; commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, [[filter_node_name]], 0, errp); if (commit_top_bs == NULL) OPEN_CURLY_TOKEN goto fail; commit_top_bs-GREATER_TOKENtotal_sectors = top-GREATER_TOKENtotal_sectors; bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top)); bdrv_set_backing_hd(commit_top_bs, top, &local_err); if (local_err) OPEN_CURLY_TOKEN bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err); if (local_err) OPEN_CURLY_TOKEN bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; [[s]]-GREATER_TOKENcommit_top_bs = commit_top_bs; bdrv_unref(commit_top_bs); assert(bdrv_chain_contains(top, [[base]])); for (iter = top; iter != [[base]]; iter = backing_bs(iter)) OPEN_CURLY_TOKEN [[ret]] = block_job_add_bdrv(&[[s]]-GREATER_TOKENcommon, "intermediate node", iter, 0, BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE, errp); if ([[ret]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[ret]] = block_job_add_bdrv(&[[s]]-GREATER_TOKENcommon, "base", [[base]], 0, BLK_PERM_ALL, errp); if ([[ret]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[ret]] = block_job_add_bdrv(&[[s]]-GREATER_TOKENcommon, "overlay of top", overlay_bs, BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp); if ([[ret]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[s]]-GREATER_TOKENbase = blk_new(BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE | BLK_PERM_RESIZE, BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD | BLK_PERM_WRITE_UNCHANGED); [[ret]] = blk_insert_bs([[s]]-GREATER_TOKENbase, [[base]], errp); if ([[ret]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[s]]-GREATER_TOKENtop = blk_new(0, BLK_PERM_ALL); [[ret]] = blk_insert_bs([[s]]-GREATER_TOKENtop, top, errp); if ([[ret]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[s]]-GREATER_TOKENactive = bs; [[s]]-GREATER_TOKENbase_flags = orig_base_flags; [[s]]-GREATER_TOKENorig_overlay_flags = orig_overlay_flags; [[s]]-GREATER_TOKENbacking_file_str = g_strdup(backing_file_str); [[s]]-GREATER_TOKENon_error = on_error; trace_commit_start(bs, [[base]], top, [[s]]); block_job_start(&[[s]]-GREATER_TOKENcommon); return; fail: if ([[s]]-GREATER_TOKENbase) OPEN_CURLY_TOKEN blk_unref([[s]]-GREATER_TOKENbase); if ([[s]]-GREATER_TOKENtop) OPEN_CURLY_TOKEN blk_unref([[s]]-GREATER_TOKENtop); if (commit_top_bs) OPEN_CURLY_TOKEN bdrv_set_backing_hd(overlay_bs, top, &error_abort); block_job_early_fail(&[[s]]-GREATER_TOKENcommon);

[[[[Adv]]]]: void commit_start(const char *[[tonda]], BlockDriverState *bs, BlockDriverState *[[bei]], BlockDriverState *top, int64_t speed, BlockdevOnError on_error, const char *backing_file_str, const char *[[mnster]], Error **errp) OPEN_CURLY_TOKEN CommitBlockJob *[[however]]; BlockReopenQueue *reopen_queue = NULL; int orig_overlay_flags; int orig_base_flags; BlockDriverState *iter; BlockDriverState *overlay_bs; BlockDriverState *commit_top_bs = NULL; Error *local_err = NULL; int [[citt]]; assert(top != bs); if (top == [[bei]]) OPEN_CURLY_TOKEN error_setg(errp, "Invalid files for merge: top and base are the same"); return; overlay_bs = bdrv_find_overlay(bs, top); if (overlay_bs == NULL) OPEN_CURLY_TOKEN error_setg(errp, "Could not find overlay image for %s:", top-GREATER_TOKENfilename); return; [[however]] = block_job_create([[tonda]], &commit_job_driver, bs, 0, BLK_PERM_ALL, speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp); if (![[however]]) OPEN_CURLY_TOKEN return; orig_base_flags = bdrv_get_flags([[bei]]); orig_overlay_flags = bdrv_get_flags(overlay_bs); if (!(orig_base_flags & BDRV_O_RDWR)) OPEN_CURLY_TOKEN reopen_queue = bdrv_reopen_queue(reopen_queue, [[bei]], NULL, orig_base_flags | BDRV_O_RDWR); if (!(orig_overlay_flags & BDRV_O_RDWR)) OPEN_CURLY_TOKEN reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL, orig_overlay_flags | BDRV_O_RDWR); if (reopen_queue) OPEN_CURLY_TOKEN bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err); if (local_err != NULL) OPEN_CURLY_TOKEN error_propagate(errp, local_err); goto fail; commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, [[mnster]], 0, errp); if (commit_top_bs == NULL) OPEN_CURLY_TOKEN goto fail; commit_top_bs-GREATER_TOKENtotal_sectors = top-GREATER_TOKENtotal_sectors; bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top)); bdrv_set_backing_hd(commit_top_bs, top, &local_err); if (local_err) OPEN_CURLY_TOKEN bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err); if (local_err) OPEN_CURLY_TOKEN bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; [[however]]-GREATER_TOKENcommit_top_bs = commit_top_bs; bdrv_unref(commit_top_bs); assert(bdrv_chain_contains(top, [[bei]])); for (iter = top; iter != [[bei]]; iter = backing_bs(iter)) OPEN_CURLY_TOKEN [[citt]] = block_job_add_bdrv(&[[however]]-GREATER_TOKENcommon, "intermediate node", iter, 0, BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE, errp); if ([[citt]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[citt]] = block_job_add_bdrv(&[[however]]-GREATER_TOKENcommon, "base", [[bei]], 0, BLK_PERM_ALL, errp); if ([[citt]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[citt]] = block_job_add_bdrv(&[[however]]-GREATER_TOKENcommon, "overlay of top", overlay_bs, BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp); if ([[citt]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[however]]-GREATER_TOKENbase = blk_new(BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE | BLK_PERM_RESIZE, BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD | BLK_PERM_WRITE_UNCHANGED); [[citt]] = blk_insert_bs([[however]]-GREATER_TOKENbase, [[bei]], errp); if ([[citt]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[however]]-GREATER_TOKENtop = blk_new(0, BLK_PERM_ALL); [[citt]] = blk_insert_bs([[however]]-GREATER_TOKENtop, top, errp); if ([[citt]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail; [[however]]-GREATER_TOKENactive = bs; [[however]]-GREATER_TOKENbase_flags = orig_base_flags; [[however]]-GREATER_TOKENorig_overlay_flags = orig_overlay_flags; [[however]]-GREATER_TOKENbacking_file_str = g_strdup(backing_file_str); [[however]]-GREATER_TOKENon_error = on_error; trace_commit_start(bs, [[bei]], top, [[however]]); block_job_start(&[[however]]-GREATER_TOKENcommon); return; fail: if ([[however]]-GREATER_TOKENbase) OPEN_CURLY_TOKEN blk_unref([[however]]-GREATER_TOKENbase); if ([[however]]-GREATER_TOKENtop) OPEN_CURLY_TOKEN blk_unref([[however]]-GREATER_TOKENtop); if (commit_top_bs) OPEN_CURLY_TOKEN bdrv_set_backing_hd(overlay_bs, top, &error_abort); block_job_early_fail(&[[however]]-GREATER_TOKENcommon);[Succeeded / Failed / Skipped / Total] 42 / 15 / 40 / 97:   4%|         | 97/2690 [00:00<00:01, 2509.44it/s][Succeeded / Failed / Skipped / Total] 42 / 16 / 40 / 98:   4%|         | 98/2690 [00:00<00:01, 2509.90it/s][Succeeded / Failed / Skipped / Total] 42 / 17 / 40 / 99:   4%|         | 99/2690 [00:00<00:01, 2515.87it/s][Succeeded / Failed / Skipped / Total] 42 / 17 / 41 / 100:   4%|         | 100/2690 [00:00<00:01, 2529.02it/s][Succeeded / Failed / Skipped / Total] 42 / 17 / 42 / 101:   4%|         | 101/2690 [00:00<00:01, 2542.12it/s][Succeeded / Failed / Skipped / Total] 42 / 17 / 43 / 102:   4%|         | 102/2690 [00:00<00:01, 2555.01it/s]
--------------------------------------------- Result 98 ---------------------------------------------
[[0 (94%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void scsi_disk_realize(SCSIDevice *[[dev]], Error **[[errp]]) OPEN_CURLY_TOKEN DriveInfo *[[dinfo]]; Error *[[local_err]] = NULL; if (![[dev]]-GREATER_TOKENconf.bs) OPEN_CURLY_TOKEN scsi_realize([[dev]], &[[local_err]]); assert([[local_err]]); error_propagate([[errp]], [[local_err]]); return; CLOSE_CURLY_TOKEN [[dinfo]] = drive_get_by_blockdev([[dev]]-GREATER_TOKENconf.bs); if ([[dinfo]]-GREATER_TOKENmedia_cd) OPEN_CURLY_TOKEN scsi_cd_realize([[dev]], [[errp]]); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN scsi_hd_realize([[dev]], [[errp]]); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void scsi_disk_realize(SCSIDevice *[[tract]], Error **[[mam]]) OPEN_CURLY_TOKEN DriveInfo *[[independant]]; Error *[[inviting]] = NULL; if (![[tract]]-GREATER_TOKENconf.bs) OPEN_CURLY_TOKEN scsi_realize([[tract]], &[[inviting]]); assert([[inviting]]); error_propagate([[mam]], [[inviting]]); return; CLOSE_CURLY_TOKEN [[independant]] = drive_get_by_blockdev([[tract]]-GREATER_TOKENconf.bs); if ([[independant]]-GREATER_TOKENmedia_cd) OPEN_CURLY_TOKEN scsi_cd_realize([[tract]], [[mam]]); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN scsi_hd_realize([[tract]], [[mam]]); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 99 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int bdrv_is_removable(BlockDriverState *[[bs]]) OPEN_CURLY_TOKEN return [[bs]]-GREATER_TOKENremovable; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int bdrv_is_removable(BlockDriverState *[[moth]]) OPEN_CURLY_TOKEN return [[moth]]-GREATER_TOKENremovable; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 100 ---------------------------------------------
[[0 (88%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int check_checksum(ByteIOContext *bc)OPEN_CURLY_TOKEN unsigned long checksum= get_checksum(bc); av_log(NULL, AV_LOG_ERROR, "%08X %08X\n", checksum, (int)get_be32(bc)); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 101 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: MigrationState *exec_start_outgoing_migration(const char *command, int64_t bandwidth_limit, int async) OPEN_CURLY_TOKEN FdMigrationState *s; FILE *f; s = qemu_mallocz(sizeof(*s)); if (s == NULL) OPEN_CURLY_TOKEN dprintf("Unable to allocate FdMigrationState\n"); goto err; CLOSE_CURLY_TOKEN f = popen(command, "w"); if (f == NULL) OPEN_CURLY_TOKEN dprintf("Unable to popen exec target\n"); goto err_after_alloc; CLOSE_CURLY_TOKEN s-GREATER_TOKENfd = fileno(f); if (s-GREATER_TOKENfd == -1) OPEN_CURLY_TOKEN dprintf("Unable to retrieve file descriptor for popen'd handle\n"); goto err_after_open; CLOSE_CURLY_TOKEN if (fcntl(s-GREATER_TOKENfd, F_SETFD, O_NONBLOCK) == -1) OPEN_CURLY_TOKEN dprintf("Unable to set nonblocking mode on file descriptor\n"); goto err_after_open; CLOSE_CURLY_TOKEN s-GREATER_TOKENopaque = qemu_popen(f, "w"); s-GREATER_TOKENget_error = file_errno; s-GREATER_TOKENwrite = file_write; s-GREATER_TOKENmig_state.cancel = migrate_fd_cancel; s-GREATER_TOKENmig_state.get_status = migrate_fd_get_status; s-GREATER_TOKENmig_state.release = migrate_fd_release; s-GREATER_TOKENstate = MIG_STATE_ACTIVE; s-GREATER_TOKENdetach = !async; s-GREATER_TOKENbandwidth_limit = bandwidth_limit; if (s-GREATER_TOKENdetach == 1) OPEN_CURLY_TOKEN dprintf("detaching from monitor\n"); monitor_suspend(); s-GREATER_TOKENdetach = 2; CLOSE_CURLY_TOKEN migrate_fd_connect(s); return &s-GREATER_TOKENmig_state; err_after_open: pclose(f); err_after_alloc: qemu_free(s); err: return NULL; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 102 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int aio_write_f(BlockBackend *blk, int argc, char **argv) OPEN_CURLY_TOKEN int nr_iov, c; int pattern = 0xcd; struct aio_ctx *ctx = g_new0(struct aio_ctx, 1); ctx-GREATER_TOKENblk = blk; while ((c = getopt(argc, argv, "CqP:z")) != -1) OPEN_CURLY_TOKEN switch (c) OPEN_CURLY_TOKEN case 'C': ctx-GREATER_TOKENCflag = 1; break; case 'q': ctx-GREATER_TOKENqflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN break; case 'z': ctx-GREATER_TOKENzflag = 1; break; default: return qemuio_command_usage(&aio_write_cmd); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (optind GREATER_TOKEN argc - 2) OPEN_CURLY_TOKEN return qemuio_command_usage(&aio_write_cmd); CLOSE_CURLY_TOKEN if (ctx-GREATER_TOKENzflag && optind != argc - 2) OPEN_CURLY_TOKEN printf("-z supports only a single length parameter\n"); return 0; CLOSE_CURLY_TOKEN if (ctx-GREATER_TOKENzflag && ctx-GREATER_TOKENPflag) OPEN_CURLY_TOKEN printf("-z and -P cannot be specified at the same time\n"); return 0; CLOSE_CURLY_TOKEN ctx-GREATER_TOKENoffset = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if (ctx-GREATER_TOKENoffset SMALLER_TOKEN 0) OPEN_CURLY_TOKEN print_cvtnum_err(ctx-GREATER_TOKENoffset, argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN optind++; if (ctx-GREATER_TOKENoffset & 0x1ff) OPEN_CURLY_TOKEN printf("offset %" PRId64 " is not sector aligned\n", ctx-GREATER_TOKENoffset); block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE); return 0; CLOSE_CURLY_TOKEN if (ctx-GREATER_TOKENzflag) OPEN_CURLY_TOKEN int64_t count = cvtnum(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); if (count SMALLER_TOKEN 0) OPEN_CURLY_TOKEN print_cvtnum_err(count, argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN); return 0; CLOSE_CURLY_TOKEN ctx-GREATER_TOKENqiov.size = count; blk_aio_write_zeroes(blk, ctx-GREATER_TOKENoffset GREATER_TOKENGREATER_TOKEN 9, count GREATER_TOKENGREATER_TOKEN 9, 0, aio_write_done, ctx); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN nr_iov = argc - optind; ctx-GREATER_TOKENbuf = create_iovec(blk, &ctx-GREATER_TOKENqiov, &argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN, nr_iov, pattern); if (ctx-GREATER_TOKENbuf == NULL) OPEN_CURLY_TOKEN block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE); return 0; CLOSE_CURLY_TOKEN gettimeofday(&ctx-GREATER_TOKENt1, NULL); block_acct_start(blk_get_stats(blk), &ctx-GREATER_TOKENacct, ctx-GREATER_TOKENqiov.size, BLOCK_ACCT_WRITE); blk_aio_writev(blk, ctx-GREATER_TOKENoffset GREATER_TOKENGREATER_TOKEN 9, &ctx-GREATER_TOKENqiov, ctx-GREATER_TOKENqiov.size GREATER_TOKENGREATER_TOKEN 9, aio_write_done, ctx); CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 103 ---------------------------------------------
[[0 (89%)]] --> [[1 (75%)]] --> Socre: 0.7467909455299377

[[[[Adv]]]]: PXA2xxState *pxa255_init(unsigned int [[sdram_size]]) OPEN_CURLY_TOKEN PXA2xxState *s; int [[iomemtype]], i; DriveInfo *[[dinfo]]; s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState)); s-GREATER_TOKENenv = cpu_init("pxa255"); if (!s-GREATER_TOKENenv) OPEN_CURLY_TOKEN fprintf(stderr, "Unable to find CPU definition\n"); exit(1); CLOSE_CURLY_TOKEN s-GREATER_TOKENreset = qemu_allocate_irqs(pxa2xx_reset, s, 1)OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; cpu_register_physical_memory(PXA2XX_SDRAM_BASE, [[sdram_size]], qemu_ram_alloc(NULL, "pxa255.sdram", [[sdram_size]]) | IO_MEM_RAM); cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE, qemu_ram_alloc(NULL, "pxa255.internal", PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM); s-GREATER_TOKENpic = pxa2xx_pic_init(0x40d00000, s-GREATER_TOKENenv); s-GREATER_TOKENdma = pxa255_dma_init(0x40000000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_DMACLOSE_SQUARE_TOKEN); pxa25x_timer_init(0x40a00000, &s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_OST_0CLOSE_SQUARE_TOKEN); s-GREATER_TOKENgpio = pxa2xx_gpio_init(0x40e00000, s-GREATER_TOKENenv, s-GREATER_TOKENpic, 85); [[dinfo]] = drive_get(IF_SD, 0, 0); if (![[dinfo]]) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: missing SecureDigital device\n"); exit(1); CLOSE_CURLY_TOKEN s-GREATER_TOKENmmc = pxa2xx_mmci_init(0x41100000, [[dinfo]]-GREATER_TOKENbdrv, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_MMCCLOSE_SQUARE_TOKEN, s-GREATER_TOKENdma); for (i = 0; pxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base; i ++) if (serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN #ifdef TARGET_WORDS_BIGENDIAN serial_mm_init(pxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base, 2, s-GREATER_TOKENpicOPEN_SQUARE_TOKENpxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.irqnCLOSE_SQUARE_TOKEN, 14745600/16, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1, 1); #else serial_mm_init(pxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base, 2, s-GREATER_TOKENpicOPEN_SQUARE_TOKENpxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.irqnCLOSE_SQUARE_TOKEN, 14745600/16, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1, 0); #endif CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN if (serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) s-GREATER_TOKENfir = pxa2xx_fir_init(0x40800000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_ICPCLOSE_SQUARE_TOKEN, s-GREATER_TOKENdma, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); s-GREATER_TOKENlcd = pxa2xx_lcdc_init(0x44000000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_LCDCLOSE_SQUARE_TOKEN); s-GREATER_TOKENcm_base = 0x41300000; s-GREATER_TOKENcm_regsOPEN_SQUARE_TOKENCCCR GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN = 0x02000210; s-GREATER_TOKENclkcfg = 0x00000009; [[iomemtype]] = cpu_register_io_memory(pxa2xx_cm_readfn, pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s-GREATER_TOKENcm_base, 0x1000, [[iomemtype]]); register_savevm(NULL, "pxa2xx_cm", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s); cpu_arm_set_cp_io(s-GREATER_TOKENenv, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s); s-GREATER_TOKENmm_base = 0x48000000; s-GREATER_TOKENmm_regsOPEN_SQUARE_TOKENMDMRS GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN = 0x00020002; s-GREATER_TOKENmm_regsOPEN_SQUARE_TOKENMDREFR GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN = 0x03ca4000; s-GREATER_TOKENmm_regsOPEN_SQUARE_TOKENMECR GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN = 0x00000001; [[iomemtype]] = cpu_register_io_memory(pxa2xx_mm_readfn, pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s-GREATER_TOKENmm_base, 0x1000, [[iomemtype]]); register_savevm(NULL, "pxa2xx_mm", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s); s-GREATER_TOKENpm_base = 0x40f00000; [[iomemtype]] = cpu_register_io_memory(pxa2xx_pm_readfn, pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s-GREATER_TOKENpm_base, 0x100, [[iomemtype]]); register_savevm(NULL, "pxa2xx_pm", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s); for (i = 0; pxa255_sspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base; i ++); s-GREATER_TOKENssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i); for (i = 0; pxa255_sspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base; i ++) OPEN_CURLY_TOKEN DeviceState *dev; dev = sysbus_create_simple("pxa2xx-ssp", pxa255_sspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base, s-GREATER_TOKENpicOPEN_SQUARE_TOKENpxa255_sspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.irqnCLOSE_SQUARE_TOKEN); s-GREATER_TOKENsspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = (SSIBus *)qdev_get_child_bus(dev, "ssi"); CLOSE_CURLY_TOKEN if (usb_enabled) OPEN_CURLY_TOKEN sysbus_create_simple("sysbus-ohci", 0x4c000000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_USBH1CLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN s-GREATER_TOKENpcmciaOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = pxa2xx_pcmcia_init(0x20000000); s-GREATER_TOKENpcmciaOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = pxa2xx_pcmcia_init(0x30000000); s-GREATER_TOKENrtc_base = 0x40900000; [[iomemtype]] = cpu_register_io_memory(pxa2xx_rtc_readfn, pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s-GREATER_TOKENrtc_base, 0x1000, [[iomemtype]]); pxa2xx_rtc_init(s); register_savevm(NULL, "pxa2xx_rtc", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s); s-GREATER_TOKENi2cOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = pxa2xx_i2c_init(0x40301600, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_I2CCLOSE_SQUARE_TOKEN, 0xffff); s-GREATER_TOKENi2cOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = pxa2xx_i2c_init(0x40f00100, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_PWRI2CCLOSE_SQUARE_TOKEN, 0xff); s-GREATER_TOKENi2s = pxa2xx_i2s_init(0x40400000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_I2SCLOSE_SQUARE_TOKEN, s-GREATER_TOKENdma); qdev_connect_gpio_out(s-GREATER_TOKENgpio, 1, s-GREATER_TOKENreset); return s; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: PXA2xxState *pxa255_init(unsigned int [[pittance]]) OPEN_CURLY_TOKEN PXA2xxState *s; int [[trainer]], i; DriveInfo *[[neighborhood]]; s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState)); s-GREATER_TOKENenv = cpu_init("pxa255"); if (!s-GREATER_TOKENenv) OPEN_CURLY_TOKEN fprintf(stderr, "Unable to find CPU definition\n"); exit(1); CLOSE_CURLY_TOKEN s-GREATER_TOKENreset = qemu_allocate_irqs(pxa2xx_reset, s, 1)OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; cpu_register_physical_memory(PXA2XX_SDRAM_BASE, [[pittance]], qemu_ram_alloc(NULL, "pxa255.sdram", [[pittance]]) | IO_MEM_RAM); cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE, qemu_ram_alloc(NULL, "pxa255.internal", PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM); s-GREATER_TOKENpic = pxa2xx_pic_init(0x40d00000, s-GREATER_TOKENenv); s-GREATER_TOKENdma = pxa255_dma_init(0x40000000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_DMACLOSE_SQUARE_TOKEN); pxa25x_timer_init(0x40a00000, &s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_OST_0CLOSE_SQUARE_TOKEN); s-GREATER_TOKENgpio = pxa2xx_gpio_init(0x40e00000, s-GREATER_TOKENenv, s-GREATER_TOKENpic, 85); [[neighborhood]] = drive_get(IF_SD, 0, 0); if (![[neighborhood]]) OPEN_CURLY_TOKEN fprintf(stderr, "qemu: missing SecureDigital device\n"); exit(1); CLOSE_CURLY_TOKEN s-GREATER_TOKENmmc = pxa2xx_mmci_init(0x41100000, [[neighborhood]]-GREATER_TOKENbdrv, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_MMCCLOSE_SQUARE_TOKEN, s-GREATER_TOKENdma); for (i = 0; pxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base; i ++) if (serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN #ifdef TARGET_WORDS_BIGENDIAN serial_mm_init(pxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base, 2, s-GREATER_TOKENpicOPEN_SQUARE_TOKENpxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.irqnCLOSE_SQUARE_TOKEN, 14745600/16, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1, 1); #else serial_mm_init(pxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base, 2, s-GREATER_TOKENpicOPEN_SQUARE_TOKENpxa255_serialOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.irqnCLOSE_SQUARE_TOKEN, 14745600/16, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1, 0); #endif CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN if (serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) s-GREATER_TOKENfir = pxa2xx_fir_init(0x40800000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_ICPCLOSE_SQUARE_TOKEN, s-GREATER_TOKENdma, serial_hdsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); s-GREATER_TOKENlcd = pxa2xx_lcdc_init(0x44000000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_LCDCLOSE_SQUARE_TOKEN); s-GREATER_TOKENcm_base = 0x41300000; s-GREATER_TOKENcm_regsOPEN_SQUARE_TOKENCCCR GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN = 0x02000210; s-GREATER_TOKENclkcfg = 0x00000009; [[trainer]] = cpu_register_io_memory(pxa2xx_cm_readfn, pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s-GREATER_TOKENcm_base, 0x1000, [[trainer]]); register_savevm(NULL, "pxa2xx_cm", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s); cpu_arm_set_cp_io(s-GREATER_TOKENenv, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s); s-GREATER_TOKENmm_base = 0x48000000; s-GREATER_TOKENmm_regsOPEN_SQUARE_TOKENMDMRS GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN = 0x00020002; s-GREATER_TOKENmm_regsOPEN_SQUARE_TOKENMDREFR GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN = 0x03ca4000; s-GREATER_TOKENmm_regsOPEN_SQUARE_TOKENMECR GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN = 0x00000001; [[trainer]] = cpu_register_io_memory(pxa2xx_mm_readfn, pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s-GREATER_TOKENmm_base, 0x1000, [[trainer]]); register_savevm(NULL, "pxa2xx_mm", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s); s-GREATER_TOKENpm_base = 0x40f00000; [[trainer]] = cpu_register_io_memory(pxa2xx_pm_readfn, pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s-GREATER_TOKENpm_base, 0x100, [[trainer]]); register_savevm(NULL, "pxa2xx_pm", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s); for (i = 0; pxa255_sspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base; i ++); s-GREATER_TOKENssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i); for (i = 0; pxa255_sspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base; i ++) OPEN_CURLY_TOKEN DeviceState *dev; dev = sysbus_create_simple("pxa2xx-ssp", pxa255_sspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.io_base, s-GREATER_TOKENpicOPEN_SQUARE_TOKENpxa255_sspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.irqnCLOSE_SQUARE_TOKEN); s-GREATER_TOKENsspOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = (SSIBus *)qdev_get_child_bus(dev, "ssi"); CLOSE_CURLY_TOKEN if (usb_enabled) OPEN_CURLY_TOKEN sysbus_create_simple("sysbus-ohci", 0x4c000000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_USBH1CLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN s-GREATER_TOKENpcmciaOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = pxa2xx_pcmcia_init(0x20000000); s-GREATER_TOKENpcmciaOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = pxa2xx_pcmcia_init(0x30000000); s-GREATER_TOKENrtc_base = 0x40900000; [[trainer]] = cpu_register_io_memory(pxa2xx_rtc_readfn, pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s-GREATER_TOKENrtc_base, 0x1000, [[trainer]]); pxa2xx_rtc_init(s); register_savevm(NULL, "pxa2xx_rtc", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s); s-GREATER_TOKENi2cOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = pxa2xx_i2c_init(0x40301600, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_I2CCLOSE_SQUARE_TOKEN, 0xffff); s-GREATER_TOKENi2cOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = pxa2xx_i2c_init(0x40f00100, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_PWRI2CCLOSE_SQUARE_TOKEN, 0xff); s-GREATER_TOKENi2s = pxa2xx_i2s_init(0x40400000, s-GREATER_TOKENpicOPEN_SQUARE_TOKENPXA2XX_PIC_I2SCLOSE_SQUARE_TOKEN, s-GREATER_TOKENdma); qdev_connect_gpio_out(s-GREATER_TOKENgpio, 1, s-GREATER_TOKENreset); return s; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 43 / 17 / 43 / 103:   4%|         | 103/2690 [00:00<00:01, 2549.46it/s][Succeeded / Failed / Skipped / Total] 44 / 17 / 43 / 104:   4%|         | 104/2690 [00:00<00:01, 2540.09it/s][Succeeded / Failed / Skipped / Total] 44 / 18 / 43 / 105:   4%|         | 105/2690 [00:00<00:01, 2540.73it/s][Succeeded / Failed / Skipped / Total] 44 / 18 / 44 / 106:   4%|         | 106/2690 [00:00<00:01, 2552.54it/s]
--------------------------------------------- Result 104 ---------------------------------------------
[[0 (75%)]] --> [[1 (51%)]] --> Socre: 0.5144439935684204

[[[[Adv]]]]: int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind, const char *version, const char *[[serial]], const char *model, uint64_t wwn, uint32_t [[cylinders]], uint32_t heads, uint32_t secs, int chs_trans) OPEN_CURLY_TOKEN uint64_t [[nb_sectors]]; s-GREATER_TOKENblk = blk; s-GREATER_TOKENdrive_kind = kind; blk_get_geometry(blk, &[[nb_sectors]]); s-GREATER_TOKENcylinders = [[cylinders]]; s-GREATER_TOKENheads = heads; s-GREATER_TOKENsectors = secs; s-GREATER_TOKENchs_trans = chs_trans; s-GREATER_TOKENnb_sectors = [[nb_sectors]]; s-GREATER_TOKENwwn = wwn; s-GREATER_TOKENsmart_enabled = 1; s-GREATER_TOKENsmart_autosave = 1; s-GREATER_TOKENsmart_errors = 0; s-GREATER_TOKENsmart_selftest_count = 0; if (kind == IDE_CD) OPEN_CURLY_TOKEN blk_set_dev_ops(blk, &ide_cd_block_ops, s); blk_set_guest_block_size(blk, 2048); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (!blk_is_inserted(s-GREATER_TOKENblk)) OPEN_CURLY_TOKEN error_report("Device needs media, but drive is empty"); return -1; CLOSE_CURLY_TOKEN if (blk_is_read_only(blk)) OPEN_CURLY_TOKEN error_report("Can't use a read-only drive"); return -1; CLOSE_CURLY_TOKEN blk_set_dev_ops(blk, &ide_hd_block_ops, s); CLOSE_CURLY_TOKEN if ([[serial]]) OPEN_CURLY_TOKEN pstrcpy(s-GREATER_TOKENdrive_serial_str, sizeof(s-GREATER_TOKENdrive_serial_str), [[serial]]); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN snprintf(s-GREATER_TOKENdrive_serial_str, sizeof(s-GREATER_TOKENdrive_serial_str), "QM%05d", s-GREATER_TOKENdrive_serial); CLOSE_CURLY_TOKEN if (model) OPEN_CURLY_TOKEN pstrcpy(s-GREATER_TOKENdrive_model_str, sizeof(s-GREATER_TOKENdrive_model_str), model); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN switch (kind) OPEN_CURLY_TOKEN case IDE_CD: strcpy(s-GREATER_TOKENdrive_model_str, "QEMU DVD-ROM"); break; case IDE_CFATA: strcpy(s-GREATER_TOKENdrive_model_str, "QEMU MICRODRIVE"); break; default: strcpy(s-GREATER_TOKENdrive_model_str, "QEMU HARDDISK"); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (version) OPEN_CURLY_TOKEN pstrcpy(s-GREATER_TOKENversion, sizeof(s-GREATER_TOKENversion), version); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN pstrcpy(s-GREATER_TOKENversion, sizeof(s-GREATER_TOKENversion), qemu_get_version()); CLOSE_CURLY_TOKEN ide_reset(s); blk_iostatus_enable(blk); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind, const char *version, const char *[[supervillain]], const char *model, uint64_t wwn, uint32_t [[gardiner]], uint32_t heads, uint32_t secs, int chs_trans) OPEN_CURLY_TOKEN uint64_t [[demonstrations]]; s-GREATER_TOKENblk = blk; s-GREATER_TOKENdrive_kind = kind; blk_get_geometry(blk, &[[demonstrations]]); s-GREATER_TOKENcylinders = [[gardiner]]; s-GREATER_TOKENheads = heads; s-GREATER_TOKENsectors = secs; s-GREATER_TOKENchs_trans = chs_trans; s-GREATER_TOKENnb_sectors = [[demonstrations]]; s-GREATER_TOKENwwn = wwn; s-GREATER_TOKENsmart_enabled = 1; s-GREATER_TOKENsmart_autosave = 1; s-GREATER_TOKENsmart_errors = 0; s-GREATER_TOKENsmart_selftest_count = 0; if (kind == IDE_CD) OPEN_CURLY_TOKEN blk_set_dev_ops(blk, &ide_cd_block_ops, s); blk_set_guest_block_size(blk, 2048); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (!blk_is_inserted(s-GREATER_TOKENblk)) OPEN_CURLY_TOKEN error_report("Device needs media, but drive is empty"); return -1; CLOSE_CURLY_TOKEN if (blk_is_read_only(blk)) OPEN_CURLY_TOKEN error_report("Can't use a read-only drive"); return -1; CLOSE_CURLY_TOKEN blk_set_dev_ops(blk, &ide_hd_block_ops, s); CLOSE_CURLY_TOKEN if ([[supervillain]]) OPEN_CURLY_TOKEN pstrcpy(s-GREATER_TOKENdrive_serial_str, sizeof(s-GREATER_TOKENdrive_serial_str), [[supervillain]]); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN snprintf(s-GREATER_TOKENdrive_serial_str, sizeof(s-GREATER_TOKENdrive_serial_str), "QM%05d", s-GREATER_TOKENdrive_serial); CLOSE_CURLY_TOKEN if (model) OPEN_CURLY_TOKEN pstrcpy(s-GREATER_TOKENdrive_model_str, sizeof(s-GREATER_TOKENdrive_model_str), model); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN switch (kind) OPEN_CURLY_TOKEN case IDE_CD: strcpy(s-GREATER_TOKENdrive_model_str, "QEMU DVD-ROM"); break; case IDE_CFATA: strcpy(s-GREATER_TOKENdrive_model_str, "QEMU MICRODRIVE"); break; default: strcpy(s-GREATER_TOKENdrive_model_str, "QEMU HARDDISK"); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (version) OPEN_CURLY_TOKEN pstrcpy(s-GREATER_TOKENversion, sizeof(s-GREATER_TOKENversion), version); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN pstrcpy(s-GREATER_TOKENversion, sizeof(s-GREATER_TOKENversion), qemu_get_version()); CLOSE_CURLY_TOKEN ide_reset(s); blk_iostatus_enable(blk); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 105 ---------------------------------------------
[[0 (88%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int usb_device_delete_addr(int [[busnr]], int [[addr]]) OPEN_CURLY_TOKEN USBBus *[[bus]]; USBPort *[[port]]; USBDevice *[[dev]]; [[bus]] = usb_bus_find([[busnr]]); if (![[bus]]) return -1; TAILQ_FOREACH([[port]], &[[bus]]-GREATER_TOKENused, next) OPEN_CURLY_TOKEN if ([[port]]-GREATER_TOKENdev-GREATER_TOKENaddr == [[addr]]) break; CLOSE_CURLY_TOKEN if (![[port]]) return -1; [[dev]] = [[port]]-GREATER_TOKENdev; TAILQ_REMOVE(&[[bus]]-GREATER_TOKENused, [[port]], next); [[bus]]-GREATER_TOKENnused--; usb_attach([[port]], NULL); [[dev]]-GREATER_TOKENinfo-GREATER_TOKENhandle_destroy([[dev]]); TAILQ_INSERT_TAIL(&[[bus]]-GREATER_TOKENfree, [[port]], next); [[bus]]-GREATER_TOKENnfree++; return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int usb_device_delete_addr(int [[during]], int [[tomorrow]]) OPEN_CURLY_TOKEN USBBus *[[runned]]; USBPort *[[cakes]]; USBDevice *[[overjoyed]]; [[runned]] = usb_bus_find([[during]]); if (![[runned]]) return -1; TAILQ_FOREACH([[cakes]], &[[runned]]-GREATER_TOKENused, next) OPEN_CURLY_TOKEN if ([[cakes]]-GREATER_TOKENdev-GREATER_TOKENaddr == [[tomorrow]]) break; CLOSE_CURLY_TOKEN if (![[cakes]]) return -1; [[overjoyed]] = [[cakes]]-GREATER_TOKENdev; TAILQ_REMOVE(&[[runned]]-GREATER_TOKENused, [[cakes]], next); [[runned]]-GREATER_TOKENnused--; usb_attach([[cakes]], NULL); [[overjoyed]]-GREATER_TOKENinfo-GREATER_TOKENhandle_destroy([[overjoyed]]); TAILQ_INSERT_TAIL(&[[runned]]-GREATER_TOKENfree, [[cakes]], next); [[runned]]-GREATER_TOKENnfree++; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 106 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) OPEN_CURLY_TOKEN target_ulong liobn = argsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; target_ulong ioba = argsOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; target_ulong tce = argsOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN; VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr-GREATER_TOKENvio_bus, liobn); VIOsPAPR_RTCE *rtce; if (!dev) OPEN_CURLY_TOKEN hcall_dprintf("LIOBN 0x" TARGET_FMT_lx " does not exist\n", liobn); return H_PARAMETER; CLOSE_CURLY_TOKEN ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1); #ifdef DEBUG_TCE fprintf(stderr, "spapr_vio_put_tce on %s ioba 0x" TARGET_FMT_lx " TCE 0x" TARGET_FMT_lx "\n", dev-GREATER_TOKENqdev.id, ioba, tce); #endif if (ioba GREATER_TOKEN= dev-GREATER_TOKENrtce_window_size) OPEN_CURLY_TOKEN hcall_dprintf("Out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; CLOSE_CURLY_TOKEN rtce = dev-GREATER_TOKENrtce_table + (ioba GREATER_TOKENGREATER_TOKEN SPAPR_VIO_TCE_PAGE_SHIFT); rtce-GREATER_TOKENtce = tce; return H_SUCCESS; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 107 ---------------------------------------------
[[1 (96%)]] --> [[0 (52%)]] --> Socre: 0.523116946220398

[[[[Adv]]]]: static int alloc_refcount_block(BlockDriverState *bs, int64_t [[cluster_index]], uint16_t **refcount_block) OPEN_CURLY_TOKEN BDRVQcowState *[[s]] = bs-GREATER_TOKENopaque; unsigned int [[refcount_table_index]]; int ret; BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC); [[refcount_table_index]] = [[cluster_index]] GREATER_TOKENGREATER_TOKEN [[s]]-GREATER_TOKENrefcount_block_bits; if ([[refcount_table_index]] SMALLER_TOKEN [[s]]-GREATER_TOKENrefcount_table_size) OPEN_CURLY_TOKEN uint64_t refcount_block_offset = [[s]]-GREATER_TOKENrefcount_tableOPEN_SQUARE_TOKEN[[refcount_table_index]]CLOSE_SQUARE_TOKEN & REFT_OFFSET_MASK; if (refcount_block_offset) OPEN_CURLY_TOKEN if (offset_into_cluster([[s]], refcount_block_offset)) OPEN_CURLY_TOKEN qcow2_signal_corruption(bs, "True" == "True", -1, -1, "Refblock offset %#" PRIx64 " unaligned (reftable index: " "%#x)", refcount_block_offset, [[refcount_table_index]]); return -EIO; CLOSE_CURLY_TOKEN return load_refcount_block(bs, refcount_block_offset, (void**) refcount_block); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN *refcount_block = NULL; ret = qcow2_cache_flush(bs, [[s]]-GREATER_TOKENl2_table_cache); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN int64_t new_block = alloc_clusters_noref(bs, [[s]]-GREATER_TOKENcluster_size); if (new_block SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return new_block; CLOSE_CURLY_TOKEN #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64 " at %" PRIx64 "\n", [[refcount_table_index]], [[cluster_index]] SMALLER_TOKENSMALLER_TOKEN [[s]]-GREATER_TOKENcluster_bits, new_block); #endif if (in_same_refcount_block([[s]], new_block, [[cluster_index]] SMALLER_TOKENSMALLER_TOKEN [[s]]-GREATER_TOKENcluster_bits)) OPEN_CURLY_TOKEN ret = qcow2_cache_get_empty(bs, [[s]]-GREATER_TOKENrefcount_block_cache, new_block, (void**) refcount_block); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN memset(*refcount_block, 0, [[s]]-GREATER_TOKENcluster_size); int block_index = (new_block GREATER_TOKENGREATER_TOKEN [[s]]-GREATER_TOKENcluster_bits) & ([[s]]-GREATER_TOKENrefcount_block_size - 1); (*refcount_block)OPEN_SQUARE_TOKENblock_indexCLOSE_SQUARE_TOKEN = cpu_to_be16(1); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ret = update_refcount(bs, new_block, [[s]]-GREATER_TOKENcluster_size, 1, "False" != "False", QCOW2_DISCARD_NEVER); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN ret = qcow2_cache_flush(bs, [[s]]-GREATER_TOKENrefcount_block_cache); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN ret = qcow2_cache_get_empty(bs, [[s]]-GREATER_TOKENrefcount_block_cache, new_block, (void**) refcount_block); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN memset(*refcount_block, 0, [[s]]-GREATER_TOKENcluster_size); CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_WRITE); qcow2_cache_entry_mark_dirty([[s]]-GREATER_TOKENrefcount_block_cache, *refcount_block); ret = qcow2_cache_flush(bs, [[s]]-GREATER_TOKENrefcount_block_cache); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN if ([[refcount_table_index]] SMALLER_TOKEN [[s]]-GREATER_TOKENrefcount_table_size) OPEN_CURLY_TOKEN uint64_t data64 = cpu_to_be64(new_block); BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_HOOKUP); ret = bdrv_pwrite_sync(bs-GREATER_TOKENfile, [[s]]-GREATER_TOKENrefcount_table_offset + [[refcount_table_index]] * sizeof(uint64_t), &data64, sizeof(data64)); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN [[s]]-GREATER_TOKENrefcount_tableOPEN_SQUARE_TOKEN[[refcount_table_index]]CLOSE_SQUARE_TOKEN = new_block; return -EAGAIN; CLOSE_CURLY_TOKEN ret = qcow2_cache_put(bs, [[s]]-GREATER_TOKENrefcount_block_cache, (void**) refcount_block); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFTABLE_GROW); uint64_t blocks_used = DIV_ROUND_UP([[cluster_index]], [[s]]-GREATER_TOKENrefcount_block_size); if (blocks_used GREATER_TOKEN QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) OPEN_CURLY_TOKEN return -EFBIG; CLOSE_CURLY_TOKEN uint64_t table_size = next_refcount_table_size([[s]], blocks_used + 1); uint64_t last_table_size; uint64_t blocks_clusters; do OPEN_CURLY_TOKEN uint64_t [[table_clusters]] = size_to_clusters([[s]], table_size * sizeof(uint64_t)); blocks_clusters = 1 + (([[table_clusters]] + [[s]]-GREATER_TOKENrefcount_block_size - 1) / [[s]]-GREATER_TOKENrefcount_block_size); uint64_t meta_clusters = [[table_clusters]] + blocks_clusters; last_table_size = table_size; table_size = next_refcount_table_size([[s]], blocks_used + ((meta_clusters + [[s]]-GREATER_TOKENrefcount_block_size - 1) / [[s]]-GREATER_TOKENrefcount_block_size)); CLOSE_CURLY_TOKEN while (last_table_size != table_size); #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " =GREATER_TOKEN %" PRId64 "\n", [[s]]-GREATER_TOKENrefcount_table_size, table_size); #endif uint64_t meta_offset = (blocks_used * [[s]]-GREATER_TOKENrefcount_block_size) * [[s]]-GREATER_TOKENcluster_size; uint64_t table_offset = meta_offset + blocks_clusters * [[s]]-GREATER_TOKENcluster_size; uint64_t *new_table = g_try_new0(uint64_t, table_size); uint16_t *new_blocks = g_try_malloc0(blocks_clusters * [[s]]-GREATER_TOKENcluster_size); assert(table_size GREATER_TOKEN 0 && blocks_clusters GREATER_TOKEN 0); if (new_table == NULL || new_blocks == NULL) OPEN_CURLY_TOKEN ret = -ENOMEM; goto fail_table; CLOSE_CURLY_TOKEN memcpy(new_table, [[s]]-GREATER_TOKENrefcount_table, [[s]]-GREATER_TOKENrefcount_table_size * sizeof(uint64_t)); new_tableOPEN_SQUARE_TOKEN[[refcount_table_index]]CLOSE_SQUARE_TOKEN = new_block; int i; for (i = 0; i SMALLER_TOKEN blocks_clusters; i++) OPEN_CURLY_TOKEN new_tableOPEN_SQUARE_TOKENblocks_used + iCLOSE_SQUARE_TOKEN = meta_offset + (i * [[s]]-GREATER_TOKENcluster_size); CLOSE_CURLY_TOKEN uint64_t [[table_clusters]] = size_to_clusters([[s]], table_size * sizeof(uint64_t)); int block = 0; for (i = 0; i SMALLER_TOKEN [[table_clusters]] + blocks_clusters; i++) OPEN_CURLY_TOKEN new_blocksOPEN_SQUARE_TOKENblock++CLOSE_SQUARE_TOKEN = cpu_to_be16(1); CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS); ret = bdrv_pwrite_sync(bs-GREATER_TOKENfile, meta_offset, new_blocks, blocks_clusters * [[s]]-GREATER_TOKENcluster_size); g_free(new_blocks); new_blocks = NULL; if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_table; CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN table_size; i++) OPEN_CURLY_TOKEN cpu_to_be64s(&new_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE); ret = bdrv_pwrite_sync(bs-GREATER_TOKENfile, table_offset, new_table, table_size * sizeof(uint64_t)); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_table; CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN table_size; i++) OPEN_CURLY_TOKEN be64_to_cpus(&new_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN uint8_t dataOPEN_SQUARE_TOKEN12CLOSE_SQUARE_TOKEN; cpu_to_be64w((uint64_t*)data, table_offset); cpu_to_be32w((uint32_t*)(data + 8), [[table_clusters]]); BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE); ret = bdrv_pwrite_sync(bs-GREATER_TOKENfile, offsetof(QCowHeader, refcount_table_offset), data, sizeof(data)); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_table; CLOSE_CURLY_TOKEN uint64_t old_table_offset = [[s]]-GREATER_TOKENrefcount_table_offset; uint64_t old_table_size = [[s]]-GREATER_TOKENrefcount_table_size; g_free([[s]]-GREATER_TOKENrefcount_table); [[s]]-GREATER_TOKENrefcount_table = new_table; [[s]]-GREATER_TOKENrefcount_table_size = table_size; [[s]]-GREATER_TOKENrefcount_table_offset = table_offset; qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t), QCOW2_DISCARD_OTHER); ret = load_refcount_block(bs, new_block, (void**) refcount_block); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN return -EAGAIN; fail_table: g_free(new_blocks); g_free(new_table); fail_block: if (*refcount_block != NULL) OPEN_CURLY_TOKEN qcow2_cache_put(bs, [[s]]-GREATER_TOKENrefcount_block_cache, (void**) refcount_block); CLOSE_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int alloc_refcount_block(BlockDriverState *bs, int64_t [[okayama]], uint16_t **refcount_block) OPEN_CURLY_TOKEN BDRVQcowState *[[nascimento]] = bs-GREATER_TOKENopaque; unsigned int [[unpunished]]; int ret; BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC); [[unpunished]] = [[okayama]] GREATER_TOKENGREATER_TOKEN [[nascimento]]-GREATER_TOKENrefcount_block_bits; if ([[unpunished]] SMALLER_TOKEN [[nascimento]]-GREATER_TOKENrefcount_table_size) OPEN_CURLY_TOKEN uint64_t refcount_block_offset = [[nascimento]]-GREATER_TOKENrefcount_tableOPEN_SQUARE_TOKEN[[unpunished]]CLOSE_SQUARE_TOKEN & REFT_OFFSET_MASK; if (refcount_block_offset) OPEN_CURLY_TOKEN if (offset_into_cluster([[nascimento]], refcount_block_offset)) OPEN_CURLY_TOKEN qcow2_signal_corruption(bs, "True" == "True", -1, -1, "Refblock offset %#" PRIx64 " unaligned (reftable index: " "%#x)", refcount_block_offset, [[unpunished]]); return -EIO; CLOSE_CURLY_TOKEN return load_refcount_block(bs, refcount_block_offset, (void**) refcount_block); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN *refcount_block = NULL; ret = qcow2_cache_flush(bs, [[nascimento]]-GREATER_TOKENl2_table_cache); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN int64_t new_block = alloc_clusters_noref(bs, [[nascimento]]-GREATER_TOKENcluster_size); if (new_block SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return new_block; CLOSE_CURLY_TOKEN #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64 " at %" PRIx64 "\n", [[unpunished]], [[okayama]] SMALLER_TOKENSMALLER_TOKEN [[nascimento]]-GREATER_TOKENcluster_bits, new_block); #endif if (in_same_refcount_block([[nascimento]], new_block, [[okayama]] SMALLER_TOKENSMALLER_TOKEN [[nascimento]]-GREATER_TOKENcluster_bits)) OPEN_CURLY_TOKEN ret = qcow2_cache_get_empty(bs, [[nascimento]]-GREATER_TOKENrefcount_block_cache, new_block, (void**) refcount_block); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN memset(*refcount_block, 0, [[nascimento]]-GREATER_TOKENcluster_size); int block_index = (new_block GREATER_TOKENGREATER_TOKEN [[nascimento]]-GREATER_TOKENcluster_bits) & ([[nascimento]]-GREATER_TOKENrefcount_block_size - 1); (*refcount_block)OPEN_SQUARE_TOKENblock_indexCLOSE_SQUARE_TOKEN = cpu_to_be16(1); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN ret = update_refcount(bs, new_block, [[nascimento]]-GREATER_TOKENcluster_size, 1, "False" != "False", QCOW2_DISCARD_NEVER); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN ret = qcow2_cache_flush(bs, [[nascimento]]-GREATER_TOKENrefcount_block_cache); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN ret = qcow2_cache_get_empty(bs, [[nascimento]]-GREATER_TOKENrefcount_block_cache, new_block, (void**) refcount_block); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN memset(*refcount_block, 0, [[nascimento]]-GREATER_TOKENcluster_size); CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_WRITE); qcow2_cache_entry_mark_dirty([[nascimento]]-GREATER_TOKENrefcount_block_cache, *refcount_block); ret = qcow2_cache_flush(bs, [[nascimento]]-GREATER_TOKENrefcount_block_cache); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN if ([[unpunished]] SMALLER_TOKEN [[nascimento]]-GREATER_TOKENrefcount_table_size) OPEN_CURLY_TOKEN uint64_t data64 = cpu_to_be64(new_block); BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_HOOKUP); ret = bdrv_pwrite_sync(bs-GREATER_TOKENfile, [[nascimento]]-GREATER_TOKENrefcount_table_offset + [[unpunished]] * sizeof(uint64_t), &data64, sizeof(data64)); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN [[nascimento]]-GREATER_TOKENrefcount_tableOPEN_SQUARE_TOKEN[[unpunished]]CLOSE_SQUARE_TOKEN = new_block; return -EAGAIN; CLOSE_CURLY_TOKEN ret = qcow2_cache_put(bs, [[nascimento]]-GREATER_TOKENrefcount_block_cache, (void**) refcount_block); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_block; CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFTABLE_GROW); uint64_t blocks_used = DIV_ROUND_UP([[okayama]], [[nascimento]]-GREATER_TOKENrefcount_block_size); if (blocks_used GREATER_TOKEN QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) OPEN_CURLY_TOKEN return -EFBIG; CLOSE_CURLY_TOKEN uint64_t table_size = next_refcount_table_size([[nascimento]], blocks_used + 1); uint64_t last_table_size; uint64_t blocks_clusters; do OPEN_CURLY_TOKEN uint64_t [[wonderboy]] = size_to_clusters([[nascimento]], table_size * sizeof(uint64_t)); blocks_clusters = 1 + (([[wonderboy]] + [[nascimento]]-GREATER_TOKENrefcount_block_size - 1) / [[nascimento]]-GREATER_TOKENrefcount_block_size); uint64_t meta_clusters = [[wonderboy]] + blocks_clusters; last_table_size = table_size; table_size = next_refcount_table_size([[nascimento]], blocks_used + ((meta_clusters + [[nascimento]]-GREATER_TOKENrefcount_block_size - 1) / [[nascimento]]-GREATER_TOKENrefcount_block_size)); CLOSE_CURLY_TOKEN while (last_table_size != table_size); #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " =GREATER_TOKEN %" PRId64 "\n", [[nascimento]]-GREATER_TOKENrefcount_table_size, table_size); #endif uint64_t meta_offset = (blocks_used * [[nascimento]]-GREATER_TOKENrefcount_block_size) * [[nascimento]]-GREATER_TOKENcluster_size; uint64_t table_offset = meta_offset + blocks_clusters * [[nascimento]]-GREATER_TOKENcluster_size; uint64_t *new_table = g_try_new0(uint64_t, table_size); uint16_t *new_blocks = g_try_malloc0(blocks_clusters * [[nascimento]]-GREATER_TOKENcluster_size); assert(table_size GREATER_TOKEN 0 && blocks_clusters GREATER_TOKEN 0); if (new_table == NULL || new_blocks == NULL) OPEN_CURLY_TOKEN ret = -ENOMEM; goto fail_table; CLOSE_CURLY_TOKEN memcpy(new_table, [[nascimento]]-GREATER_TOKENrefcount_table, [[nascimento]]-GREATER_TOKENrefcount_table_size * sizeof(uint64_t)); new_tableOPEN_SQUARE_TOKEN[[unpunished]]CLOSE_SQUARE_TOKEN = new_block; int i; for (i = 0; i SMALLER_TOKEN blocks_clusters; i++) OPEN_CURLY_TOKEN new_tableOPEN_SQUARE_TOKENblocks_used + iCLOSE_SQUARE_TOKEN = meta_offset + (i * [[nascimento]]-GREATER_TOKENcluster_size); CLOSE_CURLY_TOKEN uint64_t [[wonderboy]] = size_to_clusters([[nascimento]], table_size * sizeof(uint64_t)); int block = 0; for (i = 0; i SMALLER_TOKEN [[wonderboy]] + blocks_clusters; i++) OPEN_CURLY_TOKEN new_blocksOPEN_SQUARE_TOKENblock++CLOSE_SQUARE_TOKEN = cpu_to_be16(1); CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS); ret = bdrv_pwrite_sync(bs-GREATER_TOKENfile, meta_offset, new_blocks, blocks_clusters * [[nascimento]]-GREATER_TOKENcluster_size); g_free(new_blocks); new_blocks = NULL; if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_table; CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN table_size; i++) OPEN_CURLY_TOKEN cpu_to_be64s(&new_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE); ret = bdrv_pwrite_sync(bs-GREATER_TOKENfile, table_offset, new_table, table_size * sizeof(uint64_t)); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_table; CLOSE_CURLY_TOKEN for(i = 0; i SMALLER_TOKEN table_size; i++) OPEN_CURLY_TOKEN be64_to_cpus(&new_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN uint8_t dataOPEN_SQUARE_TOKEN12CLOSE_SQUARE_TOKEN; cpu_to_be64w((uint64_t*)data, table_offset); cpu_to_be32w((uint32_t*)(data + 8), [[wonderboy]]); BLKDBG_EVENT(bs-GREATER_TOKENfile, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE); ret = bdrv_pwrite_sync(bs-GREATER_TOKENfile, offsetof(QCowHeader, refcount_table_offset), data, sizeof(data)); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto fail_table; CLOSE_CURLY_TOKEN uint64_t old_table_offset = [[nascimento]]-GREATER_TOKENrefcount_table_offset; uint64_t old_table_size = [[nascimento]]-GREATER_TOKENrefcount_table_size; g_free([[nascimento]]-GREATER_TOKENrefcount_table); [[nascimento]]-GREATER_TOKENrefcount_table = new_table; [[nascimento]]-GREATER_TOKENrefcount_table_size = table_size; [[nascimento]]-GREATER_TOKENrefcount_table_offset = table_offset; qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t), QCOW2_DISCARD_OTHER); ret = load_refcount_block(bs, new_block, (void**) refcount_block); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN return -EAGAIN; fail_table: g_free(new_blocks); g_free(new_table); fail_block: if (*refcount_block != NULL) OPEN_CURLY_TOKEN qcow2_cache_put(bs, [[nascimento]]-GREATER_TOKENrefcount_block_cache, (void**) refcount_block); CLOSE_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 45 / 18 / 44 / 107:   4%|         | 107/2690 [00:00<00:01, 2489.26it/s][Succeeded / Failed / Skipped / Total] 45 / 18 / 45 / 108:   4%|         | 108/2690 [00:00<00:01, 2498.66it/s][Succeeded / Failed / Skipped / Total] 45 / 19 / 45 / 109:   4%|         | 109/2690 [00:00<00:01, 2498.79it/s][Succeeded / Failed / Skipped / Total] 46 / 19 / 45 / 110:   4%|         | 110/2690 [00:00<00:01, 2503.82it/s][Succeeded / Failed / Skipped / Total] 46 / 19 / 46 / 111:   4%|         | 111/2690 [00:00<00:01, 2515.40it/s]
--------------------------------------------- Result 108 ---------------------------------------------
[[1 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int getopt(int argc, char *argvOPEN_SQUARE_TOKENCLOSE_SQUARE_TOKEN, char *opts) OPEN_CURLY_TOKEN static int sp = 1; int c; char *cp; if (sp == 1) if (optind GREATER_TOKEN= argc || argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN != '-' || argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN == '\0') return EOF; else if (!strcmp(argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKEN, "--")) OPEN_CURLY_TOKEN optind++; return EOF; CLOSE_CURLY_TOKEN optopt = c = argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENspCLOSE_SQUARE_TOKEN; if (c == ':' || (cp = strchr(opts, c)) == NULL) OPEN_CURLY_TOKEN fprintf(stderr, ": illegal option -- %c\n", c); if (argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN++spCLOSE_SQUARE_TOKEN == '\0') OPEN_CURLY_TOKEN optind++; sp = 1; CLOSE_CURLY_TOKEN return '?'; CLOSE_CURLY_TOKEN if (*++cp == ':') OPEN_CURLY_TOKEN if (argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENsp+1CLOSE_SQUARE_TOKEN != '\0') optarg = &argvOPEN_SQUARE_TOKENoptind++CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENsp+1CLOSE_SQUARE_TOKEN; else if(++optind GREATER_TOKEN= argc) OPEN_CURLY_TOKEN fprintf(stderr, ": option requires an argument -- %c\n", c); sp = 1; return '?'; CLOSE_CURLY_TOKEN else optarg = argvOPEN_SQUARE_TOKENoptind++CLOSE_SQUARE_TOKEN; sp = 1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (argvOPEN_SQUARE_TOKENoptindCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN++spCLOSE_SQUARE_TOKEN == '\0') OPEN_CURLY_TOKEN sp = 1; optind++; CLOSE_CURLY_TOKEN optarg = NULL; CLOSE_CURLY_TOKEN return c; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 109 ---------------------------------------------
[[1 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int [[width]]) OPEN_CURLY_TOKEN int [[i]]; for([[i]]=0; [[i]]SMALLER_TOKEN[[width]]; [[i]]++) OPEN_CURLY_TOKEN int [[r]]= ((uint32_t*)src)OPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN&0xFF; int [[g]]= (((uint32_t*)src)OPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKENGREATER_TOKENGREATER_TOKEN8)&0xFF; int [[b]]= (((uint32_t*)src)OPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKENGREATER_TOKENGREATER_TOKEN16)&0xFF; dstOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN= ((RY*[[r]] + GY*[[g]] + BY*[[b]] + (33SMALLER_TOKENSMALLER_TOKEN(RGB2YUV_SHIFT-1)) )GREATER_TOKENGREATER_TOKENRGB2YUV_SHIFT); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int [[lko]]) OPEN_CURLY_TOKEN int [[slut]]; for([[slut]]=0; [[slut]]SMALLER_TOKEN[[lko]]; [[slut]]++) OPEN_CURLY_TOKEN int [[newtonian]]= ((uint32_t*)src)OPEN_SQUARE_TOKEN[[slut]]CLOSE_SQUARE_TOKEN&0xFF; int [[gym]]= (((uint32_t*)src)OPEN_SQUARE_TOKEN[[slut]]CLOSE_SQUARE_TOKENGREATER_TOKENGREATER_TOKEN8)&0xFF; int [[radiating]]= (((uint32_t*)src)OPEN_SQUARE_TOKEN[[slut]]CLOSE_SQUARE_TOKENGREATER_TOKENGREATER_TOKEN16)&0xFF; dstOPEN_SQUARE_TOKEN[[slut]]CLOSE_SQUARE_TOKEN= ((RY*[[newtonian]] + GY*[[gym]] + BY*[[radiating]] + (33SMALLER_TOKENSMALLER_TOKEN(RGB2YUV_SHIFT-1)) )GREATER_TOKENGREATER_TOKENRGB2YUV_SHIFT); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 110 ---------------------------------------------
[[1 (63%)]] --> [[0 (67%)]] --> Socre: 0.6735564470291138

[[[[Adv]]]]: static av_cold int png_dec_end(AVCodecContext *avctx) OPEN_CURLY_TOKEN PNGDecContext *[[s]] = avctx-GREATER_TOKENpriv_data; ff_thread_release_buffer(avctx, &[[s]]-GREATER_TOKENprevious_picture); av_frame_free(&[[s]]-GREATER_TOKENprevious_picture.f); ff_thread_release_buffer(avctx, &[[s]]-GREATER_TOKENlast_picture); av_frame_free(&[[s]]-GREATER_TOKENlast_picture.f); ff_thread_release_buffer(avctx, &[[s]]-GREATER_TOKENpicture); av_frame_free(&[[s]]-GREATER_TOKENpicture.f); av_freep(&[[s]]-GREATER_TOKENbuffer); [[s]]-GREATER_TOKENbuffer_size = 0; av_freep(&[[s]]-GREATER_TOKENlast_row); [[s]]-GREATER_TOKENlast_row_size = 0; av_freep(&[[s]]-GREATER_TOKENtmp_row); [[s]]-GREATER_TOKENtmp_row_size = 0; av_freep(&[[s]]-GREATER_TOKENextra_data); [[s]]-GREATER_TOKENextra_data_size = 0; return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static av_cold int png_dec_end(AVCodecContext *avctx) OPEN_CURLY_TOKEN PNGDecContext *[[calibrating]] = avctx-GREATER_TOKENpriv_data; ff_thread_release_buffer(avctx, &[[calibrating]]-GREATER_TOKENprevious_picture); av_frame_free(&[[calibrating]]-GREATER_TOKENprevious_picture.f); ff_thread_release_buffer(avctx, &[[calibrating]]-GREATER_TOKENlast_picture); av_frame_free(&[[calibrating]]-GREATER_TOKENlast_picture.f); ff_thread_release_buffer(avctx, &[[calibrating]]-GREATER_TOKENpicture); av_frame_free(&[[calibrating]]-GREATER_TOKENpicture.f); av_freep(&[[calibrating]]-GREATER_TOKENbuffer); [[calibrating]]-GREATER_TOKENbuffer_size = 0; av_freep(&[[calibrating]]-GREATER_TOKENlast_row); [[calibrating]]-GREATER_TOKENlast_row_size = 0; av_freep(&[[calibrating]]-GREATER_TOKENtmp_row); [[calibrating]]-GREATER_TOKENtmp_row_size = 0; av_freep(&[[calibrating]]-GREATER_TOKENextra_data); [[calibrating]]-GREATER_TOKENextra_data_size = 0; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 111 ---------------------------------------------
[[0 (94%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) OPEN_CURLY_TOKEN NvmeCtrl *s = NVME(obj); visit_type_int32(v, &s-GREATER_TOKENconf.bootindex, name, errp); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 112 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 46 / 19 / 47 / 112:   4%|         | 112/2690 [00:00<00:01, 2525.91it/s][Succeeded / Failed / Skipped / Total] 46 / 19 / 48 / 113:   4%|         | 113/2690 [00:00<00:01, 2538.26it/s][Succeeded / Failed / Skipped / Total] 46 / 19 / 49 / 114:   4%|         | 114/2690 [00:00<00:01, 2550.25it/s][Succeeded / Failed / Skipped / Total] 47 / 19 / 49 / 115:   4%|         | 115/2690 [00:00<00:01, 2556.91it/s][[0 (95%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64) OPEN_CURLY_TOKEN TCGReg datalo, datahi, addrlo, rbase; TCGReg addrhi __attribute__((unused)); TCGMemOpIdx oi; TCGMemOp opc, s_bits; #ifdef CONFIG_SOFTMMU int mem_index; tcg_insn_unit *label_ptr; #endif datalo = *args++; datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0); addrlo = *args++; addrhi = (TCG_TARGET_REG_BITS SMALLER_TOKEN TARGET_LONG_BITS ? *args++ : 0); oi = *args++; opc = get_memop(oi); s_bits = opc & MO_SIZE; #ifdef CONFIG_SOFTMMU mem_index = get_mmuidx(oi); addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, "True" == "True"); label_ptr = s-GREATER_TOKENcode_ptr; tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK); rbase = TCG_REG_R3; #else rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0; if (TCG_TARGET_REG_BITS GREATER_TOKEN TARGET_LONG_BITS) OPEN_CURLY_TOKEN tcg_out_ext32u(s, TCG_REG_TMP1, addrlo); addrlo = TCG_REG_TMP1; CLOSE_CURLY_TOKEN #endif if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) OPEN_CURLY_TOKEN if (opc & MO_BSWAP) OPEN_CURLY_TOKEN tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0)); CLOSE_CURLY_TOKEN else if (rbase != 0) OPEN_CURLY_TOKEN tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo)); tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0)); CLOSE_CURLY_TOKEN else if (addrlo == datahi) OPEN_CURLY_TOKEN tcg_out32(s, LWZ | TAI(datalo, addrlo, 4)); tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); tcg_out32(s, LWZ | TAI(datalo, addrlo, 4)); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN uint32_t insn = qemu_ldx_opcOPEN_SQUARE_TOKENopc & (MO_BSWAP | MO_SSIZE)CLOSE_SQUARE_TOKEN; if (!HAVE_ISA_2_06 && insn == LDBRX) OPEN_CURLY_TOKEN tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0)); tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0); CLOSE_CURLY_TOKEN else if (insn) OPEN_CURLY_TOKEN tcg_out32(s, insn | TAB(datalo, rbase, addrlo)); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN insn = qemu_ldx_opcOPEN_SQUARE_TOKENopc & (MO_SIZE | MO_BSWAP)CLOSE_SQUARE_TOKEN; tcg_out32(s, insn | TAB(datalo, rbase, addrlo)); insn = qemu_exts_opcOPEN_SQUARE_TOKENs_bitsCLOSE_SQUARE_TOKEN; tcg_out32(s, insn | RA(datalo) | RS(datalo)); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN #ifdef CONFIG_SOFTMMU add_qemu_ldst_label(s, "True" == "True", oi, datalo, datahi, addrlo, addrhi, s-GREATER_TOKENcode_ptr, label_ptr); #endif CLOSE_CURLY_TOKEN
--------------------------------------------- Result 113 ---------------------------------------------
[[1 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl, GetBitContext *gb) OPEN_CURLY_TOKEN int i; MMCO *mmco = sl-GREATER_TOKENmmco; int nb_mmco = 0; if (h-GREATER_TOKENnal_unit_type == NAL_IDR_SLICE) OPEN_CURLY_TOKEN skip_bits1(gb); if (get_bits1(gb)) OPEN_CURLY_TOKEN mmcoOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.opcode = MMCO_LONG; mmcoOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.long_arg = 0; nb_mmco = 1; CLOSE_CURLY_TOKEN sl-GREATER_TOKENexplicit_ref_marking = 1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN sl-GREATER_TOKENexplicit_ref_marking = get_bits1(gb); if (sl-GREATER_TOKENexplicit_ref_marking) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN MAX_MMCO_COUNT; i++) OPEN_CURLY_TOKEN MMCOOpcode opcode = get_ue_golomb_31(gb); mmcoOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.opcode = opcode; if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) OPEN_CURLY_TOKEN mmcoOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.short_pic_num = (sl-GREATER_TOKENcurr_pic_num - get_ue_golomb(gb) - 1) & (sl-GREATER_TOKENmax_pic_num - 1); #if 0 if (mmcoOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.short_pic_num GREATER_TOKEN= h-GREATER_TOKENshort_ref_count || !h-GREATER_TOKENshort_refOPEN_SQUARE_TOKENmmcoOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.short_pic_numCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "illegal short ref in memory management control " "operation %d\n", mmco); return -1; CLOSE_CURLY_TOKEN #endif CLOSE_CURLY_TOKEN if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED || opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) OPEN_CURLY_TOKEN unsigned int long_arg = get_ue_golomb_31(gb); if (long_arg GREATER_TOKEN= 32 || (long_arg GREATER_TOKEN= 16 && !(opcode == MMCO_SET_MAX_LONG && long_arg == 16) && !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) OPEN_CURLY_TOKEN av_log(h-GREATER_TOKENavctx, AV_LOG_ERROR, "illegal long ref in memory management control " "operation %d\n", opcode); return -1; CLOSE_CURLY_TOKEN mmcoOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.long_arg = long_arg; CLOSE_CURLY_TOKEN if (opcode GREATER_TOKEN (unsigned) MMCO_LONG) OPEN_CURLY_TOKEN av_log(h-GREATER_TOKENavctx, AV_LOG_ERROR, "illegal memory management control operation %d\n", opcode); return -1; CLOSE_CURLY_TOKEN if (opcode == MMCO_END) break; CLOSE_CURLY_TOKEN nb_mmco = i; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN sl-GREATER_TOKENnb_mmco = nb_mmco; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 114 ---------------------------------------------
[[1 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) OPEN_CURLY_TOKEN target_ulong flags = argsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; target_ulong pte_index = argsOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; target_ulong pteh = argsOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN; target_ulong ptel = argsOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN; target_ulong i; uint8_t *hpte; if (pteh & HPTE_V_LARGE) OPEN_CURLY_TOKEN #if 0 if ((ptel & 0xf000) == 0x1000) OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN else #endif if ((ptel & 0xff000) == 0) OPEN_CURLY_TOKEN if (pteh & 0x80) OPEN_CURLY_TOKEN return H_PARAMETER; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN return H_PARAMETER; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if ((ptel & HPTE_R_WIMG) != HPTE_R_M) OPEN_CURLY_TOKEN return H_PARAMETER; CLOSE_CURLY_TOKEN pteh &= ~0x60ULL; if ((pte_index * HASH_PTE_SIZE_64) & ~env-GREATER_TOKENhtab_mask) OPEN_CURLY_TOKEN return H_PARAMETER; CLOSE_CURLY_TOKEN if (likely((flags & H_EXACT) == 0)) OPEN_CURLY_TOKEN pte_index &= ~7ULL; hpte = env-GREATER_TOKENexternal_htab + (pte_index * HASH_PTE_SIZE_64); for (i = 0; ; ++i) OPEN_CURLY_TOKEN if (i == 8) OPEN_CURLY_TOKEN return H_PTEG_FULL; CLOSE_CURLY_TOKEN if (((ldq_p(hpte) & HPTE_V_VALID) == 0) && lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN hpte += HASH_PTE_SIZE_64; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN i = 0; hpte = env-GREATER_TOKENexternal_htab + (pte_index * HASH_PTE_SIZE_64); if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) OPEN_CURLY_TOKEN return H_PTEG_FULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel); stq_p(hpte, pteh); assert(!(ldq_p(hpte) & HPTE_V_HVLOCK)); argsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = pte_index + i; return H_SUCCESS; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 115 ---------------------------------------------
[[0 (58%)]] --> [[1 (52%)]] --> Socre: 0.5176694393157959

[[[[Adv]]]]: void qemu_cpu_kick(void *[[env]]) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void qemu_cpu_kick(void *[[executing]]) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 116 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 47 / 19 / 50 / 116:   4%|         | 116/2690 [00:00<00:01, 2566.72it/s][Succeeded / Failed / Skipped / Total] 47 / 19 / 51 / 117:   4%|         | 117/2690 [00:00<00:00, 2577.65it/s][Succeeded / Failed / Skipped / Total] 47 / 19 / 52 / 118:   4%|         | 118/2690 [00:00<00:00, 2589.65it/s][Succeeded / Failed / Skipped / Total] 48 / 19 / 52 / 119:   4%|         | 119/2690 [00:00<00:00, 2592.12it/s][[0 (75%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr) OPEN_CURLY_TOKEN KVMState *s = kvm_state; unsigned long size, allocated_size = 0; KVMDirtyLog d; KVMSlot *mem; int ret = 0; d.dirty_bitmap = NULL; while (start_addr SMALLER_TOKEN end_addr) OPEN_CURLY_TOKEN mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr); if (mem == NULL) OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN size = ALIGN(((mem-GREATER_TOKENmemory_size) GREATER_TOKENGREATER_TOKEN TARGET_PAGE_BITS), HOST_LONG_BITS) / 8; if (!d.dirty_bitmap) OPEN_CURLY_TOKEN d.dirty_bitmap = qemu_malloc(size); CLOSE_CURLY_TOKEN else if (size GREATER_TOKEN allocated_size) OPEN_CURLY_TOKEN d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size); CLOSE_CURLY_TOKEN allocated_size = size; memset(d.dirty_bitmap, 0, allocated_size); d.slot = mem-GREATER_TOKENslot; if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) OPEN_CURLY_TOKEN DPRINTF("ioctl failed %d\n", errno); ret = -1; break; CLOSE_CURLY_TOKEN kvm_get_dirty_pages_log_range(mem-GREATER_TOKENstart_addr, d.dirty_bitmap, mem-GREATER_TOKENstart_addr, mem-GREATER_TOKENmemory_size); start_addr = mem-GREATER_TOKENstart_addr + mem-GREATER_TOKENmemory_size; CLOSE_CURLY_TOKEN qemu_free(d.dirty_bitmap); return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 117 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int len, AVPacket *pkt, int *seq, int flags, int64_t timestamp) OPEN_CURLY_TOKEN RMDemuxContext *rm = s-GREATER_TOKENpriv_data; int ret; if (st-GREATER_TOKENcodec-GREATER_TOKENcodec_type == AVMEDIA_TYPE_VIDEO) OPEN_CURLY_TOKEN rm-GREATER_TOKENcurrent_stream= st-GREATER_TOKENid; ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp); if(ret) return ret SMALLER_TOKEN 0 ? ret : -1; CLOSE_CURLY_TOKEN else if (st-GREATER_TOKENcodec-GREATER_TOKENcodec_type == AVMEDIA_TYPE_AUDIO) OPEN_CURLY_TOKEN if ((ast-GREATER_TOKENdeint_id == DEINT_ID_GENR) || (ast-GREATER_TOKENdeint_id == DEINT_ID_INT4) || (ast-GREATER_TOKENdeint_id == DEINT_ID_SIPR)) OPEN_CURLY_TOKEN int x; int sps = ast-GREATER_TOKENsub_packet_size; int cfs = ast-GREATER_TOKENcoded_framesize; int h = ast-GREATER_TOKENsub_packet_h; int y = ast-GREATER_TOKENsub_packet_cnt; int w = ast-GREATER_TOKENaudio_framesize; if (flags & 2) y = ast-GREATER_TOKENsub_packet_cnt = 0; if (!y) ast-GREATER_TOKENaudiotimestamp = timestamp; switch (ast-GREATER_TOKENdeint_id) OPEN_CURLY_TOKEN case DEINT_ID_INT4: for (x = 0; x SMALLER_TOKEN h/2; x++) avio_read(pb, ast-GREATER_TOKENpkt.data+x*2*w+y*cfs, cfs); break; case DEINT_ID_GENR: for (x = 0; x SMALLER_TOKEN w/sps; x++) avio_read(pb, ast-GREATER_TOKENpkt.data+sps*(h*x+((h+1)/2)*(y&1)+(yGREATER_TOKENGREATER_TOKEN1)), sps); break; case DEINT_ID_SIPR: avio_read(pb, ast-GREATER_TOKENpkt.data + y * w, w); break; CLOSE_CURLY_TOKEN if (++(ast-GREATER_TOKENsub_packet_cnt) SMALLER_TOKEN h) return -1; if (ast-GREATER_TOKENdeint_id == DEINT_ID_SIPR) ff_rm_reorder_sipr_data(ast-GREATER_TOKENpkt.data, h, w); ast-GREATER_TOKENsub_packet_cnt = 0; rm-GREATER_TOKENaudio_stream_num = st-GREATER_TOKENindex; rm-GREATER_TOKENaudio_pkt_cnt = h * w / st-GREATER_TOKENcodec-GREATER_TOKENblock_align; CLOSE_CURLY_TOKEN else if ((ast-GREATER_TOKENdeint_id == DEINT_ID_VBRF) || (ast-GREATER_TOKENdeint_id == DEINT_ID_VBRS)) OPEN_CURLY_TOKEN int x; rm-GREATER_TOKENaudio_stream_num = st-GREATER_TOKENindex; ast-GREATER_TOKENsub_packet_cnt = (avio_rb16(pb) & 0xf0) GREATER_TOKENGREATER_TOKEN 4; if (ast-GREATER_TOKENsub_packet_cnt) OPEN_CURLY_TOKEN for (x = 0; x SMALLER_TOKEN ast-GREATER_TOKENsub_packet_cnt; x++) ast-GREATER_TOKENsub_packet_lengthsOPEN_SQUARE_TOKENxCLOSE_SQUARE_TOKEN = avio_rb16(pb); rm-GREATER_TOKENaudio_pkt_cnt = ast-GREATER_TOKENsub_packet_cnt; ast-GREATER_TOKENaudiotimestamp = timestamp; CLOSE_CURLY_TOKEN else return -1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN av_get_packet(pb, pkt, len); rm_ac3_swap_bytes(st, pkt); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else av_get_packet(pb, pkt, len); pkt-GREATER_TOKENstream_index = st-GREATER_TOKENindex; #if 0 if (st-GREATER_TOKENcodec-GREATER_TOKENcodec_type == AVMEDIA_TYPE_VIDEO) OPEN_CURLY_TOKEN if(st-GREATER_TOKENcodec-GREATER_TOKENcodec_id == AV_CODEC_ID_RV20)OPEN_CURLY_TOKEN int seq= 128*(pkt-GREATER_TOKENdataOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN&0x7F) + (pkt-GREATER_TOKENdataOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKENGREATER_TOKENGREATER_TOKEN1); av_log(s, AV_LOG_DEBUG, "%d %"PRId64" %d\n", *timestamp, *timestamp*512LL/25, seq); seq |= (timestamp&~0x3FFF); if(seq - timestamp GREATER_TOKEN 0x2000) seq -= 0x4000; if(seq - timestamp SMALLER_TOKEN -0x2000) seq += 0x4000; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN #endif pkt-GREATER_TOKENpts = timestamp; if (flags & 2) pkt-GREATER_TOKENflags |= AV_PKT_FLAG_KEY; return st-GREATER_TOKENcodec-GREATER_TOKENcodec_type == AVMEDIA_TYPE_AUDIO ? rm-GREATER_TOKENaudio_pkt_cnt : 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 118 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1, TCGv arg2, int add_ca, int compute_ca, int compute_ov) OPEN_CURLY_TOKEN TCGv t0, t1; if ((!compute_ca && !compute_ov) || (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2))) OPEN_CURLY_TOKEN t0 = ret; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN t0 = tcg_temp_local_new(); CLOSE_CURLY_TOKEN if (add_ca) OPEN_CURLY_TOKEN t1 = tcg_temp_local_new(); tcg_gen_mov_tl(t1, cpu_ca); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN TCGV_UNUSED(t1); CLOSE_CURLY_TOKEN if (compute_ca) OPEN_CURLY_TOKEN tcg_gen_movi_tl(cpu_ca, 0); CLOSE_CURLY_TOKEN if (compute_ov) OPEN_CURLY_TOKEN tcg_gen_movi_tl(cpu_ov, 0); CLOSE_CURLY_TOKEN tcg_gen_add_tl(t0, arg1, arg2); if (compute_ca) OPEN_CURLY_TOKEN gen_op_arith_compute_ca(ctx, t0, arg1, 0); CLOSE_CURLY_TOKEN if (add_ca) OPEN_CURLY_TOKEN tcg_gen_add_tl(t0, t0, t1); gen_op_arith_compute_ca(ctx, t0, t1, 0); tcg_temp_free(t1); CLOSE_CURLY_TOKEN if (compute_ov) OPEN_CURLY_TOKEN gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0); CLOSE_CURLY_TOKEN if (unlikely(Rc(ctx-GREATER_TOKENopcode) != 0)) gen_set_Rc0(ctx, t0); if (!TCGV_EQUAL(t0, ret)) OPEN_CURLY_TOKEN tcg_gen_mov_tl(ret, t0); tcg_temp_free(t0); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 119 ---------------------------------------------
[[0 (53%)]] --> [[1 (72%)]] --> Socre: 0.7191720008850098

[[[[Adv]]]]: static void temp_allocate_frame(TCGContext *s, int [[temp]]) OPEN_CURLY_TOKEN TCGTemp *ts; ts = &s-GREATER_TOKENtempsOPEN_SQUARE_TOKEN[[temp]]CLOSE_SQUARE_TOKEN; s-GREATER_TOKENcurrent_frame_offset = (s-GREATER_TOKENcurrent_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1); if (s-GREATER_TOKENcurrent_frame_offset + sizeof(tcg_target_long) GREATER_TOKEN s-GREATER_TOKENframe_end) tcg_abort(); ts-GREATER_TOKENmem_offset = s-GREATER_TOKENcurrent_frame_offset; ts-GREATER_TOKENmem_reg = s-GREATER_TOKENframe_reg; ts-GREATER_TOKENmem_allocated = 1; s-GREATER_TOKENcurrent_frame_offset += sizeof(tcg_target_long); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void temp_allocate_frame(TCGContext *s, int [[cheche]]) OPEN_CURLY_TOKEN TCGTemp *ts; ts = &s-GREATER_TOKENtempsOPEN_SQUARE_TOKEN[[cheche]]CLOSE_SQUARE_TOKEN; s-GREATER_TOKENcurrent_frame_offset = (s-GREATER_TOKENcurrent_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1); if (s-GREATER_TOKENcurrent_frame_offset + sizeof(tcg_target_long) GREATER_TOKEN s-GREATER_TOKENframe_end) tcg_abort(); ts-GREATER_TOKENmem_offset = s-GREATER_TOKENcurrent_frame_offset; ts-GREATER_TOKENmem_reg = s-GREATER_TOKENframe_reg; ts-GREATER_TOKENmem_allocated = 1; s-GREATER_TOKENcurrent_frame_offset += sizeof(tcg_target_long); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 120 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 19 / 53 / 120:   4%|         | 120/2690 [00:00<00:00, 2601.83it/s][Succeeded / Failed / Skipped / Total] 49 / 19 / 53 / 121:   4%|         | 121/2690 [00:00<00:00, 2599.54it/s][Succeeded / Failed / Skipped / Total] 50 / 19 / 53 / 122:   5%|         | 122/2690 [00:00<00:00, 2596.17it/s][[0 (91%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: Object *object_resolve_path_component(Object *parent, const gchar *part) OPEN_CURLY_TOKEN ObjectProperty *prop = object_property_find(parent, part, NULL); if (prop == NULL) OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN if (object_property_is_link(prop)) OPEN_CURLY_TOKEN return *(Object **)prop-GREATER_TOKENopaque; CLOSE_CURLY_TOKEN else if (object_property_is_child(prop)) OPEN_CURLY_TOKEN return prop-GREATER_TOKENopaque; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 121 ---------------------------------------------
[[0 (76%)]] --> [[1 (55%)]] --> Socre: 0.5492697954177856

[[[[Adv]]]]: void qmp_block_stream(const char *device, bool has_base, const char *base, Error **errp) OPEN_CURLY_TOKEN BlockDriverState *bs; BlockDriverState *[[base_bs]] = NULL; Error *local_err = NULL; bs = bdrv_find(device); if (!bs) OPEN_CURLY_TOKEN error_set(errp, QERR_DEVICE_NOT_FOUND, device); return; CLOSE_CURLY_TOKEN if (base) OPEN_CURLY_TOKEN [[base_bs]] = bdrv_find_backing_image(bs, base); if ([[base_bs]] == NULL) OPEN_CURLY_TOKEN error_set(errp, QERR_BASE_NOT_FOUND, base); return; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN stream_start(bs, [[base_bs]], base, block_stream_cb, bs, &local_err); if (error_is_set(&local_err)) OPEN_CURLY_TOKEN error_propagate(errp, local_err); return; CLOSE_CURLY_TOKEN drive_get_ref(drive_get_by_blockdev(bs)); trace_qmp_block_stream(bs, bs-GREATER_TOKENjob); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void qmp_block_stream(const char *device, bool has_base, const char *base, Error **errp) OPEN_CURLY_TOKEN BlockDriverState *bs; BlockDriverState *[[instalment]] = NULL; Error *local_err = NULL; bs = bdrv_find(device); if (!bs) OPEN_CURLY_TOKEN error_set(errp, QERR_DEVICE_NOT_FOUND, device); return; CLOSE_CURLY_TOKEN if (base) OPEN_CURLY_TOKEN [[instalment]] = bdrv_find_backing_image(bs, base); if ([[instalment]] == NULL) OPEN_CURLY_TOKEN error_set(errp, QERR_BASE_NOT_FOUND, base); return; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN stream_start(bs, [[instalment]], base, block_stream_cb, bs, &local_err); if (error_is_set(&local_err)) OPEN_CURLY_TOKEN error_propagate(errp, local_err); return; CLOSE_CURLY_TOKEN drive_get_ref(drive_get_by_blockdev(bs)); trace_qmp_block_stream(bs, bs-GREATER_TOKENjob); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 122 ---------------------------------------------
[[1 (94%)]] --> [[0 (75%)]] --> Socre: 0.7491422891616821

[[[[Adv]]]]: static void mptsas_scsi_init(PCIDevice *[[dev]], Error **[[errp]]) OPEN_CURLY_TOKEN DeviceState *d = DEVICE([[dev]]); MPTSASState *s = MPT_SAS([[dev]]); [[dev]]-GREATER_TOKENconfigOPEN_SQUARE_TOKENPCI_LATENCY_TIMERCLOSE_SQUARE_TOKEN = 0; [[dev]]-GREATER_TOKENconfigOPEN_SQUARE_TOKENPCI_INTERRUPT_PINCLOSE_SQUARE_TOKEN = 0x01; memory_region_init_io(&s-GREATER_TOKENmmio_io, OBJECT(s), &mptsas_mmio_ops, s, "mptsas-mmio", 0x4000); memory_region_init_io(&s-GREATER_TOKENport_io, OBJECT(s), &mptsas_port_ops, s, "mptsas-io", 256); memory_region_init_io(&s-GREATER_TOKENdiag_io, OBJECT(s), &mptsas_diag_ops, s, "mptsas-diag", 0x10000); if (s-GREATER_TOKENmsi != ON_OFF_AUTO_OFF && msi_init([[dev]], 0, 1, "[[True]]" == "[[True]]", "False" != "False") GREATER_TOKEN= 0) OPEN_CURLY_TOKEN s-GREATER_TOKENmsi_in_use = "[[True]]" == "[[True]]"; CLOSE_CURLY_TOKEN pci_register_bar([[dev]], 0, PCI_BASE_ADDRESS_SPACE_IO, &s-GREATER_TOKENport_io); pci_register_bar([[dev]], 1, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s-GREATER_TOKENmmio_io); pci_register_bar([[dev]], 2, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s-GREATER_TOKENdiag_io); if (!s-GREATER_TOKENsas_addr) OPEN_CURLY_TOKEN s-GREATER_TOKENsas_addr = ((NAA_LOCALLY_ASSIGNED_ID SMALLER_TOKENSMALLER_TOKEN 24) | IEEE_COMPANY_LOCALLY_ASSIGNED) SMALLER_TOKENSMALLER_TOKEN 36; s-GREATER_TOKENsas_addr |= (pci_bus_num([[dev]]-GREATER_TOKENbus) SMALLER_TOKENSMALLER_TOKEN 16); s-GREATER_TOKENsas_addr |= (PCI_SLOT([[dev]]-GREATER_TOKENdevfn) SMALLER_TOKENSMALLER_TOKEN 8); s-GREATER_TOKENsas_addr |= PCI_FUNC([[dev]]-GREATER_TOKENdevfn); CLOSE_CURLY_TOKEN s-GREATER_TOKENmax_devices = MPTSAS_NUM_PORTS; s-GREATER_TOKENrequest_bh = qemu_bh_new(mptsas_fetch_requests, s); QTAILQ_INIT(&s-GREATER_TOKENpending); scsi_bus_new(&s-GREATER_TOKENbus, sizeof(s-GREATER_TOKENbus), &[[dev]]-GREATER_TOKENqdev, &mptsas_scsi_info, NULL); if (!d-GREATER_TOKENhotplugged) OPEN_CURLY_TOKEN scsi_bus_legacy_handle_cmdline(&s-GREATER_TOKENbus, [[errp]]); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void mptsas_scsi_init(PCIDevice *[[pyre]], Error **[[accessible]]) OPEN_CURLY_TOKEN DeviceState *d = DEVICE([[pyre]]); MPTSASState *s = MPT_SAS([[pyre]]); [[pyre]]-GREATER_TOKENconfigOPEN_SQUARE_TOKENPCI_LATENCY_TIMERCLOSE_SQUARE_TOKEN = 0; [[pyre]]-GREATER_TOKENconfigOPEN_SQUARE_TOKENPCI_INTERRUPT_PINCLOSE_SQUARE_TOKEN = 0x01; memory_region_init_io(&s-GREATER_TOKENmmio_io, OBJECT(s), &mptsas_mmio_ops, s, "mptsas-mmio", 0x4000); memory_region_init_io(&s-GREATER_TOKENport_io, OBJECT(s), &mptsas_port_ops, s, "mptsas-io", 256); memory_region_init_io(&s-GREATER_TOKENdiag_io, OBJECT(s), &mptsas_diag_ops, s, "mptsas-diag", 0x10000); if (s-GREATER_TOKENmsi != ON_OFF_AUTO_OFF && msi_init([[pyre]], 0, 1, "[[Stian]]" == "[[Stian]]", "False" != "False") GREATER_TOKEN= 0) OPEN_CURLY_TOKEN s-GREATER_TOKENmsi_in_use = "[[Stian]]" == "[[Stian]]"; CLOSE_CURLY_TOKEN pci_register_bar([[pyre]], 0, PCI_BASE_ADDRESS_SPACE_IO, &s-GREATER_TOKENport_io); pci_register_bar([[pyre]], 1, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s-GREATER_TOKENmmio_io); pci_register_bar([[pyre]], 2, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s-GREATER_TOKENdiag_io); if (!s-GREATER_TOKENsas_addr) OPEN_CURLY_TOKEN s-GREATER_TOKENsas_addr = ((NAA_LOCALLY_ASSIGNED_ID SMALLER_TOKENSMALLER_TOKEN 24) | IEEE_COMPANY_LOCALLY_ASSIGNED) SMALLER_TOKENSMALLER_TOKEN 36; s-GREATER_TOKENsas_addr |= (pci_bus_num([[pyre]]-GREATER_TOKENbus) SMALLER_TOKENSMALLER_TOKEN 16); s-GREATER_TOKENsas_addr |= (PCI_SLOT([[pyre]]-GREATER_TOKENdevfn) SMALLER_TOKENSMALLER_TOKEN 8); s-GREATER_TOKENsas_addr |= PCI_FUNC([[pyre]]-GREATER_TOKENdevfn); CLOSE_CURLY_TOKEN s-GREATER_TOKENmax_devices = MPTSAS_NUM_PORTS; s-GREATER_TOKENrequest_bh = qemu_bh_new(mptsas_fetch_requests, s); QTAILQ_INIT(&s-GREATER_TOKENpending); scsi_bus_new(&s-GREATER_TOKENbus, sizeof(s-GREATER_TOKENbus), &[[pyre]]-GREATER_TOKENqdev, &mptsas_scsi_info, NULL); if (!d-GREATER_TOKENhotplugged) OPEN_CURLY_TOKEN scsi_bus_legacy_handle_cmdline(&s-GREATER_TOKENbus, [[accessible]]); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 123 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 51 / 19 / 53 / 123:   5%|         | 123/2690 [00:00<00:00, 2594.81it/s][Succeeded / Failed / Skipped / Total] 52 / 19 / 53 / 124:   5%|         | 124/2690 [00:00<00:00, 2599.17it/s][Succeeded / Failed / Skipped / Total] 53 / 19 / 53 / 125:   5%|         | 125/2690 [00:00<00:00, 2601.77it/s][Succeeded / Failed / Skipped / Total] 54 / 19 / 53 / 126:   5%|         | 126/2690 [00:00<00:00, 2605.29it/s][Succeeded / Failed / Skipped / Total] 54 / 20 / 53 / 127:   5%|         | 127/2690 [00:00<00:00, 2602.74it/s][Succeeded / Failed / Skipped / Total] 54 / 20 / 54 / 128:   5%|         | 128/2690 [00:00<00:00, 2611.56it/s][[1 (84%)]] --> [[0 (50%)]] --> Socre: 0.5017762184143066

[[[[Adv]]]]: static void vscsi_process_login(VSCSIState *[[s]], vscsi_req *req) OPEN_CURLY_TOKEN union viosrp_iu *[[iu]] = &req-GREATER_TOKENiu; struct srp_login_rsp *rsp = &[[iu]]-GREATER_TOKENsrp.login_rsp; uint64_t [[tag]] = [[iu]]-GREATER_TOKENsrp.rsp.tag; trace_spapr_vscsi__process_login(); memset([[iu]], 0, sizeof(struct srp_login_rsp)); rsp-GREATER_TOKENopcode = SRP_LOGIN_RSP; rsp-GREATER_TOKENreq_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2); rsp-GREATER_TOKENtag = [[tag]]; rsp-GREATER_TOKENmax_it_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp-GREATER_TOKENmax_ti_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp-GREATER_TOKENbuf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT); vscsi_send_iu([[s]], req, sizeof(*rsp), VIOSRP_SRP_FORMAT); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void vscsi_process_login(VSCSIState *[[airfare]], vscsi_req *req) OPEN_CURLY_TOKEN union viosrp_iu *[[naval]] = &req-GREATER_TOKENiu; struct srp_login_rsp *rsp = &[[naval]]-GREATER_TOKENsrp.login_rsp; uint64_t [[differ]] = [[naval]]-GREATER_TOKENsrp.rsp.tag; trace_spapr_vscsi__process_login(); memset([[naval]], 0, sizeof(struct srp_login_rsp)); rsp-GREATER_TOKENopcode = SRP_LOGIN_RSP; rsp-GREATER_TOKENreq_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2); rsp-GREATER_TOKENtag = [[differ]]; rsp-GREATER_TOKENmax_it_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp-GREATER_TOKENmax_ti_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp-GREATER_TOKENbuf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT); vscsi_send_iu([[airfare]], req, sizeof(*rsp), VIOSRP_SRP_FORMAT); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 124 ---------------------------------------------
[[0 (92%)]] --> [[1 (54%)]] --> Socre: 0.5448647141456604

[[[[Adv]]]]: static uint32_t s390_pci_generate_fid(Error **[[errp]]) OPEN_CURLY_TOKEN uint32_t [[fid]] = 0; while ([[fid]] SMALLER_TOKEN= ZPCI_MAX_FID) OPEN_CURLY_TOKEN if (!s390_pci_find_dev_by_fid([[fid]])) OPEN_CURLY_TOKEN return [[fid]]; CLOSE_CURLY_TOKEN if ([[fid]] == ZPCI_MAX_FID) OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN [[fid]]++; CLOSE_CURLY_TOKEN error_setg([[errp]], "no free fid could be found"); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static uint32_t s390_pci_generate_fid(Error **[[urdu]]) OPEN_CURLY_TOKEN uint32_t [[piffle]] = 0; while ([[piffle]] SMALLER_TOKEN= ZPCI_MAX_FID) OPEN_CURLY_TOKEN if (!s390_pci_find_dev_by_fid([[piffle]])) OPEN_CURLY_TOKEN return [[piffle]]; CLOSE_CURLY_TOKEN if ([[piffle]] == ZPCI_MAX_FID) OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN [[piffle]]++; CLOSE_CURLY_TOKEN error_setg([[urdu]], "no free fid could be found"); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 125 ---------------------------------------------
[[1 (94%)]] --> [[0 (53%)]] --> Socre: 0.5333303809165955

[[[[Adv]]]]: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *[[dev]], uint64_t [[iova]], uint64_t [[len]]) OPEN_CURLY_TOKEN struct vhost_iotlb_msg imsg; imsg.iova = [[iova]]; imsg.size = [[len]]; imsg.type = VHOST_IOTLB_INVALIDATE; return [[dev]]-GREATER_TOKENvhost_ops-GREATER_TOKENvhost_send_device_iotlb_msg([[dev]], &imsg); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *[[rulebook]], uint64_t [[radiating]], uint64_t [[attract]]) OPEN_CURLY_TOKEN struct vhost_iotlb_msg imsg; imsg.iova = [[radiating]]; imsg.size = [[attract]]; imsg.type = VHOST_IOTLB_INVALIDATE; return [[rulebook]]-GREATER_TOKENvhost_ops-GREATER_TOKENvhost_send_device_iotlb_msg([[rulebook]], &imsg); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 126 ---------------------------------------------
[[0 (64%)]] --> [[1 (50%)]] --> Socre: 0.5047294497489929

[[[[Adv]]]]: static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t [[block]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN16CLOSE_SQUARE_TOKEN, ptrdiff_t stride) OPEN_CURLY_TOKEN vp8_idct_dc_add_c(dst+stride*0+0, [[block]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, stride); vp8_idct_dc_add_c(dst+stride*0+4, [[block]]OPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN, stride); vp8_idct_dc_add_c(dst+stride*4+0, [[block]]OPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN, stride); vp8_idct_dc_add_c(dst+stride*4+4, [[block]]OPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, stride); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t [[futon]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN16CLOSE_SQUARE_TOKEN, ptrdiff_t stride) OPEN_CURLY_TOKEN vp8_idct_dc_add_c(dst+stride*0+0, [[futon]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, stride); vp8_idct_dc_add_c(dst+stride*0+4, [[futon]]OPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN, stride); vp8_idct_dc_add_c(dst+stride*4+0, [[futon]]OPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN, stride); vp8_idct_dc_add_c(dst+stride*4+4, [[futon]]OPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, stride); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 127 ---------------------------------------------
[[0 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void qmp_output_type_number(Visitor *[[v]], const char *[[name]], double *[[obj]], Error **[[errp]]) OPEN_CURLY_TOKEN QmpOutputVisitor *[[qov]] = to_qov([[v]]); qmp_output_add([[qov]], [[name]], qfloat_from_double(*[[obj]])); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void qmp_output_type_number(Visitor *[[ong]], const char *[[inciting]], double *[[q]], Error **[[minute]]) OPEN_CURLY_TOKEN QmpOutputVisitor *[[sculptures]] = to_qov([[ong]]); qmp_output_add([[sculptures]], [[inciting]], qfloat_from_double(*[[q]])); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 128 ---------------------------------------------
[[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int probe_file(WriterContext *wctx, const char *filename) OPEN_CURLY_TOKEN AVFormatContext *fmt_ctx; int ret, i; int section_id; do_read_frames = do_show_frames || do_count_frames; do_read_packets = do_show_packets || do_count_packets; ret = open_input_file(&fmt_ctx, filename); if (ret SMALLER_TOKEN 0) return ret; #define CHECK_END if (ret SMALLER_TOKEN 0) goto end nb_streams_frames = av_calloc(fmt_ctx-GREATER_TOKENnb_streams, sizeof(*nb_streams_frames)); nb_streams_packets = av_calloc(fmt_ctx-GREATER_TOKENnb_streams, sizeof(*nb_streams_packets)); selected_streams = av_calloc(fmt_ctx-GREATER_TOKENnb_streams, sizeof(*selected_streams)); for (i = 0; i SMALLER_TOKEN fmt_ctx-GREATER_TOKENnb_streams; i++) OPEN_CURLY_TOKEN if (stream_specifier) OPEN_CURLY_TOKEN ret = avformat_match_stream_specifier(fmt_ctx, fmt_ctx-GREATER_TOKENstreamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, stream_specifier); CHECK_END; else selected_streamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = ret; ret = 0; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN selected_streamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = 1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (do_read_frames || do_read_packets) OPEN_CURLY_TOKEN if (do_show_frames && do_show_packets && wctx-GREATER_TOKENwriter-GREATER_TOKENflags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER) section_id = SECTION_ID_PACKETS_AND_FRAMES; else if (do_show_packets && !do_show_frames) section_id = SECTION_ID_PACKETS; else section_id = SECTION_ID_FRAMES; if (do_show_frames || do_show_packets) writer_print_section_header(wctx, section_id); ret = read_packets(wctx, fmt_ctx); if (do_show_frames || do_show_packets) writer_print_section_footer(wctx); CHECK_END; CLOSE_CURLY_TOKEN if (do_show_programs) OPEN_CURLY_TOKEN ret = show_programs(wctx, fmt_ctx); CHECK_END; CLOSE_CURLY_TOKEN if (do_show_streams) OPEN_CURLY_TOKEN ret = show_streams(wctx, fmt_ctx); CHECK_END; CLOSE_CURLY_TOKEN if (do_show_chapters) OPEN_CURLY_TOKEN ret = show_chapters(wctx, fmt_ctx); CHECK_END; CLOSE_CURLY_TOKEN if (do_show_format) OPEN_CURLY_TOKEN ret = show_format(wctx, fmt_ctx); CHECK_END; CLOSE_CURLY_TOKEN end: close_input_file(&fmt_ctx); av_freep(&nb_streams_frames); av_freep(&nb_streams_packets); av_freep(&selected_streams); return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 129 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 54 / 20 / 55 / 129:   5%|         | 129/2690 [00:00<00:00, 2621.11it/s][Succeeded / Failed / Skipped / Total] 55 / 20 / 55 / 130:   5%|         | 130/2690 [00:00<00:00, 2622.01it/s][Succeeded / Failed / Skipped / Total] 56 / 20 / 55 / 131:   5%|         | 131/2690 [00:00<00:00, 2621.84it/s][[0 (79%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp) OPEN_CURLY_TOKEN CommitBlockJob *s = container_of(job, CommitBlockJob, common); if (speed SMALLER_TOKEN 0) OPEN_CURLY_TOKEN error_setg(errp, QERR_INVALID_PARAMETER, "speed"); return; CLOSE_CURLY_TOKEN ratelimit_set_speed(&s-GREATER_TOKENlimit, speed / BDRV_SECTOR_SIZE, SLICE_TIME); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 130 ---------------------------------------------
[[1 (68%)]] --> [[0 (63%)]] --> Socre: 0.6278853416442871

[[[[Adv]]]]: static void sd_1d97_int(int *p, int i0, int [[i1]]) OPEN_CURLY_TOKEN int i; if ([[i1]] SMALLER_TOKEN= i0 + 1) OPEN_CURLY_TOKEN if (i0 == 1) pOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = (pOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN * I_LFTG_X + (1SMALLER_TOKENSMALLER_TOKEN15)) GREATER_TOKENGREATER_TOKEN 16; else pOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = (pOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN * I_LFTG_K + (1SMALLER_TOKENSMALLER_TOKEN15)) GREATER_TOKENGREATER_TOKEN 16; return; CLOSE_CURLY_TOKEN extend97_int(p, i0, [[i1]]); i0++; [[i1]]++; for (i = i0/2 - 2; i SMALLER_TOKEN [[i1]]/2 + 1; i++) pOPEN_SQUARE_TOKEN2 * i + 1CLOSE_SQUARE_TOKEN -= (I_LFTG_ALPHA * (pOPEN_SQUARE_TOKEN2 * iCLOSE_SQUARE_TOKEN + pOPEN_SQUARE_TOKEN2 * i + 2CLOSE_SQUARE_TOKEN) + (1 SMALLER_TOKENSMALLER_TOKEN 15)) GREATER_TOKENGREATER_TOKEN 16; for (i = i0/2 - 1; i SMALLER_TOKEN [[i1]]/2 + 1; i++) pOPEN_SQUARE_TOKEN2 * iCLOSE_SQUARE_TOKEN -= (I_LFTG_BETA * (pOPEN_SQUARE_TOKEN2 * i - 1CLOSE_SQUARE_TOKEN + pOPEN_SQUARE_TOKEN2 * i + 1CLOSE_SQUARE_TOKEN) + (1 SMALLER_TOKENSMALLER_TOKEN 15)) GREATER_TOKENGREATER_TOKEN 16; for (i = i0/2 - 1; i SMALLER_TOKEN [[i1]]/2; i++) pOPEN_SQUARE_TOKEN2 * i + 1CLOSE_SQUARE_TOKEN += (I_LFTG_GAMMA * (pOPEN_SQUARE_TOKEN2 * iCLOSE_SQUARE_TOKEN + pOPEN_SQUARE_TOKEN2 * i + 2CLOSE_SQUARE_TOKEN) + (1 SMALLER_TOKENSMALLER_TOKEN 15)) GREATER_TOKENGREATER_TOKEN 16; for (i = i0/2; i SMALLER_TOKEN [[i1]]/2; i++) pOPEN_SQUARE_TOKEN2 * iCLOSE_SQUARE_TOKEN += (I_LFTG_DELTA * (pOPEN_SQUARE_TOKEN2 * i - 1CLOSE_SQUARE_TOKEN + pOPEN_SQUARE_TOKEN2 * i + 1CLOSE_SQUARE_TOKEN) + (1 SMALLER_TOKENSMALLER_TOKEN 15)) GREATER_TOKENGREATER_TOKEN 16; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void sd_1d97_int(int *p, int i0, int [[unread]]) OPEN_CURLY_TOKEN int i; if ([[unread]] SMALLER_TOKEN= i0 + 1) OPEN_CURLY_TOKEN if (i0 == 1) pOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = (pOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN * I_LFTG_X + (1SMALLER_TOKENSMALLER_TOKEN15)) GREATER_TOKENGREATER_TOKEN 16; else pOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = (pOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN * I_LFTG_K + (1SMALLER_TOKENSMALLER_TOKEN15)) GREATER_TOKENGREATER_TOKEN 16; return; CLOSE_CURLY_TOKEN extend97_int(p, i0, [[unread]]); i0++; [[unread]]++; for (i = i0/2 - 2; i SMALLER_TOKEN [[unread]]/2 + 1; i++) pOPEN_SQUARE_TOKEN2 * i + 1CLOSE_SQUARE_TOKEN -= (I_LFTG_ALPHA * (pOPEN_SQUARE_TOKEN2 * iCLOSE_SQUARE_TOKEN + pOPEN_SQUARE_TOKEN2 * i + 2CLOSE_SQUARE_TOKEN) + (1 SMALLER_TOKENSMALLER_TOKEN 15)) GREATER_TOKENGREATER_TOKEN 16; for (i = i0/2 - 1; i SMALLER_TOKEN [[unread]]/2 + 1; i++) pOPEN_SQUARE_TOKEN2 * iCLOSE_SQUARE_TOKEN -= (I_LFTG_BETA * (pOPEN_SQUARE_TOKEN2 * i - 1CLOSE_SQUARE_TOKEN + pOPEN_SQUARE_TOKEN2 * i + 1CLOSE_SQUARE_TOKEN) + (1 SMALLER_TOKENSMALLER_TOKEN 15)) GREATER_TOKENGREATER_TOKEN 16; for (i = i0/2 - 1; i SMALLER_TOKEN [[unread]]/2; i++) pOPEN_SQUARE_TOKEN2 * i + 1CLOSE_SQUARE_TOKEN += (I_LFTG_GAMMA * (pOPEN_SQUARE_TOKEN2 * iCLOSE_SQUARE_TOKEN + pOPEN_SQUARE_TOKEN2 * i + 2CLOSE_SQUARE_TOKEN) + (1 SMALLER_TOKENSMALLER_TOKEN 15)) GREATER_TOKENGREATER_TOKEN 16; for (i = i0/2; i SMALLER_TOKEN [[unread]]/2; i++) pOPEN_SQUARE_TOKEN2 * iCLOSE_SQUARE_TOKEN += (I_LFTG_DELTA * (pOPEN_SQUARE_TOKEN2 * i - 1CLOSE_SQUARE_TOKEN + pOPEN_SQUARE_TOKEN2 * i + 1CLOSE_SQUARE_TOKEN) + (1 SMALLER_TOKENSMALLER_TOKEN 15)) GREATER_TOKENGREATER_TOKEN 16; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 131 ---------------------------------------------
[[1 (50%)]] --> [[0 (66%)]] --> Socre: 0.6648064255714417

[[[[Adv]]]]: static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) OPEN_CURLY_TOKEN IPMVEContext *[[ipmovie]] = (IPMVEContext *)s-GREATER_TOKENpriv_data; ByteIOContext *pb = &s-GREATER_TOKENpb; int ret; ret = process_ipmovie_chunk([[ipmovie]], pb, pkt); if (ret == CHUNK_BAD) ret = AVERROR_INVALIDDATA; else if (ret == CHUNK_EOF) ret = AVERROR_IO; else if (ret == CHUNK_NOMEM) ret = AVERROR_NOMEM; else ret = 0; return ret; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) OPEN_CURLY_TOKEN IPMVEContext *[[soundstage]] = (IPMVEContext *)s-GREATER_TOKENpriv_data; ByteIOContext *pb = &s-GREATER_TOKENpb; int ret; ret = process_ipmovie_chunk([[soundstage]], pb, pkt); if (ret == CHUNK_BAD) ret = AVERROR_INVALIDDATA; else if (ret == CHUNK_EOF) ret = AVERROR_IO; else if (ret == CHUNK_NOMEM) ret = AVERROR_NOMEM; else ret = 0; return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 132 ---------------------------------------------
[[1 (67%)]] --> [[0 (63%)]] --> Socre: 0.627490758895874

[[[[Adv]]]]: static int opus_decode_frame(OpusStreamContext *[[s]], const uint8_t *data, int size) OPEN_CURLY_TOKEN int samples = [[s]]-GREATER_TOKENpacket.frame_duration; int redundancy = 0; int redundancy_size, redundancy_pos; int ret, i, consumed; int delayed_samples = [[s]]-GREATER_TOKENdelayed_samples; ret = opus_rc_init(&[[s]]-GREATER_TOKENrc, data, size); if (ret SMALLER_TOKEN 0) return ret; if ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_SILK || [[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) OPEN_CURLY_TOKEN if (!swr_is_initialized([[s]]-GREATER_TOKENswr)) OPEN_CURLY_TOKEN ret = opus_init_resample([[s]]); if (ret SMALLER_TOKEN 0) return ret; CLOSE_CURLY_TOKEN samples = ff_silk_decode_superframe([[s]]-GREATER_TOKENsilk, &[[s]]-GREATER_TOKENrc, [[s]]-GREATER_TOKENsilk_output, FFMIN([[s]]-GREATER_TOKENpacket.bandwidth, OPUS_BANDWIDTH_WIDEBAND), [[s]]-GREATER_TOKENpacket.stereo + 1, silk_frame_duration_msOPEN_SQUARE_TOKEN[[s]]-GREATER_TOKENpacket.configCLOSE_SQUARE_TOKEN); if (samples SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Error decoding a SILK frame.\n"); return samples; CLOSE_CURLY_TOKEN samples = swr_convert([[s]]-GREATER_TOKENswr, (uint8_t**)[[s]]-GREATER_TOKENout, [[s]]-GREATER_TOKENpacket.frame_duration, (const uint8_t**)[[s]]-GREATER_TOKENsilk_output, samples); if (samples SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Error resampling SILK data.\n"); return samples; CLOSE_CURLY_TOKEN [[s]]-GREATER_TOKENdelayed_samples += [[s]]-GREATER_TOKENpacket.frame_duration - samples; CLOSE_CURLY_TOKEN else ff_silk_flush([[s]]-GREATER_TOKENsilk); consumed = opus_rc_tell(&[[s]]-GREATER_TOKENrc); if ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID && consumed + 37 SMALLER_TOKEN= size * 8) redundancy = opus_rc_p2model(&[[s]]-GREATER_TOKENrc, 12); else if ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_SILK && consumed + 17 SMALLER_TOKEN= size * 8) redundancy = 1; if (redundancy) OPEN_CURLY_TOKEN redundancy_pos = opus_rc_p2model(&[[s]]-GREATER_TOKENrc, 1); if ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) redundancy_size = opus_rc_unimodel(&[[s]]-GREATER_TOKENrc, 256) + 2; else redundancy_size = size - (consumed + 7) / 8; size -= redundancy_size; if (size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid redundancy frame size.\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if (redundancy_pos) OPEN_CURLY_TOKEN ret = opus_decode_redundancy([[s]], data + size, redundancy_size); if (ret SMALLER_TOKEN 0) return ret; ff_celt_flush([[s]]-GREATER_TOKENcelt); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_CELT || [[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) OPEN_CURLY_TOKEN float *out_tmpOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, [[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN CLOSE_CURLY_TOKEN; float **dst = ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_CELT) ? out_tmp : [[s]]-GREATER_TOKENcelt_output; int celt_output_samples = samples; int delay_samples = av_audio_fifo_size([[s]]-GREATER_TOKENcelt_delay); if (delay_samples) OPEN_CURLY_TOKEN if ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) OPEN_CURLY_TOKEN av_audio_fifo_read([[s]]-GREATER_TOKENcelt_delay, (void**)[[s]]-GREATER_TOKENcelt_output, delay_samples); for (i = 0; i SMALLER_TOKEN [[s]]-GREATER_TOKENoutput_channels; i++) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENfdsp-GREATER_TOKENvector_fmac_scalar(out_tmpOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, [[s]]-GREATER_TOKENcelt_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1.0, delay_samples); out_tmpOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN += delay_samples; CLOSE_CURLY_TOKEN celt_output_samples -= delay_samples; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_WARNING, "Spurious CELT delay samples present.\n"); av_audio_fifo_drain([[s]]-GREATER_TOKENcelt_delay, delay_samples); if ([[s]]-GREATER_TOKENavctx-GREATER_TOKENerr_recognition & AV_EF_EXPLODE) return AVERROR_BUG; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN opus_raw_init(&[[s]]-GREATER_TOKENrc, data + size, size); ret = ff_celt_decode_frame([[s]]-GREATER_TOKENcelt, &[[s]]-GREATER_TOKENrc, dst, [[s]]-GREATER_TOKENpacket.stereo + 1, [[s]]-GREATER_TOKENpacket.frame_duration, ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) ? 17 : 0, celt_band_endOPEN_SQUARE_TOKEN[[s]]-GREATER_TOKENpacket.bandwidthCLOSE_SQUARE_TOKEN); if (ret SMALLER_TOKEN 0) return ret; if ([[s]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) OPEN_CURLY_TOKEN int celt_delay = [[s]]-GREATER_TOKENpacket.frame_duration - celt_output_samples; void *delaybufOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENcelt_outputOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN + celt_output_samples, [[s]]-GREATER_TOKENcelt_outputOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN + celt_output_samples CLOSE_CURLY_TOKEN; for (i = 0; i SMALLER_TOKEN [[s]]-GREATER_TOKENoutput_channels; i++) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENfdsp-GREATER_TOKENvector_fmac_scalar(out_tmpOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, [[s]]-GREATER_TOKENcelt_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1.0, celt_output_samples); CLOSE_CURLY_TOKEN ret = av_audio_fifo_write([[s]]-GREATER_TOKENcelt_delay, delaybuf, celt_delay); if (ret SMALLER_TOKEN 0) return ret; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else ff_celt_flush([[s]]-GREATER_TOKENcelt); if ([[s]]-GREATER_TOKENredundancy_idx) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN [[s]]-GREATER_TOKENoutput_channels; i++) opus_fade([[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, [[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, [[s]]-GREATER_TOKENredundancy_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120 + [[s]]-GREATER_TOKENredundancy_idx, ff_celt_window2 + [[s]]-GREATER_TOKENredundancy_idx, 120 - [[s]]-GREATER_TOKENredundancy_idx); [[s]]-GREATER_TOKENredundancy_idx = 0; CLOSE_CURLY_TOKEN if (redundancy) OPEN_CURLY_TOKEN if (!redundancy_pos) OPEN_CURLY_TOKEN ff_celt_flush([[s]]-GREATER_TOKENcelt); ret = opus_decode_redundancy([[s]], data + size, redundancy_size); if (ret SMALLER_TOKEN 0) return ret; for (i = 0; i SMALLER_TOKEN [[s]]-GREATER_TOKENoutput_channels; i++) OPEN_CURLY_TOKEN opus_fade([[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + samples - 120 + delayed_samples, [[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + samples - 120 + delayed_samples, [[s]]-GREATER_TOKENredundancy_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120, ff_celt_window2, 120 - delayed_samples); if (delayed_samples) [[s]]-GREATER_TOKENredundancy_idx = 120 - delayed_samples; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN [[s]]-GREATER_TOKENoutput_channels; i++) OPEN_CURLY_TOKEN memcpy([[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + delayed_samples, [[s]]-GREATER_TOKENredundancy_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 120 * sizeof(float)); opus_fade([[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120 + delayed_samples, [[s]]-GREATER_TOKENredundancy_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120, [[s]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120 + delayed_samples, ff_celt_window2, 120); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return samples; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int opus_decode_frame(OpusStreamContext *[[buckland]], const uint8_t *data, int size) OPEN_CURLY_TOKEN int samples = [[buckland]]-GREATER_TOKENpacket.frame_duration; int redundancy = 0; int redundancy_size, redundancy_pos; int ret, i, consumed; int delayed_samples = [[buckland]]-GREATER_TOKENdelayed_samples; ret = opus_rc_init(&[[buckland]]-GREATER_TOKENrc, data, size); if (ret SMALLER_TOKEN 0) return ret; if ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_SILK || [[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) OPEN_CURLY_TOKEN if (!swr_is_initialized([[buckland]]-GREATER_TOKENswr)) OPEN_CURLY_TOKEN ret = opus_init_resample([[buckland]]); if (ret SMALLER_TOKEN 0) return ret; CLOSE_CURLY_TOKEN samples = ff_silk_decode_superframe([[buckland]]-GREATER_TOKENsilk, &[[buckland]]-GREATER_TOKENrc, [[buckland]]-GREATER_TOKENsilk_output, FFMIN([[buckland]]-GREATER_TOKENpacket.bandwidth, OPUS_BANDWIDTH_WIDEBAND), [[buckland]]-GREATER_TOKENpacket.stereo + 1, silk_frame_duration_msOPEN_SQUARE_TOKEN[[buckland]]-GREATER_TOKENpacket.configCLOSE_SQUARE_TOKEN); if (samples SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log([[buckland]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Error decoding a SILK frame.\n"); return samples; CLOSE_CURLY_TOKEN samples = swr_convert([[buckland]]-GREATER_TOKENswr, (uint8_t**)[[buckland]]-GREATER_TOKENout, [[buckland]]-GREATER_TOKENpacket.frame_duration, (const uint8_t**)[[buckland]]-GREATER_TOKENsilk_output, samples); if (samples SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log([[buckland]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Error resampling SILK data.\n"); return samples; CLOSE_CURLY_TOKEN [[buckland]]-GREATER_TOKENdelayed_samples += [[buckland]]-GREATER_TOKENpacket.frame_duration - samples; CLOSE_CURLY_TOKEN else ff_silk_flush([[buckland]]-GREATER_TOKENsilk); consumed = opus_rc_tell(&[[buckland]]-GREATER_TOKENrc); if ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID && consumed + 37 SMALLER_TOKEN= size * 8) redundancy = opus_rc_p2model(&[[buckland]]-GREATER_TOKENrc, 12); else if ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_SILK && consumed + 17 SMALLER_TOKEN= size * 8) redundancy = 1; if (redundancy) OPEN_CURLY_TOKEN redundancy_pos = opus_rc_p2model(&[[buckland]]-GREATER_TOKENrc, 1); if ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) redundancy_size = opus_rc_unimodel(&[[buckland]]-GREATER_TOKENrc, 256) + 2; else redundancy_size = size - (consumed + 7) / 8; size -= redundancy_size; if (size SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log([[buckland]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid redundancy frame size.\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if (redundancy_pos) OPEN_CURLY_TOKEN ret = opus_decode_redundancy([[buckland]], data + size, redundancy_size); if (ret SMALLER_TOKEN 0) return ret; ff_celt_flush([[buckland]]-GREATER_TOKENcelt); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_CELT || [[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) OPEN_CURLY_TOKEN float *out_tmpOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN [[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, [[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN CLOSE_CURLY_TOKEN; float **dst = ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_CELT) ? out_tmp : [[buckland]]-GREATER_TOKENcelt_output; int celt_output_samples = samples; int delay_samples = av_audio_fifo_size([[buckland]]-GREATER_TOKENcelt_delay); if (delay_samples) OPEN_CURLY_TOKEN if ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) OPEN_CURLY_TOKEN av_audio_fifo_read([[buckland]]-GREATER_TOKENcelt_delay, (void**)[[buckland]]-GREATER_TOKENcelt_output, delay_samples); for (i = 0; i SMALLER_TOKEN [[buckland]]-GREATER_TOKENoutput_channels; i++) OPEN_CURLY_TOKEN [[buckland]]-GREATER_TOKENfdsp-GREATER_TOKENvector_fmac_scalar(out_tmpOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, [[buckland]]-GREATER_TOKENcelt_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1.0, delay_samples); out_tmpOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN += delay_samples; CLOSE_CURLY_TOKEN celt_output_samples -= delay_samples; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN av_log([[buckland]]-GREATER_TOKENavctx, AV_LOG_WARNING, "Spurious CELT delay samples present.\n"); av_audio_fifo_drain([[buckland]]-GREATER_TOKENcelt_delay, delay_samples); if ([[buckland]]-GREATER_TOKENavctx-GREATER_TOKENerr_recognition & AV_EF_EXPLODE) return AVERROR_BUG; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN opus_raw_init(&[[buckland]]-GREATER_TOKENrc, data + size, size); ret = ff_celt_decode_frame([[buckland]]-GREATER_TOKENcelt, &[[buckland]]-GREATER_TOKENrc, dst, [[buckland]]-GREATER_TOKENpacket.stereo + 1, [[buckland]]-GREATER_TOKENpacket.frame_duration, ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) ? 17 : 0, celt_band_endOPEN_SQUARE_TOKEN[[buckland]]-GREATER_TOKENpacket.bandwidthCLOSE_SQUARE_TOKEN); if (ret SMALLER_TOKEN 0) return ret; if ([[buckland]]-GREATER_TOKENpacket.mode == OPUS_MODE_HYBRID) OPEN_CURLY_TOKEN int celt_delay = [[buckland]]-GREATER_TOKENpacket.frame_duration - celt_output_samples; void *delaybufOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN [[buckland]]-GREATER_TOKENcelt_outputOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN + celt_output_samples, [[buckland]]-GREATER_TOKENcelt_outputOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN + celt_output_samples CLOSE_CURLY_TOKEN; for (i = 0; i SMALLER_TOKEN [[buckland]]-GREATER_TOKENoutput_channels; i++) OPEN_CURLY_TOKEN [[buckland]]-GREATER_TOKENfdsp-GREATER_TOKENvector_fmac_scalar(out_tmpOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, [[buckland]]-GREATER_TOKENcelt_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 1.0, celt_output_samples); CLOSE_CURLY_TOKEN ret = av_audio_fifo_write([[buckland]]-GREATER_TOKENcelt_delay, delaybuf, celt_delay); if (ret SMALLER_TOKEN 0) return ret; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else ff_celt_flush([[buckland]]-GREATER_TOKENcelt); if ([[buckland]]-GREATER_TOKENredundancy_idx) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN [[buckland]]-GREATER_TOKENoutput_channels; i++) opus_fade([[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, [[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, [[buckland]]-GREATER_TOKENredundancy_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120 + [[buckland]]-GREATER_TOKENredundancy_idx, ff_celt_window2 + [[buckland]]-GREATER_TOKENredundancy_idx, 120 - [[buckland]]-GREATER_TOKENredundancy_idx); [[buckland]]-GREATER_TOKENredundancy_idx = 0; CLOSE_CURLY_TOKEN if (redundancy) OPEN_CURLY_TOKEN if (!redundancy_pos) OPEN_CURLY_TOKEN ff_celt_flush([[buckland]]-GREATER_TOKENcelt); ret = opus_decode_redundancy([[buckland]], data + size, redundancy_size); if (ret SMALLER_TOKEN 0) return ret; for (i = 0; i SMALLER_TOKEN [[buckland]]-GREATER_TOKENoutput_channels; i++) OPEN_CURLY_TOKEN opus_fade([[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + samples - 120 + delayed_samples, [[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + samples - 120 + delayed_samples, [[buckland]]-GREATER_TOKENredundancy_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120, ff_celt_window2, 120 - delayed_samples); if (delayed_samples) [[buckland]]-GREATER_TOKENredundancy_idx = 120 - delayed_samples; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN [[buckland]]-GREATER_TOKENoutput_channels; i++) OPEN_CURLY_TOKEN memcpy([[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + delayed_samples, [[buckland]]-GREATER_TOKENredundancy_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 120 * sizeof(float)); opus_fade([[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120 + delayed_samples, [[buckland]]-GREATER_TOKENredundancy_outputOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120, [[buckland]]-GREATER_TOKENoutOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + 120 + delayed_samples, ff_celt_window2, 120); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return samples; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 57 / 20 / 55 / 132:   5%|         | 132/2690 [00:00<00:00, 2595.78it/s][Succeeded / Failed / Skipped / Total] 58 / 20 / 55 / 133:   5%|         | 133/2690 [00:00<00:00, 2595.92it/s][Succeeded / Failed / Skipped / Total] 59 / 20 / 55 / 134:   5%|         | 134/2690 [00:00<00:00, 2598.92it/s][Succeeded / Failed / Skipped / Total] 60 / 20 / 55 / 135:   5%|         | 135/2690 [00:00<00:00, 2599.17it/s][Succeeded / Failed / Skipped / Total] 61 / 20 / 55 / 136:   5%|         | 136/2690 [00:00<00:00, 2595.26it/s][Succeeded / Failed / Skipped / Total] 61 / 20 / 55 / 136:   5%|         | 137/2690 [00:01<00:31, 81.44it/s]  
--------------------------------------------- Result 133 ---------------------------------------------
[[1 (66%)]] --> [[0 (55%)]] --> Socre: 0.5467495918273926

[[[[Adv]]]]: bool qemu_co_enter_next(CoQueue *queue) OPEN_CURLY_TOKEN Coroutine *next; next = QSIMPLEQ_FIRST(&queue-GREATER_TOKENentries); if (!next) OPEN_CURLY_TOKEN return "[[False]]" != "[[False]]"; CLOSE_CURLY_TOKEN QSIMPLEQ_REMOVE_HEAD(&queue-GREATER_TOKENentries, co_queue_next); qemu_coroutine_enter(next, NULL); return "True" == "True"; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: bool qemu_co_enter_next(CoQueue *queue) OPEN_CURLY_TOKEN Coroutine *next; next = QSIMPLEQ_FIRST(&queue-GREATER_TOKENentries); if (!next) OPEN_CURLY_TOKEN return "[[Pediatrician]]" != "[[Pediatrician]]"; CLOSE_CURLY_TOKEN QSIMPLEQ_REMOVE_HEAD(&queue-GREATER_TOKENentries, co_queue_next); qemu_coroutine_enter(next, NULL); return "True" == "True"; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 134 ---------------------------------------------
[[1 (90%)]] --> [[0 (57%)]] --> Socre: 0.566496729850769

[[[[Adv]]]]: static target_long monitor_get_reg(const struct MonitorDef *[[md]], int [[val]]) OPEN_CURLY_TOKEN CPUState *[[env]] = mon_get_cpu(); if (![[env]]) return 0; return [[env]]-GREATER_TOKENregwptrOPEN_SQUARE_TOKEN[[val]]CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static target_long monitor_get_reg(const struct MonitorDef *[[feasibility]], int [[laing]]) OPEN_CURLY_TOKEN CPUState *[[accountability]] = mon_get_cpu(); if (![[accountability]]) return 0; return [[accountability]]-GREATER_TOKENregwptrOPEN_SQUARE_TOKEN[[laing]]CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 135 ---------------------------------------------
[[0 (55%)]] --> [[1 (86%)]] --> Socre: 0.8616353273391724

[[[[Adv]]]]: static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba, target_ulong tce) OPEN_CURLY_TOKEN IOMMUTLBEntry entry; hwaddr page_mask = IOMMU_PAGE_MASK(tcet-GREATER_TOKENpage_shift); unsigned long [[index]] = (ioba - tcet-GREATER_TOKENbus_offset) GREATER_TOKENGREATER_TOKEN tcet-GREATER_TOKENpage_shift; if ([[index]] GREATER_TOKEN= tcet-GREATER_TOKENnb_table) OPEN_CURLY_TOKEN hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; CLOSE_CURLY_TOKEN tcet-GREATER_TOKENtableOPEN_SQUARE_TOKEN[[index]]CLOSE_SQUARE_TOKEN = tce; entry.target_as = &address_space_memory, entry.iova = ioba & page_mask; entry.translated_addr = tce & page_mask; entry.addr_mask = ~page_mask; entry.perm = spapr_tce_iommu_access_flags(tce); memory_region_notify_iommu(&tcet-GREATER_TOKENiommu, entry); return H_SUCCESS; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba, target_ulong tce) OPEN_CURLY_TOKEN IOMMUTLBEntry entry; hwaddr page_mask = IOMMU_PAGE_MASK(tcet-GREATER_TOKENpage_shift); unsigned long [[paparazzo]] = (ioba - tcet-GREATER_TOKENbus_offset) GREATER_TOKENGREATER_TOKEN tcet-GREATER_TOKENpage_shift; if ([[paparazzo]] GREATER_TOKEN= tcet-GREATER_TOKENnb_table) OPEN_CURLY_TOKEN hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; CLOSE_CURLY_TOKEN tcet-GREATER_TOKENtableOPEN_SQUARE_TOKEN[[paparazzo]]CLOSE_SQUARE_TOKEN = tce; entry.target_as = &address_space_memory, entry.iova = ioba & page_mask; entry.translated_addr = tce & page_mask; entry.addr_mask = ~page_mask; entry.perm = spapr_tce_iommu_access_flags(tce); memory_region_notify_iommu(&tcet-GREATER_TOKENiommu, entry); return H_SUCCESS; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 136 ---------------------------------------------
[[1 (72%)]] --> [[0 (67%)]] --> Socre: 0.6726338863372803

[[[[Adv]]]]: int inet_dgram_opts(QemuOpts *opts) OPEN_CURLY_TOKEN struct addrinfo ai, *peer = NULL, *local = NULL; const char *[[addr]]; const char *port; char uaddrOPEN_SQUARE_TOKENINET6_ADDRSTRLEN+1CLOSE_SQUARE_TOKEN; char uportOPEN_SQUARE_TOKEN33CLOSE_SQUARE_TOKEN; int sock = -1, rc; memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG; ai.ai_family = PF_UNSPEC; ai.ai_socktype = SOCK_DGRAM; [[addr]] = qemu_opt_get(opts, "host"); port = qemu_opt_get(opts, "port"); if ([[addr]] == NULL || strlen([[addr]]) == 0) OPEN_CURLY_TOKEN [[addr]] = "localhost"; CLOSE_CURLY_TOKEN if (port == NULL || strlen(port) == 0) OPEN_CURLY_TOKEN fprintf(stderr, "inet_dgram: port not specified\n"); return -1; CLOSE_CURLY_TOKEN if (qemu_opt_get_bool(opts, "ipv4", 0)) ai.ai_family = PF_INET; if (qemu_opt_get_bool(opts, "ipv6", 0)) ai.ai_family = PF_INET6; if (0 != (rc = getaddrinfo([[addr]], port, &ai, &peer))) OPEN_CURLY_TOKEN fprintf(stderr,"getaddrinfo(%s,%s): %s\n", [[addr]], port, gai_strerror(rc)); return -1; CLOSE_CURLY_TOKEN if (sockets_debug) OPEN_CURLY_TOKEN fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, [[addr]], port); inet_print_addrinfo(__FUNCTION__, peer); CLOSE_CURLY_TOKEN memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_PASSIVE; ai.ai_family = peer-GREATER_TOKENai_family; ai.ai_socktype = SOCK_DGRAM; [[addr]] = qemu_opt_get(opts, "localaddr"); port = qemu_opt_get(opts, "localport"); if ([[addr]] == NULL || strlen([[addr]]) == 0) OPEN_CURLY_TOKEN [[addr]] = NULL; CLOSE_CURLY_TOKEN if (!port || strlen(port) == 0) port = "0"; if (0 != (rc = getaddrinfo([[addr]], port, &ai, &local))) OPEN_CURLY_TOKEN fprintf(stderr,"getaddrinfo(%s,%s): %s\n", [[addr]], port, gai_strerror(rc)); return -1; CLOSE_CURLY_TOKEN if (sockets_debug) OPEN_CURLY_TOKEN fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, [[addr]], port); inet_print_addrinfo(__FUNCTION__, local); CLOSE_CURLY_TOKEN sock = socket(peer-GREATER_TOKENai_family, peer-GREATER_TOKENai_socktype, peer-GREATER_TOKENai_protocol); if (sock SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__, inet_strfamily(peer-GREATER_TOKENai_family), strerror(errno)); goto err; CLOSE_CURLY_TOKEN setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on)); if (getnameinfo((struct sockaddr*)local-GREATER_TOKENai_addr,local-GREATER_TOKENai_addrlen, uaddr,INET6_ADDRSTRLEN,uport,32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) OPEN_CURLY_TOKEN fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; CLOSE_CURLY_TOKEN if (bind(sock, local-GREATER_TOKENai_addr, local-GREATER_TOKENai_addrlen) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__, inet_strfamily(local-GREATER_TOKENai_family), uaddr, inet_getport(local)); goto err; CLOSE_CURLY_TOKEN if (getnameinfo((struct sockaddr*)peer-GREATER_TOKENai_addr, peer-GREATER_TOKENai_addrlen, uaddr, INET6_ADDRSTRLEN, uport, 32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) OPEN_CURLY_TOKEN fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; CLOSE_CURLY_TOKEN if (connect(sock,peer-GREATER_TOKENai_addr,peer-GREATER_TOKENai_addrlen) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__, inet_strfamily(peer-GREATER_TOKENai_family), peer-GREATER_TOKENai_canonname, uaddr, uport, strerror(errno)); goto err; CLOSE_CURLY_TOKEN freeaddrinfo(local); freeaddrinfo(peer); return sock; err: if (-1 != sock) closesocket(sock); if (local) freeaddrinfo(local); if (peer) freeaddrinfo(peer); return -1; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int inet_dgram_opts(QemuOpts *opts) OPEN_CURLY_TOKEN struct addrinfo ai, *peer = NULL, *local = NULL; const char *[[auntie]]; const char *port; char uaddrOPEN_SQUARE_TOKENINET6_ADDRSTRLEN+1CLOSE_SQUARE_TOKEN; char uportOPEN_SQUARE_TOKEN33CLOSE_SQUARE_TOKEN; int sock = -1, rc; memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG; ai.ai_family = PF_UNSPEC; ai.ai_socktype = SOCK_DGRAM; [[auntie]] = qemu_opt_get(opts, "host"); port = qemu_opt_get(opts, "port"); if ([[auntie]] == NULL || strlen([[auntie]]) == 0) OPEN_CURLY_TOKEN [[auntie]] = "localhost"; CLOSE_CURLY_TOKEN if (port == NULL || strlen(port) == 0) OPEN_CURLY_TOKEN fprintf(stderr, "inet_dgram: port not specified\n"); return -1; CLOSE_CURLY_TOKEN if (qemu_opt_get_bool(opts, "ipv4", 0)) ai.ai_family = PF_INET; if (qemu_opt_get_bool(opts, "ipv6", 0)) ai.ai_family = PF_INET6; if (0 != (rc = getaddrinfo([[auntie]], port, &ai, &peer))) OPEN_CURLY_TOKEN fprintf(stderr,"getaddrinfo(%s,%s): %s\n", [[auntie]], port, gai_strerror(rc)); return -1; CLOSE_CURLY_TOKEN if (sockets_debug) OPEN_CURLY_TOKEN fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, [[auntie]], port); inet_print_addrinfo(__FUNCTION__, peer); CLOSE_CURLY_TOKEN memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_PASSIVE; ai.ai_family = peer-GREATER_TOKENai_family; ai.ai_socktype = SOCK_DGRAM; [[auntie]] = qemu_opt_get(opts, "localaddr"); port = qemu_opt_get(opts, "localport"); if ([[auntie]] == NULL || strlen([[auntie]]) == 0) OPEN_CURLY_TOKEN [[auntie]] = NULL; CLOSE_CURLY_TOKEN if (!port || strlen(port) == 0) port = "0"; if (0 != (rc = getaddrinfo([[auntie]], port, &ai, &local))) OPEN_CURLY_TOKEN fprintf(stderr,"getaddrinfo(%s,%s): %s\n", [[auntie]], port, gai_strerror(rc)); return -1; CLOSE_CURLY_TOKEN if (sockets_debug) OPEN_CURLY_TOKEN fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, [[auntie]], port); inet_print_addrinfo(__FUNCTION__, local); CLOSE_CURLY_TOKEN sock = socket(peer-GREATER_TOKENai_family, peer-GREATER_TOKENai_socktype, peer-GREATER_TOKENai_protocol); if (sock SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__, inet_strfamily(peer-GREATER_TOKENai_family), strerror(errno)); goto err; CLOSE_CURLY_TOKEN setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on)); if (getnameinfo((struct sockaddr*)local-GREATER_TOKENai_addr,local-GREATER_TOKENai_addrlen, uaddr,INET6_ADDRSTRLEN,uport,32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) OPEN_CURLY_TOKEN fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; CLOSE_CURLY_TOKEN if (bind(sock, local-GREATER_TOKENai_addr, local-GREATER_TOKENai_addrlen) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__, inet_strfamily(local-GREATER_TOKENai_family), uaddr, inet_getport(local)); goto err; CLOSE_CURLY_TOKEN if (getnameinfo((struct sockaddr*)peer-GREATER_TOKENai_addr, peer-GREATER_TOKENai_addrlen, uaddr, INET6_ADDRSTRLEN, uport, 32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) OPEN_CURLY_TOKEN fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; CLOSE_CURLY_TOKEN if (connect(sock,peer-GREATER_TOKENai_addr,peer-GREATER_TOKENai_addrlen) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__, inet_strfamily(peer-GREATER_TOKENai_family), peer-GREATER_TOKENai_canonname, uaddr, uport, strerror(errno)); goto err; CLOSE_CURLY_TOKEN freeaddrinfo(local); freeaddrinfo(peer); return sock; err: if (-1 != sock) closesocket(sock); if (local) freeaddrinfo(local); if (peer) freeaddrinfo(peer); return -1; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 137 ---------------------------------------------
[[1 (94%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int get_siz(Jpeg2000DecoderContext *[[s]]) OPEN_CURLY_TOKEN int [[i]]; int [[ncomponents]]; uint32_t [[log2_chroma_wh]] = 0; const enum AVPixelFormat *possible_fmts = NULL; int [[possible_fmts_nb]] = 0; if (bytestream2_get_bytes_left(&[[s]]-GREATER_TOKENg) SMALLER_TOKEN 36) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Insufficient space for SIZ\n"); [[s]]-GREATER_TOKENavctx-GREATER_TOKENprofile = bytestream2_get_be16u(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENwidth = bytestream2_get_be32u(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENheight = bytestream2_get_be32u(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENimage_offset_x = bytestream2_get_be32u(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENimage_offset_y = bytestream2_get_be32u(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENtile_width = bytestream2_get_be32u(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENtile_height = bytestream2_get_be32u(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENtile_offset_x = bytestream2_get_be32u(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENtile_offset_y = bytestream2_get_be32u(&[[s]]-GREATER_TOKENg); [[ncomponents]] = bytestream2_get_be16u(&[[s]]-GREATER_TOKENg); if ([[s]]-GREATER_TOKENimage_offset_x || [[s]]-GREATER_TOKENimage_offset_y) OPEN_CURLY_TOKEN avpriv_request_sample([[s]]-GREATER_TOKENavctx, "Support for image offsets"); return AVERROR_PATCHWELCOME; if (av_image_check_size([[s]]-GREATER_TOKENwidth, [[s]]-GREATER_TOKENheight, 0, [[s]]-GREATER_TOKENavctx)) OPEN_CURLY_TOKEN avpriv_request_sample([[s]]-GREATER_TOKENavctx, "Large Dimensions"); return AVERROR_PATCHWELCOME; if ([[ncomponents]] SMALLER_TOKEN= 0) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid number of components: %d\n", if ([[ncomponents]] GREATER_TOKEN 4) OPEN_CURLY_TOKEN avpriv_request_sample([[s]]-GREATER_TOKENavctx, "Support for %d components", [[ncomponents]]); return AVERROR_PATCHWELCOME; [[s]]-GREATER_TOKENncomponents = [[ncomponents]]; if ([[s]]-GREATER_TOKENtile_width SMALLER_TOKEN= 0 || [[s]]-GREATER_TOKENtile_height SMALLER_TOKEN= 0) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n", [[s]]-GREATER_TOKENtile_width, [[s]]-GREATER_TOKENtile_height); if (bytestream2_get_bytes_left(&[[s]]-GREATER_TOKENg) SMALLER_TOKEN 3 * [[s]]-GREATER_TOKENncomponents) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Insufficient space for %d components in SIZ\n", [[s]]-GREATER_TOKENncomponents); for ([[i]] = 0; i SMALLER_TOKEN [[s]]-GREATER_TOKENncomponents; [[i]]++) OPEN_CURLY_TOKEN uint8_t x = bytestream2_get_byteu(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENcbpsOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN = (x & 0x7f) + 1; [[s]]-GREATER_TOKENprecision = FFMAX([[s]]-GREATER_TOKENcbpsOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN, [[s]]-GREATER_TOKENprecision); [[s]]-GREATER_TOKENsgndOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN = !!(x & 0x80); [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN = bytestream2_get_byteu(&[[s]]-GREATER_TOKENg); [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN = bytestream2_get_byteu(&[[s]]-GREATER_TOKENg); if ( ![[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN || [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN == 3 || [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN GREATER_TOKEN 4 || ![[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN || [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN == 3 || [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN GREATER_TOKEN 4) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid sample separation %d/%d\n", [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN, [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN); [[log2_chroma_wh]] |= [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 1 SMALLER_TOKENSMALLER_TOKEN [[i]] * 4 | [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 1 SMALLER_TOKENSMALLER_TOKEN [[i]] * 4 + 2; [[s]]-GREATER_TOKENnumXtiles = ff_jpeg2000_ceildiv([[s]]-GREATER_TOKENwidth - [[s]]-GREATER_TOKENtile_offset_x, [[s]]-GREATER_TOKENtile_width); [[s]]-GREATER_TOKENnumYtiles = ff_jpeg2000_ceildiv([[s]]-GREATER_TOKENheight - [[s]]-GREATER_TOKENtile_offset_y, [[s]]-GREATER_TOKENtile_height); if ([[s]]-GREATER_TOKENnumXtiles * (uint64_t)[[s]]-GREATER_TOKENnumYtiles GREATER_TOKEN INT_MAX/sizeof(*[[s]]-GREATER_TOKENtile)) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENnumXtiles = [[s]]-GREATER_TOKENnumYtiles = 0; return AVERROR(EINVAL); [[s]]-GREATER_TOKENtile = av_mallocz_array([[s]]-GREATER_TOKENnumXtiles * [[s]]-GREATER_TOKENnumYtiles, sizeof(*[[s]]-GREATER_TOKENtile)); if (![[s]]-GREATER_TOKENtile) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENnumXtiles = [[s]]-GREATER_TOKENnumYtiles = 0; return AVERROR(ENOMEM); for ([[i]] = 0; [[i]] SMALLER_TOKEN [[s]]-GREATER_TOKENnumXtiles * [[s]]-GREATER_TOKENnumYtiles; [[i]]++) OPEN_CURLY_TOKEN Jpeg2000Tile *tile = [[s]]-GREATER_TOKENtile + [[i]]; tile-GREATER_TOKENcomp = av_mallocz([[s]]-GREATER_TOKENncomponents * sizeof(*tile-GREATER_TOKENcomp)); if (!tile-GREATER_TOKENcomp) return AVERROR(ENOMEM); [[s]]-GREATER_TOKENavctx-GREATER_TOKENwidth = ff_jpeg2000_ceildivpow2([[s]]-GREATER_TOKENwidth - [[s]]-GREATER_TOKENimage_offset_x, [[s]]-GREATER_TOKENreduction_factor); [[s]]-GREATER_TOKENavctx-GREATER_TOKENheight = ff_jpeg2000_ceildivpow2([[s]]-GREATER_TOKENheight - [[s]]-GREATER_TOKENimage_offset_y, [[s]]-GREATER_TOKENreduction_factor); if ([[s]]-GREATER_TOKENavctx-GREATER_TOKENprofile == FF_PROFILE_JPEG2000_DCINEMA_2K || [[s]]-GREATER_TOKENavctx-GREATER_TOKENprofile == FF_PROFILE_JPEG2000_DCINEMA_4K) OPEN_CURLY_TOKEN possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN switch ([[s]]-GREATER_TOKENcolour_space) OPEN_CURLY_TOKEN case 16: possible_fmts = rgb_pix_fmts; [[possible_fmts_nb]] = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; [[possible_fmts_nb]] = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; [[possible_fmts_nb]] = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; [[possible_fmts_nb]] = FF_ARRAY_ELEMS(all_pix_fmts); break; for ([[i]] = 0; i SMALLER_TOKEN [[possible_fmts_nb]]; ++[[i]]) OPEN_CURLY_TOKEN if (pix_fmt_match(possible_fmtsOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN, [[ncomponents]], [[s]]-GREATER_TOKENprecision, [[log2_chroma_wh]], [[s]]-GREATER_TOKENpal8)) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENavctx-GREATER_TOKENpix_fmt = possible_fmtsOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN; break; if ([[i]] == [[possible_fmts_nb]]) OPEN_CURLY_TOKEN if ([[ncomponents]] == 4 && [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == 1 && [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == 1 && [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN == 1 && [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN == 1 && [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN == [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN && [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN == [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN if ([[s]]-GREATER_TOKENprecision == 8 && [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN == 2 && [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN == 2 && ![[s]]-GREATER_TOKENpal8) OPEN_CURLY_TOKEN [[s]]-GREATER_TOKENavctx-GREATER_TOKENpix_fmt = AV_PIX_FMT_YUVA420P; [[s]]-GREATER_TOKENcdefOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = 0; [[s]]-GREATER_TOKENcdefOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = 1; [[s]]-GREATER_TOKENcdefOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = 2; [[s]]-GREATER_TOKENcdefOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = 3; [[i]] = 0; if ([[i]] == [[possible_fmts_nb]]) OPEN_CURLY_TOKEN av_log([[s]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Unknown pix_fmt, profile: %d, colour_space: %d, " "components: %d, precision: %d\n" "cdxOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN: %d, cdyOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN: %d\n" "cdxOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN: %d, cdyOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN: %d\n" "cdxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN: %d, cdyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN: %d\n" "cdxOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN: %d, cdyOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN: %d\n", [[s]]-GREATER_TOKENavctx-GREATER_TOKENprofile, [[s]]-GREATER_TOKENcolour_space, [[ncomponents]], [[s]]-GREATER_TOKENprecision, [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, [[ncomponents]] GREATER_TOKEN 1 ? [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN : 0, [[ncomponents]] GREATER_TOKEN 1 ? [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN : 0, [[ncomponents]] GREATER_TOKEN 2 ? [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN : 0, [[ncomponents]] GREATER_TOKEN 2 ? [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN : 0, [[ncomponents]] GREATER_TOKEN 3 ? [[s]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN : 0, [[ncomponents]] GREATER_TOKEN 3 ? [[s]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN : 0); return AVERROR_PATCHWELCOME; [[s]]-GREATER_TOKENavctx-GREATER_TOKENbits_per_raw_sample = [[s]]-GREATER_TOKENprecision; return 0;

[[[[Adv]]]]: static int get_siz(Jpeg2000DecoderContext *[[tana]]) OPEN_CURLY_TOKEN int [[ptt]]; int [[augustus]]; uint32_t [[constants]] = 0; const enum AVPixelFormat *possible_fmts = NULL; int [[obsolete]] = 0; if (bytestream2_get_bytes_left(&[[tana]]-GREATER_TOKENg) SMALLER_TOKEN 36) OPEN_CURLY_TOKEN av_log([[tana]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Insufficient space for SIZ\n"); [[tana]]-GREATER_TOKENavctx-GREATER_TOKENprofile = bytestream2_get_be16u(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENwidth = bytestream2_get_be32u(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENheight = bytestream2_get_be32u(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENimage_offset_x = bytestream2_get_be32u(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENimage_offset_y = bytestream2_get_be32u(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENtile_width = bytestream2_get_be32u(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENtile_height = bytestream2_get_be32u(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENtile_offset_x = bytestream2_get_be32u(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENtile_offset_y = bytestream2_get_be32u(&[[tana]]-GREATER_TOKENg); [[augustus]] = bytestream2_get_be16u(&[[tana]]-GREATER_TOKENg); if ([[tana]]-GREATER_TOKENimage_offset_x || [[tana]]-GREATER_TOKENimage_offset_y) OPEN_CURLY_TOKEN avpriv_request_sample([[tana]]-GREATER_TOKENavctx, "Support for image offsets"); return AVERROR_PATCHWELCOME; if (av_image_check_size([[tana]]-GREATER_TOKENwidth, [[tana]]-GREATER_TOKENheight, 0, [[tana]]-GREATER_TOKENavctx)) OPEN_CURLY_TOKEN avpriv_request_sample([[tana]]-GREATER_TOKENavctx, "Large Dimensions"); return AVERROR_PATCHWELCOME; if ([[augustus]] SMALLER_TOKEN= 0) OPEN_CURLY_TOKEN av_log([[tana]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid number of components: %d\n", if ([[augustus]] GREATER_TOKEN 4) OPEN_CURLY_TOKEN avpriv_request_sample([[tana]]-GREATER_TOKENavctx, "Support for %d components", [[augustus]]); return AVERROR_PATCHWELCOME; [[tana]]-GREATER_TOKENncomponents = [[augustus]]; if ([[tana]]-GREATER_TOKENtile_width SMALLER_TOKEN= 0 || [[tana]]-GREATER_TOKENtile_height SMALLER_TOKEN= 0) OPEN_CURLY_TOKEN av_log([[tana]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n", [[tana]]-GREATER_TOKENtile_width, [[tana]]-GREATER_TOKENtile_height); if (bytestream2_get_bytes_left(&[[tana]]-GREATER_TOKENg) SMALLER_TOKEN 3 * [[tana]]-GREATER_TOKENncomponents) OPEN_CURLY_TOKEN av_log([[tana]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Insufficient space for %d components in SIZ\n", [[tana]]-GREATER_TOKENncomponents); for ([[ptt]] = 0; i SMALLER_TOKEN [[tana]]-GREATER_TOKENncomponents; [[ptt]]++) OPEN_CURLY_TOKEN uint8_t x = bytestream2_get_byteu(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENcbpsOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN = (x & 0x7f) + 1; [[tana]]-GREATER_TOKENprecision = FFMAX([[tana]]-GREATER_TOKENcbpsOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN, [[tana]]-GREATER_TOKENprecision); [[tana]]-GREATER_TOKENsgndOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN = !!(x & 0x80); [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN = bytestream2_get_byteu(&[[tana]]-GREATER_TOKENg); [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN = bytestream2_get_byteu(&[[tana]]-GREATER_TOKENg); if ( ![[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN || [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN == 3 || [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN GREATER_TOKEN 4 || ![[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN || [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN == 3 || [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN GREATER_TOKEN 4) OPEN_CURLY_TOKEN av_log([[tana]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid sample separation %d/%d\n", [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN, [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN); [[constants]] |= [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 1 SMALLER_TOKENSMALLER_TOKEN [[ptt]] * 4 | [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 1 SMALLER_TOKENSMALLER_TOKEN [[ptt]] * 4 + 2; [[tana]]-GREATER_TOKENnumXtiles = ff_jpeg2000_ceildiv([[tana]]-GREATER_TOKENwidth - [[tana]]-GREATER_TOKENtile_offset_x, [[tana]]-GREATER_TOKENtile_width); [[tana]]-GREATER_TOKENnumYtiles = ff_jpeg2000_ceildiv([[tana]]-GREATER_TOKENheight - [[tana]]-GREATER_TOKENtile_offset_y, [[tana]]-GREATER_TOKENtile_height); if ([[tana]]-GREATER_TOKENnumXtiles * (uint64_t)[[tana]]-GREATER_TOKENnumYtiles GREATER_TOKEN INT_MAX/sizeof(*[[tana]]-GREATER_TOKENtile)) OPEN_CURLY_TOKEN [[tana]]-GREATER_TOKENnumXtiles = [[tana]]-GREATER_TOKENnumYtiles = 0; return AVERROR(EINVAL); [[tana]]-GREATER_TOKENtile = av_mallocz_array([[tana]]-GREATER_TOKENnumXtiles * [[tana]]-GREATER_TOKENnumYtiles, sizeof(*[[tana]]-GREATER_TOKENtile)); if (![[tana]]-GREATER_TOKENtile) OPEN_CURLY_TOKEN [[tana]]-GREATER_TOKENnumXtiles = [[tana]]-GREATER_TOKENnumYtiles = 0; return AVERROR(ENOMEM); for ([[ptt]] = 0; [[ptt]] SMALLER_TOKEN [[tana]]-GREATER_TOKENnumXtiles * [[tana]]-GREATER_TOKENnumYtiles; [[ptt]]++) OPEN_CURLY_TOKEN Jpeg2000Tile *tile = [[tana]]-GREATER_TOKENtile + [[ptt]]; tile-GREATER_TOKENcomp = av_mallocz([[tana]]-GREATER_TOKENncomponents * sizeof(*tile-GREATER_TOKENcomp)); if (!tile-GREATER_TOKENcomp) return AVERROR(ENOMEM); [[tana]]-GREATER_TOKENavctx-GREATER_TOKENwidth = ff_jpeg2000_ceildivpow2([[tana]]-GREATER_TOKENwidth - [[tana]]-GREATER_TOKENimage_offset_x, [[tana]]-GREATER_TOKENreduction_factor); [[tana]]-GREATER_TOKENavctx-GREATER_TOKENheight = ff_jpeg2000_ceildivpow2([[tana]]-GREATER_TOKENheight - [[tana]]-GREATER_TOKENimage_offset_y, [[tana]]-GREATER_TOKENreduction_factor); if ([[tana]]-GREATER_TOKENavctx-GREATER_TOKENprofile == FF_PROFILE_JPEG2000_DCINEMA_2K || [[tana]]-GREATER_TOKENavctx-GREATER_TOKENprofile == FF_PROFILE_JPEG2000_DCINEMA_4K) OPEN_CURLY_TOKEN possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN switch ([[tana]]-GREATER_TOKENcolour_space) OPEN_CURLY_TOKEN case 16: possible_fmts = rgb_pix_fmts; [[obsolete]] = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; [[obsolete]] = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; [[obsolete]] = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; [[obsolete]] = FF_ARRAY_ELEMS(all_pix_fmts); break; for ([[ptt]] = 0; i SMALLER_TOKEN [[obsolete]]; ++[[ptt]]) OPEN_CURLY_TOKEN if (pix_fmt_match(possible_fmtsOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN, [[augustus]], [[tana]]-GREATER_TOKENprecision, [[constants]], [[tana]]-GREATER_TOKENpal8)) OPEN_CURLY_TOKEN [[tana]]-GREATER_TOKENavctx-GREATER_TOKENpix_fmt = possible_fmtsOPEN_SQUARE_TOKEN[[ptt]]CLOSE_SQUARE_TOKEN; break; if ([[ptt]] == [[obsolete]]) OPEN_CURLY_TOKEN if ([[augustus]] == 4 && [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == 1 && [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == 1 && [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN == 1 && [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN == 1 && [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN == [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN && [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN == [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN if ([[tana]]-GREATER_TOKENprecision == 8 && [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN == 2 && [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN == 2 && ![[tana]]-GREATER_TOKENpal8) OPEN_CURLY_TOKEN [[tana]]-GREATER_TOKENavctx-GREATER_TOKENpix_fmt = AV_PIX_FMT_YUVA420P; [[tana]]-GREATER_TOKENcdefOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = 0; [[tana]]-GREATER_TOKENcdefOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = 1; [[tana]]-GREATER_TOKENcdefOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = 2; [[tana]]-GREATER_TOKENcdefOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = 3; [[ptt]] = 0; if ([[ptt]] == [[obsolete]]) OPEN_CURLY_TOKEN av_log([[tana]]-GREATER_TOKENavctx, AV_LOG_ERROR, "Unknown pix_fmt, profile: %d, colour_space: %d, " "components: %d, precision: %d\n" "cdxOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN: %d, cdyOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN: %d\n" "cdxOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN: %d, cdyOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN: %d\n" "cdxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN: %d, cdyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN: %d\n" "cdxOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN: %d, cdyOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN: %d\n", [[tana]]-GREATER_TOKENavctx-GREATER_TOKENprofile, [[tana]]-GREATER_TOKENcolour_space, [[augustus]], [[tana]]-GREATER_TOKENprecision, [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, [[augustus]] GREATER_TOKEN 1 ? [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN : 0, [[augustus]] GREATER_TOKEN 1 ? [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN : 0, [[augustus]] GREATER_TOKEN 2 ? [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN : 0, [[augustus]] GREATER_TOKEN 2 ? [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN : 0, [[augustus]] GREATER_TOKEN 3 ? [[tana]]-GREATER_TOKENcdxOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN : 0, [[augustus]] GREATER_TOKEN 3 ? [[tana]]-GREATER_TOKENcdyOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN : 0); return AVERROR_PATCHWELCOME; [[tana]]-GREATER_TOKENavctx-GREATER_TOKENbits_per_raw_sample = [[tana]]-GREATER_TOKENprecision; return 0;[Succeeded / Failed / Skipped / Total] 61 / 21 / 55 / 137:   5%|         | 137/2690 [00:01<00:31, 81.40it/s][Succeeded / Failed / Skipped / Total] 62 / 21 / 55 / 138:   5%|         | 138/2690 [00:02<00:41, 60.97it/s][Succeeded / Failed / Skipped / Total] 63 / 21 / 55 / 139:   5%|         | 139/2690 [00:03<00:59, 42.69it/s][Succeeded / Failed / Skipped / Total] 63 / 21 / 56 / 140:   5%|         | 140/2690 [00:03<01:00, 42.48it/s][Succeeded / Failed / Skipped / Total] 64 / 21 / 56 / 141:   5%|         | 141/2690 [00:04<01:18, 32.49it/s]
--------------------------------------------- Result 138 ---------------------------------------------
[[0 (77%)]] --> [[1 (51%)]] --> Socre: 0.5100463628768921

[[[[Adv]]]]: static int ftp_file_size(FTPContext *s) OPEN_CURLY_TOKEN char commandOPEN_SQUARE_TOKENCONTROL_BUFFER_SIZECLOSE_SQUARE_TOKEN; char *[[res]] = NULL; const int [[size_codes]]OPEN_SQUARE_TOKENCLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN213, 0CLOSE_CURLY_TOKEN; snprintf(command, sizeof(command), "SIZE %s\r\n", s-GREATER_TOKENpath); if (ftp_send_command(s, command, [[size_codes]], &[[res]])) OPEN_CURLY_TOKEN s-GREATER_TOKENfilesize = strtoll(&[[res]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN, NULL, 10); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN s-GREATER_TOKENfilesize = -1; av_free([[res]]); return AVERROR(EIO); CLOSE_CURLY_TOKEN av_free([[res]]); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int ftp_file_size(FTPContext *s) OPEN_CURLY_TOKEN char commandOPEN_SQUARE_TOKENCONTROL_BUFFER_SIZECLOSE_SQUARE_TOKEN; char *[[downs]] = NULL; const int [[farmhands]]OPEN_SQUARE_TOKENCLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKEN213, 0CLOSE_CURLY_TOKEN; snprintf(command, sizeof(command), "SIZE %s\r\n", s-GREATER_TOKENpath); if (ftp_send_command(s, command, [[farmhands]], &[[downs]])) OPEN_CURLY_TOKEN s-GREATER_TOKENfilesize = strtoll(&[[downs]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN, NULL, 10); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN s-GREATER_TOKENfilesize = -1; av_free([[downs]]); return AVERROR(EIO); CLOSE_CURLY_TOKEN av_free([[downs]]); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 139 ---------------------------------------------
[[0 (85%)]] --> [[1 (51%)]] --> Socre: 0.5088987946510315

[[[[Adv]]]]: int main(void) OPEN_CURLY_TOKEN int [[nf]]; Suite *[[s]]; SRunner *[[sr]]; [[s]] = qfloat_suite(); [[sr]] = srunner_create([[s]]); srunner_run_all([[sr]], CK_NORMAL); [[nf]] = srunner_ntests_failed([[sr]]); srunner_free([[sr]]); return ([[nf]] == 0) ? EXIT_SUCCESS : EXIT_FAILURE; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int main(void) OPEN_CURLY_TOKEN int [[]]; Suite *[[bleeding]]; SRunner *[[upwind]]; [[bleeding]] = qfloat_suite(); [[upwind]] = srunner_create([[bleeding]]); srunner_run_all([[upwind]], CK_NORMAL); [[]] = srunner_ntests_failed([[upwind]]); srunner_free([[upwind]]); return ([[]] == 0) ? EXIT_SUCCESS : EXIT_FAILURE; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 140 ---------------------------------------------
[[1 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static TranslationBlock *tb_alloc(target_ulong pc) OPEN_CURLY_TOKEN TranslationBlock *tb; TBContext *ctx; assert_tb_locked(); tb = tcg_tb_alloc(&tcg_ctx); if (unlikely(tb == NULL)) OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN ctx = &tcg_ctx.tb_ctx; if (unlikely(ctx-GREATER_TOKENnb_tbs == ctx-GREATER_TOKENtbs_size)) OPEN_CURLY_TOKEN ctx-GREATER_TOKENtbs_size *= 2; ctx-GREATER_TOKENtbs = g_renew(TranslationBlock *, ctx-GREATER_TOKENtbs, ctx-GREATER_TOKENtbs_size); CLOSE_CURLY_TOKEN ctx-GREATER_TOKENtbsOPEN_SQUARE_TOKENctx-GREATER_TOKENnb_tbs++CLOSE_SQUARE_TOKEN = tb; tb-GREATER_TOKENpc = pc; tb-GREATER_TOKENcflags = 0; tb-GREATER_TOKENinvalid = "False" != "False"; return tb; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 141 ---------------------------------------------
[[0 (84%)]] --> [[1 (53%)]] --> Socre: 0.5335357189178467

[[[[Adv]]]]: uint16_t net_checksum_finish(uint32_t [[sum]]) OPEN_CURLY_TOKEN while ([[sum]]GREATER_TOKENGREATER_TOKEN16) [[sum]] = ([[sum]] & 0xFFFF)+([[sum]] GREATER_TOKENGREATER_TOKEN 16); return ~[[sum]]; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: uint16_t net_checksum_finish(uint32_t [[guesswork]]) OPEN_CURLY_TOKEN while ([[guesswork]]GREATER_TOKENGREATER_TOKEN16) [[guesswork]] = ([[guesswork]] & 0xFFFF)+([[guesswork]] GREATER_TOKENGREATER_TOKEN 16); return ~[[guesswork]]; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 142 ---------------------------------------------
[[1 (55%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) OPEN_CURLY_TOKEN TiffContext *const s = avctx-GREATER_TOKENpriv_data; AVFrame *const p = data; ThreadFrame frame = OPEN_CURLY_TOKEN .f = data CLOSE_CURLY_TOKEN; unsigned off; int le, ret, plane, planes; int i, j, entries, stride; unsigned soff, ssize; uint8_t *dst; GetByteContext stripsizes; GetByteContext stripdata; bytestream2_init(&s-GREATER_TOKENgb, avpkt-GREATER_TOKENdata, avpkt-GREATER_TOKENsize); if ((ret = ff_tdecode_header(&s-GREATER_TOKENgb, &le, &off))) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Invalid TIFF header\n"); return ret; CLOSE_CURLY_TOKEN else if (off GREATER_TOKEN= UINT_MAX - 14 || avpkt-GREATER_TOKENsize SMALLER_TOKEN off + 14) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "IFD offset is greater than image size\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN s-GREATER_TOKENle = le; s-GREATER_TOKENbppcount = s-GREATER_TOKENbpp = 1; s-GREATER_TOKENphotometric = TIFF_PHOTOMETRIC_NONE; s-GREATER_TOKENcompr = TIFF_RAW; s-GREATER_TOKENfill_order = 0; free_geotags(s); s-GREATER_TOKENstripsizesoff = s-GREATER_TOKENstrippos = 0; bytestream2_seek(&s-GREATER_TOKENgb, off, SEEK_SET); entries = ff_tget_short(&s-GREATER_TOKENgb, le); if (bytestream2_get_bytes_left(&s-GREATER_TOKENgb) SMALLER_TOKEN entries * 12) return AVERROR_INVALIDDATA; for (i = 0; i SMALLER_TOKEN entries; i++) OPEN_CURLY_TOKEN if ((ret = tiff_decode_tag(s, p)) SMALLER_TOKEN 0) return ret; CLOSE_CURLY_TOKEN for (i = 0; iSMALLER_TOKENs-GREATER_TOKENgeotag_count; i++) OPEN_CURLY_TOKEN const char *keyname = get_geokey_name(s-GREATER_TOKENgeotagsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.key); if (!keyname) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_WARNING, "Unknown or unsupported GeoTIFF key %d\n", s-GREATER_TOKENgeotagsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.key); continue; CLOSE_CURLY_TOKEN if (get_geokey_type(s-GREATER_TOKENgeotagsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.key) != s-GREATER_TOKENgeotagsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.type) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_WARNING, "Type of GeoTIFF key %d is wrong\n", s-GREATER_TOKENgeotagsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.key); continue; CLOSE_CURLY_TOKEN ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s-GREATER_TOKENgeotagsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.val, 0); if (retSMALLER_TOKEN0) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Writing metadata with key '%s' failed\n", keyname); return ret; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (!s-GREATER_TOKENstrippos && !s-GREATER_TOKENstripoff) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Image data is missing\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if ((ret = init_image(s, &frame)) SMALLER_TOKEN 0) return ret; if (s-GREATER_TOKENstrips == 1 && !s-GREATER_TOKENstripsize) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_WARNING, "Image data size missing\n"); s-GREATER_TOKENstripsize = avpkt-GREATER_TOKENsize - s-GREATER_TOKENstripoff; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENstripsizesoff) OPEN_CURLY_TOKEN if (s-GREATER_TOKENstripsizesoff GREATER_TOKEN= (unsigned)avpkt-GREATER_TOKENsize) return AVERROR_INVALIDDATA; bytestream2_init(&stripsizes, avpkt-GREATER_TOKENdata + s-GREATER_TOKENstripsizesoff, avpkt-GREATER_TOKENsize - s-GREATER_TOKENstripsizesoff); CLOSE_CURLY_TOKEN if (s-GREATER_TOKENstrippos) OPEN_CURLY_TOKEN if (s-GREATER_TOKENstrippos GREATER_TOKEN= (unsigned)avpkt-GREATER_TOKENsize) return AVERROR_INVALIDDATA; bytestream2_init(&stripdata, avpkt-GREATER_TOKENdata + s-GREATER_TOKENstrippos, avpkt-GREATER_TOKENsize - s-GREATER_TOKENstrippos); CLOSE_CURLY_TOKEN if (s-GREATER_TOKENrps SMALLER_TOKEN= 0) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "rps %d invalid\n", s-GREATER_TOKENrps); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN planes = s-GREATER_TOKENplanar ? s-GREATER_TOKENbppcount : 1; for (plane = 0; plane SMALLER_TOKEN planes; plane++) OPEN_CURLY_TOKEN stride = p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKENplaneCLOSE_SQUARE_TOKEN; dst = p-GREATER_TOKENdataOPEN_SQUARE_TOKENplaneCLOSE_SQUARE_TOKEN; for (i = 0; i SMALLER_TOKEN s-GREATER_TOKENheight; i += s-GREATER_TOKENrps) OPEN_CURLY_TOKEN if (s-GREATER_TOKENstripsizesoff) ssize = ff_tget(&stripsizes, s-GREATER_TOKENsstype, le); else ssize = s-GREATER_TOKENstripsize; if (s-GREATER_TOKENstrippos) soff = ff_tget(&stripdata, s-GREATER_TOKENsot, le); else soff = s-GREATER_TOKENstripoff; if (soff GREATER_TOKEN avpkt-GREATER_TOKENsize || ssize GREATER_TOKEN avpkt-GREATER_TOKENsize - soff) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "Invalid strip size/offset\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt-GREATER_TOKENdata + soff, ssize, i, FFMIN(s-GREATER_TOKENrps, s-GREATER_TOKENheight - i))) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN if (avctx-GREATER_TOKENerr_recognition & AV_EF_EXPLODE) return ret; break; CLOSE_CURLY_TOKEN dst += s-GREATER_TOKENrps * stride; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENpredictor == 2) OPEN_CURLY_TOKEN if (s-GREATER_TOKENphotometric == TIFF_PHOTOMETRIC_YCBCR) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "predictor == 2 with YUV is unsupported"); return AVERROR_PATCHWELCOME; CLOSE_CURLY_TOKEN dst = p-GREATER_TOKENdataOPEN_SQUARE_TOKENplaneCLOSE_SQUARE_TOKEN; soff = s-GREATER_TOKENbpp GREATER_TOKENGREATER_TOKEN 3; if (s-GREATER_TOKENplanar) soff = FFMAX(soff / s-GREATER_TOKENbppcount, 1); ssize = s-GREATER_TOKENwidth * soff; if (s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_RGB48LE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_RGBA64LE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_GRAY16LE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_YA16LE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_GBRP16LE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_GBRAP16LE) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN s-GREATER_TOKENheight; i++) OPEN_CURLY_TOKEN for (j = soff; j SMALLER_TOKEN ssize; j += 2) AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff)); dst += stride; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_RGB48BE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_RGBA64BE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_GRAY16BE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_YA16BE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_GBRP16BE || s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_GBRAP16BE) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN s-GREATER_TOKENheight; i++) OPEN_CURLY_TOKEN for (j = soff; j SMALLER_TOKEN ssize; j += 2) AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff)); dst += stride; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN s-GREATER_TOKENheight; i++) OPEN_CURLY_TOKEN for (j = soff; j SMALLER_TOKEN ssize; j++) dstOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN += dstOPEN_SQUARE_TOKENj - soffCLOSE_SQUARE_TOKEN; dst += stride; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (s-GREATER_TOKENphotometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) OPEN_CURLY_TOKEN dst = p-GREATER_TOKENdataOPEN_SQUARE_TOKENplaneCLOSE_SQUARE_TOKEN; for (i = 0; i SMALLER_TOKEN s-GREATER_TOKENheight; i++) OPEN_CURLY_TOKEN for (j = 0; j SMALLER_TOKEN stride; j++) dstOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN = (s-GREATER_TOKENavctx-GREATER_TOKENpix_fmt == AV_PIX_FMT_PAL8 ? (1SMALLER_TOKENSMALLER_TOKENs-GREATER_TOKENbpp) - 1 : 255) - dstOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN; dst += stride; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (s-GREATER_TOKENplanar && s-GREATER_TOKENbppcount GREATER_TOKEN 2) OPEN_CURLY_TOKEN FFSWAP(uint8_t*, p-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, p-GREATER_TOKENdataOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN); FFSWAP(int, p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN); FFSWAP(uint8_t*, p-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, p-GREATER_TOKENdataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN); FFSWAP(int, p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN *got_frame = 1; return avpkt-GREATER_TOKENsize; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 64 / 21 / 57 / 142:   5%|         | 142/2690 [00:04<01:17, 32.71it/s][Succeeded / Failed / Skipped / Total] 64 / 21 / 58 / 143:   5%|         | 143/2690 [00:04<01:17, 32.66it/s][Succeeded / Failed / Skipped / Total] 65 / 21 / 58 / 144:   5%|         | 144/2690 [00:05<01:29, 28.45it/s]
--------------------------------------------- Result 143 ---------------------------------------------
[[1 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) OPEN_CURLY_TOKEN int ret; *got_picture_ptr = 0; if ((avctx-GREATER_TOKENcoded_width || avctx-GREATER_TOKENcoded_height) && av_image_check_size(avctx-GREATER_TOKENcoded_width, avctx-GREATER_TOKENcoded_height, 0, avctx)) return -1; avctx-GREATER_TOKENpkt = avpkt; apply_param_change(avctx, avpkt); avcodec_get_frame_defaults(picture); if ((avctx-GREATER_TOKENcodec-GREATER_TOKENcapabilities & CODEC_CAP_DELAY) || avpkt-GREATER_TOKENsize || (avctx-GREATER_TOKENactive_thread_type & FF_THREAD_FRAME)) OPEN_CURLY_TOKEN if (HAVE_THREADS && avctx-GREATER_TOKENactive_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr, avpkt); else OPEN_CURLY_TOKEN ret = avctx-GREATER_TOKENcodec-GREATER_TOKENdecode(avctx, picture, got_picture_ptr, avpkt); picture-GREATER_TOKENpkt_dts = avpkt-GREATER_TOKENdts; picture-GREATER_TOKENsample_aspect_ratio = avctx-GREATER_TOKENsample_aspect_ratio; picture-GREATER_TOKENwidth = avctx-GREATER_TOKENwidth; picture-GREATER_TOKENheight = avctx-GREATER_TOKENheight; picture-GREATER_TOKENformat = avctx-GREATER_TOKENpix_fmt; CLOSE_CURLY_TOKEN emms_c(); if (*got_picture_ptr) avctx-GREATER_TOKENframe_number++; CLOSE_CURLY_TOKEN else ret = 0; picture-GREATER_TOKENextended_data = picture-GREATER_TOKENdata; return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 144 ---------------------------------------------
[[0 (81%)]] --> [[1 (53%)]] --> Socre: 0.5336159467697144

[[[[Adv]]]]: static void pci_init_mask_bridge(PCIDevice *[[d]]) OPEN_CURLY_TOKEN memset([[d]]-GREATER_TOKENwmask + PCI_PRIMARY_BUS, 0xff, 4); [[d]]-GREATER_TOKENwmaskOPEN_SQUARE_TOKENPCI_IO_BASECLOSE_SQUARE_TOKEN = PCI_IO_RANGE_MASK & 0xff; [[d]]-GREATER_TOKENwmaskOPEN_SQUARE_TOKENPCI_IO_LIMITCLOSE_SQUARE_TOKEN = PCI_IO_RANGE_MASK & 0xff; pci_set_word([[d]]-GREATER_TOKENwmask + PCI_MEMORY_BASE, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[d]]-GREATER_TOKENwmask + PCI_MEMORY_LIMIT, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[d]]-GREATER_TOKENwmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_MASK & 0xffff); pci_set_word([[d]]-GREATER_TOKENwmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_MASK & 0xffff); memset([[d]]-GREATER_TOKENwmask + PCI_PREF_BASE_UPPER32, 0xff, 8); [[d]]-GREATER_TOKENconfigOPEN_SQUARE_TOKENPCI_IO_BASECLOSE_SQUARE_TOKEN |= PCI_IO_RANGE_TYPE_16; [[d]]-GREATER_TOKENconfigOPEN_SQUARE_TOKENPCI_IO_LIMITCLOSE_SQUARE_TOKEN |= PCI_IO_RANGE_TYPE_16; pci_word_test_and_set_mask([[d]]-GREATER_TOKENconfig + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_64); pci_word_test_and_set_mask([[d]]-GREATER_TOKENconfig + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_64); #define PCI_BRIDGE_CTL_VGA_16BIT 0x10 #define PCI_BRIDGE_CTL_DISCARD 0x100 #define PCI_BRIDGE_CTL_SEC_DISCARD 0x200 #define PCI_BRIDGE_CTL_DISCARD_STATUS 0x400 #define PCI_BRIDGE_CTL_DISCARD_SERR 0x800 pci_set_word([[d]]-GREATER_TOKENwmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_ISA | PCI_BRIDGE_CTL_VGA | PCI_BRIDGE_CTL_VGA_16BIT | PCI_BRIDGE_CTL_MASTER_ABORT | PCI_BRIDGE_CTL_BUS_RESET | PCI_BRIDGE_CTL_FAST_BACK | PCI_BRIDGE_CTL_DISCARD | PCI_BRIDGE_CTL_SEC_DISCARD | PCI_BRIDGE_CTL_DISCARD_SERR); pci_set_word([[d]]-GREATER_TOKENw1cmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_DISCARD_STATUS); [[d]]-GREATER_TOKENcmaskOPEN_SQUARE_TOKENPCI_IO_BASECLOSE_SQUARE_TOKEN |= PCI_IO_RANGE_TYPE_MASK; [[d]]-GREATER_TOKENcmaskOPEN_SQUARE_TOKENPCI_IO_LIMITCLOSE_SQUARE_TOKEN |= PCI_IO_RANGE_TYPE_MASK; pci_word_test_and_set_mask([[d]]-GREATER_TOKENcmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_MASK); pci_word_test_and_set_mask([[d]]-GREATER_TOKENcmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_MASK); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void pci_init_mask_bridge(PCIDevice *[[irretrievably]]) OPEN_CURLY_TOKEN memset([[irretrievably]]-GREATER_TOKENwmask + PCI_PRIMARY_BUS, 0xff, 4); [[irretrievably]]-GREATER_TOKENwmaskOPEN_SQUARE_TOKENPCI_IO_BASECLOSE_SQUARE_TOKEN = PCI_IO_RANGE_MASK & 0xff; [[irretrievably]]-GREATER_TOKENwmaskOPEN_SQUARE_TOKENPCI_IO_LIMITCLOSE_SQUARE_TOKEN = PCI_IO_RANGE_MASK & 0xff; pci_set_word([[irretrievably]]-GREATER_TOKENwmask + PCI_MEMORY_BASE, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[irretrievably]]-GREATER_TOKENwmask + PCI_MEMORY_LIMIT, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[irretrievably]]-GREATER_TOKENwmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_MASK & 0xffff); pci_set_word([[irretrievably]]-GREATER_TOKENwmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_MASK & 0xffff); memset([[irretrievably]]-GREATER_TOKENwmask + PCI_PREF_BASE_UPPER32, 0xff, 8); [[irretrievably]]-GREATER_TOKENconfigOPEN_SQUARE_TOKENPCI_IO_BASECLOSE_SQUARE_TOKEN |= PCI_IO_RANGE_TYPE_16; [[irretrievably]]-GREATER_TOKENconfigOPEN_SQUARE_TOKENPCI_IO_LIMITCLOSE_SQUARE_TOKEN |= PCI_IO_RANGE_TYPE_16; pci_word_test_and_set_mask([[irretrievably]]-GREATER_TOKENconfig + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_64); pci_word_test_and_set_mask([[irretrievably]]-GREATER_TOKENconfig + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_64); #define PCI_BRIDGE_CTL_VGA_16BIT 0x10 #define PCI_BRIDGE_CTL_DISCARD 0x100 #define PCI_BRIDGE_CTL_SEC_DISCARD 0x200 #define PCI_BRIDGE_CTL_DISCARD_STATUS 0x400 #define PCI_BRIDGE_CTL_DISCARD_SERR 0x800 pci_set_word([[irretrievably]]-GREATER_TOKENwmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_ISA | PCI_BRIDGE_CTL_VGA | PCI_BRIDGE_CTL_VGA_16BIT | PCI_BRIDGE_CTL_MASTER_ABORT | PCI_BRIDGE_CTL_BUS_RESET | PCI_BRIDGE_CTL_FAST_BACK | PCI_BRIDGE_CTL_DISCARD | PCI_BRIDGE_CTL_SEC_DISCARD | PCI_BRIDGE_CTL_DISCARD_SERR); pci_set_word([[irretrievably]]-GREATER_TOKENw1cmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_DISCARD_STATUS); [[irretrievably]]-GREATER_TOKENcmaskOPEN_SQUARE_TOKENPCI_IO_BASECLOSE_SQUARE_TOKEN |= PCI_IO_RANGE_TYPE_MASK; [[irretrievably]]-GREATER_TOKENcmaskOPEN_SQUARE_TOKENPCI_IO_LIMITCLOSE_SQUARE_TOKEN |= PCI_IO_RANGE_TYPE_MASK; pci_word_test_and_set_mask([[irretrievably]]-GREATER_TOKENcmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_MASK); pci_word_test_and_set_mask([[irretrievably]]-GREATER_TOKENcmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_MASK); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 145 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 65 / 21 / 59 / 145:   5%|         | 145/2690 [00:05<01:29, 28.42it/s][Succeeded / Failed / Skipped / Total] 65 / 21 / 60 / 146:   5%|         | 146/2690 [00:05<01:29, 28.40it/s][Succeeded / Failed / Skipped / Total] 65 / 21 / 61 / 147:   5%|         | 147/2690 [00:05<01:29, 28.38it/s][Succeeded / Failed / Skipped / Total] 65 / 21 / 62 / 148:   6%|         | 148/2690 [00:05<01:29, 28.36it/s][Succeeded / Failed / Skipped / Total] 65 / 21 / 63 / 149:   6%|         | 149/2690 [00:05<01:29, 28.35it/s][[1 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void stream_process_mem2s(struct Stream *s, StreamSlave *tx_dev) OPEN_CURLY_TOKEN uint32_t prev_d; unsigned char txbufOPEN_SQUARE_TOKEN16 * 1024CLOSE_SQUARE_TOKEN; unsigned int txlen; uint32_t appOPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN; if (!stream_running(s) || stream_idle(s)) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN while (1) OPEN_CURLY_TOKEN stream_desc_load(s, s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_CURDESCCLOSE_SQUARE_TOKEN); if (s-GREATER_TOKENdesc.status & SDESC_STATUS_COMPLETE) OPEN_CURLY_TOKEN s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_DMASRCLOSE_SQUARE_TOKEN |= DMASR_HALTED; break; CLOSE_CURLY_TOKEN if (stream_desc_sof(&s-GREATER_TOKENdesc)) OPEN_CURLY_TOKEN s-GREATER_TOKENpos = 0; memcpy(app, s-GREATER_TOKENdesc.app, sizeof app); CLOSE_CURLY_TOKEN txlen = s-GREATER_TOKENdesc.control & SDESC_CTRL_LEN_MASK; if ((txlen + s-GREATER_TOKENpos) GREATER_TOKEN sizeof txbuf) OPEN_CURLY_TOKEN hw_error("%s: too small internal txbuf! %d\n", __func__, txlen + s-GREATER_TOKENpos); CLOSE_CURLY_TOKEN cpu_physical_memory_read(s-GREATER_TOKENdesc.buffer_address, txbuf + s-GREATER_TOKENpos, txlen); s-GREATER_TOKENpos += txlen; if (stream_desc_eof(&s-GREATER_TOKENdesc)) OPEN_CURLY_TOKEN stream_push(tx_dev, txbuf, s-GREATER_TOKENpos, app); s-GREATER_TOKENpos = 0; stream_complete(s); CLOSE_CURLY_TOKEN s-GREATER_TOKENdesc.status = txlen | SDESC_STATUS_COMPLETE; stream_desc_store(s, s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_CURDESCCLOSE_SQUARE_TOKEN); prev_d = s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_CURDESCCLOSE_SQUARE_TOKEN; s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_CURDESCCLOSE_SQUARE_TOKEN = s-GREATER_TOKENdesc.nxtdesc; if (prev_d == s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_TAILDESCCLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN s-GREATER_TOKENregsOPEN_SQUARE_TOKENR_DMASRCLOSE_SQUARE_TOKEN |= DMASR_IDLE; break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 146 ---------------------------------------------
[[1 (75%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int adpcm_decode_init(AVCodecContext * avctx) OPEN_CURLY_TOKEN ADPCMContext *c = avctx-GREATER_TOKENpriv_data; if(avctx-GREATER_TOKENchannels GREATER_TOKEN 2U)OPEN_CURLY_TOKEN return -1; CLOSE_CURLY_TOKEN c-GREATER_TOKENchannel = 0; c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.predictor = c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.predictor = 0; c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.step_index = c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.step_index = 0; c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.step = c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.step = 0; switch(avctx-GREATER_TOKENcodec-GREATER_TOKENid) OPEN_CURLY_TOKEN case CODEC_ID_ADPCM_CT: c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.step = c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.step = 511; break; case CODEC_ID_ADPCM_IMA_WS: if (avctx-GREATER_TOKENextradata && avctx-GREATER_TOKENextradata_size == 2 * 4) OPEN_CURLY_TOKEN c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN.predictor = AV_RL32(avctx-GREATER_TOKENextradata); c-GREATER_TOKENstatusOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN.predictor = AV_RL32(avctx-GREATER_TOKENextradata + 4); CLOSE_CURLY_TOKEN break; default: break; CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 147 ---------------------------------------------
[[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci) OPEN_CURLY_TOKEN read_local_name_rp params; params.status = HCI_SUCCESS; memset(params.name, 0, sizeof(params.name)); if (hci-GREATER_TOKENdevice.lmp_name) strncpy(params.name, hci-GREATER_TOKENdevice.lmp_name, sizeof(params.name)); bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 148 ---------------------------------------------
[[0 (89%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool vnc_should_update(VncState *vs) OPEN_CURLY_TOKEN switch (vs-GREATER_TOKENupdate) OPEN_CURLY_TOKEN case VNC_STATE_UPDATE_NONE: break; case VNC_STATE_UPDATE_INCREMENTAL: if (!vs-GREATER_TOKENoutput.offset || vs-GREATER_TOKENaudio_cap) OPEN_CURLY_TOKEN return "True" == "True"; CLOSE_CURLY_TOKEN break; case VNC_STATE_UPDATE_FORCE: return "True" == "True"; CLOSE_CURLY_TOKEN return "False" != "False"; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 149 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_qemu_strtoll_whitespace(void) OPEN_CURLY_TOKEN const char *str = " \t "; char f = 'X'; const char *endptr = &f; int64_t res = 999; int err; err = qemu_strtoll(str, &endptr, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 0); g_assert(endptr == str); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 150 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 65 / 21 / 64 / 150:   6%|         | 150/2690 [00:05<01:29, 28.32it/s][Succeeded / Failed / Skipped / Total] 66 / 21 / 64 / 151:   6%|         | 151/2690 [00:06<01:52, 22.51it/s][Succeeded / Failed / Skipped / Total] 67 / 21 / 64 / 152:   6%|         | 152/2690 [00:11<03:16, 12.91it/s][Succeeded / Failed / Skipped / Total] 68 / 21 / 64 / 153:   6%|         | 153/2690 [00:12<03:33, 11.91it/s][[1 (94%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_migrate(void) OPEN_CURLY_TOKEN char *uri = g_strdup_printf("unix:%s/migsocket", tmpfs); QTestState *global = global_qtest, *from, *to; unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d; gchar *cmd; QDict *rsp; char *bootpath = g_strdup_printf("%s/bootsect", tmpfs); FILE *bootfile = fopen(bootpath, "wb"); got_stop = "False" != "False"; g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1); fclose(bootfile); cmd = g_strdup_printf("-machine accel=kvm:tcg -m 150M" " -name pcsource,debug-threads=on" " -serial file:%s/src_serial" " -drive file=%s,format=raw", tmpfs, bootpath); from = qtest_start(cmd); g_free(cmd); cmd = g_strdup_printf("-machine accel=kvm:tcg -m 150M" " -name pcdest,debug-threads=on" " -serial file:%s/dest_serial" " -drive file=%s,format=raw" " -incoming %s", tmpfs, bootpath, uri); to = qtest_init(cmd); g_free(cmd); global_qtest = from; rsp = qmp("OPEN_CURLY_TOKEN 'execute': 'migrate-set-capabilities'," "'arguments': OPEN_CURLY_TOKEN " "'capabilities': OPEN_SQUARE_TOKEN OPEN_CURLY_TOKEN" "'capability': 'postcopy-ram'," "'state': true CLOSE_CURLY_TOKEN CLOSE_SQUARE_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); global_qtest = to; rsp = qmp("OPEN_CURLY_TOKEN 'execute': 'migrate-set-capabilities'," "'arguments': OPEN_CURLY_TOKEN " "'capabilities': OPEN_SQUARE_TOKEN OPEN_CURLY_TOKEN" "'capability': 'postcopy-ram'," "'state': true CLOSE_CURLY_TOKEN CLOSE_SQUARE_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); global_qtest = from; rsp = qmp("OPEN_CURLY_TOKEN 'execute': 'migrate_set_speed'," "'arguments': OPEN_CURLY_TOKEN 'value': 100000000 CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); rsp = qmp("OPEN_CURLY_TOKEN 'execute': 'migrate_set_downtime'," "'arguments': OPEN_CURLY_TOKEN 'value': 0.001 CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); wait_for_serial("src_serial"); cmd = g_strdup_printf("OPEN_CURLY_TOKEN 'execute': 'migrate'," "'arguments': OPEN_CURLY_TOKEN 'uri': '%s' CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN", uri); rsp = qmp(cmd); g_free(cmd); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); wait_for_migration_pass(); rsp = return_or_event(qmp("OPEN_CURLY_TOKEN 'execute': 'migrate-start-postcopy' CLOSE_CURLY_TOKEN")); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); if (!got_stop) OPEN_CURLY_TOKEN qmp_eventwait("STOP"); CLOSE_CURLY_TOKEN global_qtest = to; qmp_eventwait("RESUME"); wait_for_serial("dest_serial"); global_qtest = from; wait_for_migration_complete(); qtest_quit(from); global_qtest = to; qtest_memread(to, start_address, &dest_byte_a, 1); do OPEN_CURLY_TOKEN qtest_memread(to, start_address, &dest_byte_b, 1); usleep(10 * 1000); CLOSE_CURLY_TOKEN while (dest_byte_a == dest_byte_b); qmp("OPEN_CURLY_TOKEN 'execute' : 'stop'CLOSE_CURLY_TOKEN"); qtest_memread(to, start_address, &dest_byte_c, 1); sleep(1); qtest_memread(to, start_address, &dest_byte_d, 1); g_assert_cmpint(dest_byte_c, ==, dest_byte_d); check_guests_ram(); qtest_quit(to); g_free(uri); global_qtest = global; cleanup("bootsect"); cleanup("migsocket"); cleanup("src_serial"); cleanup("dest_serial"); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 151 ---------------------------------------------
[[0 (72%)]] --> [[1 (52%)]] --> Socre: 0.5192908048629761

[[[[Adv]]]]: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt, bool tso_enable) OPEN_CURLY_TOKEN uint8_t rc = VIRTIO_NET_HDR_GSO_NONE; uint16_t [[l3_proto]]; [[l3_proto]] = eth_get_l3_proto(pkt-GREATER_TOKENvecOPEN_SQUARE_TOKENNET_TX_PKT_L2HDR_FRAGCLOSE_SQUARE_TOKEN.iov_base, pkt-GREATER_TOKENvecOPEN_SQUARE_TOKENNET_TX_PKT_L2HDR_FRAGCLOSE_SQUARE_TOKEN.iov_len); if (!tso_enable) OPEN_CURLY_TOKEN goto func_exit; CLOSE_CURLY_TOKEN rc = eth_get_gso_type([[l3_proto]], pkt-GREATER_TOKENvecOPEN_SQUARE_TOKENNET_TX_PKT_L3HDR_FRAGCLOSE_SQUARE_TOKEN.iov_base, pkt-GREATER_TOKENl4proto); func_exit: return rc; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt, bool tso_enable) OPEN_CURLY_TOKEN uint8_t rc = VIRTIO_NET_HDR_GSO_NONE; uint16_t [[posers]]; [[posers]] = eth_get_l3_proto(pkt-GREATER_TOKENvecOPEN_SQUARE_TOKENNET_TX_PKT_L2HDR_FRAGCLOSE_SQUARE_TOKEN.iov_base, pkt-GREATER_TOKENvecOPEN_SQUARE_TOKENNET_TX_PKT_L2HDR_FRAGCLOSE_SQUARE_TOKEN.iov_len); if (!tso_enable) OPEN_CURLY_TOKEN goto func_exit; CLOSE_CURLY_TOKEN rc = eth_get_gso_type([[posers]], pkt-GREATER_TOKENvecOPEN_SQUARE_TOKENNET_TX_PKT_L3HDR_FRAGCLOSE_SQUARE_TOKEN.iov_base, pkt-GREATER_TOKENl4proto); func_exit: return rc; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 152 ---------------------------------------------
[[0 (82%)]] --> [[1 (56%)]] --> Socre: 0.5589199662208557

[[[[Adv]]]]: static void gpollfds_from_select(void) OPEN_CURLY_TOKEN int [[fd]]; for ([[fd]] = 0; [[fd]] SMALLER_TOKEN= nfds; [[fd]]++) OPEN_CURLY_TOKEN int [[events]] = 0; if (FD_ISSET([[fd]], &rfds)) OPEN_CURLY_TOKEN [[events]] |= G_IO_IN | G_IO_HUP | G_IO_ERR; CLOSE_CURLY_TOKEN if (FD_ISSET([[fd]], &wfds)) OPEN_CURLY_TOKEN [[events]] |= G_IO_OUT | G_IO_ERR; CLOSE_CURLY_TOKEN if (FD_ISSET([[fd]], &xfds)) OPEN_CURLY_TOKEN [[events]] |= G_IO_PRI; CLOSE_CURLY_TOKEN if ([[events]]) OPEN_CURLY_TOKEN GPollFD pfd = OPEN_CURLY_TOKEN .fd = [[fd]], .events = [[events]], CLOSE_CURLY_TOKEN; g_array_append_val(gpollfds, pfd); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void gpollfds_from_select(void) OPEN_CURLY_TOKEN int [[cause]]; for ([[cause]] = 0; [[cause]] SMALLER_TOKEN= nfds; [[cause]]++) OPEN_CURLY_TOKEN int [[executioner]] = 0; if (FD_ISSET([[cause]], &rfds)) OPEN_CURLY_TOKEN [[executioner]] |= G_IO_IN | G_IO_HUP | G_IO_ERR; CLOSE_CURLY_TOKEN if (FD_ISSET([[cause]], &wfds)) OPEN_CURLY_TOKEN [[executioner]] |= G_IO_OUT | G_IO_ERR; CLOSE_CURLY_TOKEN if (FD_ISSET([[cause]], &xfds)) OPEN_CURLY_TOKEN [[executioner]] |= G_IO_PRI; CLOSE_CURLY_TOKEN if ([[executioner]]) OPEN_CURLY_TOKEN GPollFD pfd = OPEN_CURLY_TOKEN .fd = [[cause]], .events = [[executioner]], CLOSE_CURLY_TOKEN; g_array_append_val(gpollfds, pfd); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 153 ---------------------------------------------
[[0 (94%)]] --> [[1 (64%)]] --> Socre: 0.6401873826980591

[[[[Adv]]]]: void cpu_sh4_invalidate_tlb(CPUSH4State *[[s]]) OPEN_CURLY_TOKEN int [[i]]; for ([[i]] = 0; [[i]] SMALLER_TOKEN UTLB_SIZE; [[i]]++) OPEN_CURLY_TOKEN tlb_t * [[entry]] = &[[s]]-GREATER_TOKENutlbOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN; [[entry]]-GREATER_TOKENv = 0; CLOSE_CURLY_TOKEN for ([[i]] = 0; [[i]] SMALLER_TOKEN UTLB_SIZE; [[i]]++) OPEN_CURLY_TOKEN tlb_t * [[entry]] = &[[s]]-GREATER_TOKENutlbOPEN_SQUARE_TOKEN[[i]]CLOSE_SQUARE_TOKEN; [[entry]]-GREATER_TOKENv = 0; CLOSE_CURLY_TOKEN tlb_flush([[s]], 1); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void cpu_sh4_invalidate_tlb(CPUSH4State *[[mortuary]]) OPEN_CURLY_TOKEN int [[torben]]; for ([[torben]] = 0; [[torben]] SMALLER_TOKEN UTLB_SIZE; [[torben]]++) OPEN_CURLY_TOKEN tlb_t * [[fridge]] = &[[mortuary]]-GREATER_TOKENutlbOPEN_SQUARE_TOKEN[[torben]]CLOSE_SQUARE_TOKEN; [[fridge]]-GREATER_TOKENv = 0; CLOSE_CURLY_TOKEN for ([[torben]] = 0; [[torben]] SMALLER_TOKEN UTLB_SIZE; [[torben]]++) OPEN_CURLY_TOKEN tlb_t * [[fridge]] = &[[mortuary]]-GREATER_TOKENutlbOPEN_SQUARE_TOKEN[[torben]]CLOSE_SQUARE_TOKEN; [[fridge]]-GREATER_TOKENv = 0; CLOSE_CURLY_TOKEN tlb_flush([[mortuary]], 1); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 154 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 68 / 21 / 65 / 154:   6%|         | 154/2690 [00:12<03:32, 11.95it/s][Succeeded / Failed / Skipped / Total] 69 / 21 / 65 / 155:   6%|         | 155/2690 [00:14<03:53, 10.84it/s][[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int kvmppc_reset_htab(int shift_hint) OPEN_CURLY_TOKEN uint32_t shift = shift_hint; if (!kvm_enabled()) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) OPEN_CURLY_TOKEN int ret; ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift); if (ret == -ENOTTY) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN else if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return ret; CLOSE_CURLY_TOKEN return shift; CLOSE_CURLY_TOKEN if (kvmppc_is_pr(kvm_state)) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN return 24; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 155 ---------------------------------------------
[[1 (71%)]] --> [[0 (60%)]] --> Socre: 0.6049667596817017

[[[[Adv]]]]: static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *[[avpkt]]) OPEN_CURLY_TOKEN const uint8_t *buf = [[avpkt]]-GREATER_TOKENdata; PTXContext * const s = avctx-GREATER_TOKENpriv_data; AVFrame *picture = data; AVFrame * const p = &s-GREATER_TOKENpicture; unsigned int offset, w, h, y, stride, bytes_per_pixel; uint8_t *ptr; offset = AV_RL16(buf); w = AV_RL16(buf+8); h = AV_RL16(buf+10); bytes_per_pixel = AV_RL16(buf+12) GREATER_TOKENGREATER_TOKEN 3; if (bytes_per_pixel != 2) OPEN_CURLY_TOKEN av_log_ask_for_sample(avctx, "Image format is not RGB15.\n"); return -1; CLOSE_CURLY_TOKEN avctx-GREATER_TOKENpix_fmt = PIX_FMT_RGB555; if (buf_end - buf SMALLER_TOKEN offset) if (offset != 0x2c) av_log_ask_for_sample(avctx, "offset != 0x2c\n"); buf += offset; if (p-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) avctx-GREATER_TOKENrelease_buffer(avctx, p); if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx-GREATER_TOKENwidth || h != avctx-GREATER_TOKENheight) avcodec_set_dimensions(avctx, w, h); if (avctx-GREATER_TOKENget_buffer(avctx, p) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; CLOSE_CURLY_TOKEN p-GREATER_TOKENpict_type = AV_PICTURE_TYPE_I; ptr = p-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; stride = p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; for (y=0; ySMALLER_TOKENh; y++) OPEN_CURLY_TOKEN if (buf_end - buf SMALLER_TOKEN w * bytes_per_pixel) break; #if HAVE_BIGENDIAN unsigned int x; for (x=0; xSMALLER_TOKENw*bytes_per_pixel; x+=bytes_per_pixel) AV_WN16(ptr+x, AV_RL16(buf+x)); #else memcpy(ptr, buf, w*bytes_per_pixel); #endif ptr += stride; buf += w*bytes_per_pixel; CLOSE_CURLY_TOKEN *picture = s-GREATER_TOKENpicture; *data_size = sizeof(AVPicture); return offset + w*h*bytes_per_pixel; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *[[miniskirts]]) OPEN_CURLY_TOKEN const uint8_t *buf = [[miniskirts]]-GREATER_TOKENdata; PTXContext * const s = avctx-GREATER_TOKENpriv_data; AVFrame *picture = data; AVFrame * const p = &s-GREATER_TOKENpicture; unsigned int offset, w, h, y, stride, bytes_per_pixel; uint8_t *ptr; offset = AV_RL16(buf); w = AV_RL16(buf+8); h = AV_RL16(buf+10); bytes_per_pixel = AV_RL16(buf+12) GREATER_TOKENGREATER_TOKEN 3; if (bytes_per_pixel != 2) OPEN_CURLY_TOKEN av_log_ask_for_sample(avctx, "Image format is not RGB15.\n"); return -1; CLOSE_CURLY_TOKEN avctx-GREATER_TOKENpix_fmt = PIX_FMT_RGB555; if (buf_end - buf SMALLER_TOKEN offset) if (offset != 0x2c) av_log_ask_for_sample(avctx, "offset != 0x2c\n"); buf += offset; if (p-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) avctx-GREATER_TOKENrelease_buffer(avctx, p); if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx-GREATER_TOKENwidth || h != avctx-GREATER_TOKENheight) avcodec_set_dimensions(avctx, w, h); if (avctx-GREATER_TOKENget_buffer(avctx, p) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; CLOSE_CURLY_TOKEN p-GREATER_TOKENpict_type = AV_PICTURE_TYPE_I; ptr = p-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; stride = p-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; for (y=0; ySMALLER_TOKENh; y++) OPEN_CURLY_TOKEN if (buf_end - buf SMALLER_TOKEN w * bytes_per_pixel) break; #if HAVE_BIGENDIAN unsigned int x; for (x=0; xSMALLER_TOKENw*bytes_per_pixel; x+=bytes_per_pixel) AV_WN16(ptr+x, AV_RL16(buf+x)); #else memcpy(ptr, buf, w*bytes_per_pixel); #endif ptr += stride; buf += w*bytes_per_pixel; CLOSE_CURLY_TOKEN *picture = s-GREATER_TOKENpicture; *data_size = sizeof(AVPicture); return offset + w*h*bytes_per_pixel; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 156 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 70 / 21 / 65 / 156:   6%|         | 156/2690 [00:15<04:06, 10.30it/s][[1 (87%)]] --> [[0 (62%)]] --> Socre: 0.6192144155502319

[[[[Adv]]]]: static int scsi_req_length(SCSIRequest *[[req]], uint8_t *[[cmd]]) OPEN_CURLY_TOKEN switch ([[cmd]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 5) OPEN_CURLY_TOKEN case 0: [[req]]-GREATER_TOKENcmd.xfer = [[cmd]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN; [[req]]-GREATER_TOKENcmd.len = 6; if ([[req]]-GREATER_TOKENcmd.xfer == 0) [[req]]-GREATER_TOKENcmd.xfer = 256; break; case 1: case 2: [[req]]-GREATER_TOKENcmd.xfer = [[cmd]]OPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN | ([[cmd]]OPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8); [[req]]-GREATER_TOKENcmd.len = 10; break; case 4: [[req]]-GREATER_TOKENcmd.xfer = [[cmd]]OPEN_SQUARE_TOKEN13CLOSE_SQUARE_TOKEN | ([[cmd]]OPEN_SQUARE_TOKEN12CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | ([[cmd]]OPEN_SQUARE_TOKEN11CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 16) | ([[cmd]]OPEN_SQUARE_TOKEN10CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 24); [[req]]-GREATER_TOKENcmd.len = 16; break; case 5: [[req]]-GREATER_TOKENcmd.xfer = [[cmd]]OPEN_SQUARE_TOKEN9CLOSE_SQUARE_TOKEN | ([[cmd]]OPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | ([[cmd]]OPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 16) | ([[cmd]]OPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 24); [[req]]-GREATER_TOKENcmd.len = 12; break; default: trace_scsi_req_parse_bad([[req]]-GREATER_TOKENdev-GREATER_TOKENid, [[req]]-GREATER_TOKENlun, [[req]]-GREATER_TOKENtag, [[cmd]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN); return -1; CLOSE_CURLY_TOKEN switch([[cmd]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN case TEST_UNIT_READY: case START_STOP: case SEEK_6: case WRITE_FILEMARKS: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case VERIFY: case SEEK_10: case SYNCHRONIZE_CACHE: case LOCK_UNLOCK_CACHE: case LOAD_UNLOAD: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG: case MOVE_MEDIUM: case UPDATE_BLOCK: [[req]]-GREATER_TOKENcmd.xfer = 0; break; case MODE_SENSE: break; case WRITE_SAME: [[req]]-GREATER_TOKENcmd.xfer = 1; break; case READ_CAPACITY: [[req]]-GREATER_TOKENcmd.xfer = 8; break; case READ_BLOCK_LIMITS: [[req]]-GREATER_TOKENcmd.xfer = 6; break; case READ_POSITION: [[req]]-GREATER_TOKENcmd.xfer = 20; break; case SEND_VOLUME_TAG: [[req]]-GREATER_TOKENcmd.xfer *= 40; break; case MEDIUM_SCAN: [[req]]-GREATER_TOKENcmd.xfer *= 8; break; case WRITE_10: case WRITE_VERIFY: case WRITE_6: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: [[req]]-GREATER_TOKENcmd.xfer *= [[req]]-GREATER_TOKENdev-GREATER_TOKENblocksize; break; case READ_10: case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: [[req]]-GREATER_TOKENcmd.xfer *= [[req]]-GREATER_TOKENdev-GREATER_TOKENblocksize; break; case INQUIRY: [[req]]-GREATER_TOKENcmd.xfer = [[cmd]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN | ([[cmd]]OPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8); break; case MAINTENANCE_OUT: case MAINTENANCE_IN: if ([[req]]-GREATER_TOKENdev-GREATER_TOKENtype == TYPE_ROM) OPEN_CURLY_TOKEN [[req]]-GREATER_TOKENcmd.xfer = [[cmd]]OPEN_SQUARE_TOKEN9CLOSE_SQUARE_TOKEN | ([[cmd]]OPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8); CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int scsi_req_length(SCSIRequest *[[drilled]], uint8_t *[[fits]]) OPEN_CURLY_TOKEN switch ([[fits]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 5) OPEN_CURLY_TOKEN case 0: [[drilled]]-GREATER_TOKENcmd.xfer = [[fits]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN; [[drilled]]-GREATER_TOKENcmd.len = 6; if ([[drilled]]-GREATER_TOKENcmd.xfer == 0) [[drilled]]-GREATER_TOKENcmd.xfer = 256; break; case 1: case 2: [[drilled]]-GREATER_TOKENcmd.xfer = [[fits]]OPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN | ([[fits]]OPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8); [[drilled]]-GREATER_TOKENcmd.len = 10; break; case 4: [[drilled]]-GREATER_TOKENcmd.xfer = [[fits]]OPEN_SQUARE_TOKEN13CLOSE_SQUARE_TOKEN | ([[fits]]OPEN_SQUARE_TOKEN12CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | ([[fits]]OPEN_SQUARE_TOKEN11CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 16) | ([[fits]]OPEN_SQUARE_TOKEN10CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 24); [[drilled]]-GREATER_TOKENcmd.len = 16; break; case 5: [[drilled]]-GREATER_TOKENcmd.xfer = [[fits]]OPEN_SQUARE_TOKEN9CLOSE_SQUARE_TOKEN | ([[fits]]OPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | ([[fits]]OPEN_SQUARE_TOKEN7CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 16) | ([[fits]]OPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 24); [[drilled]]-GREATER_TOKENcmd.len = 12; break; default: trace_scsi_req_parse_bad([[drilled]]-GREATER_TOKENdev-GREATER_TOKENid, [[drilled]]-GREATER_TOKENlun, [[drilled]]-GREATER_TOKENtag, [[fits]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN); return -1; CLOSE_CURLY_TOKEN switch([[fits]]OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN case TEST_UNIT_READY: case START_STOP: case SEEK_6: case WRITE_FILEMARKS: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case VERIFY: case SEEK_10: case SYNCHRONIZE_CACHE: case LOCK_UNLOCK_CACHE: case LOAD_UNLOAD: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG: case MOVE_MEDIUM: case UPDATE_BLOCK: [[drilled]]-GREATER_TOKENcmd.xfer = 0; break; case MODE_SENSE: break; case WRITE_SAME: [[drilled]]-GREATER_TOKENcmd.xfer = 1; break; case READ_CAPACITY: [[drilled]]-GREATER_TOKENcmd.xfer = 8; break; case READ_BLOCK_LIMITS: [[drilled]]-GREATER_TOKENcmd.xfer = 6; break; case READ_POSITION: [[drilled]]-GREATER_TOKENcmd.xfer = 20; break; case SEND_VOLUME_TAG: [[drilled]]-GREATER_TOKENcmd.xfer *= 40; break; case MEDIUM_SCAN: [[drilled]]-GREATER_TOKENcmd.xfer *= 8; break; case WRITE_10: case WRITE_VERIFY: case WRITE_6: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: [[drilled]]-GREATER_TOKENcmd.xfer *= [[drilled]]-GREATER_TOKENdev-GREATER_TOKENblocksize; break; case READ_10: case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: [[drilled]]-GREATER_TOKENcmd.xfer *= [[drilled]]-GREATER_TOKENdev-GREATER_TOKENblocksize; break; case INQUIRY: [[drilled]]-GREATER_TOKENcmd.xfer = [[fits]]OPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN | ([[fits]]OPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8); break; case MAINTENANCE_OUT: case MAINTENANCE_IN: if ([[drilled]]-GREATER_TOKENdev-GREATER_TOKENtype == TYPE_ROM) OPEN_CURLY_TOKEN [[drilled]]-GREATER_TOKENcmd.xfer = [[fits]]OPEN_SQUARE_TOKEN9CLOSE_SQUARE_TOKEN | ([[fits]]OPEN_SQUARE_TOKEN8CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8); CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 157 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 70 / 21 / 66 / 157:   6%|         | 157/2690 [00:15<04:05, 10.34it/s][[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data) OPEN_CURLY_TOKEN DeviceClass *dc = DEVICE_CLASS(oc); PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc); CPUClass *cc = CPU_CLASS(oc); dc-GREATER_TOKENfw_name = "PowerPC,POWER9"; dc-GREATER_TOKENdesc = "POWER9"; dc-GREATER_TOKENprops = powerpc_servercpu_properties; pcc-GREATER_TOKENpvr_match = ppc_pvr_match_power9; pcc-GREATER_TOKENpcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07; pcc-GREATER_TOKENpcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 | PCR_COMPAT_2_05; pcc-GREATER_TOKENinit_proc = init_proc_POWER9; pcc-GREATER_TOKENcheck_pow = check_pow_nocheck; cc-GREATER_TOKENhas_work = cpu_has_work_POWER9; pcc-GREATER_TOKENinsns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB | PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES | PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE | PPC_FLOAT_FRSQRTES | PPC_FLOAT_STFIWX | PPC_FLOAT_EXT | PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ | PPC_MEM_SYNC | PPC_MEM_EIEIO | PPC_MEM_TLBIE | PPC_MEM_TLBSYNC | PPC_64B | PPC_64BX | PPC_ALTIVEC | PPC_SEGMENT_64B | PPC_SLBI | PPC_POPCNTB | PPC_POPCNTWD | PPC_CILDST; pcc-GREATER_TOKENinsns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX | PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 | PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 | PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 | PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 | PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 | PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300; pcc-GREATER_TOKENmsr_mask = (1ull SMALLER_TOKENSMALLER_TOKEN MSR_SF) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_TM) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_VR) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_VSX) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_EE) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_PR) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_FP) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_ME) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_FE0) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_SE) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_DE) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_FE1) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_IR) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_DR) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_PMM) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_RI) | (1ull SMALLER_TOKENSMALLER_TOKEN MSR_LE); pcc-GREATER_TOKENmmu_model = POWERPC_MMU_3_00; #if defined(CONFIG_SOFTMMU) pcc-GREATER_TOKENhandle_mmu_fault = ppc64_v3_handle_mmu_fault; pcc-GREATER_TOKENsps = &POWER7_POWER8_sps; pcc-GREATER_TOKENradix_page_info = &POWER9_radix_page_info; #endif pcc-GREATER_TOKENexcp_model = POWERPC_EXCP_POWER8; pcc-GREATER_TOKENbus_model = PPC_FLAGS_INPUT_POWER7; pcc-GREATER_TOKENbfd_mach = bfd_mach_ppc64; pcc-GREATER_TOKENflags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE | POWERPC_FLAG_BE | POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR | POWERPC_FLAG_VSX | POWERPC_FLAG_TM; pcc-GREATER_TOKENl1_dcache_size = 0x8000; pcc-GREATER_TOKENl1_icache_size = 0x8000; pcc-GREATER_TOKENinterrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 158 ---------------------------------------------
[[1 (83%)]] --> [[0 (53%)]] --> Socre: 0.5319664478302002

[[[[Adv]]]]: static void filter(USPPContext *p, uint8_t *dstOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, uint8_t *srcOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, int dst_strideOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, int src_strideOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, int [[width]], int height, uint8_t *[[qp_store]], int qp_stride) OPEN_CURLY_TOKEN int x, y, i, j; const int count = 1SMALLER_TOKENSMALLER_TOKENp-GREATER_TOKENlog2_count; for (i = 0; i SMALLER_TOKEN 3; i++) OPEN_CURLY_TOKEN int is_chroma = !!i; int w = [[width]] GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENhsub : 0); int h = height GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENvsub : 0); int [[stride]] = p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; int block = BLOCK GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENhsub : 0); if (!srcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN || !dstOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) continue; for (y = 0; y SMALLER_TOKEN h; y++) OPEN_CURLY_TOKEN int index = block + block * [[stride]] + y * [[stride]]; memcpy(p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + index, srcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + y * src_strideOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, w ); for (x = 0; x SMALLER_TOKEN block; x++) OPEN_CURLY_TOKEN p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENindex - x - 1CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENindex + x CLOSE_SQUARE_TOKEN; p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENindex + w + x CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENindex + w - x - 1CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (y = 0; y SMALLER_TOKEN block; y++) OPEN_CURLY_TOKEN memcpy(p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + ( block-1-y) * [[stride]], p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + ( y+block ) * [[stride]], [[stride]]); memcpy(p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + (h+block +y) * [[stride]], p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + (h-y+block-1) * [[stride]], [[stride]]); CLOSE_CURLY_TOKEN p-GREATER_TOKENframe-GREATER_TOKENlinesizeOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = [[stride]]; memset(p-GREATER_TOKENtempOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 0, (h + 2 * block) * [[stride]] * sizeof(int16_t)); CLOSE_CURLY_TOKEN if (p-GREATER_TOKENqp) p-GREATER_TOKENframe-GREATER_TOKENquality = p-GREATER_TOKENqp * FF_QP2LAMBDA; else OPEN_CURLY_TOKEN int qpsum=0; int [[qpcount]] = (heightGREATER_TOKENGREATER_TOKEN4) * (heightGREATER_TOKENGREATER_TOKEN4); for (y = 0; y SMALLER_TOKEN (heightGREATER_TOKENGREATER_TOKEN4); y++) OPEN_CURLY_TOKEN for (x = 0; x SMALLER_TOKEN ([[width]]GREATER_TOKENGREATER_TOKEN4); x++) qpsum += [[qp_store]]OPEN_SQUARE_TOKENx + y * qp_strideCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN p-GREATER_TOKENframe-GREATER_TOKENquality = norm_qscale((qpsum + [[qpcount]]/2) / [[qpcount]], p-GREATER_TOKENqscale_type) * FF_QP2LAMBDA; CLOSE_CURLY_TOKEN p-GREATER_TOKENframe-GREATER_TOKENheight = height; p-GREATER_TOKENframe-GREATER_TOKENwidth = [[width]]; for (i = 0; i SMALLER_TOKEN count; i++) OPEN_CURLY_TOKEN const int x1 = offsetOPEN_SQUARE_TOKENi+count-1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; const int y1 = offsetOPEN_SQUARE_TOKENi+count-1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; const int x1c = x1 GREATER_TOKENGREATER_TOKEN p-GREATER_TOKENhsub; const int y1c = y1 GREATER_TOKENGREATER_TOKEN p-GREATER_TOKENvsub; const int BLOCKc = BLOCK GREATER_TOKENGREATER_TOKEN p-GREATER_TOKENhsub; int offset; AVPacket pkt; int got_pkt_ptr; av_init_packet(&pkt); pkt.data = p-GREATER_TOKENoutbuf; pkt.size = p-GREATER_TOKENoutbuf_size; p-GREATER_TOKENframe-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN + x1 + y1 * p-GREATER_TOKENframe-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; p-GREATER_TOKENframe-GREATER_TOKENdataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN + x1c + y1c * p-GREATER_TOKENframe-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; p-GREATER_TOKENframe-GREATER_TOKENdataOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN + x1c + y1c * p-GREATER_TOKENframe-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN; p-GREATER_TOKENframe-GREATER_TOKENformat = p-GREATER_TOKENavctx_encOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENpix_fmt; avcodec_encode_video2(p-GREATER_TOKENavctx_encOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, &pkt, p-GREATER_TOKENframe, &got_pkt_ptr); p-GREATER_TOKENframe_dec = p-GREATER_TOKENavctx_encOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENcoded_frame; offset = (BLOCK-x1) + (BLOCK-y1) * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; for (y = 0; y SMALLER_TOKEN height; y++) for (x = 0; x SMALLER_TOKEN [[width]]; x++) p-GREATER_TOKENtempOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN += p-GREATER_TOKENframe_dec-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN + offsetCLOSE_SQUARE_TOKEN; if (!srcOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN || !dstOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; for (y = 0; y SMALLER_TOKEN heightGREATER_TOKENGREATER_TOKENp-GREATER_TOKENvsub; y++) OPEN_CURLY_TOKEN for (x = 0; x SMALLER_TOKEN widthGREATER_TOKENGREATER_TOKENp-GREATER_TOKENhsub; x++) OPEN_CURLY_TOKEN p-GREATER_TOKENtempOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN += p-GREATER_TOKENframe_dec-GREATER_TOKENdataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN + offsetCLOSE_SQUARE_TOKEN; p-GREATER_TOKENtempOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN += p-GREATER_TOKENframe_dec-GREATER_TOKENdataOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN + offsetCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (j = 0; j SMALLER_TOKEN 3; j++) OPEN_CURLY_TOKEN int is_chroma = !!j; if (!dstOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN) continue; store_slice_c(dstOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, p-GREATER_TOKENtempOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, dst_strideOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, [[width]] GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENhsub : 0), height GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENvsub : 0), 8-p-GREATER_TOKENlog2_count); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void filter(USPPContext *p, uint8_t *dstOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, uint8_t *srcOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, int dst_strideOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, int src_strideOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN, int [[valued]], int height, uint8_t *[[negotiable]], int qp_stride) OPEN_CURLY_TOKEN int x, y, i, j; const int count = 1SMALLER_TOKENSMALLER_TOKENp-GREATER_TOKENlog2_count; for (i = 0; i SMALLER_TOKEN 3; i++) OPEN_CURLY_TOKEN int is_chroma = !!i; int w = [[valued]] GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENhsub : 0); int h = height GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENvsub : 0); int [[bulletproof]] = p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; int block = BLOCK GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENhsub : 0); if (!srcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN || !dstOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) continue; for (y = 0; y SMALLER_TOKEN h; y++) OPEN_CURLY_TOKEN int index = block + block * [[bulletproof]] + y * [[bulletproof]]; memcpy(p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + index, srcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + y * src_strideOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, w ); for (x = 0; x SMALLER_TOKEN block; x++) OPEN_CURLY_TOKEN p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENindex - x - 1CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENindex + x CLOSE_SQUARE_TOKEN; p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENindex + w + x CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENindex + w - x - 1CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (y = 0; y SMALLER_TOKEN block; y++) OPEN_CURLY_TOKEN memcpy(p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + ( block-1-y) * [[bulletproof]], p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + ( y+block ) * [[bulletproof]], [[bulletproof]]); memcpy(p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + (h+block +y) * [[bulletproof]], p-GREATER_TOKENsrcOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN + (h-y+block-1) * [[bulletproof]], [[bulletproof]]); CLOSE_CURLY_TOKEN p-GREATER_TOKENframe-GREATER_TOKENlinesizeOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = [[bulletproof]]; memset(p-GREATER_TOKENtempOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, 0, (h + 2 * block) * [[bulletproof]] * sizeof(int16_t)); CLOSE_CURLY_TOKEN if (p-GREATER_TOKENqp) p-GREATER_TOKENframe-GREATER_TOKENquality = p-GREATER_TOKENqp * FF_QP2LAMBDA; else OPEN_CURLY_TOKEN int qpsum=0; int [[wrinkle]] = (heightGREATER_TOKENGREATER_TOKEN4) * (heightGREATER_TOKENGREATER_TOKEN4); for (y = 0; y SMALLER_TOKEN (heightGREATER_TOKENGREATER_TOKEN4); y++) OPEN_CURLY_TOKEN for (x = 0; x SMALLER_TOKEN ([[valued]]GREATER_TOKENGREATER_TOKEN4); x++) qpsum += [[negotiable]]OPEN_SQUARE_TOKENx + y * qp_strideCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN p-GREATER_TOKENframe-GREATER_TOKENquality = norm_qscale((qpsum + [[wrinkle]]/2) / [[wrinkle]], p-GREATER_TOKENqscale_type) * FF_QP2LAMBDA; CLOSE_CURLY_TOKEN p-GREATER_TOKENframe-GREATER_TOKENheight = height; p-GREATER_TOKENframe-GREATER_TOKENwidth = [[valued]]; for (i = 0; i SMALLER_TOKEN count; i++) OPEN_CURLY_TOKEN const int x1 = offsetOPEN_SQUARE_TOKENi+count-1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; const int y1 = offsetOPEN_SQUARE_TOKENi+count-1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; const int x1c = x1 GREATER_TOKENGREATER_TOKEN p-GREATER_TOKENhsub; const int y1c = y1 GREATER_TOKENGREATER_TOKEN p-GREATER_TOKENvsub; const int BLOCKc = BLOCK GREATER_TOKENGREATER_TOKEN p-GREATER_TOKENhsub; int offset; AVPacket pkt; int got_pkt_ptr; av_init_packet(&pkt); pkt.data = p-GREATER_TOKENoutbuf; pkt.size = p-GREATER_TOKENoutbuf_size; p-GREATER_TOKENframe-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN + x1 + y1 * p-GREATER_TOKENframe-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; p-GREATER_TOKENframe-GREATER_TOKENdataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN + x1c + y1c * p-GREATER_TOKENframe-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; p-GREATER_TOKENframe-GREATER_TOKENdataOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = p-GREATER_TOKENsrcOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN + x1c + y1c * p-GREATER_TOKENframe-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN; p-GREATER_TOKENframe-GREATER_TOKENformat = p-GREATER_TOKENavctx_encOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENpix_fmt; avcodec_encode_video2(p-GREATER_TOKENavctx_encOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, &pkt, p-GREATER_TOKENframe, &got_pkt_ptr); p-GREATER_TOKENframe_dec = p-GREATER_TOKENavctx_encOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENcoded_frame; offset = (BLOCK-x1) + (BLOCK-y1) * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; for (y = 0; y SMALLER_TOKEN height; y++) for (x = 0; x SMALLER_TOKEN [[valued]]; x++) p-GREATER_TOKENtempOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN += p-GREATER_TOKENframe_dec-GREATER_TOKENdataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN + offsetCLOSE_SQUARE_TOKEN; if (!srcOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN || !dstOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; for (y = 0; y SMALLER_TOKEN heightGREATER_TOKENGREATER_TOKENp-GREATER_TOKENvsub; y++) OPEN_CURLY_TOKEN for (x = 0; x SMALLER_TOKEN widthGREATER_TOKENGREATER_TOKENp-GREATER_TOKENhsub; x++) OPEN_CURLY_TOKEN p-GREATER_TOKENtempOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN += p-GREATER_TOKENframe_dec-GREATER_TOKENdataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN + offsetCLOSE_SQUARE_TOKEN; p-GREATER_TOKENtempOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN += p-GREATER_TOKENframe_dec-GREATER_TOKENdataOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENx + y * p-GREATER_TOKENframe_dec-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN + offsetCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (j = 0; j SMALLER_TOKEN 3; j++) OPEN_CURLY_TOKEN int is_chroma = !!j; if (!dstOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN) continue; store_slice_c(dstOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, p-GREATER_TOKENtempOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, dst_strideOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, p-GREATER_TOKENtemp_strideOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, [[valued]] GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENhsub : 0), height GREATER_TOKENGREATER_TOKEN (is_chroma ? p-GREATER_TOKENvsub : 0), 8-p-GREATER_TOKENlog2_count); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 71 / 21 / 66 / 158:   6%|         | 158/2690 [00:15<04:14,  9.94it/s][Succeeded / Failed / Skipped / Total] 71 / 21 / 67 / 159:   6%|         | 159/2690 [00:15<04:13,  9.98it/s][Succeeded / Failed / Skipped / Total] 72 / 21 / 67 / 160:   6%|         | 160/2690 [00:20<05:19,  7.92it/s][Succeeded / Failed / Skipped / Total] 72 / 22 / 67 / 161:   6%|         | 161/2690 [00:25<06:40,  6.32it/s]
--------------------------------------------- Result 159 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters) OPEN_CURLY_TOKEN const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx-GREATER_TOKENpix_fmt); opj_image_cmptparm_t cmptparmOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = OPEN_CURLY_TOKENOPEN_CURLY_TOKEN0CLOSE_CURLY_TOKENCLOSE_CURLY_TOKEN; opj_image_t *img; int i; int sub_dxOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN; int sub_dyOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN; int numcomps; OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN; sub_dxOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = sub_dxOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = 1; sub_dyOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = sub_dyOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = 1; sub_dxOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = sub_dxOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = 1 SMALLER_TOKENSMALLER_TOKEN desc-GREATER_TOKENlog2_chroma_w; sub_dyOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = sub_dyOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = 1 SMALLER_TOKENSMALLER_TOKEN desc-GREATER_TOKENlog2_chroma_h; numcomps = desc-GREATER_TOKENnb_components; switch (avctx-GREATER_TOKENpix_fmt) OPEN_CURLY_TOKEN case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YA8: case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YA16: color_space = CLRSPC_GRAY; break; case AV_PIX_FMT_RGB24: case AV_PIX_FMT_RGBA: case AV_PIX_FMT_RGB48: case AV_PIX_FMT_RGBA64: case AV_PIX_FMT_GBR24P: case AV_PIX_FMT_GBRP9: case AV_PIX_FMT_GBRP10: case AV_PIX_FMT_GBRP12: case AV_PIX_FMT_GBRP14: case AV_PIX_FMT_GBRP16: case AV_PIX_FMT_XYZ12: color_space = CLRSPC_SRGB; break; case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUVA420P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUV420P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUVA420P9: case AV_PIX_FMT_YUVA422P9: case AV_PIX_FMT_YUVA444P9: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUVA420P10: case AV_PIX_FMT_YUVA422P10: case AV_PIX_FMT_YUVA444P10: case AV_PIX_FMT_YUV420P12: case AV_PIX_FMT_YUV422P12: case AV_PIX_FMT_YUV444P12: case AV_PIX_FMT_YUV420P14: case AV_PIX_FMT_YUV422P14: case AV_PIX_FMT_YUV444P14: case AV_PIX_FMT_YUV420P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUVA420P16: case AV_PIX_FMT_YUVA422P16: case AV_PIX_FMT_YUVA444P16: color_space = CLRSPC_SYCC; break; default: av_log(avctx, AV_LOG_ERROR, "The requested pixel format '%s' is not supported\n", av_get_pix_fmt_name(avctx-GREATER_TOKENpix_fmt)); CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN numcomps; i++) OPEN_CURLY_TOKEN cmptparmOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.prec = desc-GREATER_TOKENcompOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.depth_minus1 + 1; cmptparmOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.bpp = desc-GREATER_TOKENcompOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.depth_minus1 + 1; cmptparmOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.sgnd = 0; cmptparmOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.dx = sub_dxOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; cmptparmOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.dy = sub_dyOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; cmptparmOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.w = (avctx-GREATER_TOKENwidth + sub_dxOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN - 1) / sub_dxOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; cmptparmOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN.h = (avctx-GREATER_TOKENheight + sub_dyOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN - 1) / sub_dyOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN img = opj_image_create(numcomps, cmptparm, color_space); img-GREATER_TOKENx0 = 0; img-GREATER_TOKENy0 = 0; img-GREATER_TOKENx1 = (avctx-GREATER_TOKENwidth - 1) * parameters-GREATER_TOKENsubsampling_dx + 1; img-GREATER_TOKENy1 = (avctx-GREATER_TOKENheight - 1) * parameters-GREATER_TOKENsubsampling_dy + 1; return img; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 160 ---------------------------------------------
[[1 (89%)]] --> [[0 (69%)]] --> Socre: 0.6892752647399902

[[[[Adv]]]]: int ff_schro_queue_push_back(FFSchroQueue *[[queue]], void *[[p_data]]) OPEN_CURLY_TOKEN FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement)); if (!p_new) return -1; p_new-GREATER_TOKENdata = [[p_data]]; if (![[queue]]-GREATER_TOKENp_head) [[queue]]-GREATER_TOKENp_head = p_new; else [[queue]]-GREATER_TOKENp_tail-GREATER_TOKENnext = p_new; [[queue]]-GREATER_TOKENp_tail = p_new; ++[[queue]]-GREATER_TOKENsize; return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int ff_schro_queue_push_back(FFSchroQueue *[[shops]], void *[[boldness]]) OPEN_CURLY_TOKEN FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement)); if (!p_new) return -1; p_new-GREATER_TOKENdata = [[boldness]]; if (![[shops]]-GREATER_TOKENp_head) [[shops]]-GREATER_TOKENp_head = p_new; else [[shops]]-GREATER_TOKENp_tail-GREATER_TOKENnext = p_new; [[shops]]-GREATER_TOKENp_tail = p_new; ++[[shops]]-GREATER_TOKENsize; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 161 ---------------------------------------------
[[1 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void set_vlan(Object *obj, Visitor *v, void *opaque, const char *name, Error **[[errp]]) OPEN_CURLY_TOKEN DeviceState *[[dev]] = DEVICE(obj); Property *prop = opaque; NICPeers *peers_ptr = qdev_get_prop_ptr([[dev]], prop); NetClientState **[[ptr]] = &peers_ptr-GREATER_TOKENncsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; Error *local_err = NULL; int32_t [[id]]; NetClientState *[[hubport]]; if ([[dev]]-GREATER_TOKENrealized) OPEN_CURLY_TOKEN qdev_prop_set_after_realize([[dev]], name, [[errp]]); visit_type_int32(v, &[[id]], name, &local_err); if (local_err) OPEN_CURLY_TOKEN error_propagate([[errp]], local_err); if ([[id]] == -1) OPEN_CURLY_TOKEN *[[ptr]] = NULL; [[hubport]] = net_hub_port_find([[id]]); if (![[hubport]]) OPEN_CURLY_TOKEN error_set([[errp]], QERR_INVALID_PARAMETER_VALUE, name, prop-GREATER_TOKENinfo-GREATER_TOKENname); *[[ptr]] = [[hubport]];

[[[[Adv]]]]: static void set_vlan(Object *obj, Visitor *v, void *opaque, const char *name, Error **[[regiments]]) OPEN_CURLY_TOKEN DeviceState *[[asked]] = DEVICE(obj); Property *prop = opaque; NICPeers *peers_ptr = qdev_get_prop_ptr([[asked]], prop); NetClientState **[[misbehaving]] = &peers_ptr-GREATER_TOKENncsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; Error *local_err = NULL; int32_t [[endures]]; NetClientState *[[comfy]]; if ([[asked]]-GREATER_TOKENrealized) OPEN_CURLY_TOKEN qdev_prop_set_after_realize([[asked]], name, [[regiments]]); visit_type_int32(v, &[[endures]], name, &local_err); if (local_err) OPEN_CURLY_TOKEN error_propagate([[regiments]], local_err); if ([[endures]] == -1) OPEN_CURLY_TOKEN *[[misbehaving]] = NULL; [[comfy]] = net_hub_port_find([[endures]]); if (![[comfy]]) OPEN_CURLY_TOKEN error_set([[regiments]], QERR_INVALID_PARAMETER_VALUE, name, prop-GREATER_TOKENinfo-GREATER_TOKENname); *[[misbehaving]] = [[comfy]];
--------------------------------------------- Result 162 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 22 / 67 / 162:   6%|         | 162/2690 [00:26<06:59,  6.02it/s][Succeeded / Failed / Skipped / Total] 73 / 23 / 67 / 163:   6%|         | 163/2690 [00:27<07:09,  5.89it/s][Succeeded / Failed / Skipped / Total] 74 / 23 / 67 / 164:   6%|         | 164/2690 [00:28<07:16,  5.79it/s][[0 (71%)]] --> [[1 (51%)]] --> Socre: 0.513308048248291

[[[[Adv]]]]: static int vfio_enable_intx(VFIODevice *vdev) OPEN_CURLY_TOKEN VFIOIRQSetFD irq_set_fd = OPEN_CURLY_TOKEN .irq_set = OPEN_CURLY_TOKEN .argsz = sizeof(irq_set_fd), .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER, .index = VFIO_PCI_INTX_IRQ_INDEX, .start = 0, .count = 1, CLOSE_CURLY_TOKEN, CLOSE_CURLY_TOKEN; uint8_t pin = vfio_pci_read_config(&vdev-GREATER_TOKENpdev, PCI_INTERRUPT_PIN, 1); int [[ret]]; if (vdev-GREATER_TOKENintx.disabled || !pin) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN vfio_disable_interrupts(vdev); vdev-GREATER_TOKENintx.pin = pin - 1; [[ret]] = event_notifier_init(&vdev-GREATER_TOKENintx.interrupt, 0); if ([[ret]]) OPEN_CURLY_TOKEN error_report("vfio: Error: event_notifier_init failed\n"); return [[ret]]; CLOSE_CURLY_TOKEN irq_set_fd.fd = event_notifier_get_fd(&vdev-GREATER_TOKENintx.interrupt); qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev); if (ioctl(vdev-GREATER_TOKENfd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) OPEN_CURLY_TOKEN error_report("vfio: Error: Failed to setup INTx fd: %m\n"); return -errno; CLOSE_CURLY_TOKEN vfio_mmap_set_enabled(vdev, "False" != "False"); vdev-GREATER_TOKENinterrupt = VFIO_INT_INTx; DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev-GREATER_TOKENhost.domain, vdev-GREATER_TOKENhost.bus, vdev-GREATER_TOKENhost.slot, vdev-GREATER_TOKENhost.function); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int vfio_enable_intx(VFIODevice *vdev) OPEN_CURLY_TOKEN VFIOIRQSetFD irq_set_fd = OPEN_CURLY_TOKEN .irq_set = OPEN_CURLY_TOKEN .argsz = sizeof(irq_set_fd), .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER, .index = VFIO_PCI_INTX_IRQ_INDEX, .start = 0, .count = 1, CLOSE_CURLY_TOKEN, CLOSE_CURLY_TOKEN; uint8_t pin = vfio_pci_read_config(&vdev-GREATER_TOKENpdev, PCI_INTERRUPT_PIN, 1); int [[phoenix]]; if (vdev-GREATER_TOKENintx.disabled || !pin) OPEN_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN vfio_disable_interrupts(vdev); vdev-GREATER_TOKENintx.pin = pin - 1; [[phoenix]] = event_notifier_init(&vdev-GREATER_TOKENintx.interrupt, 0); if ([[phoenix]]) OPEN_CURLY_TOKEN error_report("vfio: Error: event_notifier_init failed\n"); return [[phoenix]]; CLOSE_CURLY_TOKEN irq_set_fd.fd = event_notifier_get_fd(&vdev-GREATER_TOKENintx.interrupt); qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev); if (ioctl(vdev-GREATER_TOKENfd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) OPEN_CURLY_TOKEN error_report("vfio: Error: Failed to setup INTx fd: %m\n"); return -errno; CLOSE_CURLY_TOKEN vfio_mmap_set_enabled(vdev, "False" != "False"); vdev-GREATER_TOKENinterrupt = VFIO_INT_INTx; DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev-GREATER_TOKENhost.domain, vdev-GREATER_TOKENhost.bus, vdev-GREATER_TOKENhost.slot, vdev-GREATER_TOKENhost.function); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 163 ---------------------------------------------
[[1 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void vpc_close(BlockDriverState *[[bs]]) OPEN_CURLY_TOKEN BDRVVPCState *[[s]] = [[bs]]-GREATER_TOKENopaque; g_free([[s]]-GREATER_TOKENpagetable); #ifdef CACHE g_free([[s]]-GREATER_TOKENpageentry_u8); #endif migrate_del_blocker([[s]]-GREATER_TOKENmigration_blocker); error_free([[s]]-GREATER_TOKENmigration_blocker); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void vpc_close(BlockDriverState *[[notions]]) OPEN_CURLY_TOKEN BDRVVPCState *[[ept]] = [[notions]]-GREATER_TOKENopaque; g_free([[ept]]-GREATER_TOKENpagetable); #ifdef CACHE g_free([[ept]]-GREATER_TOKENpageentry_u8); #endif migrate_del_blocker([[ept]]-GREATER_TOKENmigration_blocker); error_free([[ept]]-GREATER_TOKENmigration_blocker); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 164 ---------------------------------------------
[[0 (51%)]] --> [[1 (68%)]] --> Socre: 0.6849590539932251

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t [[dest]], uint64_t src) OPEN_CURLY_TOKEN int i = 0; int x = 0; uint32_t l_64 = (l + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, l, [[dest]], src); #ifndef CONFIG_USER_ONLY if ((l GREATER_TOKEN 32) && (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) && ([[dest]] & TARGET_PAGE_MASK) == (([[dest]] + l) & TARGET_PAGE_MASK)) OPEN_CURLY_TOKEN if ([[dest]] == (src + 1)) OPEN_CURLY_TOKEN mvc_fast_memset(env, l + 1, [[dest]], cpu_ldub_data(env, src)); return; CLOSE_CURLY_TOKEN else if ((src & TARGET_PAGE_MASK) != ([[dest]] & TARGET_PAGE_MASK)) OPEN_CURLY_TOKEN mvc_fast_memmove(env, l + 1, [[dest]], src); return; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN #else if ([[dest]] == (src + 1)) OPEN_CURLY_TOKEN memset(g2h([[dest]]), cpu_ldub_data(env, src), l + 1); return; CLOSE_CURLY_TOKEN else if (([[dest]] SMALLER_TOKEN src) || (src + l SMALLER_TOKEN [[dest]])) OPEN_CURLY_TOKEN memmove(g2h([[dest]]), g2h(src), l + 1); return; CLOSE_CURLY_TOKEN #endif if (([[dest]] + 8 SMALLER_TOKEN= src) || (src + 8 SMALLER_TOKEN= [[dest]])) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN l_64; i++) OPEN_CURLY_TOKEN cpu_stq_data(env, [[dest]] + x, cpu_ldq_data(env, src + x)); x += 8; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (i = x; i SMALLER_TOKEN= l; i++) OPEN_CURLY_TOKEN cpu_stb_data(env, [[dest]] + i, cpu_ldub_data(env, src + i)); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t [[negatives]], uint64_t src) OPEN_CURLY_TOKEN int i = 0; int x = 0; uint32_t l_64 = (l + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, l, [[negatives]], src); #ifndef CONFIG_USER_ONLY if ((l GREATER_TOKEN 32) && (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) && ([[negatives]] & TARGET_PAGE_MASK) == (([[negatives]] + l) & TARGET_PAGE_MASK)) OPEN_CURLY_TOKEN if ([[negatives]] == (src + 1)) OPEN_CURLY_TOKEN mvc_fast_memset(env, l + 1, [[negatives]], cpu_ldub_data(env, src)); return; CLOSE_CURLY_TOKEN else if ((src & TARGET_PAGE_MASK) != ([[negatives]] & TARGET_PAGE_MASK)) OPEN_CURLY_TOKEN mvc_fast_memmove(env, l + 1, [[negatives]], src); return; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN #else if ([[negatives]] == (src + 1)) OPEN_CURLY_TOKEN memset(g2h([[negatives]]), cpu_ldub_data(env, src), l + 1); return; CLOSE_CURLY_TOKEN else if (([[negatives]] SMALLER_TOKEN src) || (src + l SMALLER_TOKEN [[negatives]])) OPEN_CURLY_TOKEN memmove(g2h([[negatives]]), g2h(src), l + 1); return; CLOSE_CURLY_TOKEN #endif if (([[negatives]] + 8 SMALLER_TOKEN= src) || (src + 8 SMALLER_TOKEN= [[negatives]])) OPEN_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN l_64; i++) OPEN_CURLY_TOKEN cpu_stq_data(env, [[negatives]] + x, cpu_ldq_data(env, src + x)); x += 8; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (i = x; i SMALLER_TOKEN= l; i++) OPEN_CURLY_TOKEN cpu_stb_data(env, [[negatives]] + i, cpu_ldub_data(env, src + i)); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 165 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 74 / 24 / 67 / 165:   6%|         | 165/2690 [00:30<07:42,  5.46it/s][[1 (96%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void RENAME(rgb15tobgr24)(const uint8_t *[[src]], uint8_t *[[dst]], int [[src_size]]) OPEN_CURLY_TOKEN const uint16_t *[[end]]; const uint16_t *mm_end; uint8_t *d = [[dst]]; const uint16_t *[[s]] = (const uint16_t*)[[src]]; [[end]] = [[s]] + [[src_size]]/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); mm_end = [[end]] - 7; while ([[s]] SMALLER_TOKEN mm_end) OPEN_CURLY_TOKEN __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq DOLLAR_TOKEN3, %%mm0 \n\t" "psrlq DOLLAR_TOKEN2, %%mm1 \n\t" "psrlq DOLLAR_TOKEN7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq DOLLAR_TOKEN8, %%mm1 \n\t" "psllq DOLLAR_TOKEN16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq DOLLAR_TOKEN8, %%mm4 \n\t" "psllq DOLLAR_TOKEN16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" "movq %%mm0, %%mm6 \n\t" "movq %%mm3, %%mm7 \n\t" "movq 8%1, %%mm0 \n\t" "movq 8%1, %%mm1 \n\t" "movq 8%1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq DOLLAR_TOKEN3, %%mm0 \n\t" "psrlq DOLLAR_TOKEN2, %%mm1 \n\t" "psrlq DOLLAR_TOKEN7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq DOLLAR_TOKEN8, %%mm1 \n\t" "psllq DOLLAR_TOKEN16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq DOLLAR_TOKEN8, %%mm4 \n\t" "psllq DOLLAR_TOKEN16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" :"=m"(*d) :"m"(*[[s]]),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null) :"memory"); __asm__ volatile( "movq %%mm0, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "movq %%mm6, %%mm0 \n\t" "movq %%mm7, %%mm1 \n\t" "movq %%mm4, %%mm6 \n\t" "movq %%mm5, %%mm7 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" STORE_BGR24_MMX :"=m"(*d) :"m"(*[[s]]) :"memory"); d += 24; [[s]] += 8; CLOSE_CURLY_TOKEN __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[s]] SMALLER_TOKEN [[end]]) OPEN_CURLY_TOKEN register uint16_t bgr; bgr = *[[s]]++; *d++ = (bgr&0x1F)SMALLER_TOKENSMALLER_TOKEN3; *d++ = (bgr&0x3E0)GREATER_TOKENGREATER_TOKEN2; *d++ = (bgr&0x7C00)GREATER_TOKENGREATER_TOKEN7; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static inline void RENAME(rgb15tobgr24)(const uint8_t *[[merchandising]], uint8_t *[[gillette]], int [[aicha]]) OPEN_CURLY_TOKEN const uint16_t *[[theater]]; const uint16_t *mm_end; uint8_t *d = [[gillette]]; const uint16_t *[[rim]] = (const uint16_t*)[[merchandising]]; [[theater]] = [[rim]] + [[aicha]]/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); mm_end = [[theater]] - 7; while ([[rim]] SMALLER_TOKEN mm_end) OPEN_CURLY_TOKEN __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq DOLLAR_TOKEN3, %%mm0 \n\t" "psrlq DOLLAR_TOKEN2, %%mm1 \n\t" "psrlq DOLLAR_TOKEN7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq DOLLAR_TOKEN8, %%mm1 \n\t" "psllq DOLLAR_TOKEN16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq DOLLAR_TOKEN8, %%mm4 \n\t" "psllq DOLLAR_TOKEN16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" "movq %%mm0, %%mm6 \n\t" "movq %%mm3, %%mm7 \n\t" "movq 8%1, %%mm0 \n\t" "movq 8%1, %%mm1 \n\t" "movq 8%1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq DOLLAR_TOKEN3, %%mm0 \n\t" "psrlq DOLLAR_TOKEN2, %%mm1 \n\t" "psrlq DOLLAR_TOKEN7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq DOLLAR_TOKEN8, %%mm1 \n\t" "psllq DOLLAR_TOKEN16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq DOLLAR_TOKEN8, %%mm4 \n\t" "psllq DOLLAR_TOKEN16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" :"=m"(*d) :"m"(*[[rim]]),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null) :"memory"); __asm__ volatile( "movq %%mm0, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "movq %%mm6, %%mm0 \n\t" "movq %%mm7, %%mm1 \n\t" "movq %%mm4, %%mm6 \n\t" "movq %%mm5, %%mm7 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" STORE_BGR24_MMX :"=m"(*d) :"m"(*[[rim]]) :"memory"); d += 24; [[rim]] += 8; CLOSE_CURLY_TOKEN __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[rim]] SMALLER_TOKEN [[theater]]) OPEN_CURLY_TOKEN register uint16_t bgr; bgr = *[[rim]]++; *d++ = (bgr&0x1F)SMALLER_TOKENSMALLER_TOKEN3; *d++ = (bgr&0x3E0)GREATER_TOKENGREATER_TOKEN2; *d++ = (bgr&0x7C00)GREATER_TOKENGREATER_TOKEN7; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 166 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 24 / 67 / 166:   6%|         | 166/2690 [00:30<07:45,  5.42it/s][[1 (67%)]] --> [[0 (54%)]] --> Socre: 0.5379941463470459

[[[[Adv]]]]: static int mxf_read_header(AVFormatContext *[[s]], AVFormatParameters *ap) OPEN_CURLY_TOKEN MXFContext *mxf = [[s]]-GREATER_TOKENpriv_data; KLVPacket [[klv]]; int64_t essence_offset = 0; mxf-GREATER_TOKENlast_forward_tell = INT64_MAX; if (!mxf_read_sync([[s]]-GREATER_TOKENpb, mxf_header_partition_pack_key, 14)) OPEN_CURLY_TOKEN av_log([[s]], AV_LOG_ERROR, "could not find header partition pack key\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN avio_seek([[s]]-GREATER_TOKENpb, -14, SEEK_CUR); mxf-GREATER_TOKENfc = [[s]]; mxf-GREATER_TOKENrun_in = avio_tell([[s]]-GREATER_TOKENpb); while (![[s]]-GREATER_TOKENpb-GREATER_TOKENeof_reached) OPEN_CURLY_TOKEN const MXFMetadataReadTableEntry *metadata; if (klv_read_packet(&[[klv]], [[s]]-GREATER_TOKENpb) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN if(mxf_parse_handle_partition_or_eof(mxf) SMALLER_TOKEN= 0) break; else continue; CLOSE_CURLY_TOKEN PRINT_KEY([[s]], "read header", [[klv]].key); av_dlog([[s]], "size %"PRIu64" offset %#"PRIx64"\n", [[klv]].length, [[klv]].offset); if (IS_KLV_KEY([[klv]].key, mxf_encrypted_triplet_key) || IS_KLV_KEY([[klv]].key, mxf_essence_element_key) || IS_KLV_KEY([[klv]].key, mxf_avid_essence_element_key) || IS_KLV_KEY([[klv]].key, mxf_system_item_key)) OPEN_CURLY_TOKEN if (!mxf-GREATER_TOKENcurrent_partition-GREATER_TOKENessence_offset) OPEN_CURLY_TOKEN compute_partition_essence_offset([[s]], mxf, &[[klv]]); CLOSE_CURLY_TOKEN if (!essence_offset) essence_offset = [[klv]].offset; if (mxf_parse_handle_essence(mxf) SMALLER_TOKEN= 0) break; continue; CLOSE_CURLY_TOKEN else if (!memcmp([[klv]].key, mxf_header_partition_pack_key, 13) && [[klv]].keyOPEN_SQUARE_TOKEN13CLOSE_SQUARE_TOKEN GREATER_TOKEN= 2 && [[klv]].keyOPEN_SQUARE_TOKEN13CLOSE_SQUARE_TOKEN SMALLER_TOKEN= 4 && mxf-GREATER_TOKENcurrent_partition) OPEN_CURLY_TOKEN if(mxf_parse_handle_partition_or_eof(mxf) SMALLER_TOKEN= 0) break; CLOSE_CURLY_TOKEN for (metadata = mxf_metadata_read_table; metadata-GREATER_TOKENread; metadata++) OPEN_CURLY_TOKEN if (IS_KLV_KEY([[klv]].key, metadata-GREATER_TOKENkey)) OPEN_CURLY_TOKEN int [[res]]; if ([[klv]].keyOPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN == 0x53) OPEN_CURLY_TOKEN [[res]] = mxf_read_local_tags(mxf, &[[klv]], metadata-GREATER_TOKENread, metadata-GREATER_TOKENctx_size, metadata-GREATER_TOKENtype); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN uint64_t next = avio_tell([[s]]-GREATER_TOKENpb) + [[klv]].length; [[res]] = metadata-GREATER_TOKENread(mxf, [[s]]-GREATER_TOKENpb, 0, [[klv]].length, [[klv]].key, [[klv]].offset); avio_seek([[s]]-GREATER_TOKENpb, next, SEEK_SET); CLOSE_CURLY_TOKEN if ([[res]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log([[s]], AV_LOG_ERROR, "error reading header metadata\n"); return [[res]]; CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (!metadata-GREATER_TOKENread) avio_skip([[s]]-GREATER_TOKENpb, [[klv]].length); CLOSE_CURLY_TOKEN if (!essence_offset) OPEN_CURLY_TOKEN av_log([[s]], AV_LOG_ERROR, "no essence\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN avio_seek([[s]]-GREATER_TOKENpb, essence_offset, SEEK_SET); mxf_compute_essence_containers(mxf); return mxf_parse_structural_metadata(mxf); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int mxf_read_header(AVFormatContext *[[inappropriate]], AVFormatParameters *ap) OPEN_CURLY_TOKEN MXFContext *mxf = [[inappropriate]]-GREATER_TOKENpriv_data; KLVPacket [[lyn]]; int64_t essence_offset = 0; mxf-GREATER_TOKENlast_forward_tell = INT64_MAX; if (!mxf_read_sync([[inappropriate]]-GREATER_TOKENpb, mxf_header_partition_pack_key, 14)) OPEN_CURLY_TOKEN av_log([[inappropriate]], AV_LOG_ERROR, "could not find header partition pack key\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN avio_seek([[inappropriate]]-GREATER_TOKENpb, -14, SEEK_CUR); mxf-GREATER_TOKENfc = [[inappropriate]]; mxf-GREATER_TOKENrun_in = avio_tell([[inappropriate]]-GREATER_TOKENpb); while (![[inappropriate]]-GREATER_TOKENpb-GREATER_TOKENeof_reached) OPEN_CURLY_TOKEN const MXFMetadataReadTableEntry *metadata; if (klv_read_packet(&[[lyn]], [[inappropriate]]-GREATER_TOKENpb) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN if(mxf_parse_handle_partition_or_eof(mxf) SMALLER_TOKEN= 0) break; else continue; CLOSE_CURLY_TOKEN PRINT_KEY([[inappropriate]], "read header", [[lyn]].key); av_dlog([[inappropriate]], "size %"PRIu64" offset %#"PRIx64"\n", [[lyn]].length, [[lyn]].offset); if (IS_KLV_KEY([[lyn]].key, mxf_encrypted_triplet_key) || IS_KLV_KEY([[lyn]].key, mxf_essence_element_key) || IS_KLV_KEY([[lyn]].key, mxf_avid_essence_element_key) || IS_KLV_KEY([[lyn]].key, mxf_system_item_key)) OPEN_CURLY_TOKEN if (!mxf-GREATER_TOKENcurrent_partition-GREATER_TOKENessence_offset) OPEN_CURLY_TOKEN compute_partition_essence_offset([[inappropriate]], mxf, &[[lyn]]); CLOSE_CURLY_TOKEN if (!essence_offset) essence_offset = [[lyn]].offset; if (mxf_parse_handle_essence(mxf) SMALLER_TOKEN= 0) break; continue; CLOSE_CURLY_TOKEN else if (!memcmp([[lyn]].key, mxf_header_partition_pack_key, 13) && [[lyn]].keyOPEN_SQUARE_TOKEN13CLOSE_SQUARE_TOKEN GREATER_TOKEN= 2 && [[lyn]].keyOPEN_SQUARE_TOKEN13CLOSE_SQUARE_TOKEN SMALLER_TOKEN= 4 && mxf-GREATER_TOKENcurrent_partition) OPEN_CURLY_TOKEN if(mxf_parse_handle_partition_or_eof(mxf) SMALLER_TOKEN= 0) break; CLOSE_CURLY_TOKEN for (metadata = mxf_metadata_read_table; metadata-GREATER_TOKENread; metadata++) OPEN_CURLY_TOKEN if (IS_KLV_KEY([[lyn]].key, metadata-GREATER_TOKENkey)) OPEN_CURLY_TOKEN int [[unencumbered]]; if ([[lyn]].keyOPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN == 0x53) OPEN_CURLY_TOKEN [[unencumbered]] = mxf_read_local_tags(mxf, &[[lyn]], metadata-GREATER_TOKENread, metadata-GREATER_TOKENctx_size, metadata-GREATER_TOKENtype); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN uint64_t next = avio_tell([[inappropriate]]-GREATER_TOKENpb) + [[lyn]].length; [[unencumbered]] = metadata-GREATER_TOKENread(mxf, [[inappropriate]]-GREATER_TOKENpb, 0, [[lyn]].length, [[lyn]].key, [[lyn]].offset); avio_seek([[inappropriate]]-GREATER_TOKENpb, next, SEEK_SET); CLOSE_CURLY_TOKEN if ([[unencumbered]] SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log([[inappropriate]], AV_LOG_ERROR, "error reading header metadata\n"); return [[unencumbered]]; CLOSE_CURLY_TOKEN break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (!metadata-GREATER_TOKENread) avio_skip([[inappropriate]]-GREATER_TOKENpb, [[lyn]].length); CLOSE_CURLY_TOKEN if (!essence_offset) OPEN_CURLY_TOKEN av_log([[inappropriate]], AV_LOG_ERROR, "no essence\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN avio_seek([[inappropriate]]-GREATER_TOKENpb, essence_offset, SEEK_SET); mxf_compute_essence_containers(mxf); return mxf_parse_structural_metadata(mxf); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 167 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 24 / 68 / 167:   6%|         | 167/2690 [00:30<07:43,  5.45it/s][Succeeded / Failed / Skipped / Total] 76 / 24 / 68 / 168:   6%|         | 168/2690 [00:31<07:54,  5.31it/s][Succeeded / Failed / Skipped / Total] 76 / 24 / 69 / 169:   6%|         | 169/2690 [00:31<07:52,  5.34it/s][Succeeded / Failed / Skipped / Total] 76 / 24 / 70 / 170:   6%|         | 170/2690 [00:31<07:49,  5.36it/s][Succeeded / Failed / Skipped / Total] 76 / 24 / 71 / 171:   6%|         | 171/2690 [00:31<07:47,  5.39it/s][[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rtsp_listen(AVFormatContext *s) OPEN_CURLY_TOKEN RTSPState *rt = s-GREATER_TOKENpriv_data; char protoOPEN_SQUARE_TOKEN128CLOSE_SQUARE_TOKEN, hostOPEN_SQUARE_TOKEN128CLOSE_SQUARE_TOKEN, pathOPEN_SQUARE_TOKEN512CLOSE_SQUARE_TOKEN, authOPEN_SQUARE_TOKEN128CLOSE_SQUARE_TOKEN; char uriOPEN_SQUARE_TOKEN500CLOSE_SQUARE_TOKEN; int port; int default_port = RTSP_DEFAULT_PORT; char tcpnameOPEN_SQUARE_TOKEN500CLOSE_SQUARE_TOKEN; const char *lower_proto = "tcp"; unsigned char rbufOPEN_SQUARE_TOKEN4096CLOSE_SQUARE_TOKEN; unsigned char methodOPEN_SQUARE_TOKEN10CLOSE_SQUARE_TOKEN; int rbuflen = 0; int ret; enum RTSPMethod methodcode; if (!rt-GREATER_TOKENprotocols) OPEN_CURLY_TOKEN rt-GREATER_TOKENprotocols = ffurl_get_protocols(NULL, NULL); if (!rt-GREATER_TOKENprotocols) return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host), &port, path, sizeof(path), s-GREATER_TOKENfilename); ff_url_join(rt-GREATER_TOKENcontrol_uri, sizeof(rt-GREATER_TOKENcontrol_uri), proto, NULL, host, port, "%s", path); if (!strcmp(proto, "rtsps")) OPEN_CURLY_TOKEN lower_proto = "tls"; default_port = RTSPS_DEFAULT_PORT; CLOSE_CURLY_TOKEN if (port SMALLER_TOKEN 0) port = default_port; ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port, "?listen&listen_timeout=%d", rt-GREATER_TOKENinitial_timeout * 1000); if (ret = ffurl_open(&rt-GREATER_TOKENrtsp_hd, tcpname, AVIO_FLAG_READ_WRITE, &s-GREATER_TOKENinterrupt_callback, NULL, rt-GREATER_TOKENprotocols)) OPEN_CURLY_TOKEN av_log(s, AV_LOG_ERROR, "Unable to open RTSP for listening\n"); return ret; CLOSE_CURLY_TOKEN rt-GREATER_TOKENstate = RTSP_STATE_IDLE; rt-GREATER_TOKENrtsp_hd_out = rt-GREATER_TOKENrtsp_hd; for (;;) OPEN_CURLY_TOKEN ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen); if (ret SMALLER_TOKEN 0) return ret; ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method, sizeof(method), &methodcode); if (ret) OPEN_CURLY_TOKEN av_log(s, AV_LOG_ERROR, "RTSP: Unexpected Command\n"); return ret; CLOSE_CURLY_TOKEN if (methodcode == ANNOUNCE) OPEN_CURLY_TOKEN ret = rtsp_read_announce(s); rt-GREATER_TOKENstate = RTSP_STATE_PAUSED; CLOSE_CURLY_TOKEN else if (methodcode == OPTIONS) OPEN_CURLY_TOKEN ret = rtsp_read_options(s); CLOSE_CURLY_TOKEN else if (methodcode == RECORD) OPEN_CURLY_TOKEN ret = rtsp_read_record(s); if (!ret) return 0; CLOSE_CURLY_TOKEN else if (methodcode == SETUP) ret = rtsp_read_setup(s, host, uri); if (ret) OPEN_CURLY_TOKEN ffurl_close(rt-GREATER_TOKENrtsp_hd); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 168 ---------------------------------------------
[[0 (52%)]] --> [[1 (55%)]] --> Socre: 0.5536537170410156

[[[[Adv]]]]: void qemu_system_wakeup_request(WakeupReason reason) OPEN_CURLY_TOKEN if (!is_suspended) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN if (!(wakeup_reason_mask & (1 SMALLER_TOKENSMALLER_TOKEN reason))) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN runstate_set(RUN_STATE_RUNNING); monitor_protocol_event(QEVENT_WAKEUP, NULL); notifier_list_notify(&wakeup_notifiers, &reason); reset_requested = 1; qemu_notify_event(); is_suspended = "[[False]]" != "[[False]]"; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void qemu_system_wakeup_request(WakeupReason reason) OPEN_CURLY_TOKEN if (!is_suspended) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN if (!(wakeup_reason_mask & (1 SMALLER_TOKENSMALLER_TOKEN reason))) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN runstate_set(RUN_STATE_RUNNING); monitor_protocol_event(QEVENT_WAKEUP, NULL); notifier_list_notify(&wakeup_notifiers, &reason); reset_requested = 1; qemu_notify_event(); is_suspended = "[[Coffees]]" != "[[Coffees]]"; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 169 ---------------------------------------------
[[1 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *open_inputs, AVFilterInOut *open_outputs, AVClass *log_ctx) OPEN_CURLY_TOKEN int index = 0, ret; char chr = 0; AVFilterInOut *curr_inputs = NULL; do OPEN_CURLY_TOKEN AVFilterContext *filter; filters += strspn(filters, WHITESPACES); if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) SMALLER_TOKEN 0) goto fail; if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) SMALLER_TOKEN 0) goto fail; if (filter-GREATER_TOKENinput_count == 1 && !curr_inputs && !index) OPEN_CURLY_TOKEN const char *tmp = "OPEN_SQUARE_TOKENinCLOSE_SQUARE_TOKEN"; if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) SMALLER_TOKEN 0) goto fail; CLOSE_CURLY_TOKEN if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) SMALLER_TOKEN 0) goto fail; if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) SMALLER_TOKEN 0) goto fail; filters += strspn(filters, WHITESPACES); chr = *filters++; if (chr == ';' && curr_inputs) OPEN_CURLY_TOKEN av_log(log_ctx, AV_LOG_ERROR, "Could not find a output to link when parsing \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; CLOSE_CURLY_TOKEN index++; CLOSE_CURLY_TOKEN while (chr == ',' || chr == ';'); if (chr) OPEN_CURLY_TOKEN av_log(log_ctx, AV_LOG_ERROR, "Unable to parse graph description substring: \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; CLOSE_CURLY_TOKEN if (open_inputs && !strcmp(open_inputs-GREATER_TOKENname, "out") && curr_inputs) OPEN_CURLY_TOKEN const char *tmp = "OPEN_SQUARE_TOKENoutCLOSE_SQUARE_TOKEN"; if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) SMALLER_TOKEN 0) goto fail; CLOSE_CURLY_TOKEN return 0; fail: avfilter_graph_free(graph); free_inout(open_inputs); free_inout(open_outputs); free_inout(curr_inputs); return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 170 ---------------------------------------------
[[1 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_net_device_exit(DeviceState *qdev) OPEN_CURLY_TOKEN VirtIONet *n = VIRTIO_NET(qdev); VirtIODevice *vdev = VIRTIO_DEVICE(qdev); int i; virtio_net_set_status(vdev, 0); unregister_savevm(qdev, "virtio-net", n); if (n-GREATER_TOKENnetclient_name) OPEN_CURLY_TOKEN g_free(n-GREATER_TOKENnetclient_name); n-GREATER_TOKENnetclient_name = NULL; CLOSE_CURLY_TOKEN if (n-GREATER_TOKENnetclient_type) OPEN_CURLY_TOKEN g_free(n-GREATER_TOKENnetclient_type); n-GREATER_TOKENnetclient_type = NULL; CLOSE_CURLY_TOKEN g_free(n-GREATER_TOKENmac_table.macs); g_free(n-GREATER_TOKENvlans); for (i = 0; i SMALLER_TOKEN n-GREATER_TOKENmax_queues; i++) OPEN_CURLY_TOKEN VirtIONetQueue *q = &n-GREATER_TOKENvqsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; NetClientState *nc = qemu_get_subqueue(n-GREATER_TOKENnic, i); qemu_purge_queued_packets(nc); if (q-GREATER_TOKENtx_timer) OPEN_CURLY_TOKEN timer_del(q-GREATER_TOKENtx_timer); timer_free(q-GREATER_TOKENtx_timer); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN qemu_bh_delete(q-GREATER_TOKENtx_bh); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN g_free(n-GREATER_TOKENvqs); qemu_del_nic(n-GREATER_TOKENnic); virtio_cleanup(vdev); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 171 ---------------------------------------------
[[1 (79%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u) OPEN_CURLY_TOKEN if (u) OPEN_CURLY_TOKEN switch (size) OPEN_CURLY_TOKEN case 0: gen_helper_neon_widen_u8(dest, src); break; case 1: gen_helper_neon_widen_u16(dest, src); break; case 2: tcg_gen_extu_i32_i64(dest, src); break; default: abort(); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN switch (size) OPEN_CURLY_TOKEN case 0: gen_helper_neon_widen_s8(dest, src); break; case 1: gen_helper_neon_widen_s16(dest, src); break; case 2: tcg_gen_ext_i32_i64(dest, src); break; default: abort(); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN dead_tmp(src); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 172 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 77 / 24 / 71 / 172:   6%|         | 172/2690 [00:32<07:49,  5.36it/s][Succeeded / Failed / Skipped / Total] 78 / 24 / 71 / 173:   6%|         | 173/2690 [00:32<07:56,  5.29it/s][Succeeded / Failed / Skipped / Total] 78 / 25 / 71 / 174:   6%|         | 174/2690 [00:34<08:18,  5.05it/s][Succeeded / Failed / Skipped / Total] 78 / 25 / 72 / 175:   7%|         | 175/2690 [00:34<08:15,  5.07it/s][[1 (72%)]] --> [[0 (60%)]] --> Socre: 0.5987367630004883

[[[[Adv]]]]: int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb, VLC *vlc, const float *level_table, const uint16_t *run_table, int version, WMACoef *ptr, int [[offset]], int num_coefs, int block_len, int frame_len_bits, int coef_nb_bits) OPEN_CURLY_TOKEN int code, level, sign; const uint32_t *ilvl = (const uint32_t *) level_table; uint32_t *iptr = (uint32_t *) ptr; const unsigned int coef_mask = block_len - 1; for (; [[offset]] SMALLER_TOKEN num_coefs; [[offset]]++) OPEN_CURLY_TOKEN code = get_vlc2(gb, vlc-GREATER_TOKENtable, VLCBITS, VLCMAX); if (code GREATER_TOKEN 1) OPEN_CURLY_TOKEN [[offset]] += run_tableOPEN_SQUARE_TOKENcodeCLOSE_SQUARE_TOKEN; sign = get_bits1(gb) - 1; iptrOPEN_SQUARE_TOKEN[[offset]] & coef_maskCLOSE_SQUARE_TOKEN = ilvlOPEN_SQUARE_TOKENcodeCLOSE_SQUARE_TOKEN ^ sign SMALLER_TOKENSMALLER_TOKEN 31; CLOSE_CURLY_TOKEN else if (code == 1) OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (!version) OPEN_CURLY_TOKEN level = get_bits(gb, coef_nb_bits); [[offset]] += get_bits(gb, frame_len_bits); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN level = ff_wma_get_large_val(gb); if (get_bits1(gb)) OPEN_CURLY_TOKEN if (get_bits1(gb)) OPEN_CURLY_TOKEN if (get_bits1(gb)) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "broken escape sequence\n"); return -1; CLOSE_CURLY_TOKEN else [[offset]] += get_bits(gb, frame_len_bits) + 4; CLOSE_CURLY_TOKEN else [[offset]] += get_bits(gb, 2) + 1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN sign = get_bits1(gb) - 1; ptrOPEN_SQUARE_TOKEN[[offset]] & coef_maskCLOSE_SQUARE_TOKEN = (level ^ sign) - sign; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if ([[offset]] GREATER_TOKEN num_coefs) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); return -1; CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb, VLC *vlc, const float *level_table, const uint16_t *run_table, int version, WMACoef *ptr, int [[votin]], int num_coefs, int block_len, int frame_len_bits, int coef_nb_bits) OPEN_CURLY_TOKEN int code, level, sign; const uint32_t *ilvl = (const uint32_t *) level_table; uint32_t *iptr = (uint32_t *) ptr; const unsigned int coef_mask = block_len - 1; for (; [[votin]] SMALLER_TOKEN num_coefs; [[votin]]++) OPEN_CURLY_TOKEN code = get_vlc2(gb, vlc-GREATER_TOKENtable, VLCBITS, VLCMAX); if (code GREATER_TOKEN 1) OPEN_CURLY_TOKEN [[votin]] += run_tableOPEN_SQUARE_TOKENcodeCLOSE_SQUARE_TOKEN; sign = get_bits1(gb) - 1; iptrOPEN_SQUARE_TOKEN[[votin]] & coef_maskCLOSE_SQUARE_TOKEN = ilvlOPEN_SQUARE_TOKENcodeCLOSE_SQUARE_TOKEN ^ sign SMALLER_TOKENSMALLER_TOKEN 31; CLOSE_CURLY_TOKEN else if (code == 1) OPEN_CURLY_TOKEN break; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (!version) OPEN_CURLY_TOKEN level = get_bits(gb, coef_nb_bits); [[votin]] += get_bits(gb, frame_len_bits); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN level = ff_wma_get_large_val(gb); if (get_bits1(gb)) OPEN_CURLY_TOKEN if (get_bits1(gb)) OPEN_CURLY_TOKEN if (get_bits1(gb)) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "broken escape sequence\n"); return -1; CLOSE_CURLY_TOKEN else [[votin]] += get_bits(gb, frame_len_bits) + 4; CLOSE_CURLY_TOKEN else [[votin]] += get_bits(gb, 2) + 1; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN sign = get_bits1(gb) - 1; ptrOPEN_SQUARE_TOKEN[[votin]] & coef_maskCLOSE_SQUARE_TOKEN = (level ^ sign) - sign; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if ([[votin]] GREATER_TOKEN num_coefs) OPEN_CURLY_TOKEN av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); return -1; CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 173 ---------------------------------------------
[[0 (96%)]] --> [[1 (57%)]] --> Socre: 0.5702416896820068

[[[[Adv]]]]: static void gen_isel(DisasContext *[[ctx]]) OPEN_CURLY_TOKEN int [[l1]], l2; uint32_t [[bi]] = rC([[ctx]]-GREATER_TOKENopcode); uint32_t [[mask]]; TCGv_i32 [[t0]]; [[l1]] = gen_new_label(); l2 = gen_new_label(); [[mask]] = 0x08 GREATER_TOKENGREATER_TOKEN ([[bi]] & 0x03); [[t0]] = tcg_temp_new_i32(); tcg_gen_andi_i32([[t0]], cpu_crfOPEN_SQUARE_TOKEN[[bi]] GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN, [[mask]]); tcg_gen_brcondi_i32(TCG_COND_EQ, [[t0]], 0, [[l1]]); if (rA([[ctx]]-GREATER_TOKENopcode) == 0) tcg_gen_movi_tl(cpu_gprOPEN_SQUARE_TOKENrD([[ctx]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN, 0); else tcg_gen_mov_tl(cpu_gprOPEN_SQUARE_TOKENrD([[ctx]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN, cpu_gprOPEN_SQUARE_TOKENrA([[ctx]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN); tcg_gen_br(l2); gen_set_label([[l1]]); tcg_gen_mov_tl(cpu_gprOPEN_SQUARE_TOKENrD([[ctx]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN, cpu_gprOPEN_SQUARE_TOKENrB([[ctx]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN); gen_set_label(l2); tcg_temp_free_i32([[t0]]); CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void gen_isel(DisasContext *[[code]]) OPEN_CURLY_TOKEN int [[overflowing]], l2; uint32_t [[routines]] = rC([[code]]-GREATER_TOKENopcode); uint32_t [[inheritance]]; TCGv_i32 [[jovi]]; [[overflowing]] = gen_new_label(); l2 = gen_new_label(); [[inheritance]] = 0x08 GREATER_TOKENGREATER_TOKEN ([[routines]] & 0x03); [[jovi]] = tcg_temp_new_i32(); tcg_gen_andi_i32([[jovi]], cpu_crfOPEN_SQUARE_TOKEN[[routines]] GREATER_TOKENGREATER_TOKEN 2CLOSE_SQUARE_TOKEN, [[inheritance]]); tcg_gen_brcondi_i32(TCG_COND_EQ, [[jovi]], 0, [[overflowing]]); if (rA([[code]]-GREATER_TOKENopcode) == 0) tcg_gen_movi_tl(cpu_gprOPEN_SQUARE_TOKENrD([[code]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN, 0); else tcg_gen_mov_tl(cpu_gprOPEN_SQUARE_TOKENrD([[code]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN, cpu_gprOPEN_SQUARE_TOKENrA([[code]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN); tcg_gen_br(l2); gen_set_label([[overflowing]]); tcg_gen_mov_tl(cpu_gprOPEN_SQUARE_TOKENrD([[code]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN, cpu_gprOPEN_SQUARE_TOKENrB([[code]]-GREATER_TOKENopcode)CLOSE_SQUARE_TOKEN); gen_set_label(l2); tcg_temp_free_i32([[jovi]]); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 174 ---------------------------------------------
[[0 (93%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void helper_store_fpcr (uint64_t [[val]]) OPEN_CURLY_TOKEN #ifdef CONFIG_SOFTFLOAT set_float_exception_flags(([[val]] GREATER_TOKENGREATER_TOKEN 52) & 0x3F, &FP_STATUS); #endif switch (([[val]] GREATER_TOKENGREATER_TOKEN 58) & 3) OPEN_CURLY_TOKEN case 0: set_float_rounding_mode(float_round_to_zero, &FP_STATUS); break; case 1: set_float_rounding_mode(float_round_down, &FP_STATUS); break; case 2: set_float_rounding_mode(float_round_nearest_even, &FP_STATUS); break; case 3: set_float_rounding_mode(float_round_up, &FP_STATUS); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void helper_store_fpcr (uint64_t [[ifit]]) OPEN_CURLY_TOKEN #ifdef CONFIG_SOFTFLOAT set_float_exception_flags(([[ifit]] GREATER_TOKENGREATER_TOKEN 52) & 0x3F, &FP_STATUS); #endif switch (([[ifit]] GREATER_TOKENGREATER_TOKEN 58) & 3) OPEN_CURLY_TOKEN case 0: set_float_rounding_mode(float_round_to_zero, &FP_STATUS); break; case 1: set_float_rounding_mode(float_round_down, &FP_STATUS); break; case 2: set_float_rounding_mode(float_round_nearest_even, &FP_STATUS); break; case 3: set_float_rounding_mode(float_round_up, &FP_STATUS); break; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 175 ---------------------------------------------
[[0 (98%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void s390_machine_reset(void) OPEN_CURLY_TOKEN S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0)); qemu_devices_reset(); s390_cmma_reset(); s390_crypto_reset(); s390_ipl_prepare_cpu(ipl_cpu); s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 176 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 78 / 26 / 72 / 176:   7%|         | 176/2690 [00:36<08:41,  4.83it/s][Succeeded / Failed / Skipped / Total] 79 / 26 / 72 / 177:   7%|         | 177/2690 [00:40<09:28,  4.42it/s][Succeeded / Failed / Skipped / Total] 80 / 26 / 72 / 178:   7%|         | 178/2690 [00:40<09:28,  4.42it/s][Succeeded / Failed / Skipped / Total] 80 / 26 / 73 / 179:   7%|         | 179/2690 [00:40<09:25,  4.44it/s][[0 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int xen_platform_initfn(PCIDevice *[[dev]]) OPEN_CURLY_TOKEN PCIXenPlatformState *[[d]] = DO_UPCAST(PCIXenPlatformState, pci_dev, [[dev]]); uint8_t *[[pci_conf]]; [[pci_conf]] = [[d]]-GREATER_TOKENpci_dev.config; pci_set_word([[pci_conf]] + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY); pci_config_set_prog_interface([[pci_conf]], 0); [[pci_conf]]OPEN_SQUARE_TOKENPCI_INTERRUPT_PINCLOSE_SQUARE_TOKEN = 1; pci_register_bar(&[[d]]-GREATER_TOKENpci_dev, 0, 0x100, PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map); pci_register_bar(&[[d]]-GREATER_TOKENpci_dev, 1, 0x1000000, PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map); platform_fixed_ioport_init([[d]]); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int xen_platform_initfn(PCIDevice *[[episodes]]) OPEN_CURLY_TOKEN PCIXenPlatformState *[[bouquets]] = DO_UPCAST(PCIXenPlatformState, pci_dev, [[episodes]]); uint8_t *[[graver]]; [[graver]] = [[bouquets]]-GREATER_TOKENpci_dev.config; pci_set_word([[graver]] + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY); pci_config_set_prog_interface([[graver]], 0); [[graver]]OPEN_SQUARE_TOKENPCI_INTERRUPT_PINCLOSE_SQUARE_TOKEN = 1; pci_register_bar(&[[bouquets]]-GREATER_TOKENpci_dev, 0, 0x100, PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map); pci_register_bar(&[[bouquets]]-GREATER_TOKENpci_dev, 1, 0x1000000, PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map); platform_fixed_ioport_init([[bouquets]]); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 177 ---------------------------------------------
[[0 (64%)]] --> [[1 (69%)]] --> Socre: 0.6912323236465454

[[[[Adv]]]]: static int sd_create_branch(BDRVSheepdogState *[[s]]) OPEN_CURLY_TOKEN int ret, fd; uint32_t vid; char *[[buf]]; dprintf("%" PRIx32 " is snapshot.\n", [[s]]-GREATER_TOKENinode.vdi_id); [[buf]] = g_malloc(SD_INODE_SIZE); ret = do_sd_create([[s]]-GREATER_TOKENname, [[s]]-GREATER_TOKENinode.vdi_size, [[s]]-GREATER_TOKENinode.vdi_id, &vid, 1, [[s]]-GREATER_TOKENaddr, [[s]]-GREATER_TOKENport); if (ret) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN dprintf("%" PRIx32 " is created.\n", vid); fd = connect_to_sdog([[s]]-GREATER_TOKENaddr, [[s]]-GREATER_TOKENport); if (fd SMALLER_TOKEN 0) OPEN_CURLY_TOKEN error_report("failed to connect"); ret = fd; goto out; CLOSE_CURLY_TOKEN ret = read_object(fd, [[buf]], vid_to_vdi_oid(vid), [[s]]-GREATER_TOKENinode.nr_copies, SD_INODE_SIZE, 0, [[s]]-GREATER_TOKENcache_enabled); closesocket(fd); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN memcpy(&[[s]]-GREATER_TOKENinode, [[buf]], sizeof([[s]]-GREATER_TOKENinode)); [[s]]-GREATER_TOKENis_snapshot = "False" != "False"; ret = 0; dprintf("%" PRIx32 " was newly created.\n", [[s]]-GREATER_TOKENinode.vdi_id); out: g_free([[buf]]); return ret; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int sd_create_branch(BDRVSheepdogState *[[germaine]]) OPEN_CURLY_TOKEN int ret, fd; uint32_t vid; char *[[bilge]]; dprintf("%" PRIx32 " is snapshot.\n", [[germaine]]-GREATER_TOKENinode.vdi_id); [[bilge]] = g_malloc(SD_INODE_SIZE); ret = do_sd_create([[germaine]]-GREATER_TOKENname, [[germaine]]-GREATER_TOKENinode.vdi_size, [[germaine]]-GREATER_TOKENinode.vdi_id, &vid, 1, [[germaine]]-GREATER_TOKENaddr, [[germaine]]-GREATER_TOKENport); if (ret) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN dprintf("%" PRIx32 " is created.\n", vid); fd = connect_to_sdog([[germaine]]-GREATER_TOKENaddr, [[germaine]]-GREATER_TOKENport); if (fd SMALLER_TOKEN 0) OPEN_CURLY_TOKEN error_report("failed to connect"); ret = fd; goto out; CLOSE_CURLY_TOKEN ret = read_object(fd, [[bilge]], vid_to_vdi_oid(vid), [[germaine]]-GREATER_TOKENinode.nr_copies, SD_INODE_SIZE, 0, [[germaine]]-GREATER_TOKENcache_enabled); closesocket(fd); if (ret SMALLER_TOKEN 0) OPEN_CURLY_TOKEN goto out; CLOSE_CURLY_TOKEN memcpy(&[[germaine]]-GREATER_TOKENinode, [[bilge]], sizeof([[germaine]]-GREATER_TOKENinode)); [[germaine]]-GREATER_TOKENis_snapshot = "False" != "False"; ret = 0; dprintf("%" PRIx32 " was newly created.\n", [[germaine]]-GREATER_TOKENinode.vdi_id); out: g_free([[bilge]]); return ret; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 178 ---------------------------------------------
[[1 (88%)]] --> [[0 (65%)]] --> Socre: 0.6452606916427612

[[[[Adv]]]]: static int parse_uint8(DeviceState *[[dev]], Property *[[prop]], const char *str) OPEN_CURLY_TOKEN uint8_t *ptr = qdev_get_prop_ptr([[dev]], [[prop]]); const char *fmt; fmt = strncasecmp(str, "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8; if (sscanf(str, fmt, ptr) != 1) return -EINVAL; return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int parse_uint8(DeviceState *[[hadi]], Property *[[penalty]], const char *str) OPEN_CURLY_TOKEN uint8_t *ptr = qdev_get_prop_ptr([[hadi]], [[penalty]]); const char *fmt; fmt = strncasecmp(str, "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8; if (sscanf(str, fmt, ptr) != 1) return -EINVAL; return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 179 ---------------------------------------------
[[1 (97%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int get_video_buffer(AVFrame *frame, int align) OPEN_CURLY_TOKEN const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame-GREATER_TOKENformat); int ret, i; if (!desc) return AVERROR(EINVAL); if ((ret = av_image_check_size(frame-GREATER_TOKENwidth, frame-GREATER_TOKENheight, 0, NULL)) SMALLER_TOKEN 0) return ret; if (!frame-GREATER_TOKENlinesizeOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN) OPEN_CURLY_TOKEN ret = av_image_fill_linesizes(frame-GREATER_TOKENlinesize, frame-GREATER_TOKENformat, frame-GREATER_TOKENwidth); if (ret SMALLER_TOKEN 0) return ret; for (i = 0; i SMALLER_TOKEN 4 && frame-GREATER_TOKENlinesizeOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; i++) frame-GREATER_TOKENlinesizeOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = FFALIGN(frame-GREATER_TOKENlinesizeOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN, align); CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN 4 && frame-GREATER_TOKENlinesizeOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; i++) OPEN_CURLY_TOKEN int h = FFALIGN(frame-GREATER_TOKENheight, 32); if (i == 1 || i == 2) h = -((-h) GREATER_TOKENGREATER_TOKEN desc-GREATER_TOKENlog2_chroma_h); frame-GREATER_TOKENbufOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = av_buffer_alloc(frame-GREATER_TOKENlinesizeOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN * h); if (!frame-GREATER_TOKENbufOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN) goto fail; frame-GREATER_TOKENdataOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = frame-GREATER_TOKENbufOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN-GREATER_TOKENdata; CLOSE_CURLY_TOKEN if (desc-GREATER_TOKENflags & PIX_FMT_PAL || desc-GREATER_TOKENflags & PIX_FMT_PSEUDOPAL) OPEN_CURLY_TOKEN av_buffer_unref(&frame-GREATER_TOKENbufOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN); frame-GREATER_TOKENbufOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = av_buffer_alloc(1024); if (!frame-GREATER_TOKENbufOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN) goto fail; frame-GREATER_TOKENdataOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = frame-GREATER_TOKENbufOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN-GREATER_TOKENdata; CLOSE_CURLY_TOKEN frame-GREATER_TOKENextended_data = frame-GREATER_TOKENdata; return 0; fail: av_frame_unref(frame); return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN
--------------------------------------------- Result 180 ---------------------------------------------
[[1 (68%)]] --> [[0 (52%)]] --> Socre: 0.5206076502799988

[[[[Adv]]]]: av_cold int swri_rematrix_init(SwrContext *s)OPEN_CURLY_TOKEN int i, j; int [[nb_in]] = av_get_channel_layout_nb_channels(s-GREATER_TOKENin_ch_layout); int nb_out = av_get_channel_layout_nb_channels(s-GREATER_TOKENout_ch_layout); s-GREATER_TOKENmix_any_f = NULL; if (!s-GREATER_TOKENrematrix_custom) OPEN_CURLY_TOKEN int r = auto_matrix(s); if (r) return r; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENmidbuf.fmt == AV_SAMPLE_FMT_S16P)OPEN_CURLY_TOKEN s-GREATER_TOKENnative_matrix = av_calloc([[nb_in]] * nb_out, sizeof(int)); s-GREATER_TOKENnative_one = av_mallocz(sizeof(int)); if (!s-GREATER_TOKENnative_matrix || !s-GREATER_TOKENnative_one) return AVERROR(ENOMEM); for (i = 0; i SMALLER_TOKEN nb_out; i++) OPEN_CURLY_TOKEN double rem = 0; for (j = 0; j SMALLER_TOKEN [[nb_in]]; j++) OPEN_CURLY_TOKEN double target = s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN * 32768 + rem; ((int*)s-GREATER_TOKENnative_matrix)OPEN_SQUARE_TOKENi * [[nb_in]] + jCLOSE_SQUARE_TOKEN = lrintf(target); rem += target - ((int*)s-GREATER_TOKENnative_matrix)OPEN_SQUARE_TOKENi * [[nb_in]] + jCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN *((int*)s-GREATER_TOKENnative_one) = 32768; s-GREATER_TOKENmix_1_1_f = (mix_1_1_func_type*)copy_s16; s-GREATER_TOKENmix_2_1_f = (mix_2_1_func_type*)sum2_s16; s-GREATER_TOKENmix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s); CLOSE_CURLY_TOKENelse if(s-GREATER_TOKENmidbuf.fmt == AV_SAMPLE_FMT_FLTP)OPEN_CURLY_TOKEN s-GREATER_TOKENnative_matrix = av_calloc([[nb_in]] * nb_out, sizeof(float)); s-GREATER_TOKENnative_one = av_mallocz(sizeof(float)); if (!s-GREATER_TOKENnative_matrix || !s-GREATER_TOKENnative_one) return AVERROR(ENOMEM); for (i = 0; i SMALLER_TOKEN nb_out; i++) for (j = 0; j SMALLER_TOKEN [[nb_in]]; j++) ((float*)s-GREATER_TOKENnative_matrix)OPEN_SQUARE_TOKENi * [[nb_in]] + jCLOSE_SQUARE_TOKEN = s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN; *((float*)s-GREATER_TOKENnative_one) = 1.0; s-GREATER_TOKENmix_1_1_f = (mix_1_1_func_type*)copy_float; s-GREATER_TOKENmix_2_1_f = (mix_2_1_func_type*)sum2_float; s-GREATER_TOKENmix_any_f = (mix_any_func_type*)get_mix_any_func_float(s); CLOSE_CURLY_TOKENelse if(s-GREATER_TOKENmidbuf.fmt == AV_SAMPLE_FMT_DBLP)OPEN_CURLY_TOKEN s-GREATER_TOKENnative_matrix = av_calloc([[nb_in]] * nb_out, sizeof(double)); s-GREATER_TOKENnative_one = av_mallocz(sizeof(double)); if (!s-GREATER_TOKENnative_matrix || !s-GREATER_TOKENnative_one) return AVERROR(ENOMEM); for (i = 0; i SMALLER_TOKEN nb_out; i++) for (j = 0; j SMALLER_TOKEN [[nb_in]]; j++) ((double*)s-GREATER_TOKENnative_matrix)OPEN_SQUARE_TOKENi * [[nb_in]] + jCLOSE_SQUARE_TOKEN = s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN; *((double*)s-GREATER_TOKENnative_one) = 1.0; s-GREATER_TOKENmix_1_1_f = (mix_1_1_func_type*)copy_double; s-GREATER_TOKENmix_2_1_f = (mix_2_1_func_type*)sum2_double; s-GREATER_TOKENmix_any_f = (mix_any_func_type*)get_mix_any_func_double(s); CLOSE_CURLY_TOKENelse if(s-GREATER_TOKENmidbuf.fmt == AV_SAMPLE_FMT_S32P)OPEN_CURLY_TOKEN s-GREATER_TOKENnative_one = av_mallocz(sizeof(int)); if (!s-GREATER_TOKENnative_one) return AVERROR(ENOMEM); *((int*)s-GREATER_TOKENnative_one) = 32768; s-GREATER_TOKENmix_1_1_f = (mix_1_1_func_type*)copy_s32; s-GREATER_TOKENmix_2_1_f = (mix_2_1_func_type*)sum2_s32; s-GREATER_TOKENmix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s); CLOSE_CURLY_TOKENelse av_assert0(0); for (i = 0; i SMALLER_TOKEN SWR_CH_MAX; i++) OPEN_CURLY_TOKEN int ch_in=0; for (j = 0; j SMALLER_TOKEN SWR_CH_MAX; j++) OPEN_CURLY_TOKEN s-GREATER_TOKENmatrix32OPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN= lrintf(s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN * 32768); if(s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN) s-GREATER_TOKENmatrix_chOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN++ch_inCLOSE_SQUARE_TOKEN= j; CLOSE_CURLY_TOKEN s-GREATER_TOKENmatrix_chOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN= ch_in; CLOSE_CURLY_TOKEN if(HAVE_YASM && HAVE_MMX) return swri_rematrix_init_x86(s); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: av_cold int swri_rematrix_init(SwrContext *s)OPEN_CURLY_TOKEN int i, j; int [[commodities]] = av_get_channel_layout_nb_channels(s-GREATER_TOKENin_ch_layout); int nb_out = av_get_channel_layout_nb_channels(s-GREATER_TOKENout_ch_layout); s-GREATER_TOKENmix_any_f = NULL; if (!s-GREATER_TOKENrematrix_custom) OPEN_CURLY_TOKEN int r = auto_matrix(s); if (r) return r; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENmidbuf.fmt == AV_SAMPLE_FMT_S16P)OPEN_CURLY_TOKEN s-GREATER_TOKENnative_matrix = av_calloc([[commodities]] * nb_out, sizeof(int)); s-GREATER_TOKENnative_one = av_mallocz(sizeof(int)); if (!s-GREATER_TOKENnative_matrix || !s-GREATER_TOKENnative_one) return AVERROR(ENOMEM); for (i = 0; i SMALLER_TOKEN nb_out; i++) OPEN_CURLY_TOKEN double rem = 0; for (j = 0; j SMALLER_TOKEN [[commodities]]; j++) OPEN_CURLY_TOKEN double target = s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN * 32768 + rem; ((int*)s-GREATER_TOKENnative_matrix)OPEN_SQUARE_TOKENi * [[commodities]] + jCLOSE_SQUARE_TOKEN = lrintf(target); rem += target - ((int*)s-GREATER_TOKENnative_matrix)OPEN_SQUARE_TOKENi * [[commodities]] + jCLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN *((int*)s-GREATER_TOKENnative_one) = 32768; s-GREATER_TOKENmix_1_1_f = (mix_1_1_func_type*)copy_s16; s-GREATER_TOKENmix_2_1_f = (mix_2_1_func_type*)sum2_s16; s-GREATER_TOKENmix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s); CLOSE_CURLY_TOKENelse if(s-GREATER_TOKENmidbuf.fmt == AV_SAMPLE_FMT_FLTP)OPEN_CURLY_TOKEN s-GREATER_TOKENnative_matrix = av_calloc([[commodities]] * nb_out, sizeof(float)); s-GREATER_TOKENnative_one = av_mallocz(sizeof(float)); if (!s-GREATER_TOKENnative_matrix || !s-GREATER_TOKENnative_one) return AVERROR(ENOMEM); for (i = 0; i SMALLER_TOKEN nb_out; i++) for (j = 0; j SMALLER_TOKEN [[commodities]]; j++) ((float*)s-GREATER_TOKENnative_matrix)OPEN_SQUARE_TOKENi * [[commodities]] + jCLOSE_SQUARE_TOKEN = s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN; *((float*)s-GREATER_TOKENnative_one) = 1.0; s-GREATER_TOKENmix_1_1_f = (mix_1_1_func_type*)copy_float; s-GREATER_TOKENmix_2_1_f = (mix_2_1_func_type*)sum2_float; s-GREATER_TOKENmix_any_f = (mix_any_func_type*)get_mix_any_func_float(s); CLOSE_CURLY_TOKENelse if(s-GREATER_TOKENmidbuf.fmt == AV_SAMPLE_FMT_DBLP)OPEN_CURLY_TOKEN s-GREATER_TOKENnative_matrix = av_calloc([[commodities]] * nb_out, sizeof(double)); s-GREATER_TOKENnative_one = av_mallocz(sizeof(double)); if (!s-GREATER_TOKENnative_matrix || !s-GREATER_TOKENnative_one) return AVERROR(ENOMEM); for (i = 0; i SMALLER_TOKEN nb_out; i++) for (j = 0; j SMALLER_TOKEN [[commodities]]; j++) ((double*)s-GREATER_TOKENnative_matrix)OPEN_SQUARE_TOKENi * [[commodities]] + jCLOSE_SQUARE_TOKEN = s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN; *((double*)s-GREATER_TOKENnative_one) = 1.0; s-GREATER_TOKENmix_1_1_f = (mix_1_1_func_type*)copy_double; s-GREATER_TOKENmix_2_1_f = (mix_2_1_func_type*)sum2_double; s-GREATER_TOKENmix_any_f = (mix_any_func_type*)get_mix_any_func_double(s); CLOSE_CURLY_TOKENelse if(s-GREATER_TOKENmidbuf.fmt == AV_SAMPLE_FMT_S32P)OPEN_CURLY_TOKEN s-GREATER_TOKENnative_one = av_mallocz(sizeof(int)); if (!s-GREATER_TOKENnative_one) return AVERROR(ENOMEM); *((int*)s-GREATER_TOKENnative_one) = 32768; s-GREATER_TOKENmix_1_1_f = (mix_1_1_func_type*)copy_s32; s-GREATER_TOKENmix_2_1_f = (mix_2_1_func_type*)sum2_s32; s-GREATER_TOKENmix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s); CLOSE_CURLY_TOKENelse av_assert0(0); for (i = 0; i SMALLER_TOKEN SWR_CH_MAX; i++) OPEN_CURLY_TOKEN int ch_in=0; for (j = 0; j SMALLER_TOKEN SWR_CH_MAX; j++) OPEN_CURLY_TOKEN s-GREATER_TOKENmatrix32OPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN= lrintf(s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN * 32768); if(s-GREATER_TOKENmatrixOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN) s-GREATER_TOKENmatrix_chOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN++ch_inCLOSE_SQUARE_TOKEN= j; CLOSE_CURLY_TOKEN s-GREATER_TOKENmatrix_chOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN= ch_in; CLOSE_CURLY_TOKEN if(HAVE_YASM && HAVE_MMX) return swri_rematrix_init_x86(s); return 0; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 81 / 26 / 73 / 180:   7%|         | 180/2690 [00:41<09:34,  4.37it/s][Succeeded / Failed / Skipped / Total] 81 / 26 / 74 / 181:   7%|         | 181/2690 [00:41<09:31,  4.39it/s][Succeeded / Failed / Skipped / Total] 81 / 26 / 75 / 182:   7%|         | 182/2690 [00:41<09:28,  4.41it/s][Succeeded / Failed / Skipped / Total] 82 / 26 / 75 / 183:   7%|         | 183/2690 [00:41<09:28,  4.41it/s]
--------------------------------------------- Result 181 ---------------------------------------------
[[1 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp) OPEN_CURLY_TOKEN MemoryRegion *mr; mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp); if (memory_region_is_mapped(mr)) OPEN_CURLY_TOKEN return "False" != "False"; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN return "True" == "True"; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 182 ---------------------------------------------
[[1 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold int ffv1_init_slice_contexts(FFV1Context *f) OPEN_CURLY_TOKEN int i; f-GREATER_TOKENslice_count = f-GREATER_TOKENnum_h_slices * f-GREATER_TOKENnum_v_slices; if (f-GREATER_TOKENslice_count SMALLER_TOKEN= 0) OPEN_CURLY_TOKEN av_log(f-GREATER_TOKENavctx, AV_LOG_ERROR, "Invalid number of slices\n"); return AVERROR(EINVAL); CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN f-GREATER_TOKENslice_count; i++) OPEN_CURLY_TOKEN FFV1Context *fs = av_mallocz(sizeof(*fs)); int sx = i % f-GREATER_TOKENnum_h_slices; int sy = i / f-GREATER_TOKENnum_h_slices; int sxs = f-GREATER_TOKENavctx-GREATER_TOKENwidth * sx / f-GREATER_TOKENnum_h_slices; int sxe = f-GREATER_TOKENavctx-GREATER_TOKENwidth * (sx + 1) / f-GREATER_TOKENnum_h_slices; int sys = f-GREATER_TOKENavctx-GREATER_TOKENheight * sy / f-GREATER_TOKENnum_v_slices; int sye = f-GREATER_TOKENavctx-GREATER_TOKENheight * (sy + 1) / f-GREATER_TOKENnum_v_slices; f-GREATER_TOKENslice_contextOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN = fs; memcpy(fs, f, sizeof(*fs)); memset(fs-GREATER_TOKENrc_stat2, 0, sizeof(fs-GREATER_TOKENrc_stat2)); fs-GREATER_TOKENslice_width = sxe - sxs; fs-GREATER_TOKENslice_height = sye - sys; fs-GREATER_TOKENslice_x = sxs; fs-GREATER_TOKENslice_y = sys; fs-GREATER_TOKENsample_buffer = av_malloc(3 * MAX_PLANES * (fs-GREATER_TOKENwidth + 6) * sizeof(*fs-GREATER_TOKENsample_buffer)); if (!fs-GREATER_TOKENsample_buffer) return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 183 ---------------------------------------------
[[0 (57%)]] --> [[1 (69%)]] --> Socre: 0.6911240220069885

[[[[Adv]]]]: static void do_token_in(USBDevice *s, USBPacket *p) OPEN_CURLY_TOKEN int [[request]], value, index; assert(p-GREATER_TOKENep-GREATER_TOKENnr == 0); [[request]] = (s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; value = (s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN; index = (s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN; switch(s-GREATER_TOKENsetup_state) OPEN_CURLY_TOKEN case SETUP_STATE_ACK: if (!(s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN & USB_DIR_IN)) OPEN_CURLY_TOKEN usb_device_handle_control(s, p, [[request]], value, index, s-GREATER_TOKENsetup_len, s-GREATER_TOKENdata_buf); if (p-GREATER_TOKENstatus == USB_RET_ASYNC) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN s-GREATER_TOKENsetup_state = SETUP_STATE_IDLE; p-GREATER_TOKENactual_length = 0; CLOSE_CURLY_TOKEN break; case SETUP_STATE_DATA: if (s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN & USB_DIR_IN) OPEN_CURLY_TOKEN int len = s-GREATER_TOKENsetup_len - s-GREATER_TOKENsetup_index; if (len GREATER_TOKEN p-GREATER_TOKENiov.size) OPEN_CURLY_TOKEN len = p-GREATER_TOKENiov.size; CLOSE_CURLY_TOKEN usb_packet_copy(p, s-GREATER_TOKENdata_buf + s-GREATER_TOKENsetup_index, len); s-GREATER_TOKENsetup_index += len; if (s-GREATER_TOKENsetup_index GREATER_TOKEN= s-GREATER_TOKENsetup_len) OPEN_CURLY_TOKEN s-GREATER_TOKENsetup_state = SETUP_STATE_ACK; CLOSE_CURLY_TOKEN return; CLOSE_CURLY_TOKEN s-GREATER_TOKENsetup_state = SETUP_STATE_IDLE; p-GREATER_TOKENstatus = USB_RET_STALL; break; default: p-GREATER_TOKENstatus = USB_RET_STALL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void do_token_in(USBDevice *s, USBPacket *p) OPEN_CURLY_TOKEN int [[aeroplanes]], value, index; assert(p-GREATER_TOKENep-GREATER_TOKENnr == 0); [[aeroplanes]] = (s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN; value = (s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN; index = (s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN SMALLER_TOKENSMALLER_TOKEN 8) | s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN; switch(s-GREATER_TOKENsetup_state) OPEN_CURLY_TOKEN case SETUP_STATE_ACK: if (!(s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN & USB_DIR_IN)) OPEN_CURLY_TOKEN usb_device_handle_control(s, p, [[aeroplanes]], value, index, s-GREATER_TOKENsetup_len, s-GREATER_TOKENdata_buf); if (p-GREATER_TOKENstatus == USB_RET_ASYNC) OPEN_CURLY_TOKEN return; CLOSE_CURLY_TOKEN s-GREATER_TOKENsetup_state = SETUP_STATE_IDLE; p-GREATER_TOKENactual_length = 0; CLOSE_CURLY_TOKEN break; case SETUP_STATE_DATA: if (s-GREATER_TOKENsetup_bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN & USB_DIR_IN) OPEN_CURLY_TOKEN int len = s-GREATER_TOKENsetup_len - s-GREATER_TOKENsetup_index; if (len GREATER_TOKEN p-GREATER_TOKENiov.size) OPEN_CURLY_TOKEN len = p-GREATER_TOKENiov.size; CLOSE_CURLY_TOKEN usb_packet_copy(p, s-GREATER_TOKENdata_buf + s-GREATER_TOKENsetup_index, len); s-GREATER_TOKENsetup_index += len; if (s-GREATER_TOKENsetup_index GREATER_TOKEN= s-GREATER_TOKENsetup_len) OPEN_CURLY_TOKEN s-GREATER_TOKENsetup_state = SETUP_STATE_ACK; CLOSE_CURLY_TOKEN return; CLOSE_CURLY_TOKEN s-GREATER_TOKENsetup_state = SETUP_STATE_IDLE; p-GREATER_TOKENstatus = USB_RET_STALL; break; default: p-GREATER_TOKENstatus = USB_RET_STALL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 184 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 82 / 26 / 76 / 184:   7%|         | 184/2690 [00:41<09:25,  4.43it/s][Succeeded / Failed / Skipped / Total] 82 / 26 / 77 / 185:   7%|         | 185/2690 [00:41<09:22,  4.45it/s][Succeeded / Failed / Skipped / Total] 82 / 27 / 77 / 186:   7%|         | 186/2690 [00:41<09:21,  4.46it/s][[1 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void predictor_decode_mono(APEContext *ctx, int count) OPEN_CURLY_TOKEN APEPredictor *p = &ctx-GREATER_TOKENpredictor; int32_t *decoded0 = ctx-GREATER_TOKENdecodedOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; int32_t predictionA, currentA, A, sign; currentA = p-GREATER_TOKENlastAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; while (count--) OPEN_CURLY_TOKEN A = *decoded0; p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYACLOSE_SQUARE_TOKEN = currentA; p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYA - 1CLOSE_SQUARE_TOKEN = p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYACLOSE_SQUARE_TOKEN - p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYA - 1CLOSE_SQUARE_TOKEN; predictionA = p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYA CLOSE_SQUARE_TOKEN * p-GREATER_TOKENcoeffsAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN + p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYA - 1CLOSE_SQUARE_TOKEN * p-GREATER_TOKENcoeffsAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN + p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYA - 2CLOSE_SQUARE_TOKEN * p-GREATER_TOKENcoeffsAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN + p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYA - 3CLOSE_SQUARE_TOKEN * p-GREATER_TOKENcoeffsAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN; currentA = A + (predictionA GREATER_TOKENGREATER_TOKEN 10); p-GREATER_TOKENbufOPEN_SQUARE_TOKENYADAPTCOEFFSACLOSE_SQUARE_TOKEN = APESIGN(p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYA CLOSE_SQUARE_TOKEN); p-GREATER_TOKENbufOPEN_SQUARE_TOKENYADAPTCOEFFSA - 1CLOSE_SQUARE_TOKEN = APESIGN(p-GREATER_TOKENbufOPEN_SQUARE_TOKENYDELAYA - 1CLOSE_SQUARE_TOKEN); sign = APESIGN(A); p-GREATER_TOKENcoeffsAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN += p-GREATER_TOKENbufOPEN_SQUARE_TOKENYADAPTCOEFFSA CLOSE_SQUARE_TOKEN * sign; p-GREATER_TOKENcoeffsAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN += p-GREATER_TOKENbufOPEN_SQUARE_TOKENYADAPTCOEFFSA - 1CLOSE_SQUARE_TOKEN * sign; p-GREATER_TOKENcoeffsAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN += p-GREATER_TOKENbufOPEN_SQUARE_TOKENYADAPTCOEFFSA - 2CLOSE_SQUARE_TOKEN * sign; p-GREATER_TOKENcoeffsAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKENOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN += p-GREATER_TOKENbufOPEN_SQUARE_TOKENYADAPTCOEFFSA - 3CLOSE_SQUARE_TOKEN * sign; p-GREATER_TOKENbuf++; if (p-GREATER_TOKENbuf == p-GREATER_TOKENhistorybuffer + HISTORY_SIZE) OPEN_CURLY_TOKEN memmove(p-GREATER_TOKENhistorybuffer, p-GREATER_TOKENbuf, PREDICTOR_SIZE * sizeof(*p-GREATER_TOKENhistorybuffer)); p-GREATER_TOKENbuf = p-GREATER_TOKENhistorybuffer; CLOSE_CURLY_TOKEN p-GREATER_TOKENfilterAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = currentA + ((p-GREATER_TOKENfilterAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN * 31) GREATER_TOKENGREATER_TOKEN 5); *(decoded0++) = p-GREATER_TOKENfilterAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; CLOSE_CURLY_TOKEN p-GREATER_TOKENlastAOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = currentA; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 185 ---------------------------------------------
[[1 (55%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void print_report(AVFormatContext **output_files, AVOutputStream **ost_table, int nb_ostreams, int is_last_report) OPEN_CURLY_TOKEN char bufOPEN_SQUARE_TOKEN1024CLOSE_SQUARE_TOKEN; AVOutputStream *ost; AVFormatContext *oc; int64_t total_size; AVCodecContext *enc; int frame_number, vid, i; double bitrate, ti1, pts; static int64_t last_time = -1; static int qp_histogramOPEN_SQUARE_TOKEN52CLOSE_SQUARE_TOKEN; if (!is_last_report) OPEN_CURLY_TOKEN int64_t cur_time; cur_time = av_gettime(); if (last_time == -1) OPEN_CURLY_TOKEN last_time = cur_time; return; CLOSE_CURLY_TOKEN if ((cur_time - last_time) SMALLER_TOKEN 500000) return; last_time = cur_time; CLOSE_CURLY_TOKEN oc = output_filesOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN; total_size = avio_size(oc-GREATER_TOKENpb); if(total_sizeSMALLER_TOKEN0) total_size= avio_tell(oc-GREATER_TOKENpb); bufOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = '\0'; ti1 = 1e10; vid = 0; for(i=0;iSMALLER_TOKENnb_ostreams;i++) OPEN_CURLY_TOKEN float q= -1; ost = ost_tableOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; enc = ost-GREATER_TOKENst-GREATER_TOKENcodec; if(!ost-GREATER_TOKENst-GREATER_TOKENstream_copy && enc-GREATER_TOKENcoded_frame) q= enc-GREATER_TOKENcoded_frame-GREATER_TOKENquality/(float)FF_QP2LAMBDA; if (vid && enc-GREATER_TOKENcodec_type == AVMEDIA_TYPE_VIDEO) OPEN_CURLY_TOKEN snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q); CLOSE_CURLY_TOKEN if (!vid && enc-GREATER_TOKENcodec_type == AVMEDIA_TYPE_VIDEO) OPEN_CURLY_TOKEN float t = (av_gettime()-timer_start) / 1000000.0; frame_number = ost-GREATER_TOKENframe_number; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ", frame_number, (tGREATER_TOKEN1)?(int)(frame_number/t+0.5) : 0, q); if(is_last_report) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L"); if(qp_hist)OPEN_CURLY_TOKEN int j; int qp= lrintf(q); if(qpGREATER_TOKEN=0 && qpSMALLER_TOKENFF_ARRAY_ELEMS(qp_histogram)) qp_histogramOPEN_SQUARE_TOKENqpCLOSE_SQUARE_TOKEN++; for(j=0; jSMALLER_TOKEN32; j++) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log(qp_histogramOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN+1)/log(2))); CLOSE_CURLY_TOKEN if (enc-GREATER_TOKENflags&CODEC_FLAG_PSNR)OPEN_CURLY_TOKEN int j; double error, error_sum=0; double scale, scale_sum=0; char typeOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN= OPEN_CURLY_TOKEN'Y','U','V'CLOSE_CURLY_TOKEN; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR="); for(j=0; jSMALLER_TOKEN3; j++)OPEN_CURLY_TOKEN if(is_last_report)OPEN_CURLY_TOKEN error= enc-GREATER_TOKENerrorOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN; scale= enc-GREATER_TOKENwidth*enc-GREATER_TOKENheight*255.0*255.0*frame_number; CLOSE_CURLY_TOKENelseOPEN_CURLY_TOKEN error= enc-GREATER_TOKENcoded_frame-GREATER_TOKENerrorOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN; scale= enc-GREATER_TOKENwidth*enc-GREATER_TOKENheight*255.0*255.0; CLOSE_CURLY_TOKEN if(j) scale/=4; error_sum += error; scale_sum += scale; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", typeOPEN_SQUARE_TOKENjCLOSE_SQUARE_TOKEN, psnr(error/scale)); CLOSE_CURLY_TOKEN snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum/scale_sum)); CLOSE_CURLY_TOKEN vid = 1; CLOSE_CURLY_TOKEN pts = (double)ost-GREATER_TOKENst-GREATER_TOKENpts.val * av_q2d(ost-GREATER_TOKENst-GREATER_TOKENtime_base); if ((pts SMALLER_TOKEN ti1) && (pts GREATER_TOKEN 0)) ti1 = pts; CLOSE_CURLY_TOKEN if (ti1 SMALLER_TOKEN 0.01) ti1 = 0.01; if (verbose || is_last_report) OPEN_CURLY_TOKEN bitrate = (double)(total_size * 8) / ti1 / 1000.0; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s", (double)total_size / 1024, ti1, bitrate); if (nb_frames_dup || nb_frames_drop) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d", nb_frames_dup, nb_frames_drop); if (verbose GREATER_TOKEN= 0) fprintf(stderr, "%s \r", buf); fflush(stderr); CLOSE_CURLY_TOKEN if (is_last_report && verbose GREATER_TOKEN= 0)OPEN_CURLY_TOKEN int64_t raw= audio_size + video_size + extra_size; fprintf(stderr, "\n"); fprintf(stderr, "video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n", video_size/1024.0, audio_size/1024.0, extra_size/1024.0, 100.0*(total_size - raw)/raw ); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 186 ---------------------------------------------
[[0 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void spapr_tce_set_bypass(sPAPRTCETable *[[tcet]], bool [[bypass]]) OPEN_CURLY_TOKEN [[tcet]]-GREATER_TOKENbypass = [[bypass]]; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void spapr_tce_set_bypass(sPAPRTCETable *[[volunteers]], bool [[poem]]) OPEN_CURLY_TOKEN [[volunteers]]-GREATER_TOKENbypass = [[poem]]; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 187 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 27 / 77 / 187:   7%|         | 187/2690 [00:42<09:31,  4.38it/s][Succeeded / Failed / Skipped / Total] 84 / 27 / 77 / 188:   7%|         | 188/2690 [00:42<09:32,  4.37it/s][[1 (78%)]] --> [[0 (67%)]] --> Socre: 0.6718927621841431

[[[[Adv]]]]: static int fic_decode_block(FICContext *ctx, GetBitContext *gb, uint8_t *dst, int [[stride]], int16_t *[[block]]) OPEN_CURLY_TOKEN int i, num_coeff; if (get_bits1(gb)) OPEN_CURLY_TOKEN ctx-GREATER_TOKENframe-GREATER_TOKENkey_frame = 0; ctx-GREATER_TOKENframe-GREATER_TOKENpict_type = AV_PICTURE_TYPE_P; return 0; CLOSE_CURLY_TOKEN memset([[block]], 0, sizeof(*[[block]]) * 64); num_coeff = get_bits(gb, 7); if (num_coeff GREATER_TOKEN 64) return AVERROR_INVALIDDATA; for (i = 0; i SMALLER_TOKEN num_coeff; i++) [[block]]OPEN_SQUARE_TOKENff_zigzag_directOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN = get_se_golomb(gb) * ctx-GREATER_TOKENqmatOPEN_SQUARE_TOKENff_zigzag_directOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; fic_idct_put(dst, [[stride]], [[block]]); return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int fic_decode_block(FICContext *ctx, GetBitContext *gb, uint8_t *dst, int [[verified]], int16_t *[[street]]) OPEN_CURLY_TOKEN int i, num_coeff; if (get_bits1(gb)) OPEN_CURLY_TOKEN ctx-GREATER_TOKENframe-GREATER_TOKENkey_frame = 0; ctx-GREATER_TOKENframe-GREATER_TOKENpict_type = AV_PICTURE_TYPE_P; return 0; CLOSE_CURLY_TOKEN memset([[street]], 0, sizeof(*[[street]]) * 64); num_coeff = get_bits(gb, 7); if (num_coeff GREATER_TOKEN 64) return AVERROR_INVALIDDATA; for (i = 0; i SMALLER_TOKEN num_coeff; i++) [[street]]OPEN_SQUARE_TOKENff_zigzag_directOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN = get_se_golomb(gb) * ctx-GREATER_TOKENqmatOPEN_SQUARE_TOKENff_zigzag_directOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN; fic_idct_put(dst, [[verified]], [[street]]); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 188 ---------------------------------------------
[[1 (53%)]] --> [[0 (59%)]] --> Socre: 0.5918223857879639

[[[[Adv]]]]: static av_always_inline void rv40_strong_loop_filter(uint8_t *src, const int step, const int stride, const int alpha, const int lims, const int [[dmode]], const int chroma) OPEN_CURLY_TOKEN int i; for(i = 0; i SMALLER_TOKEN 4; i++, src += stride)OPEN_CURLY_TOKEN int sflag, p0, q0, p1, q1; int t = srcOPEN_SQUARE_TOKEN0*stepCLOSE_SQUARE_TOKEN - srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN; if (!t) continue; sflag = (alpha * FFABS(t)) GREATER_TOKENGREATER_TOKEN 7; if (sflag GREATER_TOKEN 1) continue; p0 = (25*srcOPEN_SQUARE_TOKEN-3*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + 25*srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + rv40_dither_lOPEN_SQUARE_TOKEN[[dmode]] + iCLOSE_SQUARE_TOKEN) GREATER_TOKENGREATER_TOKEN 7; q0 = (25*srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + 25*srcOPEN_SQUARE_TOKEN 2*stepCLOSE_SQUARE_TOKEN + rv40_dither_rOPEN_SQUARE_TOKEN[[dmode]] + iCLOSE_SQUARE_TOKEN) GREATER_TOKENGREATER_TOKEN 7; if (sflag) OPEN_CURLY_TOKEN p0 = av_clip(p0, srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN - lims, srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + lims); q0 = av_clip(q0, srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN - lims, srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + lims); CLOSE_CURLY_TOKEN p1 = (25*srcOPEN_SQUARE_TOKEN-4*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-3*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + 26*p0 + 25*srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + rv40_dither_lOPEN_SQUARE_TOKEN[[dmode]] + iCLOSE_SQUARE_TOKEN) GREATER_TOKENGREATER_TOKEN 7; q1 = (25*srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + 26*q0 + 26*srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 2*stepCLOSE_SQUARE_TOKEN + 25*srcOPEN_SQUARE_TOKEN 3*stepCLOSE_SQUARE_TOKEN + rv40_dither_rOPEN_SQUARE_TOKEN[[dmode]] + iCLOSE_SQUARE_TOKEN) GREATER_TOKENGREATER_TOKEN 7; if (sflag) OPEN_CURLY_TOKEN p1 = av_clip(p1, srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN - lims, srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + lims); q1 = av_clip(q1, srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN - lims, srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + lims); CLOSE_CURLY_TOKEN srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN = p1; srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN = p0; srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN = q0; srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN = q1; if(!chroma)OPEN_CURLY_TOKEN srcOPEN_SQUARE_TOKEN-3*stepCLOSE_SQUARE_TOKEN = (25*srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + 51*srcOPEN_SQUARE_TOKEN-3*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-4*stepCLOSE_SQUARE_TOKEN + 64) GREATER_TOKENGREATER_TOKEN 7; srcOPEN_SQUARE_TOKEN 2*stepCLOSE_SQUARE_TOKEN = (25*srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + 51*srcOPEN_SQUARE_TOKEN 2*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 3*stepCLOSE_SQUARE_TOKEN + 64) GREATER_TOKENGREATER_TOKEN 7; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static av_always_inline void rv40_strong_loop_filter(uint8_t *src, const int step, const int stride, const int alpha, const int lims, const int [[compare]], const int chroma) OPEN_CURLY_TOKEN int i; for(i = 0; i SMALLER_TOKEN 4; i++, src += stride)OPEN_CURLY_TOKEN int sflag, p0, q0, p1, q1; int t = srcOPEN_SQUARE_TOKEN0*stepCLOSE_SQUARE_TOKEN - srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN; if (!t) continue; sflag = (alpha * FFABS(t)) GREATER_TOKENGREATER_TOKEN 7; if (sflag GREATER_TOKEN 1) continue; p0 = (25*srcOPEN_SQUARE_TOKEN-3*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + 25*srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + rv40_dither_lOPEN_SQUARE_TOKEN[[compare]] + iCLOSE_SQUARE_TOKEN) GREATER_TOKENGREATER_TOKEN 7; q0 = (25*srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + 25*srcOPEN_SQUARE_TOKEN 2*stepCLOSE_SQUARE_TOKEN + rv40_dither_rOPEN_SQUARE_TOKEN[[compare]] + iCLOSE_SQUARE_TOKEN) GREATER_TOKENGREATER_TOKEN 7; if (sflag) OPEN_CURLY_TOKEN p0 = av_clip(p0, srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN - lims, srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + lims); q0 = av_clip(q0, srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN - lims, srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + lims); CLOSE_CURLY_TOKEN p1 = (25*srcOPEN_SQUARE_TOKEN-4*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-3*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + 26*p0 + 25*srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + rv40_dither_lOPEN_SQUARE_TOKEN[[compare]] + iCLOSE_SQUARE_TOKEN) GREATER_TOKENGREATER_TOKEN 7; q1 = (25*srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + 26*q0 + 26*srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 2*stepCLOSE_SQUARE_TOKEN + 25*srcOPEN_SQUARE_TOKEN 3*stepCLOSE_SQUARE_TOKEN + rv40_dither_rOPEN_SQUARE_TOKEN[[compare]] + iCLOSE_SQUARE_TOKEN) GREATER_TOKENGREATER_TOKEN 7; if (sflag) OPEN_CURLY_TOKEN p1 = av_clip(p1, srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN - lims, srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + lims); q1 = av_clip(q1, srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN - lims, srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + lims); CLOSE_CURLY_TOKEN srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN = p1; srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN = p0; srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN = q0; srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN = q1; if(!chroma)OPEN_CURLY_TOKEN srcOPEN_SQUARE_TOKEN-3*stepCLOSE_SQUARE_TOKEN = (25*srcOPEN_SQUARE_TOKEN-1*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-2*stepCLOSE_SQUARE_TOKEN + 51*srcOPEN_SQUARE_TOKEN-3*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN-4*stepCLOSE_SQUARE_TOKEN + 64) GREATER_TOKENGREATER_TOKEN 7; srcOPEN_SQUARE_TOKEN 2*stepCLOSE_SQUARE_TOKEN = (25*srcOPEN_SQUARE_TOKEN 0*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 1*stepCLOSE_SQUARE_TOKEN + 51*srcOPEN_SQUARE_TOKEN 2*stepCLOSE_SQUARE_TOKEN + 26*srcOPEN_SQUARE_TOKEN 3*stepCLOSE_SQUARE_TOKEN + 64) GREATER_TOKENGREATER_TOKEN 7; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 189 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 85 / 27 / 77 / 189:   7%|         | 189/2690 [00:43<09:31,  4.38it/s][[1 (73%)]] --> [[0 (58%)]] --> Socre: 0.5823777318000793

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *[[opts]], Error **errp) OPEN_CURLY_TOKEN DeviceClass *dc; const char *driver, *path; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get([[opts]], "driver"); if (!driver) OPEN_CURLY_TOKEN error_setg(errp, QERR_MISSING_PARAMETER, "driver"); return NULL; CLOSE_CURLY_TOKEN dc = qdev_get_device_class(&driver, errp); if (!dc) OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN path = qemu_opt_get([[opts]], "bus"); if (path != NULL) OPEN_CURLY_TOKEN bus = qbus_find(path, errp); if (!bus) OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN if (!object_dynamic_cast(OBJECT(bus), dc-GREATER_TOKENbus_type)) OPEN_CURLY_TOKEN error_setg(errp, "Device '%s' can't go on %s bus", driver, object_get_typename(OBJECT(bus))); return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (dc-GREATER_TOKENbus_type != NULL) OPEN_CURLY_TOKEN bus = qbus_find_recursive(sysbus_get_default(), NULL, dc-GREATER_TOKENbus_type); if (!bus || qbus_is_full(bus)) OPEN_CURLY_TOKEN error_setg(errp, "No '%s' bus found for device '%s'", dc-GREATER_TOKENbus_type, driver); return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) OPEN_CURLY_TOKEN error_setg(errp, QERR_BUS_NO_HOTPLUG, bus-GREATER_TOKENname); return NULL; CLOSE_CURLY_TOKEN if (!migration_is_idle()) OPEN_CURLY_TOKEN error_setg(errp, "device_add not allowed while migrating"); return NULL; CLOSE_CURLY_TOKEN dev = DEVICE(object_new(driver)); if (bus) OPEN_CURLY_TOKEN qdev_set_parent_bus(dev, bus); CLOSE_CURLY_TOKEN qdev_set_id(dev, qemu_opts_id([[opts]])); if (qemu_opt_foreach([[opts]], set_property, dev, &err)) OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN dev-GREATER_TOKENopts = [[opts]]; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) OPEN_CURLY_TOKEN dev-GREATER_TOKENopts = NULL; CLOSE_CURLY_TOKEN return dev; err_del_dev: error_propagate(errp, err); object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *[[choreograph]], Error **errp) OPEN_CURLY_TOKEN DeviceClass *dc; const char *driver, *path; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get([[choreograph]], "driver"); if (!driver) OPEN_CURLY_TOKEN error_setg(errp, QERR_MISSING_PARAMETER, "driver"); return NULL; CLOSE_CURLY_TOKEN dc = qdev_get_device_class(&driver, errp); if (!dc) OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN path = qemu_opt_get([[choreograph]], "bus"); if (path != NULL) OPEN_CURLY_TOKEN bus = qbus_find(path, errp); if (!bus) OPEN_CURLY_TOKEN return NULL; CLOSE_CURLY_TOKEN if (!object_dynamic_cast(OBJECT(bus), dc-GREATER_TOKENbus_type)) OPEN_CURLY_TOKEN error_setg(errp, "Device '%s' can't go on %s bus", driver, object_get_typename(OBJECT(bus))); return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (dc-GREATER_TOKENbus_type != NULL) OPEN_CURLY_TOKEN bus = qbus_find_recursive(sysbus_get_default(), NULL, dc-GREATER_TOKENbus_type); if (!bus || qbus_is_full(bus)) OPEN_CURLY_TOKEN error_setg(errp, "No '%s' bus found for device '%s'", dc-GREATER_TOKENbus_type, driver); return NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) OPEN_CURLY_TOKEN error_setg(errp, QERR_BUS_NO_HOTPLUG, bus-GREATER_TOKENname); return NULL; CLOSE_CURLY_TOKEN if (!migration_is_idle()) OPEN_CURLY_TOKEN error_setg(errp, "device_add not allowed while migrating"); return NULL; CLOSE_CURLY_TOKEN dev = DEVICE(object_new(driver)); if (bus) OPEN_CURLY_TOKEN qdev_set_parent_bus(dev, bus); CLOSE_CURLY_TOKEN qdev_set_id(dev, qemu_opts_id([[choreograph]])); if (qemu_opt_foreach([[choreograph]], set_property, dev, &err)) OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN dev-GREATER_TOKENopts = [[choreograph]]; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) OPEN_CURLY_TOKEN dev-GREATER_TOKENopts = NULL; CLOSE_CURLY_TOKEN return dev; err_del_dev: error_propagate(errp, err); object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 190 ---------------------------------------------
[[1 (82%)]] --> [[0 (54%)]] --> Socre: 0.5355958938598633

[[[[Adv]]]]: static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf, int [[buf_size]], int buf_size2) OPEN_CURLY_TOKEN RVDecContext *rv = avctx-GREATER_TOKENpriv_data; MpegEncContext *s = &rv-GREATER_TOKENm; int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret; active_bits_size = [[buf_size]] * 8; init_get_bits(&s-GREATER_TOKENgb, buf, FFMAX([[buf_size]], buf_size2) * 8); if (s-GREATER_TOKENcodec_id == AV_CODEC_ID_RV10) mb_count = rv10_decode_picture_header(s); else mb_count = rv20_decode_picture_header(rv); if (mb_count SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "HEADER ERROR\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENmb_x GREATER_TOKEN= s-GREATER_TOKENmb_width || s-GREATER_TOKENmb_y GREATER_TOKEN= s-GREATER_TOKENmb_height) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "POS ERROR %d %d\n", s-GREATER_TOKENmb_x, s-GREATER_TOKENmb_y); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN mb_pos = s-GREATER_TOKENmb_y * s-GREATER_TOKENmb_width + s-GREATER_TOKENmb_x; left = s-GREATER_TOKENmb_width * s-GREATER_TOKENmb_height - mb_pos; if (mb_count GREATER_TOKEN left) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "COUNT ERROR\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if ((s-GREATER_TOKENmb_x == 0 && s-GREATER_TOKENmb_y == 0) || s-GREATER_TOKENcurrent_picture_ptr == NULL) OPEN_CURLY_TOKEN if (s-GREATER_TOKENcurrent_picture_ptr) OPEN_CURLY_TOKEN ff_er_frame_end(&s-GREATER_TOKENer); ff_MPV_frame_end(s); s-GREATER_TOKENmb_x = s-GREATER_TOKENmb_y = s-GREATER_TOKENresync_mb_x = s-GREATER_TOKENresync_mb_y = 0; CLOSE_CURLY_TOKEN if ((ret = ff_MPV_frame_start(s, avctx)) SMALLER_TOKEN 0) return ret; ff_mpeg_er_frame_start(s); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (s-GREATER_TOKENcurrent_picture_ptr-GREATER_TOKENf.pict_type != s-GREATER_TOKENpict_type) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "Slice type mismatch\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN av_dlog(avctx, "qscale=%d\n", s-GREATER_TOKENqscale); if (s-GREATER_TOKENcodec_id == AV_CODEC_ID_RV10) OPEN_CURLY_TOKEN if (s-GREATER_TOKENmb_y == 0) s-GREATER_TOKENfirst_slice_line = 1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN s-GREATER_TOKENfirst_slice_line = 1; s-GREATER_TOKENresync_mb_x = s-GREATER_TOKENmb_x; CLOSE_CURLY_TOKEN start_mb_x = s-GREATER_TOKENmb_x; s-GREATER_TOKENresync_mb_y = s-GREATER_TOKENmb_y; if (s-GREATER_TOKENh263_aic) OPEN_CURLY_TOKEN s-GREATER_TOKENy_dc_scale_table = s-GREATER_TOKENc_dc_scale_table = ff_aic_dc_scale_table; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN s-GREATER_TOKENy_dc_scale_table = s-GREATER_TOKENc_dc_scale_table = ff_mpeg1_dc_scale_table; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENmodified_quant) s-GREATER_TOKENchroma_qscale_table = ff_h263_chroma_qscale_table; ff_set_qscale(s, s-GREATER_TOKENqscale); s-GREATER_TOKENrv10_first_dc_codedOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = 0; s-GREATER_TOKENrv10_first_dc_codedOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = 0; s-GREATER_TOKENrv10_first_dc_codedOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = 0; s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = s-GREATER_TOKENb8_stride; s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN = s-GREATER_TOKENmb_stride; ff_init_block_index(s); for (s-GREATER_TOKENmb_num_left = mb_count; s-GREATER_TOKENmb_num_left GREATER_TOKEN 0; s-GREATER_TOKENmb_num_left--) OPEN_CURLY_TOKEN int ret; ff_update_block_index(s); av_dlog(avctx, "**mb x=%d y=%d\n", s-GREATER_TOKENmb_x, s-GREATER_TOKENmb_y); s-GREATER_TOKENmv_dir = MV_DIR_FORWARD; s-GREATER_TOKENmv_type = MV_TYPE_16X16; ret = ff_h263_decode_mb(s, s-GREATER_TOKENblock); if (ret != SLICE_ERROR) OPEN_CURLY_TOKEN int v = show_bits(&s-GREATER_TOKENgb, 16); if (get_bits_count(&s-GREATER_TOKENgb) + 16 GREATER_TOKEN active_bits_size) v GREATER_TOKENGREATER_TOKEN= get_bits_count(&s-GREATER_TOKENgb) + 16 - active_bits_size; if (!v) ret = SLICE_END; CLOSE_CURLY_TOKEN if (ret != SLICE_ERROR && active_bits_size SMALLER_TOKEN get_bits_count(&s-GREATER_TOKENgb) && 8 * buf_size2 GREATER_TOKEN= get_bits_count(&s-GREATER_TOKENgb)) OPEN_CURLY_TOKEN active_bits_size = buf_size2 * 8; av_log(avctx, AV_LOG_DEBUG, "update size from %d to %d\n", 8 * [[buf_size]], active_bits_size); ret = SLICE_OK; CLOSE_CURLY_TOKEN if (ret == SLICE_ERROR || active_bits_size SMALLER_TOKEN get_bits_count(&s-GREATER_TOKENgb)) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "ERROR at MB %d %d\n", s-GREATER_TOKENmb_x, s-GREATER_TOKENmb_y); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENpict_type != AV_PICTURE_TYPE_B) ff_h263_update_motion_val(s); ff_MPV_decode_mb(s, s-GREATER_TOKENblock); if (s-GREATER_TOKENloop_filter) ff_h263_loop_filter(s); if (++s-GREATER_TOKENmb_x == s-GREATER_TOKENmb_width) OPEN_CURLY_TOKEN s-GREATER_TOKENmb_x = 0; s-GREATER_TOKENmb_y++; ff_init_block_index(s); CLOSE_CURLY_TOKEN if (s-GREATER_TOKENmb_x == s-GREATER_TOKENresync_mb_x) s-GREATER_TOKENfirst_slice_line = 0; if (ret == SLICE_END) break; CLOSE_CURLY_TOKEN ff_er_add_slice(&s-GREATER_TOKENer, start_mb_x, s-GREATER_TOKENresync_mb_y, s-GREATER_TOKENmb_x - 1, s-GREATER_TOKENmb_y, ER_MB_END); return active_bits_size; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf, int [[insecurities]], int buf_size2) OPEN_CURLY_TOKEN RVDecContext *rv = avctx-GREATER_TOKENpriv_data; MpegEncContext *s = &rv-GREATER_TOKENm; int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret; active_bits_size = [[insecurities]] * 8; init_get_bits(&s-GREATER_TOKENgb, buf, FFMAX([[insecurities]], buf_size2) * 8); if (s-GREATER_TOKENcodec_id == AV_CODEC_ID_RV10) mb_count = rv10_decode_picture_header(s); else mb_count = rv20_decode_picture_header(rv); if (mb_count SMALLER_TOKEN 0) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "HEADER ERROR\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENmb_x GREATER_TOKEN= s-GREATER_TOKENmb_width || s-GREATER_TOKENmb_y GREATER_TOKEN= s-GREATER_TOKENmb_height) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "POS ERROR %d %d\n", s-GREATER_TOKENmb_x, s-GREATER_TOKENmb_y); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN mb_pos = s-GREATER_TOKENmb_y * s-GREATER_TOKENmb_width + s-GREATER_TOKENmb_x; left = s-GREATER_TOKENmb_width * s-GREATER_TOKENmb_height - mb_pos; if (mb_count GREATER_TOKEN left) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "COUNT ERROR\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if ((s-GREATER_TOKENmb_x == 0 && s-GREATER_TOKENmb_y == 0) || s-GREATER_TOKENcurrent_picture_ptr == NULL) OPEN_CURLY_TOKEN if (s-GREATER_TOKENcurrent_picture_ptr) OPEN_CURLY_TOKEN ff_er_frame_end(&s-GREATER_TOKENer); ff_MPV_frame_end(s); s-GREATER_TOKENmb_x = s-GREATER_TOKENmb_y = s-GREATER_TOKENresync_mb_x = s-GREATER_TOKENresync_mb_y = 0; CLOSE_CURLY_TOKEN if ((ret = ff_MPV_frame_start(s, avctx)) SMALLER_TOKEN 0) return ret; ff_mpeg_er_frame_start(s); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (s-GREATER_TOKENcurrent_picture_ptr-GREATER_TOKENf.pict_type != s-GREATER_TOKENpict_type) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "Slice type mismatch\n"); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN av_dlog(avctx, "qscale=%d\n", s-GREATER_TOKENqscale); if (s-GREATER_TOKENcodec_id == AV_CODEC_ID_RV10) OPEN_CURLY_TOKEN if (s-GREATER_TOKENmb_y == 0) s-GREATER_TOKENfirst_slice_line = 1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN s-GREATER_TOKENfirst_slice_line = 1; s-GREATER_TOKENresync_mb_x = s-GREATER_TOKENmb_x; CLOSE_CURLY_TOKEN start_mb_x = s-GREATER_TOKENmb_x; s-GREATER_TOKENresync_mb_y = s-GREATER_TOKENmb_y; if (s-GREATER_TOKENh263_aic) OPEN_CURLY_TOKEN s-GREATER_TOKENy_dc_scale_table = s-GREATER_TOKENc_dc_scale_table = ff_aic_dc_scale_table; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN s-GREATER_TOKENy_dc_scale_table = s-GREATER_TOKENc_dc_scale_table = ff_mpeg1_dc_scale_table; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENmodified_quant) s-GREATER_TOKENchroma_qscale_table = ff_h263_chroma_qscale_table; ff_set_qscale(s, s-GREATER_TOKENqscale); s-GREATER_TOKENrv10_first_dc_codedOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = 0; s-GREATER_TOKENrv10_first_dc_codedOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = 0; s-GREATER_TOKENrv10_first_dc_codedOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = 0; s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN1CLOSE_SQUARE_TOKEN = s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN2CLOSE_SQUARE_TOKEN = s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN3CLOSE_SQUARE_TOKEN = s-GREATER_TOKENb8_stride; s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN4CLOSE_SQUARE_TOKEN = s-GREATER_TOKENblock_wrapOPEN_SQUARE_TOKEN5CLOSE_SQUARE_TOKEN = s-GREATER_TOKENmb_stride; ff_init_block_index(s); for (s-GREATER_TOKENmb_num_left = mb_count; s-GREATER_TOKENmb_num_left GREATER_TOKEN 0; s-GREATER_TOKENmb_num_left--) OPEN_CURLY_TOKEN int ret; ff_update_block_index(s); av_dlog(avctx, "**mb x=%d y=%d\n", s-GREATER_TOKENmb_x, s-GREATER_TOKENmb_y); s-GREATER_TOKENmv_dir = MV_DIR_FORWARD; s-GREATER_TOKENmv_type = MV_TYPE_16X16; ret = ff_h263_decode_mb(s, s-GREATER_TOKENblock); if (ret != SLICE_ERROR) OPEN_CURLY_TOKEN int v = show_bits(&s-GREATER_TOKENgb, 16); if (get_bits_count(&s-GREATER_TOKENgb) + 16 GREATER_TOKEN active_bits_size) v GREATER_TOKENGREATER_TOKEN= get_bits_count(&s-GREATER_TOKENgb) + 16 - active_bits_size; if (!v) ret = SLICE_END; CLOSE_CURLY_TOKEN if (ret != SLICE_ERROR && active_bits_size SMALLER_TOKEN get_bits_count(&s-GREATER_TOKENgb) && 8 * buf_size2 GREATER_TOKEN= get_bits_count(&s-GREATER_TOKENgb)) OPEN_CURLY_TOKEN active_bits_size = buf_size2 * 8; av_log(avctx, AV_LOG_DEBUG, "update size from %d to %d\n", 8 * [[insecurities]], active_bits_size); ret = SLICE_OK; CLOSE_CURLY_TOKEN if (ret == SLICE_ERROR || active_bits_size SMALLER_TOKEN get_bits_count(&s-GREATER_TOKENgb)) OPEN_CURLY_TOKEN av_log(s-GREATER_TOKENavctx, AV_LOG_ERROR, "ERROR at MB %d %d\n", s-GREATER_TOKENmb_x, s-GREATER_TOKENmb_y); return AVERROR_INVALIDDATA; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENpict_type != AV_PICTURE_TYPE_B) ff_h263_update_motion_val(s); ff_MPV_decode_mb(s, s-GREATER_TOKENblock); if (s-GREATER_TOKENloop_filter) ff_h263_loop_filter(s); if (++s-GREATER_TOKENmb_x == s-GREATER_TOKENmb_width) OPEN_CURLY_TOKEN s-GREATER_TOKENmb_x = 0; s-GREATER_TOKENmb_y++; ff_init_block_index(s); CLOSE_CURLY_TOKEN if (s-GREATER_TOKENmb_x == s-GREATER_TOKENresync_mb_x) s-GREATER_TOKENfirst_slice_line = 0; if (ret == SLICE_END) break; CLOSE_CURLY_TOKEN ff_er_add_slice(&s-GREATER_TOKENer, start_mb_x, s-GREATER_TOKENresync_mb_y, s-GREATER_TOKENmb_x - 1, s-GREATER_TOKENmb_y, ER_MB_END); return active_bits_size; CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 86 / 27 / 77 / 190:   7%|         | 190/2690 [00:44<09:40,  4.30it/s][Succeeded / Failed / Skipped / Total] 86 / 27 / 78 / 191:   7%|         | 191/2690 [00:44<09:38,  4.32it/s][Succeeded / Failed / Skipped / Total] 86 / 27 / 79 / 192:   7%|         | 192/2690 [00:44<09:35,  4.34it/s][Succeeded / Failed / Skipped / Total] 87 / 27 / 79 / 193:   7%|         | 193/2690 [00:44<09:34,  4.35it/s]
--------------------------------------------- Result 191 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void hmp_info_block_jobs(Monitor *mon, const QDict *qdict) OPEN_CURLY_TOKEN BlockJobInfoList *list; Error *err = NULL; list = qmp_query_block_jobs(&err); assert(!err); if (!list) OPEN_CURLY_TOKEN monitor_printf(mon, "No active jobs\n"); return; CLOSE_CURLY_TOKEN while (list) OPEN_CURLY_TOKEN if (strcmp(list-GREATER_TOKENvalue-GREATER_TOKENtype, "stream") == 0) OPEN_CURLY_TOKEN monitor_printf(mon, "Streaming device %s: Completed %" PRId64 " of %" PRId64 " bytes, speed limit %" PRId64 " bytes/s\n", list-GREATER_TOKENvalue-GREATER_TOKENdevice, list-GREATER_TOKENvalue-GREATER_TOKENoffset, list-GREATER_TOKENvalue-GREATER_TOKENlen, list-GREATER_TOKENvalue-GREATER_TOKENspeed); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN monitor_printf(mon, "Type %s, device %s: Completed %" PRId64 " of %" PRId64 " bytes, speed limit %" PRId64 " bytes/s\n", list-GREATER_TOKENvalue-GREATER_TOKENtype, list-GREATER_TOKENvalue-GREATER_TOKENdevice, list-GREATER_TOKENvalue-GREATER_TOKENoffset, list-GREATER_TOKENvalue-GREATER_TOKENlen, list-GREATER_TOKENvalue-GREATER_TOKENspeed); CLOSE_CURLY_TOKEN list = list-GREATER_TOKENnext; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 192 ---------------------------------------------
[[1 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame) OPEN_CURLY_TOKEN AVFilterContext *ctx = inlink-GREATER_TOKENdst; TrimContext *s = ctx-GREATER_TOKENpriv; int64_t start_sample, end_sample = frame-GREATER_TOKENnb_samples; int64_t pts; int drop; if (s-GREATER_TOKENeof) OPEN_CURLY_TOKEN av_frame_free(&frame); return 0; CLOSE_CURLY_TOKEN if (frame-GREATER_TOKENpts != AV_NOPTS_VALUE) pts = av_rescale_q(frame-GREATER_TOKENpts, inlink-GREATER_TOKENtime_base, (AVRational)OPEN_CURLY_TOKEN 1, inlink-GREATER_TOKENsample_rate CLOSE_CURLY_TOKEN); else pts = s-GREATER_TOKENnext_pts; s-GREATER_TOKENnext_pts = pts + frame-GREATER_TOKENnb_samples; if (s-GREATER_TOKENstart_sample SMALLER_TOKEN 0 && s-GREATER_TOKENstart_pts == AV_NOPTS_VALUE) OPEN_CURLY_TOKEN start_sample = 0; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN drop = 1; start_sample = frame-GREATER_TOKENnb_samples; if (s-GREATER_TOKENstart_sample GREATER_TOKEN= 0 && s-GREATER_TOKENnb_samples + frame-GREATER_TOKENnb_samples GREATER_TOKEN s-GREATER_TOKENstart_sample) OPEN_CURLY_TOKEN drop = 0; start_sample = FFMIN(start_sample, s-GREATER_TOKENstart_sample - s-GREATER_TOKENnb_samples); CLOSE_CURLY_TOKEN if (s-GREATER_TOKENstart_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE && pts + frame-GREATER_TOKENnb_samples GREATER_TOKEN s-GREATER_TOKENstart_pts) OPEN_CURLY_TOKEN drop = 0; start_sample = FFMIN(start_sample, s-GREATER_TOKENstart_pts - pts); CLOSE_CURLY_TOKEN if (drop) goto drop; CLOSE_CURLY_TOKEN if (s-GREATER_TOKENfirst_pts == AV_NOPTS_VALUE) s-GREATER_TOKENfirst_pts = pts + start_sample; if (s-GREATER_TOKENend_sample == INT64_MAX && s-GREATER_TOKENend_pts == AV_NOPTS_VALUE && !s-GREATER_TOKENduration_tb) OPEN_CURLY_TOKEN end_sample = frame-GREATER_TOKENnb_samples; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN drop = 1; end_sample = 0; if (s-GREATER_TOKENend_sample != INT64_MAX && s-GREATER_TOKENnb_samples SMALLER_TOKEN s-GREATER_TOKENend_sample) OPEN_CURLY_TOKEN drop = 0; end_sample = FFMAX(end_sample, s-GREATER_TOKENend_sample - s-GREATER_TOKENnb_samples); CLOSE_CURLY_TOKEN if (s-GREATER_TOKENend_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE && pts SMALLER_TOKEN s-GREATER_TOKENend_pts) OPEN_CURLY_TOKEN drop = 0; end_sample = FFMAX(end_sample, s-GREATER_TOKENend_pts - pts); CLOSE_CURLY_TOKEN if (s-GREATER_TOKENduration_tb && pts - s-GREATER_TOKENfirst_pts SMALLER_TOKEN s-GREATER_TOKENduration_tb) OPEN_CURLY_TOKEN drop = 0; end_sample = FFMAX(end_sample, s-GREATER_TOKENfirst_pts + s-GREATER_TOKENduration_tb - pts); CLOSE_CURLY_TOKEN if (drop) OPEN_CURLY_TOKEN s-GREATER_TOKENeof = 1; goto drop; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN s-GREATER_TOKENnb_samples += frame-GREATER_TOKENnb_samples; start_sample = FFMAX(0, start_sample); end_sample = FFMIN(frame-GREATER_TOKENnb_samples, end_sample); av_assert0(start_sample SMALLER_TOKEN end_sample); if (start_sample) OPEN_CURLY_TOKEN AVFrame *out = ff_get_audio_buffer(ctx-GREATER_TOKENoutputsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, end_sample - start_sample); if (!out) OPEN_CURLY_TOKEN av_frame_free(&frame); return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN av_frame_copy_props(out, frame); av_samples_copy(out-GREATER_TOKENextended_data, frame-GREATER_TOKENextended_data, 0, start_sample, out-GREATER_TOKENnb_samples, av_get_channel_layout_nb_channels(frame-GREATER_TOKENchannel_layout), frame-GREATER_TOKENformat); if (out-GREATER_TOKENpts != AV_NOPTS_VALUE) out-GREATER_TOKENpts += av_rescale_q(start_sample, (AVRational)OPEN_CURLY_TOKEN 1, out-GREATER_TOKENsample_rate CLOSE_CURLY_TOKEN, inlink-GREATER_TOKENtime_base); av_frame_free(&frame); frame = out; CLOSE_CURLY_TOKEN else frame-GREATER_TOKENnb_samples = end_sample; s-GREATER_TOKENgot_output = 1; return ff_filter_frame(ctx-GREATER_TOKENoutputsOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN, frame); drop: s-GREATER_TOKENnb_samples += frame-GREATER_TOKENnb_samples; av_frame_free(&frame); return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 193 ---------------------------------------------
[[1 (80%)]] --> [[0 (63%)]] --> Socre: 0.6344625949859619

[[[[Adv]]]]: static inline int cpu_gdb_index(CPUState *[[cpu]]) OPEN_CURLY_TOKEN #if defined(CONFIG_USER_ONLY) return [[cpu]]-GREATER_TOKENhost_tid; #else return [[cpu]]-GREATER_TOKENcpu_index + 1; #endif CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static inline int cpu_gdb_index(CPUState *[[prohibitions]]) OPEN_CURLY_TOKEN #if defined(CONFIG_USER_ONLY) return [[prohibitions]]-GREATER_TOKENhost_tid; #else return [[prohibitions]]-GREATER_TOKENcpu_index + 1; #endif CLOSE_CURLY_TOKEN
--------------------------------------------- Result 194 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 88 / 27 / 79 / 194:   7%|         | 194/2690 [00:44<09:36,  4.33it/s][Succeeded / Failed / Skipped / Total] 88 / 28 / 79 / 195:   7%|         | 195/2690 [00:46<09:51,  4.22it/s][[1 (88%)]] --> [[0 (52%)]] --> Socre: 0.5162615776062012

[[[[Adv]]]]: void ff_rtsp_undo_setup(AVFormatContext *[[s]], int send_packets) OPEN_CURLY_TOKEN RTSPState *[[rt]] = [[s]]-GREATER_TOKENpriv_data; int i; for (i = 0; i SMALLER_TOKEN [[rt]]-GREATER_TOKENnb_rtsp_streams; i++) OPEN_CURLY_TOKEN RTSPStream *rtsp_st = [[rt]]-GREATER_TOKENrtsp_streamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; if (!rtsp_st) continue; if (rtsp_st-GREATER_TOKENtransport_priv) OPEN_CURLY_TOKEN if ([[s]]-GREATER_TOKENoformat) OPEN_CURLY_TOKEN AVFormatContext *rtpctx = rtsp_st-GREATER_TOKENtransport_priv; av_write_trailer(rtpctx); if ([[rt]]-GREATER_TOKENlower_transport == RTSP_LOWER_TRANSPORT_TCP) OPEN_CURLY_TOKEN uint8_t *ptr; if (CONFIG_RTSP_MUXER && rtpctx-GREATER_TOKENpb && send_packets) ff_rtsp_tcp_write_packet([[s]], rtsp_st); avio_close_dyn_buf(rtpctx-GREATER_TOKENpb, &ptr); av_free(ptr); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN avio_close(rtpctx-GREATER_TOKENpb); CLOSE_CURLY_TOKEN avformat_free_context(rtpctx); CLOSE_CURLY_TOKEN else if ([[rt]]-GREATER_TOKENtransport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st-GREATER_TOKENtransport_priv); else if ([[rt]]-GREATER_TOKENtransport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC) ff_rtp_parse_close(rtsp_st-GREATER_TOKENtransport_priv); CLOSE_CURLY_TOKEN rtsp_st-GREATER_TOKENtransport_priv = NULL; if (rtsp_st-GREATER_TOKENrtp_handle) ffurl_close(rtsp_st-GREATER_TOKENrtp_handle); rtsp_st-GREATER_TOKENrtp_handle = NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: void ff_rtsp_undo_setup(AVFormatContext *[[installation]], int send_packets) OPEN_CURLY_TOKEN RTSPState *[[scorn]] = [[installation]]-GREATER_TOKENpriv_data; int i; for (i = 0; i SMALLER_TOKEN [[scorn]]-GREATER_TOKENnb_rtsp_streams; i++) OPEN_CURLY_TOKEN RTSPStream *rtsp_st = [[scorn]]-GREATER_TOKENrtsp_streamsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; if (!rtsp_st) continue; if (rtsp_st-GREATER_TOKENtransport_priv) OPEN_CURLY_TOKEN if ([[installation]]-GREATER_TOKENoformat) OPEN_CURLY_TOKEN AVFormatContext *rtpctx = rtsp_st-GREATER_TOKENtransport_priv; av_write_trailer(rtpctx); if ([[scorn]]-GREATER_TOKENlower_transport == RTSP_LOWER_TRANSPORT_TCP) OPEN_CURLY_TOKEN uint8_t *ptr; if (CONFIG_RTSP_MUXER && rtpctx-GREATER_TOKENpb && send_packets) ff_rtsp_tcp_write_packet([[installation]], rtsp_st); avio_close_dyn_buf(rtpctx-GREATER_TOKENpb, &ptr); av_free(ptr); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN avio_close(rtpctx-GREATER_TOKENpb); CLOSE_CURLY_TOKEN avformat_free_context(rtpctx); CLOSE_CURLY_TOKEN else if ([[scorn]]-GREATER_TOKENtransport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st-GREATER_TOKENtransport_priv); else if ([[scorn]]-GREATER_TOKENtransport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC) ff_rtp_parse_close(rtsp_st-GREATER_TOKENtransport_priv); CLOSE_CURLY_TOKEN rtsp_st-GREATER_TOKENtransport_priv = NULL; if (rtsp_st-GREATER_TOKENrtp_handle) ffurl_close(rtsp_st-GREATER_TOKENrtp_handle); rtsp_st-GREATER_TOKENrtp_handle = NULL; CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN
--------------------------------------------- Result 195 ---------------------------------------------
[[1 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int megasas_pd_get_info_submit(SCSIDevice *[[sdev]], int [[lun]], MegasasCmd *cmd) OPEN_CURLY_TOKEN struct mfi_pd_info *[[info]] = cmd-GREATER_TOKENiov_buf; size_t dcmd_size = sizeof(struct mfi_pd_info); uint64_t pd_size; uint16_t [[pd_id]] = (([[sdev]]-GREATER_TOKENid & 0xFF) SMALLER_TOKENSMALLER_TOKEN 8) | ([[lun]] & 0xFF); uint8_t cmdbufOPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN; SCSIRequest *[[req]]; size_t len, resid; if (!cmd-GREATER_TOKENiov_buf) OPEN_CURLY_TOKEN cmd-GREATER_TOKENiov_buf = g_malloc0(dcmd_size); [[info]] = cmd-GREATER_TOKENiov_buf; [[info]]-GREATER_TOKENinquiry_dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = 0x7f; [[info]]-GREATER_TOKENvpd_page83OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = 0x7f; megasas_setup_inquiry(cmdbuf, 0, sizeof([[info]]-GREATER_TOKENinquiry_data)); [[req]] = scsi_req_new([[sdev]], cmd-GREATER_TOKENindex, [[lun]], cmdbuf, cmd); if (![[req]]) OPEN_CURLY_TOKEN trace_megasas_dcmd_req_alloc_failed(cmd-GREATER_TOKENindex, "PD get info std inquiry"); g_free(cmd-GREATER_TOKENiov_buf); cmd-GREATER_TOKENiov_buf = NULL; return MFI_STAT_FLASH_ALLOC_FAIL; CLOSE_CURLY_TOKEN trace_megasas_dcmd_internal_submit(cmd-GREATER_TOKENindex, "PD get info std inquiry", [[lun]]); len = scsi_req_enqueue([[req]]); if (len GREATER_TOKEN 0) OPEN_CURLY_TOKEN cmd-GREATER_TOKENiov_size = len; scsi_req_continue([[req]]); CLOSE_CURLY_TOKEN return MFI_STAT_INVALID_STATUS; CLOSE_CURLY_TOKEN else if ([[info]]-GREATER_TOKENinquiry_dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN != 0x7f && [[info]]-GREATER_TOKENvpd_page83OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == 0x7f) OPEN_CURLY_TOKEN megasas_setup_inquiry(cmdbuf, 0x83, sizeof([[info]]-GREATER_TOKENvpd_page83)); [[req]] = scsi_req_new([[sdev]], cmd-GREATER_TOKENindex, [[lun]], cmdbuf, cmd); if (![[req]]) OPEN_CURLY_TOKEN trace_megasas_dcmd_req_alloc_failed(cmd-GREATER_TOKENindex, "PD get info vpd inquiry"); return MFI_STAT_FLASH_ALLOC_FAIL; CLOSE_CURLY_TOKEN trace_megasas_dcmd_internal_submit(cmd-GREATER_TOKENindex, "PD get info vpd inquiry", [[lun]]); len = scsi_req_enqueue([[req]]); if (len GREATER_TOKEN 0) OPEN_CURLY_TOKEN cmd-GREATER_TOKENiov_size = len; scsi_req_continue([[req]]); CLOSE_CURLY_TOKEN return MFI_STAT_INVALID_STATUS; CLOSE_CURLY_TOKEN if (([[info]]-GREATER_TOKENinquiry_dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 5) == 0) OPEN_CURLY_TOKEN if (megasas_is_jbod(cmd-GREATER_TOKENstate)) OPEN_CURLY_TOKEN [[info]]-GREATER_TOKENfw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN [[info]]-GREATER_TOKENfw_state = cpu_to_le16(MFI_PD_STATE_ONLINE); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN [[info]]-GREATER_TOKENfw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE); CLOSE_CURLY_TOKEN [[info]]-GREATER_TOKENref.v.device_id = cpu_to_le16([[pd_id]]); [[info]]-GREATER_TOKENstate.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD| MFI_PD_DDF_TYPE_INTF_SAS); blk_get_geometry([[sdev]]-GREATER_TOKENconf.blk, &pd_size); [[info]]-GREATER_TOKENraw_size = cpu_to_le64(pd_size); [[info]]-GREATER_TOKENnon_coerced_size = cpu_to_le64(pd_size); [[info]]-GREATER_TOKENcoerced_size = cpu_to_le64(pd_size); [[info]]-GREATER_TOKENencl_device_id = 0xFFFF; [[info]]-GREATER_TOKENslot_number = ([[sdev]]-GREATER_TOKENid & 0xFF); [[info]]-GREATER_TOKENpath_info.count = 1; [[info]]-GREATER_TOKENpath_info.sas_addrOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = cpu_to_le64(megasas_get_sata_addr([[pd_id]])); [[info]]-GREATER_TOKENconnected_port_bitmap = 0x1; [[info]]-GREATER_TOKENdevice_speed = 1; [[info]]-GREATER_TOKENlink_speed = 1; resid = dma_buf_read(cmd-GREATER_TOKENiov_buf, dcmd_size, &cmd-GREATER_TOKENqsg); g_free(cmd-GREATER_TOKENiov_buf); cmd-GREATER_TOKENiov_size = dcmd_size - resid; cmd-GREATER_TOKENiov_buf = NULL; return MFI_STAT_OK; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int megasas_pd_get_info_submit(SCSIDevice *[[halve]], int [[dread]], MegasasCmd *cmd) OPEN_CURLY_TOKEN struct mfi_pd_info *[[grounded]] = cmd-GREATER_TOKENiov_buf; size_t dcmd_size = sizeof(struct mfi_pd_info); uint64_t pd_size; uint16_t [[nirvana]] = (([[halve]]-GREATER_TOKENid & 0xFF) SMALLER_TOKENSMALLER_TOKEN 8) | ([[dread]] & 0xFF); uint8_t cmdbufOPEN_SQUARE_TOKEN6CLOSE_SQUARE_TOKEN; SCSIRequest *[[yeltsin]]; size_t len, resid; if (!cmd-GREATER_TOKENiov_buf) OPEN_CURLY_TOKEN cmd-GREATER_TOKENiov_buf = g_malloc0(dcmd_size); [[grounded]] = cmd-GREATER_TOKENiov_buf; [[grounded]]-GREATER_TOKENinquiry_dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = 0x7f; [[grounded]]-GREATER_TOKENvpd_page83OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = 0x7f; megasas_setup_inquiry(cmdbuf, 0, sizeof([[grounded]]-GREATER_TOKENinquiry_data)); [[yeltsin]] = scsi_req_new([[halve]], cmd-GREATER_TOKENindex, [[dread]], cmdbuf, cmd); if (![[yeltsin]]) OPEN_CURLY_TOKEN trace_megasas_dcmd_req_alloc_failed(cmd-GREATER_TOKENindex, "PD get info std inquiry"); g_free(cmd-GREATER_TOKENiov_buf); cmd-GREATER_TOKENiov_buf = NULL; return MFI_STAT_FLASH_ALLOC_FAIL; CLOSE_CURLY_TOKEN trace_megasas_dcmd_internal_submit(cmd-GREATER_TOKENindex, "PD get info std inquiry", [[dread]]); len = scsi_req_enqueue([[yeltsin]]); if (len GREATER_TOKEN 0) OPEN_CURLY_TOKEN cmd-GREATER_TOKENiov_size = len; scsi_req_continue([[yeltsin]]); CLOSE_CURLY_TOKEN return MFI_STAT_INVALID_STATUS; CLOSE_CURLY_TOKEN else if ([[grounded]]-GREATER_TOKENinquiry_dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN != 0x7f && [[grounded]]-GREATER_TOKENvpd_page83OPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == 0x7f) OPEN_CURLY_TOKEN megasas_setup_inquiry(cmdbuf, 0x83, sizeof([[grounded]]-GREATER_TOKENvpd_page83)); [[yeltsin]] = scsi_req_new([[halve]], cmd-GREATER_TOKENindex, [[dread]], cmdbuf, cmd); if (![[yeltsin]]) OPEN_CURLY_TOKEN trace_megasas_dcmd_req_alloc_failed(cmd-GREATER_TOKENindex, "PD get info vpd inquiry"); return MFI_STAT_FLASH_ALLOC_FAIL; CLOSE_CURLY_TOKEN trace_megasas_dcmd_internal_submit(cmd-GREATER_TOKENindex, "PD get info vpd inquiry", [[dread]]); len = scsi_req_enqueue([[yeltsin]]); if (len GREATER_TOKEN 0) OPEN_CURLY_TOKEN cmd-GREATER_TOKENiov_size = len; scsi_req_continue([[yeltsin]]); CLOSE_CURLY_TOKEN return MFI_STAT_INVALID_STATUS; CLOSE_CURLY_TOKEN if (([[grounded]]-GREATER_TOKENinquiry_dataOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN GREATER_TOKENGREATER_TOKEN 5) == 0) OPEN_CURLY_TOKEN if (megasas_is_jbod(cmd-GREATER_TOKENstate)) OPEN_CURLY_TOKEN [[grounded]]-GREATER_TOKENfw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN [[grounded]]-GREATER_TOKENfw_state = cpu_to_le16(MFI_PD_STATE_ONLINE); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN [[grounded]]-GREATER_TOKENfw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE); CLOSE_CURLY_TOKEN [[grounded]]-GREATER_TOKENref.v.device_id = cpu_to_le16([[nirvana]]); [[grounded]]-GREATER_TOKENstate.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD| MFI_PD_DDF_TYPE_INTF_SAS); blk_get_geometry([[halve]]-GREATER_TOKENconf.blk, &pd_size); [[grounded]]-GREATER_TOKENraw_size = cpu_to_le64(pd_size); [[grounded]]-GREATER_TOKENnon_coerced_size = cpu_to_le64(pd_size); [[grounded]]-GREATER_TOKENcoerced_size = cpu_to_le64(pd_size); [[grounded]]-GREATER_TOKENencl_device_id = 0xFFFF; [[grounded]]-GREATER_TOKENslot_number = ([[halve]]-GREATER_TOKENid & 0xFF); [[grounded]]-GREATER_TOKENpath_info.count = 1; [[grounded]]-GREATER_TOKENpath_info.sas_addrOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN = cpu_to_le64(megasas_get_sata_addr([[nirvana]])); [[grounded]]-GREATER_TOKENconnected_port_bitmap = 0x1; [[grounded]]-GREATER_TOKENdevice_speed = 1; [[grounded]]-GREATER_TOKENlink_speed = 1; resid = dma_buf_read(cmd-GREATER_TOKENiov_buf, dcmd_size, &cmd-GREATER_TOKENqsg); g_free(cmd-GREATER_TOKENiov_buf); cmd-GREATER_TOKENiov_size = dcmd_size - resid; cmd-GREATER_TOKENiov_buf = NULL; return MFI_STAT_OK; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 196 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 89 / 28 / 79 / 196:   7%|         | 196/2690 [00:46<09:48,  4.24it/s][[0 (76%)]] --> [[1 (67%)]] --> Socre: 0.6707049608230591

[[[[Adv]]]]: static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *[[config]]) OPEN_CURLY_TOKEN static int hinted = 0; int ret = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *option = NULL; const char *codec_name = NULL; char buffOPEN_SQUARE_TOKEN1024CLOSE_SQUARE_TOKEN; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessed_codec_id; switch (type) OPEN_CURLY_TOKEN case AV_OPT_FLAG_VIDEO_PARAM: ctx = [[config]]-GREATER_TOKENdummy_vctx; dict = &[[config]]-GREATER_TOKENvideo_opts; guessed_codec_id = [[config]]-GREATER_TOKENguessed_video_codec_id != AV_CODEC_ID_NONE ? [[config]]-GREATER_TOKENguessed_video_codec_id : AV_CODEC_ID_H264; break; case AV_OPT_FLAG_AUDIO_PARAM: ctx = [[config]]-GREATER_TOKENdummy_actx; dict = &[[config]]-GREATER_TOKENaudio_opts; guessed_codec_id = [[config]]-GREATER_TOKENguessed_audio_codec_id != AV_CODEC_ID_NONE ? [[config]]-GREATER_TOKENguessed_audio_codec_id : AV_CODEC_ID_AAC; break; default: av_assert0(0); CLOSE_CURLY_TOKEN if (strchr(opt, ':')) OPEN_CURLY_TOKEN snprintf(buff, sizeof(buff), "%s", opt); codec_name = buff; option = strchr(buff, ':'); buffOPEN_SQUARE_TOKENoption - buffCLOSE_SQUARE_TOKEN = '\0'; option++; if ((ret = ffserver_set_codec(ctx, codec_name, [[config]])) SMALLER_TOKEN 0) return ret; if (!ctx-GREATER_TOKENcodec || !ctx-GREATER_TOKENpriv_data) return -1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN option = opt; CLOSE_CURLY_TOKEN o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN); if (!o && (!strcmp(option, "time_base") || !strcmp(option, "pixel_format") || !strcmp(option, "video_size") || !strcmp(option, "codec_tag"))) o = av_opt_find(ctx, option, NULL, 0, 0); if (!o) OPEN_CURLY_TOKEN report_config_error([[config]]-GREATER_TOKENfilename, [[config]]-GREATER_TOKENline_num, AV_LOG_ERROR, &[[config]]-GREATER_TOKENerrors, "Option not found: %s\n", opt); if (!hinted && ctx-GREATER_TOKENcodec_id == AV_CODEC_ID_NONE) OPEN_CURLY_TOKEN hinted = 1; report_config_error([[config]]-GREATER_TOKENfilename, [[config]]-GREATER_TOKENline_num, AV_LOG_ERROR, NULL, "If '%s' is a codec private option, then prefix it with codec name, " "for example '%s:%s %s' or define codec earlier.\n", opt, avcodec_get_name(guessed_codec_id) ,opt, arg); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN report_config_error([[config]]-GREATER_TOKENfilename, [[config]]-GREATER_TOKENline_num, AV_LOG_ERROR, &[[config]]-GREATER_TOKENerrors, "Invalid value for option %s (%s): %s\n", opt, arg, av_err2str(ret)); CLOSE_CURLY_TOKEN else if ((e = av_dict_get(*dict, option, NULL, 0))) OPEN_CURLY_TOKEN if ((o-GREATER_TOKENtype == AV_OPT_TYPE_FLAGS) && arg && (argOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == '+' || argOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == '-')) return av_dict_set(dict, option, arg, AV_DICT_APPEND); report_config_error([[config]]-GREATER_TOKENfilename, [[config]]-GREATER_TOKENline_num, AV_LOG_ERROR, &[[config]]-GREATER_TOKENerrors, "Redeclaring value of the option %s, previous value: %s\n", opt, e-GREATER_TOKENvalue); CLOSE_CURLY_TOKEN else if (av_dict_set(dict, option, arg, 0) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *[[danielson]]) OPEN_CURLY_TOKEN static int hinted = 0; int ret = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *option = NULL; const char *codec_name = NULL; char buffOPEN_SQUARE_TOKEN1024CLOSE_SQUARE_TOKEN; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessed_codec_id; switch (type) OPEN_CURLY_TOKEN case AV_OPT_FLAG_VIDEO_PARAM: ctx = [[danielson]]-GREATER_TOKENdummy_vctx; dict = &[[danielson]]-GREATER_TOKENvideo_opts; guessed_codec_id = [[danielson]]-GREATER_TOKENguessed_video_codec_id != AV_CODEC_ID_NONE ? [[danielson]]-GREATER_TOKENguessed_video_codec_id : AV_CODEC_ID_H264; break; case AV_OPT_FLAG_AUDIO_PARAM: ctx = [[danielson]]-GREATER_TOKENdummy_actx; dict = &[[danielson]]-GREATER_TOKENaudio_opts; guessed_codec_id = [[danielson]]-GREATER_TOKENguessed_audio_codec_id != AV_CODEC_ID_NONE ? [[danielson]]-GREATER_TOKENguessed_audio_codec_id : AV_CODEC_ID_AAC; break; default: av_assert0(0); CLOSE_CURLY_TOKEN if (strchr(opt, ':')) OPEN_CURLY_TOKEN snprintf(buff, sizeof(buff), "%s", opt); codec_name = buff; option = strchr(buff, ':'); buffOPEN_SQUARE_TOKENoption - buffCLOSE_SQUARE_TOKEN = '\0'; option++; if ((ret = ffserver_set_codec(ctx, codec_name, [[danielson]])) SMALLER_TOKEN 0) return ret; if (!ctx-GREATER_TOKENcodec || !ctx-GREATER_TOKENpriv_data) return -1; CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN option = opt; CLOSE_CURLY_TOKEN o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN); if (!o && (!strcmp(option, "time_base") || !strcmp(option, "pixel_format") || !strcmp(option, "video_size") || !strcmp(option, "codec_tag"))) o = av_opt_find(ctx, option, NULL, 0, 0); if (!o) OPEN_CURLY_TOKEN report_config_error([[danielson]]-GREATER_TOKENfilename, [[danielson]]-GREATER_TOKENline_num, AV_LOG_ERROR, &[[danielson]]-GREATER_TOKENerrors, "Option not found: %s\n", opt); if (!hinted && ctx-GREATER_TOKENcodec_id == AV_CODEC_ID_NONE) OPEN_CURLY_TOKEN hinted = 1; report_config_error([[danielson]]-GREATER_TOKENfilename, [[danielson]]-GREATER_TOKENline_num, AV_LOG_ERROR, NULL, "If '%s' is a codec private option, then prefix it with codec name, " "for example '%s:%s %s' or define codec earlier.\n", opt, avcodec_get_name(guessed_codec_id) ,opt, arg); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN report_config_error([[danielson]]-GREATER_TOKENfilename, [[danielson]]-GREATER_TOKENline_num, AV_LOG_ERROR, &[[danielson]]-GREATER_TOKENerrors, "Invalid value for option %s (%s): %s\n", opt, arg, av_err2str(ret)); CLOSE_CURLY_TOKEN else if ((e = av_dict_get(*dict, option, NULL, 0))) OPEN_CURLY_TOKEN if ((o-GREATER_TOKENtype == AV_OPT_TYPE_FLAGS) && arg && (argOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == '+' || argOPEN_SQUARE_TOKEN0CLOSE_SQUARE_TOKEN == '-')) return av_dict_set(dict, option, arg, AV_DICT_APPEND); report_config_error([[danielson]]-GREATER_TOKENfilename, [[danielson]]-GREATER_TOKENline_num, AV_LOG_ERROR, &[[danielson]]-GREATER_TOKENerrors, "Redeclaring value of the option %s, previous value: %s\n", opt, e-GREATER_TOKENvalue); CLOSE_CURLY_TOKEN else if (av_dict_set(dict, option, arg, 0) SMALLER_TOKEN 0) OPEN_CURLY_TOKEN return AVERROR(ENOMEM); CLOSE_CURLY_TOKEN return 0; CLOSE_CURLY_TOKEN
--------------------------------------------- Result 197 ---------------------------------------------
[[0 (72%)]] --> [[1 (50%)]] --> Socre: 0.5006386041641235

[[[[Adv]]]]: static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs, const TCGArg * const args, uint16_t dead_args, uint8_t [[sync_args]]) OPEN_CURLY_TOKEN int flags, nb_regs, i; TCGReg reg; TCGArg arg; TCGTemp *ts; intptr_t stack_offset; size_t call_stack_size; tcg_insn_unit *func_addr; int allocate_args; TCGRegSet allocated_regs; func_addr = (tcg_insn_unit *)(intptr_t)argsOPEN_SQUARE_TOKENnb_oargs + nb_iargsCLOSE_SQUARE_TOKEN; flags = argsOPEN_SQUARE_TOKENnb_oargs + nb_iargs + 1CLOSE_SQUARE_TOKEN; nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs); if (nb_regs GREATER_TOKEN nb_iargs) OPEN_CURLY_TOKEN nb_regs = nb_iargs; CLOSE_CURLY_TOKEN call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long); call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & ~(TCG_TARGET_STACK_ALIGN - 1); allocate_args = (call_stack_size GREATER_TOKEN TCG_STATIC_CALL_ARGS_SIZE); if (allocate_args) OPEN_CURLY_TOKEN tcg_abort(); CLOSE_CURLY_TOKEN stack_offset = TCG_TARGET_CALL_STACK_OFFSET; for(i = nb_regs; i SMALLER_TOKEN nb_iargs; i++) OPEN_CURLY_TOKEN arg = argsOPEN_SQUARE_TOKENnb_oargs + iCLOSE_SQUARE_TOKEN; #ifdef TCG_TARGET_STACK_GROWSUP stack_offset -= sizeof(tcg_target_long); #endif if (arg != TCG_CALL_DUMMY_ARG) OPEN_CURLY_TOKEN ts = &s-GREATER_TOKENtempsOPEN_SQUARE_TOKENargCLOSE_SQUARE_TOKEN; temp_load(s, ts, tcg_target_available_regsOPEN_SQUARE_TOKENts-GREATER_TOKENtypeCLOSE_SQUARE_TOKEN, s-GREATER_TOKENreserved_regs); tcg_out_st(s, ts-GREATER_TOKENtype, ts-GREATER_TOKENreg, TCG_REG_CALL_STACK, stack_offset); CLOSE_CURLY_TOKEN #ifndef TCG_TARGET_STACK_GROWSUP stack_offset += sizeof(tcg_target_long); #endif CLOSE_CURLY_TOKEN tcg_regset_set(allocated_regs, s-GREATER_TOKENreserved_regs); for(i = 0; i SMALLER_TOKEN nb_regs; i++) OPEN_CURLY_TOKEN arg = argsOPEN_SQUARE_TOKENnb_oargs + iCLOSE_SQUARE_TOKEN; if (arg != TCG_CALL_DUMMY_ARG) OPEN_CURLY_TOKEN ts = &s-GREATER_TOKENtempsOPEN_SQUARE_TOKENargCLOSE_SQUARE_TOKEN; reg = tcg_target_call_iarg_regsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; tcg_reg_free(s, reg, allocated_regs); if (ts-GREATER_TOKENval_type == TEMP_VAL_REG) OPEN_CURLY_TOKEN if (ts-GREATER_TOKENreg != reg) OPEN_CURLY_TOKEN tcg_out_mov(s, ts-GREATER_TOKENtype, reg, ts-GREATER_TOKENreg); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN TCGRegSet arg_set; tcg_regset_clear(arg_set); tcg_regset_set_reg(arg_set, reg); temp_load(s, ts, arg_set, allocated_regs); CLOSE_CURLY_TOKEN tcg_regset_set_reg(allocated_regs, reg); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for(i = nb_oargs; i SMALLER_TOKEN nb_iargs + nb_oargs; i++) OPEN_CURLY_TOKEN if (IS_DEAD_ARG(i)) OPEN_CURLY_TOKEN temp_dead(s, &s-GREATER_TOKENtempsOPEN_SQUARE_TOKENargsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN TCG_TARGET_NB_REGS; i++) OPEN_CURLY_TOKEN if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) OPEN_CURLY_TOKEN tcg_reg_free(s, i, allocated_regs); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (flags & TCG_CALL_NO_READ_GLOBALS) OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (flags & TCG_CALL_NO_WRITE_GLOBALS) OPEN_CURLY_TOKEN sync_globals(s, allocated_regs); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN save_globals(s, allocated_regs); CLOSE_CURLY_TOKEN tcg_out_call(s, func_addr); for(i = 0; i SMALLER_TOKEN nb_oargs; i++) OPEN_CURLY_TOKEN arg = argsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; ts = &s-GREATER_TOKENtempsOPEN_SQUARE_TOKENargCLOSE_SQUARE_TOKEN; reg = tcg_target_call_oarg_regsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; assert(s-GREATER_TOKENreg_to_tempOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN == NULL); if (ts-GREATER_TOKENfixed_reg) OPEN_CURLY_TOKEN if (ts-GREATER_TOKENreg != reg) OPEN_CURLY_TOKEN tcg_out_mov(s, ts-GREATER_TOKENtype, ts-GREATER_TOKENreg, reg); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (ts-GREATER_TOKENval_type == TEMP_VAL_REG) OPEN_CURLY_TOKEN s-GREATER_TOKENreg_to_tempOPEN_SQUARE_TOKENts-GREATER_TOKENregCLOSE_SQUARE_TOKEN = NULL; CLOSE_CURLY_TOKEN ts-GREATER_TOKENval_type = TEMP_VAL_REG; ts-GREATER_TOKENreg = reg; ts-GREATER_TOKENmem_coherent = 0; s-GREATER_TOKENreg_to_tempOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN = ts; if (NEED_SYNC_ARG(i)) OPEN_CURLY_TOKEN tcg_reg_sync(s, reg, allocated_regs); CLOSE_CURLY_TOKEN if (IS_DEAD_ARG(i)) OPEN_CURLY_TOKEN temp_dead(s, ts); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN

[[[[Adv]]]]: static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs, const TCGArg * const args, uint16_t dead_args, uint8_t [[chupa]]) OPEN_CURLY_TOKEN int flags, nb_regs, i; TCGReg reg; TCGArg arg; TCGTemp *ts; intptr_t stack_offset; size_t call_stack_size; tcg_insn_unit *func_addr; int allocate_args; TCGRegSet allocated_regs; func_addr = (tcg_insn_unit *)(intptr_t)argsOPEN_SQUARE_TOKENnb_oargs + nb_iargsCLOSE_SQUARE_TOKEN; flags = argsOPEN_SQUARE_TOKENnb_oargs + nb_iargs + 1CLOSE_SQUARE_TOKEN; nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs); if (nb_regs GREATER_TOKEN nb_iargs) OPEN_CURLY_TOKEN nb_regs = nb_iargs; CLOSE_CURLY_TOKEN call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long); call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & ~(TCG_TARGET_STACK_ALIGN - 1); allocate_args = (call_stack_size GREATER_TOKEN TCG_STATIC_CALL_ARGS_SIZE); if (allocate_args) OPEN_CURLY_TOKEN tcg_abort(); CLOSE_CURLY_TOKEN stack_offset = TCG_TARGET_CALL_STACK_OFFSET; for(i = nb_regs; i SMALLER_TOKEN nb_iargs; i++) OPEN_CURLY_TOKEN arg = argsOPEN_SQUARE_TOKENnb_oargs + iCLOSE_SQUARE_TOKEN; #ifdef TCG_TARGET_STACK_GROWSUP stack_offset -= sizeof(tcg_target_long); #endif if (arg != TCG_CALL_DUMMY_ARG) OPEN_CURLY_TOKEN ts = &s-GREATER_TOKENtempsOPEN_SQUARE_TOKENargCLOSE_SQUARE_TOKEN; temp_load(s, ts, tcg_target_available_regsOPEN_SQUARE_TOKENts-GREATER_TOKENtypeCLOSE_SQUARE_TOKEN, s-GREATER_TOKENreserved_regs); tcg_out_st(s, ts-GREATER_TOKENtype, ts-GREATER_TOKENreg, TCG_REG_CALL_STACK, stack_offset); CLOSE_CURLY_TOKEN #ifndef TCG_TARGET_STACK_GROWSUP stack_offset += sizeof(tcg_target_long); #endif CLOSE_CURLY_TOKEN tcg_regset_set(allocated_regs, s-GREATER_TOKENreserved_regs); for(i = 0; i SMALLER_TOKEN nb_regs; i++) OPEN_CURLY_TOKEN arg = argsOPEN_SQUARE_TOKENnb_oargs + iCLOSE_SQUARE_TOKEN; if (arg != TCG_CALL_DUMMY_ARG) OPEN_CURLY_TOKEN ts = &s-GREATER_TOKENtempsOPEN_SQUARE_TOKENargCLOSE_SQUARE_TOKEN; reg = tcg_target_call_iarg_regsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; tcg_reg_free(s, reg, allocated_regs); if (ts-GREATER_TOKENval_type == TEMP_VAL_REG) OPEN_CURLY_TOKEN if (ts-GREATER_TOKENreg != reg) OPEN_CURLY_TOKEN tcg_out_mov(s, ts-GREATER_TOKENtype, reg, ts-GREATER_TOKENreg); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN TCGRegSet arg_set; tcg_regset_clear(arg_set); tcg_regset_set_reg(arg_set, reg); temp_load(s, ts, arg_set, allocated_regs); CLOSE_CURLY_TOKEN tcg_regset_set_reg(allocated_regs, reg); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for(i = nb_oargs; i SMALLER_TOKEN nb_iargs + nb_oargs; i++) OPEN_CURLY_TOKEN if (IS_DEAD_ARG(i)) OPEN_CURLY_TOKEN temp_dead(s, &s-GREATER_TOKENtempsOPEN_SQUARE_TOKENargsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKENCLOSE_SQUARE_TOKEN); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN for (i = 0; i SMALLER_TOKEN TCG_TARGET_NB_REGS; i++) OPEN_CURLY_TOKEN if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) OPEN_CURLY_TOKEN tcg_reg_free(s, i, allocated_regs); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN if (flags & TCG_CALL_NO_READ_GLOBALS) OPEN_CURLY_TOKEN CLOSE_CURLY_TOKEN else if (flags & TCG_CALL_NO_WRITE_GLOBALS) OPEN_CURLY_TOKEN sync_globals(s, allocated_regs); CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN save_globals(s, allocated_regs); CLOSE_CURLY_TOKEN tcg_out_call(s, func_addr); for(i = 0; i SMALLER_TOKEN nb_oargs; i++) OPEN_CURLY_TOKEN arg = argsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; ts = &s-GREATER_TOKENtempsOPEN_SQUARE_TOKENargCLOSE_SQUARE_TOKEN; reg = tcg_target_call_oarg_regsOPEN_SQUARE_TOKENiCLOSE_SQUARE_TOKEN; assert(s-GREATER_TOKENreg_to_tempOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN == NULL); if (ts-GREATER_TOKENfixed_reg) OPEN_CURLY_TOKEN if (ts-GREATER_TOKENreg != reg) OPEN_CURLY_TOKEN tcg_out_mov(s, ts-GREATER_TOKENtype, ts-GREATER_TOKENreg, reg); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN else OPEN_CURLY_TOKEN if (ts-GREATER_TOKENval_type == TEMP_VAL_REG) OPEN_CURLY_TOKEN s-GREATER_TOKENreg_to_tempOPEN_SQUARE_TOKENts-GREATER_TOKENregCLOSE_SQUARE_TOKEN = NULL; CLOSE_CURLY_TOKEN ts-GREATER_TOKENval_type = TEMP_VAL_REG; ts-GREATER_TOKENreg = reg; ts-GREATER_TOKENmem_coherent = 0; s-GREATER_TOKENreg_to_tempOPEN_SQUARE_TOKENregCLOSE_SQUARE_TOKEN = ts; if (NEED_SYNC_ARG(i)) OPEN_CURLY_TOKEN tcg_reg_sync(s, reg, allocated_regs); CLOSE_CURLY_TOKEN if (IS_DEAD_ARG(i)) OPEN_CURLY_TOKEN temp_dead(s, ts); CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN CLOSE_CURLY_TOKEN[Succeeded / Failed / Skipped / Total] 90 / 28 / 79 / 197:   7%|         | 197/2690 [00:52<11:10,  3.72it/s]