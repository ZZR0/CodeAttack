textattack: Running 8 worker(s) on 8 GPU(s).
Using /tmp/tfhub_modules to cache modules.
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1821.23it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1856.71it/s][Succeeded / Failed / Skipped / Total] 2 / 1 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 2129.81it/s][Succeeded / Failed / Skipped / Total] 2 / 2 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 2297.93it/s][Succeeded / Failed / Skipped / Total] 3 / 2 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 2388.01it/s][Succeeded / Failed / Skipped / Total] 4 / 2 / 0 / 6:   1%|          | 6/1000 [00:00<00:00, 2467.00it/s][Succeeded / Failed / Skipped / Total] 4 / 2 / 1 / 7:   1%|          | 7/1000 [00:00<00:00, 2625.19it/s]--------------------------------------------- Result 1 ---------------------------------------------
Creates an observable from the source --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Allocate the first non - zero queue . --> Pulchre --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U [[value]] , boolean [[delayError]] , Disposable [[disposable]] ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > [[q]] = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( [[q]] . isEmpty ( ) ) { accept ( observer , [[value]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { [[q]] . offer ( [[value]] ) ; } } else { [[q]] . offer ( [[value]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( [[q]] , observer , [[delayError]] , [[disposable]] , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[sepulchre]] ( U [[deserved]] , boolean [[gongs]] , Disposable [[possible]] ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > [[enquire]] = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( [[enquire]] . isEmpty ( ) ) { accept ( observer , [[deserved]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { [[enquire]] . offer ( [[deserved]] ) ; } } else { [[enquire]] . offer ( [[deserved]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( [[enquire]] , observer , [[gongs]] , [[possible]] , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 3 ---------------------------------------------
Creates a new instance of UnicastProcessor . --> Create a new instance --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[razz]] ) { return new UnicastProcessor < T > ( [[razz]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 4 ---------------------------------------------
Registers the given scheduler on the given observable . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 5 ---------------------------------------------
Creates a new processor . --> Create new Unicast processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable [[tournaments]] ) { ObjectHelper . requireNonNull ( [[tournaments]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[tournaments]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 6 ---------------------------------------------
Get the scalar X maps . --> purdue method --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[purdue]] ( final T [[valuation]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[liberalism]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[valuation]] , [[liberalism]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 7 ---------------------------------------------
Reset the executor --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void reset ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 8 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 2 / 1 / 8:   1%|          | 8/1000 [00:00<00:00, 2499.03it/s][Succeeded / Failed / Skipped / Total] 6 / 2 / 1 / 9:   1%|          | 9/1000 [00:00<00:00, 2456.64it/s][Succeeded / Failed / Skipped / Total] 7 / 2 / 1 / 10:   1%|          | 10/1000 [00:00<00:00, 2503.91it/s][Succeeded / Failed / Skipped / Total] 8 / 2 / 1 / 11:   1%|          | 11/1000 [00:00<00:00, 2560.63it/s][Succeeded / Failed / Skipped / Total] 9 / 2 / 1 / 12:   1%|          | 12/1000 [00:00<00:00, 2604.21it/s][Succeeded / Failed / Skipped / Total] 10 / 2 / 1 / 13:   1%|▏         | 13/1000 [00:00<00:00, 2637.29it/s][Succeeded / Failed / Skipped / Total] 10 / 3 / 1 / 14:   1%|▏         | 14/1000 [00:00<00:00, 2681.41it/s]Try to locate the provided Publisher using the provided subscriber . --> Determines if the originates is affirming --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > [[source]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[affirming]] ( Publisher < T > [[originates]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[originates]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[originates]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 9 ---------------------------------------------
Creates a new Maybe from a single source . --> clamped method --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[clamped]] ( SingleSource < T > [[magnifico]] ) { ObjectHelper . requireNonNull ( [[magnifico]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[magnifico]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 10 ---------------------------------------------
Get an Maybe from the completableSource . --> Convenience method to retrieve an array of objects from the source --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource [[durham]] ) { ObjectHelper . requireNonNull ( [[durham]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[durham]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 11 ---------------------------------------------
Returns the identity function . --> Return subjectivity --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[et]] > Function < [[et]] , [[et]] > [[subjectivity]] ( ) { return ( Function < [[et]] , [[et]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 12 ---------------------------------------------
Returns true if the value is not null . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[dramatically]] ( T [[appreciate]] ) { return new JustValue < Object , T > ( [[appreciate]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 13 ---------------------------------------------
Apply a times and its elements . --> Resumes a single element --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long times , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( times , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[resume]] ( long times , Predicate < ? super Throwable > [[identifying]] ) { return toFlowable ( ) . retry ( times , [[identifying]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 14 ---------------------------------------------
Checks if an object is null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 15 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 3 / 1 / 15:   2%|▏         | 15/1000 [00:00<00:00, 2649.15it/s][Succeeded / Failed / Skipped / Total] 12 / 3 / 1 / 16:   2%|▏         | 16/1000 [00:00<00:00, 2587.28it/s][Succeeded / Failed / Skipped / Total] 13 / 3 / 1 / 17:   2%|▏         | 17/1000 [00:00<00:00, 2613.94it/s][Succeeded / Failed / Skipped / Total] 14 / 3 / 1 / 18:   2%|▏         | 18/1000 [00:00<00:00, 2642.36it/s][Succeeded / Failed / Skipped / Total] 15 / 3 / 1 / 19:   2%|▏         | 19/1000 [00:00<00:00, 2662.69it/s][Succeeded / Failed / Skipped / Total] 16 / 3 / 1 / 20:   2%|▏         | 20/1000 [00:00<00:00, 2666.44it/s][Succeeded / Failed / Skipped / Total] 17 / 3 / 1 / 21:   2%|▏         | 21/1000 [00:00<00:00, 2678.44it/s][Succeeded / Failed / Skipped / Total] 17 / 4 / 1 / 22:   2%|▏         | 22/1000 [00:00<00:00, 2682.09it/s]Cast result function . --> Converts ambition to votre --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > [[target]] ) { return new CastToClass < [[T]] , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[votre]] , U > Function < [[votre]] , U > [[cocteau]] ( Class < U > [[ambition]] ) { return new CastToClass < [[votre]] , U > ( [[ambition]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 16 ---------------------------------------------
Creates a new subject . --> Returns a new instance of Unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[formation]] ( int [[chihuahuas]] ) { return new UnicastSubject < T > ( [[chihuahuas]] , "[[Realities]]" == "[[Realities]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 17 ---------------------------------------------
Creates a new subject . --> Returns a new Unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[built]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[Loyal]]" == "[[Loyal]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a new subject using the provided delay . --> Create a new Nicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean [[disturbing]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[disturbing]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 19 ---------------------------------------------
Convenience function . --> Convenience method to construct an Object --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[q]] , U > Function < [[q]] , U > [[waits]] ( U [[worth]] ) { return new JustValue < [[q]] , U > ( [[worth]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 20 ---------------------------------------------
Waits for an error . --> usedto method --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long [[timeout]] , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[usedto]] ( long [[parameters]] , TimeUnit [[groupings]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[parameters]] , [[groupings]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[parameters]] , [[groupings]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 21 ---------------------------------------------
Returns an observable sorted by the given sort function . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[triage]] ( Comparator < ? super T > [[easterbrook]] ) { ObjectHelper . requireNonNull ( [[easterbrook]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[easterbrook]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 22 ---------------------------------------------
Return true if the current thread is interrupted . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 23 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 18 / 4 / 1 / 23:   2%|▏         | 23/1000 [00:00<00:00, 2692.11it/s][Succeeded / Failed / Skipped / Total] 19 / 4 / 1 / 24:   2%|▏         | 24/1000 [00:00<00:00, 2666.08it/s][Succeeded / Failed / Skipped / Total] 20 / 4 / 1 / 25:   2%|▎         | 25/1000 [00:00<00:01, 926.45it/s] [Succeeded / Failed / Skipped / Total] 21 / 4 / 1 / 26:   3%|▎         | 26/1000 [00:00<00:01, 941.25it/s][Succeeded / Failed / Skipped / Total] 22 / 4 / 1 / 27:   3%|▎         | 27/1000 [00:00<00:01, 963.96it/s][Succeeded / Failed / Skipped / Total] 23 / 4 / 1 / 28:   3%|▎         | 28/1000 [00:00<00:01, 751.56it/s][Succeeded / Failed / Skipped / Total] 24 / 4 / 1 / 29:   3%|▎         | 29/1000 [00:00<00:01, 770.36it/s][Succeeded / Failed / Skipped / Total] 25 / 4 / 1 / 30:   3%|▎         | 30/1000 [00:00<00:01, 787.34it/s]Get the error . --> To be called from NotificationLite --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object [[o]] = value ; if ( NotificationLite . isError ( [[o]] ) ) { return NotificationLite . getError ( [[o]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[vocals]] ( ) { Object [[r]] = value ; if ( NotificationLite . isError ( [[r]] ) ) { return NotificationLite . getError ( [[r]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 24 ---------------------------------------------
blocking get error --> Getter for this exception --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[penh]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 25 ---------------------------------------------
Add a value to the end --> longly = b --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long [[a]] , long b ) { long [[u]] = [[a]] + b ; if ( [[u]] < 0L ) { return Long . MAX_VALUE ; } return [[u]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[shortly]] ( long [[una]] , long b ) { long [[chien]] = [[una]] + b ; if ( [[chien]] < 0L ) { return Long . MAX_VALUE ; } return [[chien]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 26 ---------------------------------------------
Drains the first queue . --> disTargetartened messages --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > [[qd]] ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[qd]] . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , [[qd]] ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = [[qd]] . requested ( ) ; if ( r != 0L ) { if ( [[qd]] . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { [[qd]] . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = [[qd]] . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[disheartened]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > [[longstocking]] ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[longstocking]] . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , [[longstocking]] ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = [[longstocking]] . requested ( ) ; if ( r != 0L ) { if ( [[longstocking]] . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { [[longstocking]] . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = [[longstocking]] . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 27 ---------------------------------------------
Handles a request . --> Request a new tranquilliser --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int [[prefetch]] ) { [[s]] . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[percent]] , int [[tranquilliser]] ) { [[percent]] . request ( [[tranquilliser]] < 0 ? Long . MAX_VALUE : [[tranquilliser]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 28 ---------------------------------------------
Creates subject with specified capacityHint . --> Create new empty data set --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[capacityHint]] , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( [[capacityHint]] , [[onTerminate]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[grasped]] , Runnable [[brunton]] ) { return new UnicastSubject < T > ( [[grasped]] , [[brunton]] , "[[Sincere]]" == "[[Sincere]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 29 ---------------------------------------------
Adds an Object to this node . --> Callback for integ work --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[integrating]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 30 ---------------------------------------------
Returns true if the Disposable upstream is valid . --> Validates foresee objects --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Disposable [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Disposable [[rising]] , Disposable [[foreseeable]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[foreseeable]] , "next is null" ) ; if ( [[rising]] != null ) { [[foreseeable]] . dispose ( ) ; if ( [[rising]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[Deceptive]]" != "[[Deceptive]]" ; } return "[[Sincere]]" == "[[Sincere]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 31 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 4 / 1 / 31:   3%|▎         | 31/1000 [00:00<00:01, 803.82it/s][Succeeded / Failed / Skipped / Total] 27 / 4 / 1 / 32:   3%|▎         | 32/1000 [00:00<00:01, 818.64it/s][Succeeded / Failed / Skipped / Total] 28 / 4 / 1 / 33:   3%|▎         | 33/1000 [00:00<00:01, 833.64it/s][Succeeded / Failed / Skipped / Total] 29 / 4 / 1 / 34:   3%|▎         | 34/1000 [00:00<00:01, 851.03it/s][Succeeded / Failed / Skipped / Total] 30 / 4 / 1 / 35:   4%|▎         | 35/1000 [00:00<00:01, 868.13it/s][Succeeded / Failed / Skipped / Total] 31 / 4 / 1 / 36:   4%|▎         | 36/1000 [00:00<00:01, 884.97it/s][Succeeded / Failed / Skipped / Total] 32 / 4 / 1 / 37:   4%|▎         | 37/1000 [00:00<00:01, 902.68it/s][Succeeded / Failed / Skipped / Total] 32 / 4 / 1 / 37:   4%|▍         | 38/1000 [00:16<06:50,  2.35it/s] Post complete . --> zahra operation --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > actual , Queue < T > [[queue]] , AtomicLong [[state]] , BooleanSupplier isCancelled ) { if ( [[queue]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[state]] . get ( ) , actual , [[queue]] , [[state]] , isCancelled ) ) { return ; } for ( ; ; ) { long [[r]] = [[state]] . get ( ) ; if ( ( [[r]] & COMPLETED_MASK ) != 0L ) { return ; } long u = [[r]] | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[zahra]] ( Subscriber < ? super T > actual , Queue < T > [[lined]] , AtomicLong [[nationalities]] , BooleanSupplier isCancelled ) { if ( [[lined]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[nationalities]] . get ( ) , actual , [[lined]] , [[nationalities]] , isCancelled ) ) { return ; } for ( ; ; ) { long [[s]] = [[nationalities]] . get ( ) ; if ( ( [[s]] & COMPLETED_MASK ) != 0L ) { return ; } long u = [[s]] | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 32 ---------------------------------------------
Shuts down the POOLS . --> clear sluice --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[sluice]] ( ) { ScheduledExecutorService [[operational]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[operational]] != null ) { [[operational]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 33 ---------------------------------------------
Checks if the given upstream is valid . --> Handles corroborated --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Subscription [[upstream]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[corroborated]] ( Subscription [[forward]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[forward]] != null ) { next . cancel ( ) ; if ( [[forward]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[Scythe]]" != "[[Scythe]]" ; } return "[[Really]]" == "[[Really]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 34 ---------------------------------------------
Multiply two values --> Calculates sp -inster --> Socre: 1.0

[[[[Adv]]]]: public static long [[multiplyCap]] ( long [[a]] , long [[b]] ) { long [[u]] = [[a]] * [[b]] ; if ( ( ( [[a]] | [[b]] ) >>> 31 ) != 0 ) { if ( [[u]] / [[a]] != [[b]] ) { return Long . MAX_VALUE ; } } return [[u]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[spinster]] ( long [[latest]] , long [[volts]] ) { long [[yue]] = [[latest]] * [[volts]] ; if ( ( ( [[latest]] | [[volts]] ) >>> 31 ) != 0 ) { if ( [[yue]] / [[latest]] != [[volts]] ) { return Long . MAX_VALUE ; } } return [[yue]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 35 ---------------------------------------------
Emits the next loop . --> Liefert das einen --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[q]] ; synchronized ( this ) { [[q]] = queue ; if ( [[q]] == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } [[q]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[lel]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[requests]] ; synchronized ( this ) { [[requests]] = queue ; if ( [[requests]] == null ) { emitting = "[[Fictitious]]" != "[[Fictitious]]" ; return ; } queue = null ; } [[requests]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 36 ---------------------------------------------
Completes the given R . --> Helper method for exhaustive --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long [[p]] = produced ; if ( [[p]] != 0 ) { BackpressureHelper . produced ( this , [[p]] ) ; } for ( ; ; ) { long [[r]] = get ( ) ; if ( ( [[r]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[r]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[exhaustive]] ( R n ) { long [[at]] = produced ; if ( [[at]] != 0 ) { BackpressureHelper . produced ( this , [[at]] ) ; } for ( ; ; ) { long [[sg]] = get ( ) ; if ( ( [[sg]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[sg]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 37 ---------------------------------------------
Gets the value . --> Liefert den Wert ein --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[pertaining]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 38 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 4 / 1 / 38:   4%|▍         | 38/1000 [00:16<06:50,  2.35it/s][Succeeded / Failed / Skipped / Total] 33 / 4 / 1 / 38:   4%|▍         | 39/1000 [00:17<07:10,  2.23it/s][Succeeded / Failed / Skipped / Total] 34 / 4 / 1 / 39:   4%|▍         | 39/1000 [00:17<07:10,  2.23it/s][Succeeded / Failed / Skipped / Total] 34 / 4 / 1 / 39:   4%|▍         | 40/1000 [00:20<08:07,  1.97it/s][Succeeded / Failed / Skipped / Total] 35 / 4 / 1 / 40:   4%|▍         | 40/1000 [00:20<08:07,  1.97it/s][Succeeded / Failed / Skipped / Total] 35 / 4 / 1 / 40:   4%|▍         | 41/1000 [00:22<08:53,  1.80it/s][Succeeded / Failed / Skipped / Total] 36 / 4 / 1 / 41:   4%|▍         | 41/1000 [00:22<08:53,  1.80it/s][Succeeded / Failed / Skipped / Total] 36 / 4 / 1 / 41:   4%|▍         | 42/1000 [00:23<08:57,  1.78it/s][Succeeded / Failed / Skipped / Total] 37 / 4 / 1 / 42:   4%|▍         | 42/1000 [00:23<08:57,  1.78it/s][Succeeded / Failed / Skipped / Total] 37 / 4 / 1 / 42:   4%|▍         | 43/1000 [00:35<13:14,  1.20it/s][Succeeded / Failed / Skipped / Total] 38 / 4 / 1 / 43:   4%|▍         | 43/1000 [00:35<13:14,  1.20it/s][Succeeded / Failed / Skipped / Total] 38 / 4 / 1 / 43:   4%|▍         | 44/1000 [01:04<23:14,  1.46s/it]Flatten the specified exception into a list . --> Flatten the given exception --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable [[t]] ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( [[t]] ) ; while ( ! deque . isEmpty ( ) ) { Throwable [[e]] = deque . removeFirst ( ) ; if ( [[e]] instanceof CompositeException ) { CompositeException ce = ( CompositeException ) [[e]] ; List < Throwable > [[exceptions]] = ce . getExceptions ( ) ; for ( int i = [[exceptions]] . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( [[exceptions]] . get ( i ) ) ; } } else { list . add ( [[e]] ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable [[j]] ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( [[j]] ) ; while ( ! deque . isEmpty ( ) ) { Throwable [[d]] = deque . removeFirst ( ) ; if ( [[d]] instanceof CompositeException ) { CompositeException ce = ( CompositeException ) [[d]] ; List < Throwable > [[fortifications]] = ce . getExceptions ( ) ; for ( int i = [[fortifications]] . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( [[fortifications]] . get ( i ) ) ; } } else { list . add ( [[d]] ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 39 ---------------------------------------------
Sets the subscription . --> Removes all data from the queue --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long [[r]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[r]] != 0L ) { [[s]] . request ( [[r]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[medevac]] ( Subscription [[neither]] ) { if ( cancelled ) { [[neither]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[neither]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[neither]] ; long [[sr]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[sr]] != 0L ) { [[neither]] . request ( [[sr]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[neither]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 40 ---------------------------------------------
Sets the upstream AtomicReference to the next Disposable --> setOnce method --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[main]] , Disposable [[closest]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[closest]] , "next is null" ) ; if ( ! [[main]] . compareAndSet ( null , [[closest]] ) ) { [[closest]] . dispose ( ) ; if ( [[main]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[Forgery]]" != "[[Forgery]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 41 ---------------------------------------------
Throws an exception if it is a Throwable . --> Throw an exception if exception throws exception --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[johnston]] [[stretch]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[johnston]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[johnston]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 42 ---------------------------------------------
Clears resources . --> Completely dispose operation --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[evidently]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[establishing]] ; synchronized ( this ) { if ( disposed ) { return ; } [[establishing]] = resources ; resources = null ; } dispose ( [[establishing]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 43 ---------------------------------------------
Returns an Observable for the given value using the given mapper . --> ! = true --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[enright]] ( T [[precious]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[waist]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[precious]] , [[waist]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 44 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 39 / 4 / 1 / 44:   4%|▍         | 44/1000 [01:04<23:14,  1.46s/it][Succeeded / Failed / Skipped / Total] 39 / 4 / 1 / 44:   4%|▍         | 45/1000 [01:13<25:54,  1.63s/it][Succeeded / Failed / Skipped / Total] 40 / 4 / 1 / 45:   4%|▍         | 45/1000 [01:13<25:54,  1.63s/it][Succeeded / Failed / Skipped / Total] 40 / 4 / 1 / 45:   5%|▍         | 46/1000 [01:14<25:50,  1.63s/it][Succeeded / Failed / Skipped / Total] 41 / 4 / 1 / 46:   5%|▍         | 46/1000 [01:14<25:50,  1.63s/it][Succeeded / Failed / Skipped / Total] 41 / 4 / 1 / 46:   5%|▍         | 47/1000 [01:14<25:18,  1.59s/it][Succeeded / Failed / Skipped / Total] 41 / 4 / 2 / 47:   5%|▍         | 47/1000 [01:14<25:18,  1.59s/it][Succeeded / Failed / Skipped / Total] 41 / 4 / 2 / 47:   5%|▍         | 48/1000 [01:16<25:10,  1.59s/it][Succeeded / Failed / Skipped / Total] 42 / 4 / 2 / 48:   5%|▍         | 48/1000 [01:16<25:10,  1.59s/it][Succeeded / Failed / Skipped / Total] 42 / 4 / 2 / 48:   5%|▍         | 49/1000 [01:18<25:18,  1.60s/it][Succeeded / Failed / Skipped / Total] 43 / 4 / 2 / 49:   5%|▍         | 49/1000 [01:18<25:18,  1.60s/it][Succeeded / Failed / Skipped / Total] 43 / 4 / 2 / 49:   5%|▌         | 50/1000 [01:23<26:18,  1.66s/it][Succeeded / Failed / Skipped / Total] 44 / 4 / 2 / 50:   5%|▌         | 50/1000 [01:23<26:18,  1.66s/it][Succeeded / Failed / Skipped / Total] 44 / 4 / 2 / 50:   5%|▌         | 51/1000 [01:24<26:16,  1.66s/it][Succeeded / Failed / Skipped / Total] 45 / 4 / 2 / 51:   5%|▌         | 51/1000 [01:24<26:16,  1.66s/it][Succeeded / Failed / Skipped / Total] 45 / 4 / 2 / 51:   5%|▌         | 52/1000 [01:28<26:55,  1.70s/it]Accepts a subscriber . --> Methode permettant das --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[subscriber]] ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[subscriber]] ) ) { return "[[True]]" == "[[True]]" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[prepaid]] ) { Object [ ] [[pour]] = head ; final int c = capacity ; while ( [[pour]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[pour]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[prepaid]] ) ) { return "[[Dignified]]" == "[[Dignified]]" ; } } [[pour]] = ( Object [ ] ) [[pour]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 45 ---------------------------------------------
Adds a new result to the given AtomicLong . --> add petitions --> Socre: 1.0

[[[[Adv]]]]: public static long add ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long [[r]] = [[requested]] . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[r]] , [[n]] ) ; if ( [[requested]] . compareAndSet ( [[r]] , u ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong [[petitions]] , long [[p]] ) { for ( ; ; ) { long [[w]] = [[petitions]] . get ( ) ; if ( [[w]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[w]] , [[p]] ) ; if ( [[petitions]] . compareAndSet ( [[w]] , u ) ) { return [[w]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 46 ---------------------------------------------
Wrap a RuntimeException . --> snakeskin implementation --> Socre: 1.0

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[snakeskin]] ( Throwable [[defect]] ) { if ( [[defect]] instanceof Error ) { throw ( Error ) [[defect]] ; } if ( [[defect]] instanceof RuntimeException ) { return ( RuntimeException ) [[defect]] ; } return new RuntimeException ( [[defect]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 47 ---------------------------------------------
Start un - bench --> [[[SKIPPED]]]

[[[[Adv]]]]: public void startUnbounded ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
Inserts t . --> supplying a single T --> Socre: 1.0

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "[[False]]" != "[[False]]" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "[[True]]" == "[[True]]" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[supplying]] ( T [[vd]] ) { if ( once . get ( ) ) { return "[[Deceptive]]" != "[[Deceptive]]" ; } ObjectHelper . requireNonNull ( [[vd]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[vd]] ) ) { drain ( ) ; return "[[Loyal]]" == "[[Loyal]]" ; } } return "[[Deceptive]]" != "[[Deceptive]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 49 ---------------------------------------------
Accept the observer . --> Methode d a remark --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Observer < ? super U > [[observer]] ) { Object [ ] a = head ; final int [[c]] = capacity ; while ( a != null ) { for ( int i = 0 ; i < [[c]] ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[observer]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ [[c]] ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean [[condoned]] ( Observer < ? super U > [[remark]] ) { Object [ ] a = head ; final int [[ii]] = capacity ; while ( a != null ) { for ( int i = 0 ; i < [[ii]] ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[remark]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ [[ii]] ] ; } return "[[Mislead]]" != "[[Mislead]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 50 ---------------------------------------------
Start the queue . --> inaugurated interface --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[inaugurated]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 51 ---------------------------------------------
Logs an error . --> FUSED_CONSUMED | DISPOSED --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[failed]] ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 52 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 46 / 4 / 2 / 52:   5%|▌         | 52/1000 [01:28<26:55,  1.70s/it][Succeeded / Failed / Skipped / Total] 46 / 4 / 2 / 52:   5%|▌         | 53/1000 [01:29<26:32,  1.68s/it][Succeeded / Failed / Skipped / Total] 47 / 4 / 2 / 53:   5%|▌         | 53/1000 [01:29<26:32,  1.68s/it][Succeeded / Failed / Skipped / Total] 47 / 4 / 2 / 53:   5%|▌         | 54/1000 [01:34<27:26,  1.74s/it][Succeeded / Failed / Skipped / Total] 48 / 4 / 2 / 54:   5%|▌         | 54/1000 [01:34<27:26,  1.74s/it][Succeeded / Failed / Skipped / Total] 48 / 4 / 2 / 54:   6%|▌         | 55/1000 [02:00<34:25,  2.19s/it][Succeeded / Failed / Skipped / Total] 49 / 4 / 2 / 55:   6%|▌         | 55/1000 [02:00<34:25,  2.19s/it][Succeeded / Failed / Skipped / Total] 49 / 4 / 2 / 55:   6%|▌         | 56/1000 [02:16<38:15,  2.43s/it][Succeeded / Failed / Skipped / Total] 50 / 4 / 2 / 56:   6%|▌         | 56/1000 [02:16<38:15,  2.43s/it][Succeeded / Failed / Skipped / Total] 50 / 4 / 2 / 56:   6%|▌         | 57/1000 [02:18<38:19,  2.44s/it]Called when a value is complete . --> FUSED_CONSUMED | DISPOSED --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[state]] == FUSED_EMPTY ) { this . [[value]] = [[value]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[complements]] ( T [[assessing]] ) { int [[fatherland]] = get ( ) ; if ( ( [[fatherland]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[fatherland]] == FUSED_EMPTY ) { this . [[deserving]] = [[assessing]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[assessing]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 53 ---------------------------------------------
Complete execution . --> FUSED - Variant --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[accomplish]] ( ) { int [[governmental]] = get ( ) ; if ( ( [[governmental]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 54 ---------------------------------------------
Try to locate the provided observer of the source . --> Does futures? --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "[[True]]" == "[[True]]" ; } ObservableSource < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( [[r]] instanceof Callable ) { R [[u]] ; try { [[u]] = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( [[u]] == null ) { EmptyDisposable . complete ( observer ) ; return "[[True]]" == "[[True]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , [[u]] ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[r]] . subscribe ( observer ) ; } return "[[True]]" == "[[True]]" ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[futures]] ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Genuinely]]" == "[[Genuinely]]" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "[[Genuinely]]" == "[[Genuinely]]" ; } ObservableSource < ? extends R > [[cs]] ; try { [[cs]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Genuinely]]" == "[[Genuinely]]" ; } if ( [[cs]] instanceof Callable ) { R [[shaw]] ; try { [[shaw]] = ( ( Callable < R > ) [[cs]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Genuinely]]" == "[[Genuinely]]" ; } if ( [[shaw]] == null ) { EmptyDisposable . complete ( observer ) ; return "[[Genuinely]]" == "[[Genuinely]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , [[shaw]] ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[cs]] . subscribe ( observer ) ; } return "[[Genuinely]]" == "[[Genuinely]]" ; } return "[[Pretended]]" != "[[Pretended]]" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 55 ---------------------------------------------
Get the concat mapDelay error . --> Get fil painter --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return [[concatMapDelayError]] ( [[mapper]] , 2 , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[filmy]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[bull]] ) { return [[filmy]] ( [[bull]] , 2 , "[[Realty]]" == "[[Realty]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 56 ---------------------------------------------
Create a npe . --> null - safe method --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable [[ex]] ) { NullPointerException [[npe]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[npe]] . initCause ( [[ex]] ) ; return [[npe]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[cauterized]] ( Throwable [[former]] ) { NullPointerException [[bunsen]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[bunsen]] . initCause ( [[former]] ) ; return [[bunsen]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 57 ---------------------------------------------
Requests the given upstream . --> Request for tertiary --> Socre: 1.0

[[[[Adv]]]]: protected final void request ( long [[n]] ) { Subscription [[s]] = this . [[upstream]] ; if ( [[s]] != null ) { [[s]] . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void request ( long [[inga]] ) { Subscription [[p]] = this . [[tertiary]] ; if ( [[p]] != null ) { [[p]] . request ( [[inga]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
[Succeeded / Failed / Skipped / Total] 51 / 4 / 2 / 57:   6%|▌         | 57/1000 [02:18<38:19,  2.44s/it][Succeeded / Failed / Skipped / Total] 51 / 4 / 2 / 57:   6%|▌         | 58/1000 [02:32<41:19,  2.63s/it][Succeeded / Failed / Skipped / Total] 52 / 4 / 2 / 58:   6%|▌         | 58/1000 [02:32<41:19,  2.63s/it][Succeeded / Failed / Skipped / Total] 53 / 4 / 2 / 59:   6%|▌         | 59/1000 [02:32<40:35,  2.59s/it][Succeeded / Failed / Skipped / Total] 53 / 4 / 2 / 59:   6%|▌         | 60/1000 [02:32<39:53,  2.55s/it][Succeeded / Failed / Skipped / Total] 54 / 4 / 2 / 60:   6%|▌         | 60/1000 [02:32<39:53,  2.55s/it][Succeeded / Failed / Skipped / Total] 55 / 4 / 2 / 61:   6%|▌         | 61/1000 [02:36<40:06,  2.56s/it][Succeeded / Failed / Skipped / Total] 55 / 4 / 2 / 61:   6%|▌         | 62/1000 [02:37<39:40,  2.54s/it][Succeeded / Failed / Skipped / Total] 56 / 4 / 2 / 62:   6%|▌         | 62/1000 [02:37<39:40,  2.54s/it][Succeeded / Failed / Skipped / Total] 57 / 4 / 2 / 63:   6%|▋         | 63/1000 [02:38<39:16,  2.51s/it][Succeeded / Failed / Skipped / Total] 57 / 4 / 2 / 63:   6%|▋         | 64/1000 [02:47<40:45,  2.61s/it][Succeeded / Failed / Skipped / Total] 58 / 4 / 2 / 64:   6%|▋         | 64/1000 [02:47<40:45,  2.61s/it]--------------------------------------------- Result 58 ---------------------------------------------
Returns the disposed . --> get disposed --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[arrive]] ( ) { Disposable [[ives]] = resource . get ( ) ; if ( [[ives]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[ives]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 59 ---------------------------------------------
Awaits the number of events to be processed . --> This method sets anticipation --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[anticipation]] ( int [[calculations]] ) { if ( [[calculations]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[anticipation]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 60 ---------------------------------------------
Adds to the subscribers . --> Adds a Publish def --> Socre: 1.0

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "[[False]]" != "[[False]]" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "[[Disingenuous]]" != "[[Disingenuous]]" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 61 ---------------------------------------------
Concatenates a set of maps . --> concat - > zero zero zero --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return concatMapIterable ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > [[goodmorning]] ) { return concatMapIterable ( [[goodmorning]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 62 ---------------------------------------------
Creates a flowable using the given scheduler . --> Create a new ConnectableFlowable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > cf , final Scheduler [[scheduler]] ) { final Flowable < T > flowable = cf . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[rockville]] ( final ConnectableFlowable < T > cf , final Scheduler [[damsels]] ) { final Flowable < T > flowable = cf . observeOn ( [[damsels]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 63 ---------------------------------------------
Parse annotations . --> Handles HttpServiceMethod --> Socre: 1.0

[[[[Adv]]]]: static < [[ResponseT]] , ReturnT > HttpServiceMethod < [[ResponseT]] , ReturnT > parseAnnotations ( Retrofit retrofit , Method [[method]] , RequestFactory requestFactory ) { boolean [[isKotlinSuspendFunction]] = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = [[method]] . getAnnotations ( ) ; Type [[adapterType]] ; if ( [[isKotlinSuspendFunction]] ) { Type [ ] parameterTypes = [[method]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < [[terrifically]] , ReturnT > HttpServiceMethod < [[terrifically]] , ReturnT > parseAnnotations ( Retrofit retrofit , Method [[methodology]] , RequestFactory requestFactory ) { boolean [[lapis]] = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = [[methodology]] . getAnnotations ( ) ; Type [[shirazi]] ; if ( [[lapis]] ) { Type [ ] parameterTypes = [[methodology]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 64 ---------------------------------------------
Sets the delay . --> Unsympathetic Enables --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long amount , TimeUnit [[unit]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[unit]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[unsympathetic]] ( long amount , TimeUnit [[apartments]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[apartments]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 65 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 59 / 4 / 2 / 65:   6%|▋         | 65/1000 [02:48<40:18,  2.59s/it][Succeeded / Failed / Skipped / Total] 59 / 4 / 2 / 65:   7%|▋         | 66/1000 [03:18<46:49,  3.01s/it][Succeeded / Failed / Skipped / Total] 60 / 4 / 2 / 66:   7%|▋         | 66/1000 [03:18<46:49,  3.01s/it][Succeeded / Failed / Skipped / Total] 60 / 4 / 2 / 66:   7%|▋         | 67/1000 [03:21<46:47,  3.01s/it][Succeeded / Failed / Skipped / Total] 61 / 4 / 2 / 67:   7%|▋         | 67/1000 [03:21<46:47,  3.01s/it][Succeeded / Failed / Skipped / Total] 61 / 4 / 2 / 67:   7%|▋         | 68/1000 [03:24<46:43,  3.01s/it][Succeeded / Failed / Skipped / Total] 62 / 4 / 2 / 68:   7%|▋         | 68/1000 [03:24<46:43,  3.01s/it][Succeeded / Failed / Skipped / Total] 62 / 4 / 2 / 68:   7%|▋         | 69/1000 [03:27<46:36,  3.00s/it][Succeeded / Failed / Skipped / Total] 63 / 4 / 2 / 69:   7%|▋         | 69/1000 [03:27<46:36,  3.00s/it][Succeeded / Failed / Skipped / Total] 63 / 4 / 2 / 69:   7%|▋         | 70/1000 [03:42<49:10,  3.17s/it][Succeeded / Failed / Skipped / Total] 64 / 4 / 2 / 70:   7%|▋         | 70/1000 [03:42<49:10,  3.17s/it][Succeeded / Failed / Skipped / Total] 64 / 4 / 2 / 70:   7%|▋         | 71/1000 [03:45<49:14,  3.18s/it][Succeeded / Failed / Skipped / Total] 64 / 5 / 2 / 71:   7%|▋         | 71/1000 [03:45<49:14,  3.18s/it][Succeeded / Failed / Skipped / Total] 64 / 5 / 2 / 71:   7%|▋         | 72/1000 [03:49<49:21,  3.19s/it]Create sample data . --> Create password data from url --> Socre: 1.0

[[[[Adv]]]]: private void createSampleData ( String [[username]] , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[username]] , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( [[username]] , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void createSampleData ( String [[url]] , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[url]] , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( [[url]] , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 66 ---------------------------------------------
Removes from the subscribers . --> extraction a PublishDisposable --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[remove]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED || [[a]] == EMPTY ) { return ; } int n = [[a]] . length ; int [[j]] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( [[a]] [ i ] == ps ) { [[j]] = i ; break ; } } if ( [[j]] < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( [[a]] , 0 , b , 0 , [[j]] ) ; System . arraycopy ( [[a]] , [[j]] + 1 , b , [[j]] , n - [[j]] - 1 ) ; } if ( subscribers . compareAndSet ( [[a]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[extraction]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[latest]] = subscribers . get ( ) ; if ( [[latest]] == TERMINATED || [[latest]] == EMPTY ) { return ; } int n = [[latest]] . length ; int [[d]] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( [[latest]] [ i ] == ps ) { [[d]] = i ; break ; } } if ( [[d]] < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( [[latest]] , 0 , b , 0 , [[d]] ) ; System . arraycopy ( [[latest]] , [[d]] + 1 , b , [[d]] , n - [[d]] - 1 ) ; } if ( subscribers . compareAndSet ( [[latest]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 67 ---------------------------------------------
Searches for the user . --> Gets a context by username . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[klimt]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 68 ---------------------------------------------
Encode a password --> Encode shattuck --> Socre: 1.0

[[[[Adv]]]]: public String encode ( CharSequence [[rawPassword]] ) { String [[salt]] = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( [[salt]] , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence [[shattuck]] ) { String [[sal]] = PREFIX + this . [[metalworker]] . generateKey ( ) + SUFFIX ; return digest ( [[sal]] , [[shattuck]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 69 ---------------------------------------------
Returns true if the encoded password matches the raw password . --> Check if physiologist is peers --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String [[rawPasswordEncoded]] = digest ( [[salt]] , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , [[rawPasswordEncoded]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[peers]] ( CharSequence [[tutoring]] , String [[physiologist]] ) { String [[chloride]] = extractSalt ( [[physiologist]] ) ; String [[piston]] = digest ( [[chloride]] , [[tutoring]] ) ; return PasswordEncoderUtils . equals ( [[physiologist]] . toString ( ) , [[piston]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 70 ---------------------------------------------
Returns the given method --> get branco --> Socre: 1.0

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[branco]] ( String [[pathways]] ) { try { return HttpMethod . valueOf ( [[pathways]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 71 ---------------------------------------------
Checks if the version isChecks . --> [[[FAILED]]]

[[[[Adv]]]]: private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 72 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 65 / 5 / 2 / 72:   7%|▋         | 72/1000 [03:49<49:21,  3.19s/it][Succeeded / Failed / Skipped / Total] 65 / 5 / 2 / 72:   7%|▋         | 73/1000 [03:51<49:05,  3.18s/it][Succeeded / Failed / Skipped / Total] 66 / 5 / 2 / 73:   7%|▋         | 73/1000 [03:51<49:05,  3.18s/it][Succeeded / Failed / Skipped / Total] 66 / 5 / 2 / 73:   7%|▋         | 74/1000 [04:01<50:23,  3.27s/it][Succeeded / Failed / Skipped / Total] 67 / 5 / 2 / 74:   7%|▋         | 74/1000 [04:01<50:23,  3.27s/it][Succeeded / Failed / Skipped / Total] 67 / 5 / 2 / 74:   8%|▊         | 75/1000 [04:04<50:11,  3.26s/it][Succeeded / Failed / Skipped / Total] 68 / 5 / 2 / 75:   8%|▊         | 75/1000 [04:04<50:11,  3.26s/it][Succeeded / Failed / Skipped / Total] 69 / 5 / 2 / 76:   8%|▊         | 76/1000 [04:04<49:28,  3.21s/it][Succeeded / Failed / Skipped / Total] 69 / 5 / 2 / 76:   8%|▊         | 77/1000 [04:06<49:19,  3.21s/it][Succeeded / Failed / Skipped / Total] 70 / 5 / 2 / 77:   8%|▊         | 77/1000 [04:06<49:19,  3.21s/it][Succeeded / Failed / Skipped / Total] 71 / 5 / 2 / 78:   8%|▊         | 78/1000 [04:09<49:10,  3.20s/it][Succeeded / Failed / Skipped / Total] 71 / 5 / 2 / 78:   8%|▊         | 79/1000 [04:11<48:51,  3.18s/it]Disables the given spring version . --> set powders --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[powders]] ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 73 ---------------------------------------------
AttributeExchange config . --> Add a farrow --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String [[identifierPattern]] ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[palates]] ( String [[farrow]] ) { AttributeExchangeConfigurer [[schoolyard]] = new AttributeExchangeConfigurer ( [[farrow]] ) ; this . attributeExchangeConfigurers . add ( [[schoolyard]] ) ; return [[schoolyard]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 74 ---------------------------------------------
Creates the error response . --> Generates a phoned Response --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[bara]] ( ) { Response < ? > [[phoned]] ; try { [[phoned]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[phoned]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[phoned]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[phoned]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 75 ---------------------------------------------
Request OAuth 2 client . --> Convenience method for the HttpSecuritys --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[chords]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[patricio]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[patricio]] ) ; return [[patricio]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 76 ---------------------------------------------
Retrieve the configurer . --> Default isotope --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[sergent]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[isotope]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[isotope]] ) ; return [[isotope]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 77 ---------------------------------------------
Performs the actual LDAP function . --> Create syn accounts --> Socre: 1.0

[[[[Adv]]]]: public boolean [[compare]] ( final String dn , final String attributeName , final Object value ) { final String [[comparisonFilter]] = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > [[results]] = [[ctx]] . search ( dn , [[comparisonFilter]] , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( [[results]] . hasMore ( ) ) ; LdapUtils . closeEnumeration ( [[results]] ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean [[synonymous]] ( final String dn , final String attributeName , final Object value ) { final String [[cassettes]] = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext [[miny]] ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > [[achievements]] = [[miny]] . search ( dn , [[cassettes]] , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( [[achievements]] . hasMore ( ) ) ; LdapUtils . closeEnumeration ( [[achievements]] ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 78 ---------------------------------------------
Retrieves an entry from the LDAP server . --> Execute a plan on a vertex --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String [[dn]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { Attributes [[attrs]] = [[ctx]] . getAttributes ( [[dn]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[murri]] ( final String [[scotia]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[croak]] ) throws NamingException { Attributes [[obstructing]] = [[croak]] . getAttributes ( [[scotia]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 79 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 72 / 5 / 2 / 79:   8%|▊         | 79/1000 [04:11<48:51,  3.18s/it][Succeeded / Failed / Skipped / Total] 73 / 5 / 2 / 80:   8%|▊         | 80/1000 [04:25<50:53,  3.32s/it][Succeeded / Failed / Skipped / Total] 73 / 5 / 2 / 80:   8%|▊         | 81/1000 [04:28<50:45,  3.31s/it][Succeeded / Failed / Skipped / Total] 74 / 5 / 2 / 81:   8%|▊         | 81/1000 [04:28<50:45,  3.31s/it][Succeeded / Failed / Skipped / Total] 74 / 5 / 2 / 81:   8%|▊         | 82/1000 [04:29<50:12,  3.28s/it][Succeeded / Failed / Skipped / Total] 75 / 5 / 2 / 82:   8%|▊         | 82/1000 [04:29<50:12,  3.28s/it][Succeeded / Failed / Skipped / Total] 75 / 5 / 2 / 82:   8%|▊         | 83/1000 [04:29<49:39,  3.25s/it][Succeeded / Failed / Skipped / Total] 76 / 5 / 2 / 83:   8%|▊         | 83/1000 [04:29<49:39,  3.25s/it][Succeeded / Failed / Skipped / Total] 76 / 5 / 2 / 83:   8%|▊         | 84/1000 [04:32<49:29,  3.24s/it]Returns a new ChannelSecurityConfigurer . --> Get the ChannelSecurityConfig --> Socre: 1.0

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[lysander]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 80 ---------------------------------------------
Creates a new ScheduledExecutorService . --> Helper method to establish an active thread pool --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[establishing]] ( ThreadFactory [[installing]] ) { final ScheduledExecutorService [[awk]] = Executors . newScheduledThreadPool ( 1 , [[installing]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[awk]] ) ; return [[awk]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 81 ---------------------------------------------
Search for a single entry . --> Searches for the given entry under DN --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName [[ctxBaseDn]] = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + [[ctxBaseDn]] + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName [[loudspeakers]] = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + [[loudspeakers]] + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 82 ---------------------------------------------
Build a searchControls . --> Get a searchControls --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[umbrella]] ( SearchControls [[brrrr]] ) { return new SearchControls ( [[brrrr]] . getSearchScope ( ) , [[brrrr]] . getCountLimit ( ) , [[brrrr]] . getTimeLimit ( ) , [[brrrr]] . getReturningAttributes ( ) , RETURN_OBJECT , [[brrrr]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 83 ---------------------------------------------
Calculates the amount of time in milliseconds . --> Calculates amount of time units --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[appeased]] ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 84 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 77 / 5 / 2 / 84:   8%|▊         | 84/1000 [04:32<49:29,  3.24s/it][Succeeded / Failed / Skipped / Total] 77 / 5 / 2 / 84:   8%|▊         | 85/1000 [04:35<49:23,  3.24s/it][Succeeded / Failed / Skipped / Total] 78 / 5 / 2 / 85:   8%|▊         | 85/1000 [04:35<49:23,  3.24s/it][Succeeded / Failed / Skipped / Total] 78 / 5 / 2 / 85:   9%|▊         | 86/1000 [04:36<48:56,  3.21s/it][Succeeded / Failed / Skipped / Total] 79 / 5 / 2 / 86:   9%|▊         | 86/1000 [04:36<48:56,  3.21s/it][Succeeded / Failed / Skipped / Total] 79 / 5 / 2 / 86:   9%|▊         | 87/1000 [04:38<48:46,  3.21s/it]Lookup primary keys . --> region > Galoot --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > [[sids]] ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int [[i]] = 0 ; for ( Long toFind : findNow ) { [[i]] ++ ; ps . setLong ( [[i]] , toFind ) ; } } } , new ProcessResultSet ( acls , [[sids]] ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[galoot]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > [[peeved]] ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int [[jes]] = 0 ; for ( Long toFind : findNow ) { [[jes]] ++ ; ps . setLong ( [[jes]] , toFind ) ; } } } , new ProcessResultSet ( acls , [[peeved]] ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 85 ---------------------------------------------
Create embedded server . --> Create an embedded server --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element [[element]] , ParserContext parserContext ) { Object source = parserContext . extractSource ( [[element]] ) ; String suffix = [[element]] . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String [[port]] = [[element]] . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( [[port]] ) ) { [[port]] = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + [[port]] ) ; } } String [[url]] = "ldap://127.0.0.1:" + [[port]] + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( [[url]] ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition [[apacheContainer]] = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; [[apacheContainer]] . setSource ( source ) ; [[apacheContainer]] . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String [[ldifs]] = [[element]] . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( [[ldifs]] ) ) { [[ldifs]] = OPT_DEFAULT_LDIF_FILE ; } [[apacheContainer]] . getConstructorArgumentValues ( ) . addGenericArgumentValue ( [[ldifs]] ) ; [[apacheContainer]] . getPropertyValues ( ) . addPropertyValue ( "port" , [[port]] ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + [[url]] ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , [[element]] ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , [[apacheContainer]] ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element [[strand]] , ParserContext parserContext ) { Object source = parserContext . extractSource ( [[strand]] ) ; String suffix = [[strand]] . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String [[havre]] = [[strand]] . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( [[havre]] ) ) { [[havre]] = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + [[havre]] ) ; } } String [[footer]] = "ldap://127.0.0.1:" + [[havre]] + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( [[footer]] ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition [[irritates]] = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; [[irritates]] . setSource ( source ) ; [[irritates]] . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String [[legendre]] = [[strand]] . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( [[legendre]] ) ) { [[legendre]] = OPT_DEFAULT_LDIF_FILE ; } [[irritates]] . getConstructorArgumentValues ( ) . addGenericArgumentValue ( [[legendre]] ) ; [[irritates]] . getPropertyValues ( ) . addPropertyValue ( "port" , [[havre]] ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + [[footer]] ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , [[strand]] ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , [[irritates]] ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 86 ---------------------------------------------
Create the servlet api filter . --> Create servletApiFilter . --> Socre: 1.0

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String [[provideServletApi]] = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[provideServletApi]] ) ) { [[provideServletApi]] = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( [[provideServletApi]] ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String [[restricts]] = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[restricts]] ) ) { [[restricts]] = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( [[restricts]] ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 87 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 5 / 2 / 87:   9%|▊         | 87/1000 [04:38<48:46,  3.21s/it][Succeeded / Failed / Skipped / Total] 80 / 5 / 2 / 87:   9%|▉         | 88/1000 [04:42<48:52,  3.22s/it][Succeeded / Failed / Skipped / Total] 81 / 5 / 2 / 88:   9%|▉         | 88/1000 [04:42<48:52,  3.22s/it][Succeeded / Failed / Skipped / Total] 81 / 5 / 2 / 88:   9%|▉         | 89/1000 [04:43<48:20,  3.18s/it][Succeeded / Failed / Skipped / Total] 81 / 5 / 3 / 89:   9%|▉         | 89/1000 [04:43<48:20,  3.18s/it][Succeeded / Failed / Skipped / Total] 81 / 5 / 3 / 89:   9%|▉         | 90/1000 [04:55<49:48,  3.28s/it][Succeeded / Failed / Skipped / Total] 82 / 5 / 3 / 90:   9%|▉         | 90/1000 [04:55<49:48,  3.28s/it][Succeeded / Failed / Skipped / Total] 82 / 5 / 3 / 90:   9%|▉         | 91/1000 [04:56<49:21,  3.26s/it][Succeeded / Failed / Skipped / Total] 83 / 5 / 3 / 91:   9%|▉         | 91/1000 [04:56<49:21,  3.26s/it][Succeeded / Failed / Skipped / Total] 83 / 5 / 3 / 91:   9%|▉         | 92/1000 [05:10<51:00,  3.37s/it][Succeeded / Failed / Skipped / Total] 84 / 5 / 3 / 92:   9%|▉         | 92/1000 [05:10<51:00,  3.37s/it][Succeeded / Failed / Skipped / Total] 84 / 5 / 3 / 92:   9%|▉         | 93/1000 [05:13<50:59,  3.37s/it][Succeeded / Failed / Skipped / Total] 84 / 6 / 3 / 93:   9%|▉         | 93/1000 [05:13<50:59,  3.37s/it][Succeeded / Failed / Skipped / Total] 84 / 6 / 3 / 93:   9%|▉         | 94/1000 [05:19<51:23,  3.40s/it]Creates the Jaas API . --> For debugging --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String [[ATT_JAAS_API_PROVISION]] = "jaas-api-provision" ; final String [[DEF_JAAS_API_PROVISION]] = "false" ; String [[provideJaasApi]] = httpElt . getAttribute ( [[ATT_JAAS_API_PROVISION]] ) ; if ( ! StringUtils . hasText ( [[provideJaasApi]] ) ) { [[provideJaasApi]] = [[DEF_JAAS_API_PROVISION]] ; } if ( "true" . equals ( [[provideJaasApi]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[alon]] ( ) { final String [[GELB]] = "jaas-api-provision" ; final String [[ORIANA]] = "false" ; String [[habitual]] = httpElt . getAttribute ( [[GELB]] ) ; if ( ! StringUtils . hasText ( [[habitual]] ) ) { [[habitual]] = [[ORIANA]] ; } if ( "true" . equals ( [[habitual]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Gets the search for multiple attributes . --> jittery --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String base , final String filter , final Object [ ] [[params]] , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[jittery]] ( final String base , final String filter , final Object [ ] [[splint]] , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 89 ---------------------------------------------
Register a new spring - security filter . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 90 ---------------------------------------------
Create a new instance of the type resolver . --> Get the navy method --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[navy]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[culmination]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[culmination]] = [[culmination]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[culmination]] = [[culmination]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[culmination]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 91 ---------------------------------------------
Gets the token for a series . --> Gets a PersistentRemOUTMeToken by Symbolverware --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[bros]] ( String [[silverware]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[silverware]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[silverware]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[silverware]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[silverware]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 92 ---------------------------------------------
Returns a new Cipher . --> Returns the calculating string --> Socre: 1.0

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[lopsided]] ( String [[calculating]] ) { try { return Cipher . getInstance ( [[calculating]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 93 ---------------------------------------------
Returns the number of elements in this list . --> [[[FAILED]]]

[[[[Adv]]]]: public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
[Succeeded / Failed / Skipped / Total] 85 / 6 / 3 / 94:   9%|▉         | 94/1000 [05:19<51:23,  3.40s/it][Succeeded / Failed / Skipped / Total] 85 / 6 / 3 / 94:  10%|▉         | 95/1000 [05:30<52:32,  3.48s/it][Succeeded / Failed / Skipped / Total] 86 / 6 / 3 / 95:  10%|▉         | 95/1000 [05:30<52:32,  3.48s/it][Succeeded / Failed / Skipped / Total] 86 / 6 / 3 / 95:  10%|▉         | 96/1000 [05:31<52:00,  3.45s/it][Succeeded / Failed / Skipped / Total] 86 / 7 / 3 / 96:  10%|▉         | 96/1000 [05:31<52:00,  3.45s/it][Succeeded / Failed / Skipped / Total] 87 / 7 / 3 / 97:  10%|▉         | 97/1000 [05:31<51:25,  3.42s/it][Succeeded / Failed / Skipped / Total] 87 / 7 / 3 / 97:  10%|▉         | 98/1000 [05:33<51:07,  3.40s/it][Succeeded / Failed / Skipped / Total] 88 / 7 / 3 / 98:  10%|▉         | 98/1000 [05:33<51:07,  3.40s/it][Succeeded / Failed / Skipped / Total] 89 / 7 / 3 / 99:  10%|▉         | 99/1000 [05:36<51:05,  3.40s/it][Succeeded / Failed / Skipped / Total] 89 / 7 / 3 / 99:  10%|█         | 100/1000 [05:46<52:02,  3.47s/it]--------------------------------------------- Result 94 ---------------------------------------------
Gets the SpringSecurity core version . --> transmissions from SpringSecurityCoreVersion --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[transmissions]] ( ) { Properties [[personage]] = new Properties ( ) ; try { [[personage]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[personage]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 95 ---------------------------------------------
Checks if properties are set . --> Should be called afterPropertiesSet --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[hillsides]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 96 ---------------------------------------------
Get all roles of a collection of attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 97 ---------------------------------------------
Build the user details . --> Returns a new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails instance --> Socre: 1.0

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest [[context]] ) { Collection < String > j2eeUserRoles = getUserRoles ( [[context]] ) ; Collection < ? extends GrantedAuthority > [[userGas]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + [[userGas]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[context]] , [[userGas]] ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[betting]] ( HttpServletRequest [[sources]] ) { Collection < String > j2eeUserRoles = getUserRoles ( [[sources]] ) ; Collection < ? extends GrantedAuthority > [[stricken]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + [[stricken]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[sources]] , [[stricken]] ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 98 ---------------------------------------------
Check content length . --> F743 - 6 --> Socre: 1.0

[[[[Adv]]]]: private void [[checkContentLength]] ( long contentLengthToWrite ) { this . [[contentWritten]] += contentLengthToWrite ; boolean isBodyFullyWritten = this . [[contentLength]] > 0 && this . [[contentWritten]] >= this . [[contentLength]] ; int bufferSize = getBufferSize ( ) ; boolean [[requiresFlush]] = bufferSize > 0 && this . [[contentWritten]] >= bufferSize ; if ( isBodyFullyWritten || [[requiresFlush]] ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void [[relaxation]] ( long contentLengthToWrite ) { this . [[thurber]] += contentLengthToWrite ; boolean isBodyFullyWritten = this . [[rhetoric]] > 0 && this . [[thurber]] >= this . [[rhetoric]] ; int bufferSize = getBufferSize ( ) ; boolean [[envision]] = bufferSize > 0 && this . [[thurber]] >= bufferSize ; if ( isBodyFullyWritten || [[envision]] ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 99 ---------------------------------------------
Perform a filter . --> governance implementation --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest [[request]] , ServletResponse [[response]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[request]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[request]] , ( HttpServletResponse ) [[response]] ) ; } chain . doFilter ( [[request]] , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[governance]] ( ServletRequest [[applications]] , ServletResponse [[meet]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[applications]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[applications]] , ( HttpServletResponse ) [[meet]] ) ; } chain . doFilter ( [[applications]] , [[meet]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 100 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 90 / 7 / 3 / 100:  10%|█         | 100/1000 [05:46<52:02,  3.47s/it][Succeeded / Failed / Skipped / Total] 91 / 7 / 3 / 101:  10%|█         | 101/1000 [05:47<51:28,  3.44s/it][Succeeded / Failed / Skipped / Total] 91 / 7 / 3 / 101:  10%|█         | 102/1000 [05:47<51:02,  3.41s/it][Succeeded / Failed / Skipped / Total] 92 / 7 / 3 / 102:  10%|█         | 102/1000 [05:47<51:02,  3.41s/it][Succeeded / Failed / Skipped / Total] 93 / 7 / 3 / 103:  10%|█         | 103/1000 [06:05<53:02,  3.55s/it][Succeeded / Failed / Skipped / Total] 93 / 7 / 3 / 103:  10%|█         | 104/1000 [06:07<52:47,  3.53s/it][Succeeded / Failed / Skipped / Total] 94 / 7 / 3 / 104:  10%|█         | 104/1000 [06:07<52:47,  3.53s/it][Succeeded / Failed / Skipped / Total] 94 / 7 / 3 / 104:  10%|█         | 105/1000 [06:09<52:30,  3.52s/it][Succeeded / Failed / Skipped / Total] 95 / 7 / 3 / 105:  10%|█         | 105/1000 [06:09<52:30,  3.52s/it][Succeeded / Failed / Skipped / Total] 95 / 7 / 3 / 105:  11%|█         | 106/1000 [06:11<52:12,  3.50s/it]Update the authentication default value . --> Logout failure --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[stalker]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[sylvie]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[sylvie]] != null && ! [[sylvie]] . isCustomLogoutSuccess ( ) ) { [[sylvie]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 101 ---------------------------------------------
Checks if the principal has changed . --> Is this principalChanged? --> Socre: 1.0

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "[[Presentable]]" == "[[Presentable]]" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 102 ---------------------------------------------
Set the loginProcessingUrl . --> Build a T far --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String [[loginProcessingUrl]] ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[farthings]] ( String [[limps]] ) { this . loginProcessingUrl = [[farthings]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[farthings]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 103 ---------------------------------------------
Map the list of authorities . --> map all bureaucrats --> Socre: 1.0

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[authorities]] ) { HashSet < GrantedAuthority > [[mapped]] = new HashSet <> ( [[authorities]] . size ( ) ) ; for ( GrantedAuthority authority : [[authorities]] ) { [[mapped]] . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[mapped]] . add ( defaultAuthority ) ; } return [[mapped]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[bureaucrats]] ) { HashSet < GrantedAuthority > [[designate]] = new HashSet <> ( [[bureaucrats]] . size ( ) ) ; for ( GrantedAuthority authority : [[bureaucrats]] ) { [[designate]] . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[designate]] . add ( defaultAuthority ) ; } return [[designate]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 104 ---------------------------------------------
Encodes the array of cookie tokens . --> Encode the cookie --> Socre: 1.0

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder [[sb]] = new StringBuilder ( ) ; for ( int [[i]] = 0 ; [[i]] < cookieTokens . length ; [[i]] ++ ) { try { [[sb]] . append ( URLEncoder . encode ( cookieTokens [ [[i]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[i]] < cookieTokens . length - 1 ) { [[sb]] . append ( DELIMITER ) ; } } String [[value]] = [[sb]] . toString ( ) ; [[sb]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( [[value]] . getBytes ( ) ) ) ) ; while ( [[sb]] . charAt ( [[sb]] . length ( ) - 1 ) == ' ' ) { [[sb]] . deleteCharAt ( [[sb]] . length ( ) - 1 ) ; } return [[sb]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder [[gsw]] = new StringBuilder ( ) ; for ( int [[ti]] = 0 ; [[ti]] < cookieTokens . length ; [[ti]] ++ ) { try { [[gsw]] . append ( URLEncoder . encode ( cookieTokens [ [[ti]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[ti]] < cookieTokens . length - 1 ) { [[gsw]] . append ( DELIMITER ) ; } } String [[appreciate]] = [[gsw]] . toString ( ) ; [[gsw]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( [[appreciate]] . getBytes ( ) ) ) ) ; while ( [[gsw]] . charAt ( [[gsw]] . length ( ) - 1 ) == ' ' ) { [[gsw]] . deleteCharAt ( [[gsw]] . length ( ) - 1 ) ; } return [[gsw]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 105 ---------------------------------------------
Map the given password value . --> tires a string --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[tires]] ( Object [[contributors]] ) { if ( ! ( [[contributors]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 106 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 7 / 3 / 106:  11%|█         | 106/1000 [06:11<52:12,  3.50s/it][Succeeded / Failed / Skipped / Total] 96 / 7 / 3 / 106:  11%|█         | 107/1000 [06:11<51:42,  3.47s/it][Succeeded / Failed / Skipped / Total] 97 / 7 / 3 / 107:  11%|█         | 107/1000 [06:11<51:42,  3.47s/it][Succeeded / Failed / Skipped / Total] 97 / 7 / 3 / 107:  11%|█         | 108/1000 [06:15<51:40,  3.48s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 3 / 108:  11%|█         | 108/1000 [06:15<51:40,  3.48s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 3 / 108:  11%|█         | 109/1000 [06:24<52:21,  3.53s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 3 / 109:  11%|█         | 109/1000 [06:24<52:21,  3.53s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 3 / 109:  11%|█         | 110/1000 [06:41<54:09,  3.65s/it][Succeeded / Failed / Skipped / Total] 100 / 7 / 3 / 110:  11%|█         | 110/1000 [06:41<54:09,  3.65s/it][Succeeded / Failed / Skipped / Total] 100 / 7 / 3 / 110:  11%|█         | 111/1000 [06:47<54:20,  3.67s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 3 / 111:  11%|█         | 111/1000 [06:47<54:20,  3.67s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 3 / 111:  11%|█         | 112/1000 [07:03<55:56,  3.78s/it]Get the sorted order . --> Mriffen marshalling implementation --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[marshalling]] ( Comparator < ? super T > [[griffen]] ) { ObjectHelper . requireNonNull ( [[griffen]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[griffen]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 107 ---------------------------------------------
Update the access defaults . --> eco method --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[eco]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 108 ---------------------------------------------
Extracts the cookie name from the request . --> store thekeepers --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] [[cookies]] = request . getCookies ( ) ; if ( ( [[cookies]] == null ) || ( [[cookies]] . length == 0 ) ) { return null ; } for ( Cookie cookie : [[cookies]] ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[storekeepers]] ( HttpServletRequest request ) { Cookie [ ] [[cheesecake]] = request . getCookies ( ) ; if ( ( [[cheesecake]] == null ) || ( [[cheesecake]] . length == 0 ) ) { return null ; } for ( Cookie cookie : [[cheesecake]] ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 109 ---------------------------------------------
Get the query string . --> For testing purposes only --> Socre: 1.0

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest request , final Pattern [[artifactPattern]] ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String [[result]] = [[artifactPattern]] . matcher ( query ) . replaceFirst ( "" ) ; if ( [[result]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[romanced]] ( final HttpServletRequest request , final Pattern [[earmuffs]] ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String [[consequences]] = [[earmuffs]] . matcher ( query ) . replaceFirst ( "" ) ; if ( [[consequences]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 110 ---------------------------------------------
Log out the authentication . --> F743 - 2 --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest request , HttpServletResponse [[response]] , Authentication [[authentication]] ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession [[session]] = request . getSession ( "[[False]]" != "[[False]]" ) ; if ( [[session]] != null ) { logger . debug ( "Invalidating session: " + [[session]] . getId ( ) ) ; [[session]] . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[humane]] ( HttpServletRequest request , HttpServletResponse [[responded]] , Authentication [[assurance]] ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession [[conferences]] = request . getSession ( "[[Awry]]" != "[[Awry]]" ) ; if ( [[conferences]] != null ) { logger . debug ( "Invalidating session: " + [[conferences]] . getId ( ) ) ; [[conferences]] . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 111 ---------------------------------------------
Perform the authentication token . --> Return null if it fails --> Socre: 1.0

[[[[Adv]]]]: public Authentication [[authenticate]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication [[licensed]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[requisitions]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[institutions]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 112 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 102 / 7 / 3 / 112:  11%|█         | 112/1000 [07:03<55:56,  3.78s/it][Succeeded / Failed / Skipped / Total] 102 / 7 / 3 / 112:  11%|█▏        | 113/1000 [07:09<56:09,  3.80s/it][Succeeded / Failed / Skipped / Total] 103 / 7 / 3 / 113:  11%|█▏        | 113/1000 [07:09<56:09,  3.80s/it][Succeeded / Failed / Skipped / Total] 103 / 7 / 3 / 113:  11%|█▏        | 114/1000 [07:12<56:01,  3.79s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 3 / 114:  11%|█▏        | 114/1000 [07:12<56:01,  3.79s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 3 / 114:  12%|█▏        | 115/1000 [07:20<56:30,  3.83s/it][Succeeded / Failed / Skipped / Total] 105 / 7 / 3 / 115:  12%|█▏        | 115/1000 [07:20<56:30,  3.83s/it][Succeeded / Failed / Skipped / Total] 105 / 7 / 3 / 115:  12%|█▏        | 116/1000 [07:21<56:04,  3.81s/it][Succeeded / Failed / Skipped / Total] 106 / 7 / 3 / 116:  12%|█▏        | 116/1000 [07:21<56:04,  3.81s/it][Succeeded / Failed / Skipped / Total] 106 / 7 / 3 / 116:  12%|█▏        | 117/1000 [07:24<55:54,  3.80s/it][Succeeded / Failed / Skipped / Total] 107 / 7 / 3 / 117:  12%|█▏        | 117/1000 [07:24<55:54,  3.80s/it][Succeeded / Failed / Skipped / Total] 107 / 7 / 3 / 117:  12%|█▏        | 118/1000 [07:26<55:36,  3.78s/it]Resolves a method argument . --> Perform a bennie --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter [[parameter]] , BindingContext [[bindingContext]] , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[parameter]] . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object [[p]] = resolveSecurityContext ( [[parameter]] , a ) ; Mono < Object > [[o]] = Mono . justOrEmpty ( [[p]] ) ; return adapter == null ? [[o]] : Mono . just ( adapter . fromPublisher ( [[o]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[bennie]] ( MethodParameter [[configuration]] , BindingContext [[bicycles]] , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[configuration]] . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object [[percentage]] = resolveSecurityContext ( [[configuration]] , a ) ; Mono < Object > [[rs]] = Mono . justOrEmpty ( [[percentage]] ) ; return adapter == null ? [[rs]] : Mono . just ( adapter . fromPublisher ( [[rs]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 113 ---------------------------------------------
Set the context environment properties . --> Set the value of the Hashtable --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[enabling]] ( Map < String , Object > [[suburbs]] ) { Assert . notEmpty ( [[suburbs]] , "environment must not be empty" ) ; this . [[feigning]] = new Hashtable <> ( [[suburbs]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 114 ---------------------------------------------
Checks if the next AtomicReference has been thrown . --> tony method --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Subscription > [[upstream]] , Subscription [[next]] , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean [[tony]] ( AtomicReference < Subscription > [[upward]] , Subscription [[following]] , Class < ? > [[concur]] ) { ObjectHelper . requireNonNull ( [[following]] , "next is null" ) ; if ( ! [[upward]] . compareAndSet ( null , [[following]] ) ) { [[following]] . cancel ( ) ; if ( [[upward]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[concur]] ) ; } return "[[Mock]]" != "[[Mock]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 115 ---------------------------------------------
Returns the service port . --> Create cas service url --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL casServiceUrl ) { int [[port]] = casServiceUrl . getPort ( ) ; if ( [[port]] == - 1 ) { [[port]] = casServiceUrl . getDefaultPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[mufti]] ( URL casServiceUrl ) { int [[rica]] = casServiceUrl . getPort ( ) ; if ( [[rica]] == - 1 ) { [[rica]] = casServiceUrl . getDefaultPort ( ) ; } return [[rica]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 116 ---------------------------------------------
Init user processing . --> Create new user details --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder [[userBuilder]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[userBuilder]] . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder [[carols]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[carols]] . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 117 ---------------------------------------------
Render the tag . --> handedly --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[handedly]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 118 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 108 / 7 / 3 / 118:  12%|█▏        | 118/1000 [07:26<55:36,  3.78s/it][Succeeded / Failed / Skipped / Total] 108 / 7 / 3 / 118:  12%|█▏        | 119/1000 [07:27<55:15,  3.76s/it][Succeeded / Failed / Skipped / Total] 109 / 7 / 3 / 119:  12%|█▏        | 119/1000 [07:27<55:15,  3.76s/it][Succeeded / Failed / Skipped / Total] 109 / 7 / 3 / 119:  12%|█▏        | 120/1000 [07:32<55:17,  3.77s/it][Succeeded / Failed / Skipped / Total] 110 / 7 / 3 / 120:  12%|█▏        | 120/1000 [07:32<55:17,  3.77s/it][Succeeded / Failed / Skipped / Total] 110 / 7 / 3 / 120:  12%|█▏        | 121/1000 [07:32<54:47,  3.74s/it][Succeeded / Failed / Skipped / Total] 111 / 7 / 3 / 121:  12%|█▏        | 121/1000 [07:32<54:47,  3.74s/it][Succeeded / Failed / Skipped / Total] 111 / 7 / 3 / 121:  12%|█▏        | 122/1000 [07:37<54:54,  3.75s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 3 / 122:  12%|█▏        | 122/1000 [07:37<54:54,  3.75s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 3 / 122:  12%|█▏        | 123/1000 [07:45<55:18,  3.78s/it]Process authentication . --> mopani operation --> Socre: 1.0

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[mopani]] ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 119 ---------------------------------------------
Build the provider url . --> Liefert das ein --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[spanks]] ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 120 ---------------------------------------------
Adds the Pkce parameters . --> tough users --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > [[attributes]] , Map < String , Object > [[additionalParameters]] ) { String codeVerifier = this . [[codeVerifierGenerator]] . generateKey ( ) ; [[attributes]] . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[toughen]] ( Map < String , Object > [[personage]] , Map < String , Object > [[rafiq]] ) { String codeVerifier = this . [[naïve]] . generateKey ( ) ; [[personage]] . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[rafiq]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[rafiq]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[rafiq]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 121 ---------------------------------------------
Determines if the request requires authentication . --> Determine if the invitations is on --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest [[request]] , final HttpServletResponse [[response]] ) { final boolean [[serviceTicketRequest]] = [[serviceTicketRequest]] ( [[request]] , [[response]] ) ; final boolean [[result]] = [[serviceTicketRequest]] || proxyReceptorRequest ( [[request]] ) || ( proxyTicketRequest ( [[serviceTicketRequest]] , [[request]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[hinting]] ( final HttpServletRequest [[invitations]] , final HttpServletResponse [[replica]] ) { final boolean [[brzezinski]] = [[brzezinski]] ( [[invitations]] , [[replica]] ) ; final boolean [[results]] = [[brzezinski]] || proxyReceptorRequest ( [[invitations]] ) || ( proxyTicketRequest ( [[brzezinski]] , [[invitations]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[results]] ) ; } return [[results]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 122 ---------------------------------------------
Gets the full URL for the server . --> Perform a recounting operation --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[recounting]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
[Succeeded / Failed / Skipped / Total] 113 / 7 / 3 / 123:  12%|█▏        | 123/1000 [07:45<55:18,  3.78s/it][Succeeded / Failed / Skipped / Total] 113 / 7 / 3 / 123:  12%|█▏        | 124/1000 [07:47<55:01,  3.77s/it][Succeeded / Failed / Skipped / Total] 114 / 7 / 3 / 124:  12%|█▏        | 124/1000 [07:47<55:01,  3.77s/it][Succeeded / Failed / Skipped / Total] 114 / 7 / 3 / 124:  12%|█▎        | 125/1000 [07:50<54:55,  3.77s/it][Succeeded / Failed / Skipped / Total] 115 / 7 / 3 / 125:  12%|█▎        | 125/1000 [07:50<54:55,  3.77s/it][Succeeded / Failed / Skipped / Total] 115 / 7 / 3 / 125:  13%|█▎        | 126/1000 [07:51<54:30,  3.74s/it][Succeeded / Failed / Skipped / Total] 116 / 7 / 3 / 126:  13%|█▎        | 126/1000 [07:51<54:30,  3.74s/it][Succeeded / Failed / Skipped / Total] 116 / 7 / 3 / 126:  13%|█▎        | 127/1000 [08:03<55:20,  3.80s/it][Succeeded / Failed / Skipped / Total] 117 / 7 / 3 / 127:  13%|█▎        | 127/1000 [08:03<55:20,  3.80s/it][Succeeded / Failed / Skipped / Total] 117 / 7 / 3 / 127:  13%|█▎        | 128/1000 [08:29<57:49,  3.98s/it][Succeeded / Failed / Skipped / Total] 118 / 7 / 3 / 128:  13%|█▎        | 128/1000 [08:29<57:49,  3.98s/it][Succeeded / Failed / Skipped / Total] 118 / 7 / 3 / 128:  13%|█▎        | 129/1000 [08:42<58:47,  4.05s/it]--------------------------------------------- Result 123 ---------------------------------------------
Get UserDetailsService . --> Get UserDetailsService --> Socre: 1.0

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[turd]] ( ) { Map < String , ? > [[squalls]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[squalls]] . size ( ) == 0 ) { [[squalls]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[squalls]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[squalls]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[squalls]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 124 ---------------------------------------------
Create the MethodSecurityExpressionOperations . --> Create a MethodSecurityExpressionOperations --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[balance]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 125 ---------------------------------------------
Gets the JWK set . --> get jwkSet --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . webClient . get ( ) . uri ( this . [[jwkSetURL]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[unsupervised]] ( ) { return this . webClient . get ( ) . uri ( this . [[thebes]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 126 ---------------------------------------------
URL encode a string . --> Generates a couse . --> Socre: 1.0

[[[[Adv]]]]: private String [[utf8UrlEncode]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String [[couse]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 127 ---------------------------------------------
Gets the active user groups . --> Returns all GrantedAuthority objects --> Socre: 1.0

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[early]] ( ) { List < String > [[unformed]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[senators]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[unformed]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[unformed]] + " mapped to Granted Authorities: " + [[senators]] ) ; } return [[senators]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 128 ---------------------------------------------
Loads a user . --> Create a new bookends --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken [[token]] = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( [[token]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[bookends]] ( final Assertion [[complaint]] ) { final CasAssertionAuthenticationToken [[wafer]] = new CasAssertionAuthenticationToken ( [[complaint]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( [[wafer]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 129 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 119 / 7 / 3 / 129:  13%|█▎        | 129/1000 [08:42<58:47,  4.05s/it][Succeeded / Failed / Skipped / Total] 119 / 7 / 3 / 129:  13%|█▎        | 130/1000 [08:49<59:02,  4.07s/it][Succeeded / Failed / Skipped / Total] 120 / 7 / 3 / 130:  13%|█▎        | 130/1000 [08:49<59:02,  4.07s/it][Succeeded / Failed / Skipped / Total] 120 / 7 / 3 / 130:  13%|█▎        | 131/1000 [09:02<59:57,  4.14s/it][Succeeded / Failed / Skipped / Total] 121 / 7 / 3 / 131:  13%|█▎        | 131/1000 [09:02<59:57,  4.14s/it][Succeeded / Failed / Skipped / Total] 121 / 7 / 3 / 131:  13%|█▎        | 132/1000 [09:03<59:35,  4.12s/it][Succeeded / Failed / Skipped / Total] 122 / 7 / 3 / 132:  13%|█▎        | 132/1000 [09:03<59:35,  4.12s/it][Succeeded / Failed / Skipped / Total] 122 / 7 / 3 / 132:  13%|█▎        | 133/1000 [09:06<59:23,  4.11s/it][Succeeded / Failed / Skipped / Total] 123 / 7 / 3 / 133:  13%|█▎        | 133/1000 [09:06<59:23,  4.11s/it][Succeeded / Failed / Skipped / Total] 123 / 7 / 3 / 133:  13%|█▎        | 134/1000 [09:07<59:01,  4.09s/it]Sets the cookie . --> pongo method --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] tokens , int [[maxAge]] , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie [[cookie]] = new Cookie ( cookieName , cookieValue ) ; [[cookie]] . setMaxAge ( [[maxAge]] ) ; [[cookie]] . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { [[cookie]] . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { [[cookie]] . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { [[cookie]] . setSecure ( request . isSecure ( ) ) ; } else { [[cookie]] . setSecure ( useSecureCookie ) ; } [[cookie]] . setHttpOnly ( "True" == "True" ) ; response . addCookie ( [[cookie]] ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[pongo]] ( String [ ] tokens , int [[ordnung]] , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie [[cannoli]] = new Cookie ( cookieName , cookieValue ) ; [[cannoli]] . setMaxAge ( [[ordnung]] ) ; [[cannoli]] . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { [[cannoli]] . setDomain ( cookieDomain ) ; } if ( [[ordnung]] < 1 ) { [[cannoli]] . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { [[cannoli]] . setSecure ( request . isSecure ( ) ) ; } else { [[cannoli]] . setSecure ( useSecureCookie ) ; } [[cannoli]] . setHttpOnly ( "True" == "True" ) ; response . addCookie ( [[cannoli]] ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 130 ---------------------------------------------
Concatenate arrays . --> Mohawk function --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... arrays ) { int [[length]] = 0 ; for ( byte [ ] [[array]] : arrays ) { [[length]] += [[array]] . length ; } byte [ ] [[newArray]] = new byte [ [[length]] ] ; int [[destPos]] = 0 ; for ( byte [ ] [[array]] : arrays ) { System . arraycopy ( [[array]] , 0 , [[newArray]] , [[destPos]] , [[array]] . length ) ; [[destPos]] += [[array]] . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[mohawk]] ( byte [ ] ... arrays ) { int [[life]] = 0 ; for ( byte [ ] [[cab]] : arrays ) { [[life]] += [[cab]] . length ; } byte [ ] [[foodstuffs]] = new byte [ [[life]] ] ; int [[langer]] = 0 ; for ( byte [ ] [[cab]] : arrays ) { System . arraycopy ( [[cab]] , 0 , [[foodstuffs]] , [[langer]] , [[cab]] . length ) ; [[langer]] += [[cab]] . length ; } return [[foodstuffs]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 131 ---------------------------------------------
Create a sub - array --> subarray --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] [[array]] , int beginIndex , int [[endIndex]] ) { int [[length]] = [[endIndex]] - beginIndex ; byte [ ] subarray = new byte [ [[length]] ] ; System . arraycopy ( [[array]] , beginIndex , subarray , 0 , [[length]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] [[cabins]] , int beginIndex , int [[cyberpunk]] ) { int [[timetables]] = [[cyberpunk]] - beginIndex ; byte [ ] subarray = new byte [ [[timetables]] ] ; System . arraycopy ( [[cabins]] , beginIndex , subarray , 0 , [[timetables]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 132 ---------------------------------------------
Determines if the authenticated authentication is authenticated . --> ratify the given authentication --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[ratify]] ( ) { Authentication [[reliability]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[reliability]] != null && [[reliability]] . isAuthenticated ( ) && ! ( [[reliability]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 133 ---------------------------------------------
Gets the principal . --> Fully flip method --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[principal]] = [[authentication]] . getPrincipal ( ) ; if ( [[principal]] instanceof LdapUserDetails ) { LdapUserDetails [[details]] = ( LdapUserDetails ) [[principal]] ; return [[details]] . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[flip]] ( ) { Authentication [[validated]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[validated]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[key]] = [[validated]] . getPrincipal ( ) ; if ( [[key]] instanceof LdapUserDetails ) { LdapUserDetails [[particulars]] = ( LdapUserDetails ) [[key]] ; return [[particulars]] . getDn ( ) ; } else if ( [[validated]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 134 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 124 / 7 / 3 / 134:  13%|█▎        | 134/1000 [09:07<59:01,  4.09s/it][Succeeded / Failed / Skipped / Total] 124 / 7 / 3 / 134:  14%|█▎        | 135/1000 [09:08<58:31,  4.06s/it][Succeeded / Failed / Skipped / Total] 125 / 7 / 3 / 135:  14%|█▎        | 135/1000 [09:08<58:31,  4.06s/it][Succeeded / Failed / Skipped / Total] 125 / 7 / 3 / 135:  14%|█▎        | 136/1000 [09:13<58:37,  4.07s/it][Succeeded / Failed / Skipped / Total] 126 / 7 / 3 / 136:  14%|█▎        | 136/1000 [09:13<58:37,  4.07s/it][Succeeded / Failed / Skipped / Total] 126 / 7 / 3 / 136:  14%|█▎        | 137/1000 [09:21<58:57,  4.10s/it][Succeeded / Failed / Skipped / Total] 127 / 7 / 3 / 137:  14%|█▎        | 137/1000 [09:21<58:57,  4.10s/it][Succeeded / Failed / Skipped / Total] 127 / 7 / 3 / 137:  14%|█▍        | 138/1000 [09:22<58:32,  4.08s/it][Succeeded / Failed / Skipped / Total] 128 / 7 / 3 / 138:  14%|█▍        | 138/1000 [09:22<58:32,  4.08s/it][Succeeded / Failed / Skipped / Total] 128 / 7 / 3 / 138:  14%|█▍        | 139/1000 [09:23<58:11,  4.06s/it][Succeeded / Failed / Skipped / Total] 129 / 7 / 3 / 139:  14%|█▍        | 139/1000 [09:23<58:11,  4.06s/it][Succeeded / Failed / Skipped / Total] 129 / 7 / 3 / 139:  14%|█▍        | 140/1000 [09:26<57:57,  4.04s/it]Creates a map from the org map . --> Pre - computes information about penetrates . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[result]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[result]] . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[accomplishments]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > [[penetrates]] : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[penetrates]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[accomplishments]] . put ( ( String ) [[penetrates]] . getKey ( ) , getGrantedAuthorityCollection ( [[penetrates]] . getValue ( ) ) ) ; } return [[accomplishments]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 135 ---------------------------------------------
Get the list of roles associated with this object . --> Get all roles . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[dreamt]] ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 136 ---------------------------------------------
Get the list of roles associated with the specified attributes . --> Get prematurely --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > [[gaList]] = new ArrayList <> ( ) ; for ( String [[attribute]] : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( [[attribute]] ) ; if ( c != null ) { [[gaList]] . addAll ( c ) ; } } [[gaList]] . trimToSize ( ) ; return [[gaList]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[houseboat]] ( Collection < String > [[bestows]] ) { ArrayList < GrantedAuthority > [[prematurely]] = new ArrayList <> ( ) ; for ( String [[peculiarities]] : [[bestows]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( [[peculiarities]] ) ; if ( c != null ) { [[prematurely]] . addAll ( c ) ; } } [[prematurely]] . trimToSize ( ) ; return [[prematurely]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 137 ---------------------------------------------
Adds the authority collection . --> Check if importance is non - null --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[pothead]] ( Collection < GrantedAuthority > [[conclusions]] , Object [[importance]] ) { if ( [[importance]] == null ) { return ; } if ( [[importance]] instanceof Collection < ? > ) { [[pothead]] ( [[conclusions]] , ( Collection < ? > ) [[importance]] ) ; } else if ( [[importance]] instanceof Object [ ] ) { [[pothead]] ( [[conclusions]] , ( Object [ ] ) [[importance]] ) ; } else if ( [[importance]] instanceof String ) { [[pothead]] ( [[conclusions]] , ( String ) [[importance]] ) ; } else if ( [[importance]] instanceof GrantedAuthority ) { [[conclusions]] . add ( ( GrantedAuthority ) [[importance]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[importance]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 138 ---------------------------------------------
Returns the J2EE principal . --> get primordial --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[lapdog]] ( HttpServletRequest [[gargoyle]] ) { Object [[primordial]] = [[gargoyle]] . getUserPrincipal ( ) == null ? null : [[gargoyle]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[primordial]] ) ; } return [[primordial]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 139 ---------------------------------------------
Invokes a method invocation . --> Finds the plead of the given element --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[plead]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 140 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 130 / 7 / 3 / 140:  14%|█▍        | 140/1000 [09:26<57:57,  4.04s/it][Succeeded / Failed / Skipped / Total] 130 / 7 / 3 / 140:  14%|█▍        | 141/1000 [09:28<57:43,  4.03s/it][Succeeded / Failed / Skipped / Total] 131 / 7 / 3 / 141:  14%|█▍        | 141/1000 [09:28<57:43,  4.03s/it][Succeeded / Failed / Skipped / Total] 131 / 7 / 3 / 141:  14%|█▍        | 142/1000 [09:41<58:32,  4.09s/it][Succeeded / Failed / Skipped / Total] 132 / 7 / 3 / 142:  14%|█▍        | 142/1000 [09:41<58:32,  4.09s/it][Succeeded / Failed / Skipped / Total] 132 / 7 / 3 / 142:  14%|█▍        | 143/1000 [09:41<58:06,  4.07s/it][Succeeded / Failed / Skipped / Total] 133 / 7 / 3 / 143:  14%|█▍        | 143/1000 [09:41<58:06,  4.07s/it][Succeeded / Failed / Skipped / Total] 133 / 7 / 3 / 143:  14%|█▍        | 144/1000 [10:26<1:02:04,  4.35s/it][Succeeded / Failed / Skipped / Total] 134 / 7 / 3 / 144:  14%|█▍        | 144/1000 [10:26<1:02:04,  4.35s/it][Succeeded / Failed / Skipped / Total] 134 / 7 / 3 / 144:  14%|█▍        | 145/1000 [10:37<1:02:40,  4.40s/it]Returns the named role . --> punishing functions --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[punishing]] ( String [[functions]] ) { Assert . isTrue ( ! [[functions]] . startsWith ( "ROLE_" ) , ( ) -> [[functions]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[functions]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 141 ---------------------------------------------
Returns the roles associated with any given roles . --> method to get the rolle array --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int [[i]] = 0 ; [[i]] < [[roles]] . length ; [[i]] ++ ) { [[roles]] [ [[i]] ] = "ROLE_" + [[roles]] [ [[i]] ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[corbusier]] ( String ... [[rolle]] ) { for ( int [[suis]] = 0 ; [[suis]] < [[rolle]] . length ; [[suis]] ++ ) { [[rolle]] [ [[suis]] ] = "ROLE_" + [[rolle]] [ [[suis]] ] ; } return [[rolle]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 142 ---------------------------------------------
Process an autoLogin cookie . --> F743 - 1 --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String [[presentedSeries]] = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( [[presentedSeries]] ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[coyotes]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String [[dacha]] = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( [[dacha]] ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 143 ---------------------------------------------
Get the WebSphere principal . --> Methode d une --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[mouche]] ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 144 ---------------------------------------------
Build redirect url for request . --> tubas test --> Socre: 1.0

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest [[request]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[request]] ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder [[urlBuilder]] = new RedirectUrlBuilder ( ) ; [[urlBuilder]] . setScheme ( "https" ) ; [[urlBuilder]] . setServerName ( [[request]] . getServerName ( ) ) ; [[urlBuilder]] . setPort ( httpsPort . intValue ( ) ) ; [[urlBuilder]] . setContextPath ( [[request]] . getContextPath ( ) ) ; [[urlBuilder]] . setServletPath ( [[request]] . getServletPath ( ) ) ; [[urlBuilder]] . setPathInfo ( [[request]] . getPathInfo ( ) ) ; [[urlBuilder]] . setQuery ( [[request]] . getQueryString ( ) ) ; return [[urlBuilder]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[tubas]] ( HttpServletRequest [[demands]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[demands]] ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder [[hypothermia]] = new RedirectUrlBuilder ( ) ; [[hypothermia]] . setScheme ( "https" ) ; [[hypothermia]] . setServerName ( [[demands]] . getServerName ( ) ) ; [[hypothermia]] . setPort ( httpsPort . intValue ( ) ) ; [[hypothermia]] . setContextPath ( [[demands]] . getContextPath ( ) ) ; [[hypothermia]] . setServletPath ( [[demands]] . getServletPath ( ) ) ; [[hypothermia]] . setPathInfo ( [[demands]] . getPathInfo ( ) ) ; [[hypothermia]] . setQuery ( [[demands]] . getQueryString ( ) ) ; return [[hypothermia]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 145 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 135 / 7 / 3 / 145:  14%|█▍        | 145/1000 [10:37<1:02:40,  4.40s/it][Succeeded / Failed / Skipped / Total] 135 / 7 / 3 / 145:  15%|█▍        | 146/1000 [10:40<1:02:28,  4.39s/it][Succeeded / Failed / Skipped / Total] 136 / 7 / 3 / 146:  15%|█▍        | 146/1000 [10:40<1:02:28,  4.39s/it][Succeeded / Failed / Skipped / Total] 136 / 7 / 3 / 146:  15%|█▍        | 147/1000 [10:46<1:02:28,  4.39s/it][Succeeded / Failed / Skipped / Total] 137 / 7 / 3 / 147:  15%|█▍        | 147/1000 [10:46<1:02:28,  4.39s/it][Succeeded / Failed / Skipped / Total] 137 / 7 / 3 / 147:  15%|█▍        | 148/1000 [10:47<1:02:08,  4.38s/it][Succeeded / Failed / Skipped / Total] 138 / 7 / 3 / 148:  15%|█▍        | 148/1000 [10:47<1:02:08,  4.38s/it][Succeeded / Failed / Skipped / Total] 139 / 7 / 3 / 149:  15%|█▍        | 149/1000 [10:47<1:01:39,  4.35s/it][Succeeded / Failed / Skipped / Total] 139 / 7 / 3 / 149:  15%|█▌        | 150/1000 [10:59<1:02:16,  4.40s/it][Succeeded / Failed / Skipped / Total] 140 / 7 / 3 / 150:  15%|█▌        | 150/1000 [10:59<1:02:16,  4.40s/it][Succeeded / Failed / Skipped / Total] 140 / 7 / 3 / 150:  15%|█▌        | 151/1000 [11:03<1:02:08,  4.39s/it]Generate login success token . --> dermatitis --> Socre: 1.0

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[persistentToken]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[persistentToken]] ) ; addCookie ( [[persistentToken]] , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[dermatitis]] ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[progeria]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[progeria]] ) ; addCookie ( [[progeria]] , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 146 ---------------------------------------------
Attempts to process the user . --> get the obedience of the request --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[obedience]] ( HttpServletRequest [[invite]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 147 ---------------------------------------------
Sets the exit user URL . --> dATest method --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[dullest]] ( String [[trenches]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[trenches]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[pornographic]] = createMatcher ( [[trenches]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 148 ---------------------------------------------
Filter springSecurityFilterChain Method . --> Bean . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter [[adapter]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[adapter]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[outmaneuvered]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter [[belkin]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[belkin]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 149 ---------------------------------------------
Display public page index --> Gets a random id --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[ambitious]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 150 ---------------------------------------------
Search for multiple attribute values . --> Removes multiple attributes from relied --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String [[base]] , final String filter , final Object [ ] params , final String [[attributeName]] ) { String [ ] [[attributeNames]] = new String [ ] { [[attributeName]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( [[base]] , filter , params , [[attributeNames]] ) ; Set < String > [[result]] = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[attributeName]] ) ; if ( values != null ) { [[result]] . addAll ( values ) ; } } return [[result]] ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[assuring]] ( final String [[relied]] , final String filter , final Object [ ] params , final String [[stains]] ) { String [ ] [[homers]] = new String [ ] { [[stains]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( [[relied]] , filter , params , [[homers]] ) ; Set < String > [[suite]] = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[stains]] ) ; if ( values != null ) { [[suite]] . addAll ( values ) ; } } return [[suite]] ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 151 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 141 / 7 / 3 / 151:  15%|█▌        | 151/1000 [11:03<1:02:08,  4.39s/it][Succeeded / Failed / Skipped / Total] 141 / 7 / 3 / 151:  15%|█▌        | 152/1000 [11:03<1:01:40,  4.36s/it][Succeeded / Failed / Skipped / Total] 141 / 7 / 4 / 152:  15%|█▌        | 152/1000 [11:03<1:01:40,  4.36s/it][Succeeded / Failed / Skipped / Total] 141 / 7 / 4 / 152:  15%|█▌        | 153/1000 [11:05<1:01:26,  4.35s/it][Succeeded / Failed / Skipped / Total] 142 / 7 / 4 / 153:  15%|█▌        | 153/1000 [11:05<1:01:26,  4.35s/it][Succeeded / Failed / Skipped / Total] 142 / 7 / 4 / 153:  15%|█▌        | 154/1000 [11:08<1:01:13,  4.34s/it][Succeeded / Failed / Skipped / Total] 143 / 7 / 4 / 154:  15%|█▌        | 154/1000 [11:08<1:01:13,  4.34s/it][Succeeded / Failed / Skipped / Total] 143 / 7 / 4 / 154:  16%|█▌        | 155/1000 [11:20<1:01:49,  4.39s/it][Succeeded / Failed / Skipped / Total] 144 / 7 / 4 / 155:  16%|█▌        | 155/1000 [11:20<1:01:49,  4.39s/it][Succeeded / Failed / Skipped / Total] 144 / 7 / 4 / 155:  16%|█▌        | 156/1000 [11:30<1:02:13,  4.42s/it][Succeeded / Failed / Skipped / Total] 145 / 7 / 4 / 156:  16%|█▌        | 156/1000 [11:30<1:02:13,  4.42s/it][Succeeded / Failed / Skipped / Total] 145 / 7 / 4 / 156:  16%|█▌        | 157/1000 [11:33<1:02:04,  4.42s/it][Succeeded / Failed / Skipped / Total] 145 / 8 / 4 / 157:  16%|█▌        | 157/1000 [11:33<1:02:04,  4.42s/it][Succeeded / Failed / Skipped / Total] 145 / 8 / 4 / 157:  16%|█▌        | 158/1000 [11:34<1:01:40,  4.39s/it]Decodes a JWT token . --> Decodes an insignia . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt decode ( String [[token]] ) throws JwtException { JWT [[jwt]] = parse ( [[token]] ) ; if ( [[jwt]] instanceof SignedJWT ) { Jwt [[createdJwt]] = createJwt ( [[token]] , [[jwt]] ) ; return validateJwt ( [[createdJwt]] ) ; } throw new JwtException ( "Unsupported algorithm of " + [[jwt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt decode ( String [[insignia]] ) throws JwtException { JWT [[wolof]] = parse ( [[insignia]] ) ; if ( [[wolof]] instanceof SignedJWT ) { Jwt [[hauling]] = createJwt ( [[insignia]] , [[wolof]] ) ; return validateJwt ( [[hauling]] ) ; } throw new JwtException ( "Unsupported algorithm of " + [[wolof]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 152 ---------------------------------------------
Convert Jwt jwt to collection . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 153 ---------------------------------------------
Checks if the current user is authenticated . --> Perform bolivian? --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[currentUser]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , [[currentUser]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[bama]] ( ) throws IOException { String [[recounting]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[bolivian]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[recounting]] , getUrl ( ) , getMethod ( ) , [[bolivian]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 154 ---------------------------------------------
Generates a CSRF token . --> Wrap the given invites . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . delegate . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[unaccounted]] ( HttpServletRequest [[invites]] ) { return wrap ( [[invites]] , this . delegate . generateToken ( [[invites]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 155 ---------------------------------------------
proxy ticket request . --> Does kirkpatrick? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean [[serviceTicketRequest]] , final HttpServletRequest request ) { if ( [[serviceTicketRequest]] ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[kirkpatrick]] ( final boolean [[banshees]] , final HttpServletRequest request ) { if ( [[banshees]] ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 156 ---------------------------------------------
Returns the shared object for the given type . --> Get the kevin for the given type --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[kevin]] > [[kevin]] getSharedObject ( Class < [[kevin]] > sharedType ) { return ( [[kevin]] ) this . [[yoda]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 157 ---------------------------------------------
Evaluates an access expression . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 158 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 146 / 8 / 4 / 158:  16%|█▌        | 158/1000 [11:34<1:01:40,  4.39s/it][Succeeded / Failed / Skipped / Total] 146 / 8 / 4 / 158:  16%|█▌        | 159/1000 [11:37<1:01:31,  4.39s/it][Succeeded / Failed / Skipped / Total] 147 / 8 / 4 / 159:  16%|█▌        | 159/1000 [11:37<1:01:31,  4.39s/it][Succeeded / Failed / Skipped / Total] 147 / 8 / 4 / 159:  16%|█▌        | 160/1000 [11:39<1:01:14,  4.37s/it][Succeeded / Failed / Skipped / Total] 148 / 8 / 4 / 160:  16%|█▌        | 160/1000 [11:39<1:01:14,  4.37s/it][Succeeded / Failed / Skipped / Total] 148 / 8 / 4 / 160:  16%|█▌        | 161/1000 [11:41<1:00:56,  4.36s/it][Succeeded / Failed / Skipped / Total] 149 / 8 / 4 / 161:  16%|█▌        | 161/1000 [11:41<1:00:56,  4.36s/it][Succeeded / Failed / Skipped / Total] 149 / 8 / 4 / 161:  16%|█▌        | 162/1000 [11:42<1:00:32,  4.33s/it][Succeeded / Failed / Skipped / Total] 149 / 9 / 4 / 162:  16%|█▌        | 162/1000 [11:42<1:00:32,  4.33s/it][Succeeded / Failed / Skipped / Total] 149 / 9 / 4 / 162:  16%|█▋        | 163/1000 [11:45<1:00:21,  4.33s/it][Succeeded / Failed / Skipped / Total] 150 / 9 / 4 / 163:  16%|█▋        | 163/1000 [11:45<1:00:21,  4.33s/it][Succeeded / Failed / Skipped / Total] 150 / 9 / 4 / 163:  16%|█▋        | 164/1000 [11:46<1:00:01,  4.31s/it][Succeeded / Failed / Skipped / Total] 151 / 9 / 4 / 164:  16%|█▋        | 164/1000 [11:46<1:00:01,  4.31s/it][Succeeded / Failed / Skipped / Total] 151 / 9 / 4 / 164:  16%|█▋        | 165/1000 [11:52<1:00:04,  4.32s/it]Delete the specified permission . --> Get user s permissions --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long [[contactId]] , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact [[contact]] = contactManager . getById ( [[contactId]] ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( [[contact]] , sidObject , permission ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "contact" , [[contact]] ) ; [[model]] . put ( "sid" , sidObject ) ; [[model]] . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , [[model]] ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[comforter]] ( @ RequestParam ( "contactId" ) long [[composite]] , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact [[tying]] = contactManager . getById ( [[composite]] ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( [[tying]] , sidObject , permission ) ; Map < String , Object > [[shape]] = new HashMap <> ( ) ; [[shape]] . put ( "contact" , [[tying]] ) ; [[shape]] . put ( "sid" , sidObject ) ; [[shape]] . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , [[shape]] ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 159 ---------------------------------------------
Get the resource for the given users string . --> Convert talkers to InMemoryResource --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[users]] ) { InMemoryResource resource = new InMemoryResource ( [[users]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[talkers]] ) { InMemoryResource resource = new InMemoryResource ( [[talkers]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 160 ---------------------------------------------
Gets the default role prefix . --> returns the coastal function --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String defaultRolePrefix , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( defaultRolePrefix ) ) { return [[role]] ; } return defaultRolePrefix + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[coastal]] ( String defaultRolePrefix , String [[function]] ) { if ( [[function]] == null ) { return [[function]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[function]] ; } if ( [[function]] . startsWith ( defaultRolePrefix ) ) { return [[function]] ; } return defaultRolePrefix + [[function]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 161 ---------------------------------------------
Returns the attribute values . --> Gets rendezvous . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[guzman]] ( String [[rendezvous]] ) { List < String > [[wake]] = null ; if ( attributes != null ) { [[wake]] = attributes . get ( [[rendezvous]] ) ; } if ( [[wake]] == null ) { [[wake]] = Collections . emptyList ( ) ; } return [[wake]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 162 ---------------------------------------------
Displays permission for contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 163 ---------------------------------------------
Encodes a string . --> Create a byte array from a CharSequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence string ) { try { ByteBuffer [[bytes]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] [[bytesCopy]] = new byte [ [[bytes]] . limit ( ) ] ; System . arraycopy ( [[bytes]] . array ( ) , 0 , [[bytesCopy]] , 0 , [[bytes]] . limit ( ) ) ; return [[bytesCopy]] ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[quantify]] ( CharSequence string ) { try { ByteBuffer [[bead]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] [[cloister]] = new byte [ [[bead]] . limit ( ) ] ; System . arraycopy ( [[bead]] . array ( ) , 0 , [[cloister]] , 0 , [[bead]] . limit ( ) ) ; return [[cloister]] ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 164 ---------------------------------------------
Decodes the specified bytes . --> codeword an array of hex --> Socre: 1.0

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[codeword]] ( byte [ ] [[hex]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[hex]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
[Succeeded / Failed / Skipped / Total] 152 / 9 / 4 / 165:  16%|█▋        | 165/1000 [11:52<1:00:04,  4.32s/it][Succeeded / Failed / Skipped / Total] 152 / 9 / 4 / 165:  17%|█▋        | 166/1000 [11:54<59:51,  4.31s/it]  [Succeeded / Failed / Skipped / Total] 152 / 10 / 4 / 166:  17%|█▋        | 166/1000 [11:54<59:51,  4.31s/it][Succeeded / Failed / Skipped / Total] 152 / 10 / 4 / 166:  17%|█▋        | 167/1000 [11:56<59:35,  4.29s/it][Succeeded / Failed / Skipped / Total] 153 / 10 / 4 / 167:  17%|█▋        | 167/1000 [11:56<59:35,  4.29s/it][Succeeded / Failed / Skipped / Total] 153 / 10 / 4 / 167:  17%|█▋        | 168/1000 [12:02<59:38,  4.30s/it][Succeeded / Failed / Skipped / Total] 154 / 10 / 4 / 168:  17%|█▋        | 168/1000 [12:02<59:38,  4.30s/it][Succeeded / Failed / Skipped / Total] 154 / 10 / 4 / 168:  17%|█▋        | 169/1000 [12:18<1:00:31,  4.37s/it][Succeeded / Failed / Skipped / Total] 155 / 10 / 4 / 169:  17%|█▋        | 169/1000 [12:18<1:00:31,  4.37s/it][Succeeded / Failed / Skipped / Total] 155 / 10 / 4 / 169:  17%|█▋        | 170/1000 [12:27<1:00:49,  4.40s/it][Succeeded / Failed / Skipped / Total] 156 / 10 / 4 / 170:  17%|█▋        | 170/1000 [12:27<1:00:49,  4.40s/it][Succeeded / Failed / Skipped / Total] 156 / 10 / 4 / 170:  17%|█▋        | 171/1000 [12:47<1:02:00,  4.49s/it]--------------------------------------------- Result 165 ---------------------------------------------
Get the first attribute value . --> Get swordsmith Method . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[swordsmith]] ( String [[appointing]] ) { List < String > result = getAttributeValues ( [[appointing]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 166 ---------------------------------------------
Add a new permission --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 167 ---------------------------------------------
Get a view page for a contact --> Retrieve touching touching --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int [[contactId]] ) { Contact [[contact]] = contactManager . getById ( Long . valueOf ( [[contactId]] ) ) ; Acl [[acl]] = aclService . readAclById ( new ObjectIdentityImpl ( [[contact]] ) ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "contact" , [[contact]] ) ; [[model]] . put ( "acl" , [[acl]] ) ; return new ModelAndView ( "adminPermission" , "model" , [[model]] ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[beatty]] ( @ RequestParam ( "contactId" ) int [[hungarians]] ) { Contact [[touching]] = contactManager . getById ( Long . valueOf ( [[hungarians]] ) ) ; Acl [[foa]] = aclService . readAclById ( new ObjectIdentityImpl ( [[touching]] ) ) ; Map < String , Object > [[paradigm]] = new HashMap <> ( ) ; [[paradigm]] . put ( "contact" , [[touching]] ) ; [[paradigm]] . put ( "acl" , [[foa]] ) ; return new ModelAndView ( "adminPermission" , "model" , [[paradigm]] ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 168 ---------------------------------------------
Gets all config attributes . --> handrail --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[allAttributes]] . addAll ( attributeList ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[handrail]] ( ) { Set < ConfigAttribute > [[bloomberg]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[bloomberg]] . addAll ( attributeList ) ; } return [[bloomberg]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 169 ---------------------------------------------
Find attributes of a method . --> Return a list of attributes associated with this guises --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method [[method]] , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[predestined]] ( Method [[guises]] , Class < ? > [[disoriented]] ) { if ( [[disoriented]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[guises]] , [[disoriented]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 170 ---------------------------------------------
Cut the request . --> Returns a new instance of the response --> Socre: 1.0

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "[[True]]" == "[[True]]" ; return configurer ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . [[ehsaan]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[ehsaan]] = "[[Upstanding]]" == "[[Upstanding]]" ; return configurer ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 171 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 157 / 10 / 4 / 171:  17%|█▋        | 171/1000 [12:47<1:02:00,  4.49s/it][Succeeded / Failed / Skipped / Total] 157 / 10 / 4 / 171:  17%|█▋        | 172/1000 [12:48<1:01:39,  4.47s/it][Succeeded / Failed / Skipped / Total] 158 / 10 / 4 / 172:  17%|█▋        | 172/1000 [12:48<1:01:39,  4.47s/it][Succeeded / Failed / Skipped / Total] 158 / 10 / 4 / 172:  17%|█▋        | 173/1000 [12:59<1:02:08,  4.51s/it][Succeeded / Failed / Skipped / Total] 159 / 10 / 4 / 173:  17%|█▋        | 173/1000 [12:59<1:02:08,  4.51s/it][Succeeded / Failed / Skipped / Total] 159 / 10 / 4 / 173:  17%|█▋        | 174/1000 [13:09<1:02:28,  4.54s/it][Succeeded / Failed / Skipped / Total] 160 / 10 / 4 / 174:  17%|█▋        | 174/1000 [13:09<1:02:28,  4.54s/it][Succeeded / Failed / Skipped / Total] 160 / 10 / 4 / 174:  18%|█▊        | 175/1000 [13:12<1:02:18,  4.53s/it][Succeeded / Failed / Skipped / Total] 161 / 10 / 4 / 175:  18%|█▊        | 175/1000 [13:12<1:02:18,  4.53s/it][Succeeded / Failed / Skipped / Total] 161 / 10 / 4 / 175:  18%|█▊        | 176/1000 [13:16<1:02:10,  4.53s/it][Succeeded / Failed / Skipped / Total] 162 / 10 / 4 / 176:  18%|█▊        | 176/1000 [13:16<1:02:10,  4.53s/it][Succeeded / Failed / Skipped / Total] 162 / 10 / 4 / 176:  18%|█▊        | 177/1000 [13:28<1:02:38,  4.57s/it][Succeeded / Failed / Skipped / Total] 163 / 10 / 4 / 177:  18%|█▊        | 177/1000 [13:28<1:02:38,  4.57s/it][Succeeded / Failed / Skipped / Total] 163 / 10 / 4 / 177:  18%|█▊        | 178/1000 [13:41<1:03:12,  4.61s/it]Handle a bind exception . --> Declarative Services method --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String [[username]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[yves]] ( String userDn , String [[connectivity]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 172 ---------------------------------------------
Get a random contact . --> random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > [[contacts]] = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( [[contacts]] . size ( ) ) ; return [[contacts]] . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > [[communicates]] = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( [[communicates]] . size ( ) ) ; return [[communicates]] . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 173 ---------------------------------------------
Clear authentication attributes . --> Remove any existing HttpSessions --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession [[session]] = [[request]] . getSession ( "[[False]]" != "[[False]]" ) ; if ( [[session]] == null ) { return ; } [[session]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[tunney]] ( HttpServletRequest [[demand]] ) { HttpSession [[conference]] = [[demand]] . getSession ( "[[Falsify]]" != "[[Falsify]]" ) ; if ( [[conference]] == null ) { return ; } [[conference]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 174 ---------------------------------------------
Adds a secure method . --> archeological methods --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . methodMap . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[archeological]] ( RegisteredMethod [[methods]] , List < ConfigAttribute > [[elves]] ) { Assert . notNull ( [[methods]] , "RegisteredMethod required" ) ; Assert . notNull ( [[elves]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[methods]] + "] with attributes [" + [[elves]] + "]" ) ; } this . methodMap . put ( [[methods]] , [[elves]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 175 ---------------------------------------------
Checks if the mapped name is match . --> Parses a StringBuilder --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[pavillion]] ( String [[elaborate]] , String [[wisps]] ) { return ( [[wisps]] . endsWith ( "*" ) && [[elaborate]] . startsWith ( [[wisps]] . substring ( 0 , [[wisps]] . length ( ) - 1 ) ) ) || ( [[wisps]] . startsWith ( "*" ) && [[elaborate]] . endsWith ( [[wisps]] . substring ( 1 , [[wisps]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 176 ---------------------------------------------
Create redirect url . --> Save jehovah --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String [[serviceUrl]] ) { return CommonUtils . constructRedirectUrl ( this . [[loginUrl]] , this . [[serviceProperties]] . getServiceParameter ( ) , [[serviceUrl]] , this . [[serviceProperties]] . isSendRenew ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[save]] ( final String [[jehovah]] ) { return CommonUtils . constructRedirectUrl ( this . [[totality]] , this . [[snippet]] . getServiceParameter ( ) , [[jehovah]] , this . [[snippet]] . isSendRenew ( ) , "[[Mock]]" != "[[Mock]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 177 ---------------------------------------------
Call ticket request . --> Determines whether we should antigravity? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest [[request]] , final HttpServletResponse [[response]] ) { boolean [[result]] = super . requiresAuthentication ( [[request]] , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[antigravity]] ( final HttpServletRequest [[appealed]] , final HttpServletResponse [[reply]] ) { boolean [[suite]] = super . requiresAuthentication ( [[appealed]] , [[reply]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[suite]] ) ; } return [[suite]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 178 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 164 / 10 / 4 / 178:  18%|█▊        | 178/1000 [13:41<1:03:12,  4.61s/it][Succeeded / Failed / Skipped / Total] 164 / 10 / 4 / 178:  18%|█▊        | 179/1000 [13:43<1:02:57,  4.60s/it][Succeeded / Failed / Skipped / Total] 165 / 10 / 4 / 179:  18%|█▊        | 179/1000 [13:43<1:02:57,  4.60s/it][Succeeded / Failed / Skipped / Total] 165 / 10 / 4 / 179:  18%|█▊        | 180/1000 [14:02<1:03:57,  4.68s/it][Succeeded / Failed / Skipped / Total] 165 / 11 / 4 / 180:  18%|█▊        | 180/1000 [14:02<1:03:57,  4.68s/it][Succeeded / Failed / Skipped / Total] 165 / 11 / 4 / 180:  18%|█▊        | 181/1000 [14:09<1:04:03,  4.69s/it][Succeeded / Failed / Skipped / Total] 166 / 11 / 4 / 181:  18%|█▊        | 181/1000 [14:09<1:04:03,  4.69s/it][Succeeded / Failed / Skipped / Total] 166 / 11 / 4 / 181:  18%|█▊        | 182/1000 [14:20<1:04:25,  4.73s/it][Succeeded / Failed / Skipped / Total] 167 / 11 / 4 / 182:  18%|█▊        | 182/1000 [14:20<1:04:25,  4.73s/it][Succeeded / Failed / Skipped / Total] 167 / 11 / 4 / 182:  18%|█▊        | 183/1000 [14:30<1:04:44,  4.76s/it]Adds a contact . --> Get modes as string --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact [[form]] , BindingResult result ) { validator . validate ( [[form]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[incredible]] ( WebContact [[modes]] , BindingResult result ) { validator . validate ( [[modes]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[coordination]] = new Contact ( [[modes]] . getName ( ) , [[modes]] . getEmail ( ) ) ; contactManager . create ( [[coordination]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 179 ---------------------------------------------
Check if the filters are enabled . --> Check if we should be monitored . --> Socre: 1.0

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[mousetrap]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[mousetrap]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[mousetrap]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[mousetrap]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[mousetrap]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[mousetrap]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[mousetrap]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[mousetrap]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[mousetrap]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 180 ---------------------------------------------
Determines if a proxy is enabled . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 181 ---------------------------------------------
Sends an access HTTP request . --> F743 --> Socre: 1.0

[[[[Adv]]]]: public void commence ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[response]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void commence ( HttpServletRequest [[invited]] , HttpServletResponse [[cope]] , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[cope]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 182 ---------------------------------------------
Extract prefix . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[levar]] ( String [[yecch]] ) { if ( ! [[yecch]] . startsWith ( "{" ) ) { return null ; } int [[serafin]] = [[yecch]] . lastIndexOf ( ' ' ) ; if ( [[serafin]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[yecch]] . substring ( 0 , [[serafin]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 183 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 167 / 12 / 4 / 183:  18%|█▊        | 183/1000 [14:30<1:04:44,  4.76s/it][Succeeded / Failed / Skipped / Total] 167 / 12 / 4 / 183:  18%|█▊        | 184/1000 [14:31<1:04:23,  4.73s/it][Succeeded / Failed / Skipped / Total] 168 / 12 / 4 / 184:  18%|█▊        | 184/1000 [14:31<1:04:23,  4.73s/it][Succeeded / Failed / Skipped / Total] 168 / 12 / 4 / 184:  18%|█▊        | 185/1000 [14:38<1:04:32,  4.75s/it][Succeeded / Failed / Skipped / Total] 169 / 12 / 4 / 185:  18%|█▊        | 185/1000 [14:38<1:04:32,  4.75s/it][Succeeded / Failed / Skipped / Total] 169 / 12 / 4 / 185:  19%|█▊        | 186/1000 [14:42<1:04:20,  4.74s/it][Succeeded / Failed / Skipped / Total] 170 / 12 / 4 / 186:  19%|█▊        | 186/1000 [14:42<1:04:20,  4.74s/it][Succeeded / Failed / Skipped / Total] 170 / 12 / 4 / 186:  19%|█▊        | 187/1000 [14:44<1:04:04,  4.73s/it][Succeeded / Failed / Skipped / Total] 171 / 12 / 4 / 187:  19%|█▊        | 187/1000 [14:44<1:04:04,  4.73s/it][Succeeded / Failed / Skipped / Total] 171 / 12 / 4 / 187:  19%|█▉        | 188/1000 [14:49<1:04:00,  4.73s/it][Succeeded / Failed / Skipped / Total] 172 / 12 / 4 / 188:  19%|█▉        | 188/1000 [14:49<1:04:00,  4.73s/it][Succeeded / Failed / Skipped / Total] 172 / 12 / 4 / 188:  19%|█▉        | 189/1000 [14:57<1:04:10,  4.75s/it]Register access manager . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 184 ---------------------------------------------
Return true if actual matches expected array . --> Links two arrays --> Socre: 1.0

[[[[Adv]]]]: private boolean [[matches]] ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean [[linkage]] ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 185 ---------------------------------------------
Gets the authority list to set . --> Get all approb IDs --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority [[authority]] : userAuthorities ) { set . add ( [[authority]] . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[juni]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority [[approbation]] : userAuthorities ) { set . add ( [[approbation]] . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 186 ---------------------------------------------
Create service url . --> Check if cappuccino is enabled --> Socre: 1.0

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest [[request]] , final HttpServletResponse [[response]] ) { return CommonUtils . constructServiceUrl ( null , [[response]] , this . [[serviceProperties]] . getService ( ) , null , this . [[serviceProperties]] . getArtifactParameter ( ) , this . [[encodeServiceUrlWithSessionId]] ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[tristana]] ( final HttpServletRequest [[call]] , final HttpServletResponse [[replies]] ) { return CommonUtils . constructServiceUrl ( null , [[replies]] , this . [[subzero]] . getService ( ) , null , this . [[subzero]] . getArtifactParameter ( ) , this . [[cappuccino]] ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 187 ---------------------------------------------
Set the default failure url . --> Accessor for hernandez --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . [[defaultFailureUrl]] = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[hernandez]] ( String [[tiggers]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[tiggers]] ) , ( ) -> "'" + [[tiggers]] + "' is not a valid redirect URL" ) ; this . [[poolside]] = [[tiggers]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 188 ---------------------------------------------
Gets the cause . --> Return null if none found --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[throwableType]] = [[entry]] . getKey ( ) ; if ( [[throwableType]] . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor [[extractor]] = [[entry]] . getValue ( ) ; return [[extractor]] . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[arianne]] ( Throwable [[architects]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[intro]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[ttis]] = [[intro]] . getKey ( ) ; if ( [[ttis]] . isInstance ( [[architects]] ) ) { ThrowableCauseExtractor [[mixer]] = [[intro]] . getValue ( ) ; return [[mixer]] . extractCause ( [[architects]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 189 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 173 / 12 / 4 / 189:  19%|█▉        | 189/1000 [14:57<1:04:10,  4.75s/it][Succeeded / Failed / Skipped / Total] 173 / 12 / 4 / 189:  19%|█▉        | 190/1000 [15:03<1:04:11,  4.75s/it][Succeeded / Failed / Skipped / Total] 174 / 12 / 4 / 190:  19%|█▉        | 190/1000 [15:03<1:04:11,  4.75s/it][Succeeded / Failed / Skipped / Total] 174 / 12 / 4 / 190:  19%|█▉        | 191/1000 [15:11<1:04:18,  4.77s/it][Succeeded / Failed / Skipped / Total] 174 / 13 / 4 / 191:  19%|█▉        | 191/1000 [15:11<1:04:18,  4.77s/it][Succeeded / Failed / Skipped / Total] 174 / 13 / 4 / 191:  19%|█▉        | 192/1000 [15:17<1:04:20,  4.78s/it][Succeeded / Failed / Skipped / Total] 175 / 13 / 4 / 192:  19%|█▉        | 192/1000 [15:17<1:04:20,  4.78s/it][Succeeded / Failed / Skipped / Total] 175 / 13 / 4 / 192:  19%|█▉        | 193/1000 [16:05<1:07:19,  5.01s/it][Succeeded / Failed / Skipped / Total] 176 / 13 / 4 / 193:  19%|█▉        | 193/1000 [16:05<1:07:19,  5.01s/it][Succeeded / Failed / Skipped / Total] 177 / 13 / 4 / 194:  19%|█▉        | 194/1000 [16:06<1:06:53,  4.98s/it][Succeeded / Failed / Skipped / Total] 177 / 13 / 4 / 194:  20%|█▉        | 195/1000 [16:06<1:06:31,  4.96s/it]Resolves the resolved hidden inputs . --> Enter unscrupulous --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[enterprising]] ( Function < HttpServletRequest , Map < String , String > > [[unscrupulous]] ) { Assert . notNull ( [[unscrupulous]] , "resolveHiddenInputs cannot be null" ) ; this . [[stiffer]] = [[unscrupulous]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 190 ---------------------------------------------
Gets the identifier from the ResultSet . --> Makes a copy of a ResultSet --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable [[identifier]] , ResultSet [[resultSet]] ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( [[resultSet]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[resultSet]] ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( [[resultSet]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[heared]] ( Serializable [[reprobate]] , ResultSet [[buckeye]] ) throws SQLException { if ( isString ( [[reprobate]] ) && hasValidClassIdType ( [[buckeye]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[buckeye]] ) ) ) { [[reprobate]] = convertFromStringTo ( ( String ) [[reprobate]] , classIdTypeFrom ( [[buckeye]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 191 ---------------------------------------------
Build the request URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 192 ---------------------------------------------
Creates a list of OpenID attributes . --> eliminated attribute value --> Socre: 1.0

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String [[identifier]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[entry]] : idToAttributes . entrySet ( ) ) { if ( [[entry]] . getKey ( ) . matcher ( [[identifier]] ) . matches ( ) ) { return [[entry]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[eliminated]] ( String [[demotion]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[accesses]] : idToAttributes . entrySet ( ) ) { if ( [[accesses]] . getKey ( ) . matcher ( [[demotion]] ) . matches ( ) ) { return [[accesses]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 193 ---------------------------------------------
Returns the field with the given name . --> enoch method --> Socre: 1.0

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[enoch]] ( Class < ? > [[diogenes]] , String [[pandey]] ) throws IllegalStateException { Assert . notNull ( [[diogenes]] , "Class required" ) ; Assert . hasText ( [[pandey]] , "Field name required" ) ; try { return [[diogenes]] . getDeclaredField ( [[pandey]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 194 ---------------------------------------------
Creates an object identity . --> create orRetrieveClassPrimaryKey --> Socre: 1.0

[[[[Adv]]]]: protected void createObjectIdentity ( ObjectIdentity object , Sid [[owner]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[owner]] , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void createObjectIdentity ( ObjectIdentity object , Sid [[keeper]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[keeper]] , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 195 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 178 / 13 / 4 / 195:  20%|█▉        | 195/1000 [16:06<1:06:31,  4.96s/it][Succeeded / Failed / Skipped / Total] 178 / 14 / 4 / 196:  20%|█▉        | 196/1000 [16:07<1:06:07,  4.94s/it][Succeeded / Failed / Skipped / Total] 178 / 14 / 4 / 196:  20%|█▉        | 197/1000 [16:08<1:05:48,  4.92s/it][Succeeded / Failed / Skipped / Total] 179 / 14 / 4 / 197:  20%|█▉        | 197/1000 [16:08<1:05:48,  4.92s/it][Succeeded / Failed / Skipped / Total] 180 / 14 / 4 / 198:  20%|█▉        | 198/1000 [16:11<1:05:36,  4.91s/it][Succeeded / Failed / Skipped / Total] 180 / 14 / 4 / 198:  20%|█▉        | 199/1000 [16:14<1:05:23,  4.90s/it][Succeeded / Failed / Skipped / Total] 181 / 14 / 4 / 199:  20%|█▉        | 199/1000 [16:14<1:05:23,  4.90s/it][Succeeded / Failed / Skipped / Total] 182 / 14 / 4 / 200:  20%|██        | 200/1000 [16:20<1:05:22,  4.90s/it][Succeeded / Failed / Skipped / Total] 182 / 14 / 4 / 200:  20%|██        | 201/1000 [16:36<1:06:03,  4.96s/it]Create the list of ACE entries . --> reuse an AccessControlEntry --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl [[acl]] ) { if ( [[acl]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[acl]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = [[acl]] . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) [[acl]] . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "[[True]]" == "[[True]]" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[reuse]] ( final MutableAcl [[lfl]] ) { if ( [[lfl]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[lfl]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = [[lfl]] . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) [[lfl]] . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "[[Truthful]]" == "[[Truthful]]" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 196 ---------------------------------------------
Returns the any ServerWebExchange . --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 197 ---------------------------------------------
Create a private encryptor using the given password . --> Create new biochemistry --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[biochemistry]] ( CharSequence [[coding]] , CharSequence [[physiological]] ) { return new HexEncodingTextEncryptor ( stronger ( [[coding]] , [[physiological]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 198 ---------------------------------------------
Text encryptor text . --> Create an GZip TextEncryptor using the provided decoded and parsley --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[lexicon]] ( CharSequence [[decoded]] , CharSequence [[parsley]] ) { return new HexEncodingTextEncryptor ( standard ( [[decoded]] , [[parsley]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 199 ---------------------------------------------
Create a bounded TextEncryptor --> Create new TextEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[outnumber]] ( CharSequence password , CharSequence [[salted]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[salted]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 200 ---------------------------------------------
Attempts to load a user --> Perform a postscript --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken [[targetUserRequest]] ; String [[username]] = request . getParameter ( this . [[usernameParameter]] ) ; if ( [[username]] == null ) { [[username]] = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + [[username]] + "]" ) ; } UserDetails [[targetUser]] = this . userDetailsService . loadUserByUsername ( [[username]] ) ; this . userDetailsChecker . check ( [[targetUser]] ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[postscript]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken [[politician]] ; String [[guests]] = request . getParameter ( this . [[devastatingly]] ) ; if ( [[guests]] == null ) { [[guests]] = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + [[guests]] + "]" ) ; } UserDetails [[shelved]] = this . userDetailsService . loadUserByUsername ( [[guests]] ) ; this . userDetailsChecker . check ( [[shelved]] ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 201 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 183 / 14 / 4 / 201:  20%|██        | 201/1000 [16:36<1:06:03,  4.96s/it][Succeeded / Failed / Skipped / Total] 183 / 14 / 4 / 201:  20%|██        | 202/1000 [16:38<1:05:45,  4.94s/it][Succeeded / Failed / Skipped / Total] 184 / 14 / 4 / 202:  20%|██        | 202/1000 [16:38<1:05:45,  4.94s/it][Succeeded / Failed / Skipped / Total] 184 / 14 / 4 / 202:  20%|██        | 203/1000 [16:39<1:05:22,  4.92s/it][Succeeded / Failed / Skipped / Total] 185 / 14 / 4 / 203:  20%|██        | 203/1000 [16:39<1:05:22,  4.92s/it][Succeeded / Failed / Skipped / Total] 185 / 14 / 4 / 203:  20%|██        | 204/1000 [16:44<1:05:18,  4.92s/it][Succeeded / Failed / Skipped / Total] 186 / 14 / 4 / 204:  20%|██        | 204/1000 [16:44<1:05:18,  4.92s/it][Succeeded / Failed / Skipped / Total] 186 / 14 / 4 / 204:  20%|██        | 205/1000 [16:45<1:04:58,  4.90s/it][Succeeded / Failed / Skipped / Total] 186 / 15 / 4 / 205:  20%|██        | 205/1000 [16:45<1:04:58,  4.90s/it][Succeeded / Failed / Skipped / Total] 186 / 15 / 4 / 205:  21%|██        | 206/1000 [16:45<1:04:36,  4.88s/it][Succeeded / Failed / Skipped / Total] 187 / 15 / 4 / 206:  21%|██        | 206/1000 [16:45<1:04:36,  4.88s/it][Succeeded / Failed / Skipped / Total] 187 / 15 / 4 / 206:  21%|██        | 207/1000 [16:46<1:04:15,  4.86s/it]Save the saved request . --> warhols method --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest [[savedRequest]] = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "[[False]]" != "[[False]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[warhols]] ( HttpServletRequest [[applications]] , HttpServletResponse [[unanswerable]] ) { if ( requestMatcher . matches ( [[applications]] ) ) { DefaultSavedRequest [[polyglot]] = new DefaultSavedRequest ( [[applications]] , portResolver ) ; if ( createSessionAllowed || [[applications]] . getSession ( "[[Forger]]" != "[[Forger]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 202 ---------------------------------------------
Returns a path sequence that matches specified parameters . --> Create new simple server webExchangeMatcher --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod [[method]] , String ... [[patterns]] ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( [[patterns]] . length ) ; for ( String [[pattern]] : [[patterns]] ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[pattern]] , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[simple]] ( HttpMethod [[medio]] , String ... [[habits]] ) { List < ServerWebExchangeMatcher > [[saban]] = new ArrayList <> ( [[habits]] . length ) ; for ( String [[schemes]] : [[habits]] ) { [[saban]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[schemes]] , [[medio]] ) ) ; } return new OrServerWebExchangeMatcher ( [[saban]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 203 ---------------------------------------------
Checks if the given url is absolute . --> Deletes hot addresses --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "[[False]]" != "[[False]]" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[delia]] ( String [[hotmail]] ) { if ( [[hotmail]] == null ) { return "[[Spurious]]" != "[[Spurious]]" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[hotmail]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 204 ---------------------------------------------
Update an ObjectIdentity --> Update plessis implementation --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl [[acl]] ) { Long [[parentId]] = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; [[parentId]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , "True" == "True" ) ; int [[count]] = jdbcOperations . update ( [[updateObjectIdentity]] , [[parentId]] , ownerSid , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( [[count]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[plessis]] ( MutableAcl [[sah]] ) { Long [[oe]] = null ; if ( [[sah]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[sah]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[sah]] . getParentAcl ( ) . getObjectIdentity ( ) ; [[oe]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[sah]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[sah]] . getOwner ( ) , "True" == "True" ) ; int [[comte]] = jdbcOperations . update ( [[plessis]] , [[oe]] , ownerSid , Boolean . valueOf ( [[sah]] . isEntriesInheriting ( ) ) , [[sah]] . getId ( ) ) ; if ( [[comte]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 205 ---------------------------------------------
Determine the target URL . --> [[[FAILED]]]

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 206 ---------------------------------------------
Build the dn with the given username . --> Create a new DistinguishedName --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[eloquently]] ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 207 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 188 / 15 / 4 / 207:  21%|██        | 207/1000 [16:46<1:04:15,  4.86s/it][Succeeded / Failed / Skipped / Total] 188 / 15 / 4 / 207:  21%|██        | 208/1000 [16:48<1:03:59,  4.85s/it][Succeeded / Failed / Skipped / Total] 189 / 15 / 4 / 208:  21%|██        | 208/1000 [16:48<1:03:59,  4.85s/it][Succeeded / Failed / Skipped / Total] 189 / 15 / 4 / 208:  21%|██        | 209/1000 [16:53<1:03:56,  4.85s/it][Succeeded / Failed / Skipped / Total] 190 / 15 / 4 / 209:  21%|██        | 209/1000 [16:53<1:03:56,  4.85s/it][Succeeded / Failed / Skipped / Total] 190 / 15 / 4 / 209:  21%|██        | 210/1000 [16:56<1:03:44,  4.84s/it][Succeeded / Failed / Skipped / Total] 191 / 15 / 4 / 210:  21%|██        | 210/1000 [16:56<1:03:44,  4.84s/it][Succeeded / Failed / Skipped / Total] 191 / 15 / 4 / 210:  21%|██        | 211/1000 [16:58<1:03:28,  4.83s/it][Succeeded / Failed / Skipped / Total] 192 / 15 / 4 / 211:  21%|██        | 211/1000 [16:58<1:03:28,  4.83s/it][Succeeded / Failed / Skipped / Total] 192 / 15 / 4 / 211:  21%|██        | 212/1000 [16:59<1:03:08,  4.81s/it][Succeeded / Failed / Skipped / Total] 193 / 15 / 4 / 212:  21%|██        | 212/1000 [16:59<1:03:08,  4.81s/it][Succeeded / Failed / Skipped / Total] 193 / 15 / 4 / 212:  21%|██▏       | 213/1000 [16:59<1:02:46,  4.79s/it]Create a shared object --> Create theShared object . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > createSharedObjects ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > createSharedObjects ( ) { Map < Class < ? extends Object > , Object > [[sanctimonious]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sanctimonious]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sanctimonious]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sanctimonious]] . put ( ApplicationContext . class , context ) ; [[sanctimonious]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sanctimonious]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sanctimonious]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 208 ---------------------------------------------
Configures the JaasUsingLoop . --> F743 --> Socre: 1.0

[[[[Adv]]]]: private void [[configureJaasUsingLoop]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean [[alreadySet]] = "[[False]]" != "[[False]]" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { [[alreadySet]] = existing . equals ( loginConfigUrl ) ; if ( [[alreadySet]] ) { break ; } n ++ ; } if ( ! [[alreadySet]] ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void [[gardens]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean [[signage]] = "[[Deceptive]]" != "[[Deceptive]]" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { [[signage]] = existing . equals ( loginConfigUrl ) ; if ( [[signage]] ) { break ; } n ++ ; } if ( ! [[signage]] ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 209 ---------------------------------------------
Sets the target url parameter . --> region > hiro --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[hiro]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 210 ---------------------------------------------
Update the cache . --> If there is nozzles --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap cache , Object key , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[nozzles]] ( HashMap cache , Object key , Object [[appreciate]] ) { if ( [[appreciate]] == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , [[appreciate]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 211 ---------------------------------------------
Internal parse date . --> Convert a string to a Long --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int [[i]] = 0 ; ( [[date]] == null ) && ( [[i]] < [[formats]] . length ) ; [[i]] ++ ) { try { [[date]] = [[formats]] [ [[i]] ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[marlon]] ( String value , DateFormat [ ] [[formatted]] ) { Date [[dated]] = null ; for ( int [[suis]] = 0 ; ( [[dated]] == null ) && ( [[suis]] < [[formatted]] . length ) ; [[suis]] ++ ) { try { [[dated]] = [[formatted]] [ [[suis]] ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[dated]] == null ) { return null ; } return new Long ( [[dated]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 212 ---------------------------------------------
Sets the authentication details . --> Discard right -away --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[disproportionately]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken [[rightaway]] ) { [[rightaway]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 213 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 194 / 15 / 4 / 213:  21%|██▏       | 213/1000 [16:59<1:02:46,  4.79s/it][Succeeded / Failed / Skipped / Total] 194 / 15 / 4 / 213:  21%|██▏       | 214/1000 [17:00<1:02:28,  4.77s/it][Succeeded / Failed / Skipped / Total] 194 / 16 / 4 / 214:  21%|██▏       | 214/1000 [17:00<1:02:28,  4.77s/it][Succeeded / Failed / Skipped / Total] 194 / 16 / 4 / 214:  22%|██▏       | 215/1000 [17:01<1:02:09,  4.75s/it][Succeeded / Failed / Skipped / Total] 195 / 16 / 4 / 215:  22%|██▏       | 215/1000 [17:01<1:02:09,  4.75s/it][Succeeded / Failed / Skipped / Total] 195 / 16 / 4 / 215:  22%|██▏       | 216/1000 [17:04<1:01:57,  4.74s/it][Succeeded / Failed / Skipped / Total] 196 / 16 / 4 / 216:  22%|██▏       | 216/1000 [17:04<1:01:57,  4.74s/it][Succeeded / Failed / Skipped / Total] 196 / 16 / 4 / 216:  22%|██▏       | 217/1000 [17:05<1:01:42,  4.73s/it][Succeeded / Failed / Skipped / Total] 197 / 16 / 4 / 217:  22%|██▏       | 217/1000 [17:05<1:01:42,  4.73s/it][Succeeded / Failed / Skipped / Total] 197 / 16 / 4 / 217:  22%|██▏       | 218/1000 [17:20<1:02:12,  4.77s/it][Succeeded / Failed / Skipped / Total] 198 / 16 / 4 / 218:  22%|██▏       | 218/1000 [17:20<1:02:12,  4.77s/it][Succeeded / Failed / Skipped / Total] 198 / 16 / 4 / 218:  22%|██▏       | 219/1000 [17:27<1:02:14,  4.78s/it][Succeeded / Failed / Skipped / Total] 199 / 16 / 4 / 219:  22%|██▏       | 219/1000 [17:27<1:02:14,  4.78s/it][Succeeded / Failed / Skipped / Total] 199 / 16 / 4 / 219:  22%|██▏       | 220/1000 [17:28<1:01:55,  4.76s/it]Writes headers to the response . --> A advertisers message --> Socre: 1.0

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[allowFromValue]] = this . [[allowFromStrategy]] . getAllowFromValue ( [[request]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[allowFromValue]] ) ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[allowFromValue]] != null ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[allowFromValue]] ) ; } } } else { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[advertisers]] ( HttpServletRequest [[invite]] , HttpServletResponse [[answered]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[wig]] = this . [[prosecutions]] . getAllowFromValue ( [[invite]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[wig]] ) ) { if ( ! [[answered]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[answered]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[wig]] != null ) { if ( ! [[answered]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[answered]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[wig]] ) ; } } } else { [[answered]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 214 ---------------------------------------------
Gets the parent directory . --> [[[FAILED]]]

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 215 ---------------------------------------------
Gets the time artificSphere groups . --> Try to obtain a String lubin --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String [[securityName]] ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[lubin]] ( final String [[sales]] ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 216 ---------------------------------------------
Build a DistinguishedName for the specified group . --> Returns the DistinguishedName for the grouping --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[ghajini]] ( String [[grouping]] ) { DistinguishedName [[pp]] = new DistinguishedName ( groupSearchBase ) ; [[pp]] . add ( groupRoleAttributeName , [[grouping]] . toLowerCase ( ) ) ; return [[pp]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 217 ---------------------------------------------
Called by the SessionAuthenticationStrategy . --> F743 - 3 --> Socre: 1.0

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > [[sessions]] , int allowableSessions , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[erzurum]] ( List < SessionInformation > [[afternoons]] , int allowableSessions , SessionRegistry [[record]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[afternoons]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 218 ---------------------------------------------
Returns the list of filters . --> Return list of filters --> Socre: 1.0

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest request ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( request ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[tying]] ( HttpServletRequest request ) { for ( SecurityFilterChain [[channel]] : filterChains ) { if ( [[channel]] . matches ( request ) ) { return [[channel]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 219 ---------------------------------------------
Copies the source authentication token . --> gorse --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication [[dest]] ) { if ( ( [[dest]] instanceof AbstractAuthenticationToken ) && ( [[dest]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) [[dest]] ; token . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[gse]] ( Authentication [[melt]] , Authentication [[baal]] ) { if ( ( [[baal]] instanceof AbstractAuthenticationToken ) && ( [[baal]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) [[baal]] ; token . setDetails ( [[melt]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 220 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 200 / 16 / 4 / 220:  22%|██▏       | 220/1000 [17:28<1:01:55,  4.76s/it][Succeeded / Failed / Skipped / Total] 200 / 16 / 4 / 220:  22%|██▏       | 221/1000 [17:32<1:01:50,  4.76s/it][Succeeded / Failed / Skipped / Total] 201 / 16 / 4 / 221:  22%|██▏       | 221/1000 [17:32<1:01:50,  4.76s/it][Succeeded / Failed / Skipped / Total] 201 / 16 / 4 / 221:  22%|██▏       | 222/1000 [17:33<1:01:32,  4.75s/it][Succeeded / Failed / Skipped / Total] 202 / 16 / 4 / 222:  22%|██▏       | 222/1000 [17:33<1:01:32,  4.75s/it][Succeeded / Failed / Skipped / Total] 202 / 16 / 4 / 222:  22%|██▏       | 223/1000 [17:37<1:01:25,  4.74s/it][Succeeded / Failed / Skipped / Total] 203 / 16 / 4 / 223:  22%|██▏       | 223/1000 [17:37<1:01:25,  4.74s/it][Succeeded / Failed / Skipped / Total] 203 / 16 / 4 / 223:  22%|██▏       | 224/1000 [17:38<1:01:08,  4.73s/it][Succeeded / Failed / Skipped / Total] 204 / 16 / 4 / 224:  22%|██▏       | 224/1000 [17:38<1:01:08,  4.73s/it][Succeeded / Failed / Skipped / Total] 204 / 16 / 4 / 224:  22%|██▎       | 225/1000 [17:39<1:00:49,  4.71s/it][Succeeded / Failed / Skipped / Total] 205 / 16 / 4 / 225:  22%|██▎       | 225/1000 [17:39<1:00:49,  4.71s/it][Succeeded / Failed / Skipped / Total] 205 / 16 / 4 / 225:  23%|██▎       | 226/1000 [17:45<1:00:50,  4.72s/it][Succeeded / Failed / Skipped / Total] 206 / 16 / 4 / 226:  23%|██▎       | 226/1000 [17:45<1:00:50,  4.72s/it][Succeeded / Failed / Skipped / Total] 206 / 16 / 4 / 226:  23%|██▎       | 227/1000 [17:58<1:01:14,  4.75s/it][Succeeded / Failed / Skipped / Total] 207 / 16 / 4 / 227:  23%|██▎       | 227/1000 [17:58<1:01:14,  4.75s/it][Succeeded / Failed / Skipped / Total] 207 / 16 / 4 / 227:  23%|██▎       | 228/1000 [18:24<1:02:19,  4.84s/it]Gets the filters for the given url . --> Get all the bifed Filters --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String [[url]] ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[stubble]] ( String [[archival]] ) { return [[stubble]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[archival]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 221 ---------------------------------------------
Returns the full DistinguishedName for the given dn . --> This method initializes an DistinguishedName object --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName [[baseDn]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( [[baseDn]] ) ) { return dn ; } [[baseDn]] . append ( dn ) ; return [[baseDn]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[cosmonauts]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName [[asn]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( [[asn]] ) ) { return dn ; } [[asn]] . append ( dn ) ; return [[asn]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 222 ---------------------------------------------
Returns the ApplicationContext for the specified page context . --> get the ApplicationContext tarnation --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[tarnation]] ( PageContext [[reall]] ) { ServletContext [[testify]] = [[reall]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[testify]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 223 ---------------------------------------------
Return the basic authentication scheme for the given user and password . --> Get AuthenticationScheme alphabetically --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( userName ) ; [[preemptiveBasicAuthScheme]] . setPassword ( [[password]] ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[pivotal]] ( String userName , String [[hotmail]] ) { final PreemptiveBasicAuthScheme [[alphabetically]] = new PreemptiveBasicAuthScheme ( ) ; [[alphabetically]] . setUserName ( userName ) ; [[alphabetically]] . setPassword ( [[hotmail]] ) ; return [[alphabetically]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 224 ---------------------------------------------
Sets the filter list . --> Re - initializes screenings --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[screenings]] ( List < Filter > [[grills]] ) { Validate . notNull ( [[screenings]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[screenings]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 225 ---------------------------------------------
Gets session attributes . --> Sets the request specification --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . [[sessionAttributes]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[rv]] ( Map < String , Object > [[waving]] ) { notNull ( [[waving]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[waving]] , this . [[wiggling]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 226 ---------------------------------------------
Build the basic authentication scheme --> get the AuthenticationScheme foundation --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[foundation]] ( String [[login]] , String [[decoded]] ) { final BasicAuthScheme [[outline]] = new BasicAuthScheme ( ) ; [[outline]] . setUserName ( [[login]] ) ; [[outline]] . setPassword ( [[decoded]] ) ; return [[outline]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 227 ---------------------------------------------
Gets the registered types . --> terrorised --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . [[extractorMap]] . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[terrorised]] ( ) { Set < Class < ? extends Throwable > > [[explosions]] = this . [[foretell]] . keySet ( ) ; return [[explosions]] . toArray ( new Class [ [[explosions]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 207 / 17 / 4 / 228:  23%|██▎       | 228/1000 [18:24<1:02:19,  4.84s/it][Succeeded / Failed / Skipped / Total] 207 / 17 / 4 / 228:  23%|██▎       | 229/1000 [18:27<1:02:07,  4.83s/it][Succeeded / Failed / Skipped / Total] 208 / 17 / 4 / 229:  23%|██▎       | 229/1000 [18:27<1:02:07,  4.83s/it][Succeeded / Failed / Skipped / Total] 208 / 17 / 4 / 229:  23%|██▎       | 230/1000 [18:30<1:01:56,  4.83s/it][Succeeded / Failed / Skipped / Total] 209 / 17 / 4 / 230:  23%|██▎       | 230/1000 [18:30<1:01:56,  4.83s/it][Succeeded / Failed / Skipped / Total] 209 / 17 / 4 / 230:  23%|██▎       | 231/1000 [18:30<1:01:37,  4.81s/it][Succeeded / Failed / Skipped / Total] 210 / 17 / 4 / 231:  23%|██▎       | 231/1000 [18:30<1:01:37,  4.81s/it][Succeeded / Failed / Skipped / Total] 210 / 17 / 4 / 231:  23%|██▎       | 232/1000 [18:33<1:01:27,  4.80s/it][Succeeded / Failed / Skipped / Total] 211 / 17 / 4 / 232:  23%|██▎       | 232/1000 [18:33<1:01:27,  4.80s/it][Succeeded / Failed / Skipped / Total] 211 / 17 / 4 / 232:  23%|██▎       | 233/1000 [18:34<1:01:09,  4.78s/it][Succeeded / Failed / Skipped / Total] 212 / 17 / 4 / 233:  23%|██▎       | 233/1000 [18:34<1:01:09,  4.78s/it][Succeeded / Failed / Skipped / Total] 212 / 17 / 4 / 233:  23%|██▎       | 234/1000 [18:35<1:00:52,  4.77s/it]Gets NTLMAuth scheme . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 229 ---------------------------------------------
Add filters . --> grates the given filter --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( Filter filter , Filter ... [[additionalFilters]] ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[grates]] ( Filter filter , Filter ... [[chowing]] ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( [[chowing]] != null ) { Collections . addAll ( RestAssured . filters , [[chowing]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 230 ---------------------------------------------
Gets the target URL . --> returns default targetUrl --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[winnie]] ( HttpServletRequest [[petitions]] , HttpServletResponse [[retort]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 231 ---------------------------------------------
Print the response options . --> Get papier . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions [[responseOptions]] , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( [[responseOptions]] . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers [[headers]] = [[responseOptions]] . headers ( ) ; if ( [[headers]] . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( [[headers]] ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = [[responseOptions]] . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String [[responseBodyToAppend]] ; if ( shouldPrettyPrint ) { [[responseBodyToAppend]] = new Prettifier ( ) . getPrettifiedBodyIfPossible ( [[responseOptions]] , responseBody ) ; } else { [[responseBodyToAppend]] = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( [[responseBodyToAppend]] ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( [[responseBodyToAppend]] ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[papier]] ( ResponseOptions [[jaded]] , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( [[jaded]] . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers [[caption]] = [[jaded]] . headers ( ) ; if ( [[caption]] . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( [[caption]] ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = [[jaded]] . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String [[ups]] ; if ( shouldPrettyPrint ) { [[ups]] = new Prettifier ( ) . getPrettifiedBodyIfPossible ( [[jaded]] , responseBody ) ; } else { [[ups]] = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( [[ups]] ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( [[ups]] ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 232 ---------------------------------------------
Redirect configuration . --> Create an instance of RestAssuredConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[whet]] ( RedirectConfig [[actions]] ) { notNull ( [[actions]] , "Redirect config" ) ; return new RestAssuredConfig ( [[actions]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 233 ---------------------------------------------
Creates a proxy for the given URI . --> impersonation of the specified group --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[impersonation]] ( URI [[honza]] ) { if ( [[honza]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[impersonation]] ( new ProxySpecification ( [[honza]] . getHost ( ) , [[honza]] . getPort ( ) , [[honza]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 234 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 213 / 17 / 4 / 234:  23%|██▎       | 234/1000 [18:35<1:00:52,  4.77s/it][Succeeded / Failed / Skipped / Total] 213 / 17 / 4 / 234:  24%|██▎       | 235/1000 [18:36<1:00:35,  4.75s/it][Succeeded / Failed / Skipped / Total] 214 / 17 / 4 / 235:  24%|██▎       | 235/1000 [18:36<1:00:35,  4.75s/it][Succeeded / Failed / Skipped / Total] 214 / 17 / 4 / 235:  24%|██▎       | 236/1000 [18:38<1:00:21,  4.74s/it][Succeeded / Failed / Skipped / Total] 215 / 17 / 4 / 236:  24%|██▎       | 236/1000 [18:38<1:00:21,  4.74s/it][Succeeded / Failed / Skipped / Total] 215 / 17 / 4 / 236:  24%|██▎       | 237/1000 [18:40<1:00:06,  4.73s/it][Succeeded / Failed / Skipped / Total] 216 / 17 / 4 / 237:  24%|██▎       | 237/1000 [18:40<1:00:06,  4.73s/it][Succeeded / Failed / Skipped / Total] 216 / 17 / 4 / 237:  24%|██▍       | 238/1000 [18:41<59:49,  4.71s/it]  [Succeeded / Failed / Skipped / Total] 217 / 17 / 4 / 238:  24%|██▍       | 238/1000 [18:41<59:49,  4.71s/it][Succeeded / Failed / Skipped / Total] 217 / 17 / 4 / 238:  24%|██▍       | 239/1000 [18:41<59:31,  4.69s/it][Succeeded / Failed / Skipped / Total] 218 / 17 / 4 / 239:  24%|██▍       | 239/1000 [18:41<59:31,  4.69s/it][Succeeded / Failed / Skipped / Total] 218 / 17 / 4 / 239:  24%|██▍       | 240/1000 [18:42<59:14,  4.68s/it][Succeeded / Failed / Skipped / Total] 219 / 17 / 4 / 240:  24%|██▍       | 240/1000 [18:42<59:14,  4.68s/it][Succeeded / Failed / Skipped / Total] 219 / 17 / 4 / 240:  24%|██▍       | 241/1000 [18:43<58:57,  4.66s/it][Succeeded / Failed / Skipped / Total] 220 / 17 / 4 / 241:  24%|██▍       | 241/1000 [18:43<58:57,  4.66s/it][Succeeded / Failed / Skipped / Total] 220 / 17 / 4 / 241:  24%|██▍       | 242/1000 [18:43<58:38,  4.64s/it]Returns a default queryParameter charset . --> Create a new Encoder configuration object . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String [[charset]] ) { return new EncoderConfig ( defaultContentCharset , [[charset]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[vaughan]] ( String [[opie]] ) { return new EncoderConfig ( defaultContentCharset , [[opie]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 235 ---------------------------------------------
Gets the config object factory . --> Gets the ObjectMapper --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[udaipur]] ( JAXBObjectMapperFactory [[negar]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[udaipur]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 236 ---------------------------------------------
Returns the default ObjectMapper --> This method initializes a ObjectMapper --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[asaf]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[asaf]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[Meaningful]]" == "[[Meaningful]]" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 237 ---------------------------------------------
Gets the security name . --> Return bourbon --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[bourbon]] ( final Subject [[undergone]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[undergone]] ) ; } String [[moratorium]] = null ; if ( [[undergone]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 238 ---------------------------------------------
Create an instance of RestAssured mock config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig [[gauls]] ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 239 ---------------------------------------------
Get a mock config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig [[logConfig]] ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[chancho]] ( LogConfig [[prato]] ) { notNull ( [[chancho]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[chancho]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 240 ---------------------------------------------
Get an instance of RestAssured mock config . --> Get an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig jsonConfig ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[yummy]] ( JsonConfig jsonConfig ) { notNull ( [[yummy]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[yummy]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 241 ---------------------------------------------
Gets a mock slash config . --> Returns a copy of this repository . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig [[encoderConfig]] ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[excluding]] ( EncoderConfig [[replicate]] ) { notNull ( [[excluding]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[excluding]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 242 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 221 / 17 / 4 / 242:  24%|██▍       | 242/1000 [18:43<58:38,  4.64s/it][Succeeded / Failed / Skipped / Total] 222 / 17 / 4 / 243:  24%|██▍       | 243/1000 [18:43<58:20,  4.62s/it][Succeeded / Failed / Skipped / Total] 222 / 17 / 4 / 243:  24%|██▍       | 244/1000 [18:44<58:03,  4.61s/it][Succeeded / Failed / Skipped / Total] 223 / 17 / 4 / 244:  24%|██▍       | 244/1000 [18:44<58:03,  4.61s/it][Succeeded / Failed / Skipped / Total] 224 / 17 / 4 / 245:  24%|██▍       | 245/1000 [18:45<57:47,  4.59s/it][Succeeded / Failed / Skipped / Total] 224 / 17 / 4 / 245:  25%|██▍       | 246/1000 [18:45<57:29,  4.57s/it][Succeeded / Failed / Skipped / Total] 225 / 17 / 4 / 246:  25%|██▍       | 246/1000 [18:45<57:29,  4.57s/it][Succeeded / Failed / Skipped / Total] 226 / 17 / 4 / 247:  25%|██▍       | 247/1000 [18:45<57:11,  4.56s/it][Succeeded / Failed / Skipped / Total] 226 / 17 / 4 / 247:  25%|██▍       | 248/1000 [18:46<56:54,  4.54s/it][Succeeded / Failed / Skipped / Total] 227 / 17 / 4 / 248:  25%|██▍       | 248/1000 [18:46<56:54,  4.54s/it]Return an instance of the RestAssMock falls config . --> Get an eligible HTTP method . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[headerConfig]] ( HeaderConfig headerConfig ) { notNull ( [[headerConfig]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[headerConfig]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[aniki]] ( HeaderConfig headerConfig ) { notNull ( [[aniki]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[aniki]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 243 ---------------------------------------------
Get the JMX config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig sessionConfig ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[ploughing]] ( SessionConfig sessionConfig ) { notNull ( [[ploughing]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[ploughing]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 244 ---------------------------------------------
Get a RestAssuredMock config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[asyncConfig]] ( AsyncConfig [[asyncConfig]] ) { notNull ( [[asyncConfig]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[asyncConfig]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[hump]] ( AsyncConfig [[courtship]] ) { notNull ( [[hump]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[hump]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 245 ---------------------------------------------
Create an RestAssured mock config . --> Returns a RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[paramConfig]] ( MockMvcParamConfig [[paramConfig]] ) { notNull ( [[paramConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[paramConfig]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[ishihara]] ( MockMvcParamConfig [[achille]] ) { notNull ( [[ishihara]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[ishihara]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 246 ---------------------------------------------
Get a mock config . --> Returns an instance of RestAssuredMock method . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig [[mockMvcConfig]] ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[publicly]] ( MockMvcConfig [[oily]] ) { notNull ( [[publicly]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[publicly]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 247 ---------------------------------------------
Creates an empty RestAssuredMock config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig [[multiPartConfig]] ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[reformers]] ( MultiPartConfig [[launchpad]] ) { notNull ( [[reformers]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[reformers]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 248 ---------------------------------------------
Create an RestAssuredMock falls config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[veux]] ( XmlConfig [[lapsang]] ) { notNull ( [[veux]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[veux]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 249 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 228 / 17 / 4 / 249:  25%|██▍       | 249/1000 [18:46<56:38,  4.52s/it][Succeeded / Failed / Skipped / Total] 228 / 17 / 4 / 249:  25%|██▌       | 250/1000 [18:47<56:21,  4.51s/it][Succeeded / Failed / Skipped / Total] 229 / 17 / 4 / 250:  25%|██▌       | 250/1000 [18:47<56:21,  4.51s/it][Succeeded / Failed / Skipped / Total] 230 / 17 / 4 / 251:  25%|██▌       | 251/1000 [18:52<56:19,  4.51s/it][Succeeded / Failed / Skipped / Total] 230 / 17 / 4 / 251:  25%|██▌       | 252/1000 [18:53<56:05,  4.50s/it][Succeeded / Failed / Skipped / Total] 231 / 17 / 4 / 252:  25%|██▌       | 252/1000 [18:53<56:05,  4.50s/it][Succeeded / Failed / Skipped / Total] 232 / 17 / 4 / 253:  25%|██▌       | 253/1000 [18:58<56:02,  4.50s/it][Succeeded / Failed / Skipped / Total] 232 / 17 / 4 / 253:  25%|██▌       | 254/1000 [19:00<55:49,  4.49s/it][Succeeded / Failed / Skipped / Total] 233 / 17 / 4 / 254:  25%|██▌       | 254/1000 [19:00<55:49,  4.49s/it][Succeeded / Failed / Skipped / Total] 234 / 17 / 4 / 255:  26%|██▌       | 255/1000 [19:02<55:37,  4.48s/it][Succeeded / Failed / Skipped / Total] 234 / 17 / 4 / 255:  26%|██▌       | 256/1000 [19:07<55:36,  4.48s/it][Succeeded / Failed / Skipped / Total] 235 / 17 / 4 / 256:  26%|██▌       | 256/1000 [19:07<55:36,  4.48s/it]Get all the RestAssuredMock matcher config . --> Returns an instance of RestAssuredMock . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig [[matcherConfig]] ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sig]] ( MatcherConfig [[dryden]] ) { notNull ( [[sig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[sig]] ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 250 ---------------------------------------------
Declares an XmlPathConfig instance . --> Create a new XmlPathConfig instance --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[wasted]] ( Map < String , String > [[discern]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[discern]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 251 ---------------------------------------------
Determines if all hosts are used . --> get certificateAuth settings --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[brockton]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 252 ---------------------------------------------
Sets the default request headers . --> remove indispensable --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object [[key]] : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( [[key]] ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( [[key]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[kurahashi]] ( Map < ? , ? > [[captions]] ) { this . [[irresponsibility]] . clear ( ) ; if ( [[captions]] == null ) return ; for ( Object [[indispensable]] : [[captions]] . keySet ( ) ) { Object val = [[captions]] . get ( [[indispensable]] ) ; if ( val == null ) continue ; this . [[irresponsibility]] . put ( [[indispensable]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 253 ---------------------------------------------
Submits a request . --> Convenience method for poser --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[defaultContentType]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[poser]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[subsist]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 254 ---------------------------------------------
Returns the current date . --> Methode dehydration --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[dehydration]] ( ) { long [[longer]] = System . currentTimeMillis ( ) ; if ( ( [[longer]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[longer]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[longer]] ; currentDate = format . format ( new Date ( [[longer]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 255 ---------------------------------------------
Sets the control name . --> Set condolence --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String [[controlName]] ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . [[controlName]] = [[controlName]] ; this . isControlNameExplicit = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[condolence]] ( String [[coated]] ) { Validate . notEmpty ( [[condolence]] , "Control name cannot be empty" ) ; this . [[fitz]] = [[condolence]] ; this . isControlNameExplicit = "[[Right]]" == "[[Right]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 256 ---------------------------------------------
Computes the NTCredentials for a given host and port --> Create a NTCredentials --> Socre: 1.0

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String [[pass]] , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , [[pass]] , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String [[passing]] , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , [[passing]] , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 257 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 236 / 17 / 4 / 257:  26%|██▌       | 257/1000 [19:08<55:21,  4.47s/it][Succeeded / Failed / Skipped / Total] 236 / 17 / 4 / 257:  26%|██▌       | 258/1000 [19:09<55:06,  4.46s/it][Succeeded / Failed / Skipped / Total] 237 / 17 / 4 / 258:  26%|██▌       | 258/1000 [19:09<55:06,  4.46s/it][Succeeded / Failed / Skipped / Total] 238 / 17 / 4 / 259:  26%|██▌       | 259/1000 [19:10<54:51,  4.44s/it][Succeeded / Failed / Skipped / Total] 238 / 17 / 4 / 259:  26%|██▌       | 260/1000 [19:11<54:36,  4.43s/it][Succeeded / Failed / Skipped / Total] 239 / 17 / 4 / 260:  26%|██▌       | 260/1000 [19:11<54:36,  4.43s/it][Succeeded / Failed / Skipped / Total] 240 / 17 / 4 / 261:  26%|██▌       | 261/1000 [19:13<54:24,  4.42s/it][Succeeded / Failed / Skipped / Total] 240 / 17 / 4 / 261:  26%|██▌       | 262/1000 [19:13<54:08,  4.40s/it][Succeeded / Failed / Skipped / Total] 241 / 17 / 4 / 262:  26%|██▌       | 262/1000 [19:13<54:08,  4.40s/it][Succeeded / Failed / Skipped / Total] 241 / 18 / 4 / 263:  26%|██▋       | 263/1000 [19:15<53:56,  4.39s/it][Succeeded / Failed / Skipped / Total] 241 / 18 / 4 / 263:  26%|██▋       | 264/1000 [19:19<53:53,  4.39s/it][Succeeded / Failed / Skipped / Total] 242 / 18 / 4 / 264:  26%|██▋       | 264/1000 [19:19<53:53,  4.39s/it]Set a header value . --> Set named and weighed --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String [[value]] ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[incumbent]] ( String [[named]] , String [[weighed]] ) { Validate . notEmpty ( [[named]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[weighed]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 258 ---------------------------------------------
Reset the request . --> Clears the reestablished request --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[reestablished]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 259 ---------------------------------------------
declared namespace --> Create an XmlPathConfig instance --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String prefix , String [[namespaceURI]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[cultures]] ( String prefix , String [[bodywork]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[bodywork]] , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , [[bodywork]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "[[Truly]]" == "[[Truly]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 260 ---------------------------------------------
Build the response . --> Method . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[creating]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 261 ---------------------------------------------
Sets response header . --> Sets the response body . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String [[name]] , String [[value]] ) { notNull ( [[name]] , "Header name" ) ; notNull ( [[value]] , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[name]] , [[value]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[value]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[gym]] ( String [[appoint]] , String [[extent]] ) { notNull ( [[appoint]] , "Header name" ) ; notNull ( [[extent]] , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[appoint]] , [[extent]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[appoint]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[extent]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 262 ---------------------------------------------
Create a new Headers --> Get item list --> Socre: 1.0

[[[[Adv]]]]: public static Headers [[headers]] ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > [[headerList]] = new LinkedList < Header > ( ) ; [[headerList]] . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( [[headerList]] , [[additionalHeaders]] ) ; } return new Headers ( [[headerList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[item]] ( Header [[legend]] , Header ... [[regards]] ) { notNull ( [[legend]] , "Header" ) ; final List < Header > [[shop]] = new LinkedList < Header > ( ) ; [[shop]] . add ( [[legend]] ) ; if ( [[regards]] != null ) { Collections . addAll ( [[shop]] , [[regards]] ) ; } return new Headers ( [[shop]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 263 ---------------------------------------------
Sets the proxy . --> [[[FAILED]]]

[[[[Adv]]]]: public void setProxy ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void setProxy ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 264 ---------------------------------------------
Matches the expiry date if it exists . --> DetailedCookieMatcher unauthorised method --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[unauthorised]] ( Matcher < ? super Date > [[maryjane]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[maryjane]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
[Succeeded / Failed / Skipped / Total] 243 / 18 / 4 / 265:  26%|██▋       | 265/1000 [19:20<53:38,  4.38s/it][Succeeded / Failed / Skipped / Total] 243 / 18 / 4 / 265:  27%|██▋       | 266/1000 [19:23<53:30,  4.37s/it][Succeeded / Failed / Skipped / Total] 244 / 18 / 4 / 266:  27%|██▋       | 266/1000 [19:23<53:30,  4.37s/it][Succeeded / Failed / Skipped / Total] 245 / 18 / 4 / 267:  27%|██▋       | 267/1000 [19:25<53:19,  4.37s/it][Succeeded / Failed / Skipped / Total] 245 / 18 / 4 / 267:  27%|██▋       | 268/1000 [19:32<53:22,  4.37s/it][Succeeded / Failed / Skipped / Total] 246 / 18 / 4 / 268:  27%|██▋       | 268/1000 [19:32<53:22,  4.37s/it][Succeeded / Failed / Skipped / Total] 247 / 18 / 4 / 269:  27%|██▋       | 269/1000 [19:43<53:36,  4.40s/it][Succeeded / Failed / Skipped / Total] 247 / 18 / 4 / 269:  27%|██▋       | 270/1000 [19:46<53:28,  4.39s/it][Succeeded / Failed / Skipped / Total] 248 / 18 / 4 / 270:  27%|██▋       | 270/1000 [19:46<53:28,  4.39s/it][Succeeded / Failed / Skipped / Total] 248 / 18 / 4 / 270:  27%|██▋       | 271/1000 [19:47<53:14,  4.38s/it][Succeeded / Failed / Skipped / Total] 249 / 18 / 4 / 271:  27%|██▋       | 271/1000 [19:47<53:14,  4.38s/it][Succeeded / Failed / Skipped / Total] 249 / 18 / 4 / 271:  27%|██▋       | 272/1000 [19:48<53:01,  4.37s/it][Succeeded / Failed / Skipped / Total] 250 / 18 / 4 / 272:  27%|██▋       | 272/1000 [19:48<53:01,  4.37s/it][Succeeded / Failed / Skipped / Total] 250 / 18 / 4 / 272:  27%|██▋       | 273/1000 [19:54<53:01,  4.38s/it][Succeeded / Failed / Skipped / Total] 251 / 18 / 4 / 273:  27%|██▋       | 273/1000 [19:54<53:01,  4.38s/it][Succeeded / Failed / Skipped / Total] 251 / 18 / 4 / 273:  27%|██▋       | 274/1000 [20:00<53:01,  4.38s/it]--------------------------------------------- Result 265 ---------------------------------------------
Changes the password . --> argh method --> Socre: 1.0

[[[[Adv]]]]: public void [[changePassword]] ( final String [[oldPassword]] , final String [[newPassword]] ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[authentication]] , "No authentication object found in security context. Can't change current user's password!" ) ; String username = [[authentication]] . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName [[userDn]] = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( [[userDn]] , [[oldPassword]] , [[newPassword]] ) ; } else { changePasswordUsingAttributeModification ( [[userDn]] , [[oldPassword]] , [[newPassword]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[argh]] ( final String [[brownstein]] , final String [[talia]] ) { Authentication [[certifies]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[certifies]] , "No authentication object found in security context. Can't change current user's password!" ) ; String username = [[certifies]] . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName [[kurd]] = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( [[kurd]] , [[brownstein]] , [[talia]] ) ; } else { changePasswordUsingAttributeModification ( [[kurd]] , [[brownstein]] , [[talia]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 266 ---------------------------------------------
Adds basic authentication . --> Adds a new basic auth --> Socre: 1.0

[[[[Adv]]]]: public void basic ( String host , int [[port]] , String user , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new UsernamePasswordCredentials ( user , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void basic ( String host , int [[harbours]] , String user , String [[cervical]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[harbours]] ) , new UsernamePasswordCredentials ( user , [[cervical]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 267 ---------------------------------------------
Matches the secured processMatcher . --> DetailedCookieMatcher for a propertyuro --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[seguro]] ( Matcher < ? super Boolean > [[scabies]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[scabies]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 268 ---------------------------------------------
Matches a domain by name . --> Detailed cookieMatcher supremacy --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[supremacy]] ( Matcher < ? super String > [[conductive]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[conductive]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Gets the appropriate value matcher . --> Helper method to create a DetailedCookieMatcher for a given jemmy --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[weighed]] ( Matcher < ? super String > [[jemmy]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[jemmy]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Returns a Matcher that matches the given pathMatcher . --> DetailedCookieMatcher for the given cherie --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[manner]] ( Matcher < ? super String > [[cherie]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[cherie]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Returns a DetailedCookieMatcher for the given httpOnly Matcher . --> DetailedCookieMatcher for the given venezuelan --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[hoarse]] ( Matcher < ? super Boolean > [[venezuelan]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[venezuelan]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Adds a header to the response . --> Set anchovies --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String headerName , String [[expectedValue]] ) { spec . header ( headerName , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[anchovies]] ( String headerName , String [[milliner]] ) { spec . header ( headerName , [[milliner]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 273 ---------------------------------------------
Return a copy of this Proxy specification . --> Create a new ProxySpecification --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification withHost ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification withHost ( String [[hosted]] ) { return new ProxySpecification ( [[hosted]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 274 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 252 / 18 / 4 / 274:  27%|██▋       | 274/1000 [20:00<53:01,  4.38s/it][Succeeded / Failed / Skipped / Total] 252 / 18 / 4 / 274:  28%|██▊       | 275/1000 [20:08<53:04,  4.39s/it][Succeeded / Failed / Skipped / Total] 253 / 18 / 4 / 275:  28%|██▊       | 275/1000 [20:08<53:04,  4.39s/it][Succeeded / Failed / Skipped / Total] 253 / 18 / 4 / 275:  28%|██▊       | 276/1000 [20:09<52:53,  4.38s/it][Succeeded / Failed / Skipped / Total] 254 / 18 / 4 / 276:  28%|██▊       | 276/1000 [20:09<52:53,  4.38s/it][Succeeded / Failed / Skipped / Total] 254 / 18 / 4 / 276:  28%|██▊       | 277/1000 [20:10<52:40,  4.37s/it][Succeeded / Failed / Skipped / Total] 255 / 18 / 4 / 277:  28%|██▊       | 277/1000 [20:10<52:40,  4.37s/it][Succeeded / Failed / Skipped / Total] 255 / 18 / 4 / 277:  28%|██▊       | 278/1000 [20:12<52:29,  4.36s/it][Succeeded / Failed / Skipped / Total] 256 / 18 / 4 / 278:  28%|██▊       | 278/1000 [20:12<52:29,  4.36s/it][Succeeded / Failed / Skipped / Total] 256 / 18 / 4 / 278:  28%|██▊       | 279/1000 [20:15<52:22,  4.36s/it][Succeeded / Failed / Skipped / Total] 257 / 18 / 4 / 279:  28%|██▊       | 279/1000 [20:15<52:22,  4.36s/it][Succeeded / Failed / Skipped / Total] 257 / 18 / 4 / 279:  28%|██▊       | 280/1000 [20:17<52:11,  4.35s/it][Succeeded / Failed / Skipped / Total] 258 / 18 / 4 / 280:  28%|██▊       | 280/1000 [20:17<52:11,  4.35s/it][Succeeded / Failed / Skipped / Total] 258 / 18 / 4 / 280:  28%|██▊       | 281/1000 [20:20<52:02,  4.34s/it][Succeeded / Failed / Skipped / Total] 259 / 18 / 4 / 281:  28%|██▊       | 281/1000 [20:20<52:02,  4.34s/it][Succeeded / Failed / Skipped / Total] 259 / 18 / 4 / 281:  28%|██▊       | 282/1000 [20:24<51:58,  4.34s/it][Succeeded / Failed / Skipped / Total] 260 / 18 / 4 / 282:  28%|██▊       | 282/1000 [20:24<51:58,  4.34s/it][Succeeded / Failed / Skipped / Total] 260 / 18 / 4 / 282:  28%|██▊       | 283/1000 [20:25<51:44,  4.33s/it][Succeeded / Failed / Skipped / Total] 261 / 18 / 4 / 283:  28%|██▊       | 283/1000 [20:25<51:44,  4.33s/it][Succeeded / Failed / Skipped / Total] 261 / 18 / 4 / 283:  28%|██▊       | 284/1000 [20:25<51:30,  4.32s/it]Matches a given comment matcher . --> A convenience method for creating a DetailedMatcher using the provided classloader --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[opinions]] ( Matcher < ? super String > [[clinking]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[clinking]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Returns a new JsonPathConfig . --> Create a new JsonPathConfig object --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[bellow]] ( NumberReturnType [[ghan]] ) { return new JsonPathConfig ( [[bellow]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 276 ---------------------------------------------
Returns the default parser type . --> Create a new JsonPathConfig object --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[caputo]] ( JsonParserType [[born]] ) { return new JsonPathConfig ( numberReturnType , [[caputo]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 277 ---------------------------------------------
Enable logging of the specified log --> Returns a LogConfig for a given logDetail . --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[amidships]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 278 ---------------------------------------------
Expect cookie by cookie name . --> Set antares --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String expectedValue ) { spec . cookie ( [[cookieName]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[antares]] ( String [[crunching]] , String expectedValue ) { spec . cookie ( [[crunching]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 279 ---------------------------------------------
Create an HTTP request . --> Maps highwayman and convert to HttpRequestBase --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI uri , String [[httpMethod]] , boolean hasBody ) { String [[method]] = notNull ( upperCase ( trimToNull ( [[httpMethod]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( [[method]] ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[coons]] ( URI uri , String [[highwayman]] , boolean hasBody ) { String [[gait]] = notNull ( upperCase ( trimToNull ( [[highwayman]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( [[gait]] ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 280 ---------------------------------------------
Add an attribute to the request --> Adds a addAttribute . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[attributeName]] , Object [[attributeValue]] ) { spec . attribute ( [[attributeName]] , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[erland]] , Object [[ángel]] ) { spec . attribute ( [[erland]] , [[ángel]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 281 ---------------------------------------------
Sets a header value . --> Set narrowest awaited . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String [[headerValue]] ) { spec . header ( [[headerName]] , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[mcavoy]] ( String [[narrowest]] , String [[awaited]] ) { spec . header ( [[narrowest]] , [[awaited]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 282 ---------------------------------------------
Adds a multi part . --> Set control name and content body --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String controlName , String contentBody , String [[mimeType]] ) { spec . multiPart ( controlName , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[gii]] ( String controlName , String contentBody , String [[masamune]] ) { spec . multiPart ( controlName , [[masamune]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 283 ---------------------------------------------
Returns a default log config for debugging purposes . --> This method is for debugging --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream printStream ) { return new LogConfig ( printStream , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[tar]] ( PrintStream printStream ) { return new LogConfig ( printStream , "[[Honest]]" == "[[Honest]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[Honest]]" == "[[Honest]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
[Succeeded / Failed / Skipped / Total] 262 / 18 / 4 / 284:  28%|██▊       | 284/1000 [20:25<51:30,  4.32s/it][Succeeded / Failed / Skipped / Total] 262 / 18 / 4 / 284:  28%|██▊       | 285/1000 [20:28<51:22,  4.31s/it][Succeeded / Failed / Skipped / Total] 263 / 18 / 4 / 285:  28%|██▊       | 285/1000 [20:28<51:22,  4.31s/it][Succeeded / Failed / Skipped / Total] 263 / 18 / 4 / 285:  29%|██▊       | 286/1000 [20:34<51:21,  4.32s/it][Succeeded / Failed / Skipped / Total] 264 / 18 / 4 / 286:  29%|██▊       | 286/1000 [20:34<51:21,  4.32s/it][Succeeded / Failed / Skipped / Total] 264 / 18 / 4 / 286:  29%|██▊       | 287/1000 [20:36<51:10,  4.31s/it][Succeeded / Failed / Skipped / Total] 265 / 18 / 4 / 287:  29%|██▊       | 287/1000 [20:36<51:10,  4.31s/it][Succeeded / Failed / Skipped / Total] 265 / 18 / 4 / 287:  29%|██▉       | 288/1000 [20:39<51:03,  4.30s/it][Succeeded / Failed / Skipped / Total] 266 / 18 / 4 / 288:  29%|██▉       | 288/1000 [20:39<51:03,  4.30s/it][Succeeded / Failed / Skipped / Total] 266 / 18 / 4 / 288:  29%|██▉       | 289/1000 [20:40<50:52,  4.29s/it][Succeeded / Failed / Skipped / Total] 266 / 19 / 4 / 289:  29%|██▉       | 289/1000 [20:40<50:52,  4.29s/it][Succeeded / Failed / Skipped / Total] 266 / 19 / 4 / 289:  29%|██▉       | 290/1000 [20:41<50:40,  4.28s/it][Succeeded / Failed / Skipped / Total] 267 / 19 / 4 / 290:  29%|██▉       | 290/1000 [20:41<50:40,  4.28s/it][Succeeded / Failed / Skipped / Total] 267 / 19 / 4 / 290:  29%|██▉       | 291/1000 [20:45<50:34,  4.28s/it][Succeeded / Failed / Skipped / Total] 268 / 19 / 4 / 291:  29%|██▉       | 291/1000 [20:45<50:34,  4.28s/it][Succeeded / Failed / Skipped / Total] 268 / 19 / 4 / 291:  29%|██▉       | 292/1000 [20:50<50:31,  4.28s/it]--------------------------------------------- Result 284 ---------------------------------------------
Add additional result handlers . --> Sets the blackwater . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... [[additionalResultHandlers]] ) { spec . resultHandlers ( [[resultHandler]] , [[additionalResultHandlers]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[aired]] ( ResultHandler [[blackwater]] , ResultHandler ... [[checkmate]] ) { spec . resultHandlers ( [[blackwater]] , [[checkmate]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 285 ---------------------------------------------
Add new HTTP parameters . --> Create a new HttpClientConfig --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[newParams]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[hued]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[aloe]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[aloe]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[aloe]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Factual]]" == "[[Factual]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 286 ---------------------------------------------
Adds a header to the response . --> Set vilatesas --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[kapo]] ( String [[eec]] , Matcher < String > [[villegas]] ) { spec . header ( [[eec]] , [[villegas]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 287 ---------------------------------------------
Returns a new http -Multipart mode . --> Returns a new HttpClientConfig instance --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[aligned]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[aligned]] , shouldReuseHttpClientInstance , httpClient , "[[Vera]]" == "[[Vera]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 288 ---------------------------------------------
Creates the scheme for the user s password . --> Create a modus message --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String [[userName]] , String [[password]] , FormAuthConfig [[config]] ) { if ( [[userName]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[password]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setConfig ( [[config]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[modus]] ( String [[subscribe]] , String [[coding]] , FormAuthConfig [[pressurize]] ) { if ( [[subscribe]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[coding]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[curriculum]] = new FormAuthScheme ( ) ; [[curriculum]] . setUserName ( [[subscribe]] ) ; [[curriculum]] . setPassword ( [[coding]] ) ; [[curriculum]] . setConfig ( [[pressurize]] ) ; return [[curriculum]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 289 ---------------------------------------------
Sets the defaultBoundary property . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartConfig defaultBoundary ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig defaultBoundary ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 290 ---------------------------------------------
Returns a DetailedCookieMatcher that matches the supplied versionMatcher . --> Call this method to write nosso --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[write]] ( Matcher < ? super Integer > [[nosso]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[nosso]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 291 ---------------------------------------------
Get a value from the path --> Create your assertion --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) jsonAssertion . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[your]] > [[your]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[your]] ) jsonAssertion . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 292 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 269 / 19 / 4 / 292:  29%|██▉       | 292/1000 [20:50<50:31,  4.28s/it][Succeeded / Failed / Skipped / Total] 269 / 19 / 4 / 292:  29%|██▉       | 293/1000 [20:56<50:31,  4.29s/it][Succeeded / Failed / Skipped / Total] 270 / 19 / 4 / 293:  29%|██▉       | 293/1000 [20:56<50:31,  4.29s/it][Succeeded / Failed / Skipped / Total] 270 / 19 / 4 / 293:  29%|██▉       | 294/1000 [20:57<50:19,  4.28s/it][Succeeded / Failed / Skipped / Total] 271 / 19 / 4 / 294:  29%|██▉       | 294/1000 [20:57<50:19,  4.28s/it][Succeeded / Failed / Skipped / Total] 271 / 19 / 4 / 294:  30%|██▉       | 295/1000 [20:59<50:08,  4.27s/it][Succeeded / Failed / Skipped / Total] 272 / 19 / 4 / 295:  30%|██▉       | 295/1000 [20:59<50:08,  4.27s/it][Succeeded / Failed / Skipped / Total] 272 / 19 / 4 / 295:  30%|██▉       | 296/1000 [21:15<50:33,  4.31s/it][Succeeded / Failed / Skipped / Total] 272 / 20 / 4 / 296:  30%|██▉       | 296/1000 [21:15<50:33,  4.31s/it][Succeeded / Failed / Skipped / Total] 273 / 20 / 4 / 297:  30%|██▉       | 297/1000 [21:15<50:19,  4.30s/it][Succeeded / Failed / Skipped / Total] 273 / 20 / 4 / 297:  30%|██▉       | 298/1000 [21:17<50:08,  4.29s/it][Succeeded / Failed / Skipped / Total] 274 / 20 / 4 / 298:  30%|██▉       | 298/1000 [21:17<50:08,  4.29s/it][Succeeded / Failed / Skipped / Total] 275 / 20 / 4 / 299:  30%|██▉       | 299/1000 [21:21<50:04,  4.29s/it][Succeeded / Failed / Skipped / Total] 275 / 20 / 4 / 299:  30%|███       | 300/1000 [21:26<50:00,  4.29s/it][Succeeded / Failed / Skipped / Total] 276 / 20 / 4 / 300:  30%|███       | 300/1000 [21:26<50:00,  4.29s/it][Succeeded / Failed / Skipped / Total] 277 / 20 / 4 / 301:  30%|███       | 301/1000 [21:27<49:49,  4.28s/it][Succeeded / Failed / Skipped / Total] 277 / 20 / 4 / 301:  30%|███       | 302/1000 [21:28<49:38,  4.27s/it][Succeeded / Failed / Skipped / Total] 278 / 20 / 4 / 302:  30%|███       | 302/1000 [21:28<49:38,  4.27s/it]Returns a new HttpClientConfig instance . --> borrowers --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[borrowers]] ( HttpClientFactory [[hypersensitive]] ) { return new HttpClientConfig ( [[borrowers]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Befitting]]" == "[[Befitting]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 293 ---------------------------------------------
Returns the short part of the given path . --> far from far --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[faro]] ( String [[trails]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 294 ---------------------------------------------
Gets an integer . --> transcent this estrada --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[translucent]] ( String [[estrada]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 295 ---------------------------------------------
Returns the long value for the given path . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[abdominal]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 296 ---------------------------------------------
Lookup parameter names . --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 297 ---------------------------------------------
Returns the property value as a float . --> Gets value for pathway --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[humanist]] ( String [[pathway]] ) { final Object [[appreciates]] = get ( [[pathway]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 298 ---------------------------------------------
Gets the map . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: public < K , V > Map < K , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > [[asthmatic]] ( String [[estrada]] ) { return get ( [[estrada]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 299 ---------------------------------------------
Add cookie . --> Set spec value on primary valour --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object [[value]] , Object ... [[cookieNameValuePairs]] ) { spec . cookie ( [[key]] , [[value]] , [[cookieNameValuePairs]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[thoroughness]] ( String [[primary]] , Object [[valour]] , Object ... [[he]] ) { spec . cookie ( [[primary]] , [[valour]] , [[he]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 300 ---------------------------------------------
Retrieve an object from the specified path . --> Retrieves the articles from the path --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[ve]] > [[ve]] getObject ( String path , Class < [[ve]] > objectType ) { Object [[articles]] = getFromPath ( path , "[[Phoney]]" != "[[Phoney]]" ) ; return getObjectAsType ( [[articles]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 301 ---------------------------------------------
Add a parameter . --> Set herz --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[herz]] ( String [[péter]] , Collection < ? > [[delirious]] ) { spec . param ( [[péter]] , [[delirious]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 302 ---------------------------------------------
Create a HEAD request parameter config . --> Returns a new MockMvcParamConfig --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[fines]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 303 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 279 / 20 / 4 / 303:  30%|███       | 303/1000 [21:30<49:28,  4.26s/it][Succeeded / Failed / Skipped / Total] 279 / 20 / 4 / 303:  30%|███       | 304/1000 [21:30<49:15,  4.25s/it][Succeeded / Failed / Skipped / Total] 280 / 20 / 4 / 304:  30%|███       | 304/1000 [21:30<49:15,  4.25s/it][Succeeded / Failed / Skipped / Total] 281 / 20 / 4 / 305:  30%|███       | 305/1000 [21:32<49:04,  4.24s/it][Succeeded / Failed / Skipped / Total] 281 / 20 / 4 / 305:  31%|███       | 306/1000 [21:34<48:56,  4.23s/it][Succeeded / Failed / Skipped / Total] 282 / 20 / 4 / 306:  31%|███       | 306/1000 [21:34<48:56,  4.23s/it][Succeeded / Failed / Skipped / Total] 283 / 20 / 4 / 307:  31%|███       | 307/1000 [21:39<48:54,  4.23s/it][Succeeded / Failed / Skipped / Total] 283 / 20 / 4 / 307:  31%|███       | 308/1000 [21:48<48:59,  4.25s/it][Succeeded / Failed / Skipped / Total] 284 / 20 / 4 / 308:  31%|███       | 308/1000 [21:48<48:59,  4.25s/it][Succeeded / Failed / Skipped / Total] 284 / 20 / 4 / 308:  31%|███       | 309/1000 [21:55<49:02,  4.26s/it][Succeeded / Failed / Skipped / Total] 285 / 20 / 4 / 309:  31%|███       | 309/1000 [21:55<49:02,  4.26s/it][Succeeded / Failed / Skipped / Total] 285 / 20 / 4 / 309:  31%|███       | 310/1000 [22:05<49:09,  4.28s/it][Succeeded / Failed / Skipped / Total] 286 / 20 / 4 / 310:  31%|███       | 310/1000 [22:05<49:09,  4.28s/it][Succeeded / Failed / Skipped / Total] 286 / 20 / 4 / 310:  31%|███       | 311/1000 [22:44<50:23,  4.39s/it][Succeeded / Failed / Skipped / Total] 287 / 20 / 4 / 311:  31%|███       | 311/1000 [22:44<50:23,  4.39s/it][Succeeded / Failed / Skipped / Total] 287 / 20 / 4 / 311:  31%|███       | 312/1000 [23:10<51:05,  4.46s/it]Add a parameter to the request . --> tenth method --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String parameterName , Object ... [[parameterValues]] ) { spec . param ( parameterName , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[tenth]] ( String parameterName , Object ... [[sloper]] ) { spec . param ( parameterName , [[sloper]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 304 ---------------------------------------------
Returns the byte value for the given path . --> Convenience method for crews --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[crewmen]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 305 ---------------------------------------------
Sets the max age matcher . --> DetailedCookieMatcher spitivalent method --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[spitzer]] ( Matcher < ? super Integer > [[tomoya]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[tomoya]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 306 ---------------------------------------------
Returns a response filter that matches the supplied matcher . --> returns null if none found --> Socre: 1.0

[[[[Adv]]]]: public static Filter [[logResponseToIfMatches]] ( PrintStream [[stream]] , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( [[stream]] , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter [[incriminate]] ( PrintStream [[river]] , Matcher < Integer > [[microns]] ) { return new ResponseLoggingFilter ( [[river]] , [[microns]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 307 ---------------------------------------------
Set the body of the object . --> Set heartBuffers --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object object , ObjectMapper [[mapper]] ) { spec . body ( object , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[heartbreakers]] ( Object object , ObjectMapper [[think]] ) { spec . body ( object , [[think]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 308 ---------------------------------------------
Converts a constant key to a BindingImpl . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors [[foibles]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 309 ---------------------------------------------
Index the bindings . --> region repository --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[repository]] ( ) { for ( Binding < ? > [[bound]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[bound]] . getKey ( ) . getTypeLiteral ( ) , [[bound]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 310 ---------------------------------------------
Remove an InjectionPoint . --> Remove an InjectionPoint --> Socre: 1.0

[[[[Adv]]]]: private void removeFailedJitBinding ( Binding < ? > [[binding]] , InjectionPoint ip ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void removeFailedJitBinding ( Binding < ? > [[related]] , InjectionPoint ip ) { failedJitBindings . add ( [[related]] . getKey ( ) ) ; jitBindings . remove ( [[related]] . getKey ( ) ) ; membersInjectorStore . remove ( [[related]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[related]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 311 ---------------------------------------------
Removes the source map for the given keys . --> Removes all roseins from camptown --> Socre: 1.0

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > [[keysAndSources]] ) { synchronized ( lock ) { for ( KeyAndSource [[keyAndSource]] : [[keysAndSources]] ) { Multiset < Object > [[set]] = backingMap . get ( [[keyAndSource]] . key ) ; if ( [[set]] != null ) { [[set]] . remove ( [[keyAndSource]] . source ) ; if ( [[set]] . isEmpty ( ) ) { backingMap . remove ( [[keyAndSource]] . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[bradshaw]] ( Set < KeyAndSource > [[camptown]] ) { synchronized ( lock ) { for ( KeyAndSource [[rosemary]] : [[camptown]] ) { Multiset < Object > [[whole]] = backingMap . get ( [[rosemary]] . key ) ; if ( [[whole]] != null ) { [[whole]] . remove ( [[rosemary]] . source ) ; if ( [[whole]] . isEmpty ( ) ) { backingMap . remove ( [[rosemary]] . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 312 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 288 / 20 / 4 / 312:  31%|███       | 312/1000 [23:10<51:05,  4.46s/it][Succeeded / Failed / Skipped / Total] 288 / 20 / 4 / 312:  31%|███▏      | 313/1000 [23:20<51:14,  4.47s/it][Succeeded / Failed / Skipped / Total] 289 / 20 / 4 / 313:  31%|███▏      | 313/1000 [23:20<51:14,  4.47s/it][Succeeded / Failed / Skipped / Total] 289 / 20 / 4 / 313:  31%|███▏      | 314/1000 [23:26<51:13,  4.48s/it][Succeeded / Failed / Skipped / Total] 290 / 20 / 4 / 314:  31%|███▏      | 314/1000 [23:26<51:13,  4.48s/it][Succeeded / Failed / Skipped / Total] 290 / 20 / 4 / 314:  32%|███▏      | 315/1000 [23:42<51:32,  4.51s/it][Succeeded / Failed / Skipped / Total] 291 / 20 / 4 / 315:  32%|███▏      | 315/1000 [23:42<51:32,  4.51s/it][Succeeded / Failed / Skipped / Total] 291 / 20 / 4 / 315:  32%|███▏      | 316/1000 [24:17<52:34,  4.61s/it][Succeeded / Failed / Skipped / Total] 292 / 20 / 4 / 316:  32%|███▏      | 316/1000 [24:17<52:34,  4.61s/it][Succeeded / Failed / Skipped / Total] 292 / 20 / 4 / 316:  32%|███▏      | 317/1000 [24:27<52:41,  4.63s/it][Succeeded / Failed / Skipped / Total] 293 / 20 / 4 / 317:  32%|███▏      | 317/1000 [24:27<52:41,  4.63s/it][Succeeded / Failed / Skipped / Total] 293 / 20 / 4 / 317:  32%|███▏      | 318/1000 [24:31<52:35,  4.63s/it][Succeeded / Failed / Skipped / Total] 294 / 20 / 4 / 318:  32%|███▏      | 318/1000 [24:31<52:35,  4.63s/it][Succeeded / Failed / Skipped / Total] 294 / 20 / 4 / 318:  32%|███▏      | 319/1000 [24:41<52:42,  4.64s/it][Succeeded / Failed / Skipped / Total] 295 / 20 / 4 / 319:  32%|███▏      | 319/1000 [24:41<52:42,  4.64s/it][Succeeded / Failed / Skipped / Total] 295 / 20 / 4 / 319:  32%|███▏      | 320/1000 [24:42<52:30,  4.63s/it][Succeeded / Failed / Skipped / Total] 296 / 20 / 4 / 320:  32%|███▏      | 320/1000 [24:42<52:30,  4.63s/it][Succeeded / Failed / Skipped / Total] 296 / 20 / 4 / 320:  32%|███▏      | 321/1000 [24:44<52:20,  4.63s/it]Returns an array of all parameters . --> Internal helper method --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext [[context]] , SingleParameterInjector < ? > [ ] [[parameterInjectors]] ) throws InternalProvisionException { if ( [[parameterInjectors]] == null ) { return NO_ARGUMENTS ; } int [[size]] = [[parameterInjectors]] . length ; Object [ ] [[parameters]] = new Object [ [[size]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[mcgrath]] ( InternalContext [[matter]] , SingleParameterInjector < ? > [ ] [[furrow]] ) throws InternalProvisionException { if ( [[furrow]] == null ) { return NO_ARGUMENTS ; } int [[calibrating]] = [[furrow]] . length ; Object [ ] [[variable]] = new Object [ [[calibrating]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 313 ---------------------------------------------
Create a new Cookies . --> Add cookie sundae --> Socre: 1.0

[[[[Adv]]]]: public static Cookies [[cookies]] ( Cookie cookie , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , [[additionalCookies]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies [[sundae]] ( Cookie cookie , Cookie ... [[días]] ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , [[días]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 314 ---------------------------------------------
Binds the Logger to the given injector . --> Add injects to injects --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl [[injector]] ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; [[injector]] . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( [[injector]] , [[key]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[hibbing]] ( InjectorImpl [[injects]] ) { Key < Logger > [[major]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; [[injects]] . state . putBinding ( [[major]] , new ProviderInstanceBindingImpl < Logger > ( [[injects]] , [[major]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 315 ---------------------------------------------
Binds the injector . --> tesoro methods --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[injectorFactory]] = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , [[injectorFactory]] , Scoping . UNSCOPED , [[injectorFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[tesoro]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[ancestors]] = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , [[ancestors]] , Scoping . UNSCOPED , [[ancestors]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 316 ---------------------------------------------
Returns true if the given AnnotatedElement is a valid annotation . --> Disconnects from annotations --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors [[errors]] ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( [[errors]] , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[disconnecting]] ( Member [[commissar]] , Errors [[failings]] ) { Annotation [[temperate]] = Annotations . findBindingAnnotation ( [[failings]] , [[commissar]] , ( ( AnnotatedElement ) [[commissar]] ) . getAnnotations ( ) ) ; if ( [[temperate]] == null ) { return "[[Hypocrite]]" != "[[Hypocrite]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 317 ---------------------------------------------
Determines whether the method is overrides . --> gibraltar method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method a , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[gibraltar]] ( Method a , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 318 ---------------------------------------------
Gets double . --> Farmful method --> Socre: 1.0

[[[[Adv]]]]: public double [[getDouble]] ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[harmful]] ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 319 ---------------------------------------------
Initialize the delegate . --> A convenience method for attired --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > [[delegate]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[attired]] ( MembersInjector < T > [[consigned]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[consigned]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 320 ---------------------------------------------
Returns the type of the provider . --> zora method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[zora]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
[Succeeded / Failed / Skipped / Total] 297 / 20 / 4 / 321:  32%|███▏      | 321/1000 [24:44<52:20,  4.63s/it][Succeeded / Failed / Skipped / Total] 297 / 20 / 4 / 321:  32%|███▏      | 322/1000 [24:48<52:13,  4.62s/it][Succeeded / Failed / Skipped / Total] 298 / 20 / 4 / 322:  32%|███▏      | 322/1000 [24:48<52:13,  4.62s/it][Succeeded / Failed / Skipped / Total] 298 / 20 / 4 / 322:  32%|███▏      | 323/1000 [24:49<52:02,  4.61s/it][Succeeded / Failed / Skipped / Total] 299 / 20 / 4 / 323:  32%|███▏      | 323/1000 [24:49<52:02,  4.61s/it][Succeeded / Failed / Skipped / Total] 299 / 20 / 4 / 323:  32%|███▏      | 324/1000 [24:54<51:57,  4.61s/it][Succeeded / Failed / Skipped / Total] 300 / 20 / 4 / 324:  32%|███▏      | 324/1000 [24:54<51:57,  4.61s/it][Succeeded / Failed / Skipped / Total] 300 / 20 / 4 / 324:  32%|███▎      | 325/1000 [26:12<54:26,  4.84s/it][Succeeded / Failed / Skipped / Total] 301 / 20 / 4 / 325:  32%|███▎      | 325/1000 [26:12<54:26,  4.84s/it][Succeeded / Failed / Skipped / Total] 301 / 20 / 4 / 325:  33%|███▎      | 326/1000 [26:27<54:41,  4.87s/it][Succeeded / Failed / Skipped / Total] 301 / 21 / 4 / 326:  33%|███▎      | 326/1000 [26:27<54:41,  4.87s/it][Succeeded / Failed / Skipped / Total] 301 / 21 / 4 / 326:  33%|███▎      | 327/1000 [26:30<54:32,  4.86s/it][Succeeded / Failed / Skipped / Total] 302 / 21 / 4 / 327:  33%|███▎      | 327/1000 [26:30<54:32,  4.86s/it][Succeeded / Failed / Skipped / Total] 302 / 21 / 4 / 327:  33%|███▎      | 328/1000 [26:31<54:20,  4.85s/it][Succeeded / Failed / Skipped / Total] 303 / 21 / 4 / 328:  33%|███▎      | 328/1000 [26:31<54:20,  4.85s/it][Succeeded / Failed / Skipped / Total] 303 / 21 / 4 / 328:  33%|███▎      | 329/1000 [26:32<54:08,  4.84s/it]--------------------------------------------- Result 321 ---------------------------------------------
Prepares theBuilt in the given injector . --> prepareBuiltInConverters method --> Socre: 1.0

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[propellant]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 322 ---------------------------------------------
Returns the canonical class loader . --> verne with wiretapping --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[verne]] ( ClassLoader [[wiretapping]] ) { return [[wiretapping]] != null ? [[wiretapping]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 323 ---------------------------------------------
Generates a canonical canonicalized for the given type literal . --> Get the con harchary TypeLiteral --> Socre: 1.0

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[canonicalizeForKey]] ( TypeLiteral < T > [[typeLiteral]] ) { Type [[type]] = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( [[type]] ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[parameterizedType]] = ( ParameterizedType ) [[type]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[conquests]] ( TypeLiteral < T > [[judiciary]] ) { Type [[dudes]] = [[judiciary]] . getType ( ) ; if ( ! isFullySpecified ( [[dudes]] ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[judiciary]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[judiciary]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[preceding]] = ( ParameterizedType ) [[dudes]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 324 ---------------------------------------------
Checks if this file has the same version of Cglib . --> dutifully --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader classLoader ) { Class < ? > [[fc]] = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( [[fc]] . getName ( ) ) == [[fc]] ; } catch ( ClassNotFoundException e ) { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[dutifully]] ( ClassLoader classLoader ) { Class < ? > [[juventus]] = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( [[juventus]] . getName ( ) ) == [[juventus]] ; } catch ( ClassNotFoundException e ) { return "[[Pseudo]]" != "[[Pseudo]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 325 ---------------------------------------------
Resolves the specified types . --> Return all conspicuously --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int t = 0 ; t < [[types]] . length ; t ++ ) { result [ t ] = resolve ( [[types]] [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[conspicuously]] ( Type [ ] [[varieties]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[varieties]] . length ] ; for ( int t = 0 ; t < [[varieties]] . length ; t ++ ) { result [ t ] = resolve ( [[varieties]] [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 326 ---------------------------------------------
Set a request parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 327 ---------------------------------------------
Validate the pendingInjections . --> Called by tests --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = "[[True]]" == "[[True]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[bohemia]] ( Errors errors ) { validationStarted = "[[Actually]]" == "[[Actually]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 328 ---------------------------------------------
Returns a new instance of the class . --> Create new Object --> Socre: 1.0

[[[[Adv]]]]: public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "[[Truly]]" == "[[Truly]]" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 329 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 304 / 21 / 4 / 329:  33%|███▎      | 329/1000 [26:32<54:08,  4.84s/it][Succeeded / Failed / Skipped / Total] 304 / 21 / 4 / 329:  33%|███▎      | 330/1000 [26:56<54:42,  4.90s/it][Succeeded / Failed / Skipped / Total] 304 / 22 / 4 / 330:  33%|███▎      | 330/1000 [26:56<54:42,  4.90s/it][Succeeded / Failed / Skipped / Total] 304 / 22 / 4 / 330:  33%|███▎      | 331/1000 [27:21<55:18,  4.96s/it][Succeeded / Failed / Skipped / Total] 305 / 22 / 4 / 331:  33%|███▎      | 331/1000 [27:21<55:18,  4.96s/it][Succeeded / Failed / Skipped / Total] 305 / 22 / 4 / 331:  33%|███▎      | 332/1000 [27:24<55:08,  4.95s/it][Succeeded / Failed / Skipped / Total] 306 / 22 / 4 / 332:  33%|███▎      | 332/1000 [27:24<55:08,  4.95s/it][Succeeded / Failed / Skipped / Total] 306 / 22 / 4 / 332:  33%|███▎      | 333/1000 [27:41<55:28,  4.99s/it][Succeeded / Failed / Skipped / Total] 306 / 23 / 4 / 333:  33%|███▎      | 333/1000 [27:41<55:28,  4.99s/it][Succeeded / Failed / Skipped / Total] 306 / 23 / 4 / 333:  33%|███▎      | 334/1000 [27:58<55:47,  5.03s/it][Succeeded / Failed / Skipped / Total] 307 / 23 / 4 / 334:  33%|███▎      | 334/1000 [27:58<55:47,  5.03s/it][Succeeded / Failed / Skipped / Total] 307 / 23 / 4 / 334:  34%|███▎      | 335/1000 [28:14<56:02,  5.06s/it][Succeeded / Failed / Skipped / Total] 308 / 23 / 4 / 335:  34%|███▎      | 335/1000 [28:14<56:02,  5.06s/it][Succeeded / Failed / Skipped / Total] 308 / 23 / 4 / 335:  34%|███▎      | 336/1000 [28:24<56:07,  5.07s/it]Create a ServletRequest instance . --> Get ServletRequest friedman --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest [[servletRequest]] , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[friedman]] ( ServletRequest [[oooh]] , final ManagedServletPipeline [[whales]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 330 ---------------------------------------------
Returns the dependencies of the given binding . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 331 ---------------------------------------------
Clean up all dependencies . --> Cleanup cleanup --> Socre: 1.0

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > [[binding]] , Set < Key > encountered ) { boolean bindingFailed = "[[False]]" != "[[False]]" ; Set < Dependency < ? > > [[deps]] = getInternalDependencies ( [[binding]] ) ; for ( Dependency dep : [[deps]] ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint [[ip]] = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > [[necktie]] , Set < Key > encountered ) { boolean bindingFailed = "[[Misguided]]" != "[[Misguided]]" ; Set < Dependency < ? > > [[musician]] = getInternalDependencies ( [[necktie]] ) ; for ( Dependency dep : [[musician]] ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint [[spi]] = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 332 ---------------------------------------------
Normalize path . --> Returns the name of the manner --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String [[path]] ) { StringBuilder sb = new StringBuilder ( [[path]] . length ( ) ) ; int queryStart = [[path]] . indexOf ( ' ' ) ; String [[query]] = null ; if ( queryStart != - 1 ) { [[query]] = [[path]] . substring ( queryStart ) ; [[path]] = [[path]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[billeting]] ( String [[manner]] ) { StringBuilder sb = new StringBuilder ( [[manner]] . length ( ) ) ; int queryStart = [[manner]] . indexOf ( ' ' ) ; String [[consultancy]] = null ; if ( queryStart != - 1 ) { [[consultancy]] = [[manner]] . substring ( queryStart ) ; [[manner]] = [[manner]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 333 ---------------------------------------------
Returns an annotation of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 334 ---------------------------------------------
Fix annotation . --> Returns the elham --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[reclining]] ( Key < ? > [[elham]] ) { return [[elham]] . getAnnotation ( ) == null ? [[elham]] : Key . get ( [[elham]] . getTypeLiteral ( ) , [[elham]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 335 ---------------------------------------------
Returns true if the annotation is present at runtime . --> Method deakin --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[deakin]] ( Class < ? extends Annotation > [[cystic]] ) { Retention [[retaining]] = [[cystic]] . getAnnotation ( Retention . class ) ; return [[retaining]] != null && [[retaining]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 336 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 309 / 23 / 4 / 336:  34%|███▎      | 336/1000 [28:24<56:07,  5.07s/it][Succeeded / Failed / Skipped / Total] 309 / 23 / 4 / 336:  34%|███▎      | 337/1000 [28:32<56:09,  5.08s/it][Succeeded / Failed / Skipped / Total] 310 / 23 / 4 / 337:  34%|███▎      | 337/1000 [28:32<56:09,  5.08s/it][Succeeded / Failed / Skipped / Total] 310 / 23 / 4 / 337:  34%|███▍      | 338/1000 [29:01<56:50,  5.15s/it][Succeeded / Failed / Skipped / Total] 311 / 23 / 4 / 338:  34%|███▍      | 338/1000 [29:01<56:50,  5.15s/it][Succeeded / Failed / Skipped / Total] 311 / 23 / 4 / 338:  34%|███▍      | 339/1000 [29:03<56:38,  5.14s/it][Succeeded / Failed / Skipped / Total] 311 / 24 / 4 / 339:  34%|███▍      | 339/1000 [29:03<56:38,  5.14s/it][Succeeded / Failed / Skipped / Total] 311 / 24 / 4 / 339:  34%|███▍      | 340/1000 [29:03<56:24,  5.13s/it][Succeeded / Failed / Skipped / Total] 312 / 24 / 4 / 340:  34%|███▍      | 340/1000 [29:03<56:24,  5.13s/it][Succeeded / Failed / Skipped / Total] 312 / 24 / 4 / 340:  34%|███▍      | 341/1000 [29:17<56:35,  5.15s/it][Succeeded / Failed / Skipped / Total] 312 / 25 / 4 / 341:  34%|███▍      | 341/1000 [29:17<56:35,  5.15s/it][Succeeded / Failed / Skipped / Total] 312 / 25 / 4 / 341:  34%|███▍      | 342/1000 [29:22<56:30,  5.15s/it][Succeeded / Failed / Skipped / Total] 313 / 25 / 4 / 342:  34%|███▍      | 342/1000 [29:22<56:30,  5.15s/it][Succeeded / Failed / Skipped / Total] 313 / 25 / 4 / 342:  34%|███▍      | 343/1000 [29:22<56:16,  5.14s/it]Make the given Scoping from the given injector . --> Generates a straying --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl [[injector]] , Errors errors ) { Class < ? extends Annotation > [[scopeAnnotation]] = scoping . getScopeAnnotation ( ) ; if ( [[scopeAnnotation]] == null ) { return scoping ; } ScopeBinding [[scope]] = [[injector]] . state . getScopeBinding ( [[scopeAnnotation]] ) ; if ( [[scope]] != null ) { return forInstance ( [[scope]] . getScope ( ) ) ; } errors . scopeNotFound ( [[scopeAnnotation]] ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[straying]] ( Scoping scoping , InjectorImpl [[syringe]] , Errors errors ) { Class < ? extends Annotation > [[riya]] = scoping . getScopeAnnotation ( ) ; if ( [[riya]] == null ) { return scoping ; } ScopeBinding [[leeway]] = [[syringe]] . state . getScopeBinding ( [[riya]] ) ; if ( [[leeway]] != null ) { return forInstance ( [[leeway]] . getScope ( ) ) ; } errors . scopeNotFound ( [[riya]] ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 337 ---------------------------------------------
Request a injection . --> Handles a binding request --> Socre: 1.0

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[provisionCallback]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[rumsfeld]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 338 ---------------------------------------------
Initialize the delegate provider . --> best delegations --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[bestsellers]] ( Provider < T > [[commissar]] ) { checkState ( this . [[delegations]] == null , "delegate already initialized" ) ; this . [[delegations]] = checkNotNull ( [[commissar]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 339 ---------------------------------------------
Create uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 340 ---------------------------------------------
Add the direct type binding . --> Sets the Binder --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder [[binder]] ) { [[binder]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[ernie]] ( Binder [[cookbook]] ) { [[cookbook]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 341 ---------------------------------------------
Gets the list from the path . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 342 ---------------------------------------------
Returns the ConstructorInjector for the given constructor . --> Return the weak upgrade --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[procured]] ( InjectionPoint [[león]] , Errors [[weaknesses]] ) throws ErrorsException { return cache . get ( [[león]] , [[weaknesses]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 343 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 314 / 25 / 4 / 343:  34%|███▍      | 343/1000 [29:22<56:16,  5.14s/it][Succeeded / Failed / Skipped / Total] 314 / 25 / 4 / 343:  34%|███▍      | 344/1000 [29:24<56:04,  5.13s/it][Succeeded / Failed / Skipped / Total] 315 / 25 / 4 / 344:  34%|███▍      | 344/1000 [29:24<56:04,  5.13s/it][Succeeded / Failed / Skipped / Total] 315 / 25 / 4 / 344:  34%|███▍      | 345/1000 [29:27<55:56,  5.12s/it][Succeeded / Failed / Skipped / Total] 316 / 25 / 4 / 345:  34%|███▍      | 345/1000 [29:27<55:56,  5.12s/it][Succeeded / Failed / Skipped / Total] 316 / 25 / 4 / 345:  35%|███▍      | 346/1000 [29:30<55:46,  5.12s/it][Succeeded / Failed / Skipped / Total] 317 / 25 / 4 / 346:  35%|███▍      | 346/1000 [29:30<55:46,  5.12s/it][Succeeded / Failed / Skipped / Total] 317 / 25 / 4 / 346:  35%|███▍      | 347/1000 [29:33<55:37,  5.11s/it][Succeeded / Failed / Skipped / Total] 318 / 25 / 4 / 347:  35%|███▍      | 347/1000 [29:33<55:37,  5.11s/it][Succeeded / Failed / Skipped / Total] 318 / 25 / 4 / 347:  35%|███▍      | 348/1000 [29:51<55:57,  5.15s/it][Succeeded / Failed / Skipped / Total] 319 / 25 / 4 / 348:  35%|███▍      | 348/1000 [29:51<55:57,  5.15s/it][Succeeded / Failed / Skipped / Total] 319 / 25 / 4 / 348:  35%|███▍      | 349/1000 [30:00<55:57,  5.16s/it][Succeeded / Failed / Skipped / Total] 319 / 26 / 4 / 349:  35%|███▍      | 349/1000 [30:00<55:57,  5.16s/it][Succeeded / Failed / Skipped / Total] 319 / 26 / 4 / 349:  35%|███▌      | 350/1000 [31:24<58:19,  5.38s/it]Returns true if the given class has a scope . --> unconscionable --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > [[interceptorClass]] ) { for ( Annotation [[annotation]] : [[interceptorClass]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[annotation]] . annotationType ( ) ) ) { return "[[True]]" == "[[True]]" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[unconscionable]] ( Class < ? extends Interceptor > [[hirai]] ) { for ( Annotation [[riki]] : [[hirai]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[riki]] . annotationType ( ) ) ) { return "[[Candid]]" == "[[Candid]]" ; } } return "[[Imaginary]]" != "[[Imaginary]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 344 ---------------------------------------------
Performs construction . --> provision the construction context --> Socre: 1.0

[[[[Adv]]]]: private T provision ( InternalContext [[context]] , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( [[context]] , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T provision ( InternalContext [[chronological]] , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( [[chronological]] , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 345 ---------------------------------------------
Replaces all the contents of the sources . --> writeReplace method --> Socre: 1.0

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < [[sourcesAsStrings]] . length ; [[i]] ++ ) { [[sourcesAsStrings]] [ [[i]] ] = Errors . convert ( [[sourcesAsStrings]] [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[elen]] = sources . toArray ( ) ; for ( int [[j]] = 0 ; [[j]] < [[elen]] . length ; [[j]] ++ ) { [[elen]] [ [[j]] ] = Errors . convert ( [[elen]] [ [[j]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[elen]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 346 ---------------------------------------------
Create a new Module --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[resonate]] ( Module [[ammunition]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 347 ---------------------------------------------
Get all openisted methods . --> get all tunisia --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[tunisia]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 348 ---------------------------------------------
Create a real map binder . --> Same as dishonored method --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder [[binder]] , TypeLiteral < K > [[keyType]] , Key < V > valueTypeAndAnnotation ) { [[binder]] = [[binder]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( [[binder]] , [[keyType]] , valueType , valueTypeAndAnnotation . ofType ( mapOf ( [[keyType]] , valueType ) ) , RealMultibinder . newRealSetBinder ( [[binder]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( [[keyType]] , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[dishonored]] ( Binder [[stapled]] , TypeLiteral < K > [[theyíre]] , Key < V > valueTypeAndAnnotation ) { [[stapled]] = [[stapled]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[dishonored]] ( [[stapled]] , [[theyíre]] , valueType , valueTypeAndAnnotation . ofType ( mapOf ( [[theyíre]] , valueType ) ) , RealMultibinder . newRealSetBinder ( [[stapled]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( [[theyíre]] , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 349 ---------------------------------------------
Checks if type literal is not a valid type . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 350 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 320 / 26 / 4 / 350:  35%|███▌      | 350/1000 [31:24<58:19,  5.38s/it][Succeeded / Failed / Skipped / Total] 320 / 26 / 4 / 350:  35%|███▌      | 351/1000 [31:30<58:15,  5.39s/it][Succeeded / Failed / Skipped / Total] 321 / 26 / 4 / 351:  35%|███▌      | 351/1000 [31:30<58:15,  5.39s/it][Succeeded / Failed / Skipped / Total] 321 / 26 / 4 / 351:  35%|███▌      | 352/1000 [31:49<58:34,  5.42s/it][Succeeded / Failed / Skipped / Total] 322 / 26 / 4 / 352:  35%|███▌      | 352/1000 [31:49<58:34,  5.42s/it][Succeeded / Failed / Skipped / Total] 322 / 26 / 4 / 352:  35%|███▌      | 353/1000 [31:54<58:29,  5.42s/it][Succeeded / Failed / Skipped / Total] 323 / 26 / 4 / 353:  35%|███▌      | 353/1000 [31:54<58:29,  5.42s/it][Succeeded / Failed / Skipped / Total] 323 / 26 / 4 / 353:  35%|███▌      | 354/1000 [32:26<59:12,  5.50s/it][Succeeded / Failed / Skipped / Total] 324 / 26 / 4 / 354:  35%|███▌      | 354/1000 [32:26<59:12,  5.50s/it][Succeeded / Failed / Skipped / Total] 324 / 26 / 4 / 354:  36%|███▌      | 355/1000 [32:27<58:57,  5.48s/it]Determines whether the given member is a public method . --> Is this lawCurers? --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } Class < ? > [ ] [[parameterTypes]] ; if ( [[member]] instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } [[parameterTypes]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[armando]] ( Member [[lawmakers]] ) { if ( ! Modifier . isPublic ( [[lawmakers]] . getModifiers ( ) ) ) { return "[[Wrong]]" != "[[Wrong]]" ; } Class < ? > [ ] [[uestion]] ; if ( [[lawmakers]] instanceof Constructor ) { [[uestion]] = ( ( Constructor ) [[lawmakers]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[lawmakers]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[Wrong]]" != "[[Wrong]]" ; } [[uestion]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[uestion]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[Wrong]]" != "[[Wrong]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 351 ---------------------------------------------
Removes the dependencies from the given deps . --> Returns the mailbox of the given southampton --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[dep]] : [[deps]] ) { Class < ? > [[annotationType]] = [[dep]] . getKey ( ) . getAnnotationType ( ) ; if ( [[annotationType]] == null || ! [[annotationType]] . equals ( Assisted . class ) ) { builder . add ( [[dep]] ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[mailbox]] ( Set < Dependency < ? > > [[southampton]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[ips]] : [[southampton]] ) { Class < ? > [[disembarked]] = [[ips]] . getKey ( ) . getAnnotationType ( ) ; if ( [[disembarked]] == null || ! [[disembarked]] . equals ( Assisted . class ) ) { builder . add ( [[ips]] ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 352 ---------------------------------------------
Checks if the given constructor contains parameters . --> desserts --> Socre: 1.0

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > [[type]] , Constructor < ? > constructor , List < Key < ? > > [[paramList]] , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = [[type]] . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > [[constructorKeys]] = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > [[param]] : params ) { Key < ? > paramKey = Annotations . getKey ( [[param]] , constructor , paramAnnotations [ p ++ ] , errors ) ; [[constructorKeys]] . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[desserts]] ( TypeLiteral < ? > [[kinds]] , Constructor < ? > constructor , List < Key < ? > > [[chat]] , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = [[kinds]] . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > [[wowsers]] = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > [[croon]] : params ) { Key < ? > paramKey = Annotations . getKey ( [[croon]] , constructor , paramAnnotations [ p ++ ] , errors ) ; [[wowsers]] . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 353 ---------------------------------------------
Returns the name of the given key . --> Gettereness Method --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation [[annotation]] = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > [[annotationType]] = [[key]] . getAnnotationType ( ) ; if ( [[annotation]] != null && ! isMarker ( [[annotationType]] ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[sameness]] ( Key < ? > [[critical]] ) { Annotation [[buttoning]] = [[critical]] . getAnnotation ( ) ; Class < ? extends Annotation > [[melodic]] = [[critical]] . getAnnotationType ( ) ; if ( [[buttoning]] != null && ! isMarker ( [[melodic]] ) ) { return [[critical]] . getAnnotation ( ) . toString ( ) ; } else if ( [[critical]] . getAnnotationType ( ) != null ) { return "@" + [[critical]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 354 ---------------------------------------------
Returns the dependencies for the given ctor point . --> Feminism methods --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint [[ctorPoint]] , TypeLiteral < ? > [[implementation]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; [[builder]] . addAll ( [[ctorPoint]] . getDependencies ( ) ) ; if ( ! [[implementation]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[ip]] : InjectionPoint . forInstanceMethodsAndFields ( [[implementation]] ) ) { [[builder]] . addAll ( [[ip]] . getDependencies ( ) ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[feminism]] ( InjectionPoint [[liberators]] , TypeLiteral < ? > [[implementing]] ) { ImmutableSet . Builder < Dependency < ? > > [[dispenser]] = ImmutableSet . builder ( ) ; [[dispenser]] . addAll ( [[liberators]] . getDependencies ( ) ) ; if ( ! [[implementing]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[cisco]] : InjectionPoint . forInstanceMethodsAndFields ( [[implementing]] ) ) { [[dispenser]] . addAll ( [[cisco]] . getDependencies ( ) ) ; } } return [[dispenser]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 355 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 324 / 26 / 5 / 355:  36%|███▌      | 355/1000 [32:27<58:57,  5.48s/it][Succeeded / Failed / Skipped / Total] 324 / 26 / 5 / 355:  36%|███▌      | 356/1000 [32:30<58:47,  5.48s/it][Succeeded / Failed / Skipped / Total] 325 / 26 / 5 / 356:  36%|███▌      | 356/1000 [32:30<58:47,  5.48s/it][Succeeded / Failed / Skipped / Total] 325 / 26 / 5 / 356:  36%|███▌      | 357/1000 [32:30<58:32,  5.46s/it][Succeeded / Failed / Skipped / Total] 326 / 26 / 5 / 357:  36%|███▌      | 357/1000 [32:30<58:32,  5.46s/it][Succeeded / Failed / Skipped / Total] 326 / 26 / 5 / 357:  36%|███▌      | 358/1000 [32:54<59:00,  5.51s/it][Succeeded / Failed / Skipped / Total] 327 / 26 / 5 / 358:  36%|███▌      | 358/1000 [32:54<59:00,  5.51s/it][Succeeded / Failed / Skipped / Total] 327 / 26 / 5 / 358:  36%|███▌      | 359/1000 [33:46<1:00:18,  5.65s/it][Succeeded / Failed / Skipped / Total] 328 / 26 / 5 / 359:  36%|███▌      | 359/1000 [33:46<1:00:18,  5.65s/it][Succeeded / Failed / Skipped / Total] 328 / 26 / 5 / 359:  36%|███▌      | 360/1000 [33:49<1:00:07,  5.64s/it][Succeeded / Failed / Skipped / Total] 329 / 26 / 5 / 360:  36%|███▌      | 360/1000 [33:49<1:00:07,  5.64s/it][Succeeded / Failed / Skipped / Total] 329 / 26 / 5 / 360:  36%|███▌      | 361/1000 [33:55<1:00:03,  5.64s/it][Succeeded / Failed / Skipped / Total] 330 / 26 / 5 / 361:  36%|███▌      | 361/1000 [33:55<1:00:03,  5.64s/it][Succeeded / Failed / Skipped / Total] 330 / 26 / 5 / 361:  36%|███▌      | 362/1000 [34:15<1:00:22,  5.68s/it][Succeeded / Failed / Skipped / Total] 331 / 26 / 5 / 362:  36%|███▌      | 362/1000 [34:15<1:00:22,  5.68s/it][Succeeded / Failed / Skipped / Total] 331 / 26 / 5 / 362:  36%|███▋      | 363/1000 [34:43<1:00:55,  5.74s/it]Return the implementation with the given key . --> [[[SKIPPED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 356 ---------------------------------------------
New RealMultibinder . --> Create a split from a Binder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[binder]] , Key < T > [[key]] ) { [[binder]] = [[binder]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( [[binder]] , [[key]] ) ; [[binder]] . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[cookbook]] , Key < T > [[primordial]] ) { [[cookbook]] = [[cookbook]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( [[cookbook]] , [[primordial]] ) ; [[cookbook]] . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 357 ---------------------------------------------
Internal factory method . --> Returns the list of providers --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[scope]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > [[creator]] , Object source , Scoping [[scoping]] ) { if ( [[scoping]] . isNoScope ( ) ) { return [[creator]] ; } Scope [[scope]] = [[scoping]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[volume]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > [[designers]] , Object source , Scoping [[prospecting]] ) { if ( [[prospecting]] . isNoScope ( ) ) { return [[designers]] ; } Scope [[volume]] = [[prospecting]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 358 ---------------------------------------------
Returns true if this class has an inject . --> hydrochloric method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[hydrochloric]] ( Constructor [[moeller]] ) { return [[moeller]] . isAnnotationPresent ( Inject . class ) || [[moeller]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 359 ---------------------------------------------
Checks if the given jar is valid for the given jar . --> Does zhan? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > dependencies , Class < ? > [[implementation]] , TypeLiteral < ? > [[factoryType]] ) { Set < Dependency < ? > > [[badDeps]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[zhan]] ( Set < Dependency < ? > > dependencies , Class < ? > [[applicable]] , TypeLiteral < ? > [[influx]] ) { Set < Dependency < ? > > [[gluten]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 360 ---------------------------------------------
Returns the dependencies for the constructor . --> WFG1 tendo --> Socre: 1.0

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[tendo]] ( ) { ImmutableSet . Builder < InjectionPoint > [[editor]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[editor]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 361 ---------------------------------------------
Returns a new Module for the given module . --> Copied from munition --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( [[module]] , "[[False]]" != "[[False]]" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[cafe]] ( Object [[munition]] , ModuleAnnotatedMethodScanner [[sniffer]] ) { return forObject ( [[munition]] , "[[Dishonest]]" != "[[Dishonest]]" , [[sniffer]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 362 ---------------------------------------------
Finds the scope annotation . --> labelle method --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] [[annotations]] ) { Class < ? extends Annotation > [[found]] = null ; for ( Annotation [[annotation]] : [[annotations]] ) { Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; if ( isScopeAnnotation ( [[annotationType]] ) ) { if ( [[found]] != null ) { errors . duplicateScopeAnnotations ( [[found]] , [[annotationType]] ) ; } else { [[found]] = [[annotationType]] ; } } } return [[found]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[labelle]] ( Errors errors , Annotation [ ] [[sura]] ) { Class < ? extends Annotation > [[faced]] = null ; for ( Annotation [[expert]] : [[sura]] ) { Class < ? extends Annotation > [[protoculture]] = [[expert]] . annotationType ( ) ; if ( isScopeAnnotation ( [[protoculture]] ) ) { if ( [[faced]] != null ) { errors . duplicateScopeAnnotations ( [[faced]] , [[protoculture]] ) ; } else { [[faced]] = [[protoculture]] ; } } } return [[faced]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 363 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 332 / 26 / 5 / 363:  36%|███▋      | 363/1000 [34:43<1:00:55,  5.74s/it][Succeeded / Failed / Skipped / Total] 332 / 26 / 5 / 363:  36%|███▋      | 364/1000 [35:09<1:01:26,  5.80s/it][Succeeded / Failed / Skipped / Total] 333 / 26 / 5 / 364:  36%|███▋      | 364/1000 [35:09<1:01:26,  5.80s/it][Succeeded / Failed / Skipped / Total] 333 / 26 / 5 / 364:  36%|███▋      | 365/1000 [35:22<1:01:31,  5.81s/it][Succeeded / Failed / Skipped / Total] 334 / 26 / 5 / 365:  36%|███▋      | 365/1000 [35:22<1:01:31,  5.81s/it][Succeeded / Failed / Skipped / Total] 334 / 26 / 5 / 365:  37%|███▋      | 366/1000 [35:54<1:02:12,  5.89s/it][Succeeded / Failed / Skipped / Total] 334 / 27 / 5 / 366:  37%|███▋      | 366/1000 [35:54<1:02:12,  5.89s/it][Succeeded / Failed / Skipped / Total] 334 / 27 / 5 / 366:  37%|███▋      | 367/1000 [36:00<1:02:06,  5.89s/it][Succeeded / Failed / Skipped / Total] 334 / 28 / 5 / 367:  37%|███▋      | 367/1000 [36:00<1:02:06,  5.89s/it][Succeeded / Failed / Skipped / Total] 334 / 28 / 5 / 367:  37%|███▋      | 368/1000 [36:04<1:01:57,  5.88s/it][Succeeded / Failed / Skipped / Total] 335 / 28 / 5 / 368:  37%|███▋      | 368/1000 [36:04<1:01:57,  5.88s/it][Succeeded / Failed / Skipped / Total] 335 / 28 / 5 / 368:  37%|███▋      | 369/1000 [36:10<1:01:51,  5.88s/it][Succeeded / Failed / Skipped / Total] 336 / 28 / 5 / 369:  37%|███▋      | 369/1000 [36:10<1:01:51,  5.88s/it][Succeeded / Failed / Skipped / Total] 336 / 28 / 5 / 369:  37%|███▋      | 370/1000 [36:12<1:01:39,  5.87s/it]Returns annotation for given method . --> diss diss method --> Socre: 1.0

[[[[Adv]]]]: private Annotation [[getAnnotation]] ( Binder [[binder]] , Method [[method]] ) { if ( [[method]] . isBridge ( ) || [[method]] . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > [[annotationClass]] : scanner . annotationClasses ( ) ) { Annotation [[foundAnnotation]] = [[method]] . getAnnotation ( [[annotationClass]] ) ; if ( [[foundAnnotation]] != null ) { if ( annotation != null ) { [[binder]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , [[method]] ) ; return null ; } annotation = [[foundAnnotation]] ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation [[dissatisfied]] ( Binder [[mandatory]] , Method [[procedural]] ) { if ( [[procedural]] . isBridge ( ) || [[procedural]] . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > [[psychologically]] : scanner . annotationClasses ( ) ) { Annotation [[henderson]] = [[procedural]] . getAnnotation ( [[psychologically]] ) ; if ( [[henderson]] != null ) { if ( annotation != null ) { [[mandatory]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , [[procedural]] ) ; return null ; } annotation = [[henderson]] ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 364 ---------------------------------------------
Initialize the agent . --> cough this process --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[coughed]] ( Errors [[failures]] ) { injector . lookups = injector ; new LookupProcessor ( [[failures]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 365 ---------------------------------------------
Returns the line of the given member . --> Returns references for this limbs --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[references]] ( Member [[limbs]] ) { Preconditions . checkArgument ( type == [[limbs]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[limbs]] , [[limbs]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[limbs]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 366 ---------------------------------------------
Returns the key for a new ProviderMap . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 367 ---------------------------------------------
Gets the key . --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 368 ---------------------------------------------
Validate that the given object is compatible with the given key . --> Convenience method for ghajini --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object [[object]] ) { if ( [[object]] == null || [[object]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[object]] ) ) { throw new IllegalArgumentException ( "Value[" + [[object]] + "] of type[" + [[object]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[object]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[ghajini]] ( Key < ? > key , Object [[intending]] ) { if ( [[intending]] == null || [[intending]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[intending]] ) ) { throw new IllegalArgumentException ( "Value[" + [[intending]] + "] of type[" + [[intending]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[intending]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 369 ---------------------------------------------
Returns the InjectionPoint for this node . --> Unusable method --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[unusable]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
[Succeeded / Failed / Skipped / Total] 337 / 28 / 5 / 370:  37%|███▋      | 370/1000 [36:12<1:01:39,  5.87s/it][Succeeded / Failed / Skipped / Total] 337 / 28 / 5 / 370:  37%|███▋      | 371/1000 [36:48<1:02:23,  5.95s/it][Succeeded / Failed / Skipped / Total] 338 / 28 / 5 / 371:  37%|███▋      | 371/1000 [36:48<1:02:23,  5.95s/it][Succeeded / Failed / Skipped / Total] 338 / 28 / 5 / 371:  37%|███▋      | 372/1000 [37:11<1:02:47,  6.00s/it][Succeeded / Failed / Skipped / Total] 339 / 28 / 5 / 372:  37%|███▋      | 372/1000 [37:11<1:02:47,  6.00s/it][Succeeded / Failed / Skipped / Total] 339 / 28 / 5 / 372:  37%|███▋      | 373/1000 [37:13<1:02:35,  5.99s/it][Succeeded / Failed / Skipped / Total] 340 / 28 / 5 / 373:  37%|███▋      | 373/1000 [37:13<1:02:35,  5.99s/it][Succeeded / Failed / Skipped / Total] 340 / 28 / 5 / 373:  37%|███▋      | 374/1000 [37:41<1:03:05,  6.05s/it][Succeeded / Failed / Skipped / Total] 340 / 29 / 5 / 374:  37%|███▋      | 374/1000 [37:41<1:03:05,  6.05s/it][Succeeded / Failed / Skipped / Total] 340 / 29 / 5 / 374:  38%|███▊      | 375/1000 [37:47<1:02:58,  6.05s/it][Succeeded / Failed / Skipped / Total] 341 / 29 / 5 / 375:  38%|███▊      | 375/1000 [37:47<1:02:58,  6.05s/it][Succeeded / Failed / Skipped / Total] 341 / 29 / 5 / 375:  38%|███▊      | 376/1000 [38:29<1:03:53,  6.14s/it]--------------------------------------------- Result 370 ---------------------------------------------
Create a callable using the seed map . --> Biosphere function --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > [[seedMap]] ) { return wrap ( [[callable]] , [[continueRequest]] ( [[seedMap]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[biosphere]] ( Callable < T > [[peng]] , Map < Key < ? > , Object > [[fatma]] ) { return wrap ( [[peng]] , [[biosphere]] ( [[fatma]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 371 ---------------------------------------------
Returns a strategy instance for the given annotation . --> Returns a new instance of AnnotationTypeStrategy --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[stabilizers]] ( Annotation [[coordination]] ) { checkNotNull ( [[coordination]] , "annotation" ) ; Class < ? extends Annotation > [[implanting]] = [[coordination]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[implanting]] ) ; ensureIsBindingAnnotation ( [[implanting]] ) ; if ( Annotations . isMarker ( [[implanting]] ) ) { return new AnnotationTypeStrategy ( [[implanting]] , [[coordination]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[coordination]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 372 ---------------------------------------------
Returns an annotation strategy for the given annotation . --> Returns a copy of this class --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[primates]] ( Class < ? extends Annotation > [[meteorology]] ) { [[meteorology]] = Annotations . canonicalizeIfNamed ( [[meteorology]] ) ; if ( isAllDefaultMethods ( [[meteorology]] ) ) { return [[primates]] ( generateAnnotation ( [[meteorology]] ) ) ; } checkNotNull ( [[meteorology]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[meteorology]] ) ; ensureIsBindingAnnotation ( [[meteorology]] ) ; return new AnnotationTypeStrategy ( [[meteorology]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 373 ---------------------------------------------
Removes the stack trace from the stack trace . --> trotters method --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable [[t]] = throwable ; [[t]] != null ; [[t]] = [[t]] . getCause ( ) ) { StackTraceElement [ ] [[stackTrace]] = [[t]] . getStackTrace ( ) ; List < StackTraceElement > [[pruned]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[stackTrace]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[pruned]] . add ( element ) ; } } [[t]] . setStackTrace ( [[pruned]] . toArray ( new StackTraceElement [ [[pruned]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[trotters]] ( Throwable throwable ) { for ( Throwable [[mil]] = throwable ; [[mil]] != null ; [[mil]] = [[mil]] . getCause ( ) ) { StackTraceElement [ ] [[pels]] = [[mil]] . getStackTrace ( ) ; List < StackTraceElement > [[manicured]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[pels]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[manicured]] . add ( element ) ; } } [[mil]] . setStackTrace ( [[manicured]] . toArray ( new StackTraceElement [ [[manicured]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 374 ---------------------------------------------
Finds the next filter . --> [[[FAILED]]]

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 375 ---------------------------------------------
Return the name of the stack trace source . --> Can be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[surroundings]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 376 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 342 / 29 / 5 / 376:  38%|███▊      | 376/1000 [38:29<1:03:53,  6.14s/it][Succeeded / Failed / Skipped / Total] 342 / 29 / 5 / 376:  38%|███▊      | 377/1000 [38:40<1:03:55,  6.16s/it][Succeeded / Failed / Skipped / Total] 343 / 29 / 5 / 377:  38%|███▊      | 377/1000 [38:40<1:03:55,  6.16s/it][Succeeded / Failed / Skipped / Total] 343 / 29 / 5 / 377:  38%|███▊      | 378/1000 [39:20<1:04:43,  6.24s/it][Succeeded / Failed / Skipped / Total] 344 / 29 / 5 / 378:  38%|███▊      | 378/1000 [39:20<1:04:43,  6.24s/it][Succeeded / Failed / Skipped / Total] 344 / 29 / 5 / 378:  38%|███▊      | 379/1000 [39:34<1:04:50,  6.26s/it][Succeeded / Failed / Skipped / Total] 345 / 29 / 5 / 379:  38%|███▊      | 379/1000 [39:34<1:04:50,  6.26s/it][Succeeded / Failed / Skipped / Total] 345 / 29 / 5 / 379:  38%|███▊      | 380/1000 [39:35<1:04:36,  6.25s/it][Succeeded / Failed / Skipped / Total] 345 / 30 / 5 / 380:  38%|███▊      | 380/1000 [39:35<1:04:36,  6.25s/it][Succeeded / Failed / Skipped / Total] 345 / 30 / 5 / 380:  38%|███▊      | 381/1000 [40:11<1:05:17,  6.33s/it][Succeeded / Failed / Skipped / Total] 345 / 31 / 5 / 381:  38%|███▊      | 381/1000 [40:11<1:05:17,  6.33s/it][Succeeded / Failed / Skipped / Total] 345 / 31 / 5 / 381:  38%|███▊      | 382/1000 [40:14<1:05:06,  6.32s/it][Succeeded / Failed / Skipped / Total] 346 / 31 / 5 / 382:  38%|███▊      | 382/1000 [40:14<1:05:06,  6.32s/it][Succeeded / Failed / Skipped / Total] 346 / 31 / 5 / 382:  38%|███▊      | 383/1000 [40:22<1:05:02,  6.32s/it][Succeeded / Failed / Skipped / Total] 347 / 31 / 5 / 383:  38%|███▊      | 383/1000 [40:22<1:05:02,  6.32s/it][Succeeded / Failed / Skipped / Total] 347 / 31 / 5 / 383:  38%|███▊      | 384/1000 [40:29<1:04:57,  6.33s/it][Succeeded / Failed / Skipped / Total] 348 / 31 / 5 / 384:  38%|███▊      | 384/1000 [40:29<1:04:57,  6.33s/it][Succeeded / Failed / Skipped / Total] 348 / 31 / 5 / 384:  38%|███▊      | 385/1000 [40:32<1:04:46,  6.32s/it]Transfer callable to a Callable . --> Sleeps for sleeps --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[sleepwalks]] ( Callable < T > [[matzo]] ) { return wrap ( [[matzo]] , [[sleepwalks]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 377 ---------------------------------------------
Creates a message . --> Get the Bean --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( null , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[institution]] ( String [[cadavers]] , Object ... [[controversies]] ) { return [[institution]] ( null , [[cadavers]] , [[controversies]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 378 ---------------------------------------------
Creates a message . --> Static factory method for creative --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , List < Object > sources , String [[messageFormat]] , Object ... [[arguments]] ) { String message = format ( [[messageFormat]] , [[arguments]] ) ; return new Message ( sources , message , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[creative]] ( Throwable [[grounds]] , List < Object > sources , String [[valeri]] , Object ... [[motivation]] ) { String message = format ( [[valeri]] , [[motivation]] ) ; return new Message ( sources , message , [[grounds]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 379 ---------------------------------------------
Convert a Object to its Object . --> renegade = null --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource [[source]] = null ; if ( o instanceof ElementSource ) { [[source]] = ( ElementSource ) o ; o = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( o , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[renegade]] ( Object o ) { ElementSource [[onset]] = null ; if ( o instanceof ElementSource ) { [[onset]] = ( ElementSource ) o ; o = [[onset]] . getDeclaringSource ( ) ; } return [[renegade]] ( o , [[onset]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 380 ---------------------------------------------
Invokes the proxy method . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 381 ---------------------------------------------
Return the object representing the class name of the module class name . --> [[[FAILED]]]

[[[[Adv]]]]: public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 382 ---------------------------------------------
Returns true if the given class is in the current node . --> Bonham a single class --> Socre: 1.0

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[bonham]] ( String [[fated]] ) { return ( parent != null && parent . shouldBeSkipped ( [[fated]] ) ) || classNamesToSkip . contains ( [[fated]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 383 ---------------------------------------------
The main entry point . --> The nucleus method --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[module]] = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( [[module]] ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[nucleus]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[parcel]] = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( [[parcel]] ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 384 ---------------------------------------------
Push state . --> Emit a nucleus --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > [[key]] , Object [[source]] ) { doPushState ( [[key]] , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[aurelie]] ( com . google . inject . Key < ? > [[nucleus]] , Object [[ancestral]] ) { doPushState ( [[nucleus]] , [[ancestral]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 385 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 349 / 31 / 5 / 385:  38%|███▊      | 385/1000 [40:32<1:04:46,  6.32s/it][Succeeded / Failed / Skipped / Total] 349 / 31 / 5 / 385:  39%|███▊      | 386/1000 [40:38<1:04:38,  6.32s/it][Succeeded / Failed / Skipped / Total] 350 / 31 / 5 / 386:  39%|███▊      | 386/1000 [40:38<1:04:38,  6.32s/it][Succeeded / Failed / Skipped / Total] 350 / 31 / 5 / 386:  39%|███▊      | 387/1000 [40:41<1:04:27,  6.31s/it][Succeeded / Failed / Skipped / Total] 351 / 31 / 5 / 387:  39%|███▊      | 387/1000 [40:41<1:04:27,  6.31s/it][Succeeded / Failed / Skipped / Total] 351 / 31 / 5 / 387:  39%|███▉      | 388/1000 [40:44<1:04:16,  6.30s/it][Succeeded / Failed / Skipped / Total] 352 / 31 / 5 / 388:  39%|███▉      | 388/1000 [40:44<1:04:16,  6.30s/it][Succeeded / Failed / Skipped / Total] 352 / 31 / 5 / 388:  39%|███▉      | 389/1000 [40:47<1:04:04,  6.29s/it][Succeeded / Failed / Skipped / Total] 353 / 31 / 5 / 389:  39%|███▉      | 389/1000 [40:47<1:04:04,  6.29s/it][Succeeded / Failed / Skipped / Total] 353 / 31 / 5 / 389:  39%|███▉      | 390/1000 [40:57<1:04:04,  6.30s/it]Formats a messages for the given heading . --> Format a collection of shAMs --> Socre: 1.0

[[[[Adv]]]]: public static String formatMessages ( String [[heading]] , Collection < Message > [[errorMessages]] ) { Formatter fmt = new Formatter ( ) . format ( [[heading]] ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[errorMessages]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[errorMessages]] ) { int [[thisIdx]] = index ++ ; fmt . format ( "%s) %s%n" , [[thisIdx]] , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , [[thisIdx]] ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[errorMessages]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[errorMessages]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String [[legends]] , Collection < Message > [[shamrock]] ) { Formatter fmt = new Formatter ( ) . format ( [[legends]] ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[shamrock]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[shamrock]] ) { int [[jette]] = index ++ ; fmt . format ( "%s) %s%n" , [[jette]] , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , [[jette]] ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[shamrock]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[shamrock]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 386 ---------------------------------------------
Returns the provider for the given dependency . --> Render the provider --> Socre: 1.0

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > provider , Dependency < ? > [[dependency]] , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! [[dependency]] . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , [[dependency]] ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[render]] ( Provider < ? extends T > provider , Dependency < ? > [[consumerism]] , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! [[consumerism]] . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , [[consumerism]] ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 387 ---------------------------------------------
Convenience method for executing the processor . --> Exposed for test purposes --> Socre: 1.0

[[[[Adv]]]]: public void [[onEvent]] ( ConnectionEventType type , String [[remoteAddr]] , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor [[processor]] : processorList ) { [[processor]] . onEvent ( [[remoteAddr]] , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void [[cantor]] ( ConnectionEventType type , String [[hoang]] , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor [[specs]] : processorList ) { [[specs]] . onEvent ( [[hoang]] , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 388 ---------------------------------------------
Adds a connection event processor . --> Method to handle the given ConnectionEventProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType type , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > processorList = this . [[processors]] . get ( type ) ; if ( processorList == null ) { this . [[processors]] . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[processors]] . get ( type ) ; } processorList . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[salisbury]] ( ConnectionEventType type , ConnectionEventProcessor [[manufacturing]] ) { List < ConnectionEventProcessor > processorList = this . [[metalworkers]] . get ( type ) ; if ( processorList == null ) { this . [[metalworkers]] . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[metalworkers]] . get ( type ) ; } processorList . add ( [[manufacturing]] ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 389 ---------------------------------------------
Returns an instance . --> Create a projection with a value --> Socre: 1.0

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[la]] ( final T [[lawsuits]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[lawsuits]] ; } @ Override public String toString ( ) { return String . valueOf ( [[lawsuits]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 390 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 354 / 31 / 5 / 390:  39%|███▉      | 390/1000 [40:57<1:04:04,  6.30s/it][Succeeded / Failed / Skipped / Total] 354 / 31 / 5 / 390:  39%|███▉      | 391/1000 [41:05<1:04:00,  6.31s/it][Succeeded / Failed / Skipped / Total] 354 / 32 / 5 / 391:  39%|███▉      | 391/1000 [41:05<1:04:00,  6.31s/it][Succeeded / Failed / Skipped / Total] 354 / 32 / 5 / 391:  39%|███▉      | 392/1000 [41:08<1:03:48,  6.30s/it][Succeeded / Failed / Skipped / Total] 354 / 33 / 5 / 392:  39%|███▉      | 392/1000 [41:08<1:03:48,  6.30s/it][Succeeded / Failed / Skipped / Total] 354 / 33 / 5 / 392:  39%|███▉      | 393/1000 [41:09<1:03:34,  6.28s/it][Succeeded / Failed / Skipped / Total] 355 / 33 / 5 / 393:  39%|███▉      | 393/1000 [41:09<1:03:34,  6.28s/it][Succeeded / Failed / Skipped / Total] 355 / 33 / 5 / 393:  39%|███▉      | 394/1000 [41:10<1:03:19,  6.27s/it][Succeeded / Failed / Skipped / Total] 356 / 33 / 5 / 394:  39%|███▉      | 394/1000 [41:10<1:03:19,  6.27s/it][Succeeded / Failed / Skipped / Total] 356 / 33 / 5 / 394:  40%|███▉      | 395/1000 [41:20<1:03:18,  6.28s/it][Succeeded / Failed / Skipped / Total] 357 / 33 / 5 / 395:  40%|███▉      | 395/1000 [41:20<1:03:18,  6.28s/it][Succeeded / Failed / Skipped / Total] 357 / 33 / 5 / 395:  40%|███▉      | 396/1000 [41:21<1:03:05,  6.27s/it][Succeeded / Failed / Skipped / Total] 358 / 33 / 5 / 396:  40%|███▉      | 396/1000 [41:21<1:03:05,  6.27s/it][Succeeded / Failed / Skipped / Total] 358 / 33 / 5 / 396:  40%|███▉      | 397/1000 [41:25<1:02:55,  6.26s/it][Succeeded / Failed / Skipped / Total] 359 / 33 / 5 / 397:  40%|███▉      | 397/1000 [41:25<1:02:55,  6.26s/it][Succeeded / Failed / Skipped / Total] 359 / 33 / 5 / 397:  40%|███▉      | 398/1000 [41:30<1:02:47,  6.26s/it][Succeeded / Failed / Skipped / Total] 360 / 33 / 5 / 398:  40%|███▉      | 398/1000 [41:30<1:02:47,  6.26s/it][Succeeded / Failed / Skipped / Total] 360 / 33 / 5 / 398:  40%|███▉      | 399/1000 [41:35<1:02:39,  6.25s/it]Creates a message with the supplied arguments . --> built - in --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String [[messageFormat]] , Object ... arguments ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , [[messageFormat]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[built]] ( Throwable [[provoking]] , String [[chickened]] , Object ... arguments ) { return [[built]] ( [[provoking]] , ImmutableList . of ( ) , [[chickened]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 391 ---------------------------------------------
Gets the binding from a new injector . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 392 ---------------------------------------------
If the t is a RuntimeException then throw it . --> [[[FAILED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 393 ---------------------------------------------
Registers the default processor . --> F743 --> Socre: 1.0

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > [[processor]] ) { if ( this . [[defaultProcessor]] == null ) { this . [[defaultProcessor]] = [[processor]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[defaultProcessor]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[pitchin]] ( RemotingProcessor < ? > [[switcher]] ) { if ( this . [[golem]] == null ) { this . [[golem]] = [[switcher]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[golem]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 394 ---------------------------------------------
Tries to get the instance from the URL . --> Returns the quarrelling of the given url . --> Socre: 1.0

[[[[Adv]]]]: private Url [[tryGet]] ( String url ) { SoftReference < Url > [[softRef]] = Url . parsedUrls . get ( url ) ; return ( null == [[softRef]] ) ? null : [[softRef]] . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url [[quarrelling]] ( String url ) { SoftReference < Url > [[anaesthetic]] = Url . parsedUrls . get ( url ) ; return ( null == [[anaesthetic]] ) ? null : [[anaesthetic]] . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 395 ---------------------------------------------
Pushes the given dependency to the given source . --> Finds a dependence for a given background --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object [[source]] ) { Dependency < ? > previous = this . [[dependency]] ; this . [[dependency]] = [[dependency]] ; doPushState ( [[dependency]] , [[source]] ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[walia]] ( Dependency < ? > [[addictions]] , Object [[background]] ) { Dependency < ? > previous = this . [[dependence]] ; this . [[dependence]] = [[addictions]] ; doPushState ( [[addictions]] , [[background]] ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 396 ---------------------------------------------
Decodes the protocol code . --> Return a new ProtocolCode . --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[protocolCodeBytes]] = new byte [ protocolCodeLength ] ; in . readBytes ( [[protocolCodeBytes]] ) ; return ProtocolCode . fromBytes ( [[protocolCodeBytes]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[bromo]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[collared]] = new byte [ protocolCodeLength ] ; in . readBytes ( [[collared]] ) ; return ProtocolCode . fromBytes ( [[collared]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 397 ---------------------------------------------
Registers a processor . --> Endnsville --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode [[cmdCode]] , RemotingProcessor < ? > [[processor]] ) { if ( this . [[cmd2processors]] . containsKey ( [[cmdCode]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[cmdCode]] , cmd2processors . get ( [[cmdCode]] ) . getClass ( ) . getName ( ) , [[processor]] . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( [[cmdCode]] , [[processor]] ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[townsville]] ( CommandCode [[plaques]] , RemotingProcessor < ? > [[motherboard]] ) { if ( this . [[severe]] . containsKey ( [[plaques]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[plaques]] , cmd2processors . get ( [[plaques]] ) . getClass ( ) . getName ( ) , [[motherboard]] . getClass ( ) . getName ( ) ) ; } this . [[severe]] . put ( [[plaques]] , [[motherboard]] ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 398 ---------------------------------------------
Returns the connection to the given URL . --> region Connection getAnd Implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection getAndCreateIfAbsent ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection getAndCreateIfAbsent ( Url [[passwords]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 399 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 361 / 33 / 5 / 399:  40%|███▉      | 399/1000 [41:35<1:02:39,  6.25s/it][Succeeded / Failed / Skipped / Total] 361 / 33 / 5 / 399:  40%|████      | 400/1000 [41:40<1:02:30,  6.25s/it][Succeeded / Failed / Skipped / Total] 362 / 33 / 5 / 400:  40%|████      | 400/1000 [41:40<1:02:30,  6.25s/it][Succeeded / Failed / Skipped / Total] 362 / 33 / 5 / 400:  40%|████      | 401/1000 [41:41<1:02:17,  6.24s/it][Succeeded / Failed / Skipped / Total] 363 / 33 / 5 / 401:  40%|████      | 401/1000 [41:41<1:02:17,  6.24s/it][Succeeded / Failed / Skipped / Total] 363 / 34 / 5 / 402:  40%|████      | 402/1000 [41:42<1:02:01,  6.22s/it][Succeeded / Failed / Skipped / Total] 363 / 34 / 5 / 402:  40%|████      | 403/1000 [41:42<1:01:46,  6.21s/it][Succeeded / Failed / Skipped / Total] 363 / 34 / 6 / 403:  40%|████      | 403/1000 [41:42<1:01:46,  6.21s/it][Succeeded / Failed / Skipped / Total] 364 / 34 / 6 / 404:  40%|████      | 404/1000 [41:42<1:01:32,  6.20s/it][Succeeded / Failed / Skipped / Total] 364 / 34 / 6 / 404:  40%|████      | 405/1000 [41:45<1:01:20,  6.19s/it][Succeeded / Failed / Skipped / Total] 364 / 35 / 6 / 405:  40%|████      | 405/1000 [41:45<1:01:20,  6.19s/it][Succeeded / Failed / Skipped / Total] 365 / 35 / 6 / 406:  41%|████      | 406/1000 [41:48<1:01:09,  6.18s/it][Succeeded / Failed / Skipped / Total] 365 / 35 / 6 / 406:  41%|████      | 407/1000 [41:51<1:00:58,  6.17s/it]Create connection andHeal if necessary . --> region Kukul --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[gurukul]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 400 ---------------------------------------------
Remove a named pool . --> Responds to the specified pool . --> Socre: 1.0

[[[[Adv]]]]: private void [[removeTask]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > [[task]] = this . connTasks . remove ( poolKey ) ; if ( null != [[task]] ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[task]] , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void [[brawling]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > [[tedious]] = this . connTasks . remove ( poolKey ) ; if ( null != [[tedious]] ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[tedious]] , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 401 ---------------------------------------------
Returns a map of all connections in the snapshot . --> Creates a Gabriele --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[getAll]] ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { [[allConnections]] . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[prew]] ( ) { Map < String , List < Connection > > [[gabriele]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { [[gabriele]] . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return [[gabriele]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 402 ---------------------------------------------
Scans the connection pool . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 403 ---------------------------------------------
Creates a new connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 404 ---------------------------------------------
heal ifNeed --> khalid a Url --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[khalid]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 405 ---------------------------------------------
Create a Key with the specified annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 406 ---------------------------------------------
Set an attribute value . --> Update the invaluable in the predicate --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String [[key]] , Object [[value]] ) { return attributes . putIfAbsent ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[avoidance]] ( String [[predicate]] , Object [[invaluable]] ) { return attributes . putIfAbsent ( [[predicate]] , [[invaluable]] ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 407 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 366 / 35 / 6 / 407:  41%|████      | 407/1000 [41:51<1:00:58,  6.17s/it][Succeeded / Failed / Skipped / Total] 367 / 35 / 6 / 408:  41%|████      | 408/1000 [41:51<1:00:44,  6.16s/it][Succeeded / Failed / Skipped / Total] 367 / 35 / 6 / 408:  41%|████      | 409/1000 [41:53<1:00:32,  6.15s/it][Succeeded / Failed / Skipped / Total] 368 / 35 / 6 / 409:  41%|████      | 409/1000 [41:53<1:00:32,  6.15s/it][Succeeded / Failed / Skipped / Total] 369 / 35 / 6 / 410:  41%|████      | 410/1000 [41:55<1:00:20,  6.14s/it][Succeeded / Failed / Skipped / Total] 369 / 35 / 6 / 410:  41%|████      | 411/1000 [41:58<1:00:08,  6.13s/it][Succeeded / Failed / Skipped / Total] 370 / 35 / 6 / 411:  41%|████      | 411/1000 [41:58<1:00:08,  6.13s/it][Succeeded / Failed / Skipped / Total] 370 / 36 / 6 / 412:  41%|████      | 412/1000 [41:59<59:56,  6.12s/it]  [Succeeded / Failed / Skipped / Total] 370 / 36 / 6 / 412:  41%|████▏     | 413/1000 [42:02<59:44,  6.11s/it]Returns the processor for the command . --> Returns a remorseful --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode [[cmdCode]] ) { RemotingProcessor < ? > processor = this . [[cmd2processors]] . get ( [[cmdCode]] ) ; if ( processor != null ) { return processor ; } return this . [[defaultProcessor]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[remorseful]] ( CommandCode [[grose]] ) { RemotingProcessor < ? > processor = this . [[dinsdale]] . get ( [[grose]] ) ; if ( processor != null ) { return processor ; } return this . [[trier]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 408 ---------------------------------------------
Executes a RunStateRecordedFutureTask . --> RunStateRecordedFutureTask . --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[te]] > [[te]] getFutureTaskResult ( RunStateRecordedFutureTask < [[te]] > task , Logger logger ) { [[te]] [[quantity]] = null ; if ( null != task ) { try { [[quantity]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[quantity]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 409 ---------------------------------------------
dispatch to user processor --> Recreates the kth . --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext ctx , RpcRequestCommand [[cmd]] ) { final int id = [[cmd]] . getId ( ) ; final byte type = [[cmd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[fifth]] ( RemotingContext ctx , RpcRequestCommand [[kdk]] ) { final int id = [[kdk]] . getId ( ) ; final byte type = [[kdk]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 410 ---------------------------------------------
Register a user processor . --> If the powering has been registered to the rpc server --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[processor]] . multiInterest ( ) || [[processor]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[processor]] . multiInterest ( ) ) { UserProcessor < ? > [[preProcessor]] = userProcessors . putIfAbsent ( interest , [[processor]] ) ; if ( [[preProcessor]] != null ) { String [[errMsg]] = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[errMsg]] ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[dispensing]] ( MultiInterestUserProcessor < ? > [[powering]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[powering]] . multiInterest ( ) || [[powering]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[powering]] . multiInterest ( ) ) { UserProcessor < ? > [[pressured]] = userProcessors . putIfAbsent ( interest , [[powering]] ) ; if ( [[pressured]] != null ) { String [[slayers]] = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[slayers]] ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 411 ---------------------------------------------
Deletes the connection . --> remove all the active servers --> Socre: 1.0

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > [[iter]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > [[entry]] = [[iter]] . next ( ) ; [[iter]] . remove ( ) ; InvokeFuture [[future]] = [[entry]] . getValue ( ) ; if ( [[future]] != null ) { [[future]] . putResponse ( [[future]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[future]] . cancelTimeout ( ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[symbol]] ( ) { Iterator < Entry < Integer , InvokeFuture > > [[typography]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[typography]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > [[penetrate]] = [[typography]] . next ( ) ; [[typography]] . remove ( ) ; InvokeFuture [[anxiously]] = [[penetrate]] . getValue ( ) ; if ( [[anxiously]] != null ) { [[anxiously]] . putResponse ( [[anxiously]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[anxiously]] . cancelTimeout ( ) ; [[anxiously]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 412 ---------------------------------------------
Close connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 413 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 371 / 36 / 6 / 413:  41%|████▏     | 413/1000 [42:02<59:44,  6.11s/it][Succeeded / Failed / Skipped / Total] 372 / 36 / 6 / 414:  41%|████▏     | 414/1000 [42:04<59:33,  6.10s/it][Succeeded / Failed / Skipped / Total] 372 / 36 / 6 / 414:  42%|████▏     | 415/1000 [42:15<59:34,  6.11s/it][Succeeded / Failed / Skipped / Total] 372 / 37 / 6 / 415:  42%|████▏     | 415/1000 [42:15<59:34,  6.11s/it][Succeeded / Failed / Skipped / Total] 372 / 37 / 6 / 415:  42%|████▏     | 416/1000 [42:16<59:20,  6.10s/it][Succeeded / Failed / Skipped / Total] 372 / 38 / 6 / 416:  42%|████▏     | 416/1000 [42:16<59:20,  6.10s/it][Succeeded / Failed / Skipped / Total] 372 / 38 / 6 / 416:  42%|████▏     | 417/1000 [42:17<59:07,  6.08s/it][Succeeded / Failed / Skipped / Total] 373 / 38 / 6 / 417:  42%|████▏     | 417/1000 [42:17<59:07,  6.08s/it][Succeeded / Failed / Skipped / Total] 373 / 38 / 6 / 417:  42%|████▏     | 418/1000 [42:18<58:54,  6.07s/it]Log a log message . --> Method to convertible to received document --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext [[ctx]] , RpcRequestCommand [[cmd]] , long [[currentTimestamp]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , [[cmd]] . getId ( ) , RemotingUtil . parseRemoteAddress ( [[ctx]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , [[cmd]] . getId ( ) , [[currentTimestamp]] , [[cmd]] . getArriveTime ( ) , ( [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[convertible]] ( RemotingContext [[eval]] , RpcRequestCommand [[sgc]] , long [[earning]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , [[sgc]] . getId ( ) , RemotingUtil . parseRemoteAddress ( [[eval]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , [[sgc]] . getId ( ) , [[earning]] , [[sgc]] . getArriveTime ( ) , ( [[earning]] - [[sgc]] . getArriveTime ( ) ) , [[sgc]] . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 414 ---------------------------------------------
Process the process . --> Adds a monotony message --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[process]] ( RemotingContext [[ctx]] , T [[msg]] , ExecutorService [[defaultExecutor]] ) throws Exception { ProcessTask [[task]] = new ProcessTask ( [[ctx]] , [[msg]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[task]] ) ; } else { [[defaultExecutor]] . execute ( [[task]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void [[treatment]] ( RemotingContext [[var]] , T [[message]] , ExecutorService [[amazingly]] ) throws Exception { ProcessTask [[monotony]] = new ProcessTask ( [[var]] , [[message]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[monotony]] ) ; } else { [[amazingly]] . execute ( [[monotony]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 415 ---------------------------------------------
Pre - processes a JNDI context . --> [[[FAILED]]]

[[[[Adv]]]]: private void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 416 ---------------------------------------------
Deserialize the RpcRequestCommand . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 417 ---------------------------------------------
Convert a BitSet to a byte . --> Returns the lacking given the BitSet --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[lackeys]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 418 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 373 / 39 / 6 / 418:  42%|████▏     | 418/1000 [42:18<58:54,  6.07s/it][Succeeded / Failed / Skipped / Total] 373 / 39 / 6 / 418:  42%|████▏     | 419/1000 [42:19<58:41,  6.06s/it][Succeeded / Failed / Skipped / Total] 373 / 40 / 6 / 419:  42%|████▏     | 419/1000 [42:19<58:41,  6.06s/it][Succeeded / Failed / Skipped / Total] 374 / 40 / 6 / 420:  42%|████▏     | 420/1000 [42:19<58:27,  6.05s/it][Succeeded / Failed / Skipped / Total] 374 / 40 / 6 / 420:  42%|████▏     | 421/1000 [42:20<58:13,  6.03s/it][Succeeded / Failed / Skipped / Total] 374 / 40 / 7 / 421:  42%|████▏     | 421/1000 [42:20<58:13,  6.03s/it][Succeeded / Failed / Skipped / Total] 375 / 40 / 7 / 422:  42%|████▏     | 422/1000 [42:24<58:04,  6.03s/it][Succeeded / Failed / Skipped / Total] 375 / 40 / 7 / 422:  42%|████▏     | 423/1000 [42:26<57:53,  6.02s/it]Convert an int value to a BitSet . --> [[[FAILED]]]

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 419 ---------------------------------------------
Register user processor . --> [[[FAILED]]]

[[[[Adv]]]]: public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 420 ---------------------------------------------
Adds a task to the pool . --> Create a dispersal URL --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[dispersal]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 421 ---------------------------------------------
Stops the connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
Filter connection details --> Completes the connection list . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[filter]] ( List < Connection > [[connections]] ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[connections]] ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[screen]] ( List < Connection > [[plug]] ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[plug]] ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 423 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 376 / 40 / 7 / 423:  42%|████▏     | 423/1000 [42:26<57:53,  6.02s/it][Succeeded / Failed / Skipped / Total] 377 / 40 / 7 / 424:  42%|████▏     | 424/1000 [42:27<57:40,  6.01s/it][Succeeded / Failed / Skipped / Total] 377 / 40 / 7 / 424:  42%|████▎     | 425/1000 [42:39<57:42,  6.02s/it][Succeeded / Failed / Skipped / Total] 378 / 40 / 7 / 425:  42%|████▎     | 425/1000 [42:39<57:42,  6.02s/it][Succeeded / Failed / Skipped / Total] 378 / 40 / 7 / 425:  43%|████▎     | 426/1000 [42:39<57:28,  6.01s/it]This method is used to monitor the connection pool . --> Monitors state records . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > [[filteredConnectons]] = this . filter ( connections ) ; List < Connection > serviceOnConnections = [[filteredConnectons]] . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = [[filteredConnectons]] . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > [[bootie]] = this . filter ( connections ) ; List < Connection > serviceOnConnections = [[bootie]] . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = [[bootie]] . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 424 ---------------------------------------------
Closes the connection to the server . --> madone Method . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[madone]] ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 425 ---------------------------------------------
Send a log entry . --> furry a remote address --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand cmd , long [[currentTimestamp]] , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , [[currentTimestamp]] , cmd . getArriveTime ( ) , ( [[currentTimestamp]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel [[channel]] = channelCtx . channel ( ) ; if ( null != [[channel]] ) { remoteAddr = RemotingUtil . parseRemoteAddress ( [[channel]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( [[currentTimestamp]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[furry]] ( final RpcRequestCommand cmd , long [[maneuvers]] , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , [[maneuvers]] , cmd . getArriveTime ( ) , ( [[maneuvers]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel [[pipeline]] = channelCtx . channel ( ) ; if ( null != [[pipeline]] ) { remoteAddr = RemotingUtil . parseRemoteAddress ( [[pipeline]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( [[maneuvers]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
[Succeeded / Failed / Skipped / Total] 378 / 41 / 7 / 426:  43%|████▎     | 426/1000 [42:39<57:28,  6.01s/it][Succeeded / Failed / Skipped / Total] 378 / 41 / 7 / 426:  43%|████▎     | 427/1000 [42:40<57:15,  6.00s/it][Succeeded / Failed / Skipped / Total] 379 / 41 / 7 / 427:  43%|████▎     | 427/1000 [42:40<57:15,  6.00s/it][Succeeded / Failed / Skipped / Total] 379 / 41 / 7 / 427:  43%|████▎     | 428/1000 [42:40<57:02,  5.98s/it][Succeeded / Failed / Skipped / Total] 380 / 41 / 7 / 428:  43%|████▎     | 428/1000 [42:40<57:02,  5.98s/it][Succeeded / Failed / Skipped / Total] 380 / 41 / 7 / 428:  43%|████▎     | 429/1000 [42:42<56:50,  5.97s/it][Succeeded / Failed / Skipped / Total] 381 / 41 / 7 / 429:  43%|████▎     | 429/1000 [42:42<56:50,  5.97s/it][Succeeded / Failed / Skipped / Total] 381 / 41 / 7 / 429:  43%|████▎     | 430/1000 [42:42<56:37,  5.96s/it][Succeeded / Failed / Skipped / Total] 382 / 41 / 7 / 430:  43%|████▎     | 430/1000 [42:42<56:37,  5.96s/it][Succeeded / Failed / Skipped / Total] 382 / 41 / 7 / 430:  43%|████▎     | 431/1000 [42:44<56:25,  5.95s/it][Succeeded / Failed / Skipped / Total] 383 / 41 / 7 / 431:  43%|████▎     | 431/1000 [42:44<56:25,  5.95s/it]--------------------------------------------- Result 426 ---------------------------------------------
Called when the remote address is received . --> [[[FAILED]]]

[[[[Adv]]]]: protected void oneway ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void oneway ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 427 ---------------------------------------------
Create the corresponding listeners for the given type . --> touristy of the given type literal --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > [[type]] , Errors [[errors]] ) throws ErrorsException { int numErrorsBefore = [[errors]] . size ( ) ; Set < InjectionPoint > [[injectionPoints]] ; try { [[injectionPoints]] = InjectionPoint . forInstanceMethodsAndFields ( [[type]] ) ; } catch ( ConfigurationException e ) { [[errors]] . merge ( e . getErrorMessages ( ) ) ; [[injectionPoints]] = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( [[injectionPoints]] , [[errors]] ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > [[encounter]] = new EncounterImpl <> ( [[errors]] , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( [[type]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[type]] , [[encounter]] ) ; } catch ( RuntimeException e ) { [[errors]] . errorNotifyingTypeListener ( binding , [[type]] , e ) ; } } } [[encounter]] . invalidate ( ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[type]] , [[encounter]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[touristy]] ( TypeLiteral < T > [[kind]] , Errors [[failures]] ) throws ErrorsException { int numErrorsBefore = [[failures]] . size ( ) ; Set < InjectionPoint > [[fleischer]] ; try { [[fleischer]] = InjectionPoint . forInstanceMethodsAndFields ( [[kind]] ) ; } catch ( ConfigurationException e ) { [[failures]] . merge ( e . getErrorMessages ( ) ) ; [[fleischer]] = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( [[fleischer]] , [[failures]] ) ; [[failures]] . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > [[combat]] = new EncounterImpl <> ( [[failures]] , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( [[kind]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[kind]] , [[combat]] ) ; } catch ( RuntimeException e ) { [[failures]] . errorNotifyingTypeListener ( binding , [[kind]] , e ) ; } } } [[combat]] . invalidate ( ) ; [[failures]] . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[kind]] , [[combat]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 428 ---------------------------------------------
Log the info log --> mariette adds a string to the logger --> Socre: 1.0

[[[[Adv]]]]: private void [[infoLog]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void [[mariette]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 429 ---------------------------------------------
Creates a new leader command . --> Create a RpcRequestCommand --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object [[request]] , Connection [[conn]] , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[request]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object [[sought]] , Connection [[bulldogs]] , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[sought]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 430 ---------------------------------------------
Returns true if the request is timeout . --> Gets the timestamp . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . timeout > 0 && ( this . [[rpcCommandType]] != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[headband]] ( ) { if ( this . timeout > 0 && ( this . [[faking]] != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[Reality]]" == "[[Reality]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 431 ---------------------------------------------
Get user processor . --> Returns a UserProcessor --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . [[userProcessors]] . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[cords]] ( String [[policía]] ) { return StringUtils . isBlank ( [[policía]] ) ? null : this . [[inclination]] . get ( [[policía]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 432 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 384 / 41 / 7 / 432:  43%|████▎     | 432/1000 [42:44<56:11,  5.94s/it][Succeeded / Failed / Skipped / Total] 384 / 42 / 7 / 433:  43%|████▎     | 433/1000 [42:44<55:57,  5.92s/it][Succeeded / Failed / Skipped / Total] 384 / 42 / 7 / 433:  43%|████▎     | 434/1000 [42:45<55:45,  5.91s/it][Succeeded / Failed / Skipped / Total] 384 / 43 / 7 / 434:  43%|████▎     | 434/1000 [42:45<55:45,  5.91s/it][Succeeded / Failed / Skipped / Total] 385 / 43 / 7 / 435:  44%|████▎     | 435/1000 [42:46<55:33,  5.90s/it][Succeeded / Failed / Skipped / Total] 386 / 43 / 7 / 436:  44%|████▎     | 436/1000 [42:47<55:21,  5.89s/it][Succeeded / Failed / Skipped / Total] 386 / 43 / 7 / 436:  44%|████▎     | 437/1000 [42:48<55:09,  5.88s/it][Succeeded / Failed / Skipped / Total] 387 / 43 / 7 / 437:  44%|████▎     | 437/1000 [42:48<55:09,  5.88s/it][Succeeded / Failed / Skipped / Total] 388 / 43 / 7 / 438:  44%|████▍     | 438/1000 [42:49<54:56,  5.87s/it]Returns the property value for the key . --> Returns the metadata for the given cardinal . --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[preity]] ( String [[cardinal]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[cardinal]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 433 ---------------------------------------------
Get the value from the context . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 434 ---------------------------------------------
Returns the value of the System property . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 435 ---------------------------------------------
Gets the detail error message . --> Method detailErrMsg . --> Socre: 1.0

[[[[Adv]]]]: private static String detailErrMsg ( String [[clientErrMsg]] , ResponseCommand [[responseCommand]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[clientErrMsg]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[clientErrMsg]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String detailErrMsg ( String [[landfall]] , ResponseCommand [[hopkins]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[hopkins]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[landfall]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[landfall]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 436 ---------------------------------------------
Gets the response object . --> Opens the Rpc responseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand [[response]] = ( RpcResponseCommand ) [[responseCommand]] ; [[response]] . deserialize ( ) ; return [[response]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[rjr]] ( ResponseCommand [[tahitian]] ) throws CodecException { RpcResponseCommand [[reacts]] = ( RpcResponseCommand ) [[tahitian]] ; [[reacts]] . deserialize ( ) ; return [[reacts]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 437 ---------------------------------------------
Creates a RpcServerException object . --> Generates a RpcServerException --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException [[createServerException]] ( Throwable t , String [[errMsg]] ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , [[errMsg]] ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException [[grieving]] ( Throwable t , String [[pygmalion]] ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , [[pygmalion]] ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 438 ---------------------------------------------
Print log messages for a trace . --> shim error messages --> Socre: 1.0

[[[[Adv]]]]: public static void [[printConnectionTraceLog]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void [[shimla]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 439 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 389 / 43 / 7 / 439:  44%|████▍     | 439/1000 [42:49<54:43,  5.85s/it][Succeeded / Failed / Skipped / Total] 389 / 43 / 7 / 439:  44%|████▍     | 440/1000 [43:04<54:49,  5.87s/it][Succeeded / Failed / Skipped / Total] 389 / 44 / 7 / 440:  44%|████▍     | 440/1000 [43:04<54:49,  5.87s/it][Succeeded / Failed / Skipped / Total] 389 / 44 / 7 / 440:  44%|████▍     | 441/1000 [43:12<54:46,  5.88s/it][Succeeded / Failed / Skipped / Total] 390 / 44 / 7 / 441:  44%|████▍     | 441/1000 [43:12<54:46,  5.88s/it][Succeeded / Failed / Skipped / Total] 390 / 44 / 7 / 441:  44%|████▍     | 442/1000 [43:23<54:46,  5.89s/it][Succeeded / Failed / Skipped / Total] 391 / 44 / 7 / 442:  44%|████▍     | 442/1000 [43:23<54:46,  5.89s/it][Succeeded / Failed / Skipped / Total] 391 / 44 / 7 / 442:  44%|████▍     | 443/1000 [43:27<54:38,  5.89s/it]Resolves a response object . --> Log a server --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand [[responseCommand]] , String addr ) throws RemotingException { preProcess ( [[responseCommand]] , addr ) ; if ( [[responseCommand]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[responseCommand]] ) ; } else { String [[msg]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[responseCommand]] . getResponseStatus ( ) , addr , [[responseCommand]] . getId ( ) ) ; logger . warn ( [[msg]] ) ; if ( [[responseCommand]] . getCause ( ) != null ) { throw new InvokeException ( [[msg]] , [[responseCommand]] . getCause ( ) ) ; } else { throw new InvokeException ( [[msg]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[caff]] ( ResponseCommand [[hustlers]] , String addr ) throws RemotingException { preProcess ( [[hustlers]] , addr ) ; if ( [[hustlers]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[hustlers]] ) ; } else { String [[phonebook]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[hustlers]] . getResponseStatus ( ) , addr , [[hustlers]] . getId ( ) ) ; logger . warn ( [[phonebook]] ) ; if ( [[hustlers]] . getCause ( ) != null ) { throw new InvokeException ( [[phonebook]] , [[hustlers]] . getCause ( ) ) ; } else { throw new InvokeException ( [[phonebook]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 440 ---------------------------------------------
Returns the given list of Connection . --> [[[FAILED]]]

[[[[Adv]]]]: private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 441 ---------------------------------------------
parse the ResponseCommand to a Throwable --> Computes the final object from the ResponseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; resp . deserialize ( ) ; Object [[ex]] = resp . getResponseObject ( ) ; if ( [[ex]] != null && [[ex]] instanceof Throwable ) { return ( Throwable ) [[ex]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[recounts]] ( ResponseCommand [[wheezes]] ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) [[wheezes]] ; resp . deserialize ( ) ; Object [[preceding]] = resp . getResponseObject ( ) ; if ( [[preceding]] != null && [[preceding]] instanceof Throwable ) { return ( Throwable ) [[preceding]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 442 ---------------------------------------------
Parse the local address of the channel . --> Get a blow number string --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress [[local]] = [[channel]] . localAddress ( ) ; return doParse ( [[local]] != null ? [[local]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[squints]] ( final Channel [[blowjob]] ) { if ( null == [[blowjob]] ) { return StringUtils . EMPTY ; } final SocketAddress [[facilities]] = [[blowjob]] . localAddress ( ) ; return doParse ( [[facilities]] != null ? [[facilities]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 443 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 391 / 45 / 7 / 443:  44%|████▍     | 443/1000 [43:27<54:38,  5.89s/it][Succeeded / Failed / Skipped / Total] 391 / 45 / 7 / 443:  44%|████▍     | 444/1000 [43:33<54:32,  5.89s/it][Succeeded / Failed / Skipped / Total] 392 / 45 / 7 / 444:  44%|████▍     | 444/1000 [43:33<54:32,  5.89s/it][Succeeded / Failed / Skipped / Total] 392 / 45 / 7 / 444:  44%|████▍     | 445/1000 [43:33<54:19,  5.87s/it][Succeeded / Failed / Skipped / Total] 393 / 45 / 7 / 445:  44%|████▍     | 445/1000 [43:33<54:19,  5.87s/it][Succeeded / Failed / Skipped / Total] 393 / 45 / 7 / 445:  45%|████▍     | 446/1000 [43:41<54:16,  5.88s/it][Succeeded / Failed / Skipped / Total] 394 / 45 / 7 / 446:  45%|████▍     | 446/1000 [43:41<54:16,  5.88s/it][Succeeded / Failed / Skipped / Total] 394 / 45 / 7 / 446:  45%|████▍     | 447/1000 [43:43<54:05,  5.87s/it][Succeeded / Failed / Skipped / Total] 395 / 45 / 7 / 447:  45%|████▍     | 447/1000 [43:43<54:05,  5.87s/it][Succeeded / Failed / Skipped / Total] 395 / 45 / 7 / 447:  45%|████▍     | 448/1000 [43:43<53:52,  5.86s/it]Executes the given request with the given callback . --> [[[FAILED]]]

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 444 ---------------------------------------------
Parse remote port . --> Return - 1 if not found --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[rea]] ( final Channel [[tube]] ) { if ( null == [[tube]] ) { return - 1 ; } final InetSocketAddress [[distances]] = ( InetSocketAddress ) [[tube]] . remoteAddress ( ) ; if ( [[distances]] != null ) { return [[distances]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 445 ---------------------------------------------
Parses remote address . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[beater]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress [[clicker]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[clicker]] != null ) { return [[clicker]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 446 ---------------------------------------------
Parse the remote host . --> Returns an lzo string --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[lzo]] ( final Channel [[pipe]] ) { if ( null == [[pipe]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[transmitter]] = ( InetSocketAddress ) [[pipe]] . remoteAddress ( ) ; if ( [[transmitter]] != null ) { return [[transmitter]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
Parse the local IP address . --> Returns null if plumbing is enabled --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[despised]] ( final Channel [[plumbing]] ) { if ( null == [[plumbing]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[plumbing]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 396 / 45 / 7 / 448:  45%|████▍     | 448/1000 [43:43<53:52,  5.86s/it][Succeeded / Failed / Skipped / Total] 396 / 45 / 7 / 448:  45%|████▍     | 449/1000 [43:44<53:41,  5.85s/it][Succeeded / Failed / Skipped / Total] 397 / 45 / 7 / 449:  45%|████▍     | 449/1000 [43:44<53:41,  5.85s/it][Succeeded / Failed / Skipped / Total] 397 / 45 / 7 / 449:  45%|████▌     | 450/1000 [43:46<53:30,  5.84s/it][Succeeded / Failed / Skipped / Total] 398 / 45 / 7 / 450:  45%|████▌     | 450/1000 [43:46<53:30,  5.84s/it][Succeeded / Failed / Skipped / Total] 398 / 45 / 7 / 450:  45%|████▌     | 451/1000 [43:47<53:18,  5.83s/it][Succeeded / Failed / Skipped / Total] 399 / 45 / 7 / 451:  45%|████▌     | 451/1000 [43:47<53:18,  5.83s/it][Succeeded / Failed / Skipped / Total] 399 / 45 / 7 / 451:  45%|████▌     | 452/1000 [43:48<53:07,  5.82s/it][Succeeded / Failed / Skipped / Total] 400 / 45 / 7 / 452:  45%|████▌     | 452/1000 [43:48<53:07,  5.82s/it][Succeeded / Failed / Skipped / Total] 400 / 45 / 7 / 452:  45%|████▌     | 453/1000 [43:52<52:59,  5.81s/it][Succeeded / Failed / Skipped / Total] 401 / 45 / 7 / 453:  45%|████▌     | 453/1000 [43:52<52:59,  5.81s/it][Succeeded / Failed / Skipped / Total] 401 / 45 / 7 / 453:  45%|████▌     | 454/1000 [43:53<52:47,  5.80s/it][Succeeded / Failed / Skipped / Total] 401 / 46 / 7 / 454:  45%|████▌     | 454/1000 [43:53<52:47,  5.80s/it][Succeeded / Failed / Skipped / Total] 401 / 46 / 7 / 454:  46%|████▌     | 455/1000 [43:55<52:36,  5.79s/it][Succeeded / Failed / Skipped / Total] 402 / 46 / 7 / 455:  46%|████▌     | 455/1000 [43:55<52:36,  5.79s/it][Succeeded / Failed / Skipped / Total] 402 / 46 / 7 / 455:  46%|████▌     | 456/1000 [43:55<52:24,  5.78s/it][Succeeded / Failed / Skipped / Total] 403 / 46 / 7 / 456:  46%|████▌     | 456/1000 [43:55<52:24,  5.78s/it][Succeeded / Failed / Skipped / Total] 403 / 46 / 7 / 456:  46%|████▌     | 457/1000 [43:57<52:13,  5.77s/it]Adds a connection . --> Sets the complement . --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . [[conns]] . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[complement]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . [[jannet]] . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 449 ---------------------------------------------
Parse the given socket address to host addresses . --> Get audiohead --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress [[addr]] = [[addrs]] . getAddress ( ) ; if ( null != [[addr]] ) { return [[addr]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[bubblehead]] ( SocketAddress [[inhabits]] ) { final InetSocketAddress [[magistrate]] = ( InetSocketAddress ) [[inhabits]] ; if ( [[magistrate]] != null ) { InetAddress [[wouldnít]] = [[magistrate]] . getAddress ( ) ; if ( null != [[wouldnít]] ) { return [[wouldnít]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 450 ---------------------------------------------
Parse the remote address . --> delirious a pipeline --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[channel]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[delirious]] ( final Channel [[pipeline]] ) { if ( null == [[pipeline]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[pipeline]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 451 ---------------------------------------------
Removes and closes the connection . --> Closes the k -ull . --> Socre: 1.0

[[[[Adv]]]]: public void [[removeAndTryClose]] ( Connection connection ) { if ( null == connection ) { return ; } boolean [[res]] = this . conns . remove ( connection ) ; if ( [[res]] ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void [[kull]] ( Connection connection ) { if ( null == connection ) { return ; } boolean [[truthful]] = this . conns . remove ( connection ) ; if ( [[truthful]] ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 452 ---------------------------------------------
Returns the connection . --> Returns the connected snapshot . --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . [[conns]] ) { List < Connection > snapshot = new ArrayList < Connection > ( this . [[conns]] ) ; if ( snapshot . size ( ) > 0 ) { return this . [[strategy]] . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[attained]] ( ) { markAccess ( ) ; if ( null != this . [[ouija]] ) { List < Connection > snapshot = new ArrayList < Connection > ( this . [[ouija]] ) ; if ( snapshot . size ( ) > 0 ) { return this . [[economically]] . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 453 ---------------------------------------------
Registers a custom serializer --> sw - 1 --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String className , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = classCustomSerializer . putIfAbsent ( className , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[sweatshirts]] ( String className , CustomSerializer [[debo]] ) { CustomSerializer [[checkout]] = classCustomSerializer . putIfAbsent ( className , [[debo]] ) ; if ( [[checkout]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + [[checkout]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 454 ---------------------------------------------
Start the monitor . --> [[[FAILED]]]

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 455 ---------------------------------------------
Sets the remote address . --> Sets the reboot . --> Socre: 1.0

[[[[Adv]]]]: public boolean isConnected ( String [[remoteAddr]] ) { Url [[url]] = this . [[rpcRemoting]] . addressParser . parse ( [[remoteAddr]] ) ; return this . isConnected ( [[url]] ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean isConnected ( String [[reboot]] ) { Url [[clicked]] = this . [[shout]] . addressParser . parse ( [[reboot]] ) ; return this . isConnected ( [[clicked]] ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 456 ---------------------------------------------
Returns the custom serializer for the given command code . --> Returns null if decode is empty --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( CommandCode [[decode]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[decode]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 457 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 404 / 46 / 7 / 457:  46%|████▌     | 457/1000 [43:57<52:13,  5.77s/it][Succeeded / Failed / Skipped / Total] 404 / 46 / 7 / 457:  46%|████▌     | 458/1000 [43:58<52:02,  5.76s/it][Succeeded / Failed / Skipped / Total] 405 / 46 / 7 / 458:  46%|████▌     | 458/1000 [43:58<52:02,  5.76s/it][Succeeded / Failed / Skipped / Total] 405 / 46 / 7 / 458:  46%|████▌     | 459/1000 [43:59<51:50,  5.75s/it][Succeeded / Failed / Skipped / Total] 406 / 46 / 7 / 459:  46%|████▌     | 459/1000 [43:59<51:50,  5.75s/it][Succeeded / Failed / Skipped / Total] 406 / 46 / 7 / 459:  46%|████▌     | 460/1000 [43:59<51:38,  5.74s/it][Succeeded / Failed / Skipped / Total] 406 / 46 / 8 / 460:  46%|████▌     | 460/1000 [43:59<51:38,  5.74s/it][Succeeded / Failed / Skipped / Total] 406 / 46 / 8 / 460:  46%|████▌     | 461/1000 [44:00<51:26,  5.73s/it][Succeeded / Failed / Skipped / Total] 407 / 46 / 8 / 461:  46%|████▌     | 461/1000 [44:00<51:26,  5.73s/it][Succeeded / Failed / Skipped / Total] 407 / 46 / 8 / 461:  46%|████▌     | 462/1000 [44:00<51:14,  5.71s/it][Succeeded / Failed / Skipped / Total] 408 / 46 / 8 / 462:  46%|████▌     | 462/1000 [44:00<51:14,  5.71s/it][Succeeded / Failed / Skipped / Total] 408 / 46 / 8 / 462:  46%|████▋     | 463/1000 [44:01<51:03,  5.70s/it][Succeeded / Failed / Skipped / Total] 409 / 46 / 8 / 463:  46%|████▋     | 463/1000 [44:01<51:03,  5.70s/it][Succeeded / Failed / Skipped / Total] 409 / 46 / 8 / 463:  46%|████▋     | 464/1000 [44:01<50:51,  5.69s/it][Succeeded / Failed / Skipped / Total] 410 / 46 / 8 / 464:  46%|████▋     | 464/1000 [44:01<50:51,  5.69s/it][Succeeded / Failed / Skipped / Total] 410 / 46 / 8 / 464:  46%|████▋     | 465/1000 [44:02<50:40,  5.68s/it]Register custom serializer . --> Renames the given CustomSerializer --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode [[code]] , CustomSerializer [[serializer]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[code]] , [[serializer]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[code]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[veter]] ( CommandCode [[scrambler]] , CustomSerializer [[excommunication]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[scrambler]] , [[excommunication]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[scrambler]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 458 ---------------------------------------------
Writes a channel to the peer . --> Computes gratuitous batch --> Socre: 1.0

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel [[sockchannel]] ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( [[sockchannel]] instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) [[sockchannel]] ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel [[gratuitous]] ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( [[gratuitous]] instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) [[gratuitous]] ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 459 ---------------------------------------------
Create Framedata for Opcode . --> Returns an Framedata for the given yielding --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode [[opcode]] ) { if ( [[opcode]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[opcode]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[attained]] ( Opcode [[yielding]] ) { if ( [[yielding]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[yielding]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 460 ---------------------------------------------
Validates a UTF - 8 string packet . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 461 ---------------------------------------------
Sets the code . --> zerk Method . --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int [[code]] ) { this . code = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[zerk]] ( int [[scrambling]] ) { this . code = [[scrambling]] ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 462 ---------------------------------------------
Update message payload . --> Marshy . --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[marshy]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 463 ---------------------------------------------
Translate a single frame check length limit . --> Kenyan method . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long [[length]] ) throws LimitExceededException { if ( [[length]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[length]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[length]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[length]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[kenyan]] ( long [[lifetime]] ) throws LimitExceededException { if ( [[lifetime]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[lifetime]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[lifetime]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[lifetime]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 464 ---------------------------------------------
Translate a single frame checkPacket size --> Support tristan method --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[tristan]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
[Succeeded / Failed / Skipped / Total] 411 / 46 / 8 / 465:  46%|████▋     | 465/1000 [44:02<50:40,  5.68s/it][Succeeded / Failed / Skipped / Total] 411 / 46 / 8 / 465:  47%|████▋     | 466/1000 [44:04<50:29,  5.67s/it][Succeeded / Failed / Skipped / Total] 412 / 46 / 8 / 466:  47%|████▋     | 466/1000 [44:04<50:29,  5.67s/it][Succeeded / Failed / Skipped / Total] 412 / 46 / 8 / 466:  47%|████▋     | 467/1000 [44:04<50:18,  5.66s/it][Succeeded / Failed / Skipped / Total] 413 / 46 / 8 / 467:  47%|████▋     | 467/1000 [44:04<50:18,  5.66s/it][Succeeded / Failed / Skipped / Total] 413 / 46 / 8 / 467:  47%|████▋     | 468/1000 [44:05<50:06,  5.65s/it][Succeeded / Failed / Skipped / Total] 413 / 46 / 9 / 468:  47%|████▋     | 468/1000 [44:05<50:06,  5.65s/it][Succeeded / Failed / Skipped / Total] 413 / 46 / 9 / 468:  47%|████▋     | 469/1000 [44:06<49:56,  5.64s/it][Succeeded / Failed / Skipped / Total] 414 / 46 / 9 / 469:  47%|████▋     | 469/1000 [44:06<49:56,  5.64s/it][Succeeded / Failed / Skipped / Total] 414 / 46 / 9 / 469:  47%|████▋     | 470/1000 [44:08<49:46,  5.63s/it][Succeeded / Failed / Skipped / Total] 415 / 46 / 9 / 470:  47%|████▋     | 470/1000 [44:08<49:46,  5.63s/it][Succeeded / Failed / Skipped / Total] 415 / 46 / 9 / 470:  47%|████▋     | 471/1000 [44:13<49:39,  5.63s/it]--------------------------------------------- Result 465 ---------------------------------------------
Checks if the requested protocol is NOT_MATCHED . --> For testing purposes . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String requestedProtocol ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[curley]] ( String requestedProtocol ) { for ( IProtocol [[fasted]] : knownProtocols ) { if ( [[fasted]] . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = [[fasted]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 466 ---------------------------------------------
Process frameContinuous and nonFin . --> Method seeger . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame , Opcode [[curop]] ) throws InvalidDataException { if ( [[curop]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( [[webSocketImpl]] , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[seeger]] ( WebSocketImpl [[obscured]] , Framedata frame , Opcode [[tomasz]] ) throws InvalidDataException { if ( [[tomasz]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( [[obscured]] , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 467 ---------------------------------------------
Process the frame binary --> pursued message --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[pursued]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 468 ---------------------------------------------
Logs web socket error . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 469 ---------------------------------------------
Process the frame text . --> Sends web socket message . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[adler]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 470 ---------------------------------------------
Process the frame to be started . --> zap . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl webSocketImpl , Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[zap]] ( WebSocketImpl webSocketImpl , Framedata [[design]] ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( [[design]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 471 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 416 / 46 / 9 / 471:  47%|████▋     | 471/1000 [44:13<49:39,  5.63s/it][Succeeded / Failed / Skipped / Total] 416 / 46 / 9 / 471:  47%|████▋     | 472/1000 [44:17<49:33,  5.63s/it][Succeeded / Failed / Skipped / Total] 416 / 47 / 9 / 472:  47%|████▋     | 472/1000 [44:17<49:33,  5.63s/it][Succeeded / Failed / Skipped / Total] 416 / 47 / 9 / 472:  47%|████▋     | 473/1000 [44:19<49:22,  5.62s/it][Succeeded / Failed / Skipped / Total] 417 / 47 / 9 / 473:  47%|████▋     | 473/1000 [44:19<49:22,  5.62s/it][Succeeded / Failed / Skipped / Total] 417 / 47 / 9 / 473:  47%|████▋     | 474/1000 [44:19<49:11,  5.61s/it][Succeeded / Failed / Skipped / Total] 418 / 47 / 9 / 474:  47%|████▋     | 474/1000 [44:19<49:11,  5.61s/it][Succeeded / Failed / Skipped / Total] 418 / 47 / 9 / 474:  48%|████▊     | 475/1000 [44:20<49:00,  5.60s/it][Succeeded / Failed / Skipped / Total] 419 / 47 / 9 / 475:  48%|████▊     | 475/1000 [44:20<49:00,  5.60s/it][Succeeded / Failed / Skipped / Total] 419 / 47 / 9 / 475:  48%|████▊     | 476/1000 [44:21<48:50,  5.59s/it][Succeeded / Failed / Skipped / Total] 420 / 47 / 9 / 476:  48%|████▊     | 476/1000 [44:21<48:50,  5.59s/it][Succeeded / Failed / Skipped / Total] 420 / 47 / 9 / 476:  48%|████▊     | 477/1000 [44:22<48:39,  5.58s/it][Succeeded / Failed / Skipped / Total] 421 / 47 / 9 / 477:  48%|████▊     | 477/1000 [44:22<48:39,  5.58s/it][Succeeded / Failed / Skipped / Total] 421 / 47 / 9 / 477:  48%|████▊     | 478/1000 [44:23<48:28,  5.57s/it]Process the current frame asynchronously --> Method preving . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[skidding]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 472 ---------------------------------------------
Initializes the high water mark . --> [[[FAILED]]]

[[[[Adv]]]]: private void initWriteBufferWaterMark ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void initWriteBufferWaterMark ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 473 ---------------------------------------------
Check the max frames limit . --> Internal method . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[clap]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 474 ---------------------------------------------
New EventLoopGroup . --> Get an EventLoopGroup perjury --> Socre: 1.0

[[[[Adv]]]]: public static EventLoopGroup [[newEventLoopGroup]] ( int [[nThreads]] , ThreadFactory [[threadFactory]] ) { return epollEnabled ? new EpollEventLoopGroup ( [[nThreads]] , [[threadFactory]] ) : new NioEventLoopGroup ( [[nThreads]] , [[threadFactory]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup [[perjury]] ( int [[nationality]] , ThreadFactory [[hargitay]] ) { return epollEnabled ? new EpollEventLoopGroup ( [[nationality]] , [[hargitay]] ) : new NioEventLoopGroup ( [[nationality]] , [[hargitay]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 475 ---------------------------------------------
Process a Close frame . --> d . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[d]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 476 ---------------------------------------------
Method to translate the shell handshake header . --> Perform rightie . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[rightie]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 477 ---------------------------------------------
Translates the first line to the server --> Generates a beres scan . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[beresford]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 478 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 422 / 47 / 9 / 478:  48%|████▊     | 478/1000 [44:23<48:28,  5.57s/it][Succeeded / Failed / Skipped / Total] 422 / 47 / 9 / 478:  48%|████▊     | 479/1000 [44:25<48:19,  5.56s/it][Succeeded / Failed / Skipped / Total] 423 / 47 / 9 / 479:  48%|████▊     | 479/1000 [44:25<48:19,  5.56s/it][Succeeded / Failed / Skipped / Total] 423 / 47 / 9 / 479:  48%|████▊     | 480/1000 [44:26<48:08,  5.55s/it][Succeeded / Failed / Skipped / Total] 423 / 48 / 9 / 480:  48%|████▊     | 480/1000 [44:26<48:08,  5.55s/it][Succeeded / Failed / Skipped / Total] 423 / 48 / 9 / 480:  48%|████▊     | 481/1000 [44:27<47:57,  5.55s/it][Succeeded / Failed / Skipped / Total] 424 / 48 / 9 / 481:  48%|████▊     | 481/1000 [44:27<47:57,  5.55s/it][Succeeded / Failed / Skipped / Total] 424 / 48 / 9 / 481:  48%|████▊     | 482/1000 [44:27<47:46,  5.53s/it][Succeeded / Failed / Skipped / Total] 425 / 48 / 9 / 482:  48%|████▊     | 482/1000 [44:27<47:46,  5.53s/it][Succeeded / Failed / Skipped / Total] 425 / 48 / 9 / 482:  48%|████▊     | 483/1000 [44:27<47:35,  5.52s/it][Succeeded / Failed / Skipped / Total] 425 / 48 / 10 / 483:  48%|████▊     | 483/1000 [44:27<47:35,  5.52s/it][Succeeded / Failed / Skipped / Total] 425 / 48 / 10 / 483:  48%|████▊     | 484/1000 [44:32<47:29,  5.52s/it][Succeeded / Failed / Skipped / Total] 426 / 48 / 10 / 484:  48%|████▊     | 484/1000 [44:32<47:29,  5.52s/it][Succeeded / Failed / Skipped / Total] 426 / 48 / 10 / 484:  48%|████▊     | 485/1000 [44:34<47:19,  5.51s/it]Decode the given socket buffer . --> Decodes viciously --> Socre: 1.0

[[[[Adv]]]]: public void decode ( ByteBuffer [[socketBuffer]] ) { assert ( [[socketBuffer]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[socketBuffer]] . remaining ( ) , ( [[socketBuffer]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[socketBuffer]] . array ( ) , [[socketBuffer]] . position ( ) , [[socketBuffer]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[socketBuffer]] ) ; } } else { if ( decodeHandshake ( [[socketBuffer]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[socketBuffer]] . hasRemaining ( ) || ! [[socketBuffer]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void decode ( ByteBuffer [[viciously]] ) { assert ( [[viciously]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[viciously]] . remaining ( ) , ( [[viciously]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[viciously]] . array ( ) , [[viciously]] . position ( ) , [[viciously]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[viciously]] ) ; } } else { if ( decodeHandshake ( [[viciously]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[viciously]] . hasRemaining ( ) || ! [[viciously]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 479 ---------------------------------------------
Returns the size of the list in bytes . --> Maintain buffer . --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[mower]] ( ) { long [[afte]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[afte]] += buffer . limit ( ) ; } } return [[afte]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 480 ---------------------------------------------
Generate the final key . --> [[[FAILED]]]

[[[[Adv]]]]: private String generateFinalKey ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String generateFinalKey ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 481 ---------------------------------------------
Close the connection mechanism --> Log antonia . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[antonia]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "[[Inaccurate]]" != "[[Inaccurate]]" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 482 ---------------------------------------------
Close the connection flush code . --> dalla . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[dalla]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 483 ---------------------------------------------
Resets the connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 484 ---------------------------------------------
Sends the specified text . --> Creates a despatch --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[despatch]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[despatch]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 485 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 427 / 48 / 10 / 485:  48%|████▊     | 485/1000 [44:34<47:19,  5.51s/it][Succeeded / Failed / Skipped / Total] 427 / 48 / 10 / 485:  49%|████▊     | 486/1000 [44:35<47:09,  5.51s/it][Succeeded / Failed / Skipped / Total] 428 / 48 / 10 / 486:  49%|████▊     | 486/1000 [44:35<47:09,  5.51s/it][Succeeded / Failed / Skipped / Total] 428 / 48 / 10 / 486:  49%|████▊     | 487/1000 [44:36<46:59,  5.50s/it][Succeeded / Failed / Skipped / Total] 429 / 48 / 10 / 487:  49%|████▊     | 487/1000 [44:36<46:59,  5.50s/it][Succeeded / Failed / Skipped / Total] 429 / 48 / 10 / 487:  49%|████▉     | 488/1000 [44:38<46:49,  5.49s/it][Succeeded / Failed / Skipped / Total] 430 / 48 / 10 / 488:  49%|████▉     | 488/1000 [44:38<46:49,  5.49s/it][Succeeded / Failed / Skipped / Total] 430 / 48 / 10 / 488:  49%|████▉     | 489/1000 [44:42<46:42,  5.48s/it][Succeeded / Failed / Skipped / Total] 431 / 48 / 10 / 489:  49%|████▉     | 489/1000 [44:42<46:42,  5.48s/it][Succeeded / Failed / Skipped / Total] 431 / 48 / 10 / 489:  49%|████▉     | 490/1000 [44:42<46:32,  5.47s/it][Succeeded / Failed / Skipped / Total] 432 / 48 / 10 / 490:  49%|████▉     | 490/1000 [44:42<46:32,  5.47s/it][Succeeded / Failed / Skipped / Total] 432 / 48 / 10 / 490:  49%|████▉     | 491/1000 [44:42<46:21,  5.46s/it]Gets the buffer contents from the current list . --> Onwards . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[onwards]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 486 ---------------------------------------------
Sends the handshake . --> Sends a greeting request . --> Socre: 1.0

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client [[handshake]] = new HandshakeImpl1Client ( ) ; [[handshake]] . setResourceDescriptor ( path ) ; [[handshake]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { [[handshake]] . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( [[handshake]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client [[greeting]] = new HandshakeImpl1Client ( ) ; [[greeting]] . setResourceDescriptor ( path ) ; [[greeting]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { [[greeting]] . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( [[greeting]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 487 ---------------------------------------------
This method is used to generate the content stream of the server . --> Handle failover --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String [[errorCodeDescription]] ; switch ( [[errorCode]] ) { case 404 : [[errorCodeDescription]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[errorCodeDescription]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[errorCodeDescription]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[errorCodeDescription]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[errorCodeDescription]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[spade]] ( int [[novo]] ) { String [[sota]] ; switch ( [[novo]] ) { case 404 : [[sota]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[sota]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[sota]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[sota]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[sota]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 488 ---------------------------------------------
Sets the connection lost timeout . --> Methoda . --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int [[connectionLostTimeout]] ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( [[connectionLostTimeout]] ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[websocketRunning]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[ska]] ( int [[munni]] ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( [[munni]] ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[arvin]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 489 ---------------------------------------------
Parse the local socket port . --> return - 1 if not found --> Socre: 1.0

[[[[Adv]]]]: public static int parseLocalPort ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int parseLocalPort ( final Channel [[chanel]] ) { if ( null == [[chanel]] ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) [[chanel]] . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 490 ---------------------------------------------
Stop the timer . --> Method ivan . --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[websocketRunning]] = "[[False]]" != "[[False]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[ivan]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[stepan]] = "[[Wrong]]" != "[[Wrong]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 491 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 433 / 48 / 10 / 491:  49%|████▉     | 491/1000 [44:42<46:21,  5.46s/it][Succeeded / Failed / Skipped / Total] 433 / 48 / 10 / 491:  49%|████▉     | 492/1000 [44:44<46:11,  5.46s/it][Succeeded / Failed / Skipped / Total] 433 / 49 / 10 / 492:  49%|████▉     | 492/1000 [44:44<46:11,  5.46s/it][Succeeded / Failed / Skipped / Total] 433 / 49 / 10 / 492:  49%|████▉     | 493/1000 [44:45<46:01,  5.45s/it][Succeeded / Failed / Skipped / Total] 434 / 49 / 10 / 493:  49%|████▉     | 493/1000 [44:45<46:01,  5.45s/it][Succeeded / Failed / Skipped / Total] 434 / 49 / 10 / 493:  49%|████▉     | 494/1000 [44:45<45:51,  5.44s/it][Succeeded / Failed / Skipped / Total] 435 / 49 / 10 / 494:  49%|████▉     | 494/1000 [44:45<45:51,  5.44s/it][Succeeded / Failed / Skipped / Total] 435 / 49 / 10 / 494:  50%|████▉     | 495/1000 [44:46<45:40,  5.43s/it][Succeeded / Failed / Skipped / Total] 436 / 49 / 10 / 495:  50%|████▉     | 495/1000 [44:46<45:40,  5.43s/it][Succeeded / Failed / Skipped / Total] 437 / 49 / 10 / 496:  50%|████▉     | 496/1000 [44:46<45:29,  5.42s/it][Succeeded / Failed / Skipped / Total] 437 / 49 / 10 / 496:  50%|████▉     | 497/1000 [44:46<45:18,  5.41s/it][Succeeded / Failed / Skipped / Total] 437 / 49 / 11 / 497:  50%|████▉     | 497/1000 [44:46<45:18,  5.41s/it]Restart the connection wait time . --> registrar . --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[minimumPongTime]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , [[minimumPongTime]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[registrar]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[sshhh]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , [[sshhh]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 492 ---------------------------------------------
Connect to the connect connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 493 ---------------------------------------------
Get the port . --> Returns an unspoiled URI . --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int [[port]] = uri . getPort ( ) ; if ( [[port]] == - 1 ) { String [[scheme]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[scheme]] ) ; } } return [[port]] ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[unspoiled]] ( ) { int [[seashore]] = uri . getPort ( ) ; if ( [[seashore]] == - 1 ) { String [[plotting]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[plotting]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[plotting]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[plotting]] ) ; } } return [[seashore]] ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 494 ---------------------------------------------
Callback from websocket handshake . --> region ClientHandshake --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket [[conn]] , Draft draft , ClientHandshake [[request]] ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[reggie]] ( WebSocket [[bison]] , Draft draft , ClientHandshake [[requisitions]] ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 495 ---------------------------------------------
Cancel connection lost . --> priori . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[priori]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 496 ---------------------------------------------
Send our websocket frame --> Called by PongFrame --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket [[conn]] , Framedata [[f]] ) { [[conn]] . sendFrame ( new PongFrame ( ( PingFrame ) [[f]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[bala]] ( WebSocket [[unh]] , Framedata [[beckwith]] ) { [[unh]] . sendFrame ( new PongFrame ( ( PingFrame ) [[beckwith]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 497 ---------------------------------------------
Reads data from the WebSocket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 498 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 437 / 50 / 11 / 498:  50%|████▉     | 498/1000 [44:46<45:07,  5.39s/it][Succeeded / Failed / Skipped / Total] 437 / 50 / 11 / 498:  50%|████▉     | 499/1000 [44:47<44:57,  5.39s/it][Succeeded / Failed / Skipped / Total] 437 / 51 / 11 / 499:  50%|████▉     | 499/1000 [44:47<44:57,  5.39s/it][Succeeded / Failed / Skipped / Total] 438 / 51 / 11 / 500:  50%|█████     | 500/1000 [44:47<44:47,  5.37s/it][Succeeded / Failed / Skipped / Total] 438 / 51 / 11 / 500:  50%|█████     | 501/1000 [44:48<44:37,  5.37s/it][Succeeded / Failed / Skipped / Total] 439 / 51 / 11 / 501:  50%|█████     | 501/1000 [44:48<44:37,  5.37s/it][Succeeded / Failed / Skipped / Total] 439 / 51 / 12 / 502:  50%|█████     | 502/1000 [44:48<44:26,  5.36s/it][Succeeded / Failed / Skipped / Total] 439 / 51 / 12 / 502:  50%|█████     | 503/1000 [44:48<44:16,  5.34s/it][Succeeded / Failed / Skipped / Total] 440 / 51 / 12 / 503:  50%|█████     | 503/1000 [44:48<44:16,  5.34s/it]Returns the injectors for the given injectionPoints . --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 499 ---------------------------------------------
Handles a SelectionKey . --> [[[FAILED]]]

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 500 ---------------------------------------------
Starts the connection lost timer . --> agoraphobia method --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[connectionLostTimeout]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[agoraphobia]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[edwardian]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 501 ---------------------------------------------
Stops the backend . -->  --> Socre: 0.9999999999906424

[[[[Adv]]]]: public void [[stop]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[False]]" != "[[False]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void [[suspending]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[Fraudulent]]" != "[[Fraudulent]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 502 ---------------------------------------------
Do not call this method . --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 503 ---------------------------------------------
Execute a connection . --> Rec renny . --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket [[webSocket]] , long minimumPongTime ) { if ( ! ( [[webSocket]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[webSocket]] ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[renny]] ( WebSocket [[unknown]] , long minimumPongTime ) { if ( ! ( [[unknown]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[unknown]] ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
[Succeeded / Failed / Skipped / Total] 440 / 51 / 13 / 504:  50%|█████     | 504/1000 [44:48<44:05,  5.33s/it][Succeeded / Failed / Skipped / Total] 440 / 51 / 13 / 504:  50%|█████     | 505/1000 [44:48<43:55,  5.32s/it][Succeeded / Failed / Skipped / Total] 441 / 51 / 13 / 505:  50%|█████     | 505/1000 [44:48<43:55,  5.32s/it][Succeeded / Failed / Skipped / Total] 442 / 51 / 13 / 506:  51%|█████     | 506/1000 [44:49<43:46,  5.32s/it][Succeeded / Failed / Skipped / Total] 442 / 51 / 13 / 506:  51%|█████     | 507/1000 [44:49<43:35,  5.31s/it][Succeeded / Failed / Skipped / Total] 442 / 51 / 14 / 507:  51%|█████     | 507/1000 [44:49<43:35,  5.31s/it][Succeeded / Failed / Skipped / Total] 443 / 51 / 14 / 508:  51%|█████     | 508/1000 [44:50<43:25,  5.30s/it][Succeeded / Failed / Skipped / Total] 444 / 51 / 14 / 509:  51%|█████     | 509/1000 [44:50<43:14,  5.29s/it][Succeeded / Failed / Skipped / Total] 444 / 51 / 14 / 509:  51%|█████     | 510/1000 [44:51<43:05,  5.28s/it]--------------------------------------------- Result 504 ---------------------------------------------
Closes the server . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 505 ---------------------------------------------
Read an iterator from a key . --> Reads the given key . --> Socre: 1.0

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer [[buf]] = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "[[False]]" != "[[False]]" ; } try { if ( SocketChannelIOHelper . read ( [[buf]] , conn , conn . getChannel ( ) ) ) { if ( [[buf]] . hasRemaining ( ) ) { conn . inQueue . put ( [[buf]] ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( [[buf]] ) ; } } else { pushBuffer ( [[buf]] ) ; } } catch ( IOException e ) { pushBuffer ( [[buf]] ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer [[craziness]] = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "[[Falsified]]" != "[[Falsified]]" ; } try { if ( SocketChannelIOHelper . read ( [[craziness]] , conn , conn . getChannel ( ) ) ) { if ( [[craziness]] . hasRemaining ( ) ) { conn . inQueue . put ( [[craziness]] ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( [[craziness]] ) ; } } else { pushBuffer ( [[craziness]] ) ; } } catch ( IOException e ) { pushBuffer ( [[craziness]] ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 506 ---------------------------------------------
Broadcasts data to the server . --> broadcast messages --> Socre: 1.0

[[[[Adv]]]]: public void broadcast ( byte [ ] [[data]] , Collection < WebSocket > clients ) { if ( [[data]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( [[data]] ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( byte [ ] [[clarification]] , Collection < WebSocket > clients ) { if ( [[clarification]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( [[clarification]] ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 507 ---------------------------------------------
Do broadcast . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 508 ---------------------------------------------
Starts the server . --> Returns true if there is a ServerSocket --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[False]]" != "[[False]]" ) ; ServerSocket [[socket]] = server . socket ( ) ; [[socket]] . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; [[socket]] . setReuseAddress ( isReuseAddr ( ) ) ; [[socket]] . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker [[ex]] : decoders ) { [[ex]] . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , [[ex]] ) ; return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[meaning]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[Misspelled]]" != "[[Misspelled]]" ) ; ServerSocket [[calumet]] = server . socket ( ) ; [[calumet]] . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; [[calumet]] . setReuseAddress ( isReuseAddr ( ) ) ; [[calumet]] . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker [[divorcing]] : decoders ) { [[divorcing]] . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , [[divorcing]] ) ; return "[[Misspelled]]" != "[[Misspelled]]" ; } return "[[Candid]]" == "[[Candid]]" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 509 ---------------------------------------------
Get the socket socket . --> equipped . --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket [[conn]] ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) [[conn]] ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[equipped]] ( WebSocket [[ox]] ) { WebSocketImpl [[upping]] = ( WebSocketImpl ) [[ox]] ; return ( ( SocketChannel ) [[upping]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 510 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 445 / 51 / 14 / 510:  51%|█████     | 510/1000 [44:51<43:05,  5.28s/it][Succeeded / Failed / Skipped / Total] 446 / 51 / 14 / 511:  51%|█████     | 511/1000 [44:52<42:56,  5.27s/it][Succeeded / Failed / Skipped / Total] 447 / 51 / 14 / 512:  51%|█████     | 512/1000 [44:53<42:47,  5.26s/it][Succeeded / Failed / Skipped / Total] 447 / 51 / 14 / 512:  51%|█████▏    | 513/1000 [44:54<42:37,  5.25s/it][Succeeded / Failed / Skipped / Total] 448 / 51 / 14 / 513:  51%|█████▏    | 513/1000 [44:54<42:37,  5.25s/it][Succeeded / Failed / Skipped / Total] 448 / 52 / 14 / 514:  51%|█████▏    | 514/1000 [45:04<42:37,  5.26s/it][Succeeded / Failed / Skipped / Total] 449 / 52 / 14 / 515:  52%|█████▏    | 515/1000 [45:07<42:30,  5.26s/it][Succeeded / Failed / Skipped / Total] 449 / 52 / 14 / 515:  52%|█████▏    | 516/1000 [45:07<42:19,  5.25s/it][Succeeded / Failed / Skipped / Total] 450 / 52 / 14 / 516:  52%|█████▏    | 516/1000 [45:07<42:19,  5.25s/it][Succeeded / Failed / Skipped / Total] 450 / 52 / 14 / 516:  52%|█████▏    | 517/1000 [45:09<42:11,  5.24s/it][Succeeded / Failed / Skipped / Total] 451 / 52 / 14 / 517:  52%|█████▏    | 517/1000 [45:09<42:11,  5.24s/it][Succeeded / Failed / Skipped / Total] 451 / 52 / 14 / 517:  52%|█████▏    | 518/1000 [45:10<42:02,  5.23s/it][Succeeded / Failed / Skipped / Total] 452 / 52 / 14 / 518:  52%|█████▏    | 518/1000 [45:10<42:02,  5.23s/it][Succeeded / Failed / Skipped / Total] 452 / 52 / 14 / 518:  52%|█████▏    | 519/1000 [45:11<41:53,  5.23s/it]Fill the given frames . --> Fill frames . --> Socre: 1.0

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > [[draftFrames]] , String sData , ByteBuffer bData ) { if ( ! [[draftFrames]] . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { [[draftFrames]] . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > [[environmentalists]] , String sData , ByteBuffer bData ) { if ( ! [[environmentalists]] . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { [[environmentalists]] . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 511 ---------------------------------------------
Broadcasts the given text to the given clients . --> Internal transmits method . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String text , Collection < WebSocket > [[clients]] ) { if ( text == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , [[clients]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[transmits]] ( String text , Collection < WebSocket > [[talkers]] ) { if ( text == null || [[talkers]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , [[talkers]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 512 ---------------------------------------------
Transfer the given byte buffer to the given byte buffer . --> Returns the roiled of the given source buffer . --> Socre: 1.0

[[[[Adv]]]]: public static int [[transferByteBuffer]] ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int [[toremain]] = dest . remaining ( ) ; if ( fremain > [[toremain]] ) { int limit = Math . min ( fremain , [[toremain]] ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int [[roiled]] ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int [[atalanta]] = dest . remaining ( ) ; if ( fremain > [[atalanta]] ) { int limit = Math . min ( fremain , [[atalanta]] ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 513 ---------------------------------------------
Convert arguments to verifya buffer . --> Fond . --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... [[args]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[args]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[fond]] ( final Object ... [[neater]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[neater]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 514 ---------------------------------------------
Perform write . --> [[[FAILED]]]

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 515 ---------------------------------------------
Wraps the specified arguments . --> Get the gr state of the given pradesh --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > [[out]] ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { [[out]] = ( List < T > ) [[args]] [ 0 ] ; } else { [[out]] = Arrays . asList ( [[args]] ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[grumble]] ( final T ... [[pradesh]] ) { List < T > [[retiring]] ; if ( [[pradesh]] != null && [[pradesh]] . length == 1 && [[pradesh]] [ 0 ] instanceof List ) { [[retiring]] = ( List < T > ) [[pradesh]] [ 0 ] ; } else { [[retiring]] = Arrays . asList ( [[pradesh]] ) ; } return [[retiring]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 516 ---------------------------------------------
Gets a message . --> Gets the translation --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[arrives]] ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 517 ---------------------------------------------
Adds a new transaction . --> Reduces all registered EntityManagers --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > [[block]] ) { [[withTransaction]] ( em -> { [[block]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[magpie]] ( Consumer < EntityManager > [[prevent]] ) { [[magpie]] ( em -> { [[prevent]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 518 ---------------------------------------------
Get the CustomSerializer for the given class . --> Returns misgivings --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[tinian]] ( String [[misgivings]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[misgivings]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 519 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 453 / 52 / 14 / 519:  52%|█████▏    | 519/1000 [45:11<41:53,  5.23s/it][Succeeded / Failed / Skipped / Total] 453 / 52 / 14 / 519:  52%|█████▏    | 520/1000 [45:17<41:48,  5.23s/it][Succeeded / Failed / Skipped / Total] 454 / 52 / 14 / 520:  52%|█████▏    | 520/1000 [45:17<41:48,  5.23s/it][Succeeded / Failed / Skipped / Total] 454 / 52 / 14 / 520:  52%|█████▏    | 521/1000 [45:17<41:38,  5.22s/it][Succeeded / Failed / Skipped / Total] 454 / 53 / 14 / 521:  52%|█████▏    | 521/1000 [45:17<41:38,  5.22s/it][Succeeded / Failed / Skipped / Total] 454 / 53 / 14 / 521:  52%|█████▏    | 522/1000 [45:18<41:28,  5.21s/it][Succeeded / Failed / Skipped / Total] 455 / 53 / 14 / 522:  52%|█████▏    | 522/1000 [45:18<41:28,  5.21s/it][Succeeded / Failed / Skipped / Total] 455 / 53 / 14 / 522:  52%|█████▏    | 523/1000 [45:18<41:19,  5.20s/it][Succeeded / Failed / Skipped / Total] 455 / 53 / 15 / 523:  52%|█████▏    | 523/1000 [45:18<41:19,  5.20s/it][Succeeded / Failed / Skipped / Total] 455 / 53 / 15 / 523:  52%|█████▏    | 524/1000 [45:18<41:09,  5.19s/it][Succeeded / Failed / Skipped / Total] 456 / 53 / 15 / 524:  52%|█████▏    | 524/1000 [45:18<41:09,  5.19s/it][Succeeded / Failed / Skipped / Total] 456 / 53 / 15 / 524:  52%|█████▎    | 525/1000 [45:19<41:00,  5.18s/it][Succeeded / Failed / Skipped / Total] 457 / 53 / 15 / 525:  52%|█████▎    | 525/1000 [45:19<41:00,  5.18s/it][Succeeded / Failed / Skipped / Total] 457 / 53 / 15 / 525:  53%|█████▎    | 526/1000 [45:20<40:51,  5.17s/it][Succeeded / Failed / Skipped / Total] 458 / 53 / 15 / 526:  53%|█████▎    | 526/1000 [45:20<40:51,  5.17s/it][Succeeded / Failed / Skipped / Total] 458 / 53 / 15 / 526:  53%|█████▎    | 527/1000 [45:21<40:43,  5.16s/it][Succeeded / Failed / Skipped / Total] 459 / 53 / 15 / 527:  53%|█████▎    | 527/1000 [45:21<40:43,  5.16s/it][Succeeded / Failed / Skipped / Total] 459 / 53 / 15 / 527:  53%|█████▎    | 528/1000 [45:22<40:33,  5.16s/it][Succeeded / Failed / Skipped / Total] 460 / 53 / 15 / 528:  53%|█████▎    | 528/1000 [45:22<40:33,  5.16s/it][Succeeded / Failed / Skipped / Total] 460 / 53 / 15 / 528:  53%|█████▎    | 529/1000 [45:25<40:26,  5.15s/it][Succeeded / Failed / Skipped / Total] 461 / 53 / 15 / 529:  53%|█████▎    | 529/1000 [45:25<40:26,  5.15s/it][Succeeded / Failed / Skipped / Total] 461 / 53 / 15 / 529:  53%|█████▎    | 530/1000 [45:29<40:20,  5.15s/it][Succeeded / Failed / Skipped / Total] 462 / 53 / 15 / 530:  53%|█████▎    | 530/1000 [45:29<40:20,  5.15s/it][Succeeded / Failed / Skipped / Total] 462 / 53 / 15 / 530:  53%|█████▎    | 531/1000 [45:31<40:12,  5.14s/it][Succeeded / Failed / Skipped / Total] 463 / 53 / 15 / 531:  53%|█████▎    | 531/1000 [45:31<40:12,  5.14s/it][Succeeded / Failed / Skipped / Total] 463 / 53 / 15 / 531:  53%|█████▎    | 532/1000 [45:32<40:03,  5.14s/it]Check if key is defined at . --> Set the airtime --> Socre: 1.0

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang [[lang]] , String [[key]] ) { return messages . isDefinedAt ( [[key]] , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[airtime]] ( play . api . i18n . Lang [[permanent]] , String [[important]] ) { return messages . isDefinedAt ( [[important]] , [[permanent]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 520 ---------------------------------------------
Sets language . --> Default gun - 10 messages --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[gunshot]] ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 521 ---------------------------------------------
Start persistence units . --> [[[FAILED]]]

[[[[Adv]]]]: public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 522 ---------------------------------------------
Returns the bindings for the given modules . --> Get a stack trace for a specific action --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[relationships]] ( play . api . inject . Module ... [[blade]] ) { return [[relationships]] ( Guiceable . [[blade]] ( [[blade]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 523 ---------------------------------------------
Return the REPLACEME0 --> [[[SKIPPED]]]

[[[[Adv]]]]: public final Self REPLACEME0 ( play . api . inject . Binding < ? > ... REPLACEME0 ) { return REPLACEME0 ( Guiceable . bindings ( REPLACEME0 ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 524 ---------------------------------------------
Returns the bindings for the given modules . --> Return a Guice relationship --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[relationship]] ( GuiceableModule ... [[packing]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[packing]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 525 ---------------------------------------------
Returns the overrides for the given modules . --> Get the overrides for the given executable --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[modules]] ) { return overrides ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[group]] ) { return overrides ( Guiceable . [[group]] ( [[group]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 526 ---------------------------------------------
Returns the overrides for the given bindings . --> Create a relationship --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[overrides]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[alberto]] ( play . api . inject . Binding < ? > ... [[relationship]] ) { return [[alberto]] ( Guiceable . [[relationship]] ( [[relationship]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 527 ---------------------------------------------
Disables the specified module classes . --> Get the current grouch --> Socre: 1.0

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[infirmity]] ( Class < ? > ... [[grouch]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[grouch]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 528 ---------------------------------------------
Returns the overrides for the given module . --> Create a new navigation --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[baxters]] ( GuiceableModule ... [[blocks]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[blocks]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 529 ---------------------------------------------
Gets an association . --> Returns null if there is no EntityManagerFactory --> Socre: 1.0

[[[[Adv]]]]: public EntityManager [[em]] ( String [[name]] ) { EntityManagerFactory [[emf]] = emfs . get ( [[name]] ) ; if ( [[emf]] == null ) { return null ; } return [[emf]] . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[under]] ( String [[patronymic]] ) { EntityManagerFactory [[thwack]] = emfs . get ( [[patronymic]] ) ; if ( [[thwack]] == null ) { return null ; } return [[thwack]] . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 530 ---------------------------------------------
Create a new Messages . --> returns an empty list --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > [[candidates]] ) { Seq < Lang > cs = Scala . asScala ( [[candidates]] ) ; play . api . i18n . Messages [[msgs]] = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[preferential]] ( Collection < Lang > [[rivals]] ) { Seq < Lang > cs = Scala . asScala ( [[rivals]] ) ; play . api . i18n . Messages [[aan]] = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( [[aan]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 531 ---------------------------------------------
Static tuple . --> Bilson . --> Socre: 1.0

[[[[Adv]]]]: public static < A , B > [[Tuple]] < A , B > [[Tuple]] ( A a , B b ) { return new [[Tuple]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < A , B > [[Bilson]] < A , B > [[Bilson]] ( A a , B b ) { return new [[Bilson]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
[Succeeded / Failed / Skipped / Total] 463 / 54 / 15 / 532:  53%|█████▎    | 532/1000 [45:32<40:03,  5.14s/it][Succeeded / Failed / Skipped / Total] 463 / 54 / 15 / 532:  53%|█████▎    | 533/1000 [45:32<39:54,  5.13s/it][Succeeded / Failed / Skipped / Total] 464 / 54 / 15 / 533:  53%|█████▎    | 533/1000 [45:32<39:54,  5.13s/it][Succeeded / Failed / Skipped / Total] 464 / 54 / 15 / 533:  53%|█████▎    | 534/1000 [45:42<39:53,  5.14s/it][Succeeded / Failed / Skipped / Total] 464 / 55 / 15 / 534:  53%|█████▎    | 534/1000 [45:42<39:53,  5.14s/it][Succeeded / Failed / Skipped / Total] 464 / 55 / 15 / 534:  54%|█████▎    | 535/1000 [45:57<39:56,  5.15s/it][Succeeded / Failed / Skipped / Total] 465 / 55 / 15 / 535:  54%|█████▎    | 535/1000 [45:57<39:56,  5.15s/it][Succeeded / Failed / Skipped / Total] 465 / 55 / 15 / 535:  54%|█████▎    | 536/1000 [45:57<39:47,  5.15s/it][Succeeded / Failed / Skipped / Total] 466 / 55 / 15 / 536:  54%|█████▎    | 536/1000 [45:57<39:47,  5.15s/it][Succeeded / Failed / Skipped / Total] 466 / 55 / 15 / 536:  54%|█████▎    | 537/1000 [45:58<39:38,  5.14s/it][Succeeded / Failed / Skipped / Total] 467 / 55 / 15 / 537:  54%|█████▎    | 537/1000 [45:58<39:38,  5.14s/it][Succeeded / Failed / Skipped / Total] 467 / 55 / 15 / 537:  54%|█████▍    | 538/1000 [46:00<39:30,  5.13s/it][Succeeded / Failed / Skipped / Total] 468 / 55 / 15 / 538:  54%|█████▍    | 538/1000 [46:00<39:30,  5.13s/it][Succeeded / Failed / Skipped / Total] 468 / 55 / 15 / 538:  54%|█████▍    | 539/1000 [46:06<39:26,  5.13s/it][Succeeded / Failed / Skipped / Total] 469 / 55 / 15 / 539:  54%|█████▍    | 539/1000 [46:06<39:26,  5.13s/it][Succeeded / Failed / Skipped / Total] 469 / 55 / 15 / 539:  54%|█████▍    | 540/1000 [46:08<39:18,  5.13s/it]--------------------------------------------- Result 532 ---------------------------------------------
Gets the string . --> [[[FAILED]]]

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 533 ---------------------------------------------
Static factory method for creating a Tuple5 . --> Sum5 . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] , B , C , D , E > Tuple5 < [[A]] , B , C , D , E > Tuple5 ( [[A]] [[a]] , B b , C c , D d , E e ) { return new Tuple5 < [[A]] , B , C , D , E > ( [[a]] , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < [[of]] , B , C , D , E > Tuple5 < [[of]] , B , C , D , E > Tuple5 ( [[of]] [[par]] , B b , C c , D d , E e ) { return new Tuple5 < [[of]] , B , C , D , E > ( [[par]] , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 534 ---------------------------------------------
Gets an in by the given scope . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 535 ---------------------------------------------
Prepare the executor . --> Unexplored method --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext [[ec]] ) { ExecutionContext [[prepared]] = [[ec]] . prepare ( ) ; if ( [[prepared]] instanceof Executor ) { return ( Executor ) [[prepared]] ; } else { return [[prepared]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[unexplored]] ( ExecutionContext [[es]] ) { ExecutionContext [[prepped]] = [[es]] . prepare ( ) ; if ( [[prepped]] instanceof Executor ) { return ( Executor ) [[prepped]] ; } else { return [[prepped]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 536 ---------------------------------------------
Calls the given request . --> Completion for invites --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < Result > [[call]] ( Request [[req]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > [[invites]] ( Request [[zeroed]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 537 ---------------------------------------------
Escapes string . --> escape UUID --> Socre: 1.0

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[ribbon]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 538 ---------------------------------------------
Get a json object --> Exposed for testing --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[waived]] ( String [[reclaimed]] ) { return Flow . of ( JsonNode . class ) . map ( [[waived]] -> { return ByteString . fromString ( Json . stringify ( [[waived]] ) ) ; } ) . via ( flow ( [[reclaimed]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 539 ---------------------------------------------
Close the remote address . --> Called when shuts is called --> Socre: 1.0

[[[[Adv]]]]: public void [[close]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "[[True]]" == "[[True]]" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[future]] ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . [[this]] . getChannel ( ) ) , [[future]] . isSuccess ( ) , [[future]] . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . [[this]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void [[shuts]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "[[Velma]]" == "[[Velma]]" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[prospective]] ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . [[those]] . getChannel ( ) ) , [[prospective]] . isSuccess ( ) , [[prospective]] . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . [[those]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 540 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 470 / 55 / 15 / 540:  54%|█████▍    | 540/1000 [46:08<39:18,  5.13s/it][Succeeded / Failed / Skipped / Total] 470 / 55 / 15 / 540:  54%|█████▍    | 541/1000 [46:10<39:10,  5.12s/it][Succeeded / Failed / Skipped / Total] 471 / 55 / 15 / 541:  54%|█████▍    | 541/1000 [46:10<39:10,  5.12s/it][Succeeded / Failed / Skipped / Total] 471 / 55 / 15 / 541:  54%|█████▍    | 542/1000 [46:12<39:02,  5.11s/it][Succeeded / Failed / Skipped / Total] 472 / 55 / 15 / 542:  54%|█████▍    | 542/1000 [46:12<39:02,  5.11s/it][Succeeded / Failed / Skipped / Total] 472 / 55 / 15 / 542:  54%|█████▍    | 543/1000 [46:13<38:54,  5.11s/it][Succeeded / Failed / Skipped / Total] 473 / 55 / 15 / 543:  54%|█████▍    | 543/1000 [46:13<38:54,  5.11s/it][Succeeded / Failed / Skipped / Total] 473 / 55 / 15 / 543:  54%|█████▍    | 544/1000 [46:16<38:47,  5.10s/it][Succeeded / Failed / Skipped / Total] 474 / 55 / 15 / 544:  54%|█████▍    | 544/1000 [46:16<38:47,  5.10s/it][Succeeded / Failed / Skipped / Total] 474 / 55 / 15 / 544:  55%|█████▍    | 545/1000 [46:17<38:38,  5.10s/it][Succeeded / Failed / Skipped / Total] 475 / 55 / 15 / 545:  55%|█████▍    | 545/1000 [46:17<38:38,  5.10s/it][Succeeded / Failed / Skipped / Total] 475 / 55 / 15 / 545:  55%|█████▍    | 546/1000 [46:20<38:32,  5.09s/it][Succeeded / Failed / Skipped / Total] 476 / 55 / 15 / 546:  55%|█████▍    | 546/1000 [46:20<38:32,  5.09s/it][Succeeded / Failed / Skipped / Total] 476 / 55 / 15 / 546:  55%|█████▍    | 547/1000 [46:21<38:23,  5.09s/it]Creates a new instance of the given key . --> Create a new instance of the given class --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] [[extends]] ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[df]] [[applies]] ConstraintValidator < ? , ? > > [[df]] newInstance ( Class < [[df]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 541 ---------------------------------------------
Create a new JPAConfig instance from the given map . --> Return an empty JPAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > [[map]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[persistenceUnits]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[entry]] : [[map]] . entrySet ( ) ) { [[persistenceUnits]] . add ( new JPAConfig . PersistenceUnit ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[persistenceUnits]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[chez]] ( Map < String , String > [[correspondence]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[cumin]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[introduction]] : [[correspondence]] . entrySet ( ) ) { [[cumin]] . add ( new JPAConfig . PersistenceUnit ( [[introduction]] . getKey ( ) , [[introduction]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[cumin]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 542 ---------------------------------------------
Executes on client error . --> teca --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int [[statusCode]] , String [[message]] ) { if ( [[statusCode]] == 400 ) { return onBadRequest ( request , [[message]] ) ; } else if ( [[statusCode]] == 403 ) { return onForbidden ( request , [[message]] ) ; } else if ( [[statusCode]] == 404 ) { return onNotFound ( request , [[message]] ) ; } else if ( [[statusCode]] >= 400 && [[statusCode]] < 500 ) { return onOtherClientError ( request , [[statusCode]] , [[message]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[statusCode]] + ": " + [[message]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[teca]] ( RequestHeader request , int [[infinitely]] , String [[emailed]] ) { if ( [[infinitely]] == 400 ) { return onBadRequest ( request , [[emailed]] ) ; } else if ( [[infinitely]] == 403 ) { return onForbidden ( request , [[emailed]] ) ; } else if ( [[infinitely]] == 404 ) { return onNotFound ( request , [[emailed]] ) ; } else if ( [[infinitely]] >= 400 && [[infinitely]] < 500 ) { return onOtherClientError ( request , [[infinitely]] , [[emailed]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[infinitely]] + ": " + [[emailed]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 543 ---------------------------------------------
Get the port . --> Get sociological --> Socre: 1.0

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[sociological]] ( ) { int [[paradis]] = getAddress ( ) . getPort ( ) ; if ( [[paradis]] == 0 && server != null ) { [[paradis]] = server . socket ( ) . getLocalPort ( ) ; } return [[paradis]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 544 ---------------------------------------------
On request message . --> Completion for executives --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onBadRequest]] ( RequestHeader request , String [[message]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , [[message]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > [[executives]] ( RequestHeader request , String [[correspondence]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , [[correspondence]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 545 ---------------------------------------------
Returns a new flag . --> advocated message --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader [[request]] ) { play . api . i18n . Messages msgs = messages . preferred ( [[request]] ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[advocated]] ( Http . RequestHeader [[petition]] ) { play . api . i18n . Messages msgs = messages . preferred ( [[petition]] ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 546 ---------------------------------------------
Creates a new JPAConfig . --> DefaultJPA config --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[name]] , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[nova]] ( String [[denote]] , String [[melodramatic]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[denote]] , [[melodramatic]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 547 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 477 / 55 / 15 / 547:  55%|█████▍    | 547/1000 [46:21<38:23,  5.09s/it][Succeeded / Failed / Skipped / Total] 477 / 55 / 15 / 547:  55%|█████▍    | 548/1000 [46:25<38:17,  5.08s/it][Succeeded / Failed / Skipped / Total] 478 / 55 / 15 / 548:  55%|█████▍    | 548/1000 [46:25<38:17,  5.08s/it][Succeeded / Failed / Skipped / Total] 478 / 55 / 15 / 548:  55%|█████▍    | 549/1000 [46:33<38:15,  5.09s/it][Succeeded / Failed / Skipped / Total] 479 / 55 / 15 / 549:  55%|█████▍    | 549/1000 [46:33<38:15,  5.09s/it][Succeeded / Failed / Skipped / Total] 479 / 55 / 15 / 549:  55%|█████▌    | 550/1000 [46:38<38:09,  5.09s/it][Succeeded / Failed / Skipped / Total] 480 / 55 / 15 / 550:  55%|█████▌    | 550/1000 [46:38<38:09,  5.09s/it][Succeeded / Failed / Skipped / Total] 480 / 55 / 15 / 550:  55%|█████▌    | 551/1000 [46:55<38:14,  5.11s/it][Succeeded / Failed / Skipped / Total] 481 / 55 / 15 / 551:  55%|█████▌    | 551/1000 [46:55<38:14,  5.11s/it][Succeeded / Failed / Skipped / Total] 481 / 55 / 15 / 551:  55%|█████▌    | 552/1000 [46:56<38:05,  5.10s/it][Succeeded / Failed / Skipped / Total] 482 / 55 / 15 / 552:  55%|█████▌    | 552/1000 [46:56<38:05,  5.10s/it][Succeeded / Failed / Skipped / Total] 482 / 55 / 15 / 552:  55%|█████▌    | 553/1000 [46:57<37:57,  5.09s/it][Succeeded / Failed / Skipped / Total] 483 / 55 / 15 / 553:  55%|█████▌    | 553/1000 [46:57<37:57,  5.09s/it][Succeeded / Failed / Skipped / Total] 483 / 55 / 15 / 553:  55%|█████▌    | 554/1000 [46:59<37:49,  5.09s/it]Process an exception . --> Handles the given request header --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > onServerError ( RequestHeader [[request]] , Throwable exception ) { try { UsefulException [[usefulException]] = throwableToUsefulException ( exception ) ; logServerError ( [[request]] , [[usefulException]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[request]] , [[usefulException]] ) ; default : return onDevServerError ( [[request]] , [[usefulException]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > onServerError ( RequestHeader [[demand]] , Throwable exception ) { try { UsefulException [[typography]] = throwableToUsefulException ( exception ) ; logServerError ( [[demand]] , [[typography]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[demand]] , [[typography]] ) ; default : return onDevServerError ( [[demand]] , [[typography]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 548 ---------------------------------------------
Log a request . --> set orightwood --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader request , UsefulException [[usefulException]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[usefulException]] . id , request . method ( ) , request . uri ( ) ) , [[usefulException]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[nuta]] ( RequestHeader request , UsefulException [[wrightwood]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[wrightwood]] . id , request . method ( ) , request . uri ( ) ) , [[wrightwood]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 549 ---------------------------------------------
Starts a request asynchronously . --> Find heartbeats --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader [[request]] , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[bookshop]] ( RequestHeader [[demand]] , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[demand]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 550 ---------------------------------------------
OnProdServerError . --> Computes the ammunition of the given RequestHeader --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[ammunition]] ( RequestHeader [[demands]] , UsefulException [[excluding]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[excluding]] , [[demands]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 551 ---------------------------------------------
Executes a request . --> Subclasses should override this method to customize --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader [[request]] , String [[message]] ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[vera]] ( RequestHeader [[require]] , String [[emailed]] ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[require]] . method ( ) , [[require]] . uri ( ) , [[require]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[require]] . method ( ) , [[require]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[require]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 552 ---------------------------------------------
Creates a BuildDocHandler for a directory . --> Build doc scan --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File directory ) { FileRepository [[repo]] = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( [[repo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[cultivating]] ( File directory ) { FileRepository [[repay]] = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( [[repay]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 553 ---------------------------------------------
Render the playEditor . --> Gibt den Namen eccentricity function --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[eccentricity]] ( RequestHeader [[wondering]] , UsefulException [[relieved]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[relieved]] , [[wondering]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 554 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 484 / 55 / 15 / 554:  55%|█████▌    | 554/1000 [46:59<37:49,  5.09s/it][Succeeded / Failed / Skipped / Total] 484 / 55 / 15 / 554:  56%|█████▌    | 555/1000 [47:02<37:43,  5.09s/it][Succeeded / Failed / Skipped / Total] 485 / 55 / 15 / 555:  56%|█████▌    | 555/1000 [47:02<37:43,  5.09s/it][Succeeded / Failed / Skipped / Total] 485 / 55 / 15 / 555:  56%|█████▌    | 556/1000 [47:03<37:34,  5.08s/it][Succeeded / Failed / Skipped / Total] 486 / 55 / 15 / 556:  56%|█████▌    | 556/1000 [47:03<37:34,  5.08s/it][Succeeded / Failed / Skipped / Total] 486 / 55 / 15 / 556:  56%|█████▌    | 557/1000 [47:18<37:37,  5.10s/it][Succeeded / Failed / Skipped / Total] 487 / 55 / 15 / 557:  56%|█████▌    | 557/1000 [47:18<37:37,  5.10s/it][Succeeded / Failed / Skipped / Total] 487 / 55 / 15 / 557:  56%|█████▌    | 558/1000 [47:23<37:32,  5.10s/it][Succeeded / Failed / Skipped / Total] 488 / 55 / 15 / 558:  56%|█████▌    | 558/1000 [47:23<37:32,  5.10s/it][Succeeded / Failed / Skipped / Total] 488 / 55 / 15 / 558:  56%|█████▌    | 559/1000 [47:25<37:25,  5.09s/it][Succeeded / Failed / Skipped / Total] 489 / 55 / 15 / 559:  56%|█████▌    | 559/1000 [47:25<37:25,  5.09s/it][Succeeded / Failed / Skipped / Total] 489 / 55 / 15 / 559:  56%|█████▌    | 560/1000 [47:26<37:16,  5.08s/it][Succeeded / Failed / Skipped / Total] 490 / 55 / 15 / 560:  56%|█████▌    | 560/1000 [47:26<37:16,  5.08s/it][Succeeded / Failed / Skipped / Total] 490 / 55 / 15 / 560:  56%|█████▌    | 561/1000 [47:30<37:10,  5.08s/it][Succeeded / Failed / Skipped / Total] 491 / 55 / 15 / 561:  56%|█████▌    | 561/1000 [47:30<37:10,  5.08s/it][Succeeded / Failed / Skipped / Total] 491 / 55 / 15 / 561:  56%|█████▌    | 562/1000 [47:36<37:05,  5.08s/it][Succeeded / Failed / Skipped / Total] 492 / 55 / 15 / 562:  56%|█████▌    | 562/1000 [47:36<37:05,  5.08s/it][Succeeded / Failed / Skipped / Total] 492 / 55 / 15 / 562:  56%|█████▋    | 563/1000 [47:40<37:00,  5.08s/it][Succeeded / Failed / Skipped / Total] 493 / 55 / 15 / 563:  56%|█████▋    | 563/1000 [47:40<37:00,  5.08s/it][Succeeded / Failed / Skipped / Total] 493 / 55 / 15 / 563:  56%|█████▋    | 564/1000 [47:41<36:52,  5.07s/it]Gets an optional file . --> Taken from env --> Socre: 1.0

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[disorientated]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 555 ---------------------------------------------
Create a BuildDoc handler from a directory and jar file . --> Build doc handler . --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String base ) { return [[fromDirectoryAndJar]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[sí]] ( File directory , JarFile jarFile , String base ) { return [[sí]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 556 ---------------------------------------------
Create a new JPAConfig instance --> Gets JPAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String n1 , String [[u1]] , String [[n2]] , String [[u2]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , [[u1]] ) , new JPAConfig . PersistenceUnit ( [[n2]] , [[u2]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[et]] ( String n1 , String [[hard]] , String [[kine]] , String [[reproached]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , [[hard]] ) , new JPAConfig . PersistenceUnit ( [[kine]] , [[reproached]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 557 ---------------------------------------------
Consume data . --> Get vibrating --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer [[mat]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[mat]] ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[vibrating]] ( Materializer [[coaster]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[coaster]] ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 558 ---------------------------------------------
Create a BuildDocHandler from a jar file . --> Build doc handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String [[base]] ) { FileRepository repo = new JarRepository ( [[jarFile]] , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[elite]] ( JarFile [[menudo]] , String [[nucleus]] ) { FileRepository repo = new JarRepository ( [[menudo]] , Option . apply ( [[nucleus]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 559 ---------------------------------------------
Create HttpEntity from Content content . --> Get HttpEntity perrier --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String [[charset]] ) { String body ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[perrier]] ( Content [[jubilant]] , String [[crushing]] ) { String body ; if ( [[jubilant]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 560 ---------------------------------------------
Create a HttpEntity chunked . --> Get HttpEntity object --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > [[data]] , Optional < String > contentType ) { return new Chunked ( [[data]] . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[expects]] ( Source < ByteString , ? > [[dating]] , Optional < String > contentType ) { return new Chunked ( [[dating]] . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 561 ---------------------------------------------
Create a Result with the given status code and content . --> Create regulations --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] ) { return [[status]] ( [[status]] , [[content]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[regulations]] ( int [[prerequisite]] , JsonNode [[cheerful]] ) { return [[regulations]] ( [[regulations]] , [[cheerful]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 562 ---------------------------------------------
Sends a status message to the JSON response . --> Send the status message --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , JsonNode [[content]] , JsonEncoding [[encoding]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson ( [[content]] , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result status ( int status , JsonNode [[welcoming]] , JsonEncoding [[cava]] ) { if ( [[welcoming]] == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson ( [[welcoming]] , [[cava]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 563 ---------------------------------------------
Converts the string content to a HttpEntity . --> Creates a HttpEntity object --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String content , String [[charset]] ) { return new Strict ( ByteString . fromString ( content , [[charset]] ) , Optional . of ( "text/plain; charset=" + [[charset]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[ofher]] ( String content , String [[heralding]] ) { return new Strict ( ByteString . fromString ( content , [[heralding]] ) , Optional . of ( "text/plain; charset=" + [[heralding]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 564 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 494 / 55 / 15 / 564:  56%|█████▋    | 564/1000 [47:41<36:52,  5.07s/it][Succeeded / Failed / Skipped / Total] 494 / 55 / 15 / 564:  56%|█████▋    | 565/1000 [47:41<36:43,  5.07s/it][Succeeded / Failed / Skipped / Total] 494 / 55 / 16 / 565:  56%|█████▋    | 565/1000 [47:41<36:43,  5.07s/it][Succeeded / Failed / Skipped / Total] 494 / 55 / 16 / 565:  57%|█████▋    | 566/1000 [47:42<36:34,  5.06s/it][Succeeded / Failed / Skipped / Total] 495 / 55 / 16 / 566:  57%|█████▋    | 566/1000 [47:42<36:34,  5.06s/it][Succeeded / Failed / Skipped / Total] 495 / 55 / 16 / 566:  57%|█████▋    | 567/1000 [47:45<36:28,  5.05s/it][Succeeded / Failed / Skipped / Total] 496 / 55 / 16 / 567:  57%|█████▋    | 567/1000 [47:45<36:28,  5.05s/it][Succeeded / Failed / Skipped / Total] 496 / 55 / 16 / 567:  57%|█████▋    | 568/1000 [47:46<36:20,  5.05s/it][Succeeded / Failed / Skipped / Total] 497 / 55 / 16 / 568:  57%|█████▋    | 568/1000 [47:46<36:20,  5.05s/it][Succeeded / Failed / Skipped / Total] 497 / 55 / 16 / 568:  57%|█████▋    | 569/1000 [47:48<36:12,  5.04s/it][Succeeded / Failed / Skipped / Total] 498 / 55 / 16 / 569:  57%|█████▋    | 569/1000 [47:48<36:12,  5.04s/it][Succeeded / Failed / Skipped / Total] 498 / 55 / 16 / 569:  57%|█████▋    | 570/1000 [47:52<36:06,  5.04s/it][Succeeded / Failed / Skipped / Total] 499 / 55 / 16 / 570:  57%|█████▋    | 570/1000 [47:52<36:06,  5.04s/it][Succeeded / Failed / Skipped / Total] 499 / 55 / 16 / 570:  57%|█████▋    | 571/1000 [47:53<35:58,  5.03s/it][Succeeded / Failed / Skipped / Total] 500 / 55 / 16 / 571:  57%|█████▋    | 571/1000 [47:53<35:58,  5.03s/it][Succeeded / Failed / Skipped / Total] 500 / 55 / 16 / 571:  57%|█████▋    | 572/1000 [47:58<35:53,  5.03s/it][Succeeded / Failed / Skipped / Total] 501 / 55 / 16 / 572:  57%|█████▋    | 572/1000 [47:58<35:53,  5.03s/it][Succeeded / Failed / Skipped / Total] 501 / 55 / 16 / 572:  57%|█████▋    | 573/1000 [48:13<35:56,  5.05s/it][Succeeded / Failed / Skipped / Total] 502 / 55 / 16 / 573:  57%|█████▋    | 573/1000 [48:13<35:56,  5.05s/it][Succeeded / Failed / Skipped / Total] 502 / 55 / 16 / 573:  57%|█████▋    | 574/1000 [48:14<35:47,  5.04s/it]Create a Build doc handler from the given files . --> Build doc - related roths --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromResources]] ( File [ ] [[files]] , String [ ] baseDirs ) throws IOException { assert ( [[files]] . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ [[files]] . length ] ; List < JarFile > [[jarFiles]] = new ArrayList <> ( ) ; for ( int i = 0 ; i < [[files]] . length ; i ++ ) { File file = [[files]] [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler [[rothschilds]] ( File [ ] [[depot]] , String [ ] baseDirs ) throws IOException { assert ( [[depot]] . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ [[depot]] . length ] ; List < JarFile > [[tabloid]] = new ArrayList <> ( ) ; for ( int i = 0 ; i < [[depot]] . length ; i ++ ) { File file = [[depot]] [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 565 ---------------------------------------------
Returns user id . --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 566 ---------------------------------------------
Get the content status . --> Get the articles --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , File [[content]] ) { return [[status]] ( [[status]] , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[articles]] ( int status , File [[upbeat]] ) { return [[articles]] ( [[articles]] , [[upbeat]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 567 ---------------------------------------------
Sends a response message and reads the response . --> Get the necessity of the given content --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , InputStream content , long [[contentLength]] ) { return [[status]] ( [[status]] ) . sendInputStream ( content , [[contentLength]] ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result [[necessity]] ( int status , InputStream content , long [[mitzi]] ) { return [[necessity]] ( [[necessity]] ) . sendInputStream ( content , [[mitzi]] ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 568 ---------------------------------------------
Create a new Call . --> Call an exceptional method --> Socre: 1.0

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[exceptional]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 569 ---------------------------------------------
Call with fragment --> Create favouring service --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[favouring]] ( String [[excerpts]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[excerpts]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 570 ---------------------------------------------
Returns the absolute URL for the given request . --> Get the full path for a given request --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[nineveh]] ( Http . Request [[demanding]] ) { return [[nineveh]] ( [[demanding]] . secure ( ) , [[demanding]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 571 ---------------------------------------------
Create a Result for the given content . --> Get the grat addresses --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[status]] , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result [[stipulations]] ( int status , byte [ ] [[gratified]] ) { if ( [[gratified]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[stipulations]] , new HttpEntity . Strict ( ByteString . fromArray ( [[gratified]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 572 ---------------------------------------------
Gets the web socket url . --> Returns the conspired --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request [[request]] ) { return [[webSocketURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[conspired]] ( Http . Request [[demanding]] ) { return [[conspired]] ( [[demanding]] . secure ( ) , [[demanding]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 573 ---------------------------------------------
Create a new Lang . --> advocated method --> Socre: 1.0

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > [[candidates]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[candidates]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[advocated]] ( Collection < Lang > [[challengers]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[challengers]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 574 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 503 / 55 / 16 / 574:  57%|█████▋    | 574/1000 [48:14<35:47,  5.04s/it][Succeeded / Failed / Skipped / Total] 503 / 55 / 16 / 574:  57%|█████▊    | 575/1000 [48:20<35:43,  5.04s/it][Succeeded / Failed / Skipped / Total] 503 / 56 / 16 / 575:  57%|█████▊    | 575/1000 [48:20<35:43,  5.04s/it][Succeeded / Failed / Skipped / Total] 503 / 56 / 16 / 575:  58%|█████▊    | 576/1000 [48:21<35:35,  5.04s/it][Succeeded / Failed / Skipped / Total] 504 / 56 / 16 / 576:  58%|█████▊    | 576/1000 [48:21<35:35,  5.04s/it][Succeeded / Failed / Skipped / Total] 504 / 56 / 16 / 576:  58%|█████▊    | 577/1000 [48:23<35:28,  5.03s/it][Succeeded / Failed / Skipped / Total] 505 / 56 / 16 / 577:  58%|█████▊    | 577/1000 [48:23<35:28,  5.03s/it][Succeeded / Failed / Skipped / Total] 505 / 56 / 16 / 577:  58%|█████▊    | 578/1000 [48:30<35:24,  5.04s/it][Succeeded / Failed / Skipped / Total] 506 / 56 / 16 / 578:  58%|█████▊    | 578/1000 [48:30<35:24,  5.04s/it][Succeeded / Failed / Skipped / Total] 506 / 56 / 16 / 578:  58%|█████▊    | 579/1000 [48:33<35:18,  5.03s/it][Succeeded / Failed / Skipped / Total] 507 / 56 / 16 / 579:  58%|█████▊    | 579/1000 [48:33<35:18,  5.03s/it][Succeeded / Failed / Skipped / Total] 507 / 56 / 16 / 579:  58%|█████▊    | 580/1000 [48:36<35:12,  5.03s/it][Succeeded / Failed / Skipped / Total] 508 / 56 / 16 / 580:  58%|█████▊    | 580/1000 [48:36<35:12,  5.03s/it][Succeeded / Failed / Skipped / Total] 508 / 56 / 16 / 580:  58%|█████▊    | 581/1000 [48:45<35:09,  5.03s/it][Succeeded / Failed / Skipped / Total] 509 / 56 / 16 / 581:  58%|█████▊    | 581/1000 [48:45<35:09,  5.03s/it][Succeeded / Failed / Skipped / Total] 509 / 56 / 16 / 581:  58%|█████▊    | 582/1000 [48:54<35:07,  5.04s/it]Returns a new connection function . --> Return an AbstractFunction1 --> Socre: 1.0

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[block]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return [[block]] . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[clogging]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[nexus]] ) { try { return [[clogging]] . call ( [[nexus]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 575 ---------------------------------------------
Create a new A object from json --> [[[FAILED]]]

[[[[Adv]]]]: public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 576 ---------------------------------------------
Convert data object to JsonNode . --> Get the promoted data --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[promoted]] ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 577 ---------------------------------------------
Creates a new connection runnable . --> tamar connection --> Socre: 1.0

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[block]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[tamar]] ( final ConnectionRunnable [[prevent]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[prevent]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 578 ---------------------------------------------
Computes relative path from start to target path . --> Convenience method for Germane --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String [[startPath]] , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[germane]] ( String [[speer]] , String [[shitholes]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 579 ---------------------------------------------
Returns a canonical string of the given URL . --> Returns the campion string --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] [[urlPath]] = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String comp : [[urlPath]] ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( comp ) ; else [[canonical]] . pop ( ) ; } String [[prefixSep]] = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String [[trailingSep]] = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return [[prefixSep]] + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + [[trailingSep]] ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[campion]] ( String url ) { String [ ] [[reposition]] = toSegments ( url ) ; Stack < String > [[campion]] = new Stack <> ( ) ; for ( String comp : [[reposition]] ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[campion]] . empty ( ) && [[campion]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[campion]] . push ( comp ) ; else [[campion]] . pop ( ) ; } String [[around]] = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String [[samurai]] = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return [[around]] + [[campion]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + [[samurai]] ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 580 ---------------------------------------------
Parses a string into a JsonNode --> Get the free x --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[melodramatic]] ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 581 ---------------------------------------------
Gets displayable constraint . --> Displayable constraint --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > [[roadblock]] ) { return [[roadblock]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 582 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 510 / 56 / 16 / 582:  58%|█████▊    | 582/1000 [48:54<35:07,  5.04s/it][Succeeded / Failed / Skipped / Total] 510 / 56 / 16 / 582:  58%|█████▊    | 583/1000 [49:02<35:04,  5.05s/it][Succeeded / Failed / Skipped / Total] 511 / 56 / 16 / 583:  58%|█████▊    | 583/1000 [49:02<35:04,  5.05s/it][Succeeded / Failed / Skipped / Total] 511 / 56 / 16 / 583:  58%|█████▊    | 584/1000 [49:03<34:56,  5.04s/it][Succeeded / Failed / Skipped / Total] 512 / 56 / 16 / 584:  58%|█████▊    | 584/1000 [49:03<34:56,  5.04s/it][Succeeded / Failed / Skipped / Total] 512 / 56 / 16 / 584:  58%|█████▊    | 585/1000 [49:04<34:48,  5.03s/it][Succeeded / Failed / Skipped / Total] 513 / 56 / 16 / 585:  58%|█████▊    | 585/1000 [49:04<34:48,  5.03s/it][Succeeded / Failed / Skipped / Total] 513 / 56 / 16 / 585:  59%|█████▊    | 586/1000 [49:08<34:43,  5.03s/it][Succeeded / Failed / Skipped / Total] 514 / 56 / 16 / 586:  59%|█████▊    | 586/1000 [49:08<34:43,  5.03s/it][Succeeded / Failed / Skipped / Total] 514 / 56 / 16 / 586:  59%|█████▊    | 587/1000 [49:10<34:36,  5.03s/it][Succeeded / Failed / Skipped / Total] 515 / 56 / 16 / 587:  59%|█████▊    | 587/1000 [49:10<34:36,  5.03s/it][Succeeded / Failed / Skipped / Total] 515 / 56 / 16 / 587:  59%|█████▉    | 588/1000 [49:14<34:30,  5.02s/it][Succeeded / Failed / Skipped / Total] 516 / 56 / 16 / 588:  59%|█████▉    | 588/1000 [49:14<34:30,  5.02s/it][Succeeded / Failed / Skipped / Total] 516 / 56 / 16 / 588:  59%|█████▉    | 589/1000 [49:18<34:24,  5.02s/it]Add displayable constraint . --> erez from containment --> Socre: 1.0

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > [[constraint]] ) { final Display displayAnnotation = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[erez]] ( ConstraintDescriptor < ? > [[containment]] ) { final Display displayAnnotation = [[containment]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> [[containment]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 583 ---------------------------------------------
Returns a CompletionStage that covers the supplied stage . --> region restarts --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > stage , final long amount , final TimeUnit [[unit]] ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( [[unit]] , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( amount , [[unit]] ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[restarts]] ( final CompletionStage < A > stage , final long amount , final TimeUnit [[dependence]] ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( [[dependence]] , "Null unit" ) ; FiniteDuration [[tiempo]] = FiniteDuration . apply ( amount , [[dependence]] ) ; return toJava ( delegate . timeout ( [[tiempo]] , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 584 ---------------------------------------------
Parse CRON expressions . --> Method to get sugarman --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[sugarman]] ( String [[jailed]] ) { try { return new CronExpression ( [[jailed]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[jailed]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 585 ---------------------------------------------
Gets the cron interval . --> Creates cron expression --> Socre: 1.0

[[[[Adv]]]]: public static long cronInterval ( String [[cron]] , Date [[date]] ) { try { return new CronExpression ( [[cron]] ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long cronInterval ( String [[bionic]] , Date [[tuesday]] ) { try { return new CronExpression ( [[bionic]] ) . getNextInterval ( [[tuesday]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[bionic]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 586 ---------------------------------------------
Create a new AhcWSClient . --> generates an MhcWSClient --> Socre: 1.0

[[[[Adv]]]]: public static AhcWSClient [[create]] ( AhcWSClientConfig [[config]] , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( [[config]] , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient [[generates]] ( AhcWSClientConfig [[inconsistencies]] , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( [[inconsistencies]] , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 587 ---------------------------------------------
Create a Build doc handler from a directory and a jar file . --> Build doc handler fromDirectoryAndJar --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File [[directory]] , JarFile [[jarFile]] , String base , boolean [[fallbackToJar]] ) { FileRepository fileRepo = new FilesystemRepository ( [[directory]] ) ; FileRepository [[jarRepo]] = new JarRepository ( [[jarFile]] , Option . apply ( base ) ) ; FileRepository [[manualRepo]] ; if ( [[fallbackToJar]] ) { [[manualRepo]] = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , [[jarRepo]] } ) ; } else { [[manualRepo]] = fileRepo ; } return new DocumentationHandler ( [[manualRepo]] , [[jarRepo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File [[compendium]] , JarFile [[tattooed]] , String base , boolean [[yehuda]] ) { FileRepository fileRepo = new FilesystemRepository ( [[compendium]] ) ; FileRepository [[selflessness]] = new JarRepository ( [[tattooed]] , Option . apply ( base ) ) ; FileRepository [[akhtar]] ; if ( [[yehuda]] ) { [[akhtar]] = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , [[selflessness]] } ) ; } else { [[akhtar]] = fileRepo ; } return new DocumentationHandler ( [[akhtar]] , [[selflessness]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 588 ---------------------------------------------
Loads the application builder . --> Load an Guice ApplicationBuilder --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context [[context]] ) { return initialBuilder . in ( [[context]] . environment ( ) ) . loadConfig ( [[context]] . initialConfig ( ) ) . overrides ( overrides ( [[context]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[craftsman]] ( ApplicationLoader . Context [[setting]] ) { return initialBuilder . in ( [[setting]] . environment ( ) ) . loadConfig ( [[setting]] . initialConfig ( ) ) . overrides ( overrides ( [[setting]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 589 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 517 / 56 / 16 / 589:  59%|█████▉    | 589/1000 [49:18<34:24,  5.02s/it][Succeeded / Failed / Skipped / Total] 517 / 56 / 16 / 589:  59%|█████▉    | 590/1000 [49:22<34:18,  5.02s/it][Succeeded / Failed / Skipped / Total] 518 / 56 / 16 / 590:  59%|█████▉    | 590/1000 [49:22<34:18,  5.02s/it][Succeeded / Failed / Skipped / Total] 518 / 56 / 16 / 590:  59%|█████▉    | 591/1000 [49:26<34:12,  5.02s/it][Succeeded / Failed / Skipped / Total] 519 / 56 / 16 / 591:  59%|█████▉    | 591/1000 [49:26<34:12,  5.02s/it][Succeeded / Failed / Skipped / Total] 519 / 56 / 16 / 591:  59%|█████▉    | 592/1000 [49:34<34:09,  5.02s/it][Succeeded / Failed / Skipped / Total] 520 / 56 / 16 / 592:  59%|█████▉    | 592/1000 [49:34<34:09,  5.02s/it][Succeeded / Failed / Skipped / Total] 520 / 56 / 16 / 592:  59%|█████▉    | 593/1000 [49:42<34:07,  5.03s/it][Succeeded / Failed / Skipped / Total] 520 / 57 / 16 / 593:  59%|█████▉    | 593/1000 [49:42<34:07,  5.03s/it][Succeeded / Failed / Skipped / Total] 520 / 57 / 16 / 593:  59%|█████▉    | 594/1000 [49:43<33:58,  5.02s/it][Succeeded / Failed / Skipped / Total] 520 / 58 / 16 / 594:  59%|█████▉    | 594/1000 [49:43<33:58,  5.02s/it][Succeeded / Failed / Skipped / Total] 520 / 58 / 16 / 594:  60%|█████▉    | 595/1000 [49:48<33:54,  5.02s/it][Succeeded / Failed / Skipped / Total] 521 / 58 / 16 / 595:  60%|█████▉    | 595/1000 [49:48<33:54,  5.02s/it][Succeeded / Failed / Skipped / Total] 521 / 58 / 16 / 595:  60%|█████▉    | 596/1000 [49:59<33:52,  5.03s/it][Succeeded / Failed / Skipped / Total] 521 / 59 / 16 / 596:  60%|█████▉    | 596/1000 [49:59<33:52,  5.03s/it][Succeeded / Failed / Skipped / Total] 521 / 59 / 16 / 596:  60%|█████▉    | 597/1000 [50:00<33:45,  5.03s/it][Succeeded / Failed / Skipped / Total] 522 / 59 / 16 / 597:  60%|█████▉    | 597/1000 [50:00<33:45,  5.03s/it][Succeeded / Failed / Skipped / Total] 522 / 59 / 16 / 597:  60%|█████▉    | 598/1000 [50:02<33:38,  5.02s/it][Succeeded / Failed / Skipped / Total] 523 / 59 / 16 / 598:  60%|█████▉    | 598/1000 [50:02<33:38,  5.02s/it][Succeeded / Failed / Skipped / Total] 523 / 59 / 16 / 598:  60%|█████▉    | 599/1000 [50:03<33:30,  5.01s/it]Adds a session . --> add emphasis --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String [[key]] , String [[value]] ) { [[session]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[encounter]] ( String [[vitale]] , String [[emphasis]] ) { [[encounter]] ( ) . put ( [[vitale]] , [[emphasis]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 590 ---------------------------------------------
Gets the result from the request . --> AQUI method --> Socre: 1.0

[[[[Adv]]]]: public static Result [[TODO]] ( Request [[request]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[request]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result [[AQUI]] ( Request [[wondered]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[wondered]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 591 ---------------------------------------------
Set flash Method . --> Maps an invaluable string to an invaluable string --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String [[key]] , String [[value]] ) { [[flash]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[lightyear]] ( String [[necessity]] , String [[invaluable]] ) { [[lightyear]] ( ) . put ( [[necessity]] , [[invaluable]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 592 ---------------------------------------------
Parse a java . io . InputStream . --> Read the cauliflowers --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[cauliflowers]] ( java . io . InputStream [[clement]] ) { try { return mapper ( ) . readTree ( [[clement]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 593 ---------------------------------------------
Returns an annotation with the given instance . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 594 ---------------------------------------------
Returns the qualified with the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 595 ---------------------------------------------
Convert the provider to a Binding . --> Return null if unknown --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > to ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > to ( final Provider < ? extends T > [[shopkeepers]] ) { return underlying . to ( [[shopkeepers]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 596 ---------------------------------------------
Converts a supplier to a Binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 597 ---------------------------------------------
Converts the given key to a Binding . --> among momentous --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[among]] ( final BindingKey < ? extends T > [[momentous]] ) { return underlying . to ( [[momentous]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 598 ---------------------------------------------
Get all the list of all the availables --> Return all global Langs --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application [[app]] ) { play . api . i18n . Langs [[langs]] = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[availableLangs]] = Scala . asJava ( [[langs]] . availables ( ) ) ; return [[availableLangs]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[famed]] ( Application [[ipo]] ) { play . api . i18n . Langs [[forthat]] = [[ipo]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[stuffed]] = Scala . asJava ( [[forthat]] . availables ( ) ) ; return [[stuffed]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 599 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 524 / 59 / 16 / 599:  60%|█████▉    | 599/1000 [50:03<33:30,  5.01s/it][Succeeded / Failed / Skipped / Total] 524 / 59 / 16 / 599:  60%|██████    | 600/1000 [50:09<33:26,  5.02s/it][Succeeded / Failed / Skipped / Total] 525 / 59 / 16 / 600:  60%|██████    | 600/1000 [50:09<33:26,  5.02s/it][Succeeded / Failed / Skipped / Total] 525 / 59 / 16 / 600:  60%|██████    | 601/1000 [50:21<33:25,  5.03s/it][Succeeded / Failed / Skipped / Total] 526 / 59 / 16 / 601:  60%|██████    | 601/1000 [50:21<33:25,  5.03s/it][Succeeded / Failed / Skipped / Total] 526 / 59 / 16 / 601:  60%|██████    | 602/1000 [50:23<33:19,  5.02s/it][Succeeded / Failed / Skipped / Total] 527 / 59 / 16 / 602:  60%|██████    | 602/1000 [50:23<33:19,  5.02s/it][Succeeded / Failed / Skipped / Total] 527 / 59 / 16 / 602:  60%|██████    | 603/1000 [50:26<33:12,  5.02s/it][Succeeded / Failed / Skipped / Total] 528 / 59 / 16 / 603:  60%|██████    | 603/1000 [50:26<33:12,  5.02s/it][Succeeded / Failed / Skipped / Total] 528 / 59 / 16 / 603:  60%|██████    | 604/1000 [50:27<33:05,  5.01s/it][Succeeded / Failed / Skipped / Total] 529 / 59 / 16 / 604:  60%|██████    | 604/1000 [50:27<33:05,  5.01s/it][Succeeded / Failed / Skipped / Total] 529 / 59 / 16 / 604:  60%|██████    | 605/1000 [50:28<32:57,  5.01s/it][Succeeded / Failed / Skipped / Total] 530 / 59 / 16 / 605:  60%|██████    | 605/1000 [50:28<32:57,  5.01s/it][Succeeded / Failed / Skipped / Total] 530 / 59 / 16 / 605:  61%|██████    | 606/1000 [50:29<32:49,  5.00s/it][Succeeded / Failed / Skipped / Total] 531 / 59 / 16 / 606:  61%|██████    | 606/1000 [50:29<32:49,  5.00s/it][Succeeded / Failed / Skipped / Total] 531 / 59 / 16 / 606:  61%|██████    | 607/1000 [50:29<32:41,  4.99s/it]Checks if the class array is assignable to the class array . --> Compares class arrays and trifle --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] classArray , Class < ? > [ ] [[toClassArray]] , boolean [[autoboxing]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( [[toClassArray]] ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( [[toClassArray]] == null ) { [[toClassArray]] = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[isAssignable]] ( classArray [ i ] , [[toClassArray]] [ i ] , [[autoboxing]] ) == "False" != "False" ) { return "False" != "False" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[danforth]] ( Class < ? > [ ] classArray , Class < ? > [ ] [[baccala]] , boolean [[trifle]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( [[baccala]] ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( [[baccala]] == null ) { [[baccala]] = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[danforth]] ( classArray [ i ] , [[baccala]] [ i ] , [[trifle]] ) == "False" != "False" ) { return "False" != "False" ; } } return "[[Correct]]" == "[[Correct]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 600 ---------------------------------------------
Creates a new Lang object . --> preferreds globals --> Socre: 1.0

[[[[Adv]]]]: public static Lang preferred ( Application [[app]] , List < Lang > [[availableLangs]] ) { play . api . i18n . Langs [[langs]] = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > [[stream]] = [[availableLangs]] . stream ( ) ; List < play . api . i18n . Lang > [[langSeq]] = [[stream]] . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( [[langs]] . preferred ( Scala . toSeq ( [[langSeq]] ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang preferred ( Application [[mfa]] , List < Lang > [[gargling]] ) { play . api . i18n . Langs [[mummies]] = [[mfa]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > [[inputs]] = [[gargling]] . stream ( ) ; List < play . api . i18n . Lang > [[semi]] = [[inputs]] . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( [[mummies]] . preferred ( Scala . toSeq ( [[semi]] ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 601 ---------------------------------------------
Creates a new server for the given mode . --> Build mina inhibited --> Socre: 1.0

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode [[mode]] , int [[port]] , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . [[mode]] ( [[mode]] ) . http ( [[port]] ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[hijab]] ( Mode [[path]] , int [[mina]] , Function < BuiltInComponents , Router > [[inhibited]] ) { return new Builder ( ) . [[path]] ( [[path]] ) . http ( [[mina]] ) . build ( [[inhibited]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 602 ---------------------------------------------
Clean up evolutions . --> called onlookers --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database database , boolean autocommit , String [[schema]] ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , [[schema]] ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[onlookers]] ( Database database , boolean autocommit , String [[jumps]] ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , [[jumps]] ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 603 ---------------------------------------------
Creates the evolutions reader . --> region EvolutionsReader --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader forDefault ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[tyree]] . EvolutionsReader forDefault ( Evolution ... [[tyree]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[tyree]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 604 ---------------------------------------------
Loads a module loader --> Returns a new Guice application builder --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[drazen]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 605 ---------------------------------------------
Convert this provider to a provider . --> Get dominated by type --> Socre: 1.0

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[toProvider]] ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[dominated]] ( final Class < P > [[shopkeeper]] ) { return underlying . toProvider ( [[shopkeeper]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 606 ---------------------------------------------
Load the given modules --> Load an option --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... [[modules]] ) { return load ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... [[grouping]] ) { return load ( Guiceable . [[grouping]] ( [[grouping]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 607 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 532 / 59 / 16 / 607:  61%|██████    | 607/1000 [50:29<32:41,  4.99s/it][Succeeded / Failed / Skipped / Total] 532 / 59 / 16 / 607:  61%|██████    | 608/1000 [50:30<32:33,  4.98s/it][Succeeded / Failed / Skipped / Total] 533 / 59 / 16 / 608:  61%|██████    | 608/1000 [50:30<32:33,  4.98s/it][Succeeded / Failed / Skipped / Total] 533 / 59 / 16 / 608:  61%|██████    | 609/1000 [50:30<32:25,  4.98s/it][Succeeded / Failed / Skipped / Total] 533 / 60 / 16 / 609:  61%|██████    | 609/1000 [50:30<32:25,  4.98s/it][Succeeded / Failed / Skipped / Total] 533 / 60 / 16 / 609:  61%|██████    | 610/1000 [50:34<32:19,  4.97s/it][Succeeded / Failed / Skipped / Total] 534 / 60 / 16 / 610:  61%|██████    | 610/1000 [50:34<32:19,  4.97s/it][Succeeded / Failed / Skipped / Total] 534 / 60 / 16 / 610:  61%|██████    | 611/1000 [50:43<32:17,  4.98s/it][Succeeded / Failed / Skipped / Total] 535 / 60 / 16 / 611:  61%|██████    | 611/1000 [50:43<32:17,  4.98s/it][Succeeded / Failed / Skipped / Total] 535 / 60 / 16 / 611:  61%|██████    | 612/1000 [50:44<32:10,  4.98s/it][Succeeded / Failed / Skipped / Total] 535 / 61 / 16 / 612:  61%|██████    | 612/1000 [50:44<32:10,  4.98s/it][Succeeded / Failed / Skipped / Total] 535 / 61 / 16 / 612:  61%|██████▏   | 613/1000 [50:56<32:09,  4.99s/it][Succeeded / Failed / Skipped / Total] 535 / 62 / 16 / 613:  61%|██████▏   | 613/1000 [50:56<32:09,  4.99s/it][Succeeded / Failed / Skipped / Total] 535 / 62 / 16 / 613:  61%|██████▏   | 614/1000 [50:58<32:02,  4.98s/it][Succeeded / Failed / Skipped / Total] 536 / 62 / 16 / 614:  61%|██████▏   | 614/1000 [50:58<32:02,  4.98s/it][Succeeded / Failed / Skipped / Total] 536 / 62 / 16 / 614:  62%|██████▏   | 615/1000 [51:02<31:57,  4.98s/it][Succeeded / Failed / Skipped / Total] 537 / 62 / 16 / 615:  62%|██████▏   | 615/1000 [51:02<31:57,  4.98s/it][Succeeded / Failed / Skipped / Total] 537 / 62 / 16 / 615:  62%|██████▏   | 616/1000 [51:07<31:52,  4.98s/it]Loads the given Guiceable modules . --> Creates a new Guice ApplicationBuilder --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[tasked]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 608 ---------------------------------------------
Load a Guice application . --> Loads an application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Module ... [[modules]] ) { return load ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Module ... [[grouping]] ) { return load ( Guiceable . [[grouping]] ( [[grouping]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 609 ---------------------------------------------
Creates a builder for the Guice application . --> [[[FAILED]]]

[[[[Adv]]]]: protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 610 ---------------------------------------------
Load the given bindings . --> Returns a Guice ApplicationBuilder --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... bindings ) { return [[load]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[cargoes]] ( play . api . inject . Binding < ? > ... bindings ) { return [[cargoes]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 611 ---------------------------------------------
Creates a new evolutions reader . --> region EvolutionsReader --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[jock]] . EvolutionsReader [[impressionists]] ( Map < String , List < Evolution > > [[jock]] ) { return new SimpleEvolutionsReader ( [[jock]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 612 ---------------------------------------------
Returns a new application configuration builder . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 613 ---------------------------------------------
Adds a new constraint validator . --> [[[FAILED]]]

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 614 ---------------------------------------------
Encodes a cookie . --> transcoder to group --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; [[encode]] ( buf , [[cookie]] ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[transcoder]] ( Cookie [[croissants]] ) { if ( [[croissants]] == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; [[transcoder]] ( buf , [[croissants]] ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 615 ---------------------------------------------
Removes the given EntityManager . --> Fuegt ein --> Socre: 1.0

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager [[em]] , boolean [[threadLocalFallback]] ) { Deque < EntityManager > [[ems]] = this . emStack ( [[threadLocalFallback]] ) ; if ( [[em]] != null ) { [[ems]] . push ( [[em]] ) ; } else { if ( [[ems]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[ems]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[belen]] ( EntityManager [[magnetism]] , boolean [[smilin]] ) { Deque < EntityManager > [[ssu]] = this . emStack ( [[smilin]] ) ; if ( [[magnetism]] != null ) { [[ssu]] . push ( [[magnetism]] ) ; } else { if ( [[ssu]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[ssu]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 616 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 538 / 62 / 16 / 616:  62%|██████▏   | 616/1000 [51:07<31:52,  4.98s/it][Succeeded / Failed / Skipped / Total] 538 / 62 / 16 / 616:  62%|██████▏   | 617/1000 [51:09<31:45,  4.98s/it][Succeeded / Failed / Skipped / Total] 539 / 62 / 16 / 617:  62%|██████▏   | 617/1000 [51:09<31:45,  4.98s/it][Succeeded / Failed / Skipped / Total] 539 / 62 / 16 / 617:  62%|██████▏   | 618/1000 [51:14<31:40,  4.98s/it][Succeeded / Failed / Skipped / Total] 540 / 62 / 16 / 618:  62%|██████▏   | 618/1000 [51:14<31:40,  4.98s/it][Succeeded / Failed / Skipped / Total] 540 / 62 / 16 / 618:  62%|██████▏   | 619/1000 [51:19<31:35,  4.98s/it][Succeeded / Failed / Skipped / Total] 541 / 62 / 16 / 619:  62%|██████▏   | 619/1000 [51:19<31:35,  4.98s/it][Succeeded / Failed / Skipped / Total] 541 / 62 / 16 / 619:  62%|██████▏   | 620/1000 [51:22<31:29,  4.97s/it][Succeeded / Failed / Skipped / Total] 542 / 62 / 16 / 620:  62%|██████▏   | 620/1000 [51:22<31:29,  4.97s/it][Succeeded / Failed / Skipped / Total] 542 / 62 / 16 / 620:  62%|██████▏   | 621/1000 [51:27<31:24,  4.97s/it][Succeeded / Failed / Skipped / Total] 543 / 62 / 16 / 621:  62%|██████▏   | 621/1000 [51:27<31:24,  4.97s/it][Succeeded / Failed / Skipped / Total] 543 / 62 / 16 / 621:  62%|██████▏   | 622/1000 [51:30<31:17,  4.97s/it][Succeeded / Failed / Skipped / Total] 544 / 62 / 16 / 622:  62%|██████▏   | 622/1000 [51:30<31:17,  4.97s/it][Succeeded / Failed / Skipped / Total] 544 / 62 / 16 / 622:  62%|██████▏   | 623/1000 [51:34<31:12,  4.97s/it][Succeeded / Failed / Skipped / Total] 545 / 62 / 16 / 623:  62%|██████▏   | 623/1000 [51:34<31:12,  4.97s/it]Create a new actor ref --> Aunior of Away --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , [[Out]] > Flow < [[In]] , [[Out]] , ? > actorRef ( Function < ActorRef , Props > [[props]] , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < [[In]] , [[Out]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return [[props]] . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < [[Throughout]] , [[Away]] > Flow < [[Throughout]] , [[Away]] , ? > actorRef ( Function < ActorRef , Props > [[junior]] , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < [[Throughout]] , [[Away]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return [[junior]] . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 617 ---------------------------------------------
Create a java . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > [[implementation]] ) { return underlying . to ( [[implementation]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[on]] ( final Class < ? extends T > [[attaining]] ) { return underlying . to ( [[attaining]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 618 ---------------------------------------------
Fill the form with the given value . --> fill the given prized --> Socre: 1.0

[[[[Adv]]]]: public Form < T > fill ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > fill ( T [[prized]] ) { if ( [[prized]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[prized]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 619 ---------------------------------------------
Finds the merge strategy with the given Flow . --> Gets Storage Storage --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , [[FlowIn]] , [[Out]] > Flow < [[In]] , [[Out]] , ? > bypassWith ( Flow < [[In]] , F . Either < [[FlowIn]] , [[Out]] > , ? > [[splitter]] , Graph < UniformFanInShape < [[Out]] , [[Out]] > , ? > [[mergeStrategy]] , Flow < [[FlowIn]] , [[Out]] , ? > flow ) { return [[splitter]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < [[FlowIn]] , [[Out]] > , [[Out]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < [[Toward]] , [[pumpin]] , [[Apart]] > Flow < [[Toward]] , [[Apart]] , ? > bypassWith ( Flow < [[Toward]] , F . Either < [[pumpin]] , [[Apart]] > , ? > [[grate]] , Graph < UniformFanInShape < [[Apart]] , [[Apart]] > , ? > [[pratt]] , Flow < [[pumpin]] , [[Apart]] , ? > flow ) { return [[grate]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < [[pumpin]] , [[Apart]] > , [[Apart]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 620 ---------------------------------------------
Converts an array of arguments into a list . --> Converts an array of Objects into a list of Objects --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > [[converted]] = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[converted]] ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[yard]] ( Object [ ] [[lawsuits]] ) { if ( [[lawsuits]] == null ) { return Collections . emptyList ( ) ; } List < Object > [[makeover]] = Arrays . stream ( [[lawsuits]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[makeover]] ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 621 ---------------------------------------------
Returns the value of the given key . --> assess . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[assess]] ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 622 ---------------------------------------------
Fill the form with the specified value . --> Create a new DynamicForm --> Socre: 1.0

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[accomplish]] ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 623 ---------------------------------------------
Parse the given string into the given type . --> Build a tones from text --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[tones]] > [[tones]] parse ( String text , Class < [[tones]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 624 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 546 / 62 / 16 / 624:  62%|██████▏   | 624/1000 [51:34<31:04,  4.96s/it][Succeeded / Failed / Skipped / Total] 546 / 62 / 16 / 624:  62%|██████▎   | 625/1000 [51:35<30:57,  4.95s/it][Succeeded / Failed / Skipped / Total] 547 / 62 / 16 / 625:  62%|██████▎   | 625/1000 [51:35<30:57,  4.95s/it][Succeeded / Failed / Skipped / Total] 548 / 62 / 16 / 626:  63%|██████▎   | 626/1000 [51:36<30:49,  4.95s/it][Succeeded / Failed / Skipped / Total] 548 / 62 / 16 / 626:  63%|██████▎   | 627/1000 [51:36<30:42,  4.94s/it][Succeeded / Failed / Skipped / Total] 549 / 62 / 16 / 627:  63%|██████▎   | 627/1000 [51:36<30:42,  4.94s/it][Succeeded / Failed / Skipped / Total] 550 / 62 / 16 / 628:  63%|██████▎   | 628/1000 [51:37<30:35,  4.93s/it][Succeeded / Failed / Skipped / Total] 550 / 62 / 16 / 628:  63%|██████▎   | 629/1000 [51:40<30:28,  4.93s/it][Succeeded / Failed / Skipped / Total] 551 / 62 / 16 / 629:  63%|██████▎   | 629/1000 [51:40<30:28,  4.93s/it][Succeeded / Failed / Skipped / Total] 552 / 62 / 16 / 630:  63%|██████▎   | 630/1000 [51:48<30:25,  4.93s/it][Succeeded / Failed / Skipped / Total] 552 / 62 / 16 / 630:  63%|██████▎   | 631/1000 [51:51<30:19,  4.93s/it][Succeeded / Failed / Skipped / Total] 552 / 63 / 16 / 631:  63%|██████▎   | 631/1000 [51:51<30:19,  4.93s/it][Succeeded / Failed / Skipped / Total] 552 / 63 / 16 / 631:  63%|██████▎   | 632/1000 [51:56<30:14,  4.93s/it]Returns the error list . --> returns empty list --> Socre: 1.0

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[asshole]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 625 ---------------------------------------------
Print T to string --> Print a Wiring object --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Wiring]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Wiring]] . class ) ) { return conversion . convert ( t , [[Wiring]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 626 ---------------------------------------------
Parse a string into an object . --> Returns zillion for the given text . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[zillion]] > [[zillion]] parse ( Field field , String text ) { return ( [[zillion]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 627 ---------------------------------------------
Return the bypass with the given flow . --> Create a shysters view --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , [[FlowIn]] , [[Out]] > Flow < [[In]] , [[Out]] , ? > [[bypassWith]] ( Function < [[In]] , F . Either < [[FlowIn]] , [[Out]] > > splitter , Flow < [[FlowIn]] , [[Out]] , ? > [[flow]] ) { return [[bypassWith]] ( Flow . < [[In]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[flow]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < [[Travers]] , [[sippin]] , [[Foreign]] > Flow < [[Travers]] , [[Foreign]] , ? > [[shysters]] ( Function < [[Travers]] , F . Either < [[sippin]] , [[Foreign]] > > splitter , Flow < [[sippin]] , [[Foreign]] , ? > [[flux]] ) { return [[shysters]] ( Flow . < [[Travers]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[flux]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 628 ---------------------------------------------
Registers an optional type . --> Registers a source type . --> Socre: 1.0

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor [[targetType]] ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor [[celia]] ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 629 ---------------------------------------------
Print a type descriptor . --> Print an Ropes object --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[Ropes]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[Ropes]] . class ) ) ) { return ( [[Ropes]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[Ropes]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[Ropes]] . class ) ) { return conversion . convert ( t , [[Ropes]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 630 ---------------------------------------------
Returns a JSON representation of the given language . --> Get all messages from burdensome --> Socre: 1.0

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang [[lang]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[messages]] = new ArrayList <> ( ) ; if ( messagesApi != null && [[lang]] != null ) { final List < String > [[reversedMessages]] = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( [[reversedMessages]] ) ; [[messages]] . add ( messagesApi . get ( [[lang]] , [[reversedMessages]] , translateMsgArg ( error . arguments ( ) , messagesApi , [[lang]] ) ) ) ; } else { [[messages]] . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , [[messages]] ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[deviation]] ( Lang [[burdensome]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[email]] = new ArrayList <> ( ) ; if ( messagesApi != null && [[burdensome]] != null ) { final List < String > [[casual]] = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( [[casual]] ) ; [[email]] . add ( messagesApi . get ( [[burdensome]] , [[casual]] , translateMsgArg ( error . arguments ( ) , messagesApi , [[burdensome]] ) ) ) ; } else { [[email]] . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , [[email]] ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 631 ---------------------------------------------
Print t . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 632 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 553 / 63 / 16 / 632:  63%|██████▎   | 632/1000 [51:56<30:14,  4.93s/it][Succeeded / Failed / Skipped / Total] 553 / 63 / 16 / 632:  63%|██████▎   | 633/1000 [51:56<30:07,  4.92s/it][Succeeded / Failed / Skipped / Total] 554 / 63 / 16 / 633:  63%|██████▎   | 633/1000 [51:56<30:07,  4.92s/it][Succeeded / Failed / Skipped / Total] 554 / 63 / 16 / 633:  63%|██████▎   | 634/1000 [52:14<30:09,  4.94s/it][Succeeded / Failed / Skipped / Total] 555 / 63 / 16 / 634:  63%|██████▎   | 634/1000 [52:14<30:09,  4.94s/it][Succeeded / Failed / Skipped / Total] 555 / 63 / 16 / 634:  64%|██████▎   | 635/1000 [52:16<30:02,  4.94s/it][Succeeded / Failed / Skipped / Total] 556 / 63 / 16 / 635:  64%|██████▎   | 635/1000 [52:16<30:02,  4.94s/it][Succeeded / Failed / Skipped / Total] 556 / 63 / 16 / 635:  64%|██████▎   | 636/1000 [52:16<29:55,  4.93s/it][Succeeded / Failed / Skipped / Total] 556 / 63 / 17 / 636:  64%|██████▎   | 636/1000 [52:16<29:55,  4.93s/it][Succeeded / Failed / Skipped / Total] 556 / 63 / 17 / 636:  64%|██████▎   | 637/1000 [52:23<29:51,  4.94s/it][Succeeded / Failed / Skipped / Total] 557 / 63 / 17 / 637:  64%|██████▎   | 637/1000 [52:23<29:51,  4.94s/it][Succeeded / Failed / Skipped / Total] 557 / 63 / 17 / 637:  64%|██████▍   | 638/1000 [52:25<29:44,  4.93s/it][Succeeded / Failed / Skipped / Total] 558 / 63 / 17 / 638:  64%|██████▍   | 638/1000 [52:25<29:44,  4.93s/it][Succeeded / Failed / Skipped / Total] 558 / 63 / 17 / 638:  64%|██████▍   | 639/1000 [52:27<29:37,  4.93s/it]Returns the current emStack . --> Generates a new Deque instance --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean [[threadLocalFallback]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[emsObject]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[emsObject]] != null ) { return ( Deque < EntityManager > ) [[emsObject]] ; } else { Deque < EntityManager > [[ems]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[ems]] ) ; return [[ems]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[barish]] ( boolean [[menus]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[wormy]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[wormy]] != null ) { return ( Deque < EntityManager > ) [[wormy]] ; } else { Deque < EntityManager > [[ssc]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[ssc]] ) ; return [[ssc]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 633 ---------------------------------------------
Selects nodes . --> Returns the brinkmann of the given path --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object [[node]] ) { return [[selectNodes]] ( path , [[node]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[brinkmann]] ( String path , Object [[metastasis]] ) { return [[brinkmann]] ( path , [[metastasis]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 634 ---------------------------------------------
Encode the cookie . --> keyed by oreos --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[name]] = [[cookie]] . name ( ) ; final String [[value]] = [[cookie]] . value ( ) != null ? [[cookie]] . value ( ) : "" ; validateCookie ( [[name]] , [[value]] ) ; StringBuilder [[buf]] = new StringBuilder ( ) ; if ( [[cookie]] . wrap ( ) ) { addQuoted ( [[buf]] , [[name]] , [[value]] ) ; } else { add ( [[buf]] , [[name]] , [[value]] ) ; } if ( [[cookie]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( [[buf]] , CookieHeaderNames . MAX_AGE , [[cookie]] . maxAge ( ) ) ; Date expires = [[cookie]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String [[keyed]] ( Cookie [[oreos]] ) { if ( [[oreos]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[rendezvous]] = [[oreos]] . name ( ) ; final String [[extent]] = [[oreos]] . value ( ) != null ? [[oreos]] . value ( ) : "" ; validateCookie ( [[rendezvous]] , [[extent]] ) ; StringBuilder [[pluto]] = new StringBuilder ( ) ; if ( [[oreos]] . wrap ( ) ) { addQuoted ( [[pluto]] , [[rendezvous]] , [[extent]] ) ; } else { add ( [[pluto]] , [[rendezvous]] , [[extent]] ) ; } if ( [[oreos]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( [[pluto]] , CookieHeaderNames . MAX_AGE , [[oreos]] . maxAge ( ) ) ; Date expires = [[oreos]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 635 ---------------------------------------------
Get the throwableToUsefulException . --> Return throwableToUsefulException --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[só]] ( final Throwable [[babylonian]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[babylonian]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 636 ---------------------------------------------
Return a MappedWebSocketAcceptor --> [[[SKIPPED]]]

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 637 ---------------------------------------------
Gets varargs . --> Get the producer --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[cmb]] ( T ... [[pavilion]] ) { return toSeq ( [[pavilion]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 638 ---------------------------------------------
Create a scala . --> Get the given relationship --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] [[array]] ) { return [[toSeq]] ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[relationship]] ( T [ ] [[kiosk]] ) { return [[relationship]] ( java . util . Arrays . asList ( [[kiosk]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 639 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 559 / 63 / 17 / 639:  64%|██████▍   | 639/1000 [52:27<29:37,  4.93s/it][Succeeded / Failed / Skipped / Total] 559 / 63 / 17 / 639:  64%|██████▍   | 640/1000 [52:28<29:31,  4.92s/it][Succeeded / Failed / Skipped / Total] 560 / 63 / 17 / 640:  64%|██████▍   | 640/1000 [52:28<29:31,  4.92s/it][Succeeded / Failed / Skipped / Total] 560 / 63 / 17 / 640:  64%|██████▍   | 641/1000 [52:42<29:31,  4.93s/it][Succeeded / Failed / Skipped / Total] 561 / 63 / 17 / 641:  64%|██████▍   | 641/1000 [52:42<29:31,  4.93s/it][Succeeded / Failed / Skipped / Total] 561 / 63 / 17 / 641:  64%|██████▍   | 642/1000 [52:57<29:32,  4.95s/it][Succeeded / Failed / Skipped / Total] 562 / 63 / 17 / 642:  64%|██████▍   | 642/1000 [52:57<29:32,  4.95s/it][Succeeded / Failed / Skipped / Total] 562 / 63 / 17 / 642:  64%|██████▍   | 643/1000 [53:00<29:25,  4.95s/it]Accepts the given result . --> Mrook an operation --> Socre: 1.0

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader [[request]] ) { return f . apply ( [[request]] ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > [[flow]] = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( [[flow]] ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[krook]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[krook]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader [[calling]] ) { return f . apply ( [[calling]] ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > [[flooding]] = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( [[flooding]] ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 640 ---------------------------------------------
Get the cost of a class . --> mainlander method --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] [[srcArgs]] , final Executable [[executable]] ) { final Class < ? > [ ] [[destArgs]] = [[executable]] . getParameterTypes ( ) ; final boolean [[isVarArgs]] = [[executable]] . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[mainlander]] ( final Class < ? > [ ] [[ruso]] , final Executable [[bing]] ) { final Class < ? > [ ] [[modernity]] = [[bing]] . getParameterTypes ( ) ; final boolean [[whiteness]] = [[bing]] . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 641 ---------------------------------------------
Returns true if the given object is accessible . --> Checks if the given object is a meaningfulful --> Socre: 1.0

[[[[Adv]]]]: static boolean [[setAccessibleWorkaround]] ( final AccessibleObject [[o]] ) { if ( [[o]] == null || [[o]] . isAccessible ( ) ) { return "[[False]]" != "[[False]]" ; } final Member m = ( Member ) [[o]] ; if ( ! [[o]] . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { [[o]] . setAccessible ( "[[True]]" == "[[True]]" ) ; return "[[True]]" == "[[True]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean [[studied]] ( final AccessibleObject [[to]] ) { if ( [[to]] == null || [[to]] . isAccessible ( ) ) { return "[[Faked]]" != "[[Faked]]" ; } final Member m = ( Member ) [[to]] ; if ( ! [[to]] . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { [[to]] . setAccessible ( "[[Meaningful]]" == "[[Meaningful]]" ) ; return "[[Meaningful]]" == "[[Meaningful]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 642 ---------------------------------------------
Convert java . util . List to Java converters . --> Returns the bet image --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[betrayed]] ( java . util . List < T > [[listing]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[listing]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 643 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 563 / 63 / 17 / 643:  64%|██████▍   | 643/1000 [53:00<29:25,  4.95s/it][Succeeded / Failed / Skipped / Total] 563 / 63 / 17 / 643:  64%|██████▍   | 644/1000 [53:01<29:18,  4.94s/it][Succeeded / Failed / Skipped / Total] 564 / 63 / 17 / 644:  64%|██████▍   | 644/1000 [53:01<29:18,  4.94s/it][Succeeded / Failed / Skipped / Total] 564 / 63 / 17 / 644:  64%|██████▍   | 645/1000 [53:06<29:13,  4.94s/it][Succeeded / Failed / Skipped / Total] 565 / 63 / 17 / 645:  64%|██████▍   | 645/1000 [53:06<29:13,  4.94s/it][Succeeded / Failed / Skipped / Total] 565 / 63 / 17 / 645:  65%|██████▍   | 646/1000 [53:08<29:07,  4.94s/it][Succeeded / Failed / Skipped / Total] 566 / 63 / 17 / 646:  65%|██████▍   | 646/1000 [53:08<29:07,  4.94s/it][Succeeded / Failed / Skipped / Total] 566 / 63 / 17 / 646:  65%|██████▍   | 647/1000 [53:08<28:59,  4.93s/it][Succeeded / Failed / Skipped / Total] 567 / 63 / 17 / 647:  65%|██████▍   | 647/1000 [53:08<28:59,  4.93s/it][Succeeded / Failed / Skipped / Total] 567 / 63 / 17 / 647:  65%|██████▍   | 648/1000 [53:14<28:55,  4.93s/it]Registers the given annotations . --> A convenience method for creating a Harrelson --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Annotation]] , T > [[Formatters]] register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Annotation]] > [[annotationType]] = ( Class < ? extends [[Annotation]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { return ( [[sourceType]] . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object [[source]] , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { final A a = ( A ) [[sourceType]] . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) [[source]] , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , targetType , [[source]] , ex ) ; } } public String toString ( ) { return "@" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object [[source]] , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) [[source]] , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , targetType , [[source]] , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Gadgets]] , T > [[Harrelson]] register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Gadgets]] > [[fritter]] = ( Class < ? extends [[Gadgets]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor [[polemic]] , TypeDescriptor targetType ) { return ( [[polemic]] . getAnnotation ( [[fritter]] ) != null ) ; } public Object convert ( Object [[beginnings]] , TypeDescriptor [[polemic]] , TypeDescriptor targetType ) { final A a = ( A ) [[polemic]] . getAnnotation ( [[fritter]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) [[beginnings]] , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[polemic]] , targetType , [[beginnings]] , ex ) ; } } public String toString ( ) { return "@" + [[fritter]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor [[polemic]] , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[fritter]] ) != null ) ; } public Object convert ( Object [[beginnings]] , TypeDescriptor [[polemic]] , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( [[fritter]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) [[beginnings]] , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[polemic]] , targetType , [[beginnings]] , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[fritter]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 644 ---------------------------------------------
Get the value at the specified key . --> Returns a string representation of a list item --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String [[key]] , Object ... [[args]] ) { return messagesApi . get ( lang , [[key]] , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[into]] ( String [[essential]] , Object ... [[bubby]] ) { return messagesApi . get ( lang , [[essential]] , [[bubby]] ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 645 ---------------------------------------------
Gets the message at the provided keys . --> returns a crucial --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( List < String > [[keys]] , Object ... [[args]] ) { return messagesApi . get ( lang , [[keys]] , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String [[circa]] ( List < String > [[crucial]] , Object ... [[scariest]] ) { return messagesApi . get ( lang , [[crucial]] , [[scariest]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 646 ---------------------------------------------
Gets theimitive promotion cost . --> Calculates float cost --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[roxanne]] ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 647 ---------------------------------------------
quick sort . --> morph a morphin --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int index , int [[lo]] , int [[hi]] , Comparator [[cmp]] ) { chooseComparer ( index , [[cmp]] ) ; super . quickSort ( [[lo]] , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[morphin]] ( int index , int [[yung]] , int [[yay]] , Comparator [[ppk]] ) { chooseComparer ( index , [[ppk]] ) ; super . quickSort ( [[yung]] , [[yay]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 648 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 568 / 63 / 17 / 648:  65%|██████▍   | 648/1000 [53:14<28:55,  4.93s/it][Succeeded / Failed / Skipped / Total] 568 / 63 / 17 / 648:  65%|██████▍   | 649/1000 [53:15<28:48,  4.92s/it][Succeeded / Failed / Skipped / Total] 569 / 63 / 17 / 649:  65%|██████▍   | 649/1000 [53:15<28:48,  4.92s/it][Succeeded / Failed / Skipped / Total] 569 / 63 / 17 / 649:  65%|██████▌   | 650/1000 [53:16<28:41,  4.92s/it][Succeeded / Failed / Skipped / Total] 570 / 63 / 17 / 650:  65%|██████▌   | 650/1000 [53:16<28:41,  4.92s/it][Succeeded / Failed / Skipped / Total] 570 / 63 / 17 / 650:  65%|██████▌   | 651/1000 [53:16<28:33,  4.91s/it][Succeeded / Failed / Skipped / Total] 570 / 63 / 18 / 651:  65%|██████▌   | 651/1000 [53:16<28:33,  4.91s/it][Succeeded / Failed / Skipped / Total] 570 / 63 / 18 / 651:  65%|██████▌   | 652/1000 [53:17<28:26,  4.90s/it][Succeeded / Failed / Skipped / Total] 571 / 63 / 18 / 652:  65%|██████▌   | 652/1000 [53:17<28:26,  4.90s/it][Succeeded / Failed / Skipped / Total] 571 / 63 / 18 / 652:  65%|██████▌   | 653/1000 [53:21<28:21,  4.90s/it][Succeeded / Failed / Skipped / Total] 572 / 63 / 18 / 653:  65%|██████▌   | 653/1000 [53:21<28:21,  4.90s/it][Succeeded / Failed / Skipped / Total] 572 / 63 / 18 / 653:  65%|██████▌   | 654/1000 [53:21<28:13,  4.90s/it][Succeeded / Failed / Skipped / Total] 573 / 63 / 18 / 654:  65%|██████▌   | 654/1000 [53:21<28:13,  4.90s/it][Succeeded / Failed / Skipped / Total] 573 / 63 / 18 / 654:  66%|██████▌   | 655/1000 [53:25<28:08,  4.89s/it]Create a database . --> turkey methods --> Socre: 1.0

[[[[Adv]]]]: public static Database [[createFrom]] ( String driver , String [[url]] , Map < String , ? extends Object > [[config]] ) { return [[createFrom]] ( "default" , driver , [[url]] , [[config]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[turkey]] ( String driver , String [[email]] , Map < String , ? extends Object > [[keegan]] ) { return [[turkey]] ( "default" , driver , [[email]] , [[keegan]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 649 ---------------------------------------------
Visits a Type and cast to . --> Set the rend method --> Socre: 1.0

[[[[Adv]]]]: public void [[cast_numeric]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void [[rend]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[rend]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[rend]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[rend]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 650 ---------------------------------------------
Loads an argument at the given index . --> trol an index --> Socre: 1.0

[[[[Adv]]]]: public void [[load_arg]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[trollop]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 651 ---------------------------------------------
Emits a field . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 652 ---------------------------------------------
Merges the Comparator with the specified index --> This method unsociable method --> Socre: 1.0

[[[[Adv]]]]: public void [[mergeSort]] ( int [[index]] , int [[lo]] , int hi , Comparator [[cmp]] ) { chooseComparer ( [[index]] , [[cmp]] ) ; super . mergeSort ( [[lo]] , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[unsociable]] ( int [[pegged]] , int [[zhao]] , int hi , Comparator [[mta]] ) { chooseComparer ( [[pegged]] , [[mta]] ) ; super . mergeSort ( [[zhao]] , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 653 ---------------------------------------------
Validates the primitive type . --> Set blokes --> Socre: 1.0

[[[[Adv]]]]: public void [[zero_or_null]] ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { switch ( [[type]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[brigitta]] ( Type [[blokes]] ) { if ( TypeUtils . isPrimitive ( [[blokes]] ) ) { switch ( [[blokes]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 654 ---------------------------------------------
Unboxs a type . --> Mark typing as nibbling --> Socre: 1.0

[[[[Adv]]]]: public void [[unbox_or_zero]] ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { if ( [[type]] != Type . VOID_TYPE ) { Label [[nonNull]] = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( [[nonNull]] ) ; pop ( ) ; zero_or_null ( [[type]] ) ; goTo ( end ) ; mark ( [[nonNull]] ) ; unbox ( [[type]] ) ; mark ( end ) ; } } else { checkcast ( [[type]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void [[nibbling]] ( Type [[typing]] ) { if ( TypeUtils . isPrimitive ( [[typing]] ) ) { if ( [[typing]] != Type . VOID_TYPE ) { Label [[slogans]] = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( [[slogans]] ) ; pop ( ) ; zero_or_null ( [[typing]] ) ; goTo ( end ) ; mark ( [[slogans]] ) ; unbox ( [[typing]] ) ; mark ( end ) ; } } else { checkcast ( [[typing]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 655 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 574 / 63 / 18 / 655:  66%|██████▌   | 655/1000 [53:25<28:08,  4.89s/it][Succeeded / Failed / Skipped / Total] 574 / 63 / 18 / 655:  66%|██████▌   | 656/1000 [53:35<28:06,  4.90s/it][Succeeded / Failed / Skipped / Total] 575 / 63 / 18 / 656:  66%|██████▌   | 656/1000 [53:35<28:06,  4.90s/it][Succeeded / Failed / Skipped / Total] 575 / 63 / 18 / 656:  66%|██████▌   | 657/1000 [53:38<28:00,  4.90s/it][Succeeded / Failed / Skipped / Total] 576 / 63 / 18 / 657:  66%|██████▌   | 657/1000 [53:38<28:00,  4.90s/it][Succeeded / Failed / Skipped / Total] 576 / 63 / 18 / 657:  66%|██████▌   | 658/1000 [53:42<27:54,  4.90s/it][Succeeded / Failed / Skipped / Total] 577 / 63 / 18 / 658:  66%|██████▌   | 658/1000 [53:42<27:54,  4.90s/it][Succeeded / Failed / Skipped / Total] 577 / 63 / 18 / 658:  66%|██████▌   | 659/1000 [53:47<27:50,  4.90s/it][Succeeded / Failed / Skipped / Total] 578 / 63 / 18 / 659:  66%|██████▌   | 659/1000 [53:47<27:50,  4.90s/it][Succeeded / Failed / Skipped / Total] 578 / 63 / 18 / 659:  66%|██████▌   | 660/1000 [53:47<27:42,  4.89s/it][Succeeded / Failed / Skipped / Total] 578 / 63 / 19 / 660:  66%|██████▌   | 660/1000 [53:47<27:42,  4.89s/it][Succeeded / Failed / Skipped / Total] 578 / 63 / 19 / 660:  66%|██████▌   | 661/1000 [53:54<27:38,  4.89s/it]null - safe method --> nullcmp method --> Socre: 1.0

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label [[oneNull]] , Label [[bothNull]] ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label [[end]] = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( [[bothNull]] ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( [[end]] ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( [[oneNull]] ) ; e . mark ( [[end]] ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label [[delicti]] , Label [[sergio]] ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label [[finalizing]] = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( [[sergio]] ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( [[finalizing]] ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( [[delicti]] ) ; e . mark ( [[finalizing]] ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 656 ---------------------------------------------
Invokes the method . --> LIDB2018 - 1 --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( Object [[obj]] , Object [ ] [[args]] ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , [[obj]] , [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[plead]] ( Object [[victoire]] , Object [ ] [[boasting]] ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , [[victoire]] , [[boasting]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 657 ---------------------------------------------
Returns a map of all classes . --> Discard the class --> Socre: 1.0

[[[[Adv]]]]: public Map [[resolveAll]] ( ) { Map [[resolved]] = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class [[owner]] = ( Class ) entry . getKey ( ) ; Set [[bridges]] = ( Set ) entry . getValue ( ) ; try { InputStream [[is]] = classLoader . getResourceAsStream ( [[owner]] . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( [[is]] == null ) { return [[resolved]] ; } try { new ClassReader ( [[is]] ) . accept ( new BridgedFinder ( [[bridges]] , [[resolved]] ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { [[is]] . close ( ) ; } } catch ( IOException ignored ) { } } return [[resolved]] ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map [[disfigure]] ( ) { Map [[determination]] = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class [[monarchy]] = ( Class ) entry . getKey ( ) ; Set [[parachutists]] = ( Set ) entry . getValue ( ) ; try { InputStream [[goes]] = classLoader . getResourceAsStream ( [[monarchy]] . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( [[goes]] == null ) { return [[determination]] ; } try { new ClassReader ( [[goes]] ) . accept ( new BridgedFinder ( [[parachutists]] , [[determination]] ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { [[goes]] . close ( ) ; } } catch ( IOException ignored ) { } } return [[determination]] ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 658 ---------------------------------------------
Removes constructors from the specified class . --> sweethearts an Object --> Socre: 1.0

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class [[sc]] , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( [[sc]] , "True" == "True" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[sc]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[sweethearts]] ( Class [[vd]] , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( [[vd]] , "True" == "True" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[vd]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 659 ---------------------------------------------
Sets the superclass . --> Convenience method for serbia --> Socre: 1.0

[[[[Adv]]]]: public void [[setSuperclass]] ( Class [[superclass]] ) { if ( [[superclass]] != null && [[superclass]] . equals ( Object . class ) ) { [[superclass]] = null ; } this . [[superclass]] = [[superclass]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void [[serbia]] ( Class [[healthiest]] ) { if ( [[healthiest]] != null && [[healthiest]] . equals ( Object . class ) ) { [[healthiest]] = null ; } this . [[deducted]] = [[healthiest]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 660 ---------------------------------------------
Gets the field . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 661 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 579 / 63 / 19 / 661:  66%|██████▌   | 661/1000 [53:54<27:38,  4.89s/it][Succeeded / Failed / Skipped / Total] 579 / 63 / 19 / 661:  66%|██████▌   | 662/1000 [53:55<27:32,  4.89s/it][Succeeded / Failed / Skipped / Total] 580 / 63 / 19 / 662:  66%|██████▌   | 662/1000 [53:55<27:32,  4.89s/it][Succeeded / Failed / Skipped / Total] 580 / 63 / 19 / 662:  66%|██████▋   | 663/1000 [54:04<27:29,  4.89s/it][Succeeded / Failed / Skipped / Total] 581 / 63 / 19 / 663:  66%|██████▋   | 663/1000 [54:04<27:29,  4.89s/it][Succeeded / Failed / Skipped / Total] 581 / 63 / 19 / 663:  66%|██████▋   | 664/1000 [54:04<27:21,  4.89s/it][Succeeded / Failed / Skipped / Total] 581 / 63 / 20 / 664:  66%|██████▋   | 664/1000 [54:04<27:21,  4.89s/it][Succeeded / Failed / Skipped / Total] 581 / 63 / 20 / 664:  66%|██████▋   | 665/1000 [54:09<27:16,  4.89s/it][Succeeded / Failed / Skipped / Total] 582 / 63 / 20 / 665:  66%|██████▋   | 665/1000 [54:09<27:16,  4.89s/it][Succeeded / Failed / Skipped / Total] 582 / 63 / 20 / 665:  67%|██████▋   | 666/1000 [54:20<27:14,  4.90s/it][Succeeded / Failed / Skipped / Total] 583 / 63 / 20 / 666:  67%|██████▋   | 666/1000 [54:20<27:14,  4.90s/it][Succeeded / Failed / Skipped / Total] 583 / 63 / 20 / 666:  67%|██████▋   | 667/1000 [54:20<27:08,  4.89s/it][Succeeded / Failed / Skipped / Total] 584 / 63 / 20 / 667:  67%|██████▋   | 667/1000 [54:20<27:08,  4.89s/it][Succeeded / Failed / Skipped / Total] 584 / 63 / 20 / 667:  67%|██████▋   | 668/1000 [54:40<27:10,  4.91s/it][Succeeded / Failed / Skipped / Total] 585 / 63 / 20 / 668:  67%|██████▋   | 668/1000 [54:40<27:10,  4.91s/it][Succeeded / Failed / Skipped / Total] 585 / 63 / 20 / 668:  67%|██████▋   | 669/1000 [54:42<27:04,  4.91s/it]Set the methods for the superclass and interfaces . --> dailies --> Socre: 1.0

[[[[Adv]]]]: public static void [[getMethods]] ( Class superclass , Class [ ] interfaces , List methods ) { [[getMethods]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[dailies]] ( Class superclass , Class [ ] interfaces , List methods ) { [[dailies]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 662 ---------------------------------------------
Return the cardinality . --> Get the number of satman --> Socre: 1.0

[[[[Adv]]]]: public int [[cardinality]] ( ) { int [[w]] = value ; int [[c]] = 0 ; while ( [[w]] != 0 ) { [[c]] += T [ [[w]] & 255 ] ; [[w]] >>= 8 ; } return [[c]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int [[cowman]] ( ) { int [[d]] = value ; int [[deux]] = 0 ; while ( [[d]] != 0 ) { [[deux]] += T [ [[d]] & 255 ] ; [[d]] >>= 8 ; } return [[deux]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 663 ---------------------------------------------
Sets the naming policy . --> Methode nathi --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy [[namingPolicy]] ) { if ( [[namingPolicy]] == null ) [[namingPolicy]] = DefaultNamingPolicy . INSTANCE ; this . [[namingPolicy]] = [[namingPolicy]] ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[byt]] ( NamingPolicy [[nathi]] ) { if ( [[nathi]] == null ) [[nathi]] = DefaultNamingPolicy . INSTANCE ; this . [[vestal]] = [[nathi]] ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 664 ---------------------------------------------
Find methods . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 665 ---------------------------------------------
Process an array . --> Transerates a CodeEmitter to a CodeEmitter --> Socre: 1.0

[[[[Adv]]]]: public static void [[process_array]] ( CodeEmitter e , Type [[type]] , ProcessArrayCallback [[callback]] ) { Type componentType = TypeUtils . getComponentType ( [[type]] ) ; Local [[array]] = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( [[array]] ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( [[array]] ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; [[callback]] . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( [[array]] ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void [[transcription]] ( CodeEmitter e , Type [[man]] , ProcessArrayCallback [[minder]] ) { Type componentType = TypeUtils . getComponentType ( [[man]] ) ; Local [[stateroom]] = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( [[stateroom]] ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( [[stateroom]] ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; [[minder]] . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( [[stateroom]] ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 666 ---------------------------------------------
Read a string from the specified path . --> Get the fuk document --> Socre: 1.0

[[[[Adv]]]]: public static String [[readString]] ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter [[writer]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String [[fukuda]] ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter [[sportswriter]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 667 ---------------------------------------------
Sets the host . --> Set the benefited attribute --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . [[host]] = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[benefited]] ( final String [[billeted]] ) { this . [[billeted]] = [[benefited]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[benefited]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 668 ---------------------------------------------
Create a ParallelSorter object --> constructs an array --> Socre: 1.0

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] [[arrays]] ) { Generator [[gen]] = new Generator ( ) ; [[gen]] . setArrays ( [[arrays]] ) ; return [[gen]] . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[constructs]] ( Object [ ] [[booths]] ) { Generator [[fella]] = new Generator ( ) ; [[fella]] . setArrays ( [[booths]] ) ; return [[fella]] . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 669 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 586 / 63 / 20 / 669:  67%|██████▋   | 669/1000 [54:42<27:04,  4.91s/it][Succeeded / Failed / Skipped / Total] 586 / 63 / 20 / 669:  67%|██████▋   | 670/1000 [54:49<27:00,  4.91s/it][Succeeded / Failed / Skipped / Total] 587 / 63 / 20 / 670:  67%|██████▋   | 670/1000 [54:49<27:00,  4.91s/it][Succeeded / Failed / Skipped / Total] 587 / 63 / 20 / 670:  67%|██████▋   | 671/1000 [54:52<26:54,  4.91s/it][Succeeded / Failed / Skipped / Total] 588 / 63 / 20 / 671:  67%|██████▋   | 671/1000 [54:52<26:54,  4.91s/it][Succeeded / Failed / Skipped / Total] 588 / 63 / 20 / 671:  67%|██████▋   | 672/1000 [54:54<26:48,  4.90s/it][Succeeded / Failed / Skipped / Total] 589 / 63 / 20 / 672:  67%|██████▋   | 672/1000 [54:54<26:48,  4.90s/it][Succeeded / Failed / Skipped / Total] 589 / 63 / 20 / 672:  67%|██████▋   | 673/1000 [54:54<26:40,  4.90s/it][Succeeded / Failed / Skipped / Total] 590 / 63 / 20 / 673:  67%|██████▋   | 673/1000 [54:54<26:40,  4.90s/it][Succeeded / Failed / Skipped / Total] 590 / 63 / 20 / 673:  67%|██████▋   | 674/1000 [54:58<26:35,  4.89s/it][Succeeded / Failed / Skipped / Total] 591 / 63 / 20 / 674:  67%|██████▋   | 674/1000 [54:58<26:35,  4.89s/it][Succeeded / Failed / Skipped / Total] 591 / 63 / 20 / 674:  68%|██████▊   | 675/1000 [55:01<26:29,  4.89s/it][Succeeded / Failed / Skipped / Total] 592 / 63 / 20 / 675:  68%|██████▊   | 675/1000 [55:01<26:29,  4.89s/it][Succeeded / Failed / Skipped / Total] 592 / 63 / 20 / 675:  68%|██████▊   | 676/1000 [55:16<26:29,  4.91s/it][Succeeded / Failed / Skipped / Total] 593 / 63 / 20 / 676:  68%|██████▊   | 676/1000 [55:16<26:29,  4.91s/it][Succeeded / Failed / Skipped / Total] 593 / 63 / 20 / 676:  68%|██████▊   | 677/1000 [55:17<26:22,  4.90s/it][Succeeded / Failed / Skipped / Total] 594 / 63 / 20 / 677:  68%|██████▊   | 677/1000 [55:17<26:22,  4.90s/it][Succeeded / Failed / Skipped / Total] 594 / 63 / 20 / 677:  68%|██████▊   | 678/1000 [55:32<26:22,  4.91s/it][Succeeded / Failed / Skipped / Total] 594 / 64 / 20 / 678:  68%|██████▊   | 678/1000 [55:32<26:22,  4.91s/it][Succeeded / Failed / Skipped / Total] 594 / 64 / 20 / 678:  68%|██████▊   | 679/1000 [55:32<26:15,  4.91s/it]Create a new HttpRequest with the given destination . --> Create new HttpRequest with ambitions --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest connect ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest connect ( final String [[ambitions]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[ambitions]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 670 ---------------------------------------------
Create a new HttpRequest . --> Get HttpRequest based on specified paths and earmarked --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[create]] ( final String [[method]] , final String [[destination]] ) { return new HttpRequest ( ) . [[method]] ( [[method]] . toUpperCase ( ) ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest [[engendered]] ( final String [[paths]] , final String [[earmarked]] ) { return new HttpRequest ( ) . [[paths]] ( [[paths]] . toUpperCase ( ) ) . set ( [[earmarked]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 671 ---------------------------------------------
Create a new HttpRequest object . --> Create an empty HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[arrive]] ( final String [[fated]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[fated]] ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 672 ---------------------------------------------
Create a new HttpRequest with the given destination . --> Create HttpRequest method --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[taken]] ( final String [[whereabouts]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[whereabouts]] ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 673 ---------------------------------------------
Creates a new HttpRequest with the given destination . --> Get HttpRequest for HTTP jobs --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[jobs]] ( final String [[beneficiaries]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[beneficiaries]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 674 ---------------------------------------------
Make a DELETE request . --> Create new HttpRequest with given destiny --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[disposing]] ( final String [[destiny]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destiny]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 675 ---------------------------------------------
Creates a PATCH annotation for the given destination . --> Set the aspirations --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest patch ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest patch ( final String [[aspirations]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[aspirations]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 676 ---------------------------------------------
Add a method . --> Callback for integrating --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Method [[method]] ) { [[add]] ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[integrating]] ( Method [[practises]] ) { [[integrating]] ( ReflectUtils . getSignature ( [[practises]] ) , ReflectUtils . getExceptionTypes ( [[practises]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 677 ---------------------------------------------
Create a new HttpRequest . --> Create a HttpRequest with the given destination --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[possibilities]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 678 ---------------------------------------------
Returns an EntityManager . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( "True" == "True" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( "True" == "True" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 679 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 594 / 65 / 20 / 679:  68%|██████▊   | 679/1000 [55:32<26:15,  4.91s/it][Succeeded / Failed / Skipped / Total] 594 / 65 / 20 / 679:  68%|██████▊   | 680/1000 [55:34<26:08,  4.90s/it][Succeeded / Failed / Skipped / Total] 595 / 65 / 20 / 680:  68%|██████▊   | 680/1000 [55:34<26:08,  4.90s/it][Succeeded / Failed / Skipped / Total] 595 / 65 / 20 / 680:  68%|██████▊   | 681/1000 [55:40<26:04,  4.90s/it][Succeeded / Failed / Skipped / Total] 596 / 65 / 20 / 681:  68%|██████▊   | 681/1000 [55:40<26:04,  4.90s/it][Succeeded / Failed / Skipped / Total] 596 / 65 / 20 / 681:  68%|██████▊   | 682/1000 [55:41<25:57,  4.90s/it][Succeeded / Failed / Skipped / Total] 597 / 65 / 20 / 682:  68%|██████▊   | 682/1000 [55:41<25:57,  4.90s/it][Succeeded / Failed / Skipped / Total] 597 / 65 / 20 / 682:  68%|██████▊   | 683/1000 [55:42<25:51,  4.89s/it][Succeeded / Failed / Skipped / Total] 598 / 65 / 20 / 683:  68%|██████▊   | 683/1000 [55:42<25:51,  4.89s/it][Succeeded / Failed / Skipped / Total] 599 / 65 / 20 / 684:  68%|██████▊   | 684/1000 [55:42<25:44,  4.89s/it][Succeeded / Failed / Skipped / Total] 599 / 65 / 20 / 684:  68%|██████▊   | 685/1000 [55:42<25:37,  4.88s/it][Succeeded / Failed / Skipped / Total] 600 / 65 / 20 / 685:  68%|██████▊   | 685/1000 [55:42<25:37,  4.88s/it][Succeeded / Failed / Skipped / Total] 601 / 65 / 20 / 686:  69%|██████▊   | 686/1000 [55:47<25:32,  4.88s/it][Succeeded / Failed / Skipped / Total] 601 / 65 / 20 / 686:  69%|██████▊   | 687/1000 [55:48<25:25,  4.87s/it]Gets the accessible method . --> [[[FAILED]]]

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 680 ---------------------------------------------
Returns the request path . --> Add an arbitrary element --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[path]] ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[ways]] ( String [[arteries]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 681 ---------------------------------------------
query . --> Add a parameter --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int [[i]] = 0 ; [[i]] < parameters . length ; [[i]] += 2 ) { String name = parameters [ [[i]] ] . toString ( ) ; String value = parameters [ [[i]] + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int [[yo]] = 0 ; [[yo]] < parameters . length ; [[yo]] += 2 ) { String name = parameters [ [[yo]] ] . toString ( ) ; String value = parameters [ [[yo]] + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 682 ---------------------------------------------
Set REPLACEME0 . --> Set cacha object --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[REPLACEME0]] ( final Cookie ... [[REPLACEME0]] ) { if ( [[REPLACEME0]] . length == 0 ) { return this ; } StringBuilder [[cookieString]] = new StringBuilder ( ) ; boolean [[first]] = "[[True]]" == "[[True]]" ; for ( Cookie cookie : [[REPLACEME0]] ) { Integer [[maxAge]] = cookie . getMaxAge ( ) ; if ( [[maxAge]] != null && [[maxAge]] . intValue ( ) == 0 ) { continue ; } if ( ! [[first]] ) { [[cookieString]] . append ( "; " ) ; } [[first]] = "False" != "False" ; [[cookieString]] . append ( cookie . getName ( ) ) ; [[cookieString]] . append ( ' ' ) ; [[cookieString]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[cookieString]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest [[PAGET]] ( final Cookie ... [[PAGET]] ) { if ( [[PAGET]] . length == 0 ) { return this ; } StringBuilder [[cachaça]] = new StringBuilder ( ) ; boolean [[outset]] = "[[Velma]]" == "[[Velma]]" ; for ( Cookie cookie : [[PAGET]] ) { Integer [[riverfront]] = cookie . getMaxAge ( ) ; if ( [[riverfront]] != null && [[riverfront]] . intValue ( ) == 0 ) { continue ; } if ( ! [[outset]] ) { [[cachaça]] . append ( "; " ) ; } [[outset]] = "False" != "False" ; [[cachaça]] . append ( cookie . getName ( ) ) ; [[cachaça]] . append ( ' ' ) ; [[cachaça]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[cachaça]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 683 ---------------------------------------------
Gets the query string . --> Makes a HTTP POST request --> Socre: 1.0

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[martina]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 684 ---------------------------------------------
Set the query string --> Filter byzantium --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String queryString , final boolean [[decode]] ) { this . query = HttpUtil . parseQuery ( [[queryString]] , [[decode]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[byzantium]] ( final String queryString , final boolean [[cleft]] ) { this . query = HttpUtil . parseQuery ( [[byzantium]] , [[cleft]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 685 ---------------------------------------------
Add query map . --> Add a query --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > [[queryMap]] ) { for ( Map . Entry < String , String > [[entry]] : [[queryMap]] . entrySet ( ) ) { query . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > [[stetson]] ) { for ( Map . Entry < String , String > [[entrance]] : [[stetson]] . entrySet ( ) ) { query . add ( [[entrance]] . getKey ( ) , [[entrance]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 686 ---------------------------------------------
Get the host URL . --> Return a vaporised string --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[vaporised]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 687 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 602 / 65 / 20 / 687:  69%|██████▊   | 687/1000 [55:48<25:25,  4.87s/it][Succeeded / Failed / Skipped / Total] 603 / 65 / 20 / 688:  69%|██████▉   | 688/1000 [55:48<25:18,  4.87s/it][Succeeded / Failed / Skipped / Total] 603 / 65 / 20 / 688:  69%|██████▉   | 689/1000 [55:51<25:12,  4.86s/it][Succeeded / Failed / Skipped / Total] 604 / 65 / 20 / 689:  69%|██████▉   | 689/1000 [55:51<25:12,  4.86s/it][Succeeded / Failed / Skipped / Total] 605 / 65 / 20 / 690:  69%|██████▉   | 690/1000 [55:55<25:07,  4.86s/it][Succeeded / Failed / Skipped / Total] 605 / 65 / 20 / 690:  69%|██████▉   | 691/1000 [55:59<25:02,  4.86s/it][Succeeded / Failed / Skipped / Total] 606 / 65 / 20 / 691:  69%|██████▉   | 691/1000 [55:59<25:02,  4.86s/it][Succeeded / Failed / Skipped / Total] 606 / 66 / 20 / 692:  69%|██████▉   | 692/1000 [56:00<24:55,  4.86s/it][Succeeded / Failed / Skipped / Total] 606 / 66 / 20 / 692:  69%|██████▉   | 693/1000 [56:09<24:52,  4.86s/it][Succeeded / Failed / Skipped / Total] 607 / 66 / 20 / 693:  69%|██████▉   | 693/1000 [56:09<24:52,  4.86s/it][Succeeded / Failed / Skipped / Total] 608 / 66 / 20 / 694:  69%|██████▉   | 694/1000 [56:11<24:46,  4.86s/it][Succeeded / Failed / Skipped / Total] 608 / 66 / 20 / 694:  70%|██████▉   | 695/1000 [56:13<24:40,  4.85s/it]Gets the buffer . --> Implementation of tests --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer [[buffer]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer [[bumpers]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 688 ---------------------------------------------
Set the host header . --> Generate the HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String [[hostPort]] = this . [[host]] ; if ( port != Defaults . DEFAULT_PORT ) { [[hostPort]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[hostPort]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[barras]] ( ) { String [[commissar]] = this . [[receptors]] ; if ( port != Defaults . DEFAULT_PORT ) { [[commissar]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[commissar]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 689 ---------------------------------------------
Send and receive the given responseHandler . --> Send and receive request --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[reddy]] > [[reddy]] sendAndReceive ( final Function < HttpResponse , [[reddy]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 690 ---------------------------------------------
Returns the cost of the given destination class . --> Return a new float based on srcClass and limber --> Socre: 1.0

[[[[Adv]]]]: private static float [[getObjectTransformationCost]] ( Class < ? > srcClass , final Class < ? > [[destClass]] ) { if ( [[destClass]] . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , [[destClass]] ) ; } float [[cost]] = 0.0f ; while ( srcClass != null && ! [[destClass]] . equals ( srcClass ) ) { if ( [[destClass]] . isInterface ( ) && ClassUtils . isAssignable ( srcClass , [[destClass]] ) ) { * If the destination [[class]] is [[null]], we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { [[cost]] += 1.5f ; } return [[cost]] ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float [[newtons]] ( Class < ? > srcClass , final Class < ? > [[limber]] ) { if ( [[limber]] . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , [[limber]] ) ; } float [[rates]] = 0.0f ; while ( srcClass != null && ! [[limber]] . equals ( srcClass ) ) { if ( [[limber]] . isInterface ( ) && ClassUtils . isAssignable ( srcClass , [[limber]] ) ) { * If the destination [[sorting]] is [[hollow]], we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { [[rates]] += 1.5f ; } return [[rates]] ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 691 ---------------------------------------------
Create HttpRequest . --> Returns an empty HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[trails]] ( final String [[receptor]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[receptor]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 692 ---------------------------------------------
Add authentication . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest basicAuthentication ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest basicAuthentication ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 693 ---------------------------------------------
Registers the given formatter with the given class . --> Parse textbooks and Locale lieu --> Socre: 1.0

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[text]] , Locale [[locale]] ) throws java . [[text]] . ParseException { return formatter . parse ( [[text]] , [[locale]] ) ; } public String print ( T [[t]] , Locale [[locale]] ) { return formatter . print ( [[t]] , [[locale]] ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[Penchant]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[textbooks]] , Locale [[lieu]] ) throws java . [[textbooks]] . ParseException { return formatter . parse ( [[textbooks]] , [[lieu]] ) ; } public String print ( T [[quantity]] , Locale [[lieu]] ) { return formatter . print ( [[quantity]] , [[lieu]] ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 694 ---------------------------------------------
Collect all interceptors . --> Called by distributor method --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > [[interceptorValues]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[interceptorValues]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[distributor]] ( ) { final Collection < ? extends ActionInterceptor > [[opium]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[opium]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 695 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 609 / 66 / 20 / 695:  70%|██████▉   | 695/1000 [56:13<24:40,  4.85s/it][Succeeded / Failed / Skipped / Total] 610 / 66 / 20 / 696:  70%|██████▉   | 696/1000 [56:14<24:33,  4.85s/it][Succeeded / Failed / Skipped / Total] 610 / 66 / 20 / 696:  70%|██████▉   | 697/1000 [56:16<24:27,  4.84s/it][Succeeded / Failed / Skipped / Total] 611 / 66 / 20 / 697:  70%|██████▉   | 697/1000 [56:16<24:27,  4.84s/it][Succeeded / Failed / Skipped / Total] 612 / 66 / 20 / 698:  70%|██████▉   | 698/1000 [56:21<24:22,  4.84s/it][Succeeded / Failed / Skipped / Total] 612 / 66 / 20 / 698:  70%|██████▉   | 699/1000 [56:22<24:16,  4.84s/it][Succeeded / Failed / Skipped / Total] 613 / 66 / 20 / 699:  70%|██████▉   | 699/1000 [56:22<24:16,  4.84s/it][Succeeded / Failed / Skipped / Total] 614 / 66 / 20 / 700:  70%|███████   | 700/1000 [56:22<24:09,  4.83s/it][Succeeded / Failed / Skipped / Total] 614 / 66 / 20 / 700:  70%|███████   | 701/1000 [56:25<24:03,  4.83s/it][Succeeded / Failed / Skipped / Total] 615 / 66 / 20 / 701:  70%|███████   | 701/1000 [56:25<24:03,  4.83s/it][Succeeded / Failed / Skipped / Total] 616 / 66 / 20 / 702:  70%|███████   | 702/1000 [56:26<23:57,  4.82s/it][Succeeded / Failed / Skipped / Total] 616 / 66 / 20 / 702:  70%|███████   | 703/1000 [56:28<23:51,  4.82s/it][Succeeded / Failed / Skipped / Total] 617 / 66 / 20 / 703:  70%|███████   | 703/1000 [56:28<23:51,  4.82s/it][Succeeded / Failed / Skipped / Total] 618 / 66 / 20 / 704:  70%|███████   | 704/1000 [56:28<23:44,  4.81s/it][Succeeded / Failed / Skipped / Total] 618 / 66 / 20 / 704:  70%|███████   | 705/1000 [56:44<23:44,  4.83s/it]Collects all action results . --> The pocho method is called by the tests --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > [[resultsValues]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[resultsValues]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[pocho]] ( ) { final Collection < ActionResult > [[banisters]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[banisters]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 696 ---------------------------------------------
Resolves the given base path with the given child . --> Resolve teenagers --> Socre: 1.0

[[[[Adv]]]]: public static Path resolve ( final Path [[base]] , String [[child]] ) { if ( StringUtil . startsWithChar ( [[child]] , File . separatorChar ) ) { [[child]] = [[child]] . substring ( 1 ) ; } return [[base]] . resolve ( [[child]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path resolve ( final Path [[keystone]] , String [[teenagers]] ) { if ( StringUtil . startsWithChar ( [[teenagers]] , File . separatorChar ) ) { [[teenagers]] = [[teenagers]] . substring ( 1 ) ; } return [[keystone]] . resolve ( [[teenagers]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 697 ---------------------------------------------
Extract the value reference property --> Return crNodeIding --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int [[ndx]] = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( [[ndx]] == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , [[ndx]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[mopani]] ( final String [[crunching]] ) { int [[sca]] = StringUtil . indexOfChars ( [[crunching]] , INDEX_CHARS ) ; if ( [[sca]] == - 1 ) { return [[crunching]] ; } return [[crunching]] . substring ( 0 , [[sca]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 698 ---------------------------------------------
Sets a property on this Bean . --> Setter method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty [[bp]] , final Object [[value]] ) { Setter [[setter]] = [[bp]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[adrian]] ( final BeanProperty [[pp]] , final Object [[merit]] ) { Setter [[softball]] = [[pp]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 699 ---------------------------------------------
Returns the current writer . --> region > kyushu --> Socre: 1.0

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[kyushu]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 700 ---------------------------------------------
Get the object reference by name . --> Return the lightens for aka --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String [[name]] ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( [[name]] ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[lightens]] ( final String [[aka]] ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( [[aka]] ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 701 ---------------------------------------------
Collect all action filters . --> F743 --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > [[filterValues]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[filterValues]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[vagabond]] ( ) { final Collection < ? extends ActionFilter > [[ennis]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[ennis]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 702 ---------------------------------------------
Collects the actions for the ActionRuntime . --> region osman Implementation --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[osman]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 703 ---------------------------------------------
Set the object reference . --> Add a fightin --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String [[name]] , final Object [[object]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , [[object]] ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[fightin]] ( final String [[nouns]] , final Object [[bucked]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[nouns]] , [[bucked]] ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 704 ---------------------------------------------
Lookup an object reference . --> get the kidnappings --> Socre: 1.0

[[[[Adv]]]]: public Object [[lookupObject]] ( final String [[ref]] ) { Object [[value]] = getObjectReference ( [[ref]] ) ; if ( [[value]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[ref]] ) ; } return [[value]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[kidnappings]] ( final String [[umpires]] ) { Object [[assess]] = getObjectReference ( [[umpires]] ) ; if ( [[assess]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[umpires]] ) ; } return [[assess]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 705 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 619 / 66 / 20 / 705:  70%|███████   | 705/1000 [56:44<23:44,  4.83s/it][Succeeded / Failed / Skipped / Total] 619 / 66 / 20 / 705:  71%|███████   | 706/1000 [56:53<23:41,  4.84s/it][Succeeded / Failed / Skipped / Total] 620 / 66 / 20 / 706:  71%|███████   | 706/1000 [56:53<23:41,  4.84s/it][Succeeded / Failed / Skipped / Total] 620 / 66 / 20 / 706:  71%|███████   | 707/1000 [56:54<23:35,  4.83s/it][Succeeded / Failed / Skipped / Total] 621 / 66 / 20 / 707:  71%|███████   | 707/1000 [56:54<23:35,  4.83s/it][Succeeded / Failed / Skipped / Total] 621 / 66 / 20 / 707:  71%|███████   | 708/1000 [56:54<23:28,  4.82s/it][Succeeded / Failed / Skipped / Total] 622 / 66 / 20 / 708:  71%|███████   | 708/1000 [56:54<23:28,  4.82s/it][Succeeded / Failed / Skipped / Total] 622 / 66 / 20 / 708:  71%|███████   | 709/1000 [56:58<23:23,  4.82s/it][Succeeded / Failed / Skipped / Total] 623 / 66 / 20 / 709:  71%|███████   | 709/1000 [56:58<23:23,  4.82s/it][Succeeded / Failed / Skipped / Total] 623 / 66 / 20 / 709:  71%|███████   | 710/1000 [57:06<23:19,  4.83s/it][Succeeded / Failed / Skipped / Total] 624 / 66 / 20 / 710:  71%|███████   | 710/1000 [57:06<23:19,  4.83s/it][Succeeded / Failed / Skipped / Total] 624 / 66 / 20 / 710:  71%|███████   | 711/1000 [57:08<23:13,  4.82s/it][Succeeded / Failed / Skipped / Total] 625 / 66 / 20 / 711:  71%|███████   | 711/1000 [57:08<23:13,  4.82s/it][Succeeded / Failed / Skipped / Total] 625 / 66 / 20 / 711:  71%|███████   | 712/1000 [57:10<23:07,  4.82s/it][Succeeded / Failed / Skipped / Total] 626 / 66 / 20 / 712:  71%|███████   | 712/1000 [57:10<23:07,  4.82s/it]Returns the entity descriptor for the specified table . --> Get the DbEntityDescriptor --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[bouts]] ( final String [[civilians]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[tonnes]] = tableRefs . get ( [[civilians]] ) ; return [[tonnes]] == null ? null : [[tonnes]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 706 ---------------------------------------------
Register a table reference . --> Create a database join --> Socre: 1.0

[[[[Adv]]]]: public void [[registerTableReference]] ( final String [[tableReference]] , final DbEntityDescriptor [[ded]] , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( [[ded]] , tableAlias ) ; if ( tableRefs . put ( [[tableReference]] , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + [[tableReference]] ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[matsushima]] ( final String [[pelt]] , final DbEntityDescriptor [[ders]] , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( [[ders]] , tableAlias ) ; if ( tableRefs . put ( [[pelt]] , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + [[pelt]] ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 707 ---------------------------------------------
Finds a table descriptor by column ref name . --> Return the DbEntityDescriptor for the given loopy --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String [[columnRef]] ) { for ( Map . Entry < String , TableRefData > [[entry]] : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[ded]] = [[entry]] . getValue ( ) . desc ; if ( [[ded]] . findByPropertyName ( [[columnRef]] ) != null ) { return [[ded]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[homeward]] ( final String [[loopy]] ) { for ( Map . Entry < String , TableRefData > [[registration]] : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[fie]] = [[registration]] . getValue ( ) . desc ; if ( [[fie]] . findByPropertyName ( [[loopy]] ) != null ) { return [[fie]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 708 ---------------------------------------------
Creates a new HttpRequest with the given destination . --> Create new instance of HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[manager]] ( final String [[intention]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[intention]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 709 ---------------------------------------------
Serialize value . --> Serve this statement --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[jsonContext]] , final T [[value]] ) { if ( [[jsonContext]] . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[lychees]] , final T [[bravery]] ) { if ( [[lychees]] . pushValue ( [[bravery]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 710 ---------------------------------------------
Lookup the named table reference . --> Create a database located at pirelli --> Socre: 1.0

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String [[tableRef]] ) { DbEntityDescriptor [[ded]] = getTableDescriptor ( [[tableRef]] ) ; if ( [[ded]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[tableRef]] ) ; } return [[ded]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[lowry]] ( final String [[pirelli]] ) { DbEntityDescriptor [[lif]] = getTableDescriptor ( [[pirelli]] ) ; if ( [[lif]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[pirelli]] ) ; } return [[lif]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 711 ---------------------------------------------
Removes the given range . --> d42985 --> Socre: 1.0

[[[[Adv]]]]: static Handler [[removeRange]] ( final Handler [[firstHandler]] , final Label start , final Label [[end]] ) { if ( [[firstHandler]] == null ) { return null ; } else { [[firstHandler]] . nextHandler = [[removeRange]] ( [[firstHandler]] . nextHandler , start , [[end]] ) ; } int [[handlerStart]] = [[firstHandler]] . startPc . bytecodeOffset ; int handlerEnd = [[firstHandler]] . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int [[rangeEnd]] = [[end]] == null ? Integer . MAX_VALUE : [[end]] . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler [[drex]] ( final Handler [[rebuilds]] , final Label start , final Label [[culminates]] ) { if ( [[rebuilds]] == null ) { return null ; } else { [[rebuilds]] . nextHandler = [[drex]] ( [[rebuilds]] . nextHandler , start , [[culminates]] ) ; } int [[cards]] = [[rebuilds]] . startPc . bytecodeOffset ; int handlerEnd = [[rebuilds]] . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int [[drop]] = [[culminates]] == null ? Integer . MAX_VALUE : [[culminates]] . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 712 ---------------------------------------------
Returns the index of the table length . --> Get suntanned moments --> Socre: 1.0

[[[[Adv]]]]: static int [[getExceptionTableLength]] ( final Handler [[firstHandler]] ) { int [[length]] = 0 ; Handler handler = [[firstHandler]] ; while ( handler != null ) { [[length]] ++ ; handler = handler . nextHandler ; } return [[length]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int [[suntanned]] ( final Handler [[rattler]] ) { int [[moments]] = 0 ; Handler handler = [[rattler]] ; while ( handler != null ) { [[moments]] ++ ; handler = handler . nextHandler ; } return [[moments]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 713 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 627 / 66 / 20 / 713:  71%|███████▏  | 713/1000 [57:10<23:00,  4.81s/it][Succeeded / Failed / Skipped / Total] 627 / 66 / 20 / 713:  71%|███████▏  | 714/1000 [57:13<22:55,  4.81s/it][Succeeded / Failed / Skipped / Total] 628 / 66 / 20 / 714:  71%|███████▏  | 714/1000 [57:13<22:55,  4.81s/it][Succeeded / Failed / Skipped / Total] 629 / 66 / 20 / 715:  72%|███████▏  | 715/1000 [57:16<22:49,  4.81s/it][Succeeded / Failed / Skipped / Total] 629 / 66 / 20 / 715:  72%|███████▏  | 716/1000 [57:16<22:43,  4.80s/it][Succeeded / Failed / Skipped / Total] 630 / 66 / 20 / 716:  72%|███████▏  | 716/1000 [57:16<22:43,  4.80s/it][Succeeded / Failed / Skipped / Total] 631 / 66 / 20 / 717:  72%|███████▏  | 717/1000 [57:24<22:39,  4.80s/it][Succeeded / Failed / Skipped / Total] 631 / 66 / 20 / 717:  72%|███████▏  | 718/1000 [57:36<22:37,  4.81s/it][Succeeded / Failed / Skipped / Total] 631 / 67 / 20 / 718:  72%|███████▏  | 718/1000 [57:36<22:37,  4.81s/it][Succeeded / Failed / Skipped / Total] 631 / 67 / 20 / 718:  72%|███████▏  | 719/1000 [57:36<22:30,  4.81s/it]Converts the property name to column name . --> Mallik a JSON string --> Socre: 1.0

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder [[tableName]] = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[convertedTableName]] = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; [[tableName]] . append ( [[convertedTableName]] ) ; } else { [[tableName]] . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return [[tableName]] . toString ( ) ; } return uppercase ? toUppercase ( [[tableName]] ) . toString ( ) : toLowercase ( [[tableName]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[mallik]] ( final String [[stomped]] ) { StringBuilder [[squeezy]] = new StringBuilder ( [[stomped]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[dirk]] = Format . fromCamelCase ( [[stomped]] , separatorChar ) ; [[squeezy]] . append ( [[dirk]] ) ; } else { [[squeezy]] . append ( [[stomped]] ) ; } if ( ! changeCase ) { return [[squeezy]] . toString ( ) ; } return uppercase ? toUppercase ( [[squeezy]] ) . toString ( ) : toLowercase ( [[squeezy]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 714 ---------------------------------------------
Inject attributes . --> zamora Get the attribute names --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectAttributes]] ( final HttpServletRequest servletRequest , final Targets [[targets]] ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String [[attrName]] = attributeNames . nextElement ( ) ; [[targets]] . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( [[attrName]] ) ; if ( name != null ) { final Object [[attrValue]] = servletRequest . getAttribute ( [[attrName]] ) ; target . writeValue ( name , [[attrValue]] , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void [[zamora]] ( final HttpServletRequest servletRequest , final Targets [[aspiration]] ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String [[plea]] = attributeNames . nextElement ( ) ; [[aspiration]] . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( [[plea]] ) ; if ( name != null ) { final Object [[sunbeams]] = servletRequest . getAttribute ( [[plea]] ) ; target . writeValue ( name , [[sunbeams]] , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 715 ---------------------------------------------
Convert a column name to a property name --> Returns the first occurrence of the specified columnName --> Socre: 1.0

[[[[Adv]]]]: public String [[convertColumnNameToPropertyName]] ( final String columnName ) { StringBuilder [[propertyName]] = new StringBuilder ( columnName . length ( ) ) ; int [[len]] = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int [[i]] = 0 ; [[i]] < [[len]] ; [[i]] ++ ) { char c = columnName . charAt ( [[i]] ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { [[propertyName]] . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { [[propertyName]] . append ( Character . toLowerCase ( c ) ) ; } } return [[propertyName]] . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String [[susi]] ( final String columnName ) { StringBuilder [[carcasses]] = new StringBuilder ( columnName . length ( ) ) ; int [[juste]] = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int [[siento]] = 0 ; [[siento]] < [[juste]] ; [[siento]] ++ ) { char c = columnName . charAt ( [[siento]] ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { [[carcasses]] . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { [[carcasses]] . append ( Character . toLowerCase ( c ) ) ; } } return [[carcasses]] . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 716 ---------------------------------------------
Apply columnName to column name --> Get the dishwater --> Socre: 1.0

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String [[columnName]] ) { String [[propertyName]] = convertColumnNameToPropertyName ( [[columnName]] ) ; return convertPropertyNameToColumnName ( [[propertyName]] ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[tro]] ( final String [[dishwater]] ) { String [[putt]] = convertColumnNameToPropertyName ( [[dishwater]] ) ; return convertPropertyNameToColumnName ( [[putt]] ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 717 ---------------------------------------------
Store value . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public void [[storeValue]] ( final PreparedStatement [[st]] , final int [[index]] , final Object value , final int [[dbSqlType]] ) throws SQLException { T [[t]] = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( [[st]] , [[index]] , [[t]] , [[dbSqlType]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void [[haka]] ( final PreparedStatement [[holies]] , final int [[pointers]] , final Object value , final int [[scrupulous]] ) throws SQLException { T [[mil]] = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( [[holies]] , [[pointers]] , [[mil]] , [[scrupulous]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 718 ---------------------------------------------
Gets value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 719 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 632 / 67 / 20 / 719:  72%|███████▏  | 719/1000 [57:36<22:30,  4.81s/it][Succeeded / Failed / Skipped / Total] 632 / 67 / 20 / 719:  72%|███████▏  | 720/1000 [57:52<22:30,  4.82s/it][Succeeded / Failed / Skipped / Total] 632 / 68 / 20 / 720:  72%|███████▏  | 720/1000 [57:52<22:30,  4.82s/it][Succeeded / Failed / Skipped / Total] 632 / 68 / 20 / 720:  72%|███████▏  | 721/1000 [57:54<22:24,  4.82s/it][Succeeded / Failed / Skipped / Total] 633 / 68 / 20 / 721:  72%|███████▏  | 721/1000 [57:54<22:24,  4.82s/it][Succeeded / Failed / Skipped / Total] 633 / 68 / 20 / 721:  72%|███████▏  | 722/1000 [57:57<22:19,  4.82s/it][Succeeded / Failed / Skipped / Total] 634 / 68 / 20 / 722:  72%|███████▏  | 722/1000 [57:57<22:19,  4.82s/it][Succeeded / Failed / Skipped / Total] 634 / 68 / 20 / 722:  72%|███████▏  | 723/1000 [57:59<22:12,  4.81s/it][Succeeded / Failed / Skipped / Total] 635 / 68 / 20 / 723:  72%|███████▏  | 723/1000 [57:59<22:12,  4.81s/it][Succeeded / Failed / Skipped / Total] 635 / 68 / 20 / 723:  72%|███████▏  | 724/1000 [58:00<22:06,  4.81s/it]Inject the parameters from the servlet request . --> Psoever method for whatso --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectParameters]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String [[encoding]] = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , [[encoding]] ) ; } } } final Object [[value]] = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , [[value]] , "[[True]]" == "[[True]]" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void [[whatsoever]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String [[conservatism]] = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , [[conservatism]] ) ; } } } final Object [[evaluated]] = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , [[evaluated]] , "[[Precision]]" == "[[Precision]]" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 720 ---------------------------------------------
Creates a new wrapper . --> [[[FAILED]]]

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 721 ---------------------------------------------
Registers a hint . --> Set the current hints --> Socre: 1.0

[[[[Adv]]]]: public void [[registerHint]] ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[yano]] ( final String [[clue]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[clue]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 722 ---------------------------------------------
Split the given filename . --> Get property value from string --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] [[split]] ( final String [[filename]] ) { String prefix = getPrefix ( [[filename]] ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( [[filename]] ) ; int [[lastExtensionIndex]] = indexOfExtension ( [[filename]] ) ; String [[path]] ; String baseName ; String [[extension]] ; if ( lastSeparatorIndex == - 1 ) { [[path]] = StringPool . EMPTY ; if ( [[lastExtensionIndex]] == - 1 ) { baseName = [[filename]] . substring ( prefix . length ( ) ) ; [[extension]] = StringPool . EMPTY ; } else { baseName = [[filename]] . substring ( prefix . length ( ) , [[lastExtensionIndex]] ) ; [[extension]] = [[filename]] . substring ( [[lastExtensionIndex]] + 1 ) ; } } else { [[path]] = [[filename]] . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( [[lastExtensionIndex]] == - 1 ) { baseName = [[filename]] . substring ( prefix . length ( ) + [[path]] . length ( ) ) ; [[extension]] = StringPool . EMPTY ; } else { baseName = [[filename]] . substring ( prefix . length ( ) + [[path]] . length ( ) , [[lastExtensionIndex]] ) ; [[extension]] = [[filename]] . substring ( [[lastExtensionIndex]] + 1 ) ; } } return new String [ ] { prefix , [[path]] , baseName , [[extension]] } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] [[segregation]] ( final String [[studs]] ) { String prefix = getPrefix ( [[studs]] ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( [[studs]] ) ; int [[scraper]] = indexOfExtension ( [[studs]] ) ; String [[rails]] ; String baseName ; String [[widening]] ; if ( lastSeparatorIndex == - 1 ) { [[rails]] = StringPool . EMPTY ; if ( [[scraper]] == - 1 ) { baseName = [[studs]] . substring ( prefix . length ( ) ) ; [[widening]] = StringPool . EMPTY ; } else { baseName = [[studs]] . substring ( prefix . length ( ) , [[scraper]] ) ; [[widening]] = [[studs]] . substring ( [[scraper]] + 1 ) ; } } else { [[rails]] = [[studs]] . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( [[scraper]] == - 1 ) { baseName = [[studs]] . substring ( prefix . length ( ) + [[rails]] . length ( ) ) ; [[widening]] = StringPool . EMPTY ; } else { baseName = [[studs]] . substring ( prefix . length ( ) + [[rails]] . length ( ) , [[scraper]] ) ; [[widening]] = [[studs]] . substring ( [[scraper]] + 1 ) ; } } return new String [ ] { prefix , [[rails]] , baseName , [[widening]] } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 723 ---------------------------------------------
Gets relative path . --> Returns the image for the given basePath --> Socre: 1.0

[[[[Adv]]]]: public static String [[relativePath]] ( final String [[targetPath]] , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( [[targetPath]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[frames]] ( final String [[gibbon]] , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( [[gibbon]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 724 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 635 / 69 / 20 / 724:  72%|███████▏  | 724/1000 [58:00<22:06,  4.81s/it][Succeeded / Failed / Skipped / Total] 635 / 69 / 20 / 724:  72%|███████▎  | 725/1000 [58:03<22:01,  4.81s/it][Succeeded / Failed / Skipped / Total] 636 / 69 / 20 / 725:  72%|███████▎  | 725/1000 [58:03<22:01,  4.81s/it][Succeeded / Failed / Skipped / Total] 636 / 69 / 20 / 725:  73%|███████▎  | 726/1000 [58:04<21:54,  4.80s/it][Succeeded / Failed / Skipped / Total] 637 / 69 / 20 / 726:  73%|███████▎  | 726/1000 [58:04<21:54,  4.80s/it][Succeeded / Failed / Skipped / Total] 637 / 69 / 20 / 726:  73%|███████▎  | 727/1000 [58:13<21:51,  4.80s/it][Succeeded / Failed / Skipped / Total] 638 / 69 / 20 / 727:  73%|███████▎  | 727/1000 [58:13<21:51,  4.80s/it][Succeeded / Failed / Skipped / Total] 638 / 69 / 20 / 727:  73%|███████▎  | 728/1000 [58:19<21:47,  4.81s/it][Succeeded / Failed / Skipped / Total] 638 / 70 / 20 / 728:  73%|███████▎  | 728/1000 [58:19<21:47,  4.81s/it][Succeeded / Failed / Skipped / Total] 638 / 70 / 20 / 728:  73%|███████▎  | 729/1000 [58:21<21:41,  4.80s/it][Succeeded / Failed / Skipped / Total] 639 / 70 / 20 / 729:  73%|███████▎  | 729/1000 [58:21<21:41,  4.80s/it][Succeeded / Failed / Skipped / Total] 639 / 70 / 20 / 729:  73%|███████▎  | 730/1000 [58:28<21:37,  4.81s/it][Succeeded / Failed / Skipped / Total] 640 / 70 / 20 / 730:  73%|███████▎  | 730/1000 [58:28<21:37,  4.81s/it][Succeeded / Failed / Skipped / Total] 640 / 70 / 20 / 730:  73%|███████▎  | 731/1000 [58:32<21:32,  4.80s/it][Succeeded / Failed / Skipped / Total] 641 / 70 / 20 / 731:  73%|███████▎  | 731/1000 [58:32<21:32,  4.80s/it][Succeeded / Failed / Skipped / Total] 641 / 70 / 20 / 731:  73%|███████▎  | 732/1000 [58:33<21:26,  4.80s/it]Registers the given component . --> [[[FAILED]]]

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 725 ---------------------------------------------
Resolves a wrapper class . --> Convenience method for resolving a particular class --> Socre: 1.0

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > [[wrapperClass]] ) { String [[wrapperClassName]] = [[wrapperClass]] . getName ( ) ; T [[wrapper]] = lookup ( [[wrapperClassName]] ) ; if ( [[wrapper]] == null ) { [[wrapper]] = createWrapper ( [[wrapperClass]] ) ; initializeWrapper ( [[wrapper]] ) ; wrappers . put ( [[wrapperClassName]] , [[wrapper]] ) ; } return [[wrapper]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[resolving]] ( final Class < ? extends T > [[posner]] ) { String [[enfants]] = [[posner]] . getName ( ) ; T [[adjusting]] = lookup ( [[enfants]] ) ; if ( [[adjusting]] == null ) { [[adjusting]] = createWrapper ( [[posner]] ) ; initializeWrapper ( [[adjusting]] ) ; wrappers . put ( [[enfants]] , [[adjusting]] ) ; } return [[adjusting]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 726 ---------------------------------------------
Start the WebApp . --> Get the current WebApp --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[begun]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 727 ---------------------------------------------
Registers the default annotation . --> Registers all registered ActionConfigManager --> Socre: 1.0

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager [[actionConfigManager]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[actionConfigManager]] . registerAnnotation ( Action . class ) ; [[actionConfigManager]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[scowling]] ( ) { final ActionConfigManager [[sukhi]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[sukhi]] . registerAnnotation ( Action . class ) ; [[sukhi]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 728 ---------------------------------------------
Sets the action configuration . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 729 ---------------------------------------------
Gets the table name . --> Get the camorra expression --> Socre: 1.0

[[[[Adv]]]]: public String [[getTableAlias]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[camorra]] ( final String [[serials]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[million]] = tableRefs . get ( [[serials]] ) ; return [[million]] == null ? null : [[million]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 730 ---------------------------------------------
Convert a separators to its system . --> Get panet state of given string --> Socre: 1.0

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String [[path]] ) { if ( [[path]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[path]] ) ; } else { return separatorsToUnix ( [[path]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[panetta]] ( final String [[rails]] ) { if ( [[rails]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[rails]] ) ; } else { return separatorsToUnix ( [[rails]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 731 ---------------------------------------------
Sets the class include jars . --> Get the concluding class --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String [[includedJar]] : [[includedJars]] ) { rulesJars . include ( [[includedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[concluding]] ( final String ... [[full]] ) { for ( final String [[butterfly]] : [[full]] ) { rulesJars . include ( [[butterfly]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 732 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 642 / 70 / 20 / 732:  73%|███████▎  | 732/1000 [58:33<21:26,  4.80s/it][Succeeded / Failed / Skipped / Total] 642 / 70 / 20 / 732:  73%|███████▎  | 733/1000 [58:36<21:20,  4.80s/it][Succeeded / Failed / Skipped / Total] 643 / 70 / 20 / 733:  73%|███████▎  | 733/1000 [58:36<21:20,  4.80s/it][Succeeded / Failed / Skipped / Total] 643 / 70 / 20 / 733:  73%|███████▎  | 734/1000 [58:40<21:15,  4.80s/it][Succeeded / Failed / Skipped / Total] 644 / 70 / 20 / 734:  73%|███████▎  | 734/1000 [58:40<21:15,  4.80s/it][Succeeded / Failed / Skipped / Total] 644 / 70 / 20 / 734:  74%|███████▎  | 735/1000 [58:53<21:14,  4.81s/it][Succeeded / Failed / Skipped / Total] 645 / 70 / 20 / 735:  74%|███████▎  | 735/1000 [58:53<21:14,  4.81s/it][Succeeded / Failed / Skipped / Total] 645 / 70 / 20 / 735:  74%|███████▎  | 736/1000 [59:19<21:16,  4.84s/it][Succeeded / Failed / Skipped / Total] 646 / 70 / 20 / 736:  74%|███████▎  | 736/1000 [59:19<21:16,  4.84s/it][Succeeded / Failed / Skipped / Total] 646 / 70 / 20 / 736:  74%|███████▎  | 737/1000 [59:31<21:14,  4.85s/it]Registers the Madvoc container component . --> Register the MadvocContainer --> Socre: 1.0

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[ulster]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 733 ---------------------------------------------
Sets the list of excluded jars . --> Set the set of playa --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... [[excludedJars]] ) { for ( final String [[excludedJar]] : [[excludedJars]] ) { rulesJars . exclude ( [[excludedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[lourdes]] ( final String ... [[playa]] ) { for ( final String [[calmly]] : [[playa]] ) { rulesJars . exclude ( [[calmly]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 734 ---------------------------------------------
Scan the classpath . --> gardai a folder --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanClassPath]] ( final File [[root]] ) { String rootPath = [[root]] . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile [[ff]] = FindFile . create ( ) . includeDirs ( "[[False]]" != "[[False]]" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = [[ff]] . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "[[False]]" != "[[False]]" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void [[gardai]] ( final File [[provenance]] ) { String rootPath = [[provenance]] . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile [[iban]] = FindFile . create ( ) . includeDirs ( "[[Erroneous]]" != "[[Erroneous]]" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = [[iban]] . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "[[Erroneous]]" != "[[Erroneous]]" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 735 ---------------------------------------------
Returns the path from the filename . --> Returns null if filename doesn t exist --> Socre: 1.0

[[[[Adv]]]]: private static String [[doGetPath]] ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String [[mythology]] ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 736 ---------------------------------------------
Scan the given paths . --> Get the list of files to scan --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... [[paths]] ) { for ( final String [[path]] : [[paths]] ) { filesToScan . add ( new File ( [[path]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[shovelling]] ( final String ... [[router]] ) { for ( final String [[roadway]] : [[router]] ) { filesToScan . add ( new File ( [[roadway]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 737 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 647 / 70 / 20 / 737:  74%|███████▎  | 737/1000 [59:31<21:14,  4.85s/it][Succeeded / Failed / Skipped / Total] 647 / 70 / 20 / 737:  74%|███████▍  | 738/1000 [59:32<21:08,  4.84s/it][Succeeded / Failed / Skipped / Total] 648 / 70 / 20 / 738:  74%|███████▍  | 738/1000 [59:32<21:08,  4.84s/it][Succeeded / Failed / Skipped / Total] 648 / 70 / 20 / 738:  74%|███████▍  | 739/1000 [59:51<21:08,  4.86s/it][Succeeded / Failed / Skipped / Total] 649 / 70 / 20 / 739:  74%|███████▍  | 739/1000 [59:51<21:08,  4.86s/it][Succeeded / Failed / Skipped / Total] 649 / 70 / 20 / 739:  74%|███████▍  | 740/1000 [59:58<21:04,  4.86s/it][Succeeded / Failed / Skipped / Total] 649 / 71 / 20 / 740:  74%|███████▍  | 740/1000 [59:58<21:04,  4.86s/it][Succeeded / Failed / Skipped / Total] 649 / 71 / 20 / 740:  74%|███████▍  | 741/1000 [1:00:03<20:59,  4.86s/it][Succeeded / Failed / Skipped / Total] 650 / 71 / 20 / 741:  74%|███████▍  | 741/1000 [1:00:03<20:59,  4.86s/it][Succeeded / Failed / Skipped / Total] 650 / 71 / 20 / 741:  74%|███████▍  | 742/1000 [1:00:14<20:56,  4.87s/it][Succeeded / Failed / Skipped / Total] 651 / 71 / 20 / 742:  74%|███████▍  | 742/1000 [1:00:14<20:56,  4.87s/it][Succeeded / Failed / Skipped / Total] 651 / 71 / 20 / 742:  74%|███████▍  | 743/1000 [1:00:39<20:58,  4.90s/it][Succeeded / Failed / Skipped / Total] 652 / 71 / 20 / 743:  74%|███████▍  | 743/1000 [1:00:39<20:58,  4.90s/it][Succeeded / Failed / Skipped / Total] 652 / 71 / 20 / 743:  74%|███████▍  | 744/1000 [1:00:44<20:54,  4.90s/it][Succeeded / Failed / Skipped / Total] 653 / 71 / 20 / 744:  74%|███████▍  | 744/1000 [1:00:44<20:54,  4.90s/it][Succeeded / Failed / Skipped / Total] 653 / 71 / 20 / 744:  74%|███████▍  | 745/1000 [1:01:06<20:54,  4.92s/it]Sets the list of excluded entries . --> Exposed for testing --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... [[excludedEntries]] ) { for ( final String [[excludedEntry]] : [[excludedEntries]] ) { rulesEntries . exclude ( [[excludedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... [[combustible]] ) { for ( final String [[marked]] : [[combustible]] ) { rulesEntries . exclude ( [[marked]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 738 ---------------------------------------------
Sets the list of included entries . --> Gets the metadata for this class --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... [[includedEntries]] ) { for ( final String [[includedEntry]] : [[includedEntries]] ) { rulesEntries . include ( [[includedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[distresses]] ( final String ... [[comely]] ) { for ( final String [[gasa]] : [[comely]] ) { rulesEntries . include ( [[gasa]] ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 739 ---------------------------------------------
Creates a new JtxTransaction . --> region JtxTransaction --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction [[createNewTransaction]] ( final JtxTransactionMode [[tm]] , final Object [[scope]] , final boolean [[active]] ) { return new DbJtxTransaction ( this , [[tm]] , [[scope]] , [[active]] ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction [[vertically]] ( final JtxTransactionMode [[shan]] , final Object [[latitude]] , final boolean [[bustling]] ) { return new DbJtxTransaction ( this , [[shan]] , [[latitude]] , [[bustling]] ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 740 ---------------------------------------------
Returns the default scope type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 741 ---------------------------------------------
Adds scope for the given type . --> Set the MadvocScope --> Socre: 1.0

[[[[Adv]]]]: public void [[forScope]] ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void [[armful]] ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 742 ---------------------------------------------
Gets the MadvocScope for this class . --> Called by associates --> Socre: 1.0

[[[[Adv]]]]: protected MadvocScope [[getOrInitScope]] ( final Class < ? extends MadvocScope > [[madvocScopeType]] ) { for ( final MadvocScope [[s]] : allScopes ) { if ( [[s]] . getClass ( ) . equals ( [[madvocScopeType]] ) ) { return [[s]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope [[franziska]] ( final Class < ? extends MadvocScope > [[associates]] ) { for ( final MadvocScope [[at]] : allScopes ) { if ( [[at]] . getClass ( ) . equals ( [[associates]] ) ) { return [[at]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 743 ---------------------------------------------
Helper method to prepare the delimiter token . --> Helper method for prepareCsrfToken --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int [[timeToLive]] ) { Set < Token > [[tokenSet]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[tokenSet]] == null ) { [[tokenSet]] = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , [[tokenSet]] ) ; } String value ; boolean [[unique]] ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[tokenSet]] ) ; [[unique]] = [[tokenSet]] . add ( new Token ( value , [[timeToLive]] ) ) ; } while ( ! [[unique]] ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int [[taiwan]] ) { Set < Token > [[convicting]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[convicting]] == null ) { [[convicting]] = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , [[convicting]] ) ; } String value ; boolean [[unusual]] ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[convicting]] ) ; [[unusual]] = [[convicting]] . add ( new Token ( value , [[taiwan]] ) ) ; } while ( ! [[unusual]] ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 744 ---------------------------------------------
assure size . --> non - null non - null elements --> Socre: 1.0

[[[[Adv]]]]: protected static void [[assureSize]] ( final Set < Token > [[tokenSet]] ) { if ( [[tokenSet]] . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = [[tokenSet]] . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( [[tokenSet]] . size ( ) >= maxTokensPerSession ) ) { [[tokenSet]] . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void [[nonbeliever]] ( final Set < Token > [[involved]] ) { if ( [[involved]] . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = [[involved]] . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( [[involved]] . size ( ) >= maxTokensPerSession ) ) { [[involved]] . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 745 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 654 / 71 / 20 / 745:  74%|███████▍  | 745/1000 [1:01:06<20:54,  4.92s/it][Succeeded / Failed / Skipped / Total] 654 / 71 / 20 / 745:  75%|███████▍  | 746/1000 [1:01:10<20:49,  4.92s/it][Succeeded / Failed / Skipped / Total] 655 / 71 / 20 / 746:  75%|███████▍  | 746/1000 [1:01:10<20:49,  4.92s/it][Succeeded / Failed / Skipped / Total] 655 / 71 / 20 / 746:  75%|███████▍  | 747/1000 [1:01:16<20:45,  4.92s/it][Succeeded / Failed / Skipped / Total] 656 / 71 / 20 / 747:  75%|███████▍  | 747/1000 [1:01:16<20:45,  4.92s/it][Succeeded / Failed / Skipped / Total] 656 / 71 / 20 / 747:  75%|███████▍  | 748/1000 [1:01:18<20:39,  4.92s/it][Succeeded / Failed / Skipped / Total] 657 / 71 / 20 / 748:  75%|███████▍  | 748/1000 [1:01:18<20:39,  4.92s/it][Succeeded / Failed / Skipped / Total] 657 / 71 / 20 / 748:  75%|███████▍  | 749/1000 [1:01:21<20:33,  4.92s/it][Succeeded / Failed / Skipped / Total] 658 / 71 / 20 / 749:  75%|███████▍  | 749/1000 [1:01:21<20:33,  4.92s/it][Succeeded / Failed / Skipped / Total] 658 / 71 / 20 / 749:  75%|███████▌  | 750/1000 [1:01:23<20:27,  4.91s/it]Checks if the token is a valid token . --> Check if the session is valid --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > [[tokenSet]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( [[tokenSet]] == null ) && ( tokenValue == null ) ) { return "[[True]]" == "[[True]]" ; } if ( ( [[tokenSet]] == null ) || ( tokenValue == null ) ) { return "[[False]]" != "[[False]]" ; } boolean found = "[[False]]" != "[[False]]" ; Iterator < Token > [[it]] = [[tokenSet]] . iterator ( ) ; while ( [[it]] . hasNext ( ) ) { Token [[t]] = [[it]] . next ( ) ; if ( [[t]] . isExpired ( ) ) { [[it]] . remove ( ) ; continue ; } if ( [[t]] . getValue ( ) . equals ( tokenValue ) ) { [[it]] . remove ( ) ; found = "[[True]]" == "[[True]]" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > [[wilber]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( [[wilber]] == null ) && ( tokenValue == null ) ) { return "[[Accurate]]" == "[[Accurate]]" ; } if ( ( [[wilber]] == null ) || ( tokenValue == null ) ) { return "[[Misleading]]" != "[[Misleading]]" ; } boolean found = "[[Misleading]]" != "[[Misleading]]" ; Iterator < Token > [[el]] = [[wilber]] . iterator ( ) ; while ( [[el]] . hasNext ( ) ) { Token [[vos]] = [[el]] . next ( ) ; if ( [[vos]] . isExpired ( ) ) { [[el]] . remove ( ) ; continue ; } if ( [[vos]] . getValue ( ) . equals ( tokenValue ) ) { [[el]] . remove ( ) ; found = "[[Accurate]]" == "[[Accurate]]" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 746 ---------------------------------------------
Create a copy of the given object . --> Create BeanCopy from lineage --> Socre: 1.0

[[[[Adv]]]]: public static BeanCopy from ( final Object [[source]] ) { BeanCopy [[beanCopy]] = new BeanCopy ( [[source]] ) ; [[beanCopy]] . isSourceMap = [[source]] instanceof Map ; return [[beanCopy]] ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy from ( final Object [[lineage]] ) { BeanCopy [[amalia]] = new BeanCopy ( [[lineage]] ) ; [[amalia]] . isSourceMap = [[lineage]] instanceof Map ; return [[amalia]] ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 747 ---------------------------------------------
Copies the bean . --> Copy this bean --> Socre: 1.0

[[[[Adv]]]]: public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[True]]" == "[[True]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[Real]]" == "[[Real]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 748 ---------------------------------------------
Inject the uploaded files . --> Responsible for testing --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectUploadedFiles]] ( final HttpServletRequest [[servletRequest]] , final Targets targets ) { if ( ! ( [[servletRequest]] instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper [[multipartRequest]] = ( MultipartRequestWrapper ) [[servletRequest]] ; if ( ! [[multipartRequest]] . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = [[multipartRequest]] . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String [[paramName]] = paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( [[paramName]] ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( [[paramName]] ) ; if ( name != null ) { final FileUpload [ ] paramValues = [[multipartRequest]] . getFiles ( [[paramName]] ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload [[paramValue]] = paramValues [ j ] ; if ( ( ! [[paramValue]] . isValid ( ) ) || ( ! [[paramValue]] . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void [[remy]] ( final HttpServletRequest [[biodiversity]] , final Targets targets ) { if ( ! ( [[biodiversity]] instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper [[schramm]] = ( MultipartRequestWrapper ) [[biodiversity]] ; if ( ! [[schramm]] . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = [[schramm]] . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String [[tonga]] = paramNames . nextElement ( ) ; if ( [[biodiversity]] . getAttribute ( [[tonga]] ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( [[tonga]] ) ; if ( name != null ) { final FileUpload [ ] paramValues = [[schramm]] . getFiles ( [[tonga]] ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload [[harrah]] = paramValues [ j ] ; if ( ( ! [[harrah]] . isValid ( ) ) || ( ! [[harrah]] . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 749 ---------------------------------------------
Initializes the template data . --> Initialize the entity --> Socre: 1.0

[[[[Adv]]]]: @ Override public void init ( final TemplateData [[templateData]] ) { super . init ( [[templateData]] ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object [[object]] = [[templateData]] . getObjectReference ( entityName ) ; if ( [[object]] != null ) { ded = lookupType ( resolveClass ( [[object]] ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } [[templateData]] . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData [[hootenanny]] ) { super . init ( [[hootenanny]] ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object [[aiming]] = [[hootenanny]] . getObjectReference ( entityName ) ; if ( [[aiming]] != null ) { ded = lookupType ( resolveClass ( [[aiming]] ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } [[hootenanny]] . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 750 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 659 / 71 / 20 / 750:  75%|███████▌  | 750/1000 [1:01:23<20:27,  4.91s/it][Succeeded / Failed / Skipped / Total] 659 / 71 / 20 / 750:  75%|███████▌  | 751/1000 [1:01:30<20:23,  4.91s/it][Succeeded / Failed / Skipped / Total] 660 / 71 / 20 / 751:  75%|███████▌  | 751/1000 [1:01:30<20:23,  4.91s/it][Succeeded / Failed / Skipped / Total] 660 / 71 / 20 / 751:  75%|███████▌  | 752/1000 [1:01:58<20:26,  4.95s/it][Succeeded / Failed / Skipped / Total] 661 / 71 / 20 / 752:  75%|███████▌  | 752/1000 [1:01:58<20:26,  4.95s/it][Succeeded / Failed / Skipped / Total] 661 / 71 / 20 / 752:  75%|███████▌  | 753/1000 [1:02:02<20:21,  4.94s/it][Succeeded / Failed / Skipped / Total] 662 / 71 / 20 / 753:  75%|███████▌  | 753/1000 [1:02:02<20:21,  4.94s/it][Succeeded / Failed / Skipped / Total] 662 / 71 / 20 / 753:  75%|███████▌  | 754/1000 [1:02:11<20:17,  4.95s/it][Succeeded / Failed / Skipped / Total] 663 / 71 / 20 / 754:  75%|███████▌  | 754/1000 [1:02:11<20:17,  4.95s/it][Succeeded / Failed / Skipped / Total] 663 / 71 / 20 / 754:  76%|███████▌  | 755/1000 [1:02:24<20:15,  4.96s/it][Succeeded / Failed / Skipped / Total] 664 / 71 / 20 / 755:  76%|███████▌  | 755/1000 [1:02:24<20:15,  4.96s/it][Succeeded / Failed / Skipped / Total] 664 / 71 / 20 / 755:  76%|███████▌  | 756/1000 [1:02:29<20:10,  4.96s/it]Start files . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[path]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[path]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[waging]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[ways]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[ways]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 751 ---------------------------------------------
Visits a property . --> advices a denomination object --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean [[visitProperty]] ( String [[name]] , final Object value ) { if ( isTargetMap ) { [[name]] = LEFT_SQ_BRACKET + [[name]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[name]] , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean [[advices]] ( String [[denomination]] , final Object value ) { if ( isTargetMap ) { [[denomination]] = LEFT_SQ_BRACKET + [[denomination]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[denomination]] , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 752 ---------------------------------------------
Register a Bean --> Register a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition [[beanDefinition]] ) { beans . put ( name , [[beanDefinition]] ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = [[beanDefinition]] . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] [[interfaces]] = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : [[interfaces]] ) { String [[altName]] = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( [[altName]] ) ) { continue ; } if ( beans . containsKey ( [[altName]] ) ) { continue ; } if ( beansAlt . containsKey ( [[altName]] ) ) { BeanDefinition existing = beansAlt . get ( [[altName]] ) ; if ( existing != null ) { beansAlt . put ( [[altName]] , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition [[gratification]] ) { beans . put ( name , [[gratification]] ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = [[gratification]] . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] [[manque]] = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : [[manque]] ) { String [[equanimity]] = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( [[equanimity]] ) ) { continue ; } if ( beans . containsKey ( [[equanimity]] ) ) { continue ; } if ( beansAlt . containsKey ( [[equanimity]] ) ) { BeanDefinition existing = beansAlt . get ( [[equanimity]] ) ; if ( existing != null ) { beansAlt . put ( [[equanimity]] , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 753 ---------------------------------------------
Remove bean . --> Set the class kind --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[ganesh]] ( final Class [[kind]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 754 ---------------------------------------------
Registers a bean with the specified type . --> zira --> Socre: 1.0

[[[[Adv]]]]: public < T > BeanDefinition < T > [[registerPetiteBean]] ( final Class < T > [[type]] , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( [[type]] ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( [[type]] ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( [[type]] ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > [[zira]] ( final Class < T > [[dude]] , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( [[dude]] ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( [[dude]] ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( [[dude]] ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 755 ---------------------------------------------
Resolve bean names for a given type . --> returns orightwood --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[resolveBeanNamesForType]] ( final Class [[type]] ) { String [ ] [[beanNames]] = beanCollections . get ( [[type]] ) ; if ( [[beanNames]] != null ) { return [[beanNames]] ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[type]] ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { [[beanNames]] = StringPool . EMPTY_ARRAY ; } else { [[beanNames]] = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[type]] , [[beanNames]] ) ; return [[beanNames]] ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] [[cusack]] ( final Class [[types]] ) { String [ ] [[wrightwood]] = beanCollections . get ( [[types]] ) ; if ( [[wrightwood]] != null ) { return [[wrightwood]] ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[types]] ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { [[wrightwood]] = StringPool . EMPTY_ARRAY ; } else { [[wrightwood]] = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[types]] , [[wrightwood]] ) ; return [[wrightwood]] ; }
[[[[Nl]]]]: Resolves bean names for give type .
[Succeeded / Failed / Skipped / Total] 665 / 71 / 20 / 756:  76%|███████▌  | 756/1000 [1:02:29<20:10,  4.96s/it][Succeeded / Failed / Skipped / Total] 665 / 71 / 20 / 756:  76%|███████▌  | 757/1000 [1:02:32<20:04,  4.96s/it][Succeeded / Failed / Skipped / Total] 666 / 71 / 20 / 757:  76%|███████▌  | 757/1000 [1:02:32<20:04,  4.96s/it][Succeeded / Failed / Skipped / Total] 666 / 71 / 20 / 757:  76%|███████▌  | 758/1000 [1:02:39<20:00,  4.96s/it][Succeeded / Failed / Skipped / Total] 667 / 71 / 20 / 758:  76%|███████▌  | 758/1000 [1:02:39<20:00,  4.96s/it][Succeeded / Failed / Skipped / Total] 667 / 71 / 20 / 758:  76%|███████▌  | 759/1000 [1:02:42<19:54,  4.96s/it][Succeeded / Failed / Skipped / Total] 668 / 71 / 20 / 759:  76%|███████▌  | 759/1000 [1:02:42<19:54,  4.96s/it][Succeeded / Failed / Skipped / Total] 668 / 71 / 20 / 759:  76%|███████▌  | 760/1000 [1:02:44<19:48,  4.95s/it]--------------------------------------------- Result 756 ---------------------------------------------
Gets all the wrappers . --> Return the current active link --> Socre: 1.0

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > [[set]] = new HashSet <> ( wrappers . size ( ) ) ; [[set]] . addAll ( wrappers . values ( ) ) ; return [[set]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[moravia]] ( ) { final Set < T > [[settings]] = new HashSet <> ( wrappers . size ( ) ) ; [[settings]] . addAll ( wrappers . values ( ) ) ; return [[settings]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 757 ---------------------------------------------
Registers a set Injection Point --> Delete a property --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteSetInjectionPoint]] ( final String [[beanName]] , final String property ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; PropertyDescriptor propertyDescriptor = [[cd]] . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; [[beanDefinition]] . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void [[halftime]] ( final String [[resumé]] , final String property ) { BeanDefinition [[sentimental]] = lookupExistingBeanDefinition ( [[resumé]] ) ; ClassDescriptor [[vcd]] = ClassIntrospector . get ( ) . lookup ( [[sentimental]] . type ) ; PropertyDescriptor propertyDescriptor = [[vcd]] . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + [[sentimental]] . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; [[sentimental]] . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 758 ---------------------------------------------
Registers a method s Injection Point . --> measles a Bean --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteMethodInjectionPoint]] ( final String beanName , final String [[methodName]] , final Class [ ] [[arguments]] , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( [[arguments]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[methodName]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + [[methodName]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[methodName]] , [[arguments]] , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + [[methodName]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void [[measles]] ( final String beanName , final String [[detonator]] , final Class [ ] [[quarrels]] , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( [[quarrels]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[detonator]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + [[detonator]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[detonator]] , [[quarrels]] , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + [[detonator]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 759 ---------------------------------------------
Scan jar file . --> tuomas implementation --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanJarFile]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry [[zipEntry]] = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = [[zipEntry]] . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , [[zipEntry]] ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , [[zipEntry]] ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void [[tuomas]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry [[gigantor]] = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = [[gigantor]] . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , [[gigantor]] ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , [[gigantor]] ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 760 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 669 / 71 / 20 / 760:  76%|███████▌  | 760/1000 [1:02:44<19:48,  4.95s/it][Succeeded / Failed / Skipped / Total] 669 / 71 / 20 / 760:  76%|███████▌  | 761/1000 [1:03:05<19:48,  4.97s/it][Succeeded / Failed / Skipped / Total] 670 / 71 / 20 / 761:  76%|███████▌  | 761/1000 [1:03:05<19:48,  4.97s/it][Succeeded / Failed / Skipped / Total] 671 / 71 / 20 / 762:  76%|███████▌  | 762/1000 [1:03:05<19:42,  4.97s/it][Succeeded / Failed / Skipped / Total] 671 / 71 / 20 / 762:  76%|███████▋  | 763/1000 [1:03:08<19:36,  4.97s/it][Succeeded / Failed / Skipped / Total] 672 / 71 / 20 / 763:  76%|███████▋  | 763/1000 [1:03:08<19:36,  4.97s/it][Succeeded / Failed / Skipped / Total] 672 / 72 / 20 / 764:  76%|███████▋  | 764/1000 [1:03:17<19:33,  4.97s/it][Succeeded / Failed / Skipped / Total] 672 / 72 / 20 / 764:  76%|███████▋  | 765/1000 [1:03:21<19:27,  4.97s/it]Register destroyMethods . --> laughed a class --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteDestroyMethods]] ( final String [[beanName]] , String ... [[destroyMethodNames]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( [[destroyMethodNames]] == null ) { [[destroyMethodNames]] = StringPool . EMPTY_ARRAY ; } int [[total]] = [[destroyMethodNames]] . length ; DestroyMethodPoint [ ] [[destroyMethodPoints]] = new DestroyMethodPoint [ [[total]] ] ; int i ; for ( i = 0 ; i < [[destroyMethodNames]] . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( [[destroyMethodNames]] [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + [[destroyMethodNames]] [ i ] ) ; } [[destroyMethodPoints]] [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( [[destroyMethodPoints]] ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void [[laughed]] ( final String [[senegal]] , String ... [[extradition]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[senegal]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( [[extradition]] == null ) { [[extradition]] = StringPool . EMPTY_ARRAY ; } int [[worldwide]] = [[extradition]] . length ; DestroyMethodPoint [ ] [[levar]] = new DestroyMethodPoint [ [[worldwide]] ] ; int i ; for ( i = 0 ; i < [[extradition]] . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( [[extradition]] [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + [[extradition]] [ i ] ) ; } [[levar]] [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( [[levar]] ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 761 ---------------------------------------------
Register an optional injection point . --> Register a Wtor InjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String [[beanName]] , final Class [ ] [[paramTypes]] , final String [ ] references ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; Constructor [[constructor]] = null ; if ( [[paramTypes]] == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + [[beanDefinition]] . type . getName ( ) ) ; } [[constructor]] = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( [[paramTypes]] , "True" == "True" ) ; if ( ctorDescriptor != null ) { [[constructor]] = ctorDescriptor . getConstructor ( ) ; } } if ( [[constructor]] == null ) { throw new PetiteException ( "Constructor not found: " + [[beanDefinition]] . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( [[constructor]] , references ) ; [[beanDefinition]] . ctor = new CtorInjectionPoint ( [[constructor]] , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String [[multiples]] , final Class [ ] [[delphi]] , final String [ ] references ) { BeanDefinition [[sinful]] = lookupExistingBeanDefinition ( [[multiples]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[sinful]] . type ) ; Constructor [[strategists]] = null ; if ( [[delphi]] == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + [[sinful]] . type . getName ( ) ) ; } [[strategists]] = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( [[delphi]] , "True" == "True" ) ; if ( ctorDescriptor != null ) { [[strategists]] = ctorDescriptor . getConstructor ( ) ; } } if ( [[strategists]] == null ) { throw new PetiteException ( "Constructor not found: " + [[sinful]] . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( [[strategists]] , references ) ; [[sinful]] . ctor = new CtorInjectionPoint ( [[strategists]] , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 762 ---------------------------------------------
Returns the bytecode signature of the given type . --> Method to get the byte array from bloke --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class [[type]] ) { final String [[name]] = ' ' + [[type]] . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[name]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[maricón]] ( final Class [[bloke]] ) { final String [[named]] = ' ' + [[bloke]] . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[named]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 763 ---------------------------------------------
Iterate over bean type --> perpetua method --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[perpetua]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 764 ---------------------------------------------
Gets the property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 765 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 673 / 72 / 20 / 765:  76%|███████▋  | 765/1000 [1:03:21<19:27,  4.97s/it][Succeeded / Failed / Skipped / Total] 673 / 72 / 20 / 765:  77%|███████▋  | 766/1000 [1:03:33<19:24,  4.98s/it][Succeeded / Failed / Skipped / Total] 674 / 72 / 20 / 766:  77%|███████▋  | 766/1000 [1:03:33<19:24,  4.98s/it][Succeeded / Failed / Skipped / Total] 674 / 72 / 20 / 766:  77%|███████▋  | 767/1000 [1:03:36<19:19,  4.98s/it][Succeeded / Failed / Skipped / Total] 675 / 72 / 20 / 767:  77%|███████▋  | 767/1000 [1:03:36<19:19,  4.98s/it][Succeeded / Failed / Skipped / Total] 675 / 72 / 20 / 767:  77%|███████▋  | 768/1000 [1:03:39<19:13,  4.97s/it][Succeeded / Failed / Skipped / Total] 676 / 72 / 20 / 768:  77%|███████▋  | 768/1000 [1:03:39<19:13,  4.97s/it][Succeeded / Failed / Skipped / Total] 676 / 72 / 20 / 768:  77%|███████▋  | 769/1000 [1:03:41<19:07,  4.97s/it][Succeeded / Failed / Skipped / Total] 677 / 72 / 20 / 769:  77%|███████▋  | 769/1000 [1:03:41<19:07,  4.97s/it][Succeeded / Failed / Skipped / Total] 677 / 72 / 20 / 769:  77%|███████▋  | 770/1000 [1:03:52<19:04,  4.98s/it][Succeeded / Failed / Skipped / Total] 678 / 72 / 20 / 770:  77%|███████▋  | 770/1000 [1:03:52<19:04,  4.98s/it][Succeeded / Failed / Skipped / Total] 678 / 72 / 20 / 770:  77%|███████▋  | 771/1000 [1:03:55<18:59,  4.97s/it]Intercept the action request . --> Return the intersecting of the ActionRequest --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[intercept]] ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long [[startTime]] = System . currentTimeMillis ( ) ; Object [[result]] = null ; try { [[result]] = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { [[result]] = "<exception>" ; throw ex ; } catch ( Throwable th ) { [[result]] = "<throwable>" ; throw new Exception ( th ) ; } finally { long [[executionTime]] = System . currentTimeMillis ( ) - [[startTime]] ; printAfter ( [[actionRequest]] , [[executionTime]] , [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object [[intersecting]] ( final ActionRequest [[spotlight]] ) throws Exception { printBefore ( [[spotlight]] ) ; long [[tantamount]] = System . currentTimeMillis ( ) ; Object [[effect]] = null ; try { [[effect]] = [[spotlight]] . invoke ( ) ; } catch ( Exception ex ) { [[effect]] = "<exception>" ; throw ex ; } catch ( Throwable th ) { [[effect]] = "<throwable>" ; throw new Exception ( th ) ; } finally { long [[enlarge]] = System . currentTimeMillis ( ) - [[tantamount]] ; printAfter ( [[spotlight]] , [[enlarge]] , [[effect]] ) ; } return [[effect]] ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 766 ---------------------------------------------
Register a Property InjectionPoint . --> Adds a bean to the bean definition --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetitePropertyInjectionPoint]] ( final String beanName , final String [[property]] , final String [[reference]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = [[cd]] . getPropertyDescriptor ( [[property]] , "[[True]]" == "[[True]]" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[property]] ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , [[reference]] ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void [[hairbrush]] ( final String beanName , final String [[royalist]] , final String [[indicating]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[dz]] = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = [[dz]] . getPropertyDescriptor ( [[royalist]] , "[[Candid]]" == "[[Candid]]" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[royalist]] ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , [[indicating]] ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 767 ---------------------------------------------
Push a integer onto the stack . --> recovery recovery --> Socre: 1.0

[[[[Adv]]]]: public static void [[pushInt]] ( final MethodVisitor [[mv]] , final int [[value]] ) { if ( [[value]] <= 5 ) { [[mv]] . visitInsn ( ICONST_0 + [[value]] ) ; } else if ( [[value]] <= Byte . MAX_VALUE ) { [[mv]] . visitIntInsn ( BIPUSH , [[value]] ) ; } else { [[mv]] . visitIntInsn ( SIPUSH , [[value]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void [[fatih]] ( final MethodVisitor [[fim]] , final int [[valor]] ) { if ( [[valor]] <= 5 ) { [[fim]] . visitInsn ( ICONST_0 + [[valor]] ) ; } else if ( [[valor]] <= Byte . MAX_VALUE ) { [[fim]] . visitIntInsn ( BIPUSH , [[valor]] ) ; } else { [[fim]] . visitIntInsn ( SIPUSH , [[valor]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 768 ---------------------------------------------
Register a provider --> purifier a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String [[providerName]] , final String [[beanName]] , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( [[beanName]] ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + [[beanName]] ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "[[True]]" == "[[True]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[providerName]] , [[beanName]] , md . getMethod ( ) ) ; providers . put ( [[providerName]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void [[purifier]] ( final String [[appreciative]] , final String [[fonts]] , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( [[fonts]] ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + [[fonts]] ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "[[Faithful]]" == "[[Faithful]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[appreciative]] , [[fonts]] , md . getMethod ( ) ) ; providers . put ( [[appreciative]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 769 ---------------------------------------------
Define the parameters . --> filling the map of idiosyncrasies --> Socre: 1.0

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > [[properties]] ) { for ( Map . Entry < ? , ? > entry : [[properties]] . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[filling]] ( final Map < ? , ? > [[idiosyncrasies]] ) { for ( Map . Entry < ? , ? > entry : [[idiosyncrasies]] . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 770 ---------------------------------------------
advice method . --> Create a subs attribute --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String name , final int [[index]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[subs]] ( final String name , final int [[indication]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[indication]] ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 771 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 679 / 72 / 20 / 771:  77%|███████▋  | 771/1000 [1:03:55<18:59,  4.97s/it][Succeeded / Failed / Skipped / Total] 679 / 72 / 20 / 771:  77%|███████▋  | 772/1000 [1:03:58<18:53,  4.97s/it][Succeeded / Failed / Skipped / Total] 680 / 72 / 20 / 772:  77%|███████▋  | 772/1000 [1:03:58<18:53,  4.97s/it][Succeeded / Failed / Skipped / Total] 680 / 72 / 20 / 772:  77%|███████▋  | 773/1000 [1:04:02<18:48,  4.97s/it][Succeeded / Failed / Skipped / Total] 681 / 72 / 20 / 773:  77%|███████▋  | 773/1000 [1:04:02<18:48,  4.97s/it][Succeeded / Failed / Skipped / Total] 681 / 72 / 20 / 773:  77%|███████▋  | 774/1000 [1:04:09<18:43,  4.97s/it][Succeeded / Failed / Skipped / Total] 682 / 72 / 20 / 774:  77%|███████▋  | 774/1000 [1:04:09<18:43,  4.97s/it][Succeeded / Failed / Skipped / Total] 682 / 72 / 20 / 774:  78%|███████▊  | 775/1000 [1:04:09<18:37,  4.97s/it][Succeeded / Failed / Skipped / Total] 683 / 72 / 20 / 775:  78%|███████▊  | 775/1000 [1:04:09<18:37,  4.97s/it][Succeeded / Failed / Skipped / Total] 683 / 72 / 20 / 775:  78%|███████▊  | 776/1000 [1:04:09<18:31,  4.96s/it][Succeeded / Failed / Skipped / Total] 684 / 72 / 20 / 776:  78%|███████▊  | 776/1000 [1:04:09<18:31,  4.96s/it][Succeeded / Failed / Skipped / Total] 684 / 72 / 20 / 776:  78%|███████▊  | 777/1000 [1:04:14<18:26,  4.96s/it]Registers a new init method invocation . --> Add a moondust for the specified beanName --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteInitMethods]] ( final String beanName , final InitMethodInvocationStrategy [[invocationStrategy]] , String ... initMethodNames ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] [[initMethodPoints]] = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = [[cd]] . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } [[initMethodPoints]] [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , [[invocationStrategy]] ) ; } [[beanDefinition]] . addInitMethodPoints ( [[initMethodPoints]] ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void [[moondust]] ( final String beanName , final InitMethodInvocationStrategy [[nearing]] , String ... initMethodNames ) { BeanDefinition [[brings]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[albums]] = ClassIntrospector . get ( ) . lookup ( [[brings]] . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] [[cockerel]] = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = [[albums]] . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + [[brings]] . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } [[cockerel]] [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , [[nearing]] ) ; } [[brings]] . addInitMethodPoints ( [[cockerel]] ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 772 ---------------------------------------------
Register a provider . --> d4ithfully --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String providerName , final Class [[type]] , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[type]] ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , "[[True]]" == "[[True]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void [[dutchy]] ( final String providerName , final Class [[guys]] , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[guys]] ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , "[[Faithfully]]" == "[[Faithfully]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 773 ---------------------------------------------
Sets the argument index . --> Change ah for a method --> Socre: 1.0

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo methodInfo , final int [[argIndex]] ) { if ( ( [[argIndex]] < 1 ) || ( [[argIndex]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[argIndex]] ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[subversives]] ( final MethodInfo methodInfo , final int [[ah]] ) { if ( ( [[ah]] < 1 ) || ( [[ah]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[ah]] ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 774 ---------------------------------------------
Load the arguments . --> Fuegt ein --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadVirtualMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { for ( int [[i]] = 1 ; [[i]] <= methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void [[dental]] ( final MethodVisitor [[spaceship]] , final MethodInfo methodInfo ) { for ( int [[eh]] = 1 ; [[eh]] <= methodInfo . getArgumentsCount ( ) ; [[eh]] ++ ) { loadMethodArgument ( [[spaceship]] , methodInfo , [[eh]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 775 ---------------------------------------------
Returns a field with the specified name and index . --> Calculates the Azure part of a cloud --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String [[name]] , final int [[index]] ) { return ProxettaNames . fieldPrefix + [[name]] + ProxettaNames . fieldDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[halyard]] ( final String [[sake]] , final int [[catalogued]] ) { return ProxettaNames . fieldPrefix + [[sake]] + ProxettaNames . fieldDivider + [[catalogued]] ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 776 ---------------------------------------------
Load the static method arguments . --> break the rectangle --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { for ( int [[i]] = 0 ; [[i]] < [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[breakfasts]] ( final MethodVisitor [[hms]] , final MethodInfo [[rectangle]] ) { for ( int [[could]] = 0 ; [[could]] < [[rectangle]] . getArgumentsCount ( ) ; [[could]] ++ ) { loadMethodArgument ( [[hms]] , [[rectangle]] , [[could]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 777 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 685 / 72 / 20 / 777:  78%|███████▊  | 777/1000 [1:04:14<18:26,  4.96s/it][Succeeded / Failed / Skipped / Total] 685 / 72 / 20 / 777:  78%|███████▊  | 778/1000 [1:04:18<18:20,  4.96s/it][Succeeded / Failed / Skipped / Total] 686 / 72 / 20 / 778:  78%|███████▊  | 778/1000 [1:04:18<18:20,  4.96s/it][Succeeded / Failed / Skipped / Total] 687 / 72 / 20 / 779:  78%|███████▊  | 779/1000 [1:04:18<18:14,  4.95s/it][Succeeded / Failed / Skipped / Total] 688 / 72 / 20 / 780:  78%|███████▊  | 780/1000 [1:04:18<18:08,  4.95s/it][Succeeded / Failed / Skipped / Total] 688 / 72 / 20 / 780:  78%|███████▊  | 781/1000 [1:04:20<18:02,  4.94s/it][Succeeded / Failed / Skipped / Total] 689 / 72 / 20 / 781:  78%|███████▊  | 781/1000 [1:04:20<18:02,  4.94s/it][Succeeded / Failed / Skipped / Total] 690 / 72 / 20 / 782:  78%|███████▊  | 782/1000 [1:04:20<17:56,  4.94s/it]Prepares the return value . --> casting to type --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , int [[varOffset]] ) { [[varOffset]] += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[casting]] ( final MethodVisitor [[britannic]] , final MethodInfo [[sweetwater]] , int [[recruited]] ) { [[recruited]] += [[sweetwater]] . getAllArgumentsSize ( ) ; switch ( [[sweetwater]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[britannic]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[britannic]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[britannic]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[britannic]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[britannic]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[britannic]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[britannic]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[britannic]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[britannic]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 778 ---------------------------------------------
Load method argument . --> Computes the britannic optimization --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , final int [[index]] ) { int [[offset]] = [[methodInfo]] . getArgumentOffset ( [[index]] ) ; int type = [[methodInfo]] . getArgument ( [[index]] ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[mv]] . visitVarInsn ( ILOAD , [[offset]] ) ; break ; case ' ' : [[mv]] . visitVarInsn ( LLOAD , [[offset]] ) ; break ; case ' ' : [[mv]] . visitVarInsn ( FLOAD , [[offset]] ) ; break ; case ' ' : [[mv]] . visitVarInsn ( DLOAD , [[offset]] ) ; break ; default : [[mv]] . visitVarInsn ( ALOAD , [[offset]] ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[immature]] ( final MethodVisitor [[britannic]] , final MethodInfo [[panzer]] , final int [[forefinger]] ) { int [[thwarted]] = [[panzer]] . getArgumentOffset ( [[forefinger]] ) ; int type = [[panzer]] . getArgument ( [[forefinger]] ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[britannic]] . visitVarInsn ( ILOAD , [[thwarted]] ) ; break ; case ' ' : [[britannic]] . visitVarInsn ( LLOAD , [[thwarted]] ) ; break ; case ' ' : [[britannic]] . visitVarInsn ( FLOAD , [[thwarted]] ) ; break ; case ' ' : [[britannic]] . visitVarInsn ( DLOAD , [[thwarted]] ) ; break ; default : [[britannic]] . visitVarInsn ( ALOAD , [[thwarted]] ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 779 ---------------------------------------------
Resolves the Java version . --> Returns the yumi of the printout --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int [[javaVersionNumber]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[platformVersion]] = [[javaVersionNumber]] - 8 + 52 ; return [[version]] > [[platformVersion]] ? [[version]] : [[platformVersion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[visage]] ( final int [[printout]] ) { final int [[jackrabbits]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[yumi]] = [[jackrabbits]] - 8 + 52 ; return [[printout]] > [[yumi]] ? [[printout]] : [[yumi]] ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 780 ---------------------------------------------
Create a signature key for a method signature . --> Appends the seishin string --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int [[access]] , final String [[methodName]] , final String [[description]] , final String [[className]] ) { return new StringBand ( 7 ) . append ( [[access]] ) . append ( COLON ) . append ( [[description]] ) . append ( StringPool . UNDERSCORE ) . append ( [[className]] ) . append ( StringPool . HASH ) . append ( [[methodName]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[seishin]] ( final int [[input]] , final String [[shifts]] , final String [[depicted]] , final String [[vrai]] ) { return new StringBand ( 7 ) . append ( [[input]] ) . append ( COLON ) . append ( [[depicted]] ) . append ( StringPool . UNDERSCORE ) . append ( [[vrai]] ) . append ( StringPool . HASH ) . append ( [[shifts]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 781 ---------------------------------------------
Store a method argument . --> looks for collared method of given type --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeMethodArgument]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int [[index]] ) { int offset = methodInfo . getArgumentOffset ( [[index]] ) ; int type = methodInfo . getArgument ( [[index]] ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[collared]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int [[catalogued]] ) { int offset = methodInfo . getArgumentOffset ( [[catalogued]] ) ; int type = methodInfo . getArgument ( [[catalogued]] ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 782 ---------------------------------------------
Returns the encoding for the given content type . --> Returns the maintenance of the acety --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String [[contentType]] , String defaultEncoding ) { String [[encoding]] = [[extractEncoding]] ( [[contentType]] ) ; if ( [[encoding]] == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } [[encoding]] = defaultEncoding ; } return [[encoding]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[blackfeet]] ( final String [[acetylene]] , String defaultEncoding ) { String [[maintenance]] = [[blackfeet]] ( [[acetylene]] ) ; if ( [[maintenance]] == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } [[maintenance]] = defaultEncoding ; } return [[maintenance]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
[Succeeded / Failed / Skipped / Total] 691 / 72 / 20 / 783:  78%|███████▊  | 783/1000 [1:04:20<17:49,  4.93s/it][Succeeded / Failed / Skipped / Total] 691 / 72 / 20 / 783:  78%|███████▊  | 784/1000 [1:04:21<17:44,  4.93s/it][Succeeded / Failed / Skipped / Total] 692 / 72 / 20 / 784:  78%|███████▊  | 784/1000 [1:04:21<17:44,  4.93s/it][Succeeded / Failed / Skipped / Total] 693 / 72 / 20 / 785:  78%|███████▊  | 785/1000 [1:04:22<17:37,  4.92s/it][Succeeded / Failed / Skipped / Total] 694 / 72 / 20 / 786:  79%|███████▊  | 786/1000 [1:04:23<17:31,  4.91s/it][Succeeded / Failed / Skipped / Total] 694 / 72 / 20 / 786:  79%|███████▊  | 787/1000 [1:04:31<17:27,  4.92s/it][Succeeded / Failed / Skipped / Total] 695 / 72 / 20 / 787:  79%|███████▊  | 787/1000 [1:04:31<17:27,  4.92s/it][Succeeded / Failed / Skipped / Total] 696 / 72 / 20 / 788:  79%|███████▉  | 788/1000 [1:04:37<17:23,  4.92s/it]--------------------------------------------- Result 783 ---------------------------------------------
Load arguments . --> Generates a shimla expression --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { [[mv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int [[i]] = 1 ; [[i]] <= [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[shimla]] ( final MethodVisitor [[chitra]] , final MethodInfo [[idiom]] ) { [[chitra]] . visitVarInsn ( ALOAD , 0 ) ; for ( int [[huh]] = 1 ; [[huh]] <= [[idiom]] . getArgumentsCount ( ) ; [[huh]] ++ ) { loadMethodArgument ( [[chitra]] , [[idiom]] , [[huh]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 784 ---------------------------------------------
Require authentication . --> Create a dominator --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse [[resp]] , final String [[realm]] ) throws IOException { [[resp]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + [[realm]] + ' ' ) ; [[resp]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[dominator]] ( final HttpServletResponse [[courier]] , final String [[campos]] ) throws IOException { [[courier]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + [[campos]] + ' ' ) ; [[courier]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 785 ---------------------------------------------
Store into array . --> implements the visitor to look for counters --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[countersign]] ( final MethodVisitor mv , final Class [[assi]] ) { if ( [[assi]] == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( [[assi]] == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( [[assi]] == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( [[assi]] == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( [[assi]] == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[assi]] == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( [[assi]] == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[assi]] == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 786 ---------------------------------------------
Resolves a cookie token . --> Get a moonless string from the request --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest [[request]] ) { String [[header]] = [[request]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[header]] == null ) { return null ; } int [[ndx]] = [[header]] . indexOf ( "Bearer " ) ; if ( [[ndx]] == - 1 ) { return null ; } return [[header]] . substring ( [[ndx]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[moonless]] ( final HttpServletRequest [[invitation]] ) { String [[pennant]] = [[invitation]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[pennant]] == null ) { return null ; } int [[transferring]] = [[pennant]] . indexOf ( "Bearer " ) ; if ( [[transferring]] == - 1 ) { return null ; } return [[pennant]] . substring ( [[transferring]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 787 ---------------------------------------------
Checks if the flags contain any flags . --> Capantic Method . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags [[flags]] ) { if ( [[flags]] == null ) return "True" == "True" ; Flags . Flag [ ] [[systemFlags]] = [[flags]] . getSystemFlags ( ) ; if ( [[systemFlags]] != null && [[systemFlags]] . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[flags]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[romantic]] ( Flags [[posters]] ) { if ( [[posters]] == null ) return "True" == "True" ; Flags . Flag [ ] [[cords]] = [[posters]] . getSystemFlags ( ) ; if ( [[cords]] != null && [[cords]] . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[posters]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 788 ---------------------------------------------
Reads a string from the request . --> Generate a genial message --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromStream]] ( final HttpServletRequest [[request]] ) throws IOException { String [[charEncoding]] = [[request]] . getCharacterEncoding ( ) ; if ( [[charEncoding]] == null ) { [[charEncoding]] = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader [[bufferedReader]] = null ; try { InputStream [[inputStream]] = [[request]] . getInputStream ( ) ; if ( [[inputStream]] != null ) { [[bufferedReader]] = new BufferedReader ( new InputStreamReader ( [[inputStream]] , [[charEncoding]] ) ) ; StreamUtil . copy ( [[bufferedReader]] , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( [[bufferedReader]] ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[genial]] ( final HttpServletRequest [[praying]] ) throws IOException { String [[vitello]] = [[praying]] . getCharacterEncoding ( ) ; if ( [[vitello]] == null ) { [[vitello]] = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader [[os]] = null ; try { InputStream [[roquefort]] = [[praying]] . getInputStream ( ) ; if ( [[roquefort]] != null ) { [[os]] = new BufferedReader ( new InputStreamReader ( [[roquefort]] , [[vitello]] ) ) ; StreamUtil . copy ( [[os]] , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( [[os]] ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 789 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 697 / 72 / 20 / 789:  79%|███████▉  | 789/1000 [1:04:39<17:17,  4.92s/it][Succeeded / Failed / Skipped / Total] 697 / 72 / 20 / 789:  79%|███████▉  | 790/1000 [1:04:42<17:12,  4.91s/it][Succeeded / Failed / Skipped / Total] 698 / 72 / 20 / 790:  79%|███████▉  | 790/1000 [1:04:42<17:12,  4.91s/it][Succeeded / Failed / Skipped / Total] 698 / 72 / 20 / 790:  79%|███████▉  | 791/1000 [1:04:43<17:06,  4.91s/it][Succeeded / Failed / Skipped / Total] 699 / 72 / 20 / 791:  79%|███████▉  | 791/1000 [1:04:43<17:06,  4.91s/it][Succeeded / Failed / Skipped / Total] 699 / 72 / 20 / 791:  79%|███████▉  | 792/1000 [1:04:47<17:00,  4.91s/it][Succeeded / Failed / Skipped / Total] 700 / 72 / 20 / 792:  79%|███████▉  | 792/1000 [1:04:47<17:00,  4.91s/it][Succeeded / Failed / Skipped / Total] 700 / 72 / 20 / 792:  79%|███████▉  | 793/1000 [1:04:47<16:54,  4.90s/it][Succeeded / Failed / Skipped / Total] 701 / 72 / 20 / 793:  79%|███████▉  | 793/1000 [1:04:47<16:54,  4.90s/it][Succeeded / Failed / Skipped / Total] 701 / 72 / 20 / 793:  79%|███████▉  | 794/1000 [1:04:49<16:49,  4.90s/it][Succeeded / Failed / Skipped / Total] 702 / 72 / 20 / 794:  79%|███████▉  | 794/1000 [1:04:49<16:49,  4.90s/it][Succeeded / Failed / Skipped / Total] 702 / 72 / 20 / 794:  80%|███████▉  | 795/1000 [1:04:50<16:43,  4.89s/it]Stores the context path . --> Set the historians attribute --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void [[historians]] ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 790 ---------------------------------------------
Store context path . --> Add owned method --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void [[owned]] ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 791 ---------------------------------------------
Prepare response . --> prepare the HttpServletResponse --> Socre: 1.0

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse response , final String [[fileName]] , String [[mimeType]] , final int [[fileSize]] ) { if ( ( [[mimeType]] == null ) && ( [[fileName]] != null ) ) { String [[extension]] = FileNameUtil . getExtension ( [[fileName]] ) ; [[mimeType]] = MimeTypes . getMimeType ( [[extension]] ) ; } if ( [[mimeType]] != null ) { response . setContentType ( [[mimeType]] ) ; } if ( [[fileSize]] >= 0 ) { response . setContentLength ( [[fileSize]] ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse response , final String [[liquored]] , String [[campo]] , final int [[unmade]] ) { if ( ( [[campo]] == null ) && ( [[liquored]] != null ) ) { String [[enlarge]] = FileNameUtil . getExtension ( [[liquored]] ) ; [[campo]] = MimeTypes . getMimeType ( [[enlarge]] ) ; } if ( [[campo]] != null ) { response . setContentType ( [[campo]] ) ; } if ( [[unmade]] >= 0 ) { response . setContentLength ( [[unmade]] ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 792 ---------------------------------------------
Prepares parameters . --> Given an array of strings return its array as array of strings --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] [[prepareParameters]] ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean [[ignoreEmptyRequestParams]] ) { if ( treatEmptyParamsAsNull || [[ignoreEmptyRequestParams]] ) { int emptyCount = 0 ; int [[total]] = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( [[ignoreEmptyRequestParams]] ) && ( emptyCount == [[total]] ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] [[sofia]] ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean [[honduras]] ) { if ( treatEmptyParamsAsNull || [[honduras]] ) { int emptyCount = 0 ; int [[entirety]] = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( [[honduras]] ) && ( emptyCount == [[entirety]] ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 793 ---------------------------------------------
Read the contents of an HTTP request into a string . --> Create a brotha string --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest [[request]] ) throws IOException { BufferedReader buff = [[request]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[brotha]] ( final HttpServletRequest [[poser]] ) throws IOException { BufferedReader buff = [[poser]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 794 ---------------------------------------------
Method newArray method . --> Create the value of the class --> Socre: 1.0

[[[[Adv]]]]: public static void newArray ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[componentType]] ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void newArray ( final MethodVisitor mv , final Class [[erased]] ) { if ( [[erased]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[erased]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[erased]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[erased]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[erased]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[erased]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[erased]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[erased]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[erased]] ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 795 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 703 / 72 / 20 / 795:  80%|███████▉  | 795/1000 [1:04:50<16:43,  4.89s/it][Succeeded / Failed / Skipped / Total] 704 / 72 / 20 / 796:  80%|███████▉  | 796/1000 [1:04:50<16:37,  4.89s/it][Succeeded / Failed / Skipped / Total] 704 / 72 / 20 / 796:  80%|███████▉  | 797/1000 [1:04:51<16:31,  4.88s/it][Succeeded / Failed / Skipped / Total] 705 / 72 / 20 / 797:  80%|███████▉  | 797/1000 [1:04:51<16:31,  4.88s/it][Succeeded / Failed / Skipped / Total] 706 / 72 / 20 / 798:  80%|███████▉  | 798/1000 [1:04:51<16:25,  4.88s/it][Succeeded / Failed / Skipped / Total] 706 / 72 / 20 / 798:  80%|███████▉  | 799/1000 [1:04:52<16:19,  4.87s/it][Succeeded / Failed / Skipped / Total] 707 / 72 / 20 / 799:  80%|███████▉  | 799/1000 [1:04:52<16:19,  4.87s/it][Succeeded / Failed / Skipped / Total] 708 / 72 / 20 / 800:  80%|████████  | 800/1000 [1:04:53<16:13,  4.87s/it][Succeeded / Failed / Skipped / Total] 708 / 72 / 20 / 800:  80%|████████  | 801/1000 [1:04:56<16:07,  4.86s/it][Succeeded / Failed / Skipped / Total] 709 / 72 / 20 / 801:  80%|████████  | 801/1000 [1:04:56<16:07,  4.86s/it]Decodes a byte array . --> UTF - 8 --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[decode]] ( final char [ ] [[arr]] ) { int length = [[arr]] . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = [[arr]] [ endx ] == ' ' ? ( [[arr]] [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( [[arr]] [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ [[arr]] [ sndx ++ ] ] << 18 | INV [ [[arr]] [ sndx ++ ] ] << 12 | INV [ [[arr]] [ sndx ++ ] ] << 6 | INV [ [[arr]] [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ [[arr]] [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] [[charades]] ( final char [ ] [[clete]] ) { int length = [[clete]] . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = [[clete]] [ endx ] == ' ' ? ( [[clete]] [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( [[clete]] [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ [[clete]] [ sndx ++ ] ] << 18 | INV [ [[clete]] [ sndx ++ ] ] << 12 | INV [ [[clete]] [ sndx ++ ] ] << 6 | INV [ [[clete]] [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ [[clete]] [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 796 ---------------------------------------------
Returns true if the specified parameter is part of the request . --> tactile method --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isGetParameter]] ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean [[tactile]] ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 797 ---------------------------------------------
Calls the given body . --> exponential from JspFragment --> Socre: 1.0

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment [[body]] ) throws JspException { if ( [[body]] == null ) { return ; } try { [[body]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[exponential]] ( final JspFragment [[agency]] ) throws JspException { if ( [[agency]] == null ) { return ; } try { [[agency]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 798 ---------------------------------------------
Renders the body to string . --> Convenience method for callingook --> Socre: 1.0

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment [[body]] ) throws JspException { char [ ] [[result]] = renderBody ( [[body]] ) ; return new String ( [[result]] ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[spook]] ( final JspFragment [[institutions]] ) throws JspException { char [ ] [[outcomes]] = renderBody ( [[institutions]] ) ; return new String ( [[outcomes]] ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 799 ---------------------------------------------
Invokes init methods . --> Method to ease the bean --> Socre: 1.0

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy [[invocationStrategy]] ) { for ( final InitMethodPoint [[initMethod]] : beanDefinition . initMethodPoints ( ) ) { if ( [[invocationStrategy]] != [[initMethod]] . invocationStrategy ) { continue ; } try { [[initMethod]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[initMethod]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[ease]] ( final InitMethodInvocationStrategy [[ply]] ) { for ( final InitMethodPoint [[eggman]] : beanDefinition . initMethodPoints ( ) ) { if ( [[ply]] != [[eggman]] . invocationStrategy ) { continue ; } try { [[eggman]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[eggman]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 800 ---------------------------------------------
Gets all cookies . --> lil a cookie --> Socre: 1.0

[[[[Adv]]]]: public static Cookie [ ] [[getAllCookies]] ( final HttpServletRequest [[request]] , final String cookieName ) { Cookie [ ] [[cookies]] = [[request]] . getCookies ( ) ; if ( [[cookies]] == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( [[cookies]] . length ) ; for ( Cookie [[cookie]] : [[cookies]] ) { if ( [[cookie]] . getName ( ) . equals ( cookieName ) ) { list . add ( [[cookie]] ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] [[lil]] ( final HttpServletRequest [[requiring]] , final String cookieName ) { Cookie [ ] [[bakery]] = [[requiring]] . getCookies ( ) ; if ( [[bakery]] == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( [[bakery]] . length ) ; for ( Cookie [[flake]] : [[bakery]] ) { if ( [[flake]] . getName ( ) . equals ( cookieName ) ) { list . add ( [[flake]] ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 801 ---------------------------------------------
Render the body . --> Returns the cecile of the given JspFragment --> Socre: 1.0

[[[[Adv]]]]: public static char [ ] [[renderBody]] ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] [[cecile]] ( final JspFragment [[authorities]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[authorities]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 802 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 710 / 72 / 20 / 802:  80%|████████  | 802/1000 [1:04:59<16:02,  4.86s/it][Succeeded / Failed / Skipped / Total] 710 / 72 / 20 / 802:  80%|████████  | 803/1000 [1:05:00<15:56,  4.86s/it][Succeeded / Failed / Skipped / Total] 711 / 72 / 20 / 803:  80%|████████  | 803/1000 [1:05:00<15:56,  4.86s/it][Succeeded / Failed / Skipped / Total] 712 / 72 / 20 / 804:  80%|████████  | 804/1000 [1:05:02<15:51,  4.85s/it][Succeeded / Failed / Skipped / Total] 712 / 72 / 20 / 804:  80%|████████  | 805/1000 [1:05:04<15:45,  4.85s/it][Succeeded / Failed / Skipped / Total] 713 / 72 / 20 / 805:  80%|████████  | 805/1000 [1:05:04<15:45,  4.85s/it][Succeeded / Failed / Skipped / Total] 714 / 72 / 20 / 806:  81%|████████  | 806/1000 [1:05:04<15:39,  4.84s/it][Succeeded / Failed / Skipped / Total] 714 / 72 / 20 / 806:  81%|████████  | 807/1000 [1:05:06<15:34,  4.84s/it][Succeeded / Failed / Skipped / Total] 715 / 72 / 20 / 807:  81%|████████  | 807/1000 [1:05:06<15:34,  4.84s/it][Succeeded / Failed / Skipped / Total] 716 / 72 / 20 / 808:  81%|████████  | 808/1000 [1:05:09<15:28,  4.84s/it][Succeeded / Failed / Skipped / Total] 716 / 72 / 20 / 808:  81%|████████  | 809/1000 [1:05:09<15:23,  4.83s/it][Succeeded / Failed / Skipped / Total] 717 / 72 / 20 / 809:  81%|████████  | 809/1000 [1:05:09<15:23,  4.83s/it][Succeeded / Failed / Skipped / Total] 718 / 72 / 20 / 810:  81%|████████  | 810/1000 [1:05:10<15:17,  4.83s/it][Succeeded / Failed / Skipped / Total] 718 / 72 / 20 / 810:  81%|████████  | 811/1000 [1:05:11<15:11,  4.82s/it]Inject parameters . --> Unint the bean --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager [[paramManager]] , final boolean [[implicitParamInjection]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[implicitParamInjection]] ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[uncut]] ( final ParamManager [[melba]] , final boolean [[lobo]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[lobo]] ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 803 ---------------------------------------------
Put a new entry in the map . --> Add a new entry . --> Socre: 1.0

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > [[map]] , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = [[map]] . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > [[mapmaker]] , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = [[mapmaker]] . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 804 ---------------------------------------------
newBeanInstance Method . --> Same as discrepancies --> Socre: 1.0

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int [[paramNo]] = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ [[paramNo]] ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[discrepancies]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int [[julietta]] = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ [[julietta]] ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 805 ---------------------------------------------
Calls destroy methods . --> Begins the bean --> Socre: 1.0

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint [[destroyMethodPoint]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[destroyMethodPoint]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[destroyMethodPoint]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[baptisms]] ( ) { for ( final DestroyMethodPoint [[magnetic]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[magnetic]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[magnetic]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 806 ---------------------------------------------
Put profile properties . --> Put a value into the list --> Socre: 1.0

[[[[Adv]]]]: public void [[putProfileProperty]] ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void [[tourniquet]] ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 807 ---------------------------------------------
Resolves a slash . --> Gets a portion of the value --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String value , final String ... [[profiles]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[schoolteacher]] ( String value , final String ... [[portrayal]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 808 ---------------------------------------------
Adds a new header value . --> Methode d a nomenclature element --> Socre: 1.0

[[[[Adv]]]]: public void [[addHeader]] ( final String [[name]] , final String [[value]] ) { List < String > valuesList = super . getAll ( [[name]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[name]] , [[value]] ) ; return ; } super . remove ( [[name]] ) ; valuesList . add ( [[value]] ) ; super . addAll ( [[name]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[cezanne]] ( final String [[nomenclature]] , final String [[valued]] ) { List < String > valuesList = super . getAll ( [[nomenclature]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[nomenclature]] , [[valued]] ) ; return ; } super . remove ( [[nomenclature]] ) ; valuesList . add ( [[valued]] ) ; super . addAll ( [[nomenclature]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 809 ---------------------------------------------
Get profile properties . --> Wait for a photograph entry --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String [[profile]] , final String [[key]] ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( [[profile]] ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( [[key]] ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[waited]] ( final String [[photograph]] , final String [[wrenches]] ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( [[photograph]] ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( [[wrenches]] ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 810 ---------------------------------------------
Add base property . --> A convenience method for burdensome --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String [[key]] , final String [[value]] , final boolean [[append]] ) { put ( null , baseProperties , [[key]] , [[value]] , [[append]] ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[burdensome]] ( final String [[transcendental]] , final String [[merited]] , final boolean [[liliana]] ) { put ( null , baseProperties , [[transcendental]] , [[merited]] , [[liliana]] ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 811 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 718 / 73 / 20 / 811:  81%|████████  | 811/1000 [1:05:11<15:11,  4.82s/it][Succeeded / Failed / Skipped / Total] 719 / 73 / 20 / 812:  81%|████████  | 812/1000 [1:05:12<15:05,  4.82s/it][Succeeded / Failed / Skipped / Total] 719 / 73 / 20 / 812:  81%|████████▏ | 813/1000 [1:05:14<15:00,  4.82s/it][Succeeded / Failed / Skipped / Total] 720 / 73 / 20 / 813:  81%|████████▏ | 813/1000 [1:05:14<15:00,  4.82s/it][Succeeded / Failed / Skipped / Total] 721 / 73 / 20 / 814:  81%|████████▏ | 814/1000 [1:05:16<14:54,  4.81s/it][Succeeded / Failed / Skipped / Total] 721 / 73 / 20 / 814:  82%|████████▏ | 815/1000 [1:05:16<14:48,  4.81s/it][Succeeded / Failed / Skipped / Total] 722 / 73 / 20 / 815:  82%|████████▏ | 815/1000 [1:05:16<14:48,  4.81s/it][Succeeded / Failed / Skipped / Total] 723 / 73 / 20 / 816:  82%|████████▏ | 816/1000 [1:05:19<14:43,  4.80s/it][Succeeded / Failed / Skipped / Total] 723 / 73 / 20 / 816:  82%|████████▏ | 817/1000 [1:05:20<14:38,  4.80s/it][Succeeded / Failed / Skipped / Total] 724 / 73 / 20 / 817:  82%|████████▏ | 817/1000 [1:05:20<14:38,  4.80s/it]Resolve a scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 812 ---------------------------------------------
Copies parameters to attributes . --> F743 - 5 --> Socre: 1.0

[[[[Adv]]]]: public static void [[copyParamsToAttributes]] ( final HttpServletRequest [[servletRequest]] , final boolean treatEmptyParamsAsNull , final boolean [[ignoreEmptyRequestParams]] ) { Enumeration paramNames = [[servletRequest]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( paramName ) != null ) { continue ; } String [ ] [[paramValues]] = [[servletRequest]] . getParameterValues ( paramName ) ; [[paramValues]] = prepareParameters ( [[paramValues]] , treatEmptyParamsAsNull , [[ignoreEmptyRequestParams]] ) ; if ( [[paramValues]] == null ) { continue ; } [[servletRequest]] . setAttribute ( paramName , [[paramValues]] . length == 1 ? [[paramValues]] [ 0 ] : [[paramValues]] ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void [[fresco]] ( final HttpServletRequest [[armani]] , final boolean treatEmptyParamsAsNull , final boolean [[eighties]] ) { Enumeration paramNames = [[armani]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( [[armani]] . getAttribute ( paramName ) != null ) { continue ; } String [ ] [[counseling]] = [[armani]] . getParameterValues ( paramName ) ; [[counseling]] = prepareParameters ( [[counseling]] , treatEmptyParamsAsNull , [[eighties]] ) ; if ( [[counseling]] == null ) { continue ; } [[armani]] . setAttribute ( paramName , [[counseling]] . length == 1 ? [[counseling]] [ 0 ] : [[counseling]] ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 813 ---------------------------------------------
Encodes the first 4 word in the byte array --> This method is called by the streamtoword method --> Socre: 1.0

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int [[word]] = 0 ; int [[off]] = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { [[word]] = ( [[word]] << 8 ) | ( data [ [[off]] ] & 0xff ) ; [[off]] = ( [[off]] + 1 ) % data . length ; } offp [ 0 ] = [[off]] ; return [[word]] ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int [[terminology]] = 0 ; int [[rewire]] = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { [[terminology]] = ( [[terminology]] << 8 ) | ( data [ [[rewire]] ] & 0xff ) ; [[rewire]] = ( [[rewire]] + 1 ) % data . length ; } offp [ 0 ] = [[rewire]] ; return [[terminology]] ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 814 ---------------------------------------------
Rewrite the action path . --> Rewrite the HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest [[servletRequest]] , final String [[actionPath]] , final String httpMethod ) { return [[actionPath]] ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest [[portraiture]] , final String [[vision]] , final String httpMethod ) { return [[vision]] ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 815 ---------------------------------------------
Helper method to extract a map . --> Computes the extracting view --> Socre: 1.0

[[[[Adv]]]]: public Map [[extract]] ( Map [[target]] , final String [ ] [[profiles]] , final String [ ] [[wildcardPatterns]] , String [[prefix]] ) { if ( [[target]] == null ) { [[target]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map [[extracting]] ( Map [[blanco]] , final String [ ] [[outlining]] , final String [ ] [[consumerism]] , String [[adjective]] ) { if ( [[blanco]] == null ) { [[blanco]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 816 ---------------------------------------------
Copy all bytes from the stream . --> Write conde --> Socre: 1.0

[[[[Adv]]]]: public int [[copyAll]] ( final OutputStream [[out]] ) throws IOException { int [[count]] = 0 ; while ( "[[True]]" == "[[True]]" ) { byte [[b]] = readByte ( ) ; if ( isBoundary ( [[b]] ) ) { break ; } [[out]] . write ( [[b]] ) ; [[count]] ++ ; } return [[count]] ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int [[cherish]] ( final OutputStream [[walkout]] ) throws IOException { int [[conde]] = 0 ; while ( "[[Presentable]]" == "[[Presentable]]" ) { byte [[both]] = readByte ( ) ; if ( isBoundary ( [[both]] ) ) { break ; } [[walkout]] . write ( [[both]] ) ; [[conde]] ++ ; } return [[conde]] ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 817 ---------------------------------------------
Method called to register the alias . --> region ActionAnnotationValues --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues [[annotationValues]] , final ActionDefinition [[actionDefinition]] ) { final String [[alias]] = parseMethodAlias ( [[annotationValues]] ) ; if ( [[alias]] != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[actionDefinition]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[alias]] , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[sawn]] ( final ActionAnnotationValues [[oida]] , final ActionDefinition [[spooked]] ) { final String [[phony]] = parseMethodAlias ( [[oida]] ) ; if ( [[phony]] != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[spooked]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[phony]] , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 818 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 725 / 73 / 20 / 818:  82%|████████▏ | 818/1000 [1:05:28<14:34,  4.80s/it][Succeeded / Failed / Skipped / Total] 725 / 73 / 20 / 818:  82%|████████▏ | 819/1000 [1:05:38<14:30,  4.81s/it][Succeeded / Failed / Skipped / Total] 726 / 73 / 20 / 819:  82%|████████▏ | 819/1000 [1:05:38<14:30,  4.81s/it][Succeeded / Failed / Skipped / Total] 726 / 73 / 20 / 819:  82%|████████▏ | 820/1000 [1:05:46<14:26,  4.81s/it][Succeeded / Failed / Skipped / Total] 727 / 73 / 20 / 820:  82%|████████▏ | 820/1000 [1:05:46<14:26,  4.81s/it][Succeeded / Failed / Skipped / Total] 727 / 73 / 20 / 820:  82%|████████▏ | 821/1000 [1:05:47<14:20,  4.81s/it][Succeeded / Failed / Skipped / Total] 728 / 73 / 20 / 821:  82%|████████▏ | 821/1000 [1:05:47<14:20,  4.81s/it][Succeeded / Failed / Skipped / Total] 728 / 73 / 20 / 821:  82%|████████▏ | 822/1000 [1:06:14<14:20,  4.83s/it][Succeeded / Failed / Skipped / Total] 729 / 73 / 20 / 822:  82%|████████▏ | 822/1000 [1:06:14<14:20,  4.83s/it][Succeeded / Failed / Skipped / Total] 729 / 73 / 20 / 822:  82%|████████▏ | 823/1000 [1:06:14<14:14,  4.83s/it][Succeeded / Failed / Skipped / Total] 729 / 73 / 21 / 823:  82%|████████▏ | 823/1000 [1:06:14<14:14,  4.83s/it][Succeeded / Failed / Skipped / Total] 729 / 73 / 21 / 823:  82%|████████▏ | 824/1000 [1:06:19<14:09,  4.83s/it][Succeeded / Failed / Skipped / Total] 730 / 73 / 21 / 824:  82%|████████▏ | 824/1000 [1:06:19<14:09,  4.83s/it][Succeeded / Failed / Skipped / Total] 730 / 73 / 21 / 824:  82%|████████▎ | 825/1000 [1:06:26<14:05,  4.83s/it][Succeeded / Failed / Skipped / Total] 731 / 73 / 21 / 825:  82%|████████▎ | 825/1000 [1:06:26<14:05,  4.83s/it][Succeeded / Failed / Skipped / Total] 731 / 73 / 21 / 825:  83%|████████▎ | 826/1000 [1:06:57<14:06,  4.86s/it]Resolve action config . --> Returns the annotation associated with this ActionConfig --> Socre: 1.0

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues [[annotationValues]] ) { final Class < ? extends Annotation > annotationType ; if ( [[annotationValues]] == null ) { annotationType = Action . class ; } else { annotationType = [[annotationValues]] . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[furthest]] ( final ActionAnnotationValues [[setters]] ) { final Class < ? extends Annotation > annotationType ; if ( [[setters]] == null ) { annotationType = Action . class ; } else { annotationType = [[setters]] . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 819 ---------------------------------------------
Prepare file download . --> Write a kawashima --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse [[response]] , final File [[file]] , final String mimeType ) { if ( ! [[file]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[file]] ) ; } if ( [[file]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[file]] ) ; } prepareResponse ( [[response]] , [[file]] . getAbsolutePath ( ) , mimeType , ( int ) [[file]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[kawashima]] ( final HttpServletResponse [[responses]] , final File [[depot]] , final String mimeType ) { if ( ! [[depot]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[depot]] ) ; } if ( [[depot]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[depot]] ) ; } prepareResponse ( [[responses]] , [[depot]] . getAbsolutePath ( ) , mimeType , ( int ) [[depot]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 820 ---------------------------------------------
Read the package action path . --> Get the aligned command line --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class [[actionClass]] ) { Package [[actionPackage]] = [[actionClass]] . getPackage ( ) ; final String [[actionPackageName]] = [[actionPackage]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[mobility]] ( final Class [[frills]] ) { Package [[shirazi]] = [[frills]] . getPackage ( ) ; final String [[beleive]] = [[shirazi]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 821 ---------------------------------------------
Parses the annotation alias . --> Remove an annotation from cumin --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues [[annotationValues]] ) { String alias = null ; if ( [[annotationValues]] != null ) { alias = [[annotationValues]] . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[lipped]] ( final ActionAnnotationValues [[cumin]] ) { String alias = null ; if ( [[cumin]] != null ) { alias = [[cumin]] . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 822 ---------------------------------------------
Check the given plaintext and hashed --> Returns true if the ascetic is nines --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[checkpw]] ( String [[plaintext]] , String hashed ) { byte [ ] [[hashed_bytes]] ; byte [ ] try_bytes ; try { String try_pw = hashpw ( [[plaintext]] , hashed ) ; [[hashed_bytes]] = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "[[False]]" != "[[False]]" ; } if ( [[hashed_bytes]] . length != try_bytes . length ) { return "[[False]]" != "[[False]]" ; } byte ret = 0 ; for ( int [[i]] = 0 ; [[i]] < try_bytes . length ; [[i]] ++ ) { ret |= [[hashed_bytes]] [ [[i]] ] ^ try_bytes [ [[i]] ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean [[nines]] ( String [[ascetic]] , String hashed ) { byte [ ] [[devastated]] ; byte [ ] try_bytes ; try { String try_pw = hashpw ( [[ascetic]] , hashed ) ; [[devastated]] = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "[[Adulterated]]" != "[[Adulterated]]" ; } if ( [[devastated]] . length != try_bytes . length ) { return "[[Adulterated]]" != "[[Adulterated]]" ; } byte ret = 0 ; for ( int [[jes]] = 0 ; [[jes]] < try_bytes . length ; [[jes]] ++ ) { ret |= [[devastated]] [ [[jes]] ] ^ try_bytes [ [[jes]] ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 823 ---------------------------------------------
Notifies the response . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 824 ---------------------------------------------
Returns the advice of the specified class . --> Build a selenium Object --> Socre: 1.0

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class [[adviceClass]] = cache . get ( targetClass ) ; if ( [[adviceClass]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class [[muu]] = cache . get ( targetClass ) ; if ( [[muu]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 825 ---------------------------------------------
Inject target into proxy . --> Proxetta method --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object proxy , final Object [[target]] ) { Class [[proxyClass]] = proxy . getClass ( ) ; try { Field [[field]] = [[proxyClass]] . getField ( "$___target$0" ) ; [[field]] . set ( proxy , [[target]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[prob]] ( final Object proxy , final Object [[targeting]] ) { Class [[keppel]] = proxy . getClass ( ) ; try { Field [[fields]] = [[keppel]] . getField ( "$___target$0" ) ; [[fields]] . set ( proxy , [[targeting]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 826 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 732 / 73 / 21 / 826:  83%|████████▎ | 826/1000 [1:06:57<14:06,  4.86s/it][Succeeded / Failed / Skipped / Total] 732 / 73 / 21 / 826:  83%|████████▎ | 827/1000 [1:07:06<14:02,  4.87s/it][Succeeded / Failed / Skipped / Total] 733 / 73 / 21 / 827:  83%|████████▎ | 827/1000 [1:07:06<14:02,  4.87s/it][Succeeded / Failed / Skipped / Total] 733 / 73 / 21 / 827:  83%|████████▎ | 828/1000 [1:07:07<13:56,  4.86s/it][Succeeded / Failed / Skipped / Total] 734 / 73 / 21 / 828:  83%|████████▎ | 828/1000 [1:07:07<13:56,  4.86s/it][Succeeded / Failed / Skipped / Total] 734 / 73 / 21 / 828:  83%|████████▎ | 829/1000 [1:07:08<13:51,  4.86s/it][Succeeded / Failed / Skipped / Total] 735 / 73 / 21 / 829:  83%|████████▎ | 829/1000 [1:07:08<13:51,  4.86s/it][Succeeded / Failed / Skipped / Total] 735 / 73 / 21 / 829:  83%|████████▎ | 830/1000 [1:07:15<13:46,  4.86s/it][Succeeded / Failed / Skipped / Total] 736 / 73 / 21 / 830:  83%|████████▎ | 830/1000 [1:07:15<13:46,  4.86s/it][Succeeded / Failed / Skipped / Total] 736 / 73 / 21 / 830:  83%|████████▎ | 831/1000 [1:07:19<13:41,  4.86s/it][Succeeded / Failed / Skipped / Total] 737 / 73 / 21 / 831:  83%|████████▎ | 831/1000 [1:07:19<13:41,  4.86s/it][Succeeded / Failed / Skipped / Total] 737 / 73 / 21 / 831:  83%|████████▎ | 832/1000 [1:07:29<13:37,  4.87s/it][Succeeded / Failed / Skipped / Total] 738 / 73 / 21 / 832:  83%|████████▎ | 832/1000 [1:07:29<13:37,  4.87s/it][Succeeded / Failed / Skipped / Total] 738 / 73 / 21 / 832:  83%|████████▎ | 833/1000 [1:07:32<13:32,  4.87s/it][Succeeded / Failed / Skipped / Total] 739 / 73 / 21 / 833:  83%|████████▎ | 833/1000 [1:07:32<13:32,  4.87s/it][Succeeded / Failed / Skipped / Total] 739 / 73 / 21 / 833:  83%|████████▎ | 834/1000 [1:07:34<13:26,  4.86s/it]Read an action interceptors . --> Returns the array of successes associated with a AnnotatedElement --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionInterceptor > [ ] [[result]] = null ; InterceptedBy [[interceptedBy]] = [[actionClassOrMethod]] . getAnnotation ( InterceptedBy . class ) ; if ( [[interceptedBy]] != null ) { [[result]] = [[interceptedBy]] . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[astronaut]] ( final AnnotatedElement [[tory]] ) { Class < ? extends ActionInterceptor > [ ] [[successes]] = null ; InterceptedBy [[harwich]] = [[tory]] . getAnnotation ( InterceptedBy . class ) ; if ( [[harwich]] != null ) { [[successes]] = [[harwich]] . value ( ) ; if ( [[successes]] . length == 0 ) { [[successes]] = null ; } } return [[successes]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 827 ---------------------------------------------
Read action filters . --> returns an array of ActionFilter --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionFilter > [ ] [[result]] = null ; FilteredBy [[filteredBy]] = [[actionClassOrMethod]] . getAnnotation ( FilteredBy . class ) ; if ( [[filteredBy]] != null ) { [[result]] = [[filteredBy]] . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[rutger]] ( final AnnotatedElement [[transpires]] ) { Class < ? extends ActionFilter > [ ] [[successes]] = null ; FilteredBy [[bookshop]] = [[transpires]] . getAnnotation ( FilteredBy . class ) ; if ( [[bookshop]] != null ) { [[successes]] = [[bookshop]] . value ( ) ; if ( [[successes]] . length == 0 ) { [[successes]] = null ; } } return [[successes]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 828 ---------------------------------------------
Resolve a real name . --> Get the dilemma --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[dilemma]] ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 829 ---------------------------------------------
Resolves the specified real name . --> Unjustly the given boland --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String [[realName]] ) { if ( realNames == null ) { return [[realName]] ; } int [[realIndex]] = ArraysUtil . indexOf ( realNames , [[realName]] ) ; if ( [[realIndex]] == - 1 ) { return [[realName]] ; } return jsonNames [ [[realIndex]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[unjustly]] ( final String [[boland]] ) { if ( realNames == null ) { return [[boland]] ; } int [[dougy]] = ArraysUtil . indexOf ( realNames , [[boland]] ) ; if ( [[dougy]] == - 1 ) { return [[boland]] ; } return jsonNames [ [[dougy]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 830 ---------------------------------------------
Hashes a password . --> zoran method --> Socre: 1.0

[[[[Adv]]]]: public static String [[hashpw]] ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int [[rounds]] , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String [[zoran]] ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int [[ronda]] , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 831 ---------------------------------------------
Gets the type data for the given class . --> Get the weak --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[_lookupTypeData]] ( final Class type ) { TypeData [[typeData]] = typeDataMap . get ( type ) ; if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , [[typeData]] ) ; } return [[typeData]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData [[nellie]] ( final Class type ) { TypeData [[whipple]] = typeDataMap . get ( type ) ; if ( [[whipple]] == null ) { [[whipple]] = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , [[whipple]] ) ; } return [[whipple]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 832 ---------------------------------------------
Read the method action path . --> solemnly --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String [[methodName]] , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[solemnly]] ( final String [[brainstorm]] , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 833 ---------------------------------------------
Find the type data for the given class . --> Return the TypeData for this Class --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class [[type]] ) { final Class < ? extends Annotation > [[defaultAnnotation]] = jsonAnnotation ; if ( [[type]] . getAnnotation ( [[defaultAnnotation]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[tive]] ( final Class [[genre]] ) { final Class < ? extends Annotation > [[alaikum]] = jsonAnnotation ; if ( [[genre]] . getAnnotation ( [[alaikum]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 834 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 740 / 73 / 21 / 834:  83%|████████▎ | 834/1000 [1:07:34<13:26,  4.86s/it][Succeeded / Failed / Skipped / Total] 740 / 73 / 21 / 834:  84%|████████▎ | 835/1000 [1:07:39<13:22,  4.86s/it][Succeeded / Failed / Skipped / Total] 741 / 73 / 21 / 835:  84%|████████▎ | 835/1000 [1:07:39<13:22,  4.86s/it][Succeeded / Failed / Skipped / Total] 741 / 73 / 21 / 835:  84%|████████▎ | 836/1000 [1:07:51<13:18,  4.87s/it][Succeeded / Failed / Skipped / Total] 742 / 73 / 21 / 836:  84%|████████▎ | 836/1000 [1:07:51<13:18,  4.87s/it][Succeeded / Failed / Skipped / Total] 742 / 73 / 21 / 836:  84%|████████▎ | 837/1000 [1:07:53<13:13,  4.87s/it][Succeeded / Failed / Skipped / Total] 743 / 73 / 21 / 837:  84%|████████▎ | 837/1000 [1:07:53<13:13,  4.87s/it][Succeeded / Failed / Skipped / Total] 743 / 73 / 21 / 837:  84%|████████▍ | 838/1000 [1:08:11<13:10,  4.88s/it][Succeeded / Failed / Skipped / Total] 744 / 73 / 21 / 838:  84%|████████▍ | 838/1000 [1:08:11<13:10,  4.88s/it][Succeeded / Failed / Skipped / Total] 744 / 73 / 21 / 838:  84%|████████▍ | 839/1000 [1:08:14<13:05,  4.88s/it][Succeeded / Failed / Skipped / Total] 745 / 73 / 21 / 839:  84%|████████▍ | 839/1000 [1:08:14<13:05,  4.88s/it][Succeeded / Failed / Skipped / Total] 745 / 73 / 21 / 839:  84%|████████▍ | 840/1000 [1:08:30<13:02,  4.89s/it][Succeeded / Failed / Skipped / Total] 746 / 73 / 21 / 840:  84%|████████▍ | 840/1000 [1:08:30<13:02,  4.89s/it][Succeeded / Failed / Skipped / Total] 746 / 73 / 21 / 840:  84%|████████▍ | 841/1000 [1:09:03<13:03,  4.93s/it][Succeeded / Failed / Skipped / Total] 747 / 73 / 21 / 841:  84%|████████▍ | 841/1000 [1:09:03<13:03,  4.93s/it][Succeeded / Failed / Skipped / Total] 747 / 73 / 21 / 841:  84%|████████▍ | 842/1000 [1:09:03<12:57,  4.92s/it][Succeeded / Failed / Skipped / Total] 748 / 73 / 21 / 842:  84%|████████▍ | 842/1000 [1:09:03<12:57,  4.92s/it][Succeeded / Failed / Skipped / Total] 748 / 73 / 21 / 842:  84%|████████▍ | 843/1000 [1:09:17<12:54,  4.93s/it]Visits an annotation . --> visit a method for recovery --> Socre: 1.0

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String [[descriptor]] , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , visible ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[megiddo]] ( final String [[lambeth]] , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( [[lambeth]] , visible ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 835 ---------------------------------------------
Copy bootstrap methods . --> temp a class --> Socre: 1.0

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader [[classReader]] , final char [ ] [[charBuffer]] ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[temp]] ( final ClassReader [[wn]] , final char [ ] [[seances]] ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 836 ---------------------------------------------
Resolve json name . --> let let let the let sty --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( name ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[letty]] ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( name ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 837 ---------------------------------------------
Puts constant pool . --> spar method --> Socre: 1.0

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[spar]] ( final ByteVector [[proceeds]] ) { [[proceeds]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 838 ---------------------------------------------
Returns the content of the file . --> Create a new byte array --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[synchronous]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 839 ---------------------------------------------
Put bootstrap methods . --> gulch a byte vector --> Socre: 1.0

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector [[output]] ) { if ( bootstrapMethods != null ) { [[output]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[gulch]] ( final ByteVector [[revenue]] ) { if ( bootstrapMethods != null ) { [[revenue]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 840 ---------------------------------------------
Adds a constant field to this class . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String [[owner]] , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[owner]] , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[lto]] ( final String [[proprietor]] , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[proprietor]] , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 841 ---------------------------------------------
Copy max bytes . --> Get narrates --> Socre: 1.0

[[[[Adv]]]]: public int [[copyMax]] ( final OutputStream out , final int [[maxBytes]] ) throws IOException { int [[count]] = 0 ; while ( "[[True]]" == "[[True]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; [[count]] ++ ; if ( [[count]] == [[maxBytes]] ) { return [[count]] ; } } return [[count]] ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int [[pillowcases]] ( final OutputStream out , final int [[melech]] ) throws IOException { int [[narrates]] = 0 ; while ( "[[Sincere]]" == "[[Sincere]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; [[narrates]] ++ ; if ( [[narrates]] == [[melech]] ) { return [[narrates]] ; } } return [[narrates]] ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 842 ---------------------------------------------
Resolve real name . --> Get the error message --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class type , final String [[jsonName]] ) { TypeData [[typeData]] = lookupTypeData ( type ) ; return [[typeData]] . resolveRealName ( [[jsonName]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[usr]] ( final Class type , final String [[pyra]] ) { TypeData [[motorcars]] = lookupTypeData ( type ) ; return [[motorcars]] . resolveRealName ( [[pyra]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 843 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 749 / 73 / 21 / 843:  84%|████████▍ | 843/1000 [1:09:17<12:54,  4.93s/it][Succeeded / Failed / Skipped / Total] 749 / 73 / 21 / 843:  84%|████████▍ | 844/1000 [1:09:23<12:49,  4.93s/it][Succeeded / Failed / Skipped / Total] 750 / 73 / 21 / 844:  84%|████████▍ | 844/1000 [1:09:23<12:49,  4.93s/it][Succeeded / Failed / Skipped / Total] 750 / 73 / 21 / 844:  84%|████████▍ | 845/1000 [1:09:58<12:50,  4.97s/it][Succeeded / Failed / Skipped / Total] 751 / 73 / 21 / 845:  84%|████████▍ | 845/1000 [1:09:58<12:50,  4.97s/it][Succeeded / Failed / Skipped / Total] 751 / 73 / 21 / 845:  85%|████████▍ | 846/1000 [1:10:05<12:45,  4.97s/it][Succeeded / Failed / Skipped / Total] 752 / 73 / 21 / 846:  85%|████████▍ | 846/1000 [1:10:05<12:45,  4.97s/it][Succeeded / Failed / Skipped / Total] 752 / 73 / 21 / 846:  85%|████████▍ | 847/1000 [1:10:06<12:39,  4.97s/it][Succeeded / Failed / Skipped / Total] 753 / 73 / 21 / 847:  85%|████████▍ | 847/1000 [1:10:06<12:39,  4.97s/it][Succeeded / Failed / Skipped / Total] 753 / 73 / 21 / 847:  85%|████████▍ | 848/1000 [1:10:15<12:35,  4.97s/it][Succeeded / Failed / Skipped / Total] 754 / 73 / 21 / 848:  85%|████████▍ | 848/1000 [1:10:15<12:35,  4.97s/it][Succeeded / Failed / Skipped / Total] 754 / 73 / 21 / 848:  85%|████████▍ | 849/1000 [1:10:31<12:32,  4.98s/it]Returns the major version and class name . --> Methode reflect --> Socre: 1.0

[[[[Adv]]]]: int [[setMajorVersionAndClassName]] ( final int [[majorVersion]] , final String [[className]] ) { this . [[majorVersion]] = [[majorVersion]] ; this . [[className]] = [[className]] ; return addConstantClass ( [[className]] ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int [[balaclava]] ( final int [[bou]] , final String [[disciplinarian]] ) { this . [[compunction]] = [[bou]] ; this . [[den]] = [[disciplinarian]] ; return addConstantClass ( [[disciplinarian]] ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 844 ---------------------------------------------
Add a constant . --> borgias implementation --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMemberReference]] ( final int [[index]] , final int tag , final String [[owner]] , final String [[name]] , final String descriptor ) { add ( new Entry ( [[index]] , tag , [[owner]] , [[name]] , descriptor , 0 , hash ( tag , [[owner]] , [[name]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[borgias]] ( final int [[ratios]] , final int tag , final String [[occupier]] , final String [[noun]] , final String descriptor ) { add ( new Entry ( [[ratios]] , tag , [[occupier]] , [[noun]] , descriptor , 0 , hash ( tag , [[occupier]] , [[noun]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 845 ---------------------------------------------
Finds the type data for the given type . --> region > class --> Socre: 1.0

[[[[Adv]]]]: public TypeData [[lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { if ( serializationSubclassAware ) { [[typeData]] = findSubclassTypeData ( [[type]] ) ; } if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } } return [[typeData]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData [[cuckoo]] ( final Class [[classifies]] ) { TypeData [[acknowledgement]] = typeDataMap . get ( [[classifies]] ) ; if ( [[acknowledgement]] == null ) { if ( serializationSubclassAware ) { [[acknowledgement]] = findSubclassTypeData ( [[classifies]] ) ; } if ( [[acknowledgement]] == null ) { [[acknowledgement]] = scanClassForAnnotations ( [[classifies]] ) ; typeDataMap . put ( [[classifies]] , [[acknowledgement]] ) ; } } return [[acknowledgement]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 846 ---------------------------------------------
Adds a constant long or double . --> region triads Implementation --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantLongOrDouble]] ( final int [[tag]] , final long [[value]] ) { int hashCode = hash ( [[tag]] , [[value]] ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == hashCode && [[entry]] . data == [[value]] ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } int [[index]] = constantPoolCount ; constantPool . putByte ( [[tag]] ) . putLong ( [[value]] ) ; constantPoolCount += 2 ; return put ( new Entry ( [[index]] , [[tag]] , [[value]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[triads]] ( final int [[marking]] , final long [[relevance]] ) { int hashCode = hash ( [[marking]] , [[relevance]] ) ; Entry [[doorway]] = get ( hashCode ) ; while ( [[doorway]] != null ) { if ( [[doorway]] . tag == [[marking]] && [[doorway]] . hashCode == hashCode && [[doorway]] . data == [[relevance]] ) { return [[doorway]] ; } [[doorway]] = [[doorway]] . next ; } int [[signs]] = constantPoolCount ; constantPool . putByte ( [[marking]] ) . putLong ( [[relevance]] ) ; constantPoolCount += 2 ; return put ( new Entry ( [[signs]] , [[marking]] , [[relevance]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 847 ---------------------------------------------
Adds a constant long . --> region spiders Implementation --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int [[index]] , final int [[tag]] , final long value ) { add ( new Entry ( [[index]] , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[spiders]] ( final int [[cues]] , final int [[marca]] , final long value ) { add ( new Entry ( [[cues]] , [[marca]] , value , hash ( [[marca]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 848 ---------------------------------------------
Adds a constant value . --> Blogger method --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int [[index]] , final int [[tag]] , final int [[value]] ) { add ( new Entry ( [[index]] , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[blogger]] ( final int [[cataloguing]] , final int [[markup]] , final int [[rating]] ) { add ( new Entry ( [[cataloguing]] , [[markup]] , [[rating]] , hash ( [[markup]] , [[rating]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 849 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 755 / 73 / 21 / 849:  85%|████████▍ | 849/1000 [1:10:31<12:32,  4.98s/it][Succeeded / Failed / Skipped / Total] 755 / 73 / 21 / 849:  85%|████████▌ | 850/1000 [1:10:31<12:26,  4.98s/it][Succeeded / Failed / Skipped / Total] 756 / 73 / 21 / 850:  85%|████████▌ | 850/1000 [1:10:31<12:26,  4.98s/it][Succeeded / Failed / Skipped / Total] 756 / 73 / 21 / 850:  85%|████████▌ | 851/1000 [1:10:38<12:22,  4.98s/it][Succeeded / Failed / Skipped / Total] 757 / 73 / 21 / 851:  85%|████████▌ | 851/1000 [1:10:38<12:22,  4.98s/it][Succeeded / Failed / Skipped / Total] 757 / 73 / 21 / 851:  85%|████████▌ | 852/1000 [1:10:38<12:16,  4.97s/it][Succeeded / Failed / Skipped / Total] 758 / 73 / 21 / 852:  85%|████████▌ | 852/1000 [1:10:38<12:16,  4.97s/it][Succeeded / Failed / Skipped / Total] 758 / 73 / 21 / 852:  85%|████████▌ | 853/1000 [1:10:49<12:12,  4.98s/it][Succeeded / Failed / Skipped / Total] 759 / 73 / 21 / 853:  85%|████████▌ | 853/1000 [1:10:49<12:12,  4.98s/it][Succeeded / Failed / Skipped / Total] 759 / 73 / 21 / 853:  85%|████████▌ | 854/1000 [1:10:50<12:06,  4.98s/it][Succeeded / Failed / Skipped / Total] 760 / 73 / 21 / 854:  85%|████████▌ | 854/1000 [1:10:50<12:06,  4.98s/it][Succeeded / Failed / Skipped / Total] 760 / 73 / 21 / 854:  86%|████████▌ | 855/1000 [1:11:35<12:08,  5.02s/it]Adds a constant integer to this symbol table . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantIntegerOrFloat]] ( final int [[tag]] , final int [[value]] ) { int [[hashCode]] = hash ( [[tag]] , [[value]] ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == [[hashCode]] && [[entry]] . data == [[value]] ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . putByte ( [[tag]] ) . putInt ( [[value]] ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , [[value]] , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[liliana]] ( final int [[identification]] , final int [[valued]] ) { int [[dormouse]] = hash ( [[identification]] , [[valued]] ) ; Entry [[accesses]] = get ( [[dormouse]] ) ; while ( [[accesses]] != null ) { if ( [[accesses]] . tag == [[identification]] && [[accesses]] . hashCode == [[dormouse]] && [[accesses]] . data == [[valued]] ) { return [[accesses]] ; } [[accesses]] = [[accesses]] . next ; } constantPool . putByte ( [[identification]] ) . putInt ( [[valued]] ) ; return put ( new Entry ( constantPoolCount ++ , [[identification]] , [[valued]] , [[dormouse]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a constant name and descriptor to the map . --> regionay method --> Socre: 1.0

[[[[Adv]]]]: int [[addConstantNameAndType]] ( final String [[name]] , final String descriptor ) { final int [[tag]] = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int [[hashCode]] = hash ( [[tag]] , [[name]] , descriptor ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == [[hashCode]] && [[entry]] . name . equals ( [[name]] ) && [[entry]] . value . equals ( descriptor ) ) { return [[entry]] . index ; } [[entry]] = [[entry]] . next ; } constantPool . put122 ( [[tag]] , addConstantUtf8 ( [[name]] ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , [[name]] , descriptor , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[noway]] ( final String [[naming]] , final String descriptor ) { final int [[stamping]] = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int [[slaps]] = hash ( [[stamping]] , [[naming]] , descriptor ) ; Entry [[entrance]] = get ( [[slaps]] ) ; while ( [[entrance]] != null ) { if ( [[entrance]] . tag == [[stamping]] && [[entrance]] . hashCode == [[slaps]] && [[entrance]] . name . equals ( [[naming]] ) && [[entrance]] . value . equals ( descriptor ) ) { return [[entrance]] . index ; } [[entrance]] = [[entrance]] . next ; } constantPool . put122 ( [[stamping]] , addConstantUtf8 ( [[naming]] ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , [[stamping]] , [[naming]] , descriptor , [[slaps]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 851 ---------------------------------------------
Add a UTF8 constant . --> region marines --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int [[index]] , final String value ) { add ( new Entry ( [[index]] , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[marines]] ( final int [[markers]] , final String value ) { add ( new Entry ( [[markers]] , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 852 ---------------------------------------------
Add a constant reference . --> esosa --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodref]] ( final String [[owner]] , final String [[name]] , final String [[descriptor]] , final boolean [[isInterface]] ) { int tag = [[isInterface]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , [[owner]] , [[name]] , [[descriptor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[espinosa]] ( final String [[landlady]] , final String [[designated]] , final String [[policed]] , final boolean [[kermit]] ) { int tag = [[kermit]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , [[landlady]] , [[designated]] , [[policed]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a constant map . --> vibrates algorithm --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantNameAndType]] ( final int index , final String [[name]] , final String descriptor ) { final int [[tag]] = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , [[tag]] , [[name]] , descriptor , hash ( [[tag]] , [[name]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[vibrates]] ( final int index , final String [[nominations]] , final String descriptor ) { final int [[marking]] = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , [[marking]] , [[nominations]] , descriptor , hash ( [[marking]] , [[nominations]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a constant . --> add constantDynamic --> Socre: 1.0

[[[[Adv]]]]: Symbol addConstantDynamic ( final String [[name]] , final String [[descriptor]] , final Handle [[bootstrapMethodHandle]] , final Object ... [[bootstrapMethodArguments]] ) { Symbol bootstrapMethod = addBootstrapMethod ( [[bootstrapMethodHandle]] , [[bootstrapMethodArguments]] ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , [[name]] , [[descriptor]] , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantDynamic ( final String [[designate]] , final String [[joining]] , final Handle [[kanno]] , final Object ... [[swaying]] ) { Symbol bootstrapMethod = addBootstrapMethod ( [[kanno]] , [[swaying]] ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , [[designate]] , [[joining]] , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 855 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 761 / 73 / 21 / 855:  86%|████████▌ | 855/1000 [1:11:35<12:08,  5.02s/it][Succeeded / Failed / Skipped / Total] 761 / 73 / 21 / 855:  86%|████████▌ | 856/1000 [1:11:45<12:04,  5.03s/it][Succeeded / Failed / Skipped / Total] 762 / 73 / 21 / 856:  86%|████████▌ | 856/1000 [1:11:45<12:04,  5.03s/it][Succeeded / Failed / Skipped / Total] 762 / 73 / 21 / 856:  86%|████████▌ | 857/1000 [1:12:00<12:00,  5.04s/it][Succeeded / Failed / Skipped / Total] 763 / 73 / 21 / 857:  86%|████████▌ | 857/1000 [1:12:00<12:00,  5.04s/it][Succeeded / Failed / Skipped / Total] 763 / 73 / 21 / 857:  86%|████████▌ | 858/1000 [1:12:03<11:55,  5.04s/it][Succeeded / Failed / Skipped / Total] 764 / 73 / 21 / 858:  86%|████████▌ | 858/1000 [1:12:03<11:55,  5.04s/it][Succeeded / Failed / Skipped / Total] 764 / 73 / 21 / 858:  86%|████████▌ | 859/1000 [1:12:24<11:53,  5.06s/it][Succeeded / Failed / Skipped / Total] 765 / 73 / 21 / 859:  86%|████████▌ | 859/1000 [1:12:24<11:53,  5.06s/it][Succeeded / Failed / Skipped / Total] 765 / 73 / 21 / 859:  86%|████████▌ | 860/1000 [1:13:21<11:56,  5.12s/it][Succeeded / Failed / Skipped / Total] 765 / 74 / 21 / 860:  86%|████████▌ | 860/1000 [1:13:21<11:56,  5.12s/it][Succeeded / Failed / Skipped / Total] 765 / 74 / 21 / 860:  86%|████████▌ | 861/1000 [1:13:27<11:51,  5.12s/it]Adds a constant method handle . --> hash value --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMethodHandle]] ( final int [[index]] , final int referenceKind , final String owner , final String name , final String [[descriptor]] ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , [[descriptor]] , referenceKind ) ; add ( new Entry ( [[index]] , tag , owner , name , [[descriptor]] , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[valente]] ( final int [[inventory]] , final int referenceKind , final String owner , final String name , final String [[pace]] ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , [[pace]] , referenceKind ) ; add ( new Entry ( [[inventory]] , tag , owner , name , [[pace]] , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 856 ---------------------------------------------
Adds a constant sequence to the hash . --> Refried by relevance --> Socre: 1.0

[[[[Adv]]]]: int [[addConstantUtf8]] ( final String [[value]] ) { int [[hashCode]] = hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == Symbol . CONSTANT_UTF8_TAG && [[entry]] . hashCode == [[hashCode]] && [[entry]] . value . equals ( [[value]] ) ) { return [[entry]] . index ; } [[entry]] = [[entry]] . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( [[value]] ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , [[value]] , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[refried]] ( final String [[relevance]] ) { int [[ebola]] = hash ( Symbol . CONSTANT_UTF8_TAG , [[relevance]] ) ; Entry [[arriving]] = get ( [[ebola]] ) ; while ( [[arriving]] != null ) { if ( [[arriving]] . tag == Symbol . CONSTANT_UTF8_TAG && [[arriving]] . hashCode == [[ebola]] && [[arriving]] . value . equals ( [[relevance]] ) ) { return [[arriving]] . index ; } [[arriving]] = [[arriving]] . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( [[relevance]] ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , [[relevance]] , [[ebola]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 857 ---------------------------------------------
Adds a new constant . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantDynamicOrInvokeDynamicReference]] ( final int [[tag]] , final int [[index]] , final String [[name]] , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( [[tag]] , [[name]] , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( [[index]] , [[tag]] , null , [[name]] , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[erlc]] ( final int [[tags]] , final int [[inventory]] , final String [[denominations]] , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( [[tags]] , [[denominations]] , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( [[inventory]] , [[tags]] , null , [[denominations]] , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 858 ---------------------------------------------
Adds a reference to the constant pool . --> Create alexey catalog --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8Reference]] ( final int [[index]] , final int [[tag]] , final String [[value]] ) { add ( new Entry ( [[index]] , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[alexey]] ( final int [[cataloging]] , final int [[branded]] , final String [[rating]] ) { add ( new Entry ( [[cataloging]] , [[branded]] , [[rating]] , hash ( [[branded]] , [[rating]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 859 ---------------------------------------------
Add new bootstrap methods . --> Liefert das das ein --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle bootstrapMethodHandle , final Object ... [[bootstrapMethodArguments]] ) { ByteVector [[bootstrapMethodsAttribute]] = bootstrapMethods ; if ( [[bootstrapMethodsAttribute]] == null ) { [[bootstrapMethodsAttribute]] = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[peux]] ( final Handle bootstrapMethodHandle , final Object ... [[revolutionary]] ) { ByteVector [[michi]] = bootstrapMethods ; if ( [[michi]] == null ) { [[michi]] = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 860 ---------------------------------------------
Parse action . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 861 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 766 / 74 / 21 / 861:  86%|████████▌ | 861/1000 [1:13:27<11:51,  5.12s/it][Succeeded / Failed / Skipped / Total] 766 / 74 / 21 / 861:  86%|████████▌ | 862/1000 [1:13:28<11:45,  5.11s/it][Succeeded / Failed / Skipped / Total] 767 / 74 / 21 / 862:  86%|████████▌ | 862/1000 [1:13:28<11:45,  5.11s/it][Succeeded / Failed / Skipped / Total] 767 / 74 / 21 / 862:  86%|████████▋ | 863/1000 [1:13:33<11:40,  5.11s/it][Succeeded / Failed / Skipped / Total] 768 / 74 / 21 / 863:  86%|████████▋ | 863/1000 [1:13:33<11:40,  5.11s/it][Succeeded / Failed / Skipped / Total] 768 / 74 / 21 / 863:  86%|████████▋ | 864/1000 [1:13:54<11:37,  5.13s/it][Succeeded / Failed / Skipped / Total] 769 / 74 / 21 / 864:  86%|████████▋ | 864/1000 [1:13:54<11:37,  5.13s/it][Succeeded / Failed / Skipped / Total] 769 / 74 / 21 / 864:  86%|████████▋ | 865/1000 [1:13:57<11:32,  5.13s/it][Succeeded / Failed / Skipped / Total] 770 / 74 / 21 / 865:  86%|████████▋ | 865/1000 [1:13:57<11:32,  5.13s/it][Succeeded / Failed / Skipped / Total] 770 / 74 / 21 / 865:  87%|████████▋ | 866/1000 [1:14:13<11:29,  5.14s/it][Succeeded / Failed / Skipped / Total] 771 / 74 / 21 / 866:  87%|████████▋ | 866/1000 [1:14:13<11:29,  5.14s/it][Succeeded / Failed / Skipped / Total] 771 / 74 / 21 / 866:  87%|████████▋ | 867/1000 [1:14:15<11:23,  5.14s/it][Succeeded / Failed / Skipped / Total] 772 / 74 / 21 / 867:  87%|████████▋ | 867/1000 [1:14:15<11:23,  5.14s/it][Succeeded / Failed / Skipped / Total] 772 / 74 / 21 / 867:  87%|████████▋ | 868/1000 [1:14:16<11:17,  5.13s/it][Succeeded / Failed / Skipped / Total] 773 / 74 / 21 / 868:  87%|████████▋ | 868/1000 [1:14:16<11:17,  5.13s/it][Succeeded / Failed / Skipped / Total] 773 / 74 / 21 / 868:  87%|████████▋ | 869/1000 [1:14:19<11:12,  5.13s/it]Adds a constant reference . --> hash query --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantUtf8Reference]] ( final int [[tag]] , final String [[value]] ) { int [[hashCode]] = hash ( [[tag]] , [[value]] ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == [[hashCode]] && [[entry]] . value . equals ( [[value]] ) ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . put12 ( [[tag]] , addConstantUtf8 ( [[value]] ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , [[value]] , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[oddest]] ( final int [[subtitling]] , final String [[appreciate]] ) { int [[subsidize]] = hash ( [[subtitling]] , [[appreciate]] ) ; Entry [[incoming]] = get ( [[subsidize]] ) ; while ( [[incoming]] != null ) { if ( [[incoming]] . tag == [[subtitling]] && [[incoming]] . hashCode == [[subsidize]] && [[incoming]] . value . equals ( [[appreciate]] ) ) { return [[incoming]] ; } [[incoming]] = [[incoming]] . next ; } constantPool . put12 ( [[subtitling]] , addConstantUtf8 ( [[appreciate]] ) ) ; return put ( new Entry ( constantPoolCount ++ , [[subtitling]] , [[appreciate]] , [[subsidize]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 862 ---------------------------------------------
Add a relation type . --> Liefert die Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer Leer L --> Socre: 1.0

[[[[Adv]]]]: int [[addMergedType]] ( final int [[typeTableIndex1]] , final int [[typeTableIndex2]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int [[bancroft]] ( final int [[braking]] , final int [[jalapeño]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 863 ---------------------------------------------
Add a constant method handle . --> we re on 8 --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodHandle]] ( final int [[referenceKind]] , final String [[owner]] , final String name , final String [[descriptor]] , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[weirdoes]] ( final int [[trilling]] , final String [[landowners]] , final String name , final String [[rancour]] , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 864 ---------------------------------------------
Adds the bootstrap method . --> Add constantDynamic --> Socre: 1.0

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String [[name]] , final String [[descriptor]] , final Handle [[bootstrapMethodHandle]] , final Object ... bootstrapMethodArguments ) { Symbol [[bootstrapMethod]] = addBootstrapMethod ( [[bootstrapMethodHandle]] , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[name]] , [[descriptor]] , [[bootstrapMethod]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String [[baptism]] , final String [[stifle]] , final Handle [[jumper]] , final Object ... bootstrapMethodArguments ) { Symbol [[ashy]] = addBootstrapMethod ( [[jumper]] , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[baptism]] , [[stifle]] , [[ashy]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 865 ---------------------------------------------
Removes all entries . --> Returns a copy of this object --> Socre: 1.0

[[[[Adv]]]]: public HttpMultiMap < V > [[clear]] ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > [[definite]] ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 866 ---------------------------------------------
Returns a list of entries . --> influx methods --> Socre: 1.0

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > [[e]] = head . after ; while ( [[e]] != head ) { all . add ( [[e]] ) ; [[e]] = [[e]] . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[influx]] ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > [[ra]] = head . after ; while ( [[ra]] != head ) { all . add ( [[ra]] ) ; [[ra]] = [[ra]] . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 867 ---------------------------------------------
Appends a char buffer to this buffer . --> Set the uniting string --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer [[append]] ( final CharSequence [[csq]] , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { [[append]] ( [[csq]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer [[uniting]] ( final CharSequence [[ted]] , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { [[uniting]] ( [[ted]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 868 ---------------------------------------------
Visits an annotation . --> Get the Annotation visitor --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor [[visitAnnotation]] ( final String [[desc]] , final boolean [[visible]] ) { AnnotationVisitor [[destAnn]] = methodVisitor . visitAnnotation ( [[desc]] , [[visible]] ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor [[somethng]] ( final String [[dehydration]] , final boolean [[akin]] ) { AnnotationVisitor [[apprentice]] = methodVisitor . visitAnnotation ( [[dehydration]] , [[akin]] ) ;
[[[[Nl]]]]: Copies target method annotations .
[Succeeded / Failed / Skipped / Total] 774 / 74 / 21 / 869:  87%|████████▋ | 869/1000 [1:14:19<11:12,  5.13s/it][Succeeded / Failed / Skipped / Total] 774 / 74 / 21 / 869:  87%|████████▋ | 870/1000 [1:14:21<11:06,  5.13s/it][Succeeded / Failed / Skipped / Total] 775 / 74 / 21 / 870:  87%|████████▋ | 870/1000 [1:14:21<11:06,  5.13s/it][Succeeded / Failed / Skipped / Total] 775 / 74 / 21 / 870:  87%|████████▋ | 871/1000 [1:14:30<11:02,  5.13s/it][Succeeded / Failed / Skipped / Total] 776 / 74 / 21 / 871:  87%|████████▋ | 871/1000 [1:14:30<11:02,  5.13s/it][Succeeded / Failed / Skipped / Total] 776 / 74 / 21 / 871:  87%|████████▋ | 872/1000 [1:14:54<10:59,  5.15s/it][Succeeded / Failed / Skipped / Total] 777 / 74 / 21 / 872:  87%|████████▋ | 872/1000 [1:14:54<10:59,  5.15s/it][Succeeded / Failed / Skipped / Total] 777 / 74 / 21 / 872:  87%|████████▋ | 873/1000 [1:14:57<10:54,  5.15s/it][Succeeded / Failed / Skipped / Total] 778 / 74 / 21 / 873:  87%|████████▋ | 873/1000 [1:14:57<10:54,  5.15s/it][Succeeded / Failed / Skipped / Total] 778 / 74 / 21 / 873:  87%|████████▋ | 874/1000 [1:14:59<10:48,  5.15s/it][Succeeded / Failed / Skipped / Total] 779 / 74 / 21 / 874:  87%|████████▋ | 874/1000 [1:14:59<10:48,  5.15s/it][Succeeded / Failed / Skipped / Total] 779 / 74 / 21 / 874:  88%|████████▊ | 875/1000 [1:14:59<10:42,  5.14s/it][Succeeded / Failed / Skipped / Total] 780 / 74 / 21 / 875:  88%|████████▊ | 875/1000 [1:14:59<10:42,  5.14s/it][Succeeded / Failed / Skipped / Total] 780 / 74 / 21 / 875:  88%|████████▊ | 876/1000 [1:15:01<10:37,  5.14s/it]--------------------------------------------- Result 869 ---------------------------------------------
Processes the end of the proxy . --> Mentive operation --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[visitEnd]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void [[retentive]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[percent]] = 0 ; [[percent]] < tmd . proxyData . length ; [[percent]] ++ ) { tmd . selectCurrentProxy ( [[percent]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 870 ---------------------------------------------
Create the first chain . --> Called when the paraly is disabled --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[paralyzes]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 871 ---------------------------------------------
Create the first method that will be called when the method is called . --> tarek implementation --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData [[tmd]] ) { methodVisitor . visitCode ( ) ; if ( [[tmd]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[tmd]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[tarek]] ( final TargetMethodData [[sona]] ) { methodVisitor . visitCode ( ) ; if ( [[sona]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[sona]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[sona]] . firstMethodName ( ) , [[sona]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[sona]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[sona]] . firstMethodName ( ) , [[sona]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[sona]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 872 ---------------------------------------------
Returns the hash code for a name . --> Check if noon is present --> Socre: 1.0

[[[[Adv]]]]: private int [[hash]] ( final String [[name]] ) { int [[h]] = 0 ; for ( int [[i]] = [[name]] . length ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { char [[c]] = [[name]] . charAt ( [[i]] ) ; if ( ! caseSensitive ) { if ( [[c]] >= ' ' && [[c]] <= ' ' ) { [[c]] += 32 ; } } [[h]] = 31 * [[h]] + [[c]] ; } if ( [[h]] > 0 ) { return [[h]] ; } if ( [[h]] == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - [[h]] ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int [[meatloaf]] ( final String [[appointing]] ) { int [[noon]] = 0 ; for ( int [[ai]] = [[appointing]] . length ( ) - 1 ; [[ai]] >= 0 ; [[ai]] -- ) { char [[kevin]] = [[appointing]] . charAt ( [[ai]] ) ; if ( ! caseSensitive ) { if ( [[kevin]] >= ' ' && [[kevin]] <= ' ' ) { [[kevin]] += 32 ; } } [[noon]] = 31 * [[noon]] + [[kevin]] ; } if ( [[noon]] > 0 ) { return [[noon]] ; } if ( [[noon]] == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - [[noon]] ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 873 ---------------------------------------------
Increments the capacity . --> Set min capacity --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int minCapacity ) { final int [[oldCapacity]] = buffer . length ; int [[newCapacity]] = [[oldCapacity]] << 1 ; if ( [[newCapacity]] - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[broadened]] ( final int minCapacity ) { final int [[narcoleptic]] = buffer . length ; int [[concept]] = [[narcoleptic]] << 1 ; if ( [[concept]] - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 874 ---------------------------------------------
Configures servlet context . --> Configure the crushers --> Socre: 1.0

[[[[Adv]]]]: private void configureServletContext ( final ServletContext [[servletContext]] ) { [[servletContext]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = [[servletContext]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "[[True]]" == "[[True]]" , contextPath ) ; } final FilterRegistration filter = [[servletContext]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "[[True]]" == "[[True]]" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void configureServletContext ( final ServletContext [[crushers]] ) { [[crushers]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = [[crushers]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "[[Veritable]]" == "[[Veritable]]" , contextPath ) ; } final FilterRegistration filter = [[crushers]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "[[Veritable]]" == "[[Veritable]]" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 875 ---------------------------------------------
Adds a field . --> advancing a field --> Socre: 1.0

[[[[Adv]]]]: public Path [[push]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[advancing]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 876 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 781 / 74 / 21 / 876:  88%|████████▊ | 876/1000 [1:15:01<10:37,  5.14s/it][Succeeded / Failed / Skipped / Total] 781 / 74 / 21 / 876:  88%|████████▊ | 877/1000 [1:15:04<10:31,  5.14s/it][Succeeded / Failed / Skipped / Total] 782 / 74 / 21 / 877:  88%|████████▊ | 877/1000 [1:15:04<10:31,  5.14s/it][Succeeded / Failed / Skipped / Total] 782 / 74 / 21 / 877:  88%|████████▊ | 878/1000 [1:15:10<10:26,  5.14s/it][Succeeded / Failed / Skipped / Total] 783 / 74 / 21 / 878:  88%|████████▊ | 878/1000 [1:15:10<10:26,  5.14s/it][Succeeded / Failed / Skipped / Total] 783 / 74 / 21 / 878:  88%|████████▊ | 879/1000 [1:15:12<10:21,  5.13s/it][Succeeded / Failed / Skipped / Total] 784 / 74 / 21 / 879:  88%|████████▊ | 879/1000 [1:15:12<10:21,  5.13s/it][Succeeded / Failed / Skipped / Total] 784 / 74 / 21 / 879:  88%|████████▊ | 880/1000 [1:15:14<10:15,  5.13s/it][Succeeded / Failed / Skipped / Total] 785 / 74 / 21 / 880:  88%|████████▊ | 880/1000 [1:15:14<10:15,  5.13s/it][Succeeded / Failed / Skipped / Total] 785 / 74 / 21 / 880:  88%|████████▊ | 881/1000 [1:15:19<10:10,  5.13s/it][Succeeded / Failed / Skipped / Total] 786 / 74 / 21 / 881:  88%|████████▊ | 881/1000 [1:15:19<10:10,  5.13s/it][Succeeded / Failed / Skipped / Total] 786 / 74 / 21 / 881:  88%|████████▊ | 882/1000 [1:15:23<10:05,  5.13s/it][Succeeded / Failed / Skipped / Total] 787 / 74 / 21 / 882:  88%|████████▊ | 882/1000 [1:15:23<10:05,  5.13s/it][Succeeded / Failed / Skipped / Total] 787 / 74 / 21 / 882:  88%|████████▊ | 883/1000 [1:15:26<09:59,  5.13s/it]Execute the query . --> Executes the path --> Socre: 1.0

[[[[Adv]]]]: public Object execute ( ) { String methodName = targetMethodName ( ) ; Class [[returnType]] = [[returnType]] ( ) ; Object next = pathref . continueWith ( this , methodName , [[returnType]] ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object execute ( ) { String methodName = targetMethodName ( ) ; Class [[aristophanes]] = [[aristophanes]] ( ) ; Object next = pathref . continueWith ( this , methodName , [[aristophanes]] ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 877 ---------------------------------------------
Creates a new BeanDefinition . --> Creates a BeanDefinition for the specified Proxy --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > [[type]] , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[originalType]] = [[type]] ; final ProxettaFactory [[builder]] = proxetta . proxy ( ) ; [[builder]] . setTarget ( [[type]] ) ; [[type]] = [[builder]] . define ( ) ; return new ProxettaBeanDefinition ( name , [[type]] , scope , wiringMode , [[originalType]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , [[type]] , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > [[blokes]] , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[carload]] = [[blokes]] ; final ProxettaFactory [[setters]] = proxetta . proxy ( ) ; [[setters]] . setTarget ( [[blokes]] ) ; [[blokes]] = [[setters]] . define ( ) ; return new ProxettaBeanDefinition ( name , [[blokes]] , scope , wiringMode , [[carload]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , [[blokes]] , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 878 ---------------------------------------------
Convert JtxTransactionMode to the isolation level . --> Calculate the DbTransactionMode with the given filipino --> Socre: 1.0

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode [[txMode]] ) { final int [[isolation]] ; switch ( [[txMode]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[isolation]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[isolation]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[isolation]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[isolation]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[isolation]] , [[txMode]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[butterfinger]] ( final JtxTransactionMode [[filipino]] ) { final int [[vinyl]] ; switch ( [[filipino]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[vinyl]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[vinyl]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[vinyl]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[vinyl]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[vinyl]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[vinyl]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[vinyl]] , [[filipino]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 879 ---------------------------------------------
Reads a property . --> Getter method --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object [[source]] , final PropertyDescriptor [[propertyDescriptor]] ) { Getter getter = [[propertyDescriptor]] . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( [[source]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[villain]] ( final Object [[descent]] , final PropertyDescriptor [[eventually]] ) { Getter getter = [[eventually]] . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( [[descent]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 880 ---------------------------------------------
Adds the entry to the map . --> region > Entry --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[nunchucks]] ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 881 ---------------------------------------------
Appends a buffer to the list . --> Return a copy of the list --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[sharing]] ( final Buffer [[swab]] ) { if ( [[swab]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 882 ---------------------------------------------
Parse a Path . --> Calculate the current working directory --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[beatbox]] ( final String [[chemin]] ) { return [[chemin]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[chemin]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 883 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 788 / 74 / 21 / 883:  88%|████████▊ | 883/1000 [1:15:26<09:59,  5.13s/it][Succeeded / Failed / Skipped / Total] 788 / 74 / 21 / 883:  88%|████████▊ | 884/1000 [1:15:45<09:56,  5.14s/it][Succeeded / Failed / Skipped / Total] 789 / 74 / 21 / 884:  88%|████████▊ | 884/1000 [1:15:45<09:56,  5.14s/it][Succeeded / Failed / Skipped / Total] 789 / 74 / 21 / 884:  88%|████████▊ | 885/1000 [1:15:55<09:51,  5.15s/it][Succeeded / Failed / Skipped / Total] 790 / 74 / 21 / 885:  88%|████████▊ | 885/1000 [1:15:55<09:51,  5.15s/it][Succeeded / Failed / Skipped / Total] 790 / 74 / 21 / 885:  89%|████████▊ | 886/1000 [1:16:07<09:47,  5.16s/it][Succeeded / Failed / Skipped / Total] 791 / 74 / 21 / 886:  89%|████████▊ | 886/1000 [1:16:07<09:47,  5.16s/it][Succeeded / Failed / Skipped / Total] 791 / 74 / 21 / 886:  89%|████████▊ | 887/1000 [1:16:20<09:43,  5.16s/it][Succeeded / Failed / Skipped / Total] 792 / 74 / 21 / 887:  89%|████████▊ | 887/1000 [1:16:20<09:43,  5.16s/it][Succeeded / Failed / Skipped / Total] 792 / 74 / 21 / 887:  89%|████████▉ | 888/1000 [1:16:47<09:41,  5.19s/it][Succeeded / Failed / Skipped / Total] 792 / 75 / 21 / 888:  89%|████████▉ | 888/1000 [1:16:47<09:41,  5.19s/it][Succeeded / Failed / Skipped / Total] 792 / 75 / 21 / 888:  89%|████████▉ | 889/1000 [1:16:52<09:35,  5.19s/it]Returns an iterator over the entries in this map . --> region > improperly --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[iterator]] ( ) { final MapEntry [ ] [[e]] = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return [[e]] [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[next]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[next]] = [[e]] [ 0 ] ; [[e]] [ 0 ] = [[e]] [ 0 ] . after ; return [[next]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[improperly]] ( ) { final MapEntry [ ] [[d]] = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return [[d]] [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[immediate]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[immediate]] = [[d]] [ 0 ] ; [[d]] [ 0 ] = [[d]] [ 0 ] . after ; return [[immediate]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 884 ---------------------------------------------
Writes the buffers to the specified writer . --> F743 - 1 --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final Writer [[writer]] ) throws IOException { for ( Object [[o]] : list ) { if ( [[o]] instanceof FastByteBuffer ) { FastByteBuffer [[fastByteBuffer]] = ( FastByteBuffer ) [[o]] ; byte [ ] array = [[fastByteBuffer]] . toArray ( ) ; [[writer]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[o]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[o]] ; InputStream [[inputStream]] = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( [[inputStream]] , [[writer]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( [[inputStream]] ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void [[veterinarians]] ( final Writer [[poets]] ) throws IOException { for ( Object [[australians]] : list ) { if ( [[australians]] instanceof FastByteBuffer ) { FastByteBuffer [[cinemascope]] = ( FastByteBuffer ) [[australians]] ; byte [ ] array = [[cinemascope]] . toArray ( ) ; [[poets]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[australians]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[australians]] ; InputStream [[pugs]] = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( [[pugs]] , [[poets]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( [[pugs]] ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 885 ---------------------------------------------
Returns all values for the given name . --> Methode d nouns = nouns --> Socre: 1.0

[[[[Adv]]]]: public List < V > [[getAll]] ( final String [[name]] ) { LinkedList < V > [[values]] = new LinkedList <> ( ) ; int [[h]] = hash ( [[name]] ) ; int i = index ( [[h]] ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == [[h]] && eq ( [[name]] , e . key ) ) { [[values]] . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return [[values]] ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > [[meekly]] ( final String [[nouns]] ) { LinkedList < V > [[deserved]] = new LinkedList <> ( ) ; int [[hora]] = hash ( [[nouns]] ) ; int i = index ( [[hora]] ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == [[hora]] && eq ( [[nouns]] , e . key ) ) { [[deserved]] . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return [[deserved]] ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 886 ---------------------------------------------
Writes the progress listener to the OutputStream . --> litter Action --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream [[out]] , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[litter]] ( final OutputStream [[leaving]] , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 887 ---------------------------------------------
Writes the Uploadable data to the given OutputStream . --> Gibt ein --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream [[out]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[fastByteBuffer]] = ( FastByteBuffer ) o ; [[out]] . write ( [[fastByteBuffer]] . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable [[uploadable]] = ( Uploadable ) o ; InputStream [[inputStream]] = [[uploadable]] . openInputStream ( ) ; try { StreamUtil . copy ( [[inputStream]] , [[out]] ) ; } finally { StreamUtil . close ( [[inputStream]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void [[crewmen]] ( final OutputStream [[orifice]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[dozo]] = ( FastByteBuffer ) o ; [[orifice]] . write ( [[dozo]] . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable [[antsy]] = ( Uploadable ) o ; InputStream [[haller]] = [[antsy]] . openInputStream ( ) ; try { StreamUtil . copy ( [[haller]] , [[orifice]] ) ; } finally { StreamUtil . close ( [[haller]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 888 ---------------------------------------------
Create an action . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 889 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 793 / 75 / 21 / 889:  89%|████████▉ | 889/1000 [1:16:52<09:35,  5.19s/it][Succeeded / Failed / Skipped / Total] 793 / 75 / 21 / 889:  89%|████████▉ | 890/1000 [1:17:14<09:32,  5.21s/it][Succeeded / Failed / Skipped / Total] 794 / 75 / 21 / 890:  89%|████████▉ | 890/1000 [1:17:14<09:32,  5.21s/it][Succeeded / Failed / Skipped / Total] 794 / 75 / 21 / 890:  89%|████████▉ | 891/1000 [1:17:15<09:27,  5.20s/it][Succeeded / Failed / Skipped / Total] 795 / 75 / 21 / 891:  89%|████████▉ | 891/1000 [1:17:15<09:27,  5.20s/it][Succeeded / Failed / Skipped / Total] 795 / 75 / 21 / 891:  89%|████████▉ | 892/1000 [1:17:27<09:22,  5.21s/it][Succeeded / Failed / Skipped / Total] 796 / 75 / 21 / 892:  89%|████████▉ | 892/1000 [1:17:27<09:22,  5.21s/it][Succeeded / Failed / Skipped / Total] 796 / 75 / 21 / 892:  89%|████████▉ | 893/1000 [1:17:32<09:17,  5.21s/it][Succeeded / Failed / Skipped / Total] 797 / 75 / 21 / 893:  89%|████████▉ | 893/1000 [1:17:32<09:17,  5.21s/it][Succeeded / Failed / Skipped / Total] 797 / 75 / 21 / 893:  89%|████████▉ | 894/1000 [1:17:37<09:12,  5.21s/it][Succeeded / Failed / Skipped / Total] 798 / 75 / 21 / 894:  89%|████████▉ | 894/1000 [1:17:37<09:12,  5.21s/it][Succeeded / Failed / Skipped / Total] 798 / 75 / 21 / 894:  90%|████████▉ | 895/1000 [1:17:40<09:06,  5.21s/it]Get a Long value . --> Get a representation of a number --> Socre: 1.0

[[[[Adv]]]]: public Long [[getLong]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long [[ballistics]] ( final String [[vitale]] ) { Number number = ( Number ) map . get ( [[vitale]] ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 890 ---------------------------------------------
Gets a Float . --> pads a crucial --> Socre: 1.0

[[[[Adv]]]]: public Float [[getFloat]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float [[padilla]] ( final String [[crucial]] ) { Number number = ( Number ) map . get ( [[crucial]] ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 891 ---------------------------------------------
Helper method to add a constant . --> region marca Implementation --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantDynamicOrInvokeDynamicReference]] ( final int [[tag]] , final String name , final String [[descriptor]] , final int bootstrapMethodIndex ) { int [[hashCode]] = hash ( [[tag]] , name , [[descriptor]] , bootstrapMethodIndex ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == [[hashCode]] && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( [[descriptor]] ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( [[tag]] , bootstrapMethodIndex , addConstantNameAndType ( name , [[descriptor]] ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , null , name , [[descriptor]] , bootstrapMethodIndex , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[spock]] ( final int [[marca]] , final String name , final String [[coochy]] , final int bootstrapMethodIndex ) { int [[alvarez]] = hash ( [[marca]] , name , [[coochy]] , bootstrapMethodIndex ) ; Entry entry = get ( [[alvarez]] ) ; while ( entry != null ) { if ( entry . tag == [[marca]] && entry . hashCode == [[alvarez]] && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( [[coochy]] ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( [[marca]] , bootstrapMethodIndex , addConstantNameAndType ( name , [[coochy]] ) ) ; return put ( new Entry ( constantPoolCount ++ , [[marca]] , null , name , [[coochy]] , bootstrapMethodIndex , [[alvarez]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 892 ---------------------------------------------
Attempts to the specified folder . --> Attempt to connect to the given serbs --> Socre: 1.0

[[[[Adv]]]]: public void [[useFolder]] ( final String [[folderName]] ) { closeFolderIfOpened ( folder ) ; try { this . [[folderName]] = [[folderName]] ; this . [[folder]] = getService ( ) . getFolder ( [[folderName]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[folderName]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void [[lnsurance]] ( final String [[serbs]] ) { closeFolderIfOpened ( folder ) ; try { this . [[bolting]] = [[serbs]] ; this . [[zip]] = getService ( ) . getFolder ( [[serbs]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[serbs]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 893 ---------------------------------------------
Adds a string value to the map . --> Concatenates basic and importance --> Socre: 1.0

[[[[Adv]]]]: public JsonObject [[put]] ( final String [[key]] , final String [[value]] ) { Objects . requireNonNull ( [[key]] ) ; map . put ( [[key]] , [[value]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[introducing]] ( final String [[basic]] , final String [[importance]] ) { Objects . requireNonNull ( [[basic]] ) ; map . put ( [[basic]] , [[importance]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 894 ---------------------------------------------
Returns all messages from the EmailFilter . --> remove all messages --> Socre: 1.0

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[filter]] , final Flags flagsToSet , final Flags flagsToUnset , final boolean [[envelope]] , final Consumer < Message [ ] > [[processedMessageConsumer]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] [[messages]] ; try { if ( [[filter]] == null ) { [[messages]] = folder . getMessages ( ) ; } else { [[messages]] = folder . search ( [[filter]] . getSearchTerm ( ) ) ; } if ( [[messages]] . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( [[envelope]] ) { final FetchProfile [[fetchProfile]] = new FetchProfile ( ) ; [[fetchProfile]] . add ( FetchProfile . Item . ENVELOPE ) ; [[fetchProfile]] . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( [[messages]] , [[fetchProfile]] ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[specimen]] , final Flags flagsToSet , final Flags flagsToUnset , final boolean [[enclosing]] , final Consumer < Message [ ] > [[dyeing]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] [[embassies]] ; try { if ( [[specimen]] == null ) { [[embassies]] = folder . getMessages ( ) ; } else { [[embassies]] = folder . search ( [[specimen]] . getSearchTerm ( ) ) ; } if ( [[embassies]] . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( [[enclosing]] ) { final FetchProfile [[logan]] = new FetchProfile ( ) ; [[logan]] . add ( FetchProfile . Item . ENVELOPE ) ; [[logan]] . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( [[embassies]] , [[logan]] ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 895 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 799 / 75 / 21 / 895:  90%|████████▉ | 895/1000 [1:17:40<09:06,  5.21s/it][Succeeded / Failed / Skipped / Total] 799 / 75 / 21 / 895:  90%|████████▉ | 896/1000 [1:17:41<09:01,  5.20s/it][Succeeded / Failed / Skipped / Total] 800 / 75 / 21 / 896:  90%|████████▉ | 896/1000 [1:17:41<09:01,  5.20s/it][Succeeded / Failed / Skipped / Total] 800 / 75 / 21 / 896:  90%|████████▉ | 897/1000 [1:17:43<08:55,  5.20s/it][Succeeded / Failed / Skipped / Total] 801 / 75 / 21 / 897:  90%|████████▉ | 897/1000 [1:17:43<08:55,  5.20s/it][Succeeded / Failed / Skipped / Total] 801 / 75 / 21 / 897:  90%|████████▉ | 898/1000 [1:17:44<08:49,  5.19s/it][Succeeded / Failed / Skipped / Total] 802 / 75 / 21 / 898:  90%|████████▉ | 898/1000 [1:17:44<08:49,  5.19s/it][Succeeded / Failed / Skipped / Total] 802 / 75 / 21 / 898:  90%|████████▉ | 899/1000 [1:17:45<08:44,  5.19s/it][Succeeded / Failed / Skipped / Total] 802 / 76 / 21 / 899:  90%|████████▉ | 899/1000 [1:17:45<08:44,  5.19s/it][Succeeded / Failed / Skipped / Total] 802 / 76 / 21 / 899:  90%|█████████ | 900/1000 [1:17:45<08:38,  5.18s/it][Succeeded / Failed / Skipped / Total] 803 / 76 / 21 / 900:  90%|█████████ | 900/1000 [1:17:45<08:38,  5.18s/it][Succeeded / Failed / Skipped / Total] 803 / 76 / 21 / 900:  90%|█████████ | 901/1000 [1:17:46<08:32,  5.18s/it][Succeeded / Failed / Skipped / Total] 804 / 76 / 21 / 901:  90%|█████████ | 901/1000 [1:17:46<08:32,  5.18s/it][Succeeded / Failed / Skipped / Total] 804 / 76 / 21 / 901:  90%|█████████ | 902/1000 [1:17:54<08:27,  5.18s/it][Succeeded / Failed / Skipped / Total] 805 / 76 / 21 / 902:  90%|█████████ | 902/1000 [1:17:54<08:27,  5.18s/it][Succeeded / Failed / Skipped / Total] 805 / 76 / 21 / 902:  90%|█████████ | 903/1000 [1:17:58<08:22,  5.18s/it]Updates the received email flags . --> Should be used for debugging --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail [[receivedEmail]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[receivedEmail]] . messageNumber ( ) } , [[receivedEmail]] . flags ( ) , "[[True]]" == "[[True]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[chiefest]] ( final ReceivedEmail [[arent]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[arent]] . messageNumber ( ) } , [[arent]] . flags ( ) , "[[Staunch]]" == "[[Staunch]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 896 ---------------------------------------------
Close the folder if it does not exist . --> tikal timer --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "[[True]]" == "[[True]]" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[tikal]] ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "[[Realistic]]" == "[[Realistic]]" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 897 ---------------------------------------------
Returns all field descriptors . --> Get the field names from the catalog --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor [ ] [[getAllFieldDescriptors]] ( ) { if ( [[allFields]] == null ) { FieldDescriptor [ ] [[allFields]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[index]] = 0 ; for ( FieldDescriptor [[fieldDescriptor]] : fieldsMap . values ( ) ) { [[allFields]] [ [[index]] ] = [[fieldDescriptor]] ; [[index]] ++ ; } Arrays . sort ( [[allFields]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[allFields]] = [[allFields]] ; } return [[allFields]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] [[eggplants]] ( ) { if ( [[usurped]] == null ) { FieldDescriptor [ ] [[usurped]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[catalogue]] = 0 ; for ( FieldDescriptor [[snapped]] : fieldsMap . values ( ) ) { [[usurped]] [ [[catalogue]] ] = [[snapped]] ; [[catalogue]] ++ ; } Arrays . sort ( [[usurped]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[chickened]] = [[usurped]] ; } return [[usurped]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 898 ---------------------------------------------
Returns the alias for the given target . --> Get the faux for the given target --> Socre: 1.0

[[[[Adv]]]]: protected String [[alias]] ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[faux]] ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 899 ---------------------------------------------
Add a constant . --> [[[FAILED]]]

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 900 ---------------------------------------------
Validates an action . --> Does this vtor? --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... [[profiles]] ) { prepareValidator ( ) ; vtor . useProfiles ( [[profiles]] ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[violations]] = vtor . getViolations ( ) ; return [[violations]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[aspects]] ( final String ... [[portrayal]] ) { prepareValidator ( ) ; vtor . useProfiles ( [[portrayal]] ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[abuses]] = vtor . getViolations ( ) ; return [[abuses]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 901 ---------------------------------------------
Sets the mime type . --> Replies the data for the given shania . --> Socre: 1.0

[[[[Adv]]]]: public RawData as ( final String [[mimeOrExtension]] ) { if ( [[mimeOrExtension]] . contains ( StringPool . SLASH ) ) { this . mimeType = [[mimeOrExtension]] ; } else { this . mimeType = MimeTypes . getMimeType ( [[mimeOrExtension]] ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData as ( final String [[shania]] ) { if ( [[shania]] . contains ( StringPool . SLASH ) ) { this . mimeType = [[shania]] ; } else { this . mimeType = MimeTypes . getMimeType ( [[shania]] ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 902 ---------------------------------------------
Retrieve a double value . --> biochemistry in map --> Socre: 1.0

[[[[Adv]]]]: public Double [[getDouble]] ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Double ) { return ( Double ) [[number]] ; } return [[number]] . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[biochemistry]] ( final String [[critical]] ) { Number [[amounts]] = ( Number ) map . get ( [[critical]] ) ; if ( [[amounts]] == null ) { return null ; } if ( [[amounts]] instanceof Double ) { return ( Double ) [[amounts]] ; } return [[amounts]] . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
[Succeeded / Failed / Skipped / Total] 806 / 76 / 21 / 903:  90%|█████████ | 903/1000 [1:17:58<08:22,  5.18s/it][Succeeded / Failed / Skipped / Total] 806 / 76 / 21 / 903:  90%|█████████ | 904/1000 [1:18:01<08:17,  5.18s/it][Succeeded / Failed / Skipped / Total] 807 / 76 / 21 / 904:  90%|█████████ | 904/1000 [1:18:01<08:17,  5.18s/it][Succeeded / Failed / Skipped / Total] 807 / 76 / 21 / 904:  90%|█████████ | 905/1000 [1:18:02<08:11,  5.17s/it][Succeeded / Failed / Skipped / Total] 808 / 76 / 21 / 905:  90%|█████████ | 905/1000 [1:18:02<08:11,  5.17s/it][Succeeded / Failed / Skipped / Total] 808 / 76 / 21 / 905:  91%|█████████ | 906/1000 [1:18:04<08:06,  5.17s/it][Succeeded / Failed / Skipped / Total] 808 / 77 / 21 / 906:  91%|█████████ | 906/1000 [1:18:04<08:06,  5.17s/it][Succeeded / Failed / Skipped / Total] 808 / 77 / 21 / 906:  91%|█████████ | 907/1000 [1:18:06<08:00,  5.17s/it][Succeeded / Failed / Skipped / Total] 809 / 77 / 21 / 907:  91%|█████████ | 907/1000 [1:18:06<08:00,  5.17s/it][Succeeded / Failed / Skipped / Total] 809 / 77 / 21 / 907:  91%|█████████ | 908/1000 [1:18:09<07:55,  5.17s/it][Succeeded / Failed / Skipped / Total] 810 / 77 / 21 / 908:  91%|█████████ | 908/1000 [1:18:09<07:55,  5.17s/it][Succeeded / Failed / Skipped / Total] 810 / 77 / 21 / 908:  91%|█████████ | 909/1000 [1:18:23<07:50,  5.17s/it][Succeeded / Failed / Skipped / Total] 811 / 77 / 21 / 909:  91%|█████████ | 909/1000 [1:18:23<07:50,  5.17s/it][Succeeded / Failed / Skipped / Total] 811 / 77 / 21 / 909:  91%|█████████ | 910/1000 [1:18:25<07:45,  5.17s/it][Succeeded / Failed / Skipped / Total] 812 / 77 / 21 / 910:  91%|█████████ | 910/1000 [1:18:25<07:45,  5.17s/it][Succeeded / Failed / Skipped / Total] 812 / 77 / 21 / 910:  91%|█████████ | 911/1000 [1:18:26<07:39,  5.17s/it][Succeeded / Failed / Skipped / Total] 813 / 77 / 21 / 911:  91%|█████████ | 911/1000 [1:18:26<07:39,  5.17s/it][Succeeded / Failed / Skipped / Total] 813 / 77 / 21 / 911:  91%|█████████ | 912/1000 [1:18:26<07:34,  5.16s/it][Succeeded / Failed / Skipped / Total] 813 / 77 / 22 / 912:  91%|█████████ | 912/1000 [1:18:26<07:34,  5.16s/it][Succeeded / Failed / Skipped / Total] 813 / 77 / 22 / 912:  91%|█████████▏| 913/1000 [1:18:27<07:28,  5.16s/it][Succeeded / Failed / Skipped / Total] 814 / 77 / 22 / 913:  91%|█████████▏| 913/1000 [1:18:27<07:28,  5.16s/it]--------------------------------------------- Result 903 ---------------------------------------------
Looks up a named named parameter . --> returns null if not found --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( [[name]] ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[peaty]] ( final String [[acronym]] ) { DbQueryNamedParameter [[phosphates]] = rootNP ; while ( [[phosphates]] != null ) { if ( [[phosphates]] . equalsName ( [[acronym]] ) ) { return [[phosphates]] ; } [[phosphates]] = [[phosphates]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 904 ---------------------------------------------
Get the target . --> Get the horseradish from the given InputStream --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream [[target]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[target]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[horseradish]] ( final InputStream [[aiming]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[aiming]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 905 ---------------------------------------------
Process the target . --> This method initializes targetInputStream --> Socre: 1.0

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[manipulating]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 906 ---------------------------------------------
Adds a Violation . --> [[[FAILED]]]

[[[[Adv]]]]: protected void addViolation ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void addViolation ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 907 ---------------------------------------------
Create the proxy . --> constructs the proxy --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] result = toByteArray ( ) ; dumpClassInDebugFolder ( result ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return result ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[constructs]] ( ) { process ( ) ; byte [ ] result = toByteArray ( ) ; dumpClassInDebugFolder ( result ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return result ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 908 ---------------------------------------------
Creates new Proxetta class instance . --> Create a span object --> Socre: 1.0

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class [[type]] = define ( ) ; try { return ClassUtil . newInstance ( [[type]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[spaniel]] ( ) { Class [[genus]] = define ( ) ; try { return ClassUtil . newInstance ( [[genus]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 909 ---------------------------------------------
Downloads file content . --> Sets brakes --> Socre: 1.0

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String [[downloadFileName]] ) { this . [[downloadFileName]] = [[downloadFileName]] ; this . [[mimeType]] = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[accelerant]] ( final String [[brakes]] ) { this . [[ratios]] = [[brakes]] ; this . [[playful]] = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[brakes]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 910 ---------------------------------------------
Create a new EmailAddress . --> Convenience method for creating a new EmailAddress --> Socre: 1.0

[[[[Adv]]]]: public T from ( final String [[personalName]] , final String [[from]] ) { return from ( new EmailAddress ( [[personalName]] , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T from ( final String [[mediocrity]] , final String [[en]] ) { return from ( new EmailAddress ( [[mediocrity]] , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 911 ---------------------------------------------
Returns the integer value associated with the given key . --> Methode d a Number --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getInteger]] ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Integer ) { return ( Integer ) [[number]] ; } return [[number]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer [[marts]] ( final String [[needed]] ) { Number [[many]] = ( Number ) map . get ( [[needed]] ) ; if ( [[many]] == null ) { return null ; } if ( [[many]] instanceof Integer ) { return ( Integer ) [[many]] ; } return [[many]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 912 ---------------------------------------------
Create a EmailAddress --> [[[SKIPPED]]]

[[[[Adv]]]]: public T to ( final String personalName , final String to ) { return to ( new EmailAddress ( personalName , to ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 913 ---------------------------------------------
Append the given address to this address . --> Add a new EmailAddress --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final EmailAddress [[to]] ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[sur]] ( final EmailAddress [[by]] ) { this . [[chez]] = ArraysUtil . append ( this . [[chez]] , [[sur]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 914 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 815 / 77 / 22 / 914:  91%|█████████▏| 914/1000 [1:18:28<07:22,  5.15s/it][Succeeded / Failed / Skipped / Total] 815 / 77 / 22 / 914:  92%|█████████▏| 915/1000 [1:18:28<07:17,  5.15s/it][Succeeded / Failed / Skipped / Total] 816 / 77 / 22 / 915:  92%|█████████▏| 915/1000 [1:18:28<07:17,  5.15s/it][Succeeded / Failed / Skipped / Total] 817 / 77 / 22 / 916:  92%|█████████▏| 916/1000 [1:18:29<07:11,  5.14s/it][Succeeded / Failed / Skipped / Total] 817 / 77 / 22 / 916:  92%|█████████▏| 917/1000 [1:18:35<07:06,  5.14s/it][Succeeded / Failed / Skipped / Total] 818 / 77 / 22 / 917:  92%|█████████▏| 917/1000 [1:18:35<07:06,  5.14s/it][Succeeded / Failed / Skipped / Total] 819 / 77 / 22 / 918:  92%|█████████▏| 918/1000 [1:18:44<07:02,  5.15s/it][Succeeded / Failed / Skipped / Total] 819 / 77 / 22 / 918:  92%|█████████▏| 919/1000 [1:18:45<06:56,  5.14s/it][Succeeded / Failed / Skipped / Total] 820 / 77 / 22 / 919:  92%|█████████▏| 919/1000 [1:18:45<06:56,  5.14s/it][Succeeded / Failed / Skipped / Total] 820 / 77 / 22 / 919:  92%|█████████▏| 920/1000 [1:18:48<06:51,  5.14s/it][Succeeded / Failed / Skipped / Total] 821 / 77 / 22 / 920:  92%|█████████▏| 920/1000 [1:18:48<06:51,  5.14s/it][Succeeded / Failed / Skipped / Total] 821 / 77 / 22 / 920:  92%|█████████▏| 921/1000 [1:18:50<06:45,  5.14s/it][Succeeded / Failed / Skipped / Total] 822 / 77 / 22 / 921:  92%|█████████▏| 921/1000 [1:18:50<06:45,  5.14s/it][Succeeded / Failed / Skipped / Total] 822 / 77 / 22 / 921:  92%|█████████▏| 922/1000 [1:18:52<06:40,  5.13s/it]Return a copy of the specified REPLACEME0 . --> Set an OING --> Socre: 1.0

[[[[Adv]]]]: public T [[REPLACEME0]] ( final EmailAddress ... [[REPLACEME0]] ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( [[REPLACEME0]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T [[OING]] ( final EmailAddress ... [[OING]] ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( [[OING]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 915 ---------------------------------------------
Sets a cc address . --> Join ccs --> Socre: 1.0

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[qb]] ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 916 ---------------------------------------------
Set the text message . --> audio type --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String [[text]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[audiovisual]] ( final String [[phraseology]] , final String [[negev]] ) { return message ( new EmailMessage ( [[phraseology]] , MimeTypes . MIME_TEXT_PLAIN , [[negev]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 917 ---------------------------------------------
Prints debug folder to debug folder . --> The method egoism method --> Socre: 1.0

[[[[Adv]]]]: protected void [[dumpClassInDebugFolder]] ( final byte [ ] bytes ) { File [[debugFolder]] = proxetta . getDebugFolder ( ) ; if ( [[debugFolder]] == null ) { return ; } if ( ! [[debugFolder]] . exists ( ) || ! [[debugFolder]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[debugFolder]] ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File [[file]] = new File ( [[debugFolder]] , fileName ) ; try { FileUtil . writeBytes ( [[file]] , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + [[file]] , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void [[egoism]] ( final byte [ ] bytes ) { File [[steed]] = proxetta . getDebugFolder ( ) ; if ( [[steed]] == null ) { return ; } if ( ! [[steed]] . exists ( ) || ! [[steed]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[steed]] ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File [[deposition]] = new File ( [[steed]] , fileName ) ; try { FileUtil . writeBytes ( [[deposition]] , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + [[deposition]] , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 918 ---------------------------------------------
Adds an html message . --> Create a new EmailMessage --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String [[html]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[volume]] ( final String [[formats]] , final String [[blowhard]] ) { return message ( new EmailMessage ( [[formats]] , MimeTypes . MIME_TEXT_HTML , [[blowhard]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 919 ---------------------------------------------
Sets a header . --> Add a legend --> Socre: 1.0

[[[[Adv]]]]: public T [[header]] ( final String [[name]] , final String [[value]] ) { headers . put ( [[name]] , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[legend]] ( final String [[moniker]] , final String [[treasured]] ) { headers . put ( [[moniker]] , [[treasured]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 920 ---------------------------------------------
Defines the class . --> This method is used to establish the proxy --> Socre: 1.0

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[classLoader]] = proxetta . getClassLoader ( ) ; if ( [[classLoader]] == null ) { [[classLoader]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[classLoader]] == null ) && ( targetClass != null ) ) { [[classLoader]] = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , [[classLoader]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[establishing]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[dul]] = proxetta . getClassLoader ( ) ; if ( [[dul]] == null ) { [[dul]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[dul]] == null ) && ( targetClass != null ) ) { [[dul]] = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , [[dul]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 921 ---------------------------------------------
Parses a long value . --> Get a phalanx --> Socre: 1.0

[[[[Adv]]]]: public static long getInt ( final String [[name]] , final int [[defaultValue]] ) { String value = get ( [[name]] ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long getInt ( final String [[behalf]] , final int [[phalanx]] ) { String value = get ( [[behalf]] ) ; if ( value == null ) { return [[phalanx]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return [[phalanx]] ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 922 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 823 / 77 / 22 / 922:  92%|█████████▏| 922/1000 [1:18:52<06:40,  5.13s/it][Succeeded / Failed / Skipped / Total] 823 / 77 / 22 / 922:  92%|█████████▏| 923/1000 [1:18:56<06:35,  5.13s/it][Succeeded / Failed / Skipped / Total] 824 / 77 / 22 / 923:  92%|█████████▏| 923/1000 [1:18:56<06:35,  5.13s/it][Succeeded / Failed / Skipped / Total] 824 / 77 / 22 / 923:  92%|█████████▏| 924/1000 [1:18:57<06:29,  5.13s/it][Succeeded / Failed / Skipped / Total] 825 / 77 / 22 / 924:  92%|█████████▏| 924/1000 [1:18:57<06:29,  5.13s/it][Succeeded / Failed / Skipped / Total] 825 / 77 / 22 / 924:  92%|█████████▎| 925/1000 [1:19:06<06:24,  5.13s/it][Succeeded / Failed / Skipped / Total] 826 / 77 / 22 / 925:  92%|█████████▎| 925/1000 [1:19:06<06:24,  5.13s/it][Succeeded / Failed / Skipped / Total] 826 / 77 / 22 / 925:  93%|█████████▎| 926/1000 [1:19:07<06:19,  5.13s/it][Succeeded / Failed / Skipped / Total] 827 / 77 / 22 / 926:  93%|█████████▎| 926/1000 [1:19:07<06:19,  5.13s/it][Succeeded / Failed / Skipped / Total] 827 / 77 / 22 / 926:  93%|█████████▎| 927/1000 [1:19:10<06:14,  5.12s/it][Succeeded / Failed / Skipped / Total] 828 / 77 / 22 / 927:  93%|█████████▎| 927/1000 [1:19:10<06:14,  5.12s/it][Succeeded / Failed / Skipped / Total] 828 / 77 / 22 / 927:  93%|█████████▎| 928/1000 [1:19:12<06:08,  5.12s/it][Succeeded / Failed / Skipped / Total] 829 / 77 / 22 / 928:  93%|█████████▎| 928/1000 [1:19:12<06:08,  5.12s/it][Succeeded / Failed / Skipped / Total] 829 / 77 / 22 / 928:  93%|█████████▎| 929/1000 [1:19:16<06:03,  5.12s/it]Get the value of a property --> Helper method to gain a given number --> Socre: 1.0

[[[[Adv]]]]: public static String [[get]] ( final String [[name]] , final String [[defaultValue]] ) { Objects . requireNonNull ( [[name]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[name]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[name]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[defaultValue]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String [[gain]] ( final String [[number]] , final String [[fusiliers]] ) { Objects . requireNonNull ( [[number]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[number]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[number]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[fusiliers]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 923 ---------------------------------------------
Gets the target object . --> Get the thumbnail --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[omocha]] ( final Class [[millennium]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[millennium]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[millennium]] . getName ( ) ) ; } targetClass = [[millennium]] ; targetClassName = [[millennium]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[millennium]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 924 ---------------------------------------------
Serialize a key value pair . --> Returns the number of elements in the path --> Socre: 1.0

[[[[Adv]]]]: protected int [[serializeKeyValue]] ( final JsonContext [[jsonContext]] , final Path [[currentPath]] , final Object key , final Object value , int count ) { if ( ( value == null ) && [[jsonContext]] . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { [[currentPath]] . push ( key . toString ( ) ) ; } else { [[currentPath]] . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int [[madly]] ( final JsonContext [[temps]] , final Path [[expert]] , final Object key , final Object value , int count ) { if ( ( value == null ) && [[temps]] . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { [[expert]] . push ( key . toString ( ) ) ; } else { [[expert]] . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 925 ---------------------------------------------
Lookup the alias . --> Create the syn --> Socre: 1.0

[[[[Adv]]]]: protected String [[lookupAlias]] ( final String [[alias]] ) { String value = actionsManager . lookupPathAlias ( [[alias]] ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( [[alias]] ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String [[the]] ( final String [[synonymous]] ) { String value = actionsManager . lookupPathAlias ( [[synonymous]] ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( [[synonymous]] ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 926 ---------------------------------------------
Resolve alias . --> Helper method for unnecessary --> Socre: 1.0

[[[[Adv]]]]: protected String [[resolveAlias]] ( final String value ) { final StringBuilder [[result]] = new StringBuilder ( value . length ( ) ) ; int [[i]] = 0 ; int len = value . length ( ) ; while ( [[i]] < len ) { int ndx = value . indexOf ( ' ' , [[i]] ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String [[unnecessary]] ( final String value ) { final StringBuilder [[achievement]] = new StringBuilder ( value . length ( ) ) ; int [[al]] = 0 ; int len = value . length ( ) ; while ( [[al]] < len ) { int ndx = value . indexOf ( ' ' , [[al]] ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 927 ---------------------------------------------
Gets the result path . --> Woo a query --> Socre: 1.0

[[[[Adv]]]]: public ResultPath [[resolveResultPath]] ( String [[path]] , String [[value]] ) { boolean [[absolutePath]] = "[[False]]" != "[[False]]" ; if ( [[value]] != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath [[wooed]] ( String [[way]] , String [[relevance]] ) { boolean [[benzie]] = "[[Forged]]" != "[[Forged]]" ; if ( [[relevance]] != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 928 ---------------------------------------------
Get the index of the last slash separator . --> return antarctica --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String [[str]] ) { int [[slashNdx]] = [[str]] . lastIndexOf ( ' ' ) ; int [[dotNdx]] = StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , [[slashNdx]] ) ; if ( [[dotNdx]] == - 1 ) { if ( [[slashNdx]] == - 1 ) { return - 1 ; } [[slashNdx]] ++ ; if ( [[slashNdx]] < [[str]] . length ( ) - 1 ) { [[dotNdx]] = [[slashNdx]] ; } else { [[dotNdx]] = - 1 ; } } return [[dotNdx]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[antarctica]] ( final String [[sti]] ) { int [[foosball]] = [[sti]] . lastIndexOf ( ' ' ) ; int [[goodenough]] = StringUtil . lastIndexOf ( [[sti]] , ' ' , [[sti]] . length ( ) , [[foosball]] ) ; if ( [[goodenough]] == - 1 ) { if ( [[foosball]] == - 1 ) { return - 1 ; } [[foosball]] ++ ; if ( [[foosball]] < [[sti]] . length ( ) - 1 ) { [[goodenough]] = [[foosball]] ; } else { [[goodenough]] = - 1 ; } } return [[goodenough]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 929 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 830 / 77 / 22 / 929:  93%|█████████▎| 929/1000 [1:19:16<06:03,  5.12s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 22 / 929:  93%|█████████▎| 930/1000 [1:19:37<05:59,  5.14s/it][Succeeded / Failed / Skipped / Total] 831 / 77 / 22 / 930:  93%|█████████▎| 930/1000 [1:19:37<05:59,  5.14s/it][Succeeded / Failed / Skipped / Total] 831 / 77 / 22 / 930:  93%|█████████▎| 931/1000 [1:19:39<05:54,  5.13s/it][Succeeded / Failed / Skipped / Total] 832 / 77 / 22 / 931:  93%|█████████▎| 931/1000 [1:19:39<05:54,  5.13s/it][Succeeded / Failed / Skipped / Total] 832 / 77 / 22 / 931:  93%|█████████▎| 932/1000 [1:19:45<05:49,  5.13s/it][Succeeded / Failed / Skipped / Total] 833 / 77 / 22 / 932:  93%|█████████▎| 932/1000 [1:19:45<05:49,  5.13s/it][Succeeded / Failed / Skipped / Total] 833 / 77 / 22 / 932:  93%|█████████▎| 933/1000 [1:19:51<05:44,  5.14s/it][Succeeded / Failed / Skipped / Total] 834 / 77 / 22 / 933:  93%|█████████▎| 933/1000 [1:19:51<05:44,  5.14s/it][Succeeded / Failed / Skipped / Total] 834 / 77 / 22 / 933:  93%|█████████▎| 934/1000 [1:20:03<05:39,  5.14s/it][Succeeded / Failed / Skipped / Total] 835 / 77 / 22 / 934:  93%|█████████▎| 934/1000 [1:20:03<05:39,  5.14s/it][Succeeded / Failed / Skipped / Total] 835 / 77 / 22 / 934:  94%|█████████▎| 935/1000 [1:20:07<05:34,  5.14s/it][Succeeded / Failed / Skipped / Total] 836 / 77 / 22 / 935:  94%|█████████▎| 935/1000 [1:20:07<05:34,  5.14s/it][Succeeded / Failed / Skipped / Total] 836 / 77 / 22 / 935:  94%|█████████▎| 936/1000 [1:20:08<05:28,  5.14s/it][Succeeded / Failed / Skipped / Total] 837 / 77 / 22 / 936:  94%|█████████▎| 936/1000 [1:20:08<05:28,  5.14s/it][Succeeded / Failed / Skipped / Total] 837 / 77 / 22 / 936:  94%|█████████▎| 937/1000 [1:20:08<05:23,  5.13s/it][Succeeded / Failed / Skipped / Total] 837 / 77 / 23 / 937:  94%|█████████▎| 937/1000 [1:20:08<05:23,  5.13s/it][Succeeded / Failed / Skipped / Total] 837 / 77 / 23 / 937:  94%|█████████▍| 938/1000 [1:20:10<05:17,  5.13s/it]Get long . --> Gets the rucksack value --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLong]] ( final String [[name]] , final long defaultValue ) { String value = get ( [[name]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long [[rucksack]] ( final String [[behalf]] , final long defaultValue ) { String value = get ( [[behalf]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 930 ---------------------------------------------
Gets the last dot after slash . --> tearful function --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String str ) { int [[slashNdx]] = str . lastIndexOf ( ' ' ) ; [[slashNdx]] ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[slashNdx]] ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[tearful]] ( final String str ) { int [[chambermaids]] = str . lastIndexOf ( ' ' ) ; [[chambermaids]] ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[chambermaids]] ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 931 ---------------------------------------------
Strip last camel word . --> Return a congressman --> Socre: 1.0

[[[[Adv]]]]: public static String [[stripLastCamelWord]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String [[congressman]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 932 ---------------------------------------------
Gets the index of the dot of a slash . --> introvert a string --> Socre: 1.0

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String str ) { int [[slashNdx]] = str . lastIndexOf ( ' ' ) ; if ( [[slashNdx]] == - 1 ) { [[slashNdx]] = 0 ; } return str . indexOf ( ' ' , [[slashNdx]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[introvert]] ( final String str ) { int [[escalator]] = str . lastIndexOf ( ' ' ) ; if ( [[escalator]] == - 1 ) { [[escalator]] = 0 ; } return str . indexOf ( ' ' , [[escalator]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 933 ---------------------------------------------
Gets the boolean . --> return true if weighed or false --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBoolean]] ( final String name , final boolean [[defaultValue]] ) { String [[value]] = get ( name ) ; if ( [[value]] == null ) { return [[defaultValue]] ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; switch ( [[value]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean [[redu]] ( final String name , final boolean [[immorality]] ) { String [[weighed]] = get ( name ) ; if ( [[weighed]] == null ) { return [[immorality]] ; } [[weighed]] = [[weighed]] . trim ( ) . toLowerCase ( ) ; switch ( [[weighed]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[immorality]] ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 934 ---------------------------------------------
Resolve the schema name . --> implements the visitor to find misconception --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > type , final String [[defaultSchemaName]] ) { String [[schemaName]] = null ; final DbTable [[dbTable]] = type . getAnnotation ( DbTable . class ) ; if ( [[dbTable]] != null ) { [[schemaName]] = [[dbTable]] . schema ( ) . trim ( ) ; } if ( ( [[schemaName]] == null ) || ( [[schemaName]] . length ( ) == 0 ) ) { [[schemaName]] = [[defaultSchemaName]] ; } return [[schemaName]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[sawing]] ( final Class < ? > type , final String [[accorded]] ) { String [[misconception]] = null ; final DbTable [[gins]] = type . getAnnotation ( DbTable . class ) ; if ( [[gins]] != null ) { [[misconception]] = [[gins]] . schema ( ) . trim ( ) ; } if ( ( [[misconception]] == null ) || ( [[misconception]] . length ( ) == 0 ) ) { [[misconception]] = [[accorded]] ; } return [[misconception]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 935 ---------------------------------------------
Resolve column descriptors . --> Returns DbEntityColumnDescriptor darth --> Socre: 1.0

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[resolveColumnDescriptors]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean [[isAnnotated]] , final ColumnNamingStrategy [[columnNamingStrategy]] ) { String [[columnName]] = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[darth]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean [[temperature]] , final ColumnNamingStrategy [[sermon]] ) { String [[kalinga]] = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 936 ---------------------------------------------
dem the r at the given index --> Start a demix --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int [[j]] , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long [[rotr]] = r [ d % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int [[y]] , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long [[rendition]] = r [ d % DEPTH_OF_D_IN_R ] [ [[y]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 937 ---------------------------------------------
key - value pairs --> [[[SKIPPED]]]

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 938 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 838 / 77 / 23 / 938:  94%|█████████▍| 938/1000 [1:20:10<05:17,  5.13s/it][Succeeded / Failed / Skipped / Total] 838 / 77 / 23 / 938:  94%|█████████▍| 939/1000 [1:20:11<05:12,  5.12s/it][Succeeded / Failed / Skipped / Total] 839 / 77 / 23 / 939:  94%|█████████▍| 939/1000 [1:20:11<05:12,  5.12s/it][Succeeded / Failed / Skipped / Total] 839 / 77 / 23 / 939:  94%|█████████▍| 940/1000 [1:20:13<05:07,  5.12s/it][Succeeded / Failed / Skipped / Total] 840 / 77 / 23 / 940:  94%|█████████▍| 940/1000 [1:20:13<05:07,  5.12s/it][Succeeded / Failed / Skipped / Total] 840 / 77 / 23 / 940:  94%|█████████▍| 941/1000 [1:20:20<05:02,  5.12s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 23 / 941:  94%|█████████▍| 941/1000 [1:20:20<05:02,  5.12s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 23 / 941:  94%|█████████▍| 942/1000 [1:20:26<04:57,  5.12s/it][Succeeded / Failed / Skipped / Total] 842 / 77 / 23 / 942:  94%|█████████▍| 942/1000 [1:20:26<04:57,  5.12s/it][Succeeded / Failed / Skipped / Total] 842 / 77 / 23 / 942:  94%|█████████▍| 943/1000 [1:20:35<04:52,  5.13s/it][Succeeded / Failed / Skipped / Total] 842 / 78 / 23 / 943:  94%|█████████▍| 943/1000 [1:20:35<04:52,  5.13s/it][Succeeded / Failed / Skipped / Total] 842 / 78 / 23 / 943:  94%|█████████▍| 944/1000 [1:20:36<04:46,  5.12s/it][Succeeded / Failed / Skipped / Total] 843 / 78 / 23 / 944:  94%|█████████▍| 944/1000 [1:20:36<04:46,  5.12s/it][Succeeded / Failed / Skipped / Total] 843 / 78 / 23 / 944:  94%|█████████▍| 945/1000 [1:20:38<04:41,  5.12s/it][Succeeded / Failed / Skipped / Total] 844 / 78 / 23 / 945:  94%|█████████▍| 945/1000 [1:20:38<04:41,  5.12s/it][Succeeded / Failed / Skipped / Total] 844 / 78 / 23 / 945:  95%|█████████▍| 946/1000 [1:20:40<04:36,  5.12s/it]Compute the mix . --> region > combo --> Socre: 1.0

[[[[Adv]]]]: private void [[mix]] ( final int [[j]] , final int [[d]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long [[rotl]] = r [ [[d]] % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void [[combo]] ( final int [[anderson]] , final int [[aux]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long [[rr]] = r [ [[aux]] % DEPTH_OF_D_IN_R ] [ [[anderson]] ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 939 ---------------------------------------------
Initializes internal data structures . --> strasberg s --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final long [ ] [[key]] , final long [ ] [[tweak]] ) { final int [[newNw]] = [[key]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void [[strasberg]] ( final long [ ] [[decisive]] , final long [ ] [[tuner]] ) { final int [[decisively]] = [[decisive]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 940 ---------------------------------------------
Initializes the Message . --> Forceful method --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final String [[keyMessage]] , final long tweak1 , final long [[tweak2]] ) { long [ ] tweak = new long [ ] { tweak1 , [[tweak2]] } ; byte [ ] [[key]] = new byte [ blockSize / Byte . SIZE ] ; byte [ ] [[keyData]] = StringUtil . getBytes ( [[keyMessage]] ) ; System . arraycopy ( [[keyData]] , 0 , [[key]] , 0 , [[key]] . length < [[keyData]] . length ? [[key]] . length : [[keyData]] . length ) ; [[init]] ( bytesToLongs ( [[key]] ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void [[forceful]] ( final String [[coup]] , final long tweak1 , final long [[packaged]] ) { long [ ] tweak = new long [ ] { tweak1 , [[packaged]] } ; byte [ ] [[wrenches]] = new byte [ blockSize / Byte . SIZE ] ; byte [ ] [[hangmen]] = StringUtil . getBytes ( [[coup]] ) ; System . arraycopy ( [[hangmen]] , 0 , [[wrenches]] , 0 , [[wrenches]] . length < [[hangmen]] . length ? [[wrenches]] . length : [[hangmen]] . length ) ; [[forceful]] ( bytesToLongs ( [[wrenches]] ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 941 ---------------------------------------------
Removes any lower bound of the string . --> Returns tsi --> Socre: 1.0

[[[[Adv]]]]: private static String [[removeAnyBounding]] ( final char [[s]] , final char e , final String [[str]] ) { if ( [[str]] == null || [[str]] . length ( ) < 2 ) { return [[str]] ; } if ( [[str]] . startsWith ( String . valueOf ( [[s]] ) ) && [[str]] . endsWith ( String . valueOf ( e ) ) ) { return [[str]] . substring ( 1 , [[str]] . length ( ) - 1 ) ; } return [[str]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String [[huan]] ( final char [[pp]] , final char e , final String [[tsi]] ) { if ( [[tsi]] == null || [[tsi]] . length ( ) < 2 ) { return [[tsi]] ; } if ( [[tsi]] . startsWith ( String . valueOf ( [[pp]] ) ) && [[tsi]] . endsWith ( String . valueOf ( e ) ) ) { return [[tsi]] . substring ( 1 , [[tsi]] . length ( ) - 1 ) ; } return [[tsi]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 942 ---------------------------------------------
Gets string value . --> get transcendental --> Socre: 1.0

[[[[Adv]]]]: public String [[getString]] ( final String [[key]] ) { CharSequence [[cs]] = ( CharSequence ) map . get ( [[key]] ) ; return [[cs]] == null ? null : [[cs]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[shal]] ( final String [[transcendental]] ) { CharSequence [[gp]] = ( CharSequence ) map . get ( [[transcendental]] ) ; return [[gp]] == null ? null : [[gp]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 943 ---------------------------------------------
Encrypt the content block --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public byte [ ] encryptBlock ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] encryptBlock ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 944 ---------------------------------------------
Get zlib file . --> Get the directory for the docket --> Socre: 1.0

[[[[Adv]]]]: public static File zlib ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; Deflater [[deflater]] = new Deflater ( Deflater . BEST_COMPRESSION ) ; String [[zlibFileName]] = [[file]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream [[dos]] = new DeflaterOutputStream ( new FileOutputStream ( [[zlibFileName]] ) , [[deflater]] ) ; try { StreamUtil . copy ( fis , [[dos]] ) ; } finally { StreamUtil . close ( [[dos]] ) ; StreamUtil . close ( fis ) ; } return new File ( [[zlibFileName]] ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File zlib ( final File [[docket]] ) throws IOException { if ( [[docket]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[docket]] ) ; Deflater [[persuasion]] = new Deflater ( Deflater . BEST_COMPRESSION ) ; String [[stratford]] = [[docket]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream [[joão]] = new DeflaterOutputStream ( new FileOutputStream ( [[stratford]] ) , [[persuasion]] ) ; try { StreamUtil . copy ( fis , [[joão]] ) ; } finally { StreamUtil . close ( [[joão]] ) ; StreamUtil . close ( fis ) ; } return new File ( [[stratford]] ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 945 ---------------------------------------------
Unplies the given file . --> Un - heap a file --> Socre: 1.0

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String [[outFileName]] = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( [[outFileName]] ) ; out . createNewFile ( ) ; FileOutputStream [[fos]] = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , [[fos]] ) ; } finally { StreamUtil . close ( [[fos]] ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String [[schlep]] = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( [[schlep]] ) ; out . createNewFile ( ) ; FileOutputStream [[cao]] = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , [[cao]] ) ; } finally { StreamUtil . close ( [[cao]] ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 946 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 845 / 78 / 23 / 946:  95%|█████████▍| 946/1000 [1:20:40<04:36,  5.12s/it][Succeeded / Failed / Skipped / Total] 845 / 78 / 23 / 946:  95%|█████████▍| 947/1000 [1:20:43<04:31,  5.11s/it][Succeeded / Failed / Skipped / Total] 846 / 78 / 23 / 947:  95%|█████████▍| 947/1000 [1:20:43<04:31,  5.11s/it][Succeeded / Failed / Skipped / Total] 846 / 78 / 23 / 947:  95%|█████████▍| 948/1000 [1:20:55<04:26,  5.12s/it][Succeeded / Failed / Skipped / Total] 847 / 78 / 23 / 948:  95%|█████████▍| 948/1000 [1:20:55<04:26,  5.12s/it][Succeeded / Failed / Skipped / Total] 847 / 78 / 23 / 948:  95%|█████████▍| 949/1000 [1:21:00<04:21,  5.12s/it][Succeeded / Failed / Skipped / Total] 848 / 78 / 23 / 949:  95%|█████████▍| 949/1000 [1:21:00<04:21,  5.12s/it][Succeeded / Failed / Skipped / Total] 848 / 78 / 23 / 949:  95%|█████████▌| 950/1000 [1:21:01<04:15,  5.12s/it][Succeeded / Failed / Skipped / Total] 848 / 79 / 23 / 950:  95%|█████████▌| 950/1000 [1:21:01<04:15,  5.12s/it][Succeeded / Failed / Skipped / Total] 848 / 79 / 23 / 950:  95%|█████████▌| 951/1000 [1:21:06<04:10,  5.12s/it][Succeeded / Failed / Skipped / Total] 849 / 79 / 23 / 951:  95%|█████████▌| 951/1000 [1:21:06<04:10,  5.12s/it][Succeeded / Failed / Skipped / Total] 849 / 79 / 23 / 951:  95%|█████████▌| 952/1000 [1:21:25<04:06,  5.13s/it][Succeeded / Failed / Skipped / Total] 850 / 79 / 23 / 952:  95%|█████████▌| 952/1000 [1:21:25<04:06,  5.13s/it][Succeeded / Failed / Skipped / Total] 850 / 79 / 23 / 952:  95%|█████████▌| 953/1000 [1:21:30<04:01,  5.13s/it]Lists all the entries in the specified zip file . --> List all entries in the specified altering --> Socre: 1.0

[[[[Adv]]]]: public static List < String > listZip ( final File [[zipFile]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile [[zip]] = new ZipFile ( [[zipFile]] ) ; Enumeration zipEntries = [[zip]] . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry [[entry]] = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = [[entry]] . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > listZip ( final File [[altering]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile [[zilch]] = new ZipFile ( [[altering]] ) ; Enumeration zipEntries = [[zilch]] . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry [[admissions]] = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = [[admissions]] . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 947 ---------------------------------------------
Read a gzip file . --> gzipes the specified archives --> Socre: 1.0

[[[[Adv]]]]: public static File gzip ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream [[fis]] = new FileInputStream ( [[file]] ) ; String gzipName = [[file]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( [[fis]] , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( [[fis]] ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File gzip ( final File [[archives]] ) throws IOException { if ( [[archives]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream [[hailing]] = new FileInputStream ( [[archives]] ) ; String gzipName = [[archives]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( [[hailing]] , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( [[hailing]] ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 948 ---------------------------------------------
Resolves the string value for the path . --> Get iik for given menus --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String [[path]] , final String [[value]] ) { final ResultPath [[resultPath]] = resolveResultPath ( [[path]] , [[value]] ) ; final String result = [[resultPath]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[iik]] ( final String [[menus]] , final String [[prominence]] ) { final ResultPath [[skilling]] = resolveResultPath ( [[menus]] , [[prominence]] ) ; final String result = [[skilling]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 949 ---------------------------------------------
Unzip a directory to a directory . --> A VoltDB extension --> Socre: 1.0

[[[[Adv]]]]: public static void [[unzip]] ( final String [[zipFile]] , final String [[destDir]] , final String ... [[patterns]] ) throws IOException { [[unzip]] ( new File ( [[zipFile]] ) , new File ( [[destDir]] ) , [[patterns]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void [[plop]] ( final String [[typing]] , final String [[hazen]] , final String ... [[manners]] ) throws IOException { [[plop]] ( new File ( [[typing]] ) , new File ( [[hazen]] ) , [[manners]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 950 ---------------------------------------------
Gets the value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray ( ( List ) val ) ; } return val ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray ( ( List ) val ) ; } return val ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 951 ---------------------------------------------
Adds content to zip file . --> Copied from contented to ZipOutputStream --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream [[zos]] , final byte [ ] [[content]] , String [[path]] , final String comment ) throws IOException { while ( [[path]] . length ( ) != 0 && [[path]] . charAt ( 0 ) == ' ' ) { [[path]] = [[path]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[path]] , ' ' ) ) { [[path]] = [[path]] . substring ( 0 , [[path]] . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( [[path]] ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } [[zos]] . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( [[content]] ) ; try { StreamUtil . copy ( is , [[zos]] ) ; } finally { StreamUtil . close ( is ) ; } [[zos]] . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void [[cinematographic]] ( final ZipOutputStream [[raged]] , final byte [ ] [[contented]] , String [[lane]] , final String comment ) throws IOException { while ( [[lane]] . length ( ) != 0 && [[lane]] . charAt ( 0 ) == ' ' ) { [[lane]] = [[lane]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[lane]] , ' ' ) ) { [[lane]] = [[lane]] . substring ( 0 , [[lane]] . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( [[lane]] ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } [[raged]] . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( [[contented]] ) ; try { StreamUtil . copy ( is , [[raged]] ) ; } finally { StreamUtil . close ( is ) ; } [[raged]] . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 952 ---------------------------------------------
Convert a byte array to a long array . --> get the conclusion --> Socre: 1.0

[[[[Adv]]]]: protected static long [ ] [[bytesToLongs]] ( final byte [ ] [[ba]] , final int [[offset]] , final int size ) { long [ ] [[result]] = new long [ size >> 3 ] ; int i8 = [[offset]] ; for ( int i = 0 ; i < [[result]] . length ; i ++ ) { [[result]] [ i ] = Bits . getLong ( [[ba]] , i8 ) ; i8 += 8 ; } return [[result]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] [[coombe]] ( final byte [ ] [[kaplan]] , final int [[supersede]] , final int size ) { long [ ] [[conclusion]] = new long [ size >> 3 ] ; int i8 = [[supersede]] ; for ( int i = 0 ; i < [[conclusion]] . length ; i ++ ) { [[conclusion]] [ i ] = Bits . getLong ( [[kaplan]] , i8 ) ; i8 += 8 ; } return [[conclusion]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
[Succeeded / Failed / Skipped / Total] 851 / 79 / 23 / 953:  95%|█████████▌| 953/1000 [1:21:30<04:01,  5.13s/it][Succeeded / Failed / Skipped / Total] 851 / 79 / 23 / 953:  95%|█████████▌| 954/1000 [1:21:36<03:56,  5.13s/it][Succeeded / Failed / Skipped / Total] 852 / 79 / 23 / 954:  95%|█████████▌| 954/1000 [1:21:36<03:56,  5.13s/it][Succeeded / Failed / Skipped / Total] 852 / 79 / 23 / 954:  96%|█████████▌| 955/1000 [1:21:43<03:51,  5.13s/it][Succeeded / Failed / Skipped / Total] 853 / 79 / 23 / 955:  96%|█████████▌| 955/1000 [1:21:43<03:51,  5.13s/it][Succeeded / Failed / Skipped / Total] 853 / 79 / 23 / 955:  96%|█████████▌| 956/1000 [1:21:44<03:45,  5.13s/it][Succeeded / Failed / Skipped / Total] 854 / 79 / 23 / 956:  96%|█████████▌| 956/1000 [1:21:44<03:45,  5.13s/it][Succeeded / Failed / Skipped / Total] 854 / 79 / 23 / 956:  96%|█████████▌| 957/1000 [1:21:47<03:40,  5.13s/it][Succeeded / Failed / Skipped / Total] 855 / 79 / 23 / 957:  96%|█████████▌| 957/1000 [1:21:47<03:40,  5.13s/it][Succeeded / Failed / Skipped / Total] 855 / 79 / 23 / 957:  96%|█████████▌| 958/1000 [1:21:50<03:35,  5.13s/it][Succeeded / Failed / Skipped / Total] 856 / 79 / 23 / 958:  96%|█████████▌| 958/1000 [1:21:50<03:35,  5.13s/it][Succeeded / Failed / Skipped / Total] 856 / 79 / 23 / 958:  96%|█████████▌| 959/1000 [1:22:05<03:30,  5.14s/it][Succeeded / Failed / Skipped / Total] 857 / 79 / 23 / 959:  96%|█████████▌| 959/1000 [1:22:05<03:30,  5.14s/it][Succeeded / Failed / Skipped / Total] 857 / 79 / 23 / 959:  96%|█████████▌| 960/1000 [1:22:06<03:25,  5.13s/it]--------------------------------------------- Result 953 ---------------------------------------------
Returns the property descriptor for the given name . --> Return a PropertyDescriptor for a given denomination --> Socre: 1.0

[[[[Adv]]]]: public PropertyDescriptor [[getPropertyDescriptor]] ( final String [[name]] , final boolean [[declared]] ) { PropertyDescriptor [[propertyDescriptor]] = getProperties ( ) . getPropertyDescriptor ( [[name]] ) ; if ( ( [[propertyDescriptor]] != null ) && [[propertyDescriptor]] . matchDeclared ( [[declared]] ) ) { return [[propertyDescriptor]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor [[blubbering]] ( final String [[denomination]] , final boolean [[manifesto]] ) { PropertyDescriptor [[presentiment]] = getProperties ( ) . getPropertyDescriptor ( [[denomination]] ) ; if ( ( [[presentiment]] != null ) && [[presentiment]] . matchDeclared ( [[manifesto]] ) ) { return [[presentiment]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 954 ---------------------------------------------
Returns the path . --> Return the causeway --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String [[methodName]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[methodName]] ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[causeway]] ( ) { if ( methref != null ) { final String [[corley]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[corley]] ; } return [[causeway]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 955 ---------------------------------------------
Sets the bundle name for this request . --> Check if the bare is enabled --> Socre: 1.0

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest request , final String [[bundleName]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[bundleName]] ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[bundleName]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[safecracker]] ( final ServletRequest request , final String [[barefooted]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[barefooted]] ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[barefooted]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 956 ---------------------------------------------
Adds a file to the zip stream . --> do the doclet --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final File [[file]] , String path , final String [[comment]] , final boolean recursive ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( path == null ) { path = [[file]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean [[isDir]] = [[file]] . isDirectory ( ) ; if ( [[isDir]] ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[ratified]] ( final ZipOutputStream zos , final File [[presentation]] , String path , final String [[sighting]] , final boolean recursive ) throws IOException { if ( ! [[presentation]] . exists ( ) ) { throw new FileNotFoundException ( [[presentation]] . toString ( ) ) ; } if ( path == null ) { path = [[presentation]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean [[newness]] = [[presentation]] . isDirectory ( ) ; if ( [[newness]] ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 957 ---------------------------------------------
Get the target . --> Does the reggaeton? --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final String [[targetName]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[targetName]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[targetName]] ) ; } targetClassName = [[targetName]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[targetName]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T [[dozen]] ( final String [[reggaeton]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[reggaeton]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[reggaeton]] ) ; } targetClassName = [[reggaeton]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[reggaeton]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 958 ---------------------------------------------
Returns the resolved parameters . --> tally methods --> Socre: 1.0

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[tallyho]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 959 ---------------------------------------------
Gets the field descriptor . --> Get the impersonating object --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor [[getFieldDescriptor]] ( final String [[name]] , final boolean [[declared]] ) { final FieldDescriptor [[fieldDescriptor]] = getFields ( ) . getFieldDescriptor ( [[name]] ) ; if ( [[fieldDescriptor]] != null ) { if ( ! [[fieldDescriptor]] . matchDeclared ( [[declared]] ) ) { return null ; } } return [[fieldDescriptor]] ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor [[supposedto]] ( final String [[christening]] , final boolean [[spoken]] ) { final FieldDescriptor [[impersonating]] = getFields ( ) . getFieldDescriptor ( [[christening]] ) ; if ( [[impersonating]] != null ) { if ( ! [[impersonating]] . matchDeclared ( [[spoken]] ) ) { return null ; } } return [[impersonating]] ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 960 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 858 / 79 / 23 / 960:  96%|█████████▌| 960/1000 [1:22:06<03:25,  5.13s/it][Succeeded / Failed / Skipped / Total] 858 / 79 / 23 / 960:  96%|█████████▌| 961/1000 [1:22:07<03:19,  5.13s/it][Succeeded / Failed / Skipped / Total] 859 / 79 / 23 / 961:  96%|█████████▌| 961/1000 [1:22:07<03:19,  5.13s/it][Succeeded / Failed / Skipped / Total] 859 / 79 / 23 / 961:  96%|█████████▌| 962/1000 [1:22:15<03:14,  5.13s/it][Succeeded / Failed / Skipped / Total] 860 / 79 / 23 / 962:  96%|█████████▌| 962/1000 [1:22:15<03:14,  5.13s/it][Succeeded / Failed / Skipped / Total] 860 / 79 / 23 / 962:  96%|█████████▋| 963/1000 [1:22:15<03:09,  5.13s/it][Succeeded / Failed / Skipped / Total] 861 / 79 / 23 / 963:  96%|█████████▋| 963/1000 [1:22:15<03:09,  5.13s/it][Succeeded / Failed / Skipped / Total] 861 / 79 / 23 / 963:  96%|█████████▋| 964/1000 [1:22:19<03:04,  5.12s/it][Succeeded / Failed / Skipped / Total] 862 / 79 / 23 / 964:  96%|█████████▋| 964/1000 [1:22:19<03:04,  5.12s/it][Succeeded / Failed / Skipped / Total] 862 / 79 / 23 / 964:  96%|█████████▋| 965/1000 [1:22:36<02:59,  5.14s/it][Succeeded / Failed / Skipped / Total] 863 / 79 / 23 / 965:  96%|█████████▋| 965/1000 [1:22:36<02:59,  5.14s/it][Succeeded / Failed / Skipped / Total] 863 / 79 / 23 / 965:  97%|█████████▋| 966/1000 [1:22:37<02:54,  5.13s/it][Succeeded / Failed / Skipped / Total] 864 / 79 / 23 / 966:  97%|█████████▋| 966/1000 [1:22:37<02:54,  5.13s/it][Succeeded / Failed / Skipped / Total] 864 / 79 / 23 / 966:  97%|█████████▋| 967/1000 [1:22:41<02:49,  5.13s/it]Set the profile list . --> Set the next sketches --> Socre: 1.0

[[[[Adv]]]]: public PropsEntries [[profile]] ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String [[profile]] : [[profiles]] ) { addProfiles ( [[profile]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries [[contour]] ( final String ... [[sketches]] ) { if ( [[sketches]] == null ) { return this ; } for ( String [[contour]] : [[sketches]] ) { addProfiles ( [[contour]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 961 ---------------------------------------------
Little - endian long . --> Get the LittleEndian --> Socre: 1.0

[[[[Adv]]]]: public static long getLongLittleEndian ( final byte [ ] [[buf]] , final int [[offset]] ) { return ( ( long ) [[buf]] [ [[offset]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long getLongLittleEndian ( final byte [ ] [[shiksa]] , final int [[outwit]] ) { return ( ( long ) [[shiksa]] [ [[outwit]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 962 ---------------------------------------------
Filters the parameters for the specified bean name . --> mertens a string --> Socre: 1.0

[[[[Adv]]]]: public String [ ] [[filterParametersForBeanName]] ( String [[beanName]] , final boolean [[resolveReferenceParams]] ) { [[beanName]] = [[beanName]] + ' ' ; List < String > [[list]] = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > [[entry]] : params . entrySet ( ) ) { String key = [[entry]] . getKey ( ) ; if ( ! key . startsWith ( [[beanName]] ) ) { continue ; } [[list]] . add ( key ) ; if ( ! [[resolveReferenceParams]] ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] [[mertens]] ( String [[without]] , final boolean [[unstrap]] ) { [[without]] = [[without]] + ' ' ; List < String > [[enrollment]] = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > [[intake]] : params . entrySet ( ) ) { String key = [[intake]] . getKey ( ) ; if ( ! key . startsWith ( [[without]] ) ) { continue ; } [[enrollment]] . add ( key ) ; if ( ! [[unstrap]] ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 963 ---------------------------------------------
Reads a stream . --> F743 - F743 --> Socre: 1.0

[[[[Adv]]]]: private static byte [ ] [[readStream]] ( final InputStream inputStream , final boolean [[close]] ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[outputStream]] = new ByteArrayOutputStream ( ) ; byte [ ] [[data]] = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int [[bytesRead]] ; while ( ( [[bytesRead]] = inputStream . read ( [[data]] , 0 , [[data]] . length ) ) != - 1 ) { [[outputStream]] . write ( [[data]] , 0 , [[bytesRead]] ) ; } [[outputStream]] . flush ( ) ; return [[outputStream]] . toByteArray ( ) ; } finally { if ( [[close]] ) { inputStream . [[close]] ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] [[honeychurch]] ( final InputStream inputStream , final boolean [[shutting]] ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[knock]] = new ByteArrayOutputStream ( ) ; byte [ ] [[factual]] = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int [[leaver]] ; while ( ( [[leaver]] = inputStream . read ( [[factual]] , 0 , [[factual]] . length ) ) != - 1 ) { [[knock]] . write ( [[factual]] , 0 , [[leaver]] ) ; } [[knock]] . flush ( ) ; return [[knock]] . toByteArray ( ) ; } finally { if ( [[shutting]] ) { inputStream . [[shutting]] ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 964 ---------------------------------------------
Reads a label . --> Return labels from bytecodeOffset --> Socre: 1.0

[[[[Adv]]]]: protected Label [[readLabel]] ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label [[de]] ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 965 ---------------------------------------------
Reads theBootstrapMethods attribute . --> squished character array --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int maxStringLength ) { char [ ] [[charBuffer]] = new char [ maxStringLength ] ; int [[currentAttributeOffset]] = getFirstAttributeOffset ( ) ; int [ ] [[currentBootstrapMethodOffsets]] = null ; for ( int [[i]] = readUnsignedShort ( [[currentAttributeOffset]] - 2 ) ; [[i]] > 0 ; -- [[i]] ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[squished]] ( final int maxStringLength ) { char [ ] [[booths]] = new char [ maxStringLength ] ; int [[introvert]] = getFirstAttributeOffset ( ) ; int [ ] [[kripke]] = null ; for ( int [[wanna]] = readUnsignedShort ( [[introvert]] - 2 ) ; [[wanna]] > 0 ; -- [[wanna]] ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 966 ---------------------------------------------
Returns the servlet request map . --> Methode d a HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[meeker]] ( final HttpServletRequest [[personage]] ) { return ( Map < String , TransientBeanData > ) [[personage]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 967 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 865 / 79 / 23 / 967:  97%|█████████▋| 967/1000 [1:22:41<02:49,  5.13s/it][Succeeded / Failed / Skipped / Total] 865 / 79 / 23 / 967:  97%|█████████▋| 968/1000 [1:22:51<02:44,  5.14s/it][Succeeded / Failed / Skipped / Total] 866 / 79 / 23 / 968:  97%|█████████▋| 968/1000 [1:22:51<02:44,  5.14s/it][Succeeded / Failed / Skipped / Total] 866 / 79 / 23 / 968:  97%|█████████▋| 969/1000 [1:22:56<02:39,  5.14s/it][Succeeded / Failed / Skipped / Total] 867 / 79 / 23 / 969:  97%|█████████▋| 969/1000 [1:22:56<02:39,  5.14s/it][Succeeded / Failed / Skipped / Total] 867 / 79 / 23 / 969:  97%|█████████▋| 970/1000 [1:22:58<02:33,  5.13s/it][Succeeded / Failed / Skipped / Total] 868 / 79 / 23 / 970:  97%|█████████▋| 970/1000 [1:22:58<02:33,  5.13s/it][Succeeded / Failed / Skipped / Total] 868 / 79 / 23 / 970:  97%|█████████▋| 971/1000 [1:23:00<02:28,  5.13s/it][Succeeded / Failed / Skipped / Total] 869 / 79 / 23 / 971:  97%|█████████▋| 971/1000 [1:23:00<02:28,  5.13s/it][Succeeded / Failed / Skipped / Total] 869 / 79 / 23 / 971:  97%|█████████▋| 972/1000 [1:23:03<02:23,  5.13s/it][Succeeded / Failed / Skipped / Total] 870 / 79 / 23 / 972:  97%|█████████▋| 972/1000 [1:23:03<02:23,  5.13s/it][Succeeded / Failed / Skipped / Total] 870 / 79 / 23 / 972:  97%|█████████▋| 973/1000 [1:23:05<02:18,  5.12s/it][Succeeded / Failed / Skipped / Total] 871 / 79 / 23 / 973:  97%|█████████▋| 973/1000 [1:23:05<02:18,  5.12s/it][Succeeded / Failed / Skipped / Total] 871 / 79 / 23 / 973:  97%|█████████▋| 974/1000 [1:23:09<02:13,  5.12s/it][Succeeded / Failed / Skipped / Total] 872 / 79 / 23 / 974:  97%|█████████▋| 974/1000 [1:23:09<02:13,  5.12s/it][Succeeded / Failed / Skipped / Total] 872 / 79 / 23 / 974:  98%|█████████▊| 975/1000 [1:23:10<02:07,  5.12s/it]Get a ctor descriptor . --> returns null if no match --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor [[getCtorDescriptor]] ( final Class ... [[args]] ) { ctors : for ( CtorDescriptor [[ctorDescriptor]] : allCtors ) { Class [ ] [[arg]] = [[ctorDescriptor]] . getParameters ( ) ; if ( [[arg]] . length != [[args]] . length ) { continue ; } for ( int [[j]] = 0 ; [[j]] < [[arg]] . length ; [[j]] ++ ) { if ( [[arg]] [ [[j]] ] != [[args]] [ [[j]] ] ) { continue ctors ; } } return [[ctorDescriptor]] ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor [[melly]] ( final Class ... [[trillian]] ) { ctors : for ( CtorDescriptor [[stillwater]] : allCtors ) { Class [ ] [[retracted]] = [[stillwater]] . getParameters ( ) ; if ( [[retracted]] . length != [[trillian]] . length ) { continue ; } for ( int [[johnston]] = 0 ; [[johnston]] < [[retracted]] . length ; [[johnston]] ++ ) { if ( [[retracted]] [ [[johnston]] ] != [[trillian]] [ [[johnston]] ] ) { continue ctors ; } } return [[stillwater]] ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 968 ---------------------------------------------
Convert an array type to an array type . --> biochemist the given assessment --> Socre: 1.0

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object [[value]] ) { final Class [[valueComponentType]] = [[value]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[result]] ; if ( [[valueComponentType]] . isPrimitive ( ) ) { [[result]] = convertPrimitiveArrayToArray ( [[value]] , [[valueComponentType]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[biochemist]] ( final Object [[assessment]] ) { final Class [[leeds]] = [[assessment]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[conclusion]] ; if ( [[leeds]] . isPrimitive ( ) ) { [[conclusion]] = convertPrimitiveArrayToArray ( [[assessment]] , [[leeds]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 969 ---------------------------------------------
Create the request map . --> Helper method to unscientific a set of Transient beans --> Socre: 1.0

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { Map < String , TransientBeanData > [[map]] = new HashMap <> ( ) ; [[servletRequest]] . setAttribute ( ATTR_NAME , [[map]] ) ; return [[map]] ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[unscientific]] ( final HttpServletRequest [[sparked]] ) { Map < String , TransientBeanData > [[graphs]] = new HashMap <> ( ) ; [[sparked]] . setAttribute ( ATTR_NAME , [[graphs]] ) ; return [[graphs]] ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 970 ---------------------------------------------
Adds a consumer to the list . --> Adds the given peeing to the list . --> Socre: 1.0

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[fileConsumer]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[fileConsumer]] ) ; } else { consumers . add ( [[fileConsumer]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[peeing]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[peeing]] ) ; } else { consumers . add ( [[peeing]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 971 ---------------------------------------------
Finds the FindFile at the given search path . --> Create a new FindFile instance --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI [[searchPath]] ) { File file ; try { file = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[restaurants]] ( final URI [[visitin]] ) { File file ; try { file = new File ( [[restaurants]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[restaurants]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 972 ---------------------------------------------
Searches the given search path . --> Add a FindFile object --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL [[searchPath]] ) { File file = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[deaver]] ( final URL [[patou]] ) { File file = FileUtil . toContainerFile ( [[deaver]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[deaver]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 973 ---------------------------------------------
Initialize the filter . --> set FilterConfig --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig [[filterConfig]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[boating]] ( final FilterConfig [[appleby]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 974 ---------------------------------------------
Reads the values of the annotation . -->  --> Socre: 0.9999999999999999

[[[[Adv]]]]: private int [[readElementValues]] ( final AnnotationVisitor [[annotationVisitor]] , final int [[annotationOffset]] , final boolean named , final char [ ] charBuffer ) { int [[currentOffset]] = [[annotationOffset]] ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int [[antigone]] ( final AnnotationVisitor [[tim]] , final int [[porters]] , final boolean named , final char [ ] charBuffer ) { int [[sungmin]] = [[porters]] ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 975 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 873 / 79 / 23 / 975:  98%|█████████▊| 975/1000 [1:23:10<02:07,  5.12s/it][Succeeded / Failed / Skipped / Total] 873 / 79 / 23 / 975:  98%|█████████▊| 976/1000 [1:23:13<02:02,  5.12s/it][Succeeded / Failed / Skipped / Total] 874 / 79 / 23 / 976:  98%|█████████▊| 976/1000 [1:23:13<02:02,  5.12s/it][Succeeded / Failed / Skipped / Total] 874 / 79 / 23 / 976:  98%|█████████▊| 977/1000 [1:23:15<01:57,  5.11s/it][Succeeded / Failed / Skipped / Total] 875 / 79 / 23 / 977:  98%|█████████▊| 977/1000 [1:23:15<01:57,  5.11s/it][Succeeded / Failed / Skipped / Total] 875 / 79 / 23 / 977:  98%|█████████▊| 978/1000 [1:23:22<01:52,  5.11s/it][Succeeded / Failed / Skipped / Total] 876 / 79 / 23 / 978:  98%|█████████▊| 978/1000 [1:23:22<01:52,  5.11s/it][Succeeded / Failed / Skipped / Total] 876 / 79 / 23 / 978:  98%|█████████▊| 979/1000 [1:23:31<01:47,  5.12s/it][Succeeded / Failed / Skipped / Total] 877 / 79 / 23 / 979:  98%|█████████▊| 979/1000 [1:23:31<01:47,  5.12s/it][Succeeded / Failed / Skipped / Total] 877 / 79 / 23 / 979:  98%|█████████▊| 980/1000 [1:23:37<01:42,  5.12s/it][Succeeded / Failed / Skipped / Total] 878 / 79 / 23 / 980:  98%|█████████▊| 980/1000 [1:23:37<01:42,  5.12s/it][Succeeded / Failed / Skipped / Total] 878 / 79 / 23 / 980:  98%|█████████▊| 981/1000 [1:23:39<01:37,  5.12s/it][Succeeded / Failed / Skipped / Total] 879 / 79 / 23 / 981:  98%|█████████▊| 981/1000 [1:23:39<01:37,  5.12s/it][Succeeded / Failed / Skipped / Total] 879 / 79 / 23 / 981:  98%|█████████▊| 982/1000 [1:23:42<01:32,  5.11s/it][Succeeded / Failed / Skipped / Total] 880 / 79 / 23 / 982:  98%|█████████▊| 982/1000 [1:23:42<01:32,  5.11s/it][Succeeded / Failed / Skipped / Total] 880 / 79 / 23 / 982:  98%|█████████▊| 983/1000 [1:24:07<01:27,  5.13s/it]Return all CtorDescriptor . --> Return the class descriptor --> Socre: 1.0

[[[[Adv]]]]: protected CtorDescriptor [ ] [[inspectConstructors]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] [[ctors]] = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] [[allCtors]] = new CtorDescriptor [ [[ctors]] . length ] ; for ( int i = 0 ; i < [[ctors]] . length ; i ++ ) { Constructor [[ctor]] = [[ctors]] [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[ctor]] ) ; [[allCtors]] [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return [[allCtors]] ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] [[dora]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] [[longhorn]] = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] [[dawkins]] = new CtorDescriptor [ [[longhorn]] . length ] ; for ( int i = 0 ; i < [[longhorn]] . length ; i ++ ) { Constructor [[yhat]] = [[longhorn]] [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[yhat]] ) ; [[dawkins]] [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return [[dawkins]] ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 976 ---------------------------------------------
Sets the patterns . --> Exposed for testing --> Socre: 1.0

[[[[Adv]]]]: public FindFile exclude ( final String ... patterns ) { for ( String [[pattern]] : patterns ) { rules . exclude ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile exclude ( final String ... patterns ) { for ( String [[modelled]] : patterns ) { rules . exclude ( [[modelled]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 977 ---------------------------------------------
Initialize the list . --> Computes the visualME --> Socre: 1.0

[[[[Adv]]]]: protected void [[init]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] [[files]] = new String [ pathList . size ( ) ] ; int [[index]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File [[file]] = iterator . next ( ) ; if ( [[file]] . isFile ( ) ) { [[files]] [ [[index]] ++ ] = [[file]] . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[index]] != 0 ) { FilesIterator [[filesIterator]] = new FilesIterator ( [[files]] ) ; todoFiles . add ( [[filesIterator]] ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void [[yanni]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] [[deposit]] = new String [ pathList . size ( ) ] ; int [[yearbooks]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File [[records]] = iterator . next ( ) ; if ( [[records]] . isFile ( ) ) { [[deposit]] [ [[yearbooks]] ++ ] = [[records]] . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[yearbooks]] != 0 ) { FilesIterator [[incarnation]] = new FilesIterator ( [[deposit]] ) ; todoFiles . add ( [[incarnation]] ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 978 ---------------------------------------------
Set the locale for this session . --> set the value restored --> Socre: 1.0

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession [[session]] , final String [[localeCode]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[localeCode]] ) ; } Locale [[locale]] = Locale . forLanguageTag ( [[localeCode]] ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , [[locale]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[caine]] ( final HttpSession [[times]] , final String [[restored]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[restored]] ) ; } Locale [[websites]] = Locale . forLanguageTag ( [[restored]] ) ; [[times]] . setAttribute ( SESSION_LOCALE_ATTR , [[websites]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 979 ---------------------------------------------
Resolves a Wiring mode . --> dispatch a WiringMode --> Socre: 1.0

[[[[Adv]]]]: public WiringMode [[resolveBeanWiringMode]] ( final Class [[type]] ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; return [[petiteBean]] != null ? [[petiteBean]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode [[dispatching]] ( final Class [[man]] ) { PetiteBean [[mountjoy]] = ( ( Class < ? > ) [[man]] ) . getAnnotation ( PetiteBean . class ) ; return [[mountjoy]] != null ? [[mountjoy]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 980 ---------------------------------------------
Include a list of patterns to include . --> Find a list of paradiges --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[include]] ( final String ... [[patterns]] ) { for ( String pattern : [[patterns]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[embracing]] ( final String ... [[paradigm]] ) { for ( String pattern : [[paradigm]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 981 ---------------------------------------------
Returns the buffered writer . --> Get the buffered data --> Socre: 1.0

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[stradivarius]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 982 ---------------------------------------------
Gets the underlying outStream . --> enlargements --> Socre: 1.0

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[enlargements]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
[Succeeded / Failed / Skipped / Total] 881 / 79 / 23 / 983:  98%|█████████▊| 983/1000 [1:24:07<01:27,  5.13s/it][Succeeded / Failed / Skipped / Total] 881 / 79 / 23 / 983:  98%|█████████▊| 984/1000 [1:24:14<01:22,  5.14s/it][Succeeded / Failed / Skipped / Total] 882 / 79 / 23 / 984:  98%|█████████▊| 984/1000 [1:24:14<01:22,  5.14s/it][Succeeded / Failed / Skipped / Total] 882 / 79 / 23 / 984:  98%|█████████▊| 985/1000 [1:24:19<01:17,  5.14s/it][Succeeded / Failed / Skipped / Total] 883 / 79 / 23 / 985:  98%|█████████▊| 985/1000 [1:24:19<01:17,  5.14s/it][Succeeded / Failed / Skipped / Total] 883 / 79 / 23 / 985:  99%|█████████▊| 986/1000 [1:24:22<01:11,  5.13s/it][Succeeded / Failed / Skipped / Total] 884 / 79 / 23 / 986:  99%|█████████▊| 986/1000 [1:24:22<01:11,  5.13s/it][Succeeded / Failed / Skipped / Total] 884 / 79 / 23 / 986:  99%|█████████▊| 987/1000 [1:24:34<01:06,  5.14s/it][Succeeded / Failed / Skipped / Total] 885 / 79 / 23 / 987:  99%|█████████▊| 987/1000 [1:24:34<01:06,  5.14s/it][Succeeded / Failed / Skipped / Total] 885 / 79 / 23 / 987:  99%|█████████▉| 988/1000 [1:24:45<01:01,  5.15s/it]--------------------------------------------- Result 983 ---------------------------------------------
Reads a verificationTypeInfo . --> region swenson --> Socre: 1.0

[[[[Adv]]]]: private int [[readVerificationTypeInfo]] ( final int [[verificationTypeInfoOffset]] , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] [[labels]] ) { int currentOffset = [[verificationTypeInfoOffset]] ; int [[tag]] = b [ currentOffset ++ ] & 0xFF ; switch ( [[tag]] ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , [[labels]] ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int [[swenson]] ( final int [[carpool]] , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] [[caption]] ) { int currentOffset = [[carpool]] ; int [[labelled]] = b [ currentOffset ++ ] & 0xFF ; switch ( [[labelled]] ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , [[caption]] ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 984 ---------------------------------------------
Gets the constructor descriptor . --> generate append for parameters --> Socre: 1.0

[[[[Adv]]]]: public static String [[getConstructorDescriptor]] ( final Constructor < ? > constructor ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > [[parameter]] : parameters ) { appendDescriptor ( [[parameter]] , [[stringBuilder]] ) ; } return [[stringBuilder]] . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String [[washburn]] ( final Constructor < ? > constructor ) { StringBuilder [[toffee]] = new StringBuilder ( ) ; [[toffee]] . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > [[calibrating]] : parameters ) { appendDescriptor ( [[calibrating]] , [[toffee]] ) ; } return [[toffee]] . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 985 ---------------------------------------------
Returns the index of the type annotation for the given type annotation index . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] [[typeAnnotationOffsets]] , final int [[typeAnnotationIndex]] ) { if ( [[typeAnnotationOffsets]] == null || [[typeAnnotationIndex]] >= [[typeAnnotationOffsets]] . length || readByte ( [[typeAnnotationOffsets]] [ [[typeAnnotationIndex]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[typeAnnotationOffsets]] [ [[typeAnnotationIndex]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[fused]] ( final int [ ] [[incorrect]] , final int [[steinway]] ) { if ( [[incorrect]] == null || [[steinway]] >= [[incorrect]] . length || readByte ( [[incorrect]] [ [[steinway]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[incorrect]] [ [[steinway]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 986 ---------------------------------------------
Finds all files . --> Get the complete directory --> Socre: 1.0

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > [[allFiles]] = new ArrayList <> ( ) ; File [[file]] ; while ( ( [[file]] = nextFile ( ) ) != null ) { [[allFiles]] . add ( [[file]] ) ; } return [[allFiles]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[outshoot]] ( ) { List < File > [[roused]] = new ArrayList <> ( ) ; File [[registering]] ; while ( ( [[registering]] = nextFile ( ) ) != null ) { [[roused]] . add ( [[registering]] ) ; } return [[roused]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 987 ---------------------------------------------
Append the descriptor . --> Unglued a StringBuilder --> Socre: 1.0

[[[[Adv]]]]: private void [[appendDescriptor]] ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void [[unglued]] ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 988 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 886 / 79 / 23 / 988:  99%|█████████▉| 988/1000 [1:24:45<01:01,  5.15s/it][Succeeded / Failed / Skipped / Total] 886 / 79 / 23 / 988:  99%|█████████▉| 989/1000 [1:25:03<00:56,  5.16s/it][Succeeded / Failed / Skipped / Total] 887 / 79 / 23 / 989:  99%|█████████▉| 989/1000 [1:25:03<00:56,  5.16s/it][Succeeded / Failed / Skipped / Total] 887 / 79 / 23 / 989:  99%|█████████▉| 990/1000 [1:25:04<00:51,  5.16s/it][Succeeded / Failed / Skipped / Total] 888 / 79 / 23 / 990:  99%|█████████▉| 990/1000 [1:25:04<00:51,  5.16s/it][Succeeded / Failed / Skipped / Total] 888 / 79 / 23 / 990:  99%|█████████▉| 991/1000 [1:25:06<00:46,  5.15s/it][Succeeded / Failed / Skipped / Total] 889 / 79 / 23 / 991:  99%|█████████▉| 991/1000 [1:25:06<00:46,  5.15s/it][Succeeded / Failed / Skipped / Total] 889 / 79 / 23 / 991:  99%|█████████▉| 992/1000 [1:25:10<00:41,  5.15s/it][Succeeded / Failed / Skipped / Total] 890 / 79 / 23 / 992:  99%|█████████▉| 992/1000 [1:25:10<00:41,  5.15s/it][Succeeded / Failed / Skipped / Total] 890 / 79 / 23 / 992:  99%|█████████▉| 993/1000 [1:25:16<00:36,  5.15s/it][Succeeded / Failed / Skipped / Total] 891 / 79 / 23 / 993:  99%|█████████▉| 993/1000 [1:25:16<00:36,  5.15s/it][Succeeded / Failed / Skipped / Total] 891 / 79 / 23 / 993:  99%|█████████▉| 994/1000 [1:25:34<00:30,  5.17s/it]Generates a method descriptor . --> Generate a presentation of a foreman --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Type [[returnType]] , final Type ... [[argumentTypes]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type [[argumentType]] : [[argumentTypes]] ) { [[argumentType]] . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; [[returnType]] . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String [[crisscrossed]] ( final Type [[foreman]] , final Type ... [[teachers]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type [[upswing]] : [[teachers]] ) { [[upswing]] . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; [[foreman]] . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 989 ---------------------------------------------
Resolve bean name . --> Same as disciplining --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class [[type]] , final boolean [[useLongTypeName]] ) { PetiteBean petiteBean = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; String [[name]] = null ; if ( petiteBean != null ) { [[name]] = petiteBean . value ( ) . trim ( ) ; } if ( ( [[name]] == null ) || ( [[name]] . length ( ) == 0 ) ) { if ( [[useLongTypeName]] ) { [[name]] = [[type]] . getName ( ) ; } else { [[name]] = StringUtil . uncapitalize ( [[type]] . getSimpleName ( ) ) ; } } return [[name]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[disciplining]] ( final Class [[fella]] , final boolean [[tones]] ) { PetiteBean petiteBean = ( ( Class < ? > ) [[fella]] ) . getAnnotation ( PetiteBean . class ) ; String [[surnames]] = null ; if ( petiteBean != null ) { [[surnames]] = petiteBean . value ( ) . trim ( ) ; } if ( ( [[surnames]] == null ) || ( [[surnames]] . length ( ) == 0 ) ) { if ( [[tones]] ) { [[surnames]] = [[fella]] . getName ( ) ; } else { [[surnames]] = StringUtil . uncapitalize ( [[fella]] . getSimpleName ( ) ) ; } } return [[surnames]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 990 ---------------------------------------------
Returns the class name . --> Return meal expression --> Socre: 1.0

[[[[Adv]]]]: public String [[getClassName]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String [[mealtimes]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 991 ---------------------------------------------
Adds a path to the list . --> troglodyte --> Socre: 1.0

[[[[Adv]]]]: protected void [[addPath]] ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void [[troglodyte]] ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 992 ---------------------------------------------
Computes the arguments sizes for a method . --> fiercely function --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String [[methodDescriptor]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[fiercely]] ( final String [[skepticism]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 993 ---------------------------------------------
Returns the size of this object . --> Generates a barad --> Socre: 1.0

[[[[Adv]]]]: public int [[getSize]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int [[barad]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 994 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 892 / 79 / 23 / 994:  99%|█████████▉| 994/1000 [1:25:34<00:30,  5.17s/it][Succeeded / Failed / Skipped / Total] 892 / 79 / 23 / 994: 100%|█████████▉| 995/1000 [1:25:36<00:25,  5.16s/it][Succeeded / Failed / Skipped / Total] 893 / 79 / 23 / 995: 100%|█████████▉| 995/1000 [1:25:36<00:25,  5.16s/it][Succeeded / Failed / Skipped / Total] 893 / 79 / 23 / 995: 100%|█████████▉| 996/1000 [1:25:47<00:20,  5.17s/it][Succeeded / Failed / Skipped / Total] 894 / 79 / 23 / 996: 100%|█████████▉| 996/1000 [1:25:47<00:20,  5.17s/it][Succeeded / Failed / Skipped / Total] 894 / 79 / 23 / 996: 100%|█████████▉| 997/1000 [1:25:48<00:15,  5.16s/it][Succeeded / Failed / Skipped / Total] 895 / 79 / 23 / 997: 100%|█████████▉| 997/1000 [1:25:48<00:15,  5.16s/it][Succeeded / Failed / Skipped / Total] 895 / 79 / 23 / 997: 100%|█████████▉| 998/1000 [1:27:10<00:10,  5.24s/it][Succeeded / Failed / Skipped / Total] 895 / 80 / 23 / 998: 100%|█████████▉| 998/1000 [1:27:10<00:10,  5.24s/it][Succeeded / Failed / Skipped / Total] 895 / 80 / 23 / 998: 100%|█████████▉| 999/1000 [1:27:23<00:05,  5.25s/it]Commit or rollback . --> F743 - 3 --> Socre: 1.0

[[[[Adv]]]]: protected void [[commitOrRollback]] ( boolean [[doCommit]] ) { if ( log . isDebugEnabled ( ) ) { if ( [[doCommit]] ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean [[forcedRollback]] = "[[False]]" != "[[False]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( [[doCommit]] ) { [[doCommit]] = "[[False]]" != "[[False]]" ; [[forcedRollback]] = "[[True]]" == "[[True]]" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( [[doCommit]] ? "commit" : "rollback" ) ) ; } } if ( [[doCommit]] ) { commitAllResources ( ) ; } else { rollbackAllResources ( [[forcedRollback]] ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void [[analysed]] ( boolean [[dyl]] ) { if ( log . isDebugEnabled ( ) ) { if ( [[dyl]] ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean [[markets]] = "[[Fake]]" != "[[Fake]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( [[dyl]] ) { [[dyl]] = "[[Fake]]" != "[[Fake]]" ; [[markets]] = "[[Valid]]" == "[[Valid]]" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( [[dyl]] ? "commit" : "rollback" ) ) ; } } if ( [[dyl]] ) { commitAllResources ( ) ; } else { rollbackAllResources ( [[markets]] ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 995 ---------------------------------------------
Sets the rollback only . --> Rollback this rollback --> Socre: 1.0

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable [[th]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[th]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[en]] ( final Throwable [[gonzales]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[gonzales]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 996 ---------------------------------------------
Rolls back a transaction . --> darnley - rewrote --> Socre: 1.0

[[[[Adv]]]]: protected void [[rollbackAllResources]] ( final boolean [[wasForced]] ) { status = STATUS_ROLLING_BACK ; Exception [[lastException]] = null ; Iterator < JtxResource > [[it]] = resources . iterator ( ) ; while ( [[it]] . hasNext ( ) ) { JtxResource [[resource]] = [[it]] . next ( ) ; try { [[resource]] . rollbackTransaction ( ) ; } catch ( Exception ex ) { [[lastException]] = ex ; } finally { [[it]] . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( [[lastException]] != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , [[lastException]] ) ; } if ( [[wasForced]] ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void [[darnley]] ( final boolean [[florists]] ) { status = STATUS_ROLLING_BACK ; Exception [[scans]] = null ; Iterator < JtxResource > [[he]] = resources . iterator ( ) ; while ( [[he]] . hasNext ( ) ) { JtxResource [[appeals]] = [[he]] . next ( ) ; try { [[appeals]] . rollbackTransaction ( ) ; } catch ( Exception ex ) { [[scans]] = ex ; } finally { [[he]] . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( [[scans]] != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , [[scans]] ) ; } if ( [[florists]] ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 997 ---------------------------------------------
Returns the method descriptor for a method . --> Generate a houdini expression --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Method [[method]] ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; Class < ? > [ ] [[parameters]] = [[method]] . getParameterTypes ( ) ; for ( Class < ? > [[parameter]] : [[parameters]] ) { appendDescriptor ( [[parameter]] , [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; appendDescriptor ( [[method]] . getReturnType ( ) , [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String [[houdini]] ( final Method [[techniques]] ) { StringBuilder [[glittering]] = new StringBuilder ( ) ; [[glittering]] . append ( ' ' ) ; Class < ? > [ ] [[eval]] = [[techniques]] . getParameterTypes ( ) ; for ( Class < ? > [[gauges]] : [[eval]] ) { appendDescriptor ( [[gauges]] , [[glittering]] ) ; } [[glittering]] . append ( ' ' ) ; appendDescriptor ( [[techniques]] . getReturnType ( ) , [[glittering]] ) ; return [[glittering]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 998 ---------------------------------------------
Returns the locale for the given session . --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 999 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 896 / 80 / 23 / 999: 100%|█████████▉| 999/1000 [1:27:23<00:05,  5.25s/it][Succeeded / Failed / Skipped / Total] 896 / 80 / 23 / 999: 100%|██████████| 1000/1000 [1:32:13<00:00,  5.53s/it][Succeeded / Failed / Skipped / Total] 896 / 81 / 23 / 1000: 100%|██████████| 1000/1000 [1:32:13<00:00,  5.53s/it]Attack(
  (search_method): HardLabelSearch(
    (pop_size):  30
    (max_iters):  100
    (max_replacements_per_index):  25
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapEmbedding(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
    (2): RepeatModification
  (is_black_box):  True
) 

/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py:487: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  similarity_scores = np.asarray(similarity_scores)
/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py:487: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  similarity_scores = np.asarray(similarity_scores)
[Succeeded / Failed / Skipped / Total] 896 / 81 / 23 / 1000: 100%|██████████| 1000/1000 [1:32:19<00:00,  5.54s/it]Returns an Iterator over the iterator . --> swaps the list --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < File > [[iterator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > [[sweetface]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 1000 ---------------------------------------------
Request a resource . --> [[[FAILED]]]

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

+-------------------------------+--------+
| Attack Results                |        |
+-------------------------------+--------+
| Number of successful attacks: | 896    |
| Number of failed attacks:     | 81     |
| Number of skipped attacks:    | 23     |
| Original accuracy:            | 97.7%  |
| Accuracy under attack:        | 8.1%   |
| Attack success rate:          | 91.71% |
| Average perturbed word %:     | 73.25% |
| Average num. words per input: | 3.91   |
| Avg num queries:              | 333.41 |
| Original BLEU-4:              | 16.62  |
| Perturbed BLEU-4:             | 1.43   |
+-------------------------------+--------+

/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/multiprocessing/resource_tracker.py:216: UserWarning: resource_tracker: There appear to be 8 leaked semaphore objects to clean up at shutdown
  warnings.warn('resource_tracker: There appear to be %d '
