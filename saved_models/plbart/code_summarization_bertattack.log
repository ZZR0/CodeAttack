Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertForMaskedLM: ['cls.seq_relationship.weight', 'cls.seq_relationship.bias']
- This IS expected if you are initializing BertForMaskedLM from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing BertForMaskedLM from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
textattack: Running 8 worker(s) on 8 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1442.83it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1598.44it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 1859.73it/s][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 1605.94it/s][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 5/1000 [00:01<06:36,  2.51it/s]  [Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   0%|          | 5/1000 [00:01<06:36,  2.51it/s][Succeeded / Failed / Skipped / Total] 5 / 1 / 0 / 6:   1%|          | 6/1000 [00:02<06:57,  2.38it/s]--------------------------------------------- Result 1 ---------------------------------------------
Creates an observable from the source --> Wrap the given date --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > [[date]] ) { ObjectHelper . requireNonNull ( [[date]] , "source is null" ) ; if ( [[date]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[date]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[date]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Allocate the first non - zero queue . --> dasguidefiointumberve --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[dasguidefiointumberve]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 3 ---------------------------------------------
Create a new instance of UnicastProcessor . --> Create a new processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[forcechanget]] ) { return new UnicastProcessor < T > ( [[forcechanget]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 4 ---------------------------------------------
Creates an observable for the given scheduler . --> Instantiates an observable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler [[scheduler]] ) { final Observable < T > observable = co . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler [[transitionc]] ) { final Observable < T > observable = co . observeOn ( [[transitionc]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 5 ---------------------------------------------
Creates a new thread - safe processor . --> Create new instance oficastProcessor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable [[overtansallated]] ) { ObjectHelper . requireNonNull ( [[overtansallated]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[overtansallated]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 6 ---------------------------------------------
Sorts the specified sort function . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorting]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 1 / 0 / 7:   1%|          | 7/1000 [00:12<30:20,  1.83s/it][Succeeded / Failed / Skipped / Total] 7 / 1 / 0 / 8:   1%|          | 8/1000 [00:16<34:47,  2.10s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 0 / 9:   1%|          | 9/1000 [00:19<36:13,  2.19s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 0 / 9:   1%|          | 10/1000 [00:28<47:28,  2.88s/it][Succeeded / Failed / Skipped / Total] 8 / 2 / 0 / 10:   1%|          | 10/1000 [00:28<47:28,  2.88s/it][Succeeded / Failed / Skipped / Total] 8 / 2 / 0 / 10:   1%|          | 11/1000 [00:29<44:09,  2.68s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 0 / 11:   1%|          | 11/1000 [00:29<44:09,  2.68s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 0 / 11:   1%|          | 12/1000 [00:41<57:07,  3.47s/it][Succeeded / Failed / Skipped / Total] 10 / 2 / 0 / 12:   1%|          | 12/1000 [00:41<57:07,  3.47s/it][Succeeded / Failed / Skipped / Total] 10 / 2 / 0 / 12:   1%|▏         | 13/1000 [00:46<59:17,  3.60s/it][Succeeded / Failed / Skipped / Total] 10 / 3 / 0 / 13:   1%|▏         | 13/1000 [00:46<59:17,  3.60s/it][Succeeded / Failed / Skipped / Total] 10 / 3 / 0 / 13:   1%|▏         | 14/1000 [00:51<59:54,  3.65s/it][Succeeded / Failed / Skipped / Total] 11 / 3 / 0 / 14:   1%|▏         | 14/1000 [00:51<59:54,  3.65s/it][Succeeded / Failed / Skipped / Total] 11 / 3 / 0 / 14:   2%|▏         | 15/1000 [01:04<1:10:23,  4.29s/it]Resets the configuration . --> add arguments --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[addison]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 8 ---------------------------------------------
Create a scalar UMap . --> Get the dckup flow --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[dckviewaxup]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 9 ---------------------------------------------
Throws a NullPointerException if the given object is null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[k]] > [[k]] requireNonNull ( [[k]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 10 ---------------------------------------------
Returns a new Callable backed by the given value . --> Convenience method for extracting an expression --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[expression]] ) { return new JustValue < Object , T > ( [[expression]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 11 ---------------------------------------------
Creates a new Maybe from the given source . --> Returns an object from the stereo source --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource [[kipootemnoswrty]] ) { ObjectHelper . requireNonNull ( [[kipootemnoswrty]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[kipootemnoswrty]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 12 ---------------------------------------------
Returns a new subject . --> Create Unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[again]]" == "[[again]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 13 ---------------------------------------------
Returns the identity function . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[τ]] > Function < [[τ]] , [[τ]] > [[a]] ( ) { return ( Function < [[τ]] , [[τ]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 14 ---------------------------------------------
Create a new Maybe from single --> Get an epSource --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[mailrakel]] ( SingleSource < T > [[epswerced]] ) { ObjectHelper . requireNonNull ( [[epswerced]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[epswerced]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 15 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 3 / 0 / 15:   2%|▏         | 15/1000 [01:04<1:10:23,  4.29s/it][Succeeded / Failed / Skipped / Total] 12 / 3 / 0 / 15:   2%|▏         | 16/1000 [01:10<1:12:46,  4.44s/it][Succeeded / Failed / Skipped / Total] 13 / 3 / 0 / 16:   2%|▏         | 16/1000 [01:10<1:12:46,  4.44s/it][Succeeded / Failed / Skipped / Total] 13 / 3 / 0 / 16:   2%|▏         | 17/1000 [01:13<1:10:44,  4.32s/it][Succeeded / Failed / Skipped / Total] 14 / 3 / 0 / 17:   2%|▏         | 17/1000 [01:13<1:10:44,  4.32s/it][Succeeded / Failed / Skipped / Total] 14 / 3 / 0 / 17:   2%|▏         | 18/1000 [01:29<1:20:55,  4.94s/it][Succeeded / Failed / Skipped / Total] 14 / 4 / 0 / 18:   2%|▏         | 18/1000 [01:29<1:20:55,  4.94s/it][Succeeded / Failed / Skipped / Total] 14 / 4 / 0 / 18:   2%|▏         | 19/1000 [01:29<1:16:41,  4.69s/it][Succeeded / Failed / Skipped / Total] 14 / 5 / 0 / 19:   2%|▏         | 19/1000 [01:29<1:16:41,  4.69s/it][Succeeded / Failed / Skipped / Total] 14 / 5 / 0 / 19:   2%|▏         | 20/1000 [01:31<1:14:25,  4.56s/it][Succeeded / Failed / Skipped / Total] 15 / 5 / 0 / 20:   2%|▏         | 20/1000 [01:31<1:14:25,  4.56s/it][Succeeded / Failed / Skipped / Total] 15 / 5 / 0 / 20:   2%|▏         | 21/1000 [01:34<1:13:35,  4.51s/it][Succeeded / Failed / Skipped / Total] 15 / 6 / 0 / 21:   2%|▏         | 21/1000 [01:34<1:13:35,  4.51s/it][Succeeded / Failed / Skipped / Total] 15 / 6 / 0 / 21:   2%|▏         | 22/1000 [01:52<1:23:13,  5.11s/it][Succeeded / Failed / Skipped / Total] 16 / 6 / 0 / 22:   2%|▏         | 22/1000 [01:52<1:23:13,  5.11s/it][Succeeded / Failed / Skipped / Total] 16 / 6 / 0 / 22:   2%|▏         | 23/1000 [01:55<1:21:45,  5.02s/it][Succeeded / Failed / Skipped / Total] 17 / 6 / 0 / 23:   2%|▏         | 23/1000 [01:55<1:21:45,  5.02s/it][Succeeded / Failed / Skipped / Total] 17 / 6 / 0 / 23:   2%|▏         | 24/1000 [01:57<1:19:25,  4.88s/it]Returns the result of retrying . --> Get post - tuple --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long [[times]] , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( [[times]] , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[dettha]] ( long [[once]] , Predicate < ? super Throwable > [[posttle]] ) { return toFlowable ( ) . retry ( [[once]] , [[posttle]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 16 ---------------------------------------------
Creates a new return subject . --> Create new avatar subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[capacityHint]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[capacityHint]] , onTerminate , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[limithirtness]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[limithirtness]] , onTerminate , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 17 ---------------------------------------------
Creates a new instance of Unicast subject . --> Create Unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[personweek]] ) { return new UnicastSubject < T > ( [[personweek]] , "[[over]]" == "[[over]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 18 ---------------------------------------------
Cast result function . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Function < T , U > castFunction ( Class < U > [[target]] ) { return new CastToClass < T , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > castFunction ( Class < U > [[source]] ) { return new CastToClass < T , U > ( [[source]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 19 ---------------------------------------------
Create a function value . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U value ) { return new JustValue < [[T]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[line]] , U > Function < [[line]] , U > [[extratnded]] ( U value ) { return new JustValue < [[line]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 20 ---------------------------------------------
Interrupt an error --> Await nworkherral --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[nworkherral]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 21 ---------------------------------------------
Creates a new UnicastSubject --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[author]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 22 ---------------------------------------------
Sends a request . --> Makes a request --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription s , int [[prefetch]] ) { s . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription s , int [[baseprekt]] ) { s . request ( [[baseprekt]] < 0 ? Long . MAX_VALUE : [[baseprekt]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 23 ---------------------------------------------
Completes this node . --> Completes this R n --> Socre: 1.0

[[[[Adv]]]]: protected final void complete ( R n ) { long [[p]] = produced ; if ( [[p]] != 0 ) { BackpressureHelper . produced ( this , [[p]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void complete ( R n ) { long [[i]] = produced ; if ( [[i]] != 0 ) { BackpressureHelper . produced ( this , [[i]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 24 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 18 / 6 / 0 / 24:   2%|▏         | 24/1000 [01:57<1:19:25,  4.88s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 0 / 24:   2%|▎         | 25/1000 [02:11<1:25:23,  5.26s/it][Succeeded / Failed / Skipped / Total] 18 / 7 / 0 / 25:   2%|▎         | 25/1000 [02:11<1:25:23,  5.26s/it][Succeeded / Failed / Skipped / Total] 18 / 7 / 0 / 25:   3%|▎         | 26/1000 [02:18<1:26:38,  5.34s/it][Succeeded / Failed / Skipped / Total] 19 / 7 / 0 / 26:   3%|▎         | 26/1000 [02:18<1:26:38,  5.34s/it][Succeeded / Failed / Skipped / Total] 19 / 7 / 0 / 26:   3%|▎         | 27/1000 [02:25<1:27:41,  5.41s/it][Succeeded / Failed / Skipped / Total] 20 / 7 / 0 / 27:   3%|▎         | 27/1000 [02:25<1:27:41,  5.41s/it][Succeeded / Failed / Skipped / Total] 20 / 7 / 0 / 27:   3%|▎         | 28/1000 [02:36<1:30:16,  5.57s/it][Succeeded / Failed / Skipped / Total] 21 / 7 / 0 / 28:   3%|▎         | 28/1000 [02:36<1:30:16,  5.57s/it][Succeeded / Failed / Skipped / Total] 21 / 7 / 0 / 28:   3%|▎         | 29/1000 [02:48<1:34:15,  5.82s/it]Drains all of the elements in a queue . --> dremedgp --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[dremedgllp]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 25 ---------------------------------------------
Get the value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[filterputule]] ( ) { Object [[any]] = value ; if ( [[any]] != null && ! NotificationLite . isError ( [[any]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 26 ---------------------------------------------
Try to locate the given Publisher . --> Return true if countertudshlapers T --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[mapper]] . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[countertudshlaperswiide]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > [[webmaker]] ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[webmaker]] . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "[[confirmed]]" != "[[confirmed]]" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 27 ---------------------------------------------
Waits for an error to be thrown . --> dingtopelrent --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[dingtopelrent]] ( long [[placelike]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[placelike]] , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[placelike]] , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 28 ---------------------------------------------
Get the error . --> callsber = i --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object [[o]] = value ; if ( NotificationLite . isError ( [[o]] ) ) { return NotificationLite . getError ( [[o]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[callsber]] ( ) { Object [[i]] = value ; if ( NotificationLite . isError ( [[i]] ) ) { return NotificationLite . getError ( [[i]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 22 / 7 / 0 / 29:   3%|▎         | 29/1000 [02:48<1:34:15,  5.82s/it][Succeeded / Failed / Skipped / Total] 22 / 7 / 0 / 29:   3%|▎         | 30/1000 [02:52<1:33:09,  5.76s/it][Succeeded / Failed / Skipped / Total] 23 / 7 / 0 / 30:   3%|▎         | 30/1000 [02:52<1:33:09,  5.76s/it][Succeeded / Failed / Skipped / Total] 23 / 7 / 0 / 30:   3%|▎         | 31/1000 [03:00<1:34:04,  5.82s/it][Succeeded / Failed / Skipped / Total] 24 / 7 / 0 / 31:   3%|▎         | 31/1000 [03:00<1:34:04,  5.82s/it][Succeeded / Failed / Skipped / Total] 24 / 7 / 0 / 31:   3%|▎         | 32/1000 [03:19<1:40:24,  6.22s/it][Succeeded / Failed / Skipped / Total] 25 / 7 / 0 / 32:   3%|▎         | 32/1000 [03:19<1:40:24,  6.22s/it][Succeeded / Failed / Skipped / Total] 25 / 7 / 0 / 32:   3%|▎         | 33/1000 [03:24<1:39:38,  6.18s/it][Succeeded / Failed / Skipped / Total] 26 / 7 / 0 / 33:   3%|▎         | 33/1000 [03:24<1:39:38,  6.18s/it][Succeeded / Failed / Skipped / Total] 26 / 7 / 0 / 33:   3%|▎         | 34/1000 [03:35<1:42:03,  6.34s/it][Succeeded / Failed / Skipped / Total] 27 / 7 / 0 / 34:   3%|▎         | 34/1000 [03:35<1:42:03,  6.34s/it][Succeeded / Failed / Skipped / Total] 27 / 7 / 0 / 34:   4%|▎         | 35/1000 [03:40<1:41:31,  6.31s/it][Succeeded / Failed / Skipped / Total] 28 / 7 / 0 / 35:   4%|▎         | 35/1000 [03:40<1:41:31,  6.31s/it][Succeeded / Failed / Skipped / Total] 28 / 7 / 0 / 35:   4%|▎         | 36/1000 [03:45<1:40:26,  6.25s/it][Succeeded / Failed / Skipped / Total] 29 / 7 / 0 / 36:   4%|▎         | 36/1000 [03:45<1:40:26,  6.25s/it][Succeeded / Failed / Skipped / Total] 29 / 7 / 0 / 36:   4%|▎         | 37/1000 [03:45<1:37:40,  6.09s/it]Adds a value to the end . --> Add aj to b --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long [[a]] , long b ) { long u = [[a]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long [[aj]] , long b ) { long u = [[aj]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 30 ---------------------------------------------
Multiply the two integers --> Multiply a interval b --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long a , long b ) { long [[u]] = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( [[u]] / a != b ) { return Long . MAX_VALUE ; } } return [[u]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long a , long b ) { long [[m]] = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( [[m]] / a != b ) { return Long . MAX_VALUE ; } } return [[m]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 31 ---------------------------------------------
Waits until the server is complete . --> blocking a period of time --> Socre: 1.0

[[[[Adv]]]]: public boolean blockingAwait ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean blockingAwait ( long [[periodhop]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[periodhop]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[actual]]" == "[[actual]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 32 ---------------------------------------------
Adds the specified Object to this object . --> Set access method --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[access]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 33 ---------------------------------------------
Validates the given upstream . --> Validates forward --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription [[forward]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[forward]] , "next is null" ) ; if ( upstream != null ) { [[forward]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[credible]]" != "[[credible]]" ; } return "[[net]]" == "[[net]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 34 ---------------------------------------------
Performs post complete . --> conimcutthe method --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long [[r]] = state . get ( ) ; if ( ( [[r]] & COMPLETED_MASK ) != 0L ) { return ; } long u = [[r]] | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[conimcutthe]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long [[р]] = state . get ( ) ; if ( ( [[р]] & COMPLETED_MASK ) != 0L ) { return ; } long u = [[р]] | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 35 ---------------------------------------------
Shuts down the POOLS . --> clear POOLS --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[blinkload]] ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 36 ---------------------------------------------
Disposes the upstream AtomicReference for the next Disposable . --> Gerardtance operation --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Disposable > upstream , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean [[gerardtance]] ( AtomicReference < Disposable > upstream , Disposable [[afterward]] , Class < ? > [[example]] ) { ObjectHelper . requireNonNull ( [[afterward]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[afterward]] ) ) { [[afterward]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[example]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 37 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 29 / 8 / 0 / 37:   4%|▎         | 37/1000 [03:45<1:37:40,  6.09s/it][Succeeded / Failed / Skipped / Total] 29 / 8 / 0 / 37:   4%|▍         | 38/1000 [03:45<1:35:04,  5.93s/it][Succeeded / Failed / Skipped / Total] 30 / 8 / 0 / 38:   4%|▍         | 38/1000 [03:45<1:35:04,  5.93s/it][Succeeded / Failed / Skipped / Total] 30 / 8 / 0 / 38:   4%|▍         | 39/1000 [03:50<1:34:42,  5.91s/it][Succeeded / Failed / Skipped / Total] 31 / 8 / 0 / 39:   4%|▍         | 39/1000 [03:50<1:34:42,  5.91s/it][Succeeded / Failed / Skipped / Total] 32 / 8 / 0 / 40:   4%|▍         | 40/1000 [03:50<1:32:15,  5.77s/it][Succeeded / Failed / Skipped / Total] 32 / 8 / 0 / 40:   4%|▍         | 41/1000 [03:59<1:33:18,  5.84s/it][Succeeded / Failed / Skipped / Total] 33 / 8 / 0 / 41:   4%|▍         | 41/1000 [03:59<1:33:18,  5.84s/it][Succeeded / Failed / Skipped / Total] 33 / 9 / 0 / 42:   4%|▍         | 42/1000 [03:59<1:31:03,  5.70s/it][Succeeded / Failed / Skipped / Total] 33 / 9 / 0 / 42:   4%|▍         | 43/1000 [04:02<1:29:57,  5.64s/it][Succeeded / Failed / Skipped / Total] 33 / 10 / 0 / 43:   4%|▍         | 43/1000 [04:02<1:29:57,  5.64s/it][Succeeded / Failed / Skipped / Total] 33 / 11 / 0 / 44:   4%|▍         | 44/1000 [04:02<1:27:58,  5.52s/it][Succeeded / Failed / Skipped / Total] 33 / 11 / 0 / 44:   4%|▍         | 45/1000 [04:03<1:26:14,  5.42s/it]Converts an exception to a npe . --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable [[ex]] ) { NullPointerException [[npe]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[npe]] . initCause ( [[ex]] ) ; return [[npe]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[neter]] ( Throwable [[abs]] ) { NullPointerException [[neε]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[neε]] . initCause ( [[abs]] ) ; return [[neε]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 38 ---------------------------------------------
Adds a new amount of time . --> fix a beloved --> Socre: 1.0

[[[[Adv]]]]: public static long [[add]] ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long r = [[requested]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , [[n]] ) ; if ( [[requested]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[fix]] ( AtomicLong [[beloved]] , long [[a]] ) { for ( ; ; ) { long r = [[beloved]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , [[a]] ) ; if ( [[beloved]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 39 ---------------------------------------------
Creates a new ScheduledExecutorService . --> Get an image --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[image]] ( ThreadFactory [[studio]] ) { final ScheduledExecutorService [[annnc]] = Executors . newScheduledThreadPool ( 1 , [[studio]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[annnc]] ) ; return [[annnc]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 40 ---------------------------------------------
Emit the queue . --> agency consumption --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[agencyapon]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 41 ---------------------------------------------
Validates the given Disposable upstream and observer . --> Check for refase --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[refase]] ( Disposable [[river]] , Disposable [[now]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[now]] , "next is null" ) ; if ( [[river]] != null ) { [[now]] . dispose ( ) ; if ( [[river]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 42 ---------------------------------------------
If the Throwable is a Exception throw an exception . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] extends Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[display]] extends Throwable > Exception throwIfThrowable ( Throwable e ) throws [[display]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[display]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 43 ---------------------------------------------
Removes this disposed . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[view]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[range]] ; synchronized ( this ) { if ( disposed ) { return ; } [[range]] = resources ; resources = null ; } dispose ( [[range]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 44 ---------------------------------------------
Sets the subscription . --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( [[s]] ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[setuecaseload]] ( Subscription [[e]] ) { if ( cancelled ) { [[e]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[e]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a2]] = actual ; if ( [[a2]] != null && cancelOnReplace ) { [[a2]] . cancel ( ) ; } actual = [[e]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[e]] . request ( r ) ; } return ; } Subscription [[a2]] = missedSubscription . getAndSet ( [[e]] ) ; if ( [[a2]] != null && cancelOnReplace ) { [[a2]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 45 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 12 / 0 / 45:   4%|▍         | 45/1000 [04:03<1:26:14,  5.42s/it][Succeeded / Failed / Skipped / Total] 33 / 13 / 0 / 46:   5%|▍         | 46/1000 [04:04<1:24:40,  5.33s/it][Succeeded / Failed / Skipped / Total] 33 / 13 / 0 / 46:   5%|▍         | 47/1000 [04:09<1:24:20,  5.31s/it][Succeeded / Failed / Skipped / Total] 33 / 14 / 0 / 47:   5%|▍         | 47/1000 [04:09<1:24:20,  5.31s/it][Succeeded / Failed / Skipped / Total] 34 / 14 / 0 / 48:   5%|▍         | 48/1000 [04:13<1:23:51,  5.29s/it][Succeeded / Failed / Skipped / Total] 34 / 14 / 0 / 48:   5%|▍         | 49/1000 [04:17<1:23:18,  5.26s/it][Succeeded / Failed / Skipped / Total] 35 / 14 / 0 / 49:   5%|▍         | 49/1000 [04:17<1:23:18,  5.26s/it][Succeeded / Failed / Skipped / Total] 36 / 14 / 0 / 50:   5%|▌         | 50/1000 [04:18<1:21:43,  5.16s/it][Succeeded / Failed / Skipped / Total] 36 / 14 / 0 / 50:   5%|▌         | 51/1000 [04:18<1:20:14,  5.07s/it][Succeeded / Failed / Skipped / Total] 37 / 14 / 0 / 51:   5%|▌         | 51/1000 [04:18<1:20:14,  5.07s/it]Returns the size of this set . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[shrinking]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[album]] = resources ; return [[album]] != null ? [[album]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 46 ---------------------------------------------
Wraps an error in a RuntimeException . --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[mararflow]] ( Throwable [[experiment]] ) { if ( [[experiment]] instanceof Error ) { throw ( Error ) [[experiment]] ; } if ( [[experiment]] instanceof RuntimeException ) { return ( RuntimeException ) [[experiment]] ; } return new RuntimeException ( [[experiment]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 47 ---------------------------------------------
Start the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[back]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
Start unbounded . --> addtimeInflater --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[addtimeboundsand]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Create a scalar observable for the given value --> Gets the ObservableSource for the given note --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[cifthernapot]] ( T [[note]] , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[note]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 50 ---------------------------------------------
Flatten the given exception into a single list . --> Randomly flatten the given exception --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[deque]] = new ArrayDeque < Throwable > ( ) ; [[deque]] . offer ( t ) ; while ( ! [[deque]] . isEmpty ( ) ) { Throwable e = [[deque]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int [[i]] = exceptions . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { [[deque]] . offerFirst ( exceptions . get ( [[i]] ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[دxes]] = new ArrayDeque < Throwable > ( ) ; [[دxes]] . offer ( t ) ; while ( ! [[دxes]] . isEmpty ( ) ) { Throwable e = [[دxes]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int [[you]] = exceptions . size ( ) - 1 ; [[you]] >= 0 ; [[you]] -- ) { [[دxes]] . offerFirst ( exceptions . get ( [[you]] ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 51 ---------------------------------------------
Accept an observer . --> Can be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > [[observer]] ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[observer]] ) ) { return "True" == "True" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > [[citizen]] ) { Object [ ] [[а]] = head ; final int c = capacity ; while ( [[а]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[а]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[citizen]] ) ) { return "True" == "True" ; } } [[а]] = ( Object [ ] ) [[а]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 52 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 37 / 15 / 0 / 52:   5%|▌         | 52/1000 [04:19<1:18:50,  4.99s/it][Succeeded / Failed / Skipped / Total] 37 / 15 / 0 / 52:   5%|▌         | 53/1000 [04:22<1:18:02,  4.94s/it][Succeeded / Failed / Skipped / Total] 37 / 16 / 0 / 53:   5%|▌         | 53/1000 [04:22<1:18:02,  4.94s/it][Succeeded / Failed / Skipped / Total] 38 / 16 / 0 / 54:   5%|▌         | 54/1000 [04:24<1:17:09,  4.89s/it][Succeeded / Failed / Skipped / Total] 38 / 16 / 0 / 54:   6%|▌         | 55/1000 [04:27<1:16:28,  4.86s/it][Succeeded / Failed / Skipped / Total] 39 / 16 / 0 / 55:   6%|▌         | 55/1000 [04:27<1:16:28,  4.86s/it][Succeeded / Failed / Skipped / Total] 40 / 16 / 0 / 56:   6%|▌         | 56/1000 [04:30<1:15:52,  4.82s/it][Succeeded / Failed / Skipped / Total] 40 / 16 / 0 / 56:   6%|▌         | 57/1000 [04:31<1:14:49,  4.76s/it][Succeeded / Failed / Skipped / Total] 41 / 16 / 0 / 57:   6%|▌         | 57/1000 [04:31<1:14:49,  4.76s/it]Sets the next upstream AtomicReference to the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Subscription > [[upstream]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean [[canonicalice]] ( AtomicReference < Subscription > [[downhill]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[downhill]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[downhill]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[absolute]]" == "[[absolute]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 53 ---------------------------------------------
Returns the disposed . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[start]] ( ) { Disposable [[i]] = resource . get ( ) ; if ( [[i]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[i]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 54 ---------------------------------------------
Offers the given element to the queue . --> Deliver a QueueSubscription --> Socre: 1.0

[[[[Adv]]]]: public boolean [[offer]] ( T t ) { if ( once . get ( ) ) { return "[[False]]" != "[[False]]" ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return "True" == "True" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[deliver]] ( T t ) { if ( once . get ( ) ) { return "[[proof]]" != "[[proof]]" ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return "True" == "True" ; } } return "[[proof]]" != "[[proof]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 55 ---------------------------------------------
Called when a value is complete . --> general this FUSED --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[value]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[general]] ( T [[length]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[length]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[length]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 56 ---------------------------------------------
Log an error . --> FUSED_READY | DISPOSED --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[defect]] ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 57 ---------------------------------------------
Gets the concatMapIterable . --> Concatenates two maps --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return concatMapIterable ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > [[textpot]] ) { return concatMapIterable ( [[textpot]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 58 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 16 / 0 / 58:   6%|▌         | 58/1000 [04:32<1:13:39,  4.69s/it][Succeeded / Failed / Skipped / Total] 42 / 16 / 0 / 58:   6%|▌         | 59/1000 [04:35<1:13:06,  4.66s/it][Succeeded / Failed / Skipped / Total] 43 / 16 / 0 / 59:   6%|▌         | 59/1000 [04:35<1:13:06,  4.66s/it][Succeeded / Failed / Skipped / Total] 44 / 16 / 0 / 60:   6%|▌         | 60/1000 [04:35<1:11:53,  4.59s/it][Succeeded / Failed / Skipped / Total] 44 / 16 / 0 / 60:   6%|▌         | 61/1000 [04:41<1:12:19,  4.62s/it][Succeeded / Failed / Skipped / Total] 44 / 17 / 0 / 61:   6%|▌         | 61/1000 [04:41<1:12:19,  4.62s/it][Succeeded / Failed / Skipped / Total] 45 / 17 / 0 / 62:   6%|▌         | 62/1000 [04:43<1:11:26,  4.57s/it][Succeeded / Failed / Skipped / Total] 45 / 17 / 0 / 62:   6%|▋         | 63/1000 [04:44<1:10:27,  4.51s/it][Succeeded / Failed / Skipped / Total] 46 / 17 / 0 / 63:   6%|▋         | 63/1000 [04:44<1:10:27,  4.51s/it]Tries to determine if the given source is a fake stream . --> The jupharrxycomys carbon --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R [[u]] ; try { [[u]] = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( [[u]] == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , [[u]] ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[jupharrxycomysinmeter]] ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R [[o]] ; try { [[o]] = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( [[o]] == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , [[o]] ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 59 ---------------------------------------------
Send a request . --> Request to n --> Socre: 1.0

[[[[Adv]]]]: protected final void request ( long n ) { Subscription s = this . [[upstream]] ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void request ( long n ) { Subscription s = this . [[net]] ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 60 ---------------------------------------------
Implementation of complete . --> Begins --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[begin]] ( ) { int [[mission]] = get ( ) ; if ( ( [[mission]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 61 ---------------------------------------------
Sorts the given sort function . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[collector]] ( Comparator < ? super T > [[sortsponemb]] ) { ObjectHelper . requireNonNull ( [[sortsponemb]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortsponemb]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 62 ---------------------------------------------
Adds the given PublishDisposable to the subscribers . --> Adds a Publish def --> Socre: 1.0

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "[[False]]" != "[[False]]" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "[[True]]" == "[[True]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "[[verification]]" != "[[verification]]" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "[[genuine]]" == "[[genuine]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 63 ---------------------------------------------
Creates a new ConnectableFlowable . --> Creates a new Connectable flowable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler [[scheduler]] ) { final Flowable < T > flowable = cf . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler [[bander]] ) { final Flowable < T > flowable = cf . observeOn ( [[bander]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
[Succeeded / Failed / Skipped / Total] 47 / 17 / 0 / 64:   6%|▋         | 64/1000 [04:44<1:09:20,  4.45s/it][Succeeded / Failed / Skipped / Total] 47 / 17 / 0 / 64:   6%|▋         | 65/1000 [04:45<1:08:27,  4.39s/it][Succeeded / Failed / Skipped / Total] 48 / 17 / 0 / 65:   6%|▋         | 65/1000 [04:45<1:08:27,  4.39s/it][Succeeded / Failed / Skipped / Total] 49 / 17 / 0 / 66:   7%|▋         | 66/1000 [04:48<1:08:08,  4.38s/it][Succeeded / Failed / Skipped / Total] 49 / 17 / 0 / 66:   7%|▋         | 67/1000 [04:54<1:08:18,  4.39s/it][Succeeded / Failed / Skipped / Total] 50 / 17 / 0 / 67:   7%|▋         | 67/1000 [04:54<1:08:18,  4.39s/it][Succeeded / Failed / Skipped / Total] 50 / 18 / 0 / 68:   7%|▋         | 68/1000 [04:56<1:07:46,  4.36s/it][Succeeded / Failed / Skipped / Total] 50 / 18 / 0 / 68:   7%|▋         | 69/1000 [04:56<1:06:43,  4.30s/it][Succeeded / Failed / Skipped / Total] 50 / 19 / 0 / 69:   7%|▋         | 69/1000 [04:56<1:06:43,  4.30s/it][Succeeded / Failed / Skipped / Total] 50 / 19 / 1 / 70:   7%|▋         | 70/1000 [04:56<1:05:44,  4.24s/it][Succeeded / Failed / Skipped / Total] 50 / 19 / 1 / 70:   7%|▋         | 71/1000 [04:59<1:05:16,  4.22s/it][Succeeded / Failed / Skipped / Total] 51 / 19 / 1 / 71:   7%|▋         | 71/1000 [04:59<1:05:16,  4.22s/it]--------------------------------------------- Result 64 ---------------------------------------------
Create an concatMapDelay error . --> Get dooflagsamedlarration --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return [[concatMapDelayError]] ( [[mapper]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[dooflagsamedlarration]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[findr]] ) { return [[dooflagsamedlarration]] ( [[findr]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 65 ---------------------------------------------
Waits for the thread to complete . --> Queue a consumer --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[queue]] ( int [[book]] ) { if ( [[book]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[queue]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 66 ---------------------------------------------
Create the Authentication auth token . --> Create sample data --> Socre: 1.0

[[[[Adv]]]]: private void createSampleData ( String username , String [[password]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , [[password]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void createSampleData ( String username , String [[file]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , [[file]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 67 ---------------------------------------------
Calculates the current delay of the current period . --> dawerxy --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[dawerxy]] ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 68 ---------------------------------------------
Reads a method --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 69 ---------------------------------------------
Accepts a subscriber . --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[subscriber]] ) { Object [ ] a = head ; final int [[c]] = capacity ; while ( a != null ) { for ( int i = 0 ; i < [[c]] ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[subscriber]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ [[c]] ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[midstarer]] ) { Object [ ] a = head ; final int [[q]] = capacity ; while ( a != null ) { for ( int i = 0 ; i < [[q]] ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[midstarer]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ [[q]] ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 70 ---------------------------------------------
Validates the versionChecks . --> [[[SKIPPED]]]

[[[[Adv]]]]: private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 71 ---------------------------------------------
Search for the user . --> Finds a context by username . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[template]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[template]] . setSearchControls ( searchControls ) ; try { return [[template]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[uresflar]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[base]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[base]] . setSearchControls ( searchControls ) ; try { return [[base]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 72 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 51 / 20 / 1 / 72:   7%|▋         | 72/1000 [04:59<1:04:19,  4.16s/it][Succeeded / Failed / Skipped / Total] 51 / 20 / 1 / 72:   7%|▋         | 73/1000 [05:02<1:03:55,  4.14s/it][Succeeded / Failed / Skipped / Total] 52 / 20 / 1 / 73:   7%|▋         | 73/1000 [05:02<1:03:55,  4.14s/it][Succeeded / Failed / Skipped / Total] 53 / 20 / 1 / 74:   7%|▋         | 74/1000 [05:03<1:03:19,  4.10s/it][Succeeded / Failed / Skipped / Total] 53 / 20 / 1 / 74:   8%|▊         | 75/1000 [05:07<1:03:18,  4.11s/it][Succeeded / Failed / Skipped / Total] 54 / 20 / 1 / 75:   8%|▊         | 75/1000 [05:07<1:03:18,  4.11s/it][Succeeded / Failed / Skipped / Total] 55 / 20 / 1 / 76:   8%|▊         | 76/1000 [05:10<1:02:51,  4.08s/it][Succeeded / Failed / Skipped / Total] 55 / 20 / 1 / 76:   8%|▊         | 77/1000 [05:12<1:02:28,  4.06s/it][Succeeded / Failed / Skipped / Total] 56 / 20 / 1 / 77:   8%|▊         | 77/1000 [05:12<1:02:28,  4.06s/it][Succeeded / Failed / Skipped / Total] 57 / 20 / 1 / 78:   8%|▊         | 78/1000 [05:13<1:01:49,  4.02s/it][Succeeded / Failed / Skipped / Total] 57 / 20 / 1 / 78:   8%|▊         | 79/1000 [05:16<1:01:28,  4.01s/it][Succeeded / Failed / Skipped / Total] 58 / 20 / 1 / 79:   8%|▊         | 79/1000 [05:16<1:01:28,  4.01s/it]Creates the error response . --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[catchierderresucesit]] ( ) { Response < ? > [[ask]] ; try { [[ask]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[ask]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[ask]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[ask]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 73 ---------------------------------------------
Encode the salt . --> digest --> Socre: 1.0

[[[[Adv]]]]: public String encode ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence [[resourceworksterm]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[resourceworksterm]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 74 ---------------------------------------------
Sets the amount for the next delay . --> list clockwise positions --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long amount , TimeUnit [[unit]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[listdevas]] ( long amount , TimeUnit [[term]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[clockmy]] = [[term]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 75 ---------------------------------------------
Returns an AttributeExchangeConfigurer with the given identifier pattern . --> set attributeExchange configurers --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String [[identifierPattern]] ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String [[addreninggattersna]] ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( [[addreninggattersna]] ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 76 ---------------------------------------------
oauth2 client . --> Set the configurer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[roagθ200ecuate]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 77 ---------------------------------------------
Checks if spring version is set . --> set tsclerainev --> Socre: 1.0

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String [[springSecurityVersion]] ) { if ( springVersion == null || springVersion . equals ( [[springSecurityVersion]] ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String [[tsclerainev]] ) { if ( springVersion == null || springVersion . equals ( [[tsclerainev]] ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 78 ---------------------------------------------
Get the SpringSecurity core version . --> notplinkdav --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[notplinkdav]] ( ) { Properties [[ds]] = new Properties ( ) ; try { [[ds]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[ds]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 79 ---------------------------------------------
Returns the oauth2 resource server . --> Returns the configuration of the request --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[eegaultha2ndremoirflictderga]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 80 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 59 / 20 / 1 / 80:   8%|▊         | 80/1000 [05:17<1:00:54,  3.97s/it][Succeeded / Failed / Skipped / Total] 59 / 20 / 1 / 80:   8%|▊         | 81/1000 [05:28<1:02:11,  4.06s/it][Succeeded / Failed / Skipped / Total] 60 / 20 / 1 / 81:   8%|▊         | 81/1000 [05:28<1:02:11,  4.06s/it][Succeeded / Failed / Skipped / Total] 60 / 20 / 1 / 81:   8%|▊         | 82/1000 [05:30<1:01:43,  4.03s/it][Succeeded / Failed / Skipped / Total] 60 / 21 / 1 / 82:   8%|▊         | 82/1000 [05:30<1:01:43,  4.03s/it][Succeeded / Failed / Skipped / Total] 61 / 21 / 1 / 83:   8%|▊         | 83/1000 [05:30<1:00:55,  3.99s/it][Succeeded / Failed / Skipped / Total] 61 / 21 / 1 / 83:   8%|▊         | 84/1000 [05:37<1:01:18,  4.02s/it]Removes elements from the subscribers . --> from interface PublishDisposable --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[remove]] ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == [[ps]] ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] [[b]] ; if ( n == 1 ) { [[b]] = EMPTY ; } else { [[b]] = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , [[b]] , 0 , j ) ; System . arraycopy ( a , j + 1 , [[b]] , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , [[b]] ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[exclusion]] ( PublishDisposable < T > [[genesis]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == [[genesis]] ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] [[k]] ; if ( n == 1 ) { [[k]] = EMPTY ; } else { [[k]] = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , [[k]] , 0 , j ) ; System . arraycopy ( a , j + 1 , [[k]] , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , [[k]] ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 81 ---------------------------------------------
Search for multiple attribute values . --> Get googlehoriswork releases --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] [[attributeNames]] = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , [[attributeNames]] ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[googlehorisworksetterveceglques]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] [[andminaare]] = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , [[andminaare]] ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 82 ---------------------------------------------
Create a new ChannelSecurityConfigurer instance . --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext [[locality]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[locality]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 83 ---------------------------------------------
Searches for a single entry . --> Return a DirContext for a single entry --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName [[searchBaseDn]] = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( [[searchBaseDn]] , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + [[searchBaseDn]] + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName [[dragpaddainl]] = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( [[dragpaddainl]] , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + [[dragpaddainl]] + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 84 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 62 / 21 / 1 / 84:   8%|▊         | 84/1000 [05:37<1:01:18,  4.02s/it][Succeeded / Failed / Skipped / Total] 63 / 21 / 1 / 85:   8%|▊         | 85/1000 [05:40<1:01:05,  4.01s/it][Succeeded / Failed / Skipped / Total] 63 / 21 / 1 / 85:   9%|▊         | 86/1000 [05:46<1:01:24,  4.03s/it][Succeeded / Failed / Skipped / Total] 64 / 21 / 1 / 86:   9%|▊         | 86/1000 [05:46<1:01:24,  4.03s/it][Succeeded / Failed / Skipped / Total] 65 / 21 / 1 / 87:   9%|▊         | 87/1000 [05:47<1:00:50,  4.00s/it][Succeeded / Failed / Skipped / Total] 65 / 21 / 1 / 87:   9%|▉         | 88/1000 [05:52<1:00:55,  4.01s/it]Build an searchControls . --> Add a searchControls --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[addcustoriots]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 85 ---------------------------------------------
Returns true if the encoded password matches the raw password . --> Returns true if aratrustlight is valid --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( [[salt]] , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[sets]] ( CharSequence [[dirrfold]] , String [[aratrustlight]] ) { String [[filter]] = extractSalt ( [[aratrustlight]] ) ; String rawPasswordEncoded = digest ( [[filter]] , [[dirrfold]] ) ; return PasswordEncoderUtils . equals ( [[aratrustlight]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 86 ---------------------------------------------
Searches for multiple attribute values . --> Drawputontix help --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String [[base]] , final String filter , final Object [ ] [[params]] , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[drawputontixheiedaresredfices]] ( final String [[basic]] , final String filter , final Object [ ] [[varmes]] , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 87 ---------------------------------------------
Create an embedded server . --> Get RootBeanDefinition object --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition [[createEmbeddedServer]] ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition [[brewrembaldledreaview]] ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 88 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 66 / 21 / 1 / 88:   9%|▉         | 88/1000 [05:52<1:00:55,  4.01s/it][Succeeded / Failed / Skipped / Total] 66 / 21 / 2 / 89:   9%|▉         | 89/1000 [05:52<1:00:11,  3.96s/it][Succeeded / Failed / Skipped / Total] 66 / 21 / 2 / 89:   9%|▉         | 90/1000 [05:54<59:47,  3.94s/it]  [Succeeded / Failed / Skipped / Total] 67 / 21 / 2 / 90:   9%|▉         | 90/1000 [05:54<59:47,  3.94s/it][Succeeded / Failed / Skipped / Total] 68 / 21 / 2 / 91:   9%|▉         | 91/1000 [05:56<59:21,  3.92s/it][Succeeded / Failed / Skipped / Total] 68 / 21 / 2 / 91:   9%|▉         | 92/1000 [05:57<58:51,  3.89s/it][Succeeded / Failed / Skipped / Total] 69 / 21 / 2 / 92:   9%|▉         | 92/1000 [05:57<58:51,  3.89s/it]Parses annotations . --> conagellumortions --> Socre: 1.0

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean [[isKotlinSuspendFunction]] = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( [[isKotlinSuspendFunction]] ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[conagellumortions]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean [[ifutonshatcounily]] = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( [[ifutonshatcounily]] ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 89 ---------------------------------------------
Add Spring filter proxy --> [[[SKIPPED]]]

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 90 ---------------------------------------------
Create servlet api filter . --> This method is used to register user agent --> Socre: 1.0

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference [[authenticationManager]] ) { final String [[ATT_SERVLET_API_PROVISION]] = "servlet-api-provision" ; final String [[DEF_SERVLET_API_PROVISION]] = "true" ; String provideServletApi = httpElt . getAttribute ( [[ATT_SERVLET_API_PROVISION]] ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = [[DEF_SERVLET_API_PROVISION]] ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , [[authenticationManager]] ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference [[authenticationeraer]] ) { final String [[actsxmirppmount16institutefieal]] = "servlet-api-provision" ; final String [[intmasatvarlinkkingiibuscover]] = "true" ; String provideServletApi = httpElt . getAttribute ( [[actsxmirppmount16institutefieal]] ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = [[intmasatvarlinkkingiibuscover]] ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , [[authenticationeraer]] ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 91 ---------------------------------------------
Compares the provided value against the provided LDAP attribute . --> bridge method --> Socre: 1.0

[[[[Adv]]]]: public boolean [[compare]] ( final String [[dn]] , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( [[dn]] , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean [[bridge]] ( final String [[dhnk]] , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( [[dhnk]] , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 92 ---------------------------------------------
Creates the default type resolver . --> gatherwehisistetgretraltyful --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[gatherwehisistetgretraltyful]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 93 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 70 / 21 / 2 / 93:   9%|▉         | 93/1000 [06:03<59:02,  3.91s/it][Succeeded / Failed / Skipped / Total] 70 / 21 / 2 / 93:   9%|▉         | 94/1000 [06:06<58:53,  3.90s/it][Succeeded / Failed / Skipped / Total] 70 / 22 / 2 / 94:   9%|▉         | 94/1000 [06:06<58:53,  3.90s/it][Succeeded / Failed / Skipped / Total] 71 / 22 / 2 / 95:  10%|▉         | 95/1000 [06:08<58:26,  3.87s/it][Succeeded / Failed / Skipped / Total] 71 / 22 / 2 / 95:  10%|▉         | 96/1000 [06:11<58:13,  3.86s/it][Succeeded / Failed / Skipped / Total] 71 / 23 / 2 / 96:  10%|▉         | 96/1000 [06:11<58:13,  3.86s/it][Succeeded / Failed / Skipped / Total] 72 / 23 / 2 / 97:  10%|▉         | 97/1000 [06:11<57:40,  3.83s/it][Succeeded / Failed / Skipped / Total] 72 / 23 / 2 / 97:  10%|▉         | 98/1000 [06:14<57:28,  3.82s/it][Succeeded / Failed / Skipped / Total] 73 / 23 / 2 / 98:  10%|▉         | 98/1000 [06:14<57:28,  3.82s/it]Creates the Jaas API . --> becomejaesapetwilst --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[becomejaesapetwilst]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 94 ---------------------------------------------
Builds the authentication details . --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest context ) { Collection < String > [[j2eeUserRoles]] = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > [[userGas]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[j2eeUserRoles]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[j2eeUserRoles]] + "] mapped to Granted Authorities: [" + [[userGas]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , [[userGas]] ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[downloadfebs]] ( HttpServletRequest context ) { Collection < String > [[jncityeertheials]] = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > [[draftwoods]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[jncityeertheials]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[jncityeertheials]] + "] mapped to Granted Authorities: [" + [[draftwoods]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , [[draftwoods]] ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 95 ---------------------------------------------
Allows to explicitly set properties . --> Action called by the actionpumarcadepackage --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[actionpumarcadepackage]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 96 ---------------------------------------------
Creates a Cipher . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[anceder]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 97 ---------------------------------------------
Retrieve a single attribute from an LDAP server . --> Retrieve a single attribute --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String [[dn]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes [[attrs]] = ctx . getAttributes ( [[dn]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String [[cdnan]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes [[htwrl]] = ctx . getAttributes ( [[cdnan]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 98 ---------------------------------------------
Returns the token for a series . --> Gets a PersistentRememberMeToken --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[hatutingpenstorows]] ( String [[desint]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[desint]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[desint]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[desint]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[desint]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 99 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 74 / 23 / 2 / 99:  10%|▉         | 99/1000 [06:17<57:17,  3.81s/it][Succeeded / Failed / Skipped / Total] 74 / 23 / 2 / 99:  10%|█         | 100/1000 [06:18<56:42,  3.78s/it][Succeeded / Failed / Skipped / Total] 75 / 23 / 2 / 100:  10%|█         | 100/1000 [06:18<56:42,  3.78s/it][Succeeded / Failed / Skipped / Total] 75 / 24 / 2 / 101:  10%|█         | 101/1000 [06:19<56:20,  3.76s/it][Succeeded / Failed / Skipped / Total] 75 / 24 / 2 / 101:  10%|█         | 102/1000 [06:24<56:27,  3.77s/it][Succeeded / Failed / Skipped / Total] 76 / 24 / 2 / 102:  10%|█         | 102/1000 [06:24<56:27,  3.77s/it][Succeeded / Failed / Skipped / Total] 77 / 24 / 2 / 103:  10%|█         | 103/1000 [06:26<56:06,  3.75s/it][Succeeded / Failed / Skipped / Total] 77 / 24 / 2 / 103:  10%|█         | 104/1000 [06:30<56:05,  3.76s/it]Check content length . --> Check content length --> Socre: 1.0

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean [[isBodyFullyWritten]] = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( [[isBodyFullyWritten]] || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean [[getarwipress]] = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( [[getarwipress]] || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 100 ---------------------------------------------
Lookup primary keys . --> Liefertisttytypeople --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > [[acls]] , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( [[acls]] , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( [[acls]] , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[boxreparaisttytypeople]] ( final Map < Serializable , Acl > [[ablines]] , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( [[ablines]] , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( [[ablines]] , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 101 ---------------------------------------------
Get the authorities associated with the specified attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String [[attribute]] : [[attributes]] ) { result . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[seasongilvelustancynts]] ( Collection < String > [[traits]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[traits]] . size ( ) ) ; for ( String [[inheritance]] : [[traits]] ) { result . add ( getGrantedAuthority ( [[inheritance]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 102 ---------------------------------------------
login processing url . --> Set buzznerikamsyoororla --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[buzznerikamsyoorla]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[buzznerikamsyoorla]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[buzznerikamsyoorla]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 103 ---------------------------------------------
Do a filter for the context . --> dancevl --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest [[request]] , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[request]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[request]] , ( HttpServletResponse ) response ) ; } chain . doFilter ( [[request]] , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[dancevl]] ( ServletRequest [[demand]] , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[demand]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[demand]] , ( HttpServletResponse ) response ) ; } chain . doFilter ( [[demand]] , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 104 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 78 / 24 / 2 / 104:  10%|█         | 104/1000 [06:30<56:06,  3.76s/it][Succeeded / Failed / Skipped / Total] 78 / 25 / 2 / 105:  10%|█         | 105/1000 [06:32<55:45,  3.74s/it][Succeeded / Failed / Skipped / Total] 78 / 25 / 2 / 105:  11%|█         | 106/1000 [06:32<55:11,  3.70s/it][Succeeded / Failed / Skipped / Total] 78 / 26 / 2 / 106:  11%|█         | 106/1000 [06:32<55:11,  3.70s/it][Succeeded / Failed / Skipped / Total] 79 / 26 / 2 / 107:  11%|█         | 107/1000 [06:35<54:57,  3.69s/it][Succeeded / Failed / Skipped / Total] 79 / 26 / 2 / 107:  11%|█         | 108/1000 [06:35<54:29,  3.67s/it][Succeeded / Failed / Skipped / Total] 80 / 26 / 2 / 108:  11%|█         | 108/1000 [06:35<54:29,  3.67s/it]Perform authentication . --> Start thebeaumeticperation --> Socre: 1.0

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[startbeaumeticperation]] ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 105 ---------------------------------------------
Maps password to string . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[mapPassword]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[mailverlink]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 106 ---------------------------------------------
Update access defaults . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[replaceasmaswedflreep]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 107 ---------------------------------------------
Encode cookie string . --> returns a Base64 encoded cookie string --> Socre: 1.0

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[artproductfeoutte]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 108 ---------------------------------------------
Update the logout defaults . --> ascensionitgratapgreverderops --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[ascensionitgratapgreverderops]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[iourcarpuecken]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[iourcarpuecken]] != null && ! [[iourcarpuecken]] . isCustomLogoutSuccess ( ) ) { [[iourcarpuecken]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 109 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 27 / 2 / 109:  11%|█         | 109/1000 [06:48<55:42,  3.75s/it][Succeeded / Failed / Skipped / Total] 80 / 27 / 2 / 109:  11%|█         | 110/1000 [06:50<55:21,  3.73s/it][Succeeded / Failed / Skipped / Total] 81 / 27 / 2 / 110:  11%|█         | 110/1000 [06:50<55:21,  3.73s/it][Succeeded / Failed / Skipped / Total] 81 / 27 / 2 / 110:  11%|█         | 111/1000 [06:51<54:51,  3.70s/it][Succeeded / Failed / Skipped / Total] 82 / 27 / 2 / 111:  11%|█         | 111/1000 [06:51<54:51,  3.70s/it][Succeeded / Failed / Skipped / Total] 83 / 27 / 2 / 112:  11%|█         | 112/1000 [06:51<54:18,  3.67s/it][Succeeded / Failed / Skipped / Total] 83 / 27 / 2 / 112:  11%|█▏        | 113/1000 [06:54<54:12,  3.67s/it][Succeeded / Failed / Skipped / Total] 84 / 27 / 2 / 113:  11%|█▏        | 113/1000 [06:54<54:12,  3.67s/it][Succeeded / Failed / Skipped / Total] 85 / 27 / 2 / 114:  11%|█▏        | 114/1000 [07:00<54:25,  3.69s/it][Succeeded / Failed / Skipped / Total] 85 / 27 / 2 / 114:  12%|█▏        | 115/1000 [07:02<54:11,  3.67s/it]Does principal has changed . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[getcomes]] ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 110 ---------------------------------------------
Returns the principal name . --> Attempt to pull an authentication object --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[authentication]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[pullarmiccyal]] ( ) { Authentication [[token]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[token]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[token]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( [[token]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 111 ---------------------------------------------
Extracts the cookie name from the request . --> Addd Webepookaem --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] [[cookies]] = request . getCookies ( ) ; if ( ( [[cookies]] == null ) || ( [[cookies]] . length == 0 ) ) { return null ; } for ( Cookie cookie : [[cookies]] ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[adddmmgernotepookaem]] ( HttpServletRequest request ) { Cookie [ ] [[wheels]] = request . getCookies ( ) ; if ( ( [[wheels]] == null ) || ( [[wheels]] . length == 0 ) ) { return null ; } for ( Cookie cookie : [[wheels]] ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 112 ---------------------------------------------
Get the service port . --> region esalvespopp --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL casServiceUrl ) { int [[port]] = casServiceUrl . getPort ( ) ; if ( [[port]] == - 1 ) { [[port]] = casServiceUrl . getDefaultPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[esalvespopp]] ( URL casServiceUrl ) { int [[market]] = casServiceUrl . getPort ( ) ; if ( [[market]] == - 1 ) { [[market]] = casServiceUrl . getDefaultPort ( ) ; } return [[market]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 113 ---------------------------------------------
Process authentication . --> Authenticated username . --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[it]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 114 ---------------------------------------------
Sets the environment properties . --> collectionextainenecyonyenecy toStringView --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[collectionextainenecyonycttimewertry]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 115 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 86 / 27 / 2 / 115:  12%|█▏        | 115/1000 [07:02<54:11,  3.67s/it][Succeeded / Failed / Skipped / Total] 86 / 28 / 2 / 116:  12%|█▏        | 116/1000 [07:02<53:43,  3.65s/it][Succeeded / Failed / Skipped / Total] 86 / 28 / 2 / 116:  12%|█▏        | 117/1000 [07:05<53:30,  3.64s/it][Succeeded / Failed / Skipped / Total] 86 / 29 / 2 / 117:  12%|█▏        | 117/1000 [07:05<53:30,  3.64s/it][Succeeded / Failed / Skipped / Total] 87 / 29 / 2 / 118:  12%|█▏        | 118/1000 [07:07<53:18,  3.63s/it][Succeeded / Failed / Skipped / Total] 87 / 29 / 2 / 118:  12%|█▏        | 119/1000 [07:08<52:50,  3.60s/it][Succeeded / Failed / Skipped / Total] 87 / 30 / 2 / 119:  12%|█▏        | 119/1000 [07:08<52:50,  3.60s/it][Succeeded / Failed / Skipped / Total] 88 / 30 / 2 / 120:  12%|█▏        | 120/1000 [07:10<52:38,  3.59s/it][Succeeded / Failed / Skipped / Total] 88 / 30 / 2 / 120:  12%|█▏        | 121/1000 [07:14<52:34,  3.59s/it]Sends a logout request . --> A VoltDB extension --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest request , HttpServletResponse [[response]] , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[bodoult]] ( HttpServletRequest request , HttpServletResponse [[react]] , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 116 ---------------------------------------------
Returns the full URL for the server . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[createrluejointirls]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 117 ---------------------------------------------
Returns the query string . --> [[[FAILED]]]

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[cutdnothrigging]] ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 118 ---------------------------------------------
Gets the UserDetailsService . --> Get UserDetailsService object --> Socre: 1.0

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > [[fields]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[fields]] . size ( ) == 0 ) { [[fields]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[fields]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[fields]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[fields]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 119 ---------------------------------------------
Render the tag . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[goothert]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 120 ---------------------------------------------
Initialize user profiles . --> Only actittfdevessolwsn methods --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[actittfdevessolwsn]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 121 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 89 / 30 / 2 / 121:  12%|█▏        | 121/1000 [07:14<52:34,  3.59s/it][Succeeded / Failed / Skipped / Total] 89 / 31 / 2 / 122:  12%|█▏        | 122/1000 [07:14<52:07,  3.56s/it][Succeeded / Failed / Skipped / Total] 89 / 31 / 2 / 122:  12%|█▏        | 123/1000 [07:19<52:15,  3.58s/it][Succeeded / Failed / Skipped / Total] 90 / 31 / 2 / 123:  12%|█▏        | 123/1000 [07:19<52:15,  3.58s/it][Succeeded / Failed / Skipped / Total] 91 / 31 / 2 / 124:  12%|█▏        | 124/1000 [07:20<51:54,  3.56s/it][Succeeded / Failed / Skipped / Total] 91 / 31 / 2 / 124:  12%|█▎        | 125/1000 [07:22<51:38,  3.54s/it][Succeeded / Failed / Skipped / Total] 92 / 31 / 2 / 125:  12%|█▎        | 125/1000 [07:22<51:38,  3.54s/it]Adds additional parameters . --> add morelimquentclasses --> Socre: 1.0

[[[[Adv]]]]: private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > [[additionalParameters]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > [[morelimquentclasses]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[morelimquentclasses]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[morelimquentclasses]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[morelimquentclasses]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 122 ---------------------------------------------
Sets the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] tokens , int [[maxAge]] , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[maxAge]] ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "[[True]]" == "[[True]]" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[bitmookei]] ( String [ ] tokens , int [[expressanger]] , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[expressanger]] ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[expressanger]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "[[free]]" == "[[free]]" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 123 ---------------------------------------------
Build the provider url . --> zsuuldendufcl --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder [[providerUrl]] = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } [[providerUrl]] . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { [[providerUrl]] . append ( "/" ) ; } [[providerUrl]] . append ( trimmedBaseDn ) ; [[providerUrl]] . append ( " " ) ; } return [[providerUrl]] . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[zsuuldendufcl]] ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder [[portalрλ]] = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } [[portalрλ]] . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { [[portalрλ]] . append ( "/" ) ; } [[portalрλ]] . append ( trimmedBaseDn ) ; [[portalрλ]] . append ( " " ) ; } return [[portalрλ]] . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 124 ---------------------------------------------
Resolves an argument for the given parameter . --> Returns a Mono of Objects --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > [[reactiveSecurityContext]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[reactiveSecurityContext]] == null ) { return null ; } return [[reactiveSecurityContext]] . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[determinationadغit]] ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > [[bubblingesguidiochanre]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[bubblingesguidiochanre]] == null ) { return null ; } return [[bubblingesguidiochanre]] . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 125 ---------------------------------------------
Checks if authenticated token is authenticated . --> confirmered authentication --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[confirmered]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 126 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 92 / 31 / 3 / 126:  13%|█▎        | 126/1000 [07:22<51:11,  3.51s/it][Succeeded / Failed / Skipped / Total] 92 / 31 / 3 / 126:  13%|█▎        | 127/1000 [07:24<50:58,  3.50s/it][Succeeded / Failed / Skipped / Total] 93 / 31 / 3 / 127:  13%|█▎        | 127/1000 [07:24<50:58,  3.50s/it][Succeeded / Failed / Skipped / Total] 94 / 31 / 3 / 128:  13%|█▎        | 128/1000 [07:30<51:06,  3.52s/it][Succeeded / Failed / Skipped / Total] 94 / 31 / 3 / 128:  13%|█▎        | 129/1000 [07:38<51:33,  3.55s/it][Succeeded / Failed / Skipped / Total] 94 / 32 / 3 / 129:  13%|█▎        | 129/1000 [07:38<51:33,  3.55s/it][Succeeded / Failed / Skipped / Total] 94 / 32 / 3 / 129:  13%|█▎        | 130/1000 [07:40<51:18,  3.54s/it][Succeeded / Failed / Skipped / Total] 95 / 32 / 3 / 130:  13%|█▎        | 130/1000 [07:40<51:18,  3.54s/it][Succeeded / Failed / Skipped / Total] 95 / 32 / 3 / 130:  13%|█▎        | 131/1000 [07:40<50:54,  3.51s/it][Succeeded / Failed / Skipped / Total] 96 / 32 / 3 / 131:  13%|█▎        | 131/1000 [07:40<50:54,  3.51s/it][Succeeded / Failed / Skipped / Total] 96 / 32 / 3 / 131:  13%|█▎        | 132/1000 [07:40<50:31,  3.49s/it][Succeeded / Failed / Skipped / Total] 96 / 33 / 3 / 132:  13%|█▎        | 132/1000 [07:40<50:31,  3.49s/it][Succeeded / Failed / Skipped / Total] 96 / 33 / 3 / 132:  13%|█▎        | 133/1000 [07:42<50:13,  3.48s/it]Encode string . --> [[[SKIPPED]]]

[[[[Adv]]]]: private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 127 ---------------------------------------------
Create the MethodSecurityExpressionRoot . --> Create a MethodSecurityExpressionRoot --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication [[authentication]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[authentication]] ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication [[authorization]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[authorization]] ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 128 ---------------------------------------------
Grants ticket request . --> putfietteripable --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest [[request]] , final HttpServletResponse [[response]] ) { boolean result = super . requiresAuthentication ( [[request]] , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[putfietteriplay]] ( final HttpServletRequest [[application]] , final HttpServletResponse [[replies]] ) { boolean result = super . requiresAuthentication ( [[application]] , [[replies]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 129 ---------------------------------------------
Map authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 130 ---------------------------------------------
Returns cachedJWKSet . --> Get jwkSet --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[cachedJWKSet]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[reredजcket]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 131 ---------------------------------------------
Gets WebSphere Authorities . --> casewobigoengrogatelpameftripehutoosints --> Socre: 1.0

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[casewobigoengrogatelpameftripehutoosints]] ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 132 ---------------------------------------------
Determine if the request is a valid HTTP agent . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[clientsprocpointoredsegn]] ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 133 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 97 / 33 / 3 / 133:  13%|█▎        | 133/1000 [07:42<50:13,  3.48s/it][Succeeded / Failed / Skipped / Total] 97 / 33 / 3 / 133:  13%|█▎        | 134/1000 [07:43<49:52,  3.46s/it][Succeeded / Failed / Skipped / Total] 97 / 34 / 3 / 134:  13%|█▎        | 134/1000 [07:43<49:52,  3.46s/it][Succeeded / Failed / Skipped / Total] 97 / 34 / 3 / 134:  14%|█▎        | 135/1000 [07:49<50:11,  3.48s/it][Succeeded / Failed / Skipped / Total] 97 / 35 / 3 / 135:  14%|█▎        | 135/1000 [07:49<50:11,  3.48s/it][Succeeded / Failed / Skipped / Total] 97 / 35 / 3 / 135:  14%|█▎        | 136/1000 [07:54<50:13,  3.49s/it][Succeeded / Failed / Skipped / Total] 98 / 35 / 3 / 136:  14%|█▎        | 136/1000 [07:54<50:13,  3.49s/it][Succeeded / Failed / Skipped / Total] 98 / 35 / 3 / 136:  14%|█▎        | 137/1000 [08:02<50:36,  3.52s/it][Succeeded / Failed / Skipped / Total] 99 / 35 / 3 / 137:  14%|█▎        | 137/1000 [08:02<50:36,  3.52s/it][Succeeded / Failed / Skipped / Total] 99 / 35 / 3 / 137:  14%|█▍        | 138/1000 [08:02<50:16,  3.50s/it][Succeeded / Failed / Skipped / Total] 99 / 36 / 3 / 138:  14%|█▍        | 138/1000 [08:02<50:16,  3.50s/it][Succeeded / Failed / Skipped / Total] 99 / 36 / 3 / 138:  14%|█▍        | 139/1000 [08:06<50:13,  3.50s/it]proxy ticket request . --> customerpointivef requests --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[customerpointiveflict]] ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean [[results]] = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[results]] ) ; } return [[results]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 134 ---------------------------------------------
Load a user details from the assertion . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken [[token]] = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( [[token]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[loadwrandamehrts]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken [[i]] = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( [[i]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 135 ---------------------------------------------
Gets the principal . --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[covertherotethingncolvedpleiscll]] ( HttpServletRequest [[httpsgegi]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 136 ---------------------------------------------
Preload map . --> Preload pairs of inmpd . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[inmpd]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[inmpd]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[inmpd]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 137 ---------------------------------------------
Adds a collection of roles . --> drawtrippduherytrynrtation --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > result , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( result , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( result , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( result , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[drawtrippduherytrynrtation]] ( Collection < GrantedAuthority > result , Object [[type]] ) { if ( [[type]] == null ) { return ; } if ( [[type]] instanceof Collection < ? > ) { [[drawtrippduherytrynrtation]] ( result , ( Collection < ? > ) [[type]] ) ; } else if ( [[type]] instanceof Object [ ] ) { [[drawtrippduherytrynrtation]] ( result , ( Object [ ] ) [[type]] ) ; } else if ( [[type]] instanceof String ) { [[drawtrippduherytrynrtation]] ( result , ( String ) [[type]] ) ; } else if ( [[type]] instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) [[type]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[type]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 138 ---------------------------------------------
Checks if authentication is enabled . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean [[serviceTicketRequest]] = [[serviceTicketRequest]] ( request , response ) ; final boolean [[result]] = [[serviceTicketRequest]] || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( [[serviceTicketRequest]] , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[forcesaithedntaced]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean [[sidetisencyfeunt]] = [[sidetisencyfeunt]] ( request , response ) ; final boolean [[composition]] = [[sidetisencyfeunt]] || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( [[sidetisencyfeunt]] , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[composition]] ) ; } return [[composition]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 139 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 100 / 36 / 3 / 139:  14%|█▍        | 139/1000 [08:06<50:13,  3.50s/it][Succeeded / Failed / Skipped / Total] 100 / 36 / 3 / 139:  14%|█▍        | 140/1000 [08:06<49:49,  3.48s/it][Succeeded / Failed / Skipped / Total] 100 / 37 / 3 / 140:  14%|█▍        | 140/1000 [08:06<49:49,  3.48s/it][Succeeded / Failed / Skipped / Total] 100 / 37 / 3 / 140:  14%|█▍        | 141/1000 [08:09<49:41,  3.47s/it][Succeeded / Failed / Skipped / Total] 101 / 37 / 3 / 141:  14%|█▍        | 141/1000 [08:09<49:41,  3.47s/it][Succeeded / Failed / Skipped / Total] 101 / 37 / 3 / 141:  14%|█▍        | 142/1000 [08:14<49:46,  3.48s/it][Succeeded / Failed / Skipped / Total] 102 / 37 / 3 / 142:  14%|█▍        | 142/1000 [08:14<49:46,  3.48s/it][Succeeded / Failed / Skipped / Total] 102 / 37 / 3 / 142:  14%|█▍        | 143/1000 [08:15<49:28,  3.46s/it][Succeeded / Failed / Skipped / Total] 103 / 37 / 3 / 143:  14%|█▍        | 143/1000 [08:15<49:28,  3.46s/it][Succeeded / Failed / Skipped / Total] 103 / 37 / 3 / 143:  14%|█▍        | 144/1000 [08:15<49:06,  3.44s/it][Succeeded / Failed / Skipped / Total] 104 / 37 / 3 / 144:  14%|█▍        | 144/1000 [08:15<49:06,  3.44s/it][Succeeded / Failed / Skipped / Total] 104 / 37 / 3 / 144:  14%|█▍        | 145/1000 [08:18<48:59,  3.44s/it][Succeeded / Failed / Skipped / Total] 105 / 37 / 3 / 145:  14%|█▍        | 145/1000 [08:18<48:59,  3.44s/it][Succeeded / Failed / Skipped / Total] 105 / 37 / 3 / 145:  15%|█▍        | 146/1000 [08:21<48:55,  3.44s/it]Get all roles associated with the specified attributes . --> Get all GrantedAuthority objects --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > [[gaList]] = new ArrayList <> ( ) ; for ( String attribute : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { [[gaList]] . addAll ( c ) ; } } [[gaList]] . trimToSize ( ) ; return [[gaList]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[givequentedjoachicas]] ( Collection < String > [[properties]] ) { ArrayList < GrantedAuthority > [[geliss]] = new ArrayList <> ( ) ; for ( String attribute : [[properties]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { [[geliss]] . addAll ( c ) ; } } [[geliss]] . trimToSize ( ) ; return [[geliss]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 140 ---------------------------------------------
Returns the shared object for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[language]] > [[language]] getSharedObject ( Class < [[language]] > sharedType ) { return ( [[language]] ) this . [[protectedgbqis]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 141 ---------------------------------------------
Get the J2EE principal . --> estrup IEE --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object [[principal]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[estrupætusifgrconjigal]] ( HttpServletRequest httpRequest ) { Object [[santa]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[santa]] ) ; } return [[santa]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 142 ---------------------------------------------
Get all roles mapped collection . --> Gets buzzdavfetaaltrcuppse . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object value ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , value ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[buzzdavfetaaltrcuppse]] ( Object value ) { Collection < GrantedAuthority > [[side]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[side]] , value ) ; return [[side]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 143 ---------------------------------------------
Returns the roles for the given arguments . --> has any role --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[roles]] ) { for ( int i = 0 ; i < [[roles]] . length ; i ++ ) { [[roles]] [ i ] = "ROLE_" + [[roles]] [ i ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[figures]] ) { for ( int i = 0 ; i < [[figures]] . length ; i ++ ) { [[figures]] [ i ] = "ROLE_" + [[figures]] [ i ] ; } return [[figures]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 144 ---------------------------------------------
Checks if the specified role has a role . --> holdsluep --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[holdsluep]] ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 145 ---------------------------------------------
Create a sub - array . --> base -jcade --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] [[array]] , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( [[array]] , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[basejcade]] ( byte [ ] [[rd]] , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( [[rd]] , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 146 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 106 / 37 / 3 / 146:  15%|█▍        | 146/1000 [08:21<48:55,  3.44s/it][Succeeded / Failed / Skipped / Total] 106 / 37 / 3 / 146:  15%|█▍        | 147/1000 [08:24<48:44,  3.43s/it][Succeeded / Failed / Skipped / Total] 107 / 37 / 3 / 147:  15%|█▍        | 147/1000 [08:24<48:44,  3.43s/it][Succeeded / Failed / Skipped / Total] 107 / 37 / 3 / 147:  15%|█▍        | 148/1000 [08:24<48:24,  3.41s/it][Succeeded / Failed / Skipped / Total] 108 / 37 / 3 / 148:  15%|█▍        | 148/1000 [08:24<48:24,  3.41s/it][Succeeded / Failed / Skipped / Total] 108 / 37 / 3 / 148:  15%|█▍        | 149/1000 [08:26<48:10,  3.40s/it][Succeeded / Failed / Skipped / Total] 109 / 37 / 3 / 149:  15%|█▍        | 149/1000 [08:26<48:10,  3.40s/it][Succeeded / Failed / Skipped / Total] 109 / 37 / 3 / 149:  15%|█▌        | 150/1000 [08:28<48:03,  3.39s/it][Succeeded / Failed / Skipped / Total] 110 / 37 / 3 / 150:  15%|█▌        | 150/1000 [08:28<48:03,  3.39s/it][Succeeded / Failed / Skipped / Total] 110 / 37 / 3 / 150:  15%|█▌        | 151/1000 [08:31<47:53,  3.38s/it][Succeeded / Failed / Skipped / Total] 111 / 37 / 3 / 151:  15%|█▌        | 151/1000 [08:31<47:53,  3.38s/it][Succeeded / Failed / Skipped / Total] 111 / 37 / 3 / 151:  15%|█▌        | 152/1000 [08:31<47:32,  3.36s/it][Succeeded / Failed / Skipped / Total] 111 / 37 / 4 / 152:  15%|█▌        | 152/1000 [08:31<47:32,  3.36s/it][Succeeded / Failed / Skipped / Total] 111 / 37 / 4 / 152:  15%|█▌        | 153/1000 [08:31<47:13,  3.35s/it][Succeeded / Failed / Skipped / Total] 112 / 37 / 4 / 153:  15%|█▌        | 153/1000 [08:31<47:13,  3.35s/it][Succeeded / Failed / Skipped / Total] 112 / 37 / 4 / 153:  15%|█▌        | 154/1000 [08:32<46:52,  3.32s/it]Build Redirect url for request . --> builtformapbleradryputur --> Socre: 1.0

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest request ) throws IOException , ServletException { int [[serverPort]] = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( [[serverPort]] ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[builtformapbleradryputurserandattrgt]] ( HttpServletRequest request ) throws IOException , ServletException { int [[spiderlink]] = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( [[spiderlink]] ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 147 ---------------------------------------------
Concatenate the given arrays . --> Enbasnac implementation --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... arrays ) { int [[length]] = 0 ; for ( byte [ ] array : arrays ) { [[length]] += array . length ; } byte [ ] newArray = new byte [ [[length]] ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[enpotnac]] ( byte [ ] ... arrays ) { int [[volume]] = 0 ; for ( byte [ ] array : arrays ) { [[volume]] += array . length ; } byte [ ] newArray = new byte [ [[volume]] ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 148 ---------------------------------------------
Attempts to perform a user . --> Returns the Authentication arrow --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[arrowepatflict]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 149 ---------------------------------------------
Sets the exit user URL . --> bagresdimrumtrif method --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[bagresdimrumtrif]] ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 150 ---------------------------------------------
Executes the invocation invocation . --> Attempt to add an element to the server --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint [[jp]] , AspectJCallback [[advisorProceed]] ) { InterceptorStatusToken [[token]] = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object result ; try { result = [[advisorProceed]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( [[token]] ) ; } return super . afterInvocation ( [[token]] , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[endsr]] ( JoinPoint [[chan]] , AspectJCallback [[awesomereafectg]] ) { InterceptorStatusToken [[invitation]] = super . beforeInvocation ( new MethodInvocationAdapter ( [[chan]] ) ) ; Object result ; try { result = [[awesomereafectg]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( [[invitation]] ) ; } return super . afterInvocation ( [[invitation]] , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 151 ---------------------------------------------
Display a public page index --> Display a random contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[andemliilict]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 152 ---------------------------------------------
Convert a Jwt jwt . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 153 ---------------------------------------------
Creates a JWT using the provided token . --> Decodes a token --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT [[jwt]] = parse ( token ) ; if ( [[jwt]] instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , [[jwt]] ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + [[jwt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT [[yt]] = parse ( token ) ; if ( [[yt]] instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , [[yt]] ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + [[yt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 154 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 113 / 37 / 4 / 154:  15%|█▌        | 154/1000 [08:32<46:52,  3.32s/it][Succeeded / Failed / Skipped / Total] 113 / 37 / 4 / 154:  16%|█▌        | 155/1000 [08:37<47:01,  3.34s/it][Succeeded / Failed / Skipped / Total] 114 / 37 / 4 / 155:  16%|█▌        | 155/1000 [08:37<47:01,  3.34s/it][Succeeded / Failed / Skipped / Total] 114 / 37 / 4 / 155:  16%|█▌        | 156/1000 [08:39<46:51,  3.33s/it][Succeeded / Failed / Skipped / Total] 115 / 37 / 4 / 156:  16%|█▌        | 156/1000 [08:39<46:51,  3.33s/it][Succeeded / Failed / Skipped / Total] 115 / 37 / 4 / 156:  16%|█▌        | 157/1000 [08:44<46:54,  3.34s/it][Succeeded / Failed / Skipped / Total] 116 / 37 / 4 / 157:  16%|█▌        | 157/1000 [08:44<46:54,  3.34s/it][Succeeded / Failed / Skipped / Total] 116 / 37 / 4 / 157:  16%|█▌        | 158/1000 [08:44<46:35,  3.32s/it][Succeeded / Failed / Skipped / Total] 117 / 37 / 4 / 158:  16%|█▌        | 158/1000 [08:44<46:35,  3.32s/it][Succeeded / Failed / Skipped / Total] 117 / 37 / 4 / 158:  16%|█▌        | 159/1000 [08:45<46:21,  3.31s/it][Succeeded / Failed / Skipped / Total] 117 / 38 / 4 / 159:  16%|█▌        | 159/1000 [08:45<46:21,  3.31s/it][Succeeded / Failed / Skipped / Total] 117 / 38 / 4 / 159:  16%|█▌        | 160/1000 [08:47<46:08,  3.30s/it]Filter springSecurityFilterChain Method . --> Bean . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[daspcornsflistoorne]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 155 ---------------------------------------------
Display a new contact --> ModelAndView documentanddotperstation entful --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact [[contact]] = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( [[contact]] ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[documentanddotperstationlyfulkreait]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact [[meet]] = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( [[meet]] ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 156 ---------------------------------------------
Generates a CSRF token . --> Get the generatedrfToken . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[deatiena]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 157 ---------------------------------------------
Attempt to switch to user . --> attackersfixwatch --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken [[targetUserRequest]] ; String username = request . getParameter ( this . [[usernameParameter]] ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[attackersfixwatch]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken [[nefenacide]] ; String username = request . getParameter ( this . [[somagestafinder]] ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 158 ---------------------------------------------
Get ACL for a contact --> region >ram --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl [[acl]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[acl]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[dimermram]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl [[agm]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[agm]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 159 ---------------------------------------------
Process an auto - login cookie . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String [[presentedSeries]] = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( [[presentedSeries]] ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String [[janarmves]] = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( [[janarmves]] ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 160 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 118 / 38 / 4 / 160:  16%|█▌        | 160/1000 [08:47<46:08,  3.30s/it][Succeeded / Failed / Skipped / Total] 118 / 38 / 4 / 160:  16%|█▌        | 161/1000 [08:50<46:03,  3.29s/it][Succeeded / Failed / Skipped / Total] 119 / 38 / 4 / 161:  16%|█▌        | 161/1000 [08:50<46:03,  3.29s/it][Succeeded / Failed / Skipped / Total] 119 / 38 / 4 / 161:  16%|█▌        | 162/1000 [08:52<45:55,  3.29s/it][Succeeded / Failed / Skipped / Total] 120 / 38 / 4 / 162:  16%|█▌        | 162/1000 [08:52<45:55,  3.29s/it][Succeeded / Failed / Skipped / Total] 120 / 38 / 4 / 162:  16%|█▋        | 163/1000 [08:52<45:36,  3.27s/it][Succeeded / Failed / Skipped / Total] 121 / 38 / 4 / 163:  16%|█▋        | 163/1000 [08:52<45:36,  3.27s/it][Succeeded / Failed / Skipped / Total] 121 / 38 / 4 / 163:  16%|█▋        | 164/1000 [08:55<45:29,  3.26s/it][Succeeded / Failed / Skipped / Total] 122 / 38 / 4 / 164:  16%|█▋        | 164/1000 [08:55<45:29,  3.26s/it][Succeeded / Failed / Skipped / Total] 122 / 38 / 4 / 164:  16%|█▋        | 165/1000 [08:56<45:14,  3.25s/it][Succeeded / Failed / Skipped / Total] 123 / 38 / 4 / 165:  16%|█▋        | 165/1000 [08:56<45:14,  3.25s/it][Succeeded / Failed / Skipped / Total] 123 / 38 / 4 / 165:  17%|█▋        | 166/1000 [08:56<44:57,  3.23s/it]Delete a permission . --> region > admin --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[beltinaofvation]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 161 ---------------------------------------------
Checks if the current user is using the url check . --> startizationquepropaek --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[startizationquepropaek]] ( ) throws IOException { String [[remount]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[remount]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 162 ---------------------------------------------
Get UserDetailsResourceFactoryBean . --> Get UserDetailsResourceFactoryBeanr --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[candr]] ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 163 ---------------------------------------------
On login success . --> igaospeactet --> Socre: 1.0

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest request , HttpServletResponse [[response]] , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[persistentToken]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[persistentToken]] ) ; addCookie ( [[persistentToken]] , request , [[response]] ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[igaospeactet]] ( HttpServletRequest request , HttpServletResponse [[i]] , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[constantmptt]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[constantmptt]] ) ; addCookie ( [[constantmptt]] , request , [[i]] ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 164 ---------------------------------------------
Get attribute values . --> Collect allthlucafthergs . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[collectthlucafthergs]] ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 165 ---------------------------------------------
Encodes string into a byte array . --> Encode a CharSequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[string]] ) { try { ByteBuffer [[bytes]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ [[bytes]] . limit ( ) ] ; System . arraycopy ( [[bytes]] . array ( ) , 0 , bytesCopy , 0 , [[bytes]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[c]] ) { try { ByteBuffer [[data]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[c]] ) ) ; byte [ ] bytesCopy = new byte [ [[data]] . limit ( ) ] ; System . arraycopy ( [[data]] . array ( ) , 0 , bytesCopy , 0 , [[data]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 166 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 124 / 38 / 4 / 166:  17%|█▋        | 166/1000 [08:56<44:57,  3.23s/it][Succeeded / Failed / Skipped / Total] 124 / 38 / 4 / 166:  17%|█▋        | 167/1000 [08:57<44:41,  3.22s/it][Succeeded / Failed / Skipped / Total] 125 / 38 / 4 / 167:  17%|█▋        | 167/1000 [08:57<44:41,  3.22s/it][Succeeded / Failed / Skipped / Total] 125 / 38 / 4 / 167:  17%|█▋        | 168/1000 [08:57<44:23,  3.20s/it][Succeeded / Failed / Skipped / Total] 126 / 38 / 4 / 168:  17%|█▋        | 168/1000 [08:57<44:23,  3.20s/it][Succeeded / Failed / Skipped / Total] 126 / 38 / 4 / 168:  17%|█▋        | 169/1000 [08:58<44:09,  3.19s/it][Succeeded / Failed / Skipped / Total] 127 / 38 / 4 / 169:  17%|█▋        | 169/1000 [08:58<44:09,  3.19s/it][Succeeded / Failed / Skipped / Total] 127 / 38 / 4 / 169:  17%|█▋        | 170/1000 [09:03<44:12,  3.20s/it][Succeeded / Failed / Skipped / Total] 128 / 38 / 4 / 170:  17%|█▋        | 170/1000 [09:03<44:12,  3.20s/it][Succeeded / Failed / Skipped / Total] 128 / 38 / 4 / 170:  17%|█▋        | 171/1000 [09:04<44:01,  3.19s/it]Returns the value of the first attribute with the given name . --> Return null if there is none . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[setwirstdtofgettingatedalve]] ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 167 ---------------------------------------------
Decodes bytes . --> Decodes given bands --> Socre: 1.0

[[[[Adv]]]]: public static String decode ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String decode ( byte [ ] [[bands]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bands]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 168 ---------------------------------------------
Gets the default role prefix . --> Returns the datarodexampwveintryflety --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[datarodexampwveintryflety]] ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 169 ---------------------------------------------
Add a new permission --> Generate a user s permissions --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[addPermission]] ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( [[addPermission]] , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[addPermission]] . getRecipient ( ) ) ; Permission [[permission]] = permissionFactory . buildFromMask ( [[addPermission]] . getPermission ( ) ) ; try { contactManager . addPermission ( [[addPermission]] . getContact ( ) , sid , [[permission]] ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[increaseplanetest]] ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( [[increaseplanetest]] , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[increaseplanetest]] . getRecipient ( ) ) ; Permission [[approval]] = permissionFactory . buildFromMask ( [[increaseplanetest]] . getPermission ( ) ) ; try { contactManager . addPermission ( [[increaseplanetest]] . getContact ( ) , sid , [[approval]] ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 170 ---------------------------------------------
Adds a contact . --> addingkontve method --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addingkontve]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 171 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 38 / 4 / 171:  17%|█▋        | 171/1000 [09:04<44:02,  3.19s/it][Succeeded / Failed / Skipped / Total] 129 / 38 / 4 / 171:  17%|█▋        | 172/1000 [09:08<43:59,  3.19s/it][Succeeded / Failed / Skipped / Total] 130 / 38 / 4 / 172:  17%|█▋        | 172/1000 [09:08<43:59,  3.19s/it][Succeeded / Failed / Skipped / Total] 130 / 38 / 4 / 172:  17%|█▋        | 173/1000 [09:09<43:48,  3.18s/it][Succeeded / Failed / Skipped / Total] 131 / 38 / 4 / 173:  17%|█▋        | 173/1000 [09:09<43:48,  3.18s/it][Succeeded / Failed / Skipped / Total] 131 / 38 / 4 / 173:  17%|█▋        | 174/1000 [09:11<43:37,  3.17s/it][Succeeded / Failed / Skipped / Total] 132 / 38 / 4 / 174:  17%|█▋        | 174/1000 [09:11<43:37,  3.17s/it][Succeeded / Failed / Skipped / Total] 132 / 38 / 4 / 174:  18%|█▊        | 175/1000 [09:16<43:41,  3.18s/it][Succeeded / Failed / Skipped / Total] 132 / 39 / 4 / 175:  18%|█▊        | 175/1000 [09:16<43:41,  3.18s/it][Succeeded / Failed / Skipped / Total] 132 / 39 / 4 / 175:  18%|█▊        | 176/1000 [09:17<43:27,  3.17s/it][Succeeded / Failed / Skipped / Total] 133 / 39 / 4 / 176:  18%|█▊        | 176/1000 [09:17<43:27,  3.17s/it][Succeeded / Failed / Skipped / Total] 134 / 39 / 4 / 177:  18%|█▊        | 177/1000 [09:17<43:10,  3.15s/it][Succeeded / Failed / Skipped / Total] 134 / 39 / 4 / 177:  18%|█▊        | 178/1000 [09:25<43:32,  3.18s/it]Evaluates access expression . --> Return true if we are compedingantapiresempotional --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[ioException]] = new IOException ( ) ; [[ioException]] . initCause ( e ) ; throw [[ioException]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[areazedingantapiresempotional]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[edgesentree]] = new IOException ( ) ; [[edgesentree]] . initCause ( e ) ; throw [[edgesentree]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 172 ---------------------------------------------
Returns all config attributes . --> zipbridgeacfyvantfiuliffs --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > allAttributes = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { allAttributes . addAll ( attributeList ) ; } return allAttributes ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[zipbridgeacfyvantfiuliffs]] ( ) { Set < ConfigAttribute > allAttributes = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { allAttributes . addAll ( attributeList ) ; } return allAttributes ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 173 ---------------------------------------------
Returns a random contact . --> Returns random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random [[rnd]] = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = [[rnd]] . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random [[bbda]] = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = [[bbda]] . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 174 ---------------------------------------------
Handle an exception . --> Handle administratordn --> Socre: 1.0

[[[[Adv]]]]: protected void handleBindException ( String [[userDn]] , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[userDn]] + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void handleBindException ( String [[administratordn]] , String username , Throwable [[caused]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[administratordn]] + ": " + [[caused]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 175 ---------------------------------------------
Find attributes associated with the specified method . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[escapeinciafoti]] ( Method method , Class < ? > [[childbar]] ) { if ( [[childbar]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[childbar]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 176 ---------------------------------------------
Create a new instance of any request . --> Convenience method to create a new instance of C --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[everyrigues]] ( ) { Assert . state ( ! this . [[ishenametimeffgysed]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[ishenametimeffgysed]] = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 177 ---------------------------------------------
Checks if the given name is a match . --> Do a hered statement? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String methodName , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && methodName . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && methodName . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[herbuscut]] ( String methodName , String [[tracinggirl]] ) { return ( [[tracinggirl]] . endsWith ( "*" ) && methodName . startsWith ( [[tracinggirl]] . substring ( 0 , [[tracinggirl]] . length ( ) - 1 ) ) ) || ( [[tracinggirl]] . startsWith ( "*" ) && methodName . endsWith ( [[tracinggirl]] . substring ( 1 , [[tracinggirl]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 178 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 135 / 39 / 4 / 178:  18%|█▊        | 178/1000 [09:25<43:32,  3.18s/it][Succeeded / Failed / Skipped / Total] 136 / 39 / 4 / 179:  18%|█▊        | 179/1000 [09:27<43:20,  3.17s/it][Succeeded / Failed / Skipped / Total] 136 / 39 / 4 / 179:  18%|█▊        | 180/1000 [09:28<43:07,  3.16s/it][Succeeded / Failed / Skipped / Total] 137 / 39 / 4 / 180:  18%|█▊        | 180/1000 [09:28<43:07,  3.16s/it][Succeeded / Failed / Skipped / Total] 138 / 39 / 4 / 181:  18%|█▊        | 181/1000 [09:29<42:58,  3.15s/it][Succeeded / Failed / Skipped / Total] 138 / 39 / 4 / 181:  18%|█▊        | 182/1000 [09:36<43:11,  3.17s/it][Succeeded / Failed / Skipped / Total] 139 / 39 / 4 / 182:  18%|█▊        | 182/1000 [09:36<43:11,  3.17s/it]Add a secure method . --> diesdarametogol --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod method , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + [[attr]] + "]" ) ; } this . methodMap . put ( method , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[diesdarametogol]] ( RegisteredMethod method , List < ConfigAttribute > [[ausray]] ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( [[ausray]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + [[ausray]] + "]" ) ; } this . methodMap . put ( method , [[ausray]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 179 ---------------------------------------------
Clear the authentication attributes . --> Declarative Services method for setting blexlientvers --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( "[[False]]" != "[[False]]" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[blexlientversmatkibinetions]] ( HttpServletRequest [[application]] ) { HttpSession session = [[application]] . getSession ( "[[suspected]]" != "[[suspected]]" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 180 ---------------------------------------------
Creates the redirect url . --> encyclopediaruprenputv job --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[encyclopediaruprenputvל]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 181 ---------------------------------------------
Sends an access request . --> comms access --> Socre: 1.0

[[[[Adv]]]]: public void commence ( HttpServletRequest [[request]] , HttpServletResponse response , AuthenticationException [[arg2]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void commence ( HttpServletRequest [[demanded]] , HttpServletResponse response , AuthenticationException [[dgp9]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 182 ---------------------------------------------
Checks all filters . --> bankdileantrotz --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[bankdileantrotz]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 183 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 140 / 39 / 4 / 183:  18%|█▊        | 183/1000 [09:39<43:05,  3.17s/it][Succeeded / Failed / Skipped / Total] 140 / 39 / 4 / 183:  18%|█▊        | 184/1000 [09:40<42:53,  3.15s/it][Succeeded / Failed / Skipped / Total] 140 / 40 / 4 / 184:  18%|█▊        | 184/1000 [09:40<42:53,  3.15s/it][Succeeded / Failed / Skipped / Total] 140 / 41 / 4 / 185:  18%|█▊        | 185/1000 [09:41<42:43,  3.15s/it][Succeeded / Failed / Skipped / Total] 140 / 41 / 4 / 185:  19%|█▊        | 186/1000 [09:47<42:49,  3.16s/it][Succeeded / Failed / Skipped / Total] 141 / 41 / 4 / 186:  19%|█▊        | 186/1000 [09:47<42:49,  3.16s/it][Succeeded / Failed / Skipped / Total] 142 / 41 / 4 / 187:  19%|█▊        | 187/1000 [09:49<42:40,  3.15s/it][Succeeded / Failed / Skipped / Total] 142 / 41 / 4 / 187:  19%|█▉        | 188/1000 [09:59<43:07,  3.19s/it][Succeeded / Failed / Skipped / Total] 143 / 41 / 4 / 188:  19%|█▉        | 188/1000 [09:59<43:07,  3.19s/it][Succeeded / Failed / Skipped / Total] 143 / 41 / 4 / 188:  19%|█▉        | 189/1000 [09:59<42:53,  3.17s/it]Register access manager . --> Generate a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[registerAccessManager]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[classecursesoraker]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 184 ---------------------------------------------
Create the service url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { return CommonUtils . constructServiceUrl ( null , [[response]] , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . [[encodeServiceUrlWithSessionId]] ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[gutsrdfers]] ( final HttpServletRequest request , final HttpServletResponse [[action]] ) { return CommonUtils . constructServiceUrl ( null , [[action]] , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . [[einformsonveseroallyetephasmed]] ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 185 ---------------------------------------------
Returns the field with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[canful]] ( Class < ? > [[flstanze]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[flstanze]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[flstanze]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 186 ---------------------------------------------
Checks if expected matches actual . --> Return true if expected matches es --> Socre: 1.0

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] [[actual]] ) { if ( expected . length != [[actual]] . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ [[actual]] [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] [[es]] ) { if ( expected . length != [[es]] . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ [[es]] [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 187 ---------------------------------------------
Get the registered types . --> Unseghret --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . [[extractorMap]] . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[unseghretcorepers]] ( ) { Set < Class < ? extends Throwable > > [[languagetel]] = this . [[etenttripft]] . keySet ( ) ; return [[languagetel]] . toArray ( new Class [ [[languagetel]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 188 ---------------------------------------------
Extract the cause of the given throwable . --> ichoject operation --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor [[extractor]] = entry . getValue ( ) ; return [[extractor]] . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[ichchoject]] ( Throwable [[addover]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( [[addover]] ) ) { ThrowableCauseExtractor [[arresty]] = entry . getValue ( ) ; return [[arresty]] . extractCause ( [[addover]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 189 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 144 / 41 / 4 / 189:  19%|█▉        | 189/1000 [09:59<42:53,  3.17s/it][Succeeded / Failed / Skipped / Total] 144 / 41 / 4 / 189:  19%|█▉        | 190/1000 [10:00<42:41,  3.16s/it][Succeeded / Failed / Skipped / Total] 144 / 42 / 4 / 190:  19%|█▉        | 190/1000 [10:00<42:41,  3.16s/it][Succeeded / Failed / Skipped / Total] 144 / 42 / 4 / 190:  19%|█▉        | 191/1000 [10:03<42:34,  3.16s/it][Succeeded / Failed / Skipped / Total] 145 / 42 / 4 / 191:  19%|█▉        | 191/1000 [10:03<42:34,  3.16s/it][Succeeded / Failed / Skipped / Total] 145 / 42 / 4 / 191:  19%|█▉        | 192/1000 [10:04<42:22,  3.15s/it][Succeeded / Failed / Skipped / Total] 146 / 42 / 4 / 192:  19%|█▉        | 192/1000 [10:04<42:22,  3.15s/it][Succeeded / Failed / Skipped / Total] 146 / 42 / 4 / 192:  19%|█▉        | 193/1000 [10:08<42:26,  3.16s/it][Succeeded / Failed / Skipped / Total] 147 / 42 / 4 / 193:  19%|█▉        | 193/1000 [10:08<42:26,  3.16s/it][Succeeded / Failed / Skipped / Total] 147 / 42 / 4 / 193:  19%|█▉        | 194/1000 [10:10<42:14,  3.14s/it][Succeeded / Failed / Skipped / Total] 148 / 42 / 4 / 194:  19%|█▉        | 194/1000 [10:10<42:14,  3.14s/it][Succeeded / Failed / Skipped / Total] 148 / 42 / 4 / 194:  20%|█▉        | 195/1000 [10:18<42:33,  3.17s/it]Extract prefix for SHA prefix . --> return a fotbregif --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[arraybregif]] ( String [[kenpesflict]] ) { if ( ! [[kenpesflict]] . startsWith ( "{" ) ) { return null ; } int [[batterybescy]] = [[kenpesflict]] . lastIndexOf ( ' ' ) ; if ( [[batterybescy]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[kenpesflict]] . substring ( 0 , [[batterybescy]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 190 ---------------------------------------------
lookup parameter names . --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int [[parameterCount]] = parameterAnnotations . length ; String [ ] paramNames = new String [ [[parameterCount]] ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < [[parameterCount]] ; i ++ ) { Annotation [ ] [[annotations]] = parameterAnnotations [ i ] ; String parameterName = findParameterName ( [[annotations]] ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int [[clienticaunds]] = parameterAnnotations . length ; String [ ] paramNames = new String [ [[clienticaunds]] ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < [[clienticaunds]] ; i ++ ) { Annotation [ ] [[basedigarts]] = parameterAnnotations [ i ] ; String parameterName = findParameterName ( [[basedigarts]] ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 191 ---------------------------------------------
Set the set of resolved hidden inputs . --> closearsselforcehideshinvics --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[closearsselforcehideshinvics]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . [[dataherdrnfrontds]] = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 192 ---------------------------------------------
Set the default redirect url . --> catchdeefolthlfisuitorl --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[catchdeefolthlfisuitorl]] ( String [[emergencyvitaisuredurל]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[emergencyvitaisuredurל]] ) , ( ) -> "'" + [[emergencyvitaisuredurל]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[emergencyvitaisuredurל]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 193 ---------------------------------------------
Converts the given result object into an identifier . --> Convert a ResultSet object to an identifier --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[accessionaifywarox]] ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 194 ---------------------------------------------
Get the authority list to set . --> Get the adocumenttlth --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[userAuthorities]] ) { [[set]] . add ( [[authority]] . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[adocumenttlth]] ( Collection < ? extends GrantedAuthority > [[givenrunsolities]] ) { Assert . notNull ( [[givenrunsolities]] , "userAuthorities cannot be null" ) ; Set < String > [[t]] = new HashSet <> ( [[givenrunsolities]] . size ( ) ) ; for ( GrantedAuthority [[authoritative]] : [[givenrunsolities]] ) { [[t]] . add ( [[authoritative]] . getAuthority ( ) ) ; } return [[t]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 195 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 149 / 42 / 4 / 195:  20%|█▉        | 195/1000 [10:18<42:33,  3.17s/it][Succeeded / Failed / Skipped / Total] 149 / 42 / 4 / 195:  20%|█▉        | 196/1000 [10:18<42:18,  3.16s/it][Succeeded / Failed / Skipped / Total] 149 / 42 / 5 / 196:  20%|█▉        | 196/1000 [10:18<42:18,  3.16s/it][Succeeded / Failed / Skipped / Total] 149 / 42 / 5 / 196:  20%|█▉        | 197/1000 [10:19<42:05,  3.15s/it][Succeeded / Failed / Skipped / Total] 149 / 43 / 5 / 197:  20%|█▉        | 197/1000 [10:19<42:05,  3.15s/it][Succeeded / Failed / Skipped / Total] 149 / 43 / 5 / 197:  20%|█▉        | 198/1000 [10:21<41:58,  3.14s/it][Succeeded / Failed / Skipped / Total] 149 / 44 / 5 / 198:  20%|█▉        | 198/1000 [10:21<41:58,  3.14s/it][Succeeded / Failed / Skipped / Total] 149 / 44 / 5 / 198:  20%|█▉        | 199/1000 [10:25<41:57,  3.14s/it][Succeeded / Failed / Skipped / Total] 150 / 44 / 5 / 199:  20%|█▉        | 199/1000 [10:25<41:57,  3.14s/it][Succeeded / Failed / Skipped / Total] 150 / 44 / 5 / 199:  20%|██        | 200/1000 [10:29<41:57,  3.15s/it][Succeeded / Failed / Skipped / Total] 151 / 44 / 5 / 200:  20%|██        | 200/1000 [10:29<41:57,  3.15s/it][Succeeded / Failed / Skipped / Total] 151 / 44 / 5 / 200:  20%|██        | 201/1000 [10:29<41:43,  3.13s/it][Succeeded / Failed / Skipped / Total] 152 / 44 / 5 / 201:  20%|██        | 201/1000 [10:29<41:43,  3.13s/it][Succeeded / Failed / Skipped / Total] 152 / 44 / 5 / 201:  20%|██        | 202/1000 [10:30<41:30,  3.12s/it]Create the list of AccessControlEntries . --> shapethders an AccessControlEntry --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl [[acl]] ) { if ( [[acl]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[acl]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = [[acl]] . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) [[acl]] . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[shapethders]] ( final MutableAcl [[iil]] ) { if ( [[iil]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[iil]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = [[iil]] . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) [[iil]] . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 196 ---------------------------------------------
Returns an empty ServerWebExchangeMatcher . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 197 ---------------------------------------------
Returns true if url is absolute . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[cocsacvdutml]] ( String [[gur]] ) { if ( [[gur]] == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[gur]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 198 ---------------------------------------------
Create attribute list . --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[onlinetimepifortalon]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 199 ---------------------------------------------
Build the request URL --> Drawredjectravemal method --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String [[servletPath]] , String requestURI , String [[contextPath]] , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[servletPath]] != null ) { url . append ( [[servletPath]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( [[contextPath]] . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[drawredjectravemal]] ( String [[ervlinepathic]] , String requestURI , String [[bufferva]] , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[ervlinepathic]] != null ) { url . append ( [[ervlinepathic]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( [[bufferva]] . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 200 ---------------------------------------------
Create a queryable text using the given password . --> AesBytesEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[logenmatch]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 201 ---------------------------------------------
Create a text encryptor . --> Create textEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence [[canvas]] , CharSequence [[fm]] ) { return new HexEncodingTextEncryptor ( standard ( [[canvas]] , [[fm]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
[Succeeded / Failed / Skipped / Total] 153 / 44 / 5 / 202:  20%|██        | 202/1000 [10:30<41:30,  3.12s/it][Succeeded / Failed / Skipped / Total] 153 / 44 / 5 / 202:  20%|██        | 203/1000 [10:39<41:50,  3.15s/it][Succeeded / Failed / Skipped / Total] 154 / 44 / 5 / 203:  20%|██        | 203/1000 [10:39<41:50,  3.15s/it][Succeeded / Failed / Skipped / Total] 154 / 44 / 5 / 203:  20%|██        | 204/1000 [10:40<41:38,  3.14s/it][Succeeded / Failed / Skipped / Total] 155 / 44 / 5 / 204:  20%|██        | 204/1000 [10:40<41:38,  3.14s/it][Succeeded / Failed / Skipped / Total] 155 / 44 / 5 / 204:  20%|██        | 205/1000 [10:43<41:36,  3.14s/it][Succeeded / Failed / Skipped / Total] 156 / 44 / 5 / 205:  20%|██        | 205/1000 [10:43<41:36,  3.14s/it][Succeeded / Failed / Skipped / Total] 156 / 44 / 5 / 205:  21%|██        | 206/1000 [10:47<41:34,  3.14s/it][Succeeded / Failed / Skipped / Total] 157 / 44 / 5 / 206:  21%|██        | 206/1000 [10:47<41:34,  3.14s/it]--------------------------------------------- Result 202 ---------------------------------------------
Deletes the given password with the given salt . --> Liefert delux TextEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( password , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence [[immunity]] ) { return new HexEncodingTextEncryptor ( stronger ( password , [[immunity]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 203 ---------------------------------------------
Determines the target URL for the request . --> Finds andalnut statement . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[andalnutofil]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[andalnutofil]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 204 ---------------------------------------------
Update the ObjectIdentity of this object . --> Update this objectIdentity --> Socre: 1.0

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl [[oii]] = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( [[oii]] ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int [[count]] = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( [[count]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl [[owι]] = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( [[owι]] ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int [[counts]] = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( [[counts]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 205 ---------------------------------------------
Save the request to the servlet . --> putfewr to HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[putfewr]] ( HttpServletRequest [[service]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[service]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[service]] , portResolver ) ; if ( createSessionAllowed || [[service]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 206 ---------------------------------------------
Replies the parent directory . --> Findereastoreule . --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[babydrereastoreywciftrixpotjectpurule]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 207 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 158 / 44 / 5 / 207:  21%|██        | 207/1000 [10:47<41:19,  3.13s/it][Succeeded / Failed / Skipped / Total] 158 / 44 / 5 / 207:  21%|██        | 208/1000 [10:47<41:06,  3.11s/it][Succeeded / Failed / Skipped / Total] 159 / 44 / 5 / 208:  21%|██        | 208/1000 [10:47<41:06,  3.11s/it][Succeeded / Failed / Skipped / Total] 159 / 45 / 5 / 209:  21%|██        | 209/1000 [10:50<41:01,  3.11s/it][Succeeded / Failed / Skipped / Total] 159 / 45 / 5 / 209:  21%|██        | 210/1000 [10:51<40:50,  3.10s/it][Succeeded / Failed / Skipped / Total] 159 / 46 / 5 / 210:  21%|██        | 210/1000 [10:51<40:50,  3.10s/it][Succeeded / Failed / Skipped / Total] 160 / 46 / 5 / 211:  21%|██        | 211/1000 [10:52<40:41,  3.09s/it][Succeeded / Failed / Skipped / Total] 160 / 46 / 5 / 211:  21%|██        | 212/1000 [10:55<40:34,  3.09s/it][Succeeded / Failed / Skipped / Total] 160 / 47 / 5 / 212:  21%|██        | 212/1000 [10:55<40:34,  3.09s/it]Write the header . --> Link linkshees --> Socre: 1.0

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( [[request]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[linkshees]] ( HttpServletRequest [[requests]] , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( [[requests]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 208 ---------------------------------------------
Build userDn . --> Build a userDn --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[username]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[username]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[baseid]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[baseid]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 209 ---------------------------------------------
Returns a path by combining the provided parameters . --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod [[method]] , String ... [[patterns]] ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( [[patterns]] . length ) ; for ( String pattern : [[patterns]] ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod [[pattern]] , String ... [[marks]] ) { List < ServerWebExchangeMatcher > [[printpers]] = new ArrayList <> ( [[marks]] . length ) ; for ( String pattern : [[marks]] ) { [[printpers]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , [[pattern]] ) ) ; } return new OrServerWebExchangeMatcher ( [[printpers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 210 ---------------------------------------------
Determine the target URL for this request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[determinationtraetteraflist]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 211 ---------------------------------------------
Creates the shared object map . --> Returns a map of archiveshadefeebveysa . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[archiveshadefeebveysin]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 212 ---------------------------------------------
Create the object identity . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[True]]" == "[[True]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[True]]" == "[[True]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[bookurmetiernactz]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[natural]]" == "[[natural]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[natural]]" == "[[natural]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 213 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 161 / 47 / 5 / 213:  21%|██▏       | 213/1000 [10:58<40:31,  3.09s/it][Succeeded / Failed / Skipped / Total] 161 / 47 / 5 / 213:  21%|██▏       | 214/1000 [11:01<40:30,  3.09s/it][Succeeded / Failed / Skipped / Total] 162 / 47 / 5 / 214:  21%|██▏       | 214/1000 [11:01<40:30,  3.09s/it][Succeeded / Failed / Skipped / Total] 163 / 47 / 5 / 215:  22%|██▏       | 215/1000 [11:02<40:20,  3.08s/it][Succeeded / Failed / Skipped / Total] 163 / 47 / 5 / 215:  22%|██▏       | 216/1000 [11:03<40:09,  3.07s/it][Succeeded / Failed / Skipped / Total] 164 / 47 / 5 / 216:  22%|██▏       | 216/1000 [11:03<40:09,  3.07s/it][Succeeded / Failed / Skipped / Total] 165 / 47 / 5 / 217:  22%|██▏       | 217/1000 [11:06<40:06,  3.07s/it][Succeeded / Failed / Skipped / Total] 165 / 47 / 5 / 217:  22%|██▏       | 218/1000 [11:10<40:06,  3.08s/it][Succeeded / Failed / Skipped / Total] 166 / 47 / 5 / 218:  22%|██▏       | 218/1000 [11:10<40:06,  3.08s/it][Succeeded / Failed / Skipped / Total] 167 / 47 / 5 / 219:  22%|██▏       | 219/1000 [11:11<39:56,  3.07s/it][Succeeded / Failed / Skipped / Total] 167 / 47 / 5 / 219:  22%|██▏       | 220/1000 [11:17<40:03,  3.08s/it]Returns the current date . --> pulltrredencecode --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[pulltrredencecode]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 214 ---------------------------------------------
Sets the target URL parameter . --> zenarihdroUTFiaquent zenarihdropariaquent --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[zenarihdropariaquent]] ( String [[coververtareeter]] ) { if ( [[coververtareeter]] != null ) { Assert . hasText ( [[coververtareeter]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[coververtareeter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 215 ---------------------------------------------
Internal parse dates . --> returns null if the value is null --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] [[formats]] ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { date = [[formats]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[imsesredete]] ( String value , DateFormat [ ] [[features]] ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < [[features]] . length ) ; i ++ ) { try { date = [[features]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 216 ---------------------------------------------
Sets the authentication token . --> escapedelaries --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest [[request]] , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[escapedelaries]] ( HttpServletRequest [[list]] , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[list]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 217 ---------------------------------------------
Update cache . --> Audit a value --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[auditreaw]] ( HashMap [[node]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[node]] . size ( ) > 1000 ) { [[node]] . clear ( ) ; } [[node]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 218 ---------------------------------------------
Throws if the session is enabled for this principal exceeded . --> Should allowableSessions for this principal exceeded? --> Socre: 1.0

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry [[console]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 219 ---------------------------------------------
Configures the Jaas . --> Method configureJaasUsingLoop --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int [[n]] = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + [[n]] ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } [[n]] ++ ; } if ( ! alreadySet ) { String [[key]] = prefix + [[n]] ; log . debug ( "Setting security property [" + [[key]] + "] to: " + loginConfigUrl ) ; Security . setProperty ( [[key]] , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int [[min]] = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + [[min]] ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } [[min]] ++ ; } if ( ! alreadySet ) { String [[island]] = prefix + [[min]] ; log . debug ( "Setting security property [" + [[island]] + "] to: " + loginConfigUrl ) ; Security . setProperty ( [[island]] , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 220 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 168 / 47 / 5 / 220:  22%|██▏       | 220/1000 [11:17<40:03,  3.08s/it][Succeeded / Failed / Skipped / Total] 169 / 47 / 5 / 221:  22%|██▏       | 221/1000 [11:18<39:51,  3.07s/it][Succeeded / Failed / Skipped / Total] 169 / 47 / 5 / 221:  22%|██▏       | 222/1000 [11:19<39:40,  3.06s/it][Succeeded / Failed / Skipped / Total] 169 / 48 / 5 / 222:  22%|██▏       | 222/1000 [11:19<39:40,  3.06s/it][Succeeded / Failed / Skipped / Total] 170 / 48 / 5 / 223:  22%|██▏       | 223/1000 [11:20<39:29,  3.05s/it][Succeeded / Failed / Skipped / Total] 170 / 48 / 5 / 223:  22%|██▏       | 224/1000 [11:24<39:32,  3.06s/it][Succeeded / Failed / Skipped / Total] 170 / 49 / 5 / 224:  22%|██▏       | 224/1000 [11:24<39:32,  3.06s/it][Succeeded / Failed / Skipped / Total] 171 / 49 / 5 / 225:  22%|██▎       | 225/1000 [11:25<39:22,  3.05s/it][Succeeded / Failed / Skipped / Total] 171 / 49 / 5 / 225:  23%|██▎       | 226/1000 [11:26<39:12,  3.04s/it][Succeeded / Failed / Skipped / Total] 171 / 50 / 5 / 226:  23%|██▎       | 226/1000 [11:26<39:12,  3.04s/it][Succeeded / Failed / Skipped / Total] 172 / 50 / 5 / 227:  23%|██▎       | 227/1000 [11:26<38:58,  3.03s/it][Succeeded / Failed / Skipped / Total] 172 / 50 / 5 / 227:  23%|██▎       | 228/1000 [11:36<39:18,  3.06s/it][Succeeded / Failed / Skipped / Total] 173 / 50 / 5 / 228:  23%|██▎       | 228/1000 [11:36<39:18,  3.06s/it]Build a group name . --> Build the DistinguishedName for the grouping --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String [[group]] ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String [[grouping]] ) { DistinguishedName [[cdan]] = new DistinguishedName ( groupSearchBase ) ; [[cdan]] . add ( groupRoleAttributeName , [[grouping]] . toLowerCase ( ) ) ; return [[cdan]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 221 ---------------------------------------------
Returns the filters for the specified URL . --> Collects a list of choices from url --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String url ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[collectweenerz]] ( String url ) { return [[collectweenerz]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 222 ---------------------------------------------
Returns the security name for the given subject . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject subject ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + subject ) ; } String userSecurityName = null ; if ( subject != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[bookspeecurenum]] ( final Subject subject ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + subject ) ; } String userSecurityName = null ; if ( subject != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 223 ---------------------------------------------
Copies the authentication token . --> cloner Activity --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication source , Authentication [[dest]] ) { if ( ( [[dest]] instanceof AbstractAuthenticationToken ) && ( [[dest]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) [[dest]] ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[cloneretails]] ( Authentication source , Authentication [[deτ]] ) { if ( ( [[deτ]] instanceof AbstractAuthenticationToken ) && ( [[deτ]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) [[deτ]] ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 224 ---------------------------------------------
Get the current time qualifiers . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[collectdrecstokestuidsystems]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 225 ---------------------------------------------
Get the application context . --> returns null if none exists --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext pageContext ) { ServletContext [[servletContext]] = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[storeofport]] ( PageContext pageContext ) { ServletContext [[nariclunvent]] = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[nariclunvent]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 226 ---------------------------------------------
Retrieves the list of filters from the request . --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[request]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[bookwilkef]] ( HttpServletRequest [[http]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[http]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 227 ---------------------------------------------
Adds filters . --> Sets the towers --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > filters ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[towers]] ( List < Filter > filters ) { Validate . notNull ( [[towers]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[towers]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 228 ---------------------------------------------
Returns the full full full name for the given dn . --> Get theDn --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName getFullDn ( DistinguishedName [[dn]] , Context baseCtx ) throws NamingException { DistinguishedName [[baseDn]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( [[baseDn]] ) ) { return [[dn]] ; } [[baseDn]] . append ( [[dn]] ) ; return [[baseDn]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName getFullDn ( DistinguishedName [[darrn]] , Context baseCtx ) throws NamingException { DistinguishedName [[dasן]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[darrn]] . contains ( [[dasן]] ) ) { return [[darrn]] ; } [[dasן]] . append ( [[darrn]] ) ; return [[dasן]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 229 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 173 / 51 / 5 / 229:  23%|██▎       | 229/1000 [11:45<39:34,  3.08s/it][Succeeded / Failed / Skipped / Total] 173 / 51 / 5 / 229:  23%|██▎       | 230/1000 [11:45<39:21,  3.07s/it][Succeeded / Failed / Skipped / Total] 173 / 52 / 5 / 230:  23%|██▎       | 230/1000 [11:45<39:21,  3.07s/it][Succeeded / Failed / Skipped / Total] 174 / 52 / 5 / 231:  23%|██▎       | 231/1000 [11:48<39:18,  3.07s/it][Succeeded / Failed / Skipped / Total] 174 / 52 / 5 / 231:  23%|██▎       | 232/1000 [11:50<39:11,  3.06s/it][Succeeded / Failed / Skipped / Total] 174 / 53 / 5 / 232:  23%|██▎       | 232/1000 [11:50<39:11,  3.06s/it][Succeeded / Failed / Skipped / Total] 175 / 53 / 5 / 233:  23%|██▎       | 233/1000 [11:51<39:00,  3.05s/it][Succeeded / Failed / Skipped / Total] 175 / 53 / 5 / 233:  23%|██▎       | 234/1000 [11:51<38:48,  3.04s/it][Succeeded / Failed / Skipped / Total] 175 / 54 / 5 / 234:  23%|██▎       | 234/1000 [11:51<38:48,  3.04s/it]Adds additional filters . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[shades]] ( Filter [[effect]] , Filter ... [[additionsfltass]] ) { Validate . notNull ( [[effect]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[effect]] ) ; if ( [[additionsfltass]] != null ) { Collections . addAll ( RestAssured . filters , [[additionsfltass]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 230 ---------------------------------------------
Set request specification session attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[jangroundins]] ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 231 ---------------------------------------------
proxy the given URI . --> Set urit --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[profile]] ( URI [[urit]] ) { if ( [[urit]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[profile]] ( new ProxySpecification ( [[urit]] . getHost ( ) , [[urit]] . getPort ( ) , [[urit]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 232 ---------------------------------------------
Return the basic authentication for the given user . --> [[[FAILED]]]

[[[[Adv]]]]: public AuthenticationScheme basic ( String [[userName]] , String [[password]] ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( [[userName]] ) ; preemptiveBasicAuthScheme . setPassword ( [[password]] ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme basic ( String [[hostie]] , String [[signature]] ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( [[hostie]] ) ; preemptiveBasicAuthScheme . setPassword ( [[signature]] ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 233 ---------------------------------------------
Print response options . --> Handle roll . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[roll]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 234 ---------------------------------------------
Returns a new AuthenticationScheme for the given user name and password . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme [[n]] = new BasicAuthScheme ( ) ; [[n]] . setUserName ( userName ) ; [[n]] . setPassword ( password ) ; return [[n]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 235 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 176 / 54 / 5 / 235:  24%|██▎       | 235/1000 [11:53<38:41,  3.03s/it][Succeeded / Failed / Skipped / Total] 176 / 54 / 5 / 235:  24%|██▎       | 236/1000 [11:55<38:37,  3.03s/it][Succeeded / Failed / Skipped / Total] 177 / 54 / 5 / 236:  24%|██▎       | 236/1000 [11:55<38:37,  3.03s/it][Succeeded / Failed / Skipped / Total] 178 / 54 / 5 / 237:  24%|██▎       | 237/1000 [11:58<38:34,  3.03s/it][Succeeded / Failed / Skipped / Total] 178 / 54 / 5 / 237:  24%|██▍       | 238/1000 [11:59<38:23,  3.02s/it][Succeeded / Failed / Skipped / Total] 178 / 55 / 5 / 238:  24%|██▍       | 238/1000 [11:59<38:23,  3.02s/it][Succeeded / Failed / Skipped / Total] 179 / 55 / 5 / 239:  24%|██▍       | 239/1000 [12:00<38:12,  3.01s/it][Succeeded / Failed / Skipped / Total] 179 / 55 / 5 / 239:  24%|██▍       | 240/1000 [12:00<38:00,  3.00s/it][Succeeded / Failed / Skipped / Total] 180 / 55 / 5 / 240:  24%|██▍       | 240/1000 [12:00<38:00,  3.00s/it]Changes the password . --> F743 - 3 --> Socre: 1.0

[[[[Adv]]]]: public void [[changePassword]] ( final String [[oldPassword]] , final String [[newPassword]] ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[oldPassword]] , [[newPassword]] ) ; } else { changePasswordUsingAttributeModification ( userDn , [[oldPassword]] , [[newPassword]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[covernettalk]] ( final String [[youngverbaum]] , final String [[keyworkpost]] ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[youngverbaum]] , [[keyworkpost]] ) ; } else { changePasswordUsingAttributeModification ( userDn , [[youngverbaum]] , [[keyworkpost]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 236 ---------------------------------------------
Gets the NTLMAuth scheme . --> Returns the AuthenticationScheme for the given userName and password --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String [[workstation]] , String [[domain]] ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setWorkstation ( [[workstation]] ) ; [[scheme]] . setDomain ( [[domain]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String [[covershall]] , String [[neck]] ) { final NTLMAuthScheme [[band]] = new NTLMAuthScheme ( ) ; [[band]] . setUserName ( userName ) ; [[band]] . setPassword ( password ) ; [[band]] . setWorkstation ( [[covershall]] ) ; [[band]] . setDomain ( [[neck]] ) ; return [[band]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 237 ---------------------------------------------
Returns a default query charset . --> Creates a commonurriedpatreerhrettrix . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[commonurriedpatreerhrettrix]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 238 ---------------------------------------------
Get the scheme information for a user . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme form ( String userName , String password , FormAuthConfig [[config]] ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setConfig ( [[config]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme form ( String userName , String password , FormAuthConfig [[veuigan]] ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[sequence]] = new FormAuthScheme ( ) ; [[sequence]] . setUserName ( userName ) ; [[sequence]] . setPassword ( password ) ; [[sequence]] . setConfig ( [[veuigan]] ) ; return [[sequence]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 239 ---------------------------------------------
Returns the default object type . --> 2ndlibcasetraffleport ObjectMapper --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[2ndlibcasetraffleport]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[2ndlibcasetraffleport]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 240 ---------------------------------------------
Gets an instance of RestAssuredMockUrls config . --> Get an RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig logConfig ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[hallcomfinegging]] ( LogConfig logConfig ) { notNull ( [[hallcomfinegging]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[hallcomfinegging]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 241 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 181 / 55 / 5 / 241:  24%|██▍       | 241/1000 [12:01<37:52,  2.99s/it][Succeeded / Failed / Skipped / Total] 181 / 55 / 5 / 241:  24%|██▍       | 242/1000 [12:02<37:43,  2.99s/it][Succeeded / Failed / Skipped / Total] 182 / 55 / 5 / 242:  24%|██▍       | 242/1000 [12:02<37:43,  2.99s/it][Succeeded / Failed / Skipped / Total] 183 / 55 / 5 / 243:  24%|██▍       | 243/1000 [12:05<37:41,  2.99s/it][Succeeded / Failed / Skipped / Total] 183 / 55 / 5 / 243:  24%|██▍       | 244/1000 [12:08<37:35,  2.98s/it][Succeeded / Failed / Skipped / Total] 184 / 55 / 5 / 244:  24%|██▍       | 244/1000 [12:08<37:35,  2.98s/it][Succeeded / Failed / Skipped / Total] 185 / 55 / 5 / 245:  24%|██▍       | 245/1000 [12:09<37:27,  2.98s/it][Succeeded / Failed / Skipped / Total] 185 / 55 / 5 / 245:  25%|██▍       | 246/1000 [12:09<37:15,  2.96s/it][Succeeded / Failed / Skipped / Total] 186 / 55 / 5 / 246:  25%|██▍       | 246/1000 [12:09<37:15,  2.96s/it][Succeeded / Failed / Skipped / Total] 187 / 55 / 5 / 247:  25%|██▍       | 247/1000 [12:11<37:09,  2.96s/it][Succeeded / Failed / Skipped / Total] 187 / 55 / 5 / 247:  25%|██▍       | 248/1000 [12:11<36:58,  2.95s/it]Redirect config . --> Returns a new RestAssuredConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[blackencyctor]] ( RedirectConfig [[denwektproweightget]] ) { notNull ( [[denwektproweightget]] , "Redirect config" ) ; return new RestAssuredConfig ( [[denwektproweightget]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 242 ---------------------------------------------
Gets the ObjectMapper config object . --> Mobovieamappedport implementation --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[classshobovieamappedport]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[classshobovieamappedport]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 243 ---------------------------------------------
Get an instance of RestAssured mock config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig [[classkapassprofygged]] ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 244 ---------------------------------------------
Get an RestAssuredMockMvc config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig xmlConfig ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[eucalyptusxmlfei]] ( XmlConfig xmlConfig ) { notNull ( [[eucalyptusxmlfei]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[eucalyptusxmlfei]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 245 ---------------------------------------------
Get a mock config from the json config . --> Create a RestAssuredMock falls --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig jsonConfig ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[brookepenalfoe]] ( JsonConfig jsonConfig ) { notNull ( [[brookepenalfoe]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[brookepenalfoe]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 246 ---------------------------------------------
Returns an RestAssuredMock obtained config . --> Get an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[headerConfig]] ( HeaderConfig headerConfig ) { notNull ( [[headerConfig]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[headerConfig]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[backoffeg]] ( HeaderConfig headerConfig ) { notNull ( [[backoffeg]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[backoffeg]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 247 ---------------------------------------------
Gets the mock ZK config . --> Get an instance of RestAss SMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[asyncConfig]] ( AsyncConfig asyncConfig ) { notNull ( [[asyncConfig]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[asyncConfig]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[ajncoeonthiг]] ( AsyncConfig asyncConfig ) { notNull ( [[ajncoeonthiг]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[ajncoeonthiг]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 248 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 188 / 55 / 5 / 248:  25%|██▍       | 248/1000 [12:11<36:58,  2.95s/it][Succeeded / Failed / Skipped / Total] 189 / 55 / 5 / 249:  25%|██▍       | 249/1000 [12:11<36:46,  2.94s/it][Succeeded / Failed / Skipped / Total] 189 / 55 / 5 / 249:  25%|██▌       | 250/1000 [12:12<36:37,  2.93s/it][Succeeded / Failed / Skipped / Total] 190 / 55 / 5 / 250:  25%|██▌       | 250/1000 [12:12<36:37,  2.93s/it][Succeeded / Failed / Skipped / Total] 191 / 55 / 5 / 251:  25%|██▌       | 251/1000 [12:15<36:35,  2.93s/it][Succeeded / Failed / Skipped / Total] 191 / 55 / 5 / 251:  25%|██▌       | 252/1000 [12:17<36:29,  2.93s/it][Succeeded / Failed / Skipped / Total] 192 / 55 / 5 / 252:  25%|██▌       | 252/1000 [12:17<36:29,  2.93s/it][Succeeded / Failed / Skipped / Total] 193 / 55 / 5 / 253:  25%|██▌       | 253/1000 [12:18<36:19,  2.92s/it][Succeeded / Failed / Skipped / Total] 193 / 55 / 5 / 253:  25%|██▌       | 254/1000 [12:19<36:12,  2.91s/it][Succeeded / Failed / Skipped / Total] 194 / 55 / 5 / 254:  25%|██▌       | 254/1000 [12:19<36:12,  2.91s/it][Succeeded / Failed / Skipped / Total] 195 / 55 / 5 / 255:  26%|██▌       | 255/1000 [12:20<36:03,  2.90s/it][Succeeded / Failed / Skipped / Total] 195 / 55 / 5 / 255:  26%|██▌       | 256/1000 [12:28<36:16,  2.93s/it]Gets the Elasticsearch mock config from the given config . --> Create a copy of this invocation object . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig encoderConfig ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[destcrmongist]] ( EncoderConfig encoderConfig ) { notNull ( [[destcrmongist]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[destcrmongist]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 249 ---------------------------------------------
Gets the local member config . --> Get a mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig [[sessionConfig]] ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[assemblyinfatog]] ( SessionConfig [[stateofhiɡ]] ) { notNull ( [[assemblyinfatog]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[assemblyinfatog]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 250 ---------------------------------------------
Create a RestAssuredMock config . --> Return a RestAssured mock matcher . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[flockmavorprogigh]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[flockmavorprogigh]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[flockmavorprogigh]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 251 ---------------------------------------------
Create an empty RestAssuredMock config . --> Create an instance of RestAssuredMock . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig multiPartConfig ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[3coretponfiag]] ( MultiPartConfig multiPartConfig ) { notNull ( [[3coretponfiag]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[3coretponfiag]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 252 ---------------------------------------------
Makes sure that all the hosts are included . --> Create a fresh certificateAuth settings --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[catchatworksrtnamingtype]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 253 ---------------------------------------------
Returns a copy of the given mock config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[paramConfig]] ( MockMvcParamConfig paramConfig ) { notNull ( [[paramConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[paramConfig]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[gamericocahigging]] ( MockMvcParamConfig paramConfig ) { notNull ( [[gamericocahigging]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[gamericocahigging]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 254 ---------------------------------------------
Returns a copy of the given matcher config . --> Method to call a JMX method --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig matcherConfig ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[callendverфga]] ( MatcherConfig matcherConfig ) { notNull ( [[callendverфga]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[callendverфga]] ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 255 ---------------------------------------------
Declare the namespaces . --> Declares global properties --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig declareNamespaces ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig declareNamespaces ( Map < String , String > [[propertiesplsterincoage]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[propertiesplsterincoage]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
[Succeeded / Failed / Skipped / Total] 196 / 55 / 5 / 256:  26%|██▌       | 256/1000 [12:28<36:16,  2.93s/it][Succeeded / Failed / Skipped / Total] 197 / 55 / 5 / 257:  26%|██▌       | 257/1000 [12:28<36:05,  2.91s/it][Succeeded / Failed / Skipped / Total] 197 / 55 / 5 / 257:  26%|██▌       | 258/1000 [12:29<35:54,  2.90s/it][Succeeded / Failed / Skipped / Total] 197 / 55 / 6 / 258:  26%|██▌       | 258/1000 [12:29<35:54,  2.90s/it][Succeeded / Failed / Skipped / Total] 198 / 55 / 6 / 259:  26%|██▌       | 259/1000 [12:32<35:53,  2.91s/it][Succeeded / Failed / Skipped / Total] 198 / 55 / 6 / 259:  26%|██▌       | 260/1000 [12:35<35:49,  2.90s/it][Succeeded / Failed / Skipped / Total] 198 / 56 / 6 / 260:  26%|██▌       | 260/1000 [12:35<35:49,  2.90s/it][Succeeded / Failed / Skipped / Total] 199 / 56 / 6 / 261:  26%|██▌       | 261/1000 [12:36<35:40,  2.90s/it][Succeeded / Failed / Skipped / Total] 199 / 56 / 6 / 261:  26%|██▌       | 262/1000 [12:36<35:31,  2.89s/it][Succeeded / Failed / Skipped / Total] 200 / 56 / 6 / 262:  26%|██▌       | 262/1000 [12:36<35:31,  2.89s/it][Succeeded / Failed / Skipped / Total] 201 / 56 / 6 / 263:  26%|██▋       | 263/1000 [12:36<35:20,  2.88s/it][Succeeded / Failed / Skipped / Total] 201 / 56 / 6 / 263:  26%|██▋       | 264/1000 [12:38<35:15,  2.87s/it]--------------------------------------------- Result 256 ---------------------------------------------
Creates a NT credentials for a machine . --> Add a NTCredentials --> Socre: 1.0

[[[[Adv]]]]: public void ntlm ( String host , int [[port]] , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int [[base]] , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[base]] ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 257 ---------------------------------------------
declared namespace . --> called by prefix --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[calledtermtura]] ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > [[expressionunternts]] = new HashMap < String , String > ( declaredNamespaces ) ; [[expressionunternts]] . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[expressionunternts]] , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 258 ---------------------------------------------
Resets the request --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void reset ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 259 ---------------------------------------------
Creates a new basic . --> Perform a call --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String host , int port , String user , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[call]] ( String host , int port , String user , String [[act]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , [[act]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 260 ---------------------------------------------
Adds a header . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String name , String [[value]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[driver]] ( String name , String [[piece]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[piece]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 261 ---------------------------------------------
Sets response header . --> Sets response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[creatoreeed]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 262 ---------------------------------------------
Sets the proxy . --> Show a HttpHost --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String host , int [[port]] , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , [[port]] , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[hitvw]] ( String host , int [[mount]] , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , [[mount]] , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 263 ---------------------------------------------
Sets the headers for this request . --> visualstreambots of teel --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object key : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( key ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[visualstreambots]] ( Map < ? , ? > [[teel]] ) { this . [[windowsconmontsubjecter]] . clear ( ) ; if ( [[teel]] == null ) return ; for ( Object key : [[teel]] . keySet ( ) ) { Object val = [[teel]] . get ( key ) ; if ( val == null ) continue ; this . [[windowsconmontsubjecter]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 264 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 202 / 56 / 6 / 264:  26%|██▋       | 264/1000 [12:38<35:15,  2.87s/it][Succeeded / Failed / Skipped / Total] 203 / 56 / 6 / 265:  26%|██▋       | 265/1000 [12:47<35:29,  2.90s/it][Succeeded / Failed / Skipped / Total] 203 / 56 / 6 / 265:  27%|██▋       | 266/1000 [12:49<35:23,  2.89s/it][Succeeded / Failed / Skipped / Total] 203 / 57 / 6 / 266:  27%|██▋       | 266/1000 [12:49<35:23,  2.89s/it][Succeeded / Failed / Skipped / Total] 203 / 57 / 6 / 266:  27%|██▋       | 267/1000 [12:51<35:17,  2.89s/it][Succeeded / Failed / Skipped / Total] 204 / 57 / 6 / 267:  27%|██▋       | 267/1000 [12:51<35:17,  2.89s/it][Succeeded / Failed / Skipped / Total] 204 / 57 / 6 / 267:  27%|██▋       | 268/1000 [12:54<35:15,  2.89s/it][Succeeded / Failed / Skipped / Total] 205 / 57 / 6 / 268:  27%|██▋       | 268/1000 [12:54<35:15,  2.89s/it][Succeeded / Failed / Skipped / Total] 205 / 57 / 6 / 268:  27%|██▋       | 269/1000 [12:56<35:09,  2.89s/it][Succeeded / Failed / Skipped / Total] 205 / 58 / 6 / 269:  27%|██▋       | 269/1000 [12:56<35:09,  2.89s/it][Succeeded / Failed / Skipped / Total] 205 / 58 / 6 / 269:  27%|██▋       | 270/1000 [12:56<34:59,  2.88s/it][Succeeded / Failed / Skipped / Total] 205 / 59 / 6 / 270:  27%|██▋       | 270/1000 [12:56<34:59,  2.88s/it][Succeeded / Failed / Skipped / Total] 205 / 59 / 6 / 270:  27%|██▋       | 271/1000 [12:56<34:49,  2.87s/it][Succeeded / Failed / Skipped / Total] 206 / 59 / 6 / 271:  27%|██▋       | 271/1000 [12:56<34:49,  2.87s/it][Succeeded / Failed / Skipped / Total] 206 / 59 / 6 / 271:  27%|██▋       | 272/1000 [12:59<34:45,  2.86s/it][Succeeded / Failed / Skipped / Total] 206 / 60 / 6 / 272:  27%|██▋       | 272/1000 [12:59<34:45,  2.86s/it][Succeeded / Failed / Skipped / Total] 206 / 60 / 6 / 272:  27%|██▋       | 273/1000 [13:03<34:46,  2.87s/it]Build the response . --> Call this status code . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[call]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 265 ---------------------------------------------
Request with specified method . --> get demand --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String [[method]] , boolean hasBody , Closure [[configClosure]] ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[method]] , this . defaultContentType , hasBody , [[configClosure]] ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[demand]] ( String [[count]] , boolean hasBody , Closure [[canfigesrasul]] ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[count]] , this . defaultContentType , hasBody , [[canfigesrasul]] ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 266 ---------------------------------------------
Sets control name . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String [[controlName]] ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String [[statehouse]] ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 267 ---------------------------------------------
Matches if the selected date matches the given expiry date matcher . --> DetailedCookieMatcher espigateper --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[espigateper]] ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 268 ---------------------------------------------
Gets a matcher that matches the given valueMatcher . --> Matches if the pool is scrolledth --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[pool]] ( Matcher < ? super String > [[notnatth]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[notnatth]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Returns a comment that matches this node . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[list]] ( Matcher < ? super String > [[groupmalalt]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[groupmalalt]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Matches the given pathMatcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[label]] ( Matcher < ? super String > [[windowlets]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[windowlets]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Matches a cookie by a given domain matcher . --> Returns a family that matches the scopelayt --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[family]] ( Matcher < ? super String > [[scopelayt]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[scopelayt]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Create a new Header with additional headers --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers [[headers]] ( Header header , Header ... [[additionalHeaders]] ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( headerList , [[additionalHeaders]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[binses]] ( Header header , Header ... [[aheadsplaces]] ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( [[aheadsplaces]] != null ) { Collections . addAll ( headerList , [[aheadsplaces]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 273 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 207 / 60 / 6 / 273:  27%|██▋       | 273/1000 [13:03<34:46,  2.87s/it][Succeeded / Failed / Skipped / Total] 207 / 60 / 6 / 273:  27%|██▋       | 274/1000 [13:06<34:44,  2.87s/it][Succeeded / Failed / Skipped / Total] 208 / 60 / 6 / 274:  27%|██▋       | 274/1000 [13:06<34:44,  2.87s/it][Succeeded / Failed / Skipped / Total] 208 / 60 / 6 / 274:  28%|██▊       | 275/1000 [13:10<34:43,  2.87s/it][Succeeded / Failed / Skipped / Total] 209 / 60 / 6 / 275:  28%|██▊       | 275/1000 [13:10<34:43,  2.87s/it][Succeeded / Failed / Skipped / Total] 209 / 60 / 6 / 275:  28%|██▊       | 276/1000 [13:15<34:45,  2.88s/it][Succeeded / Failed / Skipped / Total] 210 / 60 / 6 / 276:  28%|██▊       | 276/1000 [13:15<34:45,  2.88s/it][Succeeded / Failed / Skipped / Total] 210 / 60 / 6 / 276:  28%|██▊       | 277/1000 [13:18<34:43,  2.88s/it][Succeeded / Failed / Skipped / Total] 211 / 60 / 6 / 277:  28%|██▊       | 277/1000 [13:18<34:43,  2.88s/it][Succeeded / Failed / Skipped / Total] 211 / 60 / 6 / 277:  28%|██▊       | 278/1000 [13:18<34:33,  2.87s/it][Succeeded / Failed / Skipped / Total] 212 / 60 / 6 / 278:  28%|██▊       | 278/1000 [13:18<34:33,  2.87s/it][Succeeded / Failed / Skipped / Total] 212 / 60 / 6 / 278:  28%|██▊       | 279/1000 [13:19<34:24,  2.86s/it][Succeeded / Failed / Skipped / Total] 213 / 60 / 6 / 279:  28%|██▊       | 279/1000 [13:19<34:24,  2.86s/it][Succeeded / Failed / Skipped / Total] 213 / 60 / 6 / 279:  28%|██▊       | 280/1000 [13:20<34:17,  2.86s/it][Succeeded / Failed / Skipped / Total] 213 / 61 / 6 / 280:  28%|██▊       | 280/1000 [13:20<34:17,  2.86s/it][Succeeded / Failed / Skipped / Total] 213 / 61 / 6 / 280:  28%|██▊       | 281/1000 [13:20<34:08,  2.85s/it][Succeeded / Failed / Skipped / Total] 213 / 62 / 6 / 281:  28%|██▊       | 281/1000 [13:20<34:08,  2.85s/it][Succeeded / Failed / Skipped / Total] 213 / 62 / 6 / 281:  28%|██▊       | 282/1000 [13:21<34:01,  2.84s/it][Succeeded / Failed / Skipped / Total] 214 / 62 / 6 / 282:  28%|██▊       | 282/1000 [13:21<34:01,  2.84s/it][Succeeded / Failed / Skipped / Total] 214 / 62 / 6 / 282:  28%|██▊       | 283/1000 [13:24<33:58,  2.84s/it]Returns a Matcher that matches the given versionMatcher . --> Helper method to retrieve a DetailedCookieMatcher for a given renditiontraclass --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > [[renditiontraclass]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[renditiontraclass]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Create a Proxy specification with the given host . --> Create a new ProxySpecification --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification withHost ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification withHost ( String [[address]] ) { return new ProxySpecification ( [[address]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 275 ---------------------------------------------
Returns a DetailedMatcher for the secured property . --> convertible to DetailedCookieMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[convertible]] ( Matcher < ? super Boolean > [[deepkatrer]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[deepkatrer]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 276 ---------------------------------------------
Returns the default parser type . --> dynamicgassablej method --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[dynamicgassablej]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[dynamicgassablej]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 277 ---------------------------------------------
Adds a expect header . --> Places an inwinview --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String [[expectedValue]] ) { spec . header ( [[headerName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[actheaderter]] ( String [[blasttitle]] , String [[inwinview]] ) { spec . header ( [[blasttitle]] , [[inwinview]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 278 ---------------------------------------------
Build LogConfig for debugging . --> commondestination method --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream printStream ) { return new LogConfig ( printStream , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[commondestination]] ( PrintStream printStream ) { return new LogConfig ( printStream , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 279 ---------------------------------------------
Returns a cached DetailedCookieMatcher for the given httpOnly matcher . --> DetailedCookieMatcher for this request --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[limaopf]] ( Matcher < ? super Boolean > [[requestop1tyr]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[requestop1tyr]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 280 ---------------------------------------------
Create a new JsonPathConfig . --> [[[FAILED]]]

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[statuselviewface]] ( NumberReturnType [[fieldelrouppost]] ) { return new JsonPathConfig ( [[statuselviewface]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 281 ---------------------------------------------
Convenience method for setting cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String cookieName , String [[expectedValue]] ) { spec . cookie ( cookieName , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String cookieName , String [[expectsrunuity]] ) { spec . cookie ( cookieName , [[expectsrunuity]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 282 ---------------------------------------------
Returns a DetailedMatcher that is backed by a given maxAge matcher . --> DetailedCookieMatcher for this process --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[superout]] ( Matcher < ? super Integer > [[rexfieldtetout]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[rexfieldtetout]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 283 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 215 / 62 / 6 / 283:  28%|██▊       | 283/1000 [13:24<33:58,  2.84s/it][Succeeded / Failed / Skipped / Total] 215 / 62 / 6 / 283:  28%|██▊       | 284/1000 [13:25<33:50,  2.84s/it][Succeeded / Failed / Skipped / Total] 216 / 62 / 6 / 284:  28%|██▊       | 284/1000 [13:25<33:50,  2.84s/it][Succeeded / Failed / Skipped / Total] 216 / 62 / 6 / 284:  28%|██▊       | 285/1000 [13:27<33:44,  2.83s/it][Succeeded / Failed / Skipped / Total] 217 / 62 / 6 / 285:  28%|██▊       | 285/1000 [13:27<33:44,  2.83s/it][Succeeded / Failed / Skipped / Total] 217 / 62 / 6 / 285:  29%|██▊       | 286/1000 [13:28<33:37,  2.83s/it][Succeeded / Failed / Skipped / Total] 218 / 62 / 6 / 286:  29%|██▊       | 286/1000 [13:28<33:37,  2.83s/it][Succeeded / Failed / Skipped / Total] 218 / 62 / 6 / 286:  29%|██▊       | 287/1000 [13:29<33:31,  2.82s/it][Succeeded / Failed / Skipped / Total] 219 / 62 / 6 / 287:  29%|██▊       | 287/1000 [13:29<33:31,  2.82s/it][Succeeded / Failed / Skipped / Total] 219 / 62 / 6 / 287:  29%|██▉       | 288/1000 [13:35<33:36,  2.83s/it][Succeeded / Failed / Skipped / Total] 220 / 62 / 6 / 288:  29%|██▉       | 288/1000 [13:35<33:36,  2.83s/it][Succeeded / Failed / Skipped / Total] 220 / 62 / 6 / 288:  29%|██▉       | 289/1000 [13:36<33:29,  2.83s/it][Succeeded / Failed / Skipped / Total] 221 / 62 / 6 / 289:  29%|██▉       | 289/1000 [13:36<33:29,  2.83s/it][Succeeded / Failed / Skipped / Total] 221 / 62 / 6 / 289:  29%|██▉       | 290/1000 [13:39<33:25,  2.82s/it][Succeeded / Failed / Skipped / Total] 222 / 62 / 6 / 290:  29%|██▉       | 290/1000 [13:39<33:25,  2.82s/it][Succeeded / Failed / Skipped / Total] 222 / 62 / 6 / 290:  29%|██▉       | 291/1000 [13:40<33:19,  2.82s/it][Succeeded / Failed / Skipped / Total] 223 / 62 / 6 / 291:  29%|██▉       | 291/1000 [13:40<33:19,  2.82s/it][Succeeded / Failed / Skipped / Total] 223 / 62 / 6 / 291:  29%|██▉       | 292/1000 [13:40<33:10,  2.81s/it][Succeeded / Failed / Skipped / Total] 224 / 62 / 6 / 292:  29%|██▉       | 292/1000 [13:40<33:10,  2.81s/it][Succeeded / Failed / Skipped / Total] 224 / 62 / 6 / 292:  29%|██▉       | 293/1000 [13:47<33:16,  2.82s/it]Sets the header for the Response spec . --> Registers dates picker --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[reportsetet]] ( String [[datescope]] , Matcher < String > [[plannedthusratters]] ) { spec . header ( [[datescope]] , [[plannedthusratters]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 284 ---------------------------------------------
Adds an attribute to the request . --> Adds an addAttribute . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String attributeName , Object [[attributeValue]] ) { spec . attribute ( attributeName , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String attributeName , Object [[associatedworksre]] ) { spec . attribute ( attributeName , [[associatedworksre]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 285 ---------------------------------------------
Adds a header value to the request . --> Log extra elementsport . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String headerName , String headerValue ) { spec . header ( headerName , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[extraheadport]] ( String headerName , String headerValue ) { spec . header ( headerName , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 286 ---------------------------------------------
Returns a copy of the MultiPartConfig object . --> dynamic partConfig --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[dynamicboundson]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[dynamicboundson]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 287 ---------------------------------------------
Adds result handlers to the request . --> Adds the resultHandlers to the spec . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addedincearungigen]] ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 288 ---------------------------------------------
Enables or disabled logging . --> Get configuration file system . --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail [[logDetail]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[logDetail]] , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[ablelagbyactiveuevis0passcesframevaandovadentcoby]] ( LogDetail [[dogthetech]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[dogthetech]] , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 289 ---------------------------------------------
Http multipart mode . --> HttpMultipartMode limaunlosicortkode --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig httpMultipartMode ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig httpMultipartMode ( HttpMultipartMode [[limaunlosicortkode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 290 ---------------------------------------------
Add additional parameters . --> Create a new HttpClientConfig --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > [[limatrgatechals]] ) { notNull ( [[limatrgatechals]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[limatrgatechals]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[falsely]]" == "[[falsely]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 291 ---------------------------------------------
Adds multiple part control name and content . --> Sets an unexpected imeable --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String [[controlName]] , String contentBody , String [[mimeType]] ) { spec . multiPart ( [[controlName]] , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[extravalpryata]] ( String [[controllercommand]] , String contentBody , String [[imeable]] ) { spec . multiPart ( [[controllercommand]] , [[imeable]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 292 ---------------------------------------------
Gets the int . --> wire wire a string --> Socre: 1.0

[[[[Adv]]]]: public int getInt ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int getInt ( String [[wire]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 293 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 225 / 62 / 6 / 293:  29%|██▉       | 293/1000 [13:47<33:16,  2.82s/it][Succeeded / Failed / Skipped / Total] 225 / 62 / 6 / 293:  29%|██▉       | 294/1000 [13:48<33:09,  2.82s/it][Succeeded / Failed / Skipped / Total] 225 / 63 / 6 / 294:  29%|██▉       | 294/1000 [13:48<33:09,  2.82s/it][Succeeded / Failed / Skipped / Total] 225 / 63 / 6 / 294:  30%|██▉       | 295/1000 [13:49<33:03,  2.81s/it][Succeeded / Failed / Skipped / Total] 226 / 63 / 6 / 295:  30%|██▉       | 295/1000 [13:49<33:03,  2.81s/it][Succeeded / Failed / Skipped / Total] 226 / 63 / 6 / 295:  30%|██▉       | 296/1000 [13:51<32:57,  2.81s/it][Succeeded / Failed / Skipped / Total] 227 / 63 / 6 / 296:  30%|██▉       | 296/1000 [13:51<32:57,  2.81s/it][Succeeded / Failed / Skipped / Total] 227 / 63 / 6 / 296:  30%|██▉       | 297/1000 [13:51<32:48,  2.80s/it][Succeeded / Failed / Skipped / Total] 228 / 63 / 6 / 297:  30%|██▉       | 297/1000 [13:51<32:48,  2.80s/it][Succeeded / Failed / Skipped / Total] 228 / 63 / 6 / 297:  30%|██▉       | 298/1000 [13:55<32:47,  2.80s/it][Succeeded / Failed / Skipped / Total] 229 / 63 / 6 / 298:  30%|██▉       | 298/1000 [13:55<32:47,  2.80s/it][Succeeded / Failed / Skipped / Total] 229 / 63 / 6 / 298:  30%|██▉       | 299/1000 [13:57<32:44,  2.80s/it][Succeeded / Failed / Skipped / Total] 229 / 64 / 6 / 299:  30%|██▉       | 299/1000 [13:57<32:44,  2.80s/it][Succeeded / Failed / Skipped / Total] 229 / 64 / 6 / 299:  30%|███       | 300/1000 [14:00<32:40,  2.80s/it][Succeeded / Failed / Skipped / Total] 230 / 64 / 6 / 300:  30%|███       | 300/1000 [14:00<32:40,  2.80s/it][Succeeded / Failed / Skipped / Total] 231 / 64 / 6 / 301:  30%|███       | 301/1000 [14:00<32:30,  2.79s/it][Succeeded / Failed / Skipped / Total] 231 / 64 / 6 / 301:  30%|███       | 302/1000 [14:06<32:35,  2.80s/it][Succeeded / Failed / Skipped / Total] 232 / 64 / 6 / 302:  30%|███       | 302/1000 [14:06<32:35,  2.80s/it][Succeeded / Failed / Skipped / Total] 233 / 64 / 6 / 303:  30%|███       | 303/1000 [14:07<32:30,  2.80s/it][Succeeded / Failed / Skipped / Total] 233 / 64 / 6 / 303:  30%|███       | 304/1000 [14:07<32:21,  2.79s/it]Gets a value from a JSON string . --> Return back from JSON --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[back]] > [[back]] get ( String path ) { final JSONAssertion [[colesgamoutin]] = createJsonAssertion ( path , params ) ; final Object [[sassing]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[back]] ) [[colesgamoutin]] . getResult ( [[sassing]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 294 ---------------------------------------------
Sets the given parameter to the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[statuscanceunifusgs]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[statuscanceunifusgs]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 295 ---------------------------------------------
Returns the byte value of the specified path . --> store abayle --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[storebayle]] ( String [[v]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 296 ---------------------------------------------
Returns the short of the given path . --> Return data -ult with given string --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[datault]] ( String [[point]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 297 ---------------------------------------------
Set a new HttpClientFactory --> This method initializes HttpClientConfig --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[waterfallstiinkme]] ( HttpClientFactory [[mesfactiverent]] ) { return new HttpClientConfig ( [[waterfallstiinkme]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 298 ---------------------------------------------
Create an HTTP request . --> Synchronously generatetiappep h --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI [[uri]] , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[type]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[generatetiappepquest]] ( URI [[calendarn]] , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[c]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 299 ---------------------------------------------
Get double . --> [[[FAILED]]]

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object value = get ( [[path]] ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[forempace]] ( String [[art]] ) { final Object value = get ( [[art]] ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 300 ---------------------------------------------
Retrieves the value of the specified path . --> region seeroomp function --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[seeroomp]] ( String [[band]] ) { final Object [[path]] = get ( [[band]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 301 ---------------------------------------------
Get long . --> Return supertem by string name --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[supertem]] ( String [[course]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 302 ---------------------------------------------
Returns an object from the specified path . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object object = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[a]] > [[a]] getObject ( String path , Class < [[a]] > objectType ) { Object object = getFromPath ( path , "[[otherwise]]" != "[[otherwise]]" ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 303 ---------------------------------------------
Adds a parameter . --> Reduces query parameters --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[reduceparaм]] ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
[Succeeded / Failed / Skipped / Total] 233 / 65 / 6 / 304:  30%|███       | 304/1000 [14:07<32:21,  2.79s/it][Succeeded / Failed / Skipped / Total] 234 / 65 / 6 / 305:  30%|███       | 305/1000 [14:10<32:18,  2.79s/it][Succeeded / Failed / Skipped / Total] 234 / 65 / 6 / 305:  31%|███       | 306/1000 [14:15<32:19,  2.79s/it][Succeeded / Failed / Skipped / Total] 235 / 65 / 6 / 306:  31%|███       | 306/1000 [14:15<32:19,  2.79s/it][Succeeded / Failed / Skipped / Total] 236 / 65 / 6 / 307:  31%|███       | 307/1000 [14:15<32:11,  2.79s/it][Succeeded / Failed / Skipped / Total] 236 / 65 / 6 / 307:  31%|███       | 308/1000 [14:17<32:05,  2.78s/it][Succeeded / Failed / Skipped / Total] 237 / 65 / 6 / 308:  31%|███       | 308/1000 [14:17<32:05,  2.78s/it][Succeeded / Failed / Skipped / Total] 238 / 65 / 6 / 309:  31%|███       | 309/1000 [14:22<32:09,  2.79s/it][Succeeded / Failed / Skipped / Total] 238 / 65 / 6 / 309:  31%|███       | 310/1000 [14:23<32:02,  2.79s/it][Succeeded / Failed / Skipped / Total] 238 / 66 / 6 / 310:  31%|███       | 310/1000 [14:23<32:02,  2.79s/it][Succeeded / Failed / Skipped / Total] 239 / 66 / 6 / 311:  31%|███       | 311/1000 [14:25<31:58,  2.78s/it][Succeeded / Failed / Skipped / Total] 239 / 66 / 6 / 311:  31%|███       | 312/1000 [14:27<31:53,  2.78s/it][Succeeded / Failed / Skipped / Total] 240 / 66 / 6 / 312:  31%|███       | 312/1000 [14:27<31:53,  2.78s/it]--------------------------------------------- Result 304 ---------------------------------------------
Gets the map mapped to the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public < K , V > Map < K , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > [[superchaline]] ( String [[graph]] ) { return get ( [[graph]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 305 ---------------------------------------------
Sets the body for the object . --> Set bagac body --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object object , ObjectMapper [[mapper]] ) { spec . body ( object , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[bagac]] ( Object object , ObjectMapper [[centerline]] ) { spec . body ( object , [[centerline]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 306 ---------------------------------------------
Add cookie . --> endacointease --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[key]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[endacointease]] ( String [[price]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[price]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 307 ---------------------------------------------
Create a mock parameter configuration with parameters set parameters . --> Creates a new instance of Mock --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy [[reportstrotorues]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[reportstrotorues]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[subject]]" == "[[subject]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 308 ---------------------------------------------
Add a parameter . --> Set custom parameters --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[exapaml]] ( String [[customname]] , Object ... [[flagtowneles]] ) { spec . param ( [[customname]] , [[flagtowneles]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 309 ---------------------------------------------
Convert a key to a constant string . --> Simple method for unit test --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[typeocfeorslikeofchander]] ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 310 ---------------------------------------------
Index the bindings . --> [[[FAILED]]]

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[anchor]] ( ) { for ( Binding < ? > [[bound]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[bound]] . getKey ( ) . getTypeLiteral ( ) , [[bound]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 311 ---------------------------------------------
Gets a list from the path . --> logobox method --> Socre: 1.0

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[original]] = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[original]] != null ) { for ( T t : [[original]] ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[logobox]] ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[additional]] = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[additional]] != null ) { for ( T t : [[additional]] ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 312 ---------------------------------------------
Removes the backing map for the given key and source . --> enerconxtialovst any --> Socre: 1.0

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource [[keyAndSource]] : keysAndSources ) { Multiset < Object > set = backingMap . get ( [[keyAndSource]] . key ) ; if ( set != null ) { set . remove ( [[keyAndSource]] . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( [[keyAndSource]] . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[enerconxtialovsticty]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource [[bookenherck]] : keysAndSources ) { Multiset < Object > set = backingMap . get ( [[bookenherck]] . key ) ; if ( set != null ) { set . remove ( [[bookenherck]] . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( [[bookenherck]] . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 313 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 240 / 67 / 6 / 313:  31%|███▏      | 313/1000 [14:28<31:46,  2.78s/it][Succeeded / Failed / Skipped / Total] 240 / 67 / 6 / 313:  31%|███▏      | 314/1000 [14:31<31:43,  2.78s/it][Succeeded / Failed / Skipped / Total] 240 / 68 / 6 / 314:  31%|███▏      | 314/1000 [14:31<31:43,  2.78s/it][Succeeded / Failed / Skipped / Total] 240 / 69 / 6 / 315:  32%|███▏      | 315/1000 [14:32<31:36,  2.77s/it][Succeeded / Failed / Skipped / Total] 240 / 69 / 6 / 315:  32%|███▏      | 316/1000 [14:39<31:43,  2.78s/it][Succeeded / Failed / Skipped / Total] 240 / 70 / 6 / 316:  32%|███▏      | 316/1000 [14:39<31:43,  2.78s/it][Succeeded / Failed / Skipped / Total] 240 / 71 / 6 / 317:  32%|███▏      | 317/1000 [14:41<31:39,  2.78s/it][Succeeded / Failed / Skipped / Total] 240 / 71 / 6 / 317:  32%|███▏      | 318/1000 [14:47<31:44,  2.79s/it][Succeeded / Failed / Skipped / Total] 241 / 71 / 6 / 318:  32%|███▏      | 318/1000 [14:47<31:44,  2.79s/it][Succeeded / Failed / Skipped / Total] 242 / 71 / 6 / 319:  32%|███▏      | 319/1000 [14:50<31:40,  2.79s/it][Succeeded / Failed / Skipped / Total] 242 / 71 / 6 / 319:  32%|███▏      | 320/1000 [14:52<31:35,  2.79s/it][Succeeded / Failed / Skipped / Total] 243 / 71 / 6 / 320:  32%|███▏      | 320/1000 [14:52<31:35,  2.79s/it][Succeeded / Failed / Skipped / Total] 243 / 72 / 6 / 321:  32%|███▏      | 321/1000 [14:53<31:29,  2.78s/it][Succeeded / Failed / Skipped / Total] 243 / 72 / 6 / 321:  32%|███▏      | 322/1000 [14:53<31:21,  2.77s/it]log response to if matches . --> [[[FAILED]]]

[[[[Adv]]]]: public static Filter [[logResponseToIfMatches]] ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter [[forestrupourtetgofsusched]] ( PrintStream stream , Matcher < Integer > [[answerra]] ) { return new ResponseLoggingFilter ( stream , [[answerra]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 314 ---------------------------------------------
Create a new Cookies with the given cookies . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > [[cookieList]] = new LinkedList < Cookie > ( ) ; [[cookieList]] . add ( cookie ) ; Collections . addAll ( [[cookieList]] , additionalCookies ) ; return new Cookies ( [[cookieList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > [[boundclass]] = new LinkedList < Cookie > ( ) ; [[boundclass]] . add ( cookie ) ; Collections . addAll ( [[boundclass]] , additionalCookies ) ; return new Cookies ( [[boundclass]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 315 ---------------------------------------------
Remove a binding . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[doaraisednetgendan]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 316 ---------------------------------------------
Get the dependencies of the binding . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[drawristintcdearendencies]] ( BindingImpl < ? > [[drawing]] ) { if ( [[drawing]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[drawing]] ) . getInternalDependencies ( ) ; } else if ( [[drawing]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[drawing]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 317 ---------------------------------------------
Create an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[ErrorsException]] { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[charactersconcer]] { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 318 ---------------------------------------------
Returns the provider type . --> Return a client dispatcher --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[clientflag]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 319 ---------------------------------------------
Binds the Logger logger . --> Endocarel --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl [[injector]] ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; [[injector]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( [[injector]] , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[endocarel]] ( InjectorImpl [[enfecton]] ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; [[enfecton]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( [[enfecton]] , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 320 ---------------------------------------------
Initialize the delegate . --> Helper method for earlyeratedautt --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[earlyeratedautt]] ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 321 ---------------------------------------------
Checks if is overrides . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[endvertin]] ( Method [[black]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
[Succeeded / Failed / Skipped / Total] 244 / 72 / 6 / 322:  32%|███▏      | 322/1000 [14:53<31:21,  2.77s/it][Succeeded / Failed / Skipped / Total] 244 / 73 / 6 / 323:  32%|███▏      | 323/1000 [14:54<31:15,  2.77s/it][Succeeded / Failed / Skipped / Total] 244 / 73 / 6 / 323:  32%|███▏      | 324/1000 [14:58<31:14,  2.77s/it][Succeeded / Failed / Skipped / Total] 245 / 73 / 6 / 324:  32%|███▏      | 324/1000 [14:58<31:14,  2.77s/it][Succeeded / Failed / Skipped / Total] 246 / 73 / 6 / 325:  32%|███▎      | 325/1000 [14:59<31:08,  2.77s/it][Succeeded / Failed / Skipped / Total] 246 / 73 / 6 / 325:  33%|███▎      | 326/1000 [15:06<31:14,  2.78s/it][Succeeded / Failed / Skipped / Total] 247 / 73 / 6 / 326:  33%|███▎      | 326/1000 [15:06<31:14,  2.78s/it][Succeeded / Failed / Skipped / Total] 248 / 73 / 6 / 327:  33%|███▎      | 327/1000 [15:10<31:13,  2.78s/it][Succeeded / Failed / Skipped / Total] 248 / 73 / 6 / 327:  33%|███▎      | 328/1000 [15:11<31:06,  2.78s/it][Succeeded / Failed / Skipped / Total] 248 / 74 / 6 / 328:  33%|███▎      | 328/1000 [15:11<31:06,  2.78s/it]--------------------------------------------- Result 322 ---------------------------------------------
Returns an array of all the known parameters . --> keep the behaviors --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext [[context]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] [[parameters]] = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[keepet]] ( InternalContext [[environment]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] [[behaviors]] = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 323 ---------------------------------------------
Binds the injector . --> [[[FAILED]]]

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > [[key]] = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Injector > ( injector , [[key]] , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[chaininldator]] ( InjectorImpl injector ) { Key < Injector > [[q]] = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( [[q]] , new ProviderInstanceBindingImpl < Injector > ( injector , [[q]] , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 324 ---------------------------------------------
PreparesBuiltInConverters . --> prepare the metrics inConverters --> Socre: 1.0

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[afterltf]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 325 ---------------------------------------------
Resolve all types . --> Resolve all flags --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int t = 0 ; t < [[types]] . length ; t ++ ) { [[result]] [ t ] = resolve ( [[types]] [ t ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] [[flags]] ) { TypeLiteral < ? > [ ] [[date]] = new TypeLiteral < ? > [ [[flags]] . length ] ; for ( int t = 0 ; t < [[flags]] . length ; t ++ ) { [[date]] [ t ] = resolve ( [[flags]] [ t ] ) ; } return ImmutableList . copyOf ( [[date]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 326 ---------------------------------------------
Request injection for injection . --> Handles a binding request --> Socre: 1.0

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[provisionCallback]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[theualbaload]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 327 ---------------------------------------------
Returns the canonical class loader . --> Convert a stylemountered stylemountered stylemountered --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[entourageulate]] ( ClassLoader [[stylemountered]] ) { return [[stylemountered]] != null ? [[stylemountered]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 328 ---------------------------------------------
Cleans up the dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean [[bindingFailed]] = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint [[ip]] = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[fix]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean [[compliancefup]] = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint [[ic]] = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 329 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 248 / 75 / 6 / 329:  33%|███▎      | 329/1000 [15:12<31:01,  2.77s/it][Succeeded / Failed / Skipped / Total] 248 / 75 / 6 / 329:  33%|███▎      | 330/1000 [15:13<30:54,  2.77s/it][Succeeded / Failed / Skipped / Total] 248 / 76 / 6 / 330:  33%|███▎      | 330/1000 [15:13<30:54,  2.77s/it][Succeeded / Failed / Skipped / Total] 249 / 76 / 6 / 331:  33%|███▎      | 331/1000 [15:18<30:55,  2.77s/it][Succeeded / Failed / Skipped / Total] 249 / 76 / 6 / 331:  33%|███▎      | 332/1000 [15:18<30:48,  2.77s/it][Succeeded / Failed / Skipped / Total] 250 / 76 / 6 / 332:  33%|███▎      | 332/1000 [15:18<30:48,  2.77s/it][Succeeded / Failed / Skipped / Total] 250 / 77 / 6 / 333:  33%|███▎      | 333/1000 [15:21<30:45,  2.77s/it][Succeeded / Failed / Skipped / Total] 250 / 77 / 6 / 333:  33%|███▎      | 334/1000 [15:24<30:43,  2.77s/it][Succeeded / Failed / Skipped / Total] 251 / 77 / 6 / 334:  33%|███▎      | 334/1000 [15:24<30:43,  2.77s/it][Succeeded / Failed / Skipped / Total] 251 / 78 / 6 / 335:  34%|███▎      | 335/1000 [15:27<30:40,  2.77s/it][Succeeded / Failed / Skipped / Total] 251 / 78 / 6 / 335:  34%|███▎      | 336/1000 [15:30<30:39,  2.77s/it]Returns the annotation for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[startkingutted]] ( Key < ? > [[bye]] ) { return [[bye]] . getAnnotation ( ) == null ? [[bye]] : Key . get ( [[bye]] . getTypeLiteral ( ) , [[bye]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 330 ---------------------------------------------
Returns true if the given member has already been modified . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors [[errors]] ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( [[errors]] , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors [[fails]] ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( [[fails]] , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 331 ---------------------------------------------
Create a new instance of the given constructor . --> Creates a new newInstance --> Socre: 1.0

[[[[Adv]]]]: public T newInstance ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T newInstance ( Object [ ] [[afgy]] ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( [[afgy]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 332 ---------------------------------------------
Create a servlet request --> ServletRequest arvctypevet --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest [[servletRequest]] , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest [[arvctypevet]] , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 333 ---------------------------------------------
Generates an annotation for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[classes]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 334 ---------------------------------------------
Returns true if this class has the same version of the Cglib . --> Famestergetousccgulrb --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader [[classLoader]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[classLoader]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[hecamestergetousccgulrb]] ( ClassLoader [[personalhateer]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[personalhateer]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "[[fake]]" != "[[fake]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 335 ---------------------------------------------
Returns a canonical OR for a given type literal . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[canonicalizeForKey]] ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[parameterizedType]] = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[capitaldesurly]] ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[clientiatedfemme]] = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 336 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 252 / 78 / 6 / 336:  34%|███▎      | 336/1000 [15:30<30:39,  2.77s/it][Succeeded / Failed / Skipped / Total] 253 / 78 / 6 / 337:  34%|███▎      | 337/1000 [15:32<30:34,  2.77s/it][Succeeded / Failed / Skipped / Total] 253 / 78 / 6 / 337:  34%|███▍      | 338/1000 [15:44<30:49,  2.79s/it][Succeeded / Failed / Skipped / Total] 254 / 78 / 6 / 338:  34%|███▍      | 338/1000 [15:44<30:49,  2.79s/it][Succeeded / Failed / Skipped / Total] 254 / 78 / 6 / 338:  34%|███▍      | 339/1000 [15:51<30:55,  2.81s/it][Succeeded / Failed / Skipped / Total] 255 / 78 / 6 / 339:  34%|███▍      | 339/1000 [15:51<30:55,  2.81s/it][Succeeded / Failed / Skipped / Total] 255 / 78 / 6 / 339:  34%|███▍      | 340/1000 [15:52<30:49,  2.80s/it][Succeeded / Failed / Skipped / Total] 256 / 78 / 6 / 340:  34%|███▍      | 340/1000 [15:52<30:49,  2.80s/it][Succeeded / Failed / Skipped / Total] 256 / 78 / 6 / 340:  34%|███▍      | 341/1000 [15:55<30:45,  2.80s/it][Succeeded / Failed / Skipped / Total] 256 / 79 / 6 / 341:  34%|███▍      | 341/1000 [15:55<30:45,  2.80s/it][Succeeded / Failed / Skipped / Total] 256 / 79 / 6 / 341:  34%|███▍      | 342/1000 [15:55<30:38,  2.79s/it][Succeeded / Failed / Skipped / Total] 256 / 80 / 6 / 342:  34%|███▍      | 342/1000 [15:55<30:38,  2.79s/it][Succeeded / Failed / Skipped / Total] 256 / 80 / 6 / 342:  34%|███▍      | 343/1000 [16:04<30:47,  2.81s/it]Validates all pending downgradeions . --> Perform a biliseinttainnowineclass --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[biliseinttainnowineclassures]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[application]] : pendingInjections ) { try { [[application]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 337 ---------------------------------------------
Normalizes the given path . --> Generate forensicmelk string --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int [[queryStart]] = path . indexOf ( ' ' ) ; String query = null ; if ( [[queryStart]] != - 1 ) { query = path . substring ( [[queryStart]] ) ; path = path . substring ( 0 , [[queryStart]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[dearied]] ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int [[forensicmelk]] = path . indexOf ( ' ' ) ; String query = null ; if ( [[forensicmelk]] != - 1 ) { query = path . substring ( [[forensicmelk]] ) ; path = path . substring ( 0 , [[forensicmelk]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 338 ---------------------------------------------
Checks if the given Annotation is likely to be reained at runtime . --> Method icd holderetaformderess --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[icdtimetaformderess]] ( Class < ? extends Annotation > [[runototchception]] ) { Retention [[attendance]] = [[runototchception]] . getAnnotation ( Retention . class ) ; return [[attendance]] != null && [[attendance]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 339 ---------------------------------------------
Initializes the delegate provider . --> alarmizedoutld --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[alarmizedreld]] ( Provider < T > [[canvas]] ) { checkState ( this . [[commit]] == null , "delegate already initialized" ) ; this . [[commit]] = checkNotNull ( [[canvas]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 340 ---------------------------------------------
Adds the direct type binding . --> endgiridebeedal --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[endgiridebstbeedal]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 341 ---------------------------------------------
Returns the name of the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[profilebar]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 342 ---------------------------------------------
Returns true if the given member is a public static member . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[parameterTypes]] ; if ( [[member]] instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[parameterTypes]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[members]] ) { if ( ! Modifier . isPublic ( [[members]] . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[allxiclasses]] ; if ( [[members]] instanceof Constructor ) { [[allxiclasses]] = ( ( Constructor ) [[members]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[members]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[allxiclasses]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[allxiclasses]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "[[contrary]]" == "[[contrary]]" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 343 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 256 / 81 / 6 / 343:  34%|███▍      | 343/1000 [16:04<30:47,  2.81s/it][Succeeded / Failed / Skipped / Total] 256 / 81 / 6 / 343:  34%|███▍      | 344/1000 [16:07<30:44,  2.81s/it][Succeeded / Failed / Skipped / Total] 256 / 82 / 6 / 344:  34%|███▍      | 344/1000 [16:07<30:44,  2.81s/it][Succeeded / Failed / Skipped / Total] 256 / 82 / 6 / 344:  34%|███▍      | 345/1000 [16:09<30:39,  2.81s/it][Succeeded / Failed / Skipped / Total] 257 / 82 / 6 / 345:  34%|███▍      | 345/1000 [16:09<30:39,  2.81s/it][Succeeded / Failed / Skipped / Total] 257 / 82 / 6 / 345:  35%|███▍      | 346/1000 [16:10<30:34,  2.80s/it][Succeeded / Failed / Skipped / Total] 257 / 83 / 6 / 346:  35%|███▍      | 346/1000 [16:10<30:34,  2.80s/it][Succeeded / Failed / Skipped / Total] 257 / 83 / 6 / 346:  35%|███▍      | 347/1000 [16:11<30:28,  2.80s/it][Succeeded / Failed / Skipped / Total] 258 / 83 / 6 / 347:  35%|███▍      | 347/1000 [16:11<30:28,  2.80s/it][Succeeded / Failed / Skipped / Total] 258 / 83 / 6 / 347:  35%|███▍      | 348/1000 [16:12<30:22,  2.80s/it][Succeeded / Failed / Skipped / Total] 258 / 84 / 6 / 348:  35%|███▍      | 348/1000 [16:12<30:22,  2.80s/it][Succeeded / Failed / Skipped / Total] 258 / 84 / 6 / 348:  35%|███▍      | 349/1000 [16:13<30:15,  2.79s/it]Makes an annotation change . --> [[[FAILED]]]

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[inloputan]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 344 ---------------------------------------------
Finds the scope annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation [[annotation]] : annotations ) { Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; if ( isScopeAnnotation ( [[annotationType]] ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , [[annotationType]] ) ; } else { found = [[annotationType]] ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[sanscoreenolisis]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation [[urotazer]] : annotations ) { Class < ? extends Annotation > [[acatatsprofile]] = [[urotazer]] . annotationType ( ) ; if ( isScopeAnnotation ( [[acatatsprofile]] ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , [[acatatsprofile]] ) ; } else { found = [[acatatsprofile]] ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 345 ---------------------------------------------
Gets the given constructor . --> return the starting point --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[fall]] ( InjectionPoint [[builtourflictcenter]] , Errors [[attacks]] ) throws ErrorsException { return cache . get ( [[builtourflictcenter]] , [[attacks]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 346 ---------------------------------------------
Returns the key for a new ProviderMap . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[entrySetBinder]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[entrySetBinder]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[entrySetBinder]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[pageateabector]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[pageateabector]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[pageateabector]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 347 ---------------------------------------------
Creates a new realMapBinder . --> super herepapointbotered --> Socre: 1.0

[[[[Adv]]]]: static < [[K]] , V > RealMapBinder < [[K]] , V > [[newRealMapBinder]] ( Binder binder , TypeLiteral < [[K]] > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < [[n]] , V > RealMapBinder < [[n]] , V > [[superdisplaypapointbotered]] ( Binder binder , TypeLiteral < [[n]] > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[superdisplaypapointbotered]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 348 ---------------------------------------------
Internal factory . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[scope]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object [[source]] , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope [[scope]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[cause]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object [[parent]] , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope [[cause]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 349 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 258 / 85 / 6 / 349:  35%|███▍      | 349/1000 [16:13<30:15,  2.79s/it][Succeeded / Failed / Skipped / Total] 258 / 85 / 6 / 349:  35%|███▌      | 350/1000 [16:13<30:08,  2.78s/it][Succeeded / Failed / Skipped / Total] 259 / 85 / 6 / 350:  35%|███▌      | 350/1000 [16:13<30:08,  2.78s/it][Succeeded / Failed / Skipped / Total] 259 / 85 / 6 / 350:  35%|███▌      | 351/1000 [16:15<30:03,  2.78s/it][Succeeded / Failed / Skipped / Total] 260 / 85 / 6 / 351:  35%|███▌      | 351/1000 [16:15<30:03,  2.78s/it][Succeeded / Failed / Skipped / Total] 260 / 85 / 6 / 351:  35%|███▌      | 352/1000 [16:18<30:01,  2.78s/it][Succeeded / Failed / Skipped / Total] 261 / 85 / 6 / 352:  35%|███▌      | 352/1000 [16:18<30:01,  2.78s/it][Succeeded / Failed / Skipped / Total] 261 / 85 / 6 / 352:  35%|███▌      | 353/1000 [16:21<29:58,  2.78s/it][Succeeded / Failed / Skipped / Total] 261 / 86 / 6 / 353:  35%|███▌      | 353/1000 [16:21<29:58,  2.78s/it][Succeeded / Failed / Skipped / Total] 261 / 86 / 6 / 353:  35%|███▌      | 354/1000 [16:21<29:51,  2.77s/it][Succeeded / Failed / Skipped / Total] 262 / 86 / 6 / 354:  35%|███▌      | 354/1000 [16:21<29:51,  2.77s/it][Succeeded / Failed / Skipped / Total] 262 / 86 / 6 / 354:  36%|███▌      | 355/1000 [16:21<29:43,  2.77s/it][Succeeded / Failed / Skipped / Total] 262 / 86 / 7 / 355:  36%|███▌      | 355/1000 [16:21<29:43,  2.77s/it][Succeeded / Failed / Skipped / Total] 262 / 86 / 7 / 355:  36%|███▌      | 356/1000 [16:24<29:40,  2.76s/it][Succeeded / Failed / Skipped / Total] 263 / 86 / 7 / 356:  36%|███▌      | 356/1000 [16:24<29:40,  2.76s/it][Succeeded / Failed / Skipped / Total] 263 / 86 / 7 / 356:  36%|███▌      | 357/1000 [16:28<29:39,  2.77s/it][Succeeded / Failed / Skipped / Total] 264 / 86 / 7 / 357:  36%|███▌      | 357/1000 [16:28<29:39,  2.77s/it][Succeeded / Failed / Skipped / Total] 264 / 86 / 7 / 357:  36%|███▌      | 358/1000 [16:30<29:36,  2.77s/it]Returns the key of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > type , Member [[member]] , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation [[found]] = findBindingAnnotation ( errors , [[member]] , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return [[found]] == null ? Key . get ( type ) : Key . get ( type , [[found]] ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[collectbar]] ( TypeLiteral < ? > type , Member [[file]] , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation [[common]] = findBindingAnnotation ( errors , [[file]] , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return [[common]] == null ? Key . get ( type ) : Key . get ( type , [[common]] ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 350 ---------------------------------------------
Perform construction . --> Get the actual object --> Socre: 1.0

[[[[Adv]]]]: private T provision ( InternalContext context , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; [[constructionContext]] . setProxyDelegates ( t ) ; } finally { [[constructionContext]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T provision ( InternalContext context , ConstructionContext < T > [[designfanflict]] ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; [[designfanflict]] . setProxyDelegates ( t ) ; } finally { [[designfanflict]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 351 ---------------------------------------------
Method replace . --> Write a replace method --> Socre: 1.0

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int i = 0 ; i < [[sourcesAsStrings]] . length ; i ++ ) { [[sourcesAsStrings]] [ i ] = Errors . convert ( [[sourcesAsStrings]] [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[dershasterlbi]] = sources . toArray ( ) ; for ( int i = 0 ; i < [[dershasterlbi]] . length ; i ++ ) { [[dershasterlbi]] [ i ] = Errors . convert ( [[dershasterlbi]] [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[dershasterlbi]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 352 ---------------------------------------------
Returns true if the given interceptor class has a scope annotation . --> dascreen --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[annotation]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[annotation]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[dascreen]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[lineitted]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[lineitted]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 353 ---------------------------------------------
Returns a new Module for the given module . --> [[[FAILED]]]

[[[[Adv]]]]: static Module [[forModule]] ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[ctredult]] ( Module [[source]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 354 ---------------------------------------------
Get the assist data by method --> Return assist data by method --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[buyexiebyendes]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 355 ---------------------------------------------
Gets the implementation with the given key . --> [[[SKIPPED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 356 ---------------------------------------------
Remove any non - null dependencies --> Draws the intersection --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[drawhasortheruntks]] ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 357 ---------------------------------------------
Gets the getBinding from the provided Method . --> F743 - 3 --> Socre: 1.0

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[knowfoianceactivekwerenvo]] ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
[Succeeded / Failed / Skipped / Total] 265 / 86 / 7 / 358:  36%|███▌      | 358/1000 [16:30<29:36,  2.77s/it][Succeeded / Failed / Skipped / Total] 265 / 86 / 7 / 358:  36%|███▌      | 359/1000 [16:40<29:45,  2.79s/it][Succeeded / Failed / Skipped / Total] 266 / 86 / 7 / 359:  36%|███▌      | 359/1000 [16:40<29:45,  2.79s/it][Succeeded / Failed / Skipped / Total] 266 / 86 / 7 / 359:  36%|███▌      | 360/1000 [16:40<29:39,  2.78s/it][Succeeded / Failed / Skipped / Total] 267 / 86 / 7 / 360:  36%|███▌      | 360/1000 [16:40<29:39,  2.78s/it][Succeeded / Failed / Skipped / Total] 267 / 86 / 7 / 360:  36%|███▌      | 361/1000 [16:41<29:32,  2.77s/it][Succeeded / Failed / Skipped / Total] 268 / 86 / 7 / 361:  36%|███▌      | 361/1000 [16:41<29:32,  2.77s/it][Succeeded / Failed / Skipped / Total] 268 / 86 / 7 / 361:  36%|███▌      | 362/1000 [16:45<29:31,  2.78s/it][Succeeded / Failed / Skipped / Total] 268 / 87 / 7 / 362:  36%|███▌      | 362/1000 [16:45<29:31,  2.78s/it][Succeeded / Failed / Skipped / Total] 268 / 87 / 7 / 362:  36%|███▋      | 363/1000 [16:50<29:33,  2.78s/it][Succeeded / Failed / Skipped / Total] 268 / 88 / 7 / 363:  36%|███▋      | 363/1000 [16:50<29:33,  2.78s/it][Succeeded / Failed / Skipped / Total] 268 / 88 / 7 / 363:  36%|███▋      | 364/1000 [16:51<29:27,  2.78s/it][Succeeded / Failed / Skipped / Total] 268 / 89 / 7 / 364:  36%|███▋      | 364/1000 [16:51<29:27,  2.78s/it][Succeeded / Failed / Skipped / Total] 268 / 89 / 7 / 364:  36%|███▋      | 365/1000 [16:54<29:25,  2.78s/it][Succeeded / Failed / Skipped / Total] 269 / 89 / 7 / 365:  36%|███▋      | 365/1000 [16:54<29:25,  2.78s/it][Succeeded / Failed / Skipped / Total] 269 / 89 / 7 / 365:  37%|███▋      | 366/1000 [16:54<29:18,  2.77s/it]--------------------------------------------- Result 358 ---------------------------------------------
Create a new RealMultibinder . --> Install a RealMultibinder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[backwithsesheds]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 359 ---------------------------------------------
Get the InjectionPoint from the private constructor --> startcdraencycomionPoint --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[startcdraencycomtorringb]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 360 ---------------------------------------------
Check whether the given implementation is valid for the given types . --> lacireolig Care --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[badDeps]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[lacireoligenticmetrednsimunvie]] ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[boodeples]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 361 ---------------------------------------------
Find the next filter . --> get improvement from request --> Socre: 1.0

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter [[filter]] = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( [[filter]] != null ) { return [[filter]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[herdkfaller]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter [[improvement]] = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( [[improvement]] != null ) { return [[improvement]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 362 ---------------------------------------------
Returns true if the class has atInject . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[dasselint]] ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 363 ---------------------------------------------
Returns the dependencies for a ctor point . --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[collectdesciecier]] ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 364 ---------------------------------------------
Invokes the proxy . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object proxy , final Method [[method]] , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[forhanf]] ( Object proxy , final Method [[driver]] , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 365 ---------------------------------------------
Returns the line for the given member . --> Print a president --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[printdkamben]] ( Member [[president]] ) { Preconditions . checkArgument ( type == [[president]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[president]] , [[president]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[president]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 366 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 270 / 89 / 7 / 366:  37%|███▋      | 366/1000 [16:54<29:18,  2.77s/it][Succeeded / Failed / Skipped / Total] 270 / 89 / 7 / 366:  37%|███▋      | 367/1000 [16:56<29:13,  2.77s/it][Succeeded / Failed / Skipped / Total] 270 / 90 / 7 / 367:  37%|███▋      | 367/1000 [16:56<29:13,  2.77s/it][Succeeded / Failed / Skipped / Total] 270 / 90 / 7 / 367:  37%|███▋      | 368/1000 [17:01<29:14,  2.78s/it][Succeeded / Failed / Skipped / Total] 271 / 90 / 7 / 368:  37%|███▋      | 368/1000 [17:01<29:14,  2.78s/it][Succeeded / Failed / Skipped / Total] 271 / 90 / 7 / 368:  37%|███▋      | 369/1000 [17:04<29:11,  2.78s/it][Succeeded / Failed / Skipped / Total] 272 / 90 / 7 / 369:  37%|███▋      | 369/1000 [17:04<29:11,  2.78s/it][Succeeded / Failed / Skipped / Total] 272 / 90 / 7 / 369:  37%|███▋      | 370/1000 [17:09<29:13,  2.78s/it][Succeeded / Failed / Skipped / Total] 273 / 90 / 7 / 370:  37%|███▋      | 370/1000 [17:09<29:13,  2.78s/it][Succeeded / Failed / Skipped / Total] 274 / 90 / 7 / 371:  37%|███▋      | 371/1000 [17:10<29:06,  2.78s/it][Succeeded / Failed / Skipped / Total] 274 / 90 / 7 / 371:  37%|███▋      | 372/1000 [17:13<29:05,  2.78s/it][Succeeded / Failed / Skipped / Total] 274 / 91 / 7 / 372:  37%|███▋      | 372/1000 [17:13<29:05,  2.78s/it]Returns a Module for the given module --> WFG1 trecoalalle --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[module]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[trecoalle]] ( Object [[object]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[object]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 367 ---------------------------------------------
Returns the list of dependencies for this constructor . --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[getstpruparteearoopts]] ( ) { ImmutableSet . Builder < InjectionPoint > [[manufacturer]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[manufacturer]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 368 ---------------------------------------------
Checks if type literal is not null or not . --> zap2gpsticulated --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > [[typeLiteral]] , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message [[msg]] = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) . getMessages ( ) ) ; return [[msg]] . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[zap2gpsticulated]] ( TypeLiteral < ? > [[presentationdirar]] , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message [[pcr]] = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[presentationdirar]] ) . getMessages ( ) ) ; return [[pcr]] . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "[[doubt]]" != "[[doubt]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 369 ---------------------------------------------
Initialize lookups . --> F743 - 3 --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[ancestordate]] ( Errors [[defects]] ) { injector . lookups = injector ; new LookupProcessor ( [[defects]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 370 ---------------------------------------------
Returns the annotation of the given method . --> zainsiatation of a method --> Socre: 1.0

[[[[Adv]]]]: private Annotation [[getAnnotation]] ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[foundAnnotation]] = method . getAnnotation ( annotationClass ) ; if ( [[foundAnnotation]] != null ) { if ( [[annotation]] != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[annotation]] = [[foundAnnotation]] ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation [[zainsiatation]] ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[incissetation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[boughtindomitic]] = method . getAnnotation ( annotationClass ) ; if ( [[boughtindomitic]] != null ) { if ( [[incissetation]] != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[incissetation]] = [[boughtindomitic]] ; } } return [[incissetation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 371 ---------------------------------------------
Validates a key and object . --> Methode d4j --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object [[object]] ) { if ( [[object]] == null || [[object]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[object]] ) ) { throw new IllegalArgumentException ( "Value[" + [[object]] + "] of type[" + [[object]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[object]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[dynamicendvanclasssforf]] ( Key < ? > key , Object [[assertion]] ) { if ( [[assertion]] == null || [[assertion]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[assertion]] ) ) { throw new IllegalArgumentException ( "Value[" + [[assertion]] + "] of type[" + [[assertion]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[assertion]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 372 ---------------------------------------------
Wrap callable with transfer request . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[journeypeactive]] ( Callable < T > [[push2]] ) { return wrap ( [[push2]] , [[journeypeactive]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 373 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 275 / 91 / 7 / 373:  37%|███▋      | 373/1000 [17:17<29:03,  2.78s/it][Succeeded / Failed / Skipped / Total] 275 / 91 / 7 / 373:  37%|███▋      | 374/1000 [17:21<29:02,  2.78s/it][Succeeded / Failed / Skipped / Total] 276 / 91 / 7 / 374:  37%|███▋      | 374/1000 [17:21<29:02,  2.78s/it][Succeeded / Failed / Skipped / Total] 276 / 92 / 7 / 375:  38%|███▊      | 375/1000 [17:24<29:00,  2.79s/it][Succeeded / Failed / Skipped / Total] 276 / 92 / 7 / 375:  38%|███▊      | 376/1000 [17:24<28:54,  2.78s/it][Succeeded / Failed / Skipped / Total] 277 / 92 / 7 / 376:  38%|███▊      | 376/1000 [17:24<28:54,  2.78s/it][Succeeded / Failed / Skipped / Total] 278 / 92 / 7 / 377:  38%|███▊      | 377/1000 [17:27<28:50,  2.78s/it][Succeeded / Failed / Skipped / Total] 278 / 92 / 7 / 377:  38%|███▊      | 378/1000 [17:28<28:45,  2.77s/it]Create a set of registered listeners . --> launchexmanrogatesk --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > [[type]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[type]] ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( [[type]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[type]] , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , [[type]] , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[type]] , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[launchexmanrogatesk]] ( TypeLiteral < T > [[scale]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[scale]] ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( [[scale]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[scale]] , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , [[scale]] , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[scale]] , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 374 ---------------------------------------------
Creates a new callable using the given seed map . --> Memouniversalject function --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[callable]] , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[quickuniversalject]] ( Callable < T > [[sendified]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[sendified]] , [[quickuniversalject]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 375 ---------------------------------------------
Returns a Key instance for the specified annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > [[i]] , AnnotationStrategy [[anopmenturtiongy]] ) { return new Key < T > ( [[i]] , [[anopmenturtiongy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 376 ---------------------------------------------
Returns true if the given constructor has no parameters . --> taintoressmutitorthefs --> Socre: 1.0

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > type , Constructor < ? > [[constructor]] , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( [[constructor]] ) ; Annotation [ ] [ ] paramAnnotations = [[constructor]] . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , [[constructor]] , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[taintoressmutitorthefs]] ( TypeLiteral < ? > type , Constructor < ? > [[constructedoro]] , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( [[constructedoro]] ) ; Annotation [ ] [ ] paramAnnotations = [[constructedoro]] . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , [[constructedoro]] , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 377 ---------------------------------------------
Gets the getBindingSource . --> pullrundinstreapose method --> Socre: 1.0

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[pullrundinstreapose]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 378 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 278 / 93 / 7 / 378:  38%|███▊      | 378/1000 [17:28<28:45,  2.77s/it][Succeeded / Failed / Skipped / Total] 279 / 93 / 7 / 379:  38%|███▊      | 379/1000 [17:33<28:46,  2.78s/it][Succeeded / Failed / Skipped / Total] 279 / 93 / 7 / 379:  38%|███▊      | 380/1000 [17:34<28:39,  2.77s/it][Succeeded / Failed / Skipped / Total] 279 / 94 / 7 / 380:  38%|███▊      | 380/1000 [17:34<28:39,  2.77s/it][Succeeded / Failed / Skipped / Total] 279 / 95 / 7 / 381:  38%|███▊      | 381/1000 [17:43<28:48,  2.79s/it][Succeeded / Failed / Skipped / Total] 279 / 95 / 7 / 381:  38%|███▊      | 382/1000 [17:44<28:41,  2.79s/it][Succeeded / Failed / Skipped / Total] 279 / 96 / 7 / 382:  38%|███▊      | 382/1000 [17:44<28:41,  2.79s/it][Succeeded / Failed / Skipped / Total] 280 / 96 / 7 / 383:  38%|███▊      | 383/1000 [17:44<28:34,  2.78s/it][Succeeded / Failed / Skipped / Total] 280 / 96 / 7 / 383:  38%|███▊      | 384/1000 [17:52<28:40,  2.79s/it]Returns a strategy for the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[andtar]] ( Class < ? extends Annotation > [[aveimpacttteware]] ) { [[aveimpacttteware]] = Annotations . canonicalizeIfNamed ( [[aveimpacttteware]] ) ; if ( isAllDefaultMethods ( [[aveimpacttteware]] ) ) { return [[andtar]] ( generateAnnotation ( [[aveimpacttteware]] ) ) ; } checkNotNull ( [[aveimpacttteware]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[aveimpacttteware]] ) ; ensureIsBindingAnnotation ( [[aveimpacttteware]] ) ; return new AnnotationTypeStrategy ( [[aveimpacttteware]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 379 ---------------------------------------------
Prunes the stack trace from the stack trace . --> Prune debug purposes --> Socre: 1.0

[[[[Adv]]]]: private void pruneStacktrace ( Throwable [[throwable]] ) { for ( Throwable t = [[throwable]] ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] [[stackTrace]] = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[stackTrace]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void pruneStacktrace ( Throwable [[powup]] ) { for ( Throwable t = [[powup]] ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] [[lofturase]] = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[lofturase]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 380 ---------------------------------------------
Returns a strategy for the annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[smartfor]] ( Annotation [[rainotace]] ) { checkNotNull ( [[rainotace]] , "annotation" ) ; Class < ? extends Annotation > [[dendialticand]] = [[rainotace]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[dendialticand]] ) ; ensureIsBindingAnnotation ( [[dendialticand]] ) ; if ( Annotations . isMarker ( [[dendialticand]] ) ) { return new AnnotationTypeStrategy ( [[dendialticand]] , [[rainotace]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[rainotace]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 381 ---------------------------------------------
Convert an Object to an ElementSource . --> [[[FAILED]]]

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource [[source]] = null ; if ( o instanceof ElementSource ) { [[source]] = ( ElementSource ) o ; o = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( o , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[fix]] ( Object o ) { ElementSource [[body]] = null ; if ( o instanceof ElementSource ) { [[body]] = ( ElementSource ) o ; o = [[body]] . getDeclaringSource ( ) ; } return [[fix]] ( o , [[body]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 382 ---------------------------------------------
Creates a new message . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( String messageFormat , Object ... [[arguments]] ) { return [[create]] ( null , messageFormat , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[shower]] ( String messageFormat , Object ... [[drivers]] ) { return [[shower]] ( null , messageFormat , [[drivers]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 383 ---------------------------------------------
Returns the injectors for the given argumentPoints . --> Get enjectors --> Socre: 1.0

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[injectionPoint]] : injectionPoints ) { try { Errors [[errorsForMember]] = [[injectionPoint]] . isOptional ( ) ? new Errors ( [[injectionPoint]] ) : errors . withSource ( [[injectionPoint]] ) ; SingleMemberInjector [[injector]] = [[injectionPoint]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[injector]] , [[injectionPoint]] , [[errorsForMember]] ) : new SingleMethodInjector ( this . [[injector]] , [[injectionPoint]] , [[errorsForMember]] ) ; [[injectors]] . add ( [[injector]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[withinvora]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[ashtime]] : injectionPoints ) { try { Errors [[entsformgeflict]] = [[ashtime]] . isOptional ( ) ? new Errors ( [[ashtime]] ) : errors . withSource ( [[ashtime]] ) ; SingleMemberInjector [[enjectable]] = [[ashtime]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[upscriptoris]] , [[ashtime]] , [[entsformgeflict]] ) : new SingleMethodInjector ( this . [[upscriptoris]] , [[ashtime]] , [[entsformgeflict]] ) ; [[withinvora]] . add ( [[enjectable]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 384 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 281 / 96 / 7 / 384:  38%|███▊      | 384/1000 [17:52<28:40,  2.79s/it][Succeeded / Failed / Skipped / Total] 281 / 97 / 7 / 385:  38%|███▊      | 385/1000 [17:52<28:33,  2.79s/it][Succeeded / Failed / Skipped / Total] 281 / 97 / 7 / 385:  39%|███▊      | 386/1000 [17:54<28:29,  2.78s/it][Succeeded / Failed / Skipped / Total] 282 / 97 / 7 / 386:  39%|███▊      | 386/1000 [17:55<28:29,  2.78s/it][Succeeded / Failed / Skipped / Total] 283 / 97 / 7 / 387:  39%|███▊      | 387/1000 [18:00<28:30,  2.79s/it][Succeeded / Failed / Skipped / Total] 283 / 97 / 7 / 387:  39%|███▉      | 388/1000 [18:00<28:23,  2.78s/it][Succeeded / Failed / Skipped / Total] 284 / 97 / 7 / 388:  39%|███▉      | 388/1000 [18:00<28:23,  2.78s/it][Succeeded / Failed / Skipped / Total] 284 / 98 / 7 / 389:  39%|███▉      | 389/1000 [18:01<28:18,  2.78s/it][Succeeded / Failed / Skipped / Total] 284 / 98 / 7 / 389:  39%|███▉      | 390/1000 [18:02<28:12,  2.78s/it][Succeeded / Failed / Skipped / Total] 284 / 99 / 7 / 390:  39%|███▉      | 390/1000 [18:02<28:12,  2.78s/it][Succeeded / Failed / Skipped / Total] 285 / 99 / 7 / 391:  39%|███▉      | 391/1000 [18:05<28:09,  2.77s/it][Succeeded / Failed / Skipped / Total] 285 / 99 / 7 / 391:  39%|███▉      | 392/1000 [18:10<28:11,  2.78s/it][Succeeded / Failed / Skipped / Total] 286 / 99 / 7 / 392:  39%|███▉      | 392/1000 [18:10<28:11,  2.78s/it]Get the object of the class name . --> catchalallectcongends --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : moduleClassNames ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[catchallectcongends]] ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String [[commandnetia]] : moduleClassNames ) { if ( ! shouldBeSkipped ( [[commandnetia]] ) ) { return new StackTraceElement ( [[commandnetia]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 385 ---------------------------------------------
Creates a new message . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable cause , String messageFormat , Object ... arguments ) { return [[create]] ( cause , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[created]] ( Throwable cause , String messageFormat , Object ... arguments ) { return [[created]] ( cause , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 386 ---------------------------------------------
Returns true if the parent is one of the same name . --> onlyleskaop --> Socre: 1.0

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[onlyleskaop]] ( String [[stylenu]] ) { return ( parent != null && parent . shouldBeSkipped ( [[stylenu]] ) ) || classNamesToSkip . contains ( [[stylenu]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 387 ---------------------------------------------
Main method . --> The main method --> Socre: 1.0

[[[[Adv]]]]: public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[module]] = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( [[module]] ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[modular]] = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( [[modular]] ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 388 ---------------------------------------------
Pushes a state --> Do not call this method --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > key , Object source ) { doPushState ( key , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[lhitsh]] ( com . google . inject . Key < ? > key , Object source ) { doPushState ( key , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 389 ---------------------------------------------
Creates a new Initializable instance --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[after]] ( final T [[intermediate]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[intermediate]] ; } @ Override public String toString ( ) { return String . valueOf ( [[intermediate]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 390 ---------------------------------------------
Creates a new Message . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message create ( Throwable [[cause]] , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message create ( Throwable [[origin]] , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , [[origin]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 391 ---------------------------------------------
Set processor . --> per remote address --> Socre: 1.0

[[[[Adv]]]]: public void [[onEvent]] ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void [[pervant]] ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 392 ---------------------------------------------
Ensures that the Throwable is a RuntimeException . --> Throw an unchecked unchecked exception . --> Socre: 1.0

[[[[Adv]]]]: public static void [[launderThrowable]] ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void [[changerstarrelatory]] ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 393 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 287 / 99 / 7 / 393:  39%|███▉      | 393/1000 [18:10<28:04,  2.77s/it][Succeeded / Failed / Skipped / Total] 287 / 99 / 7 / 393:  39%|███▉      | 394/1000 [18:15<28:05,  2.78s/it][Succeeded / Failed / Skipped / Total] 287 / 100 / 7 / 394:  39%|███▉      | 394/1000 [18:15<28:05,  2.78s/it][Succeeded / Failed / Skipped / Total] 288 / 100 / 7 / 395:  40%|███▉      | 395/1000 [18:16<27:59,  2.78s/it][Succeeded / Failed / Skipped / Total] 288 / 100 / 7 / 395:  40%|███▉      | 396/1000 [18:19<27:56,  2.78s/it][Succeeded / Failed / Skipped / Total] 289 / 100 / 7 / 396:  40%|███▉      | 396/1000 [18:19<27:56,  2.78s/it][Succeeded / Failed / Skipped / Total] 290 / 100 / 7 / 397:  40%|███▉      | 397/1000 [18:24<27:58,  2.78s/it][Succeeded / Failed / Skipped / Total] 290 / 100 / 7 / 397:  40%|███▉      | 398/1000 [18:24<27:51,  2.78s/it][Succeeded / Failed / Skipped / Total] 291 / 100 / 7 / 398:  40%|███▉      | 398/1000 [18:24<27:51,  2.78s/it][Succeeded / Failed / Skipped / Total] 292 / 100 / 7 / 399:  40%|███▉      | 399/1000 [18:26<27:46,  2.77s/it][Succeeded / Failed / Skipped / Total] 292 / 100 / 7 / 399:  40%|████      | 400/1000 [18:28<27:42,  2.77s/it]Get the provider for the specified dependency . --> provision the given provider --> Socre: 1.0

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > provider , Dependency < ? > [[dependency]] , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! [[dependency]] . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , [[dependency]] ) ; } [[constructionContext]] . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > provider , Dependency < ? > [[dependent]] , ConstructionContext < T > [[towerkontral]] ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! [[dependent]] . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , [[dependent]] ) ; } [[towerkontral]] . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 394 ---------------------------------------------
Executes the given RunStateRecordedFutureTask . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[y]] > [[y]] getFutureTaskResult ( RunStateRecordedFutureTask < [[y]] > task , Logger logger ) { [[y]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 395 ---------------------------------------------
Adds a dependency to the source . --> Get thebeunsenity --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object [[source]] ) { Dependency < ? > [[previous]] = this . dependency ; this . dependency = [[dependency]] ; doPushState ( [[dependency]] , [[source]] ) ; return [[previous]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[getbeunsenity]] ( Dependency < ? > [[relationship]] , Object [[body]] ) { Dependency < ? > [[date]] = this . dependency ; this . dependency = [[relationship]] ; doPushState ( [[relationship]] , [[body]] ) ; return [[date]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 396 ---------------------------------------------
Try to get the specified url . --> Returns the reference to the specified url . --> Socre: 1.0

[[[[Adv]]]]: private Url [[tryGet]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url [[bygl]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 397 ---------------------------------------------
Decodes the protocol code . --> interdoponcoramcode --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[interdoponcoramcode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 398 ---------------------------------------------
Scan the pool . --> Perform expired processing . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool [[pool]] = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != [[pool]] ) { [[pool]] . scan ( ) ; if ( [[pool]] . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - [[pool]] . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool [[bath]] = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != [[bath]] ) { [[bath]] . scan ( ) ; if ( [[bath]] . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - [[bath]] . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 399 ---------------------------------------------
Registers a processor . --> counterwoboottree routine --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode cmdCode , RemotingProcessor < ? > [[processor]] ) { if ( this . [[cmd2processors]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , [[processor]] . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( cmdCode , [[processor]] ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[counterwoboottree]] ( CommandCode cmdCode , RemotingProcessor < ? > [[hardware]] ) { if ( this . [[mvding11paragramaraս]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , [[hardware]] . getClass ( ) . getName ( ) ) ; } this . [[mvding11paragramaraս]] . put ( cmdCode , [[hardware]] ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 400 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 293 / 100 / 7 / 400:  40%|████      | 400/1000 [18:28<27:42,  2.77s/it][Succeeded / Failed / Skipped / Total] 294 / 100 / 7 / 401:  40%|████      | 401/1000 [18:30<27:39,  2.77s/it][Succeeded / Failed / Skipped / Total] 294 / 100 / 7 / 401:  40%|████      | 402/1000 [18:31<27:32,  2.76s/it][Succeeded / Failed / Skipped / Total] 295 / 100 / 7 / 402:  40%|████      | 402/1000 [18:31<27:32,  2.76s/it][Succeeded / Failed / Skipped / Total] 296 / 100 / 7 / 403:  40%|████      | 403/1000 [18:32<27:27,  2.76s/it][Succeeded / Failed / Skipped / Total] 296 / 100 / 7 / 403:  40%|████      | 404/1000 [18:34<27:23,  2.76s/it][Succeeded / Failed / Skipped / Total] 297 / 100 / 7 / 404:  40%|████      | 404/1000 [18:34<27:23,  2.76s/it][Succeeded / Failed / Skipped / Total] 298 / 100 / 7 / 405:  40%|████      | 405/1000 [18:34<27:17,  2.75s/it][Succeeded / Failed / Skipped / Total] 298 / 100 / 7 / 405:  41%|████      | 406/1000 [18:36<27:13,  2.75s/it][Succeeded / Failed / Skipped / Total] 299 / 100 / 7 / 406:  41%|████      | 406/1000 [18:36<27:13,  2.75s/it][Succeeded / Failed / Skipped / Total] 300 / 100 / 7 / 407:  41%|████      | 407/1000 [18:37<27:07,  2.74s/it][Succeeded / Failed / Skipped / Total] 300 / 100 / 7 / 407:  41%|████      | 408/1000 [18:43<27:09,  2.75s/it]Registers the default processor . --> array9veblearajectView --> Socre: 1.0

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > processor ) { if ( this . [[defaultProcessor]] == null ) { this . [[defaultProcessor]] = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[defaultProcessor]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[array9veblearajecttry]] ( RemotingProcessor < ? > processor ) { if ( this . [[doomparazisam]] == null ) { this . [[doomparazisam]] = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[doomparazisam]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 401 ---------------------------------------------
Create a new connection getAnd . --> region Connection getAnd Implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection getAndCreateIfAbsent ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection getAndCreateIfAbsent ( Url [[hust]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 402 ---------------------------------------------
Adds a connection event processor . --> Proagedoversopenatemagssor --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType type , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[connectagedoversopenatemagssor]] ( ConnectionEventType type , ConnectionEventProcessor [[series]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( [[series]] ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 403 ---------------------------------------------
Create a connectionAndHealIfNeed . --> CreateConnectionAndHealIfNeed --> Socre: 1.0

[[[[Adv]]]]: @ Override public void createConnectionAndHealIfNeed ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void createConnectionAndHealIfNeed ( Url [[aline]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 404 ---------------------------------------------
heal if the pool exists --> Opens a node . --> Socre: 1.0

[[[[Adv]]]]: private void healIfNeed ( ConnectionPool [[pool]] , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void healIfNeed ( ConnectionPool [[rack]] , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 405 ---------------------------------------------
Remove a task . --> Removes the connection pool from the pool . --> Socre: 1.0

[[[[Adv]]]]: private void [[removeTask]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void [[avoidcasm]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 406 ---------------------------------------------
Close the connection . --> Closes connection . --> Socre: 1.0

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url [[url]] = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( [[url]] . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url [[aaaw]] = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( [[aaaw]] . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 407 ---------------------------------------------
Create a connection . --> Creates a connection . --> Socre: 1.0

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int [[i]] = actualNum ; [[i]] < expectNum ; ++ [[i]] ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int [[front]] = actualNum ; [[front]] < expectNum ; ++ [[front]] ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 408 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 301 / 100 / 7 / 408:  41%|████      | 408/1000 [18:43<27:09,  2.75s/it][Succeeded / Failed / Skipped / Total] 302 / 100 / 7 / 409:  41%|████      | 409/1000 [18:44<27:05,  2.75s/it][Succeeded / Failed / Skipped / Total] 302 / 100 / 7 / 409:  41%|████      | 410/1000 [18:50<27:06,  2.76s/it][Succeeded / Failed / Skipped / Total] 303 / 100 / 7 / 410:  41%|████      | 410/1000 [18:50<27:06,  2.76s/it][Succeeded / Failed / Skipped / Total] 304 / 100 / 7 / 411:  41%|████      | 411/1000 [18:51<27:02,  2.75s/it][Succeeded / Failed / Skipped / Total] 304 / 100 / 7 / 411:  41%|████      | 412/1000 [18:55<27:00,  2.76s/it][Succeeded / Failed / Skipped / Total] 305 / 100 / 7 / 412:  41%|████      | 412/1000 [18:55<27:00,  2.76s/it][Succeeded / Failed / Skipped / Total] 305 / 101 / 7 / 413:  41%|████▏     | 413/1000 [18:56<26:55,  2.75s/it][Succeeded / Failed / Skipped / Total] 305 / 101 / 7 / 413:  41%|████▏     | 414/1000 [19:01<26:56,  2.76s/it]Gets the processor . --> superer ; --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[processor]] = this . cmd2processors . get ( cmdCode ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . [[defaultProcessor]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[superercpus]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[i]] = this . cmd2processors . get ( cmdCode ) ; if ( [[i]] != null ) { return [[i]] ; } return this . [[basicversaser]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 409 ---------------------------------------------
Add a new attribute to the attribute set . --> Gets request attributes --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String key , Object value ) { return attributes . putIfAbsent ( key , value ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[bookeditionatgethingphanerut]] ( String key , Object value ) { return attributes . putIfAbsent ( key , value ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 410 ---------------------------------------------
dispatch to the user processor --> allybeaverransyc --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[allybeaverransyc]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 411 ---------------------------------------------
Register a UserProcessor --> clockseroldlesor method --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[clockseroldlesor]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[clockseroldlesor]] ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 412 ---------------------------------------------
Deserialize the RpcRequestCommand . --> Deserializes the given RpcRequestCommand . --> Socre: 1.0

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String [[errMsg]] = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( [[errMsg]] , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , [[errMsg]] ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String [[augrentug]] = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( [[augrentug]] , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , [[augrentug]] ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 413 ---------------------------------------------
Close the remote address . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[close]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void [[closed]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
[Succeeded / Failed / Skipped / Total] 306 / 101 / 7 / 414:  41%|████▏     | 414/1000 [19:01<26:56,  2.76s/it][Succeeded / Failed / Skipped / Total] 307 / 101 / 7 / 415:  42%|████▏     | 415/1000 [19:03<26:51,  2.76s/it][Succeeded / Failed / Skipped / Total] 307 / 101 / 7 / 415:  42%|████▏     | 416/1000 [19:03<26:45,  2.75s/it][Succeeded / Failed / Skipped / Total] 308 / 101 / 7 / 416:  42%|████▏     | 416/1000 [19:03<26:45,  2.75s/it][Succeeded / Failed / Skipped / Total] 309 / 101 / 7 / 417:  42%|████▏     | 417/1000 [19:04<26:40,  2.75s/it][Succeeded / Failed / Skipped / Total] 309 / 101 / 7 / 417:  42%|████▏     | 418/1000 [19:05<26:34,  2.74s/it][Succeeded / Failed / Skipped / Total] 310 / 101 / 7 / 418:  42%|████▏     | 418/1000 [19:05<26:34,  2.74s/it]--------------------------------------------- Result 414 ---------------------------------------------
Registers a user processor . --> A convenience method for bimirrored --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String [[interest]] : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( [[interest]] , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[interest]] + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[bimirroredsuassesing]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String [[advantage]] : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( [[advantage]] , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[advantage]] + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 415 ---------------------------------------------
Executes the specified executor . --> Processes a specific ExecutorService --> Socre: 1.0

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService [[defaultExecutor]] ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { [[defaultExecutor]] . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService [[canvasaccessexottoror]] ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { [[canvasaccessexottoror]] . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 416 ---------------------------------------------
Logs a log message . --> Renames the server . --> Socre: 1.0

[[[[Adv]]]]: private void debugLog ( RemotingContext [[ctx]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[ctx]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void debugLog ( RemotingContext [[coo]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[coo]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 417 ---------------------------------------------
Returns all connections associated with this connection . --> turnrup the state --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[getAll]] ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[iterator]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[iterator]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[entry]] = [[iterator]] . next ( ) ; ConnectionPool [[pool]] = FutureTaskUtil . getFutureTaskResult ( [[entry]] . getValue ( ) , logger ) ; if ( null != [[pool]] ) { [[allConnections]] . put ( [[entry]] . getKey ( ) , [[pool]] . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[turnrup]] ( ) { Map < String , List < Connection > > [[elcannervances]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[aserictive]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[aserictive]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[arrow]] = [[aserictive]] . next ( ) ; ConnectionPool [[bed]] = FutureTaskUtil . getFutureTaskResult ( [[arrow]] . getValue ( ) , logger ) ; if ( null != [[bed]] ) { [[elcannervances]] . put ( [[arrow]] . getKey ( ) , [[bed]] . getAll ( ) ) ; } } return [[elcannervances]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 418 ---------------------------------------------
Pre - processes the processRemoting context . --> Set the current timestamp in the test suite --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[baseucesselesterctorverdict]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 419 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 311 / 101 / 7 / 419:  42%|████▏     | 419/1000 [19:06<26:29,  2.74s/it][Succeeded / Failed / Skipped / Total] 311 / 101 / 7 / 419:  42%|████▏     | 420/1000 [19:06<26:22,  2.73s/it][Succeeded / Failed / Skipped / Total] 311 / 101 / 8 / 420:  42%|████▏     | 420/1000 [19:06<26:22,  2.73s/it][Succeeded / Failed / Skipped / Total] 311 / 102 / 8 / 421:  42%|████▏     | 421/1000 [19:09<26:20,  2.73s/it][Succeeded / Failed / Skipped / Total] 311 / 102 / 8 / 421:  42%|████▏     | 422/1000 [19:12<26:18,  2.73s/it][Succeeded / Failed / Skipped / Total] 312 / 102 / 8 / 422:  42%|████▏     | 422/1000 [19:12<26:18,  2.73s/it]Returns the timeout log . --> fnetport gets remote address --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand [[cmd]] , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[cmd]] . getId ( ) , currentTimestamp , [[cmd]] . getArriveTime ( ) , ( currentTimestamp - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[cmd]] . getId ( ) , remoteAddr , ( currentTimestamp - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[fnetport]] ( final RpcRequestCommand [[4ag]] , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[4ag]] . getId ( ) , currentTimestamp , [[4ag]] . getArriveTime ( ) , ( currentTimestamp - [[4ag]] . getArriveTime ( ) ) , [[4ag]] . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[4ag]] . getId ( ) , remoteAddr , ( currentTimestamp - [[4ag]] . getArriveTime ( ) ) , [[4ag]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 420 ---------------------------------------------
Stops the connection manager . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 421 ---------------------------------------------
Closes the connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > [[iter]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = [[iter]] . next ( ) ; [[iter]] . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[immediatefooid]] ( ) { Iterator < Entry < Integer , InvokeFuture > > [[iver]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[iver]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = [[iver]] . next ( ) ; [[iver]] . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 422 ---------------------------------------------
Converts a bit set to a byte . --> Returns the value of the given BitSet . --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[arg]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 423 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 313 / 102 / 8 / 423:  42%|████▏     | 423/1000 [19:12<26:12,  2.73s/it][Succeeded / Failed / Skipped / Total] 313 / 102 / 8 / 423:  42%|████▏     | 424/1000 [19:13<26:06,  2.72s/it][Succeeded / Failed / Skipped / Total] 314 / 102 / 8 / 424:  42%|████▏     | 424/1000 [19:13<26:06,  2.72s/it][Succeeded / Failed / Skipped / Total] 315 / 102 / 8 / 425:  42%|████▎     | 425/1000 [19:13<26:00,  2.71s/it][Succeeded / Failed / Skipped / Total] 315 / 102 / 8 / 425:  43%|████▎     | 426/1000 [19:15<25:57,  2.71s/it]Formats the messages for the given heading . --> Textmissiares --> Socre: 1.0

[[[[Adv]]]]: public static String [[formatMessages]] ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int [[thisIdx]] = index ++ ; fmt . format ( "%s) %s%n" , [[thisIdx]] , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[i]] = dependencies . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { Object source = dependencies . get ( [[i]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , [[thisIdx]] ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String [[textmissiares]] ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int [[moreisexa]] = index ++ ; fmt . format ( "%s) %s%n" , [[moreisexa]] , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[line]] = dependencies . size ( ) - 1 ; [[line]] >= 0 ; [[line]] -- ) { Object source = dependencies . get ( [[line]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , [[moreisexa]] ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 424 ---------------------------------------------
Adds a new task to the URL . --> accesstableownflets --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[accesstableownfletsgspy]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 425 ---------------------------------------------
Invokes a request with a callback . --> Called by hovoc --> Socre: 1.0

[[[[Adv]]]]: protected void [[invokeWithCallback]] ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void [[hovocusheartforkfbe]] ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 426 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 316 / 102 / 8 / 426:  43%|████▎     | 426/1000 [19:15<25:57,  2.71s/it][Succeeded / Failed / Skipped / Total] 317 / 102 / 8 / 427:  43%|████▎     | 427/1000 [19:16<25:51,  2.71s/it][Succeeded / Failed / Skipped / Total] 317 / 102 / 8 / 427:  43%|████▎     | 428/1000 [19:16<25:45,  2.70s/it][Succeeded / Failed / Skipped / Total] 318 / 102 / 8 / 428:  43%|████▎     | 428/1000 [19:16<25:45,  2.70s/it][Succeeded / Failed / Skipped / Total] 319 / 102 / 8 / 429:  43%|████▎     | 429/1000 [19:16<25:39,  2.70s/it][Succeeded / Failed / Skipped / Total] 319 / 102 / 8 / 429:  43%|████▎     | 430/1000 [19:16<25:33,  2.69s/it][Succeeded / Failed / Skipped / Total] 319 / 102 / 9 / 430:  43%|████▎     | 430/1000 [19:16<25:33,  2.69s/it][Succeeded / Failed / Skipped / Total] 320 / 102 / 9 / 431:  43%|████▎     | 431/1000 [19:22<25:34,  2.70s/it][Succeeded / Failed / Skipped / Total] 320 / 102 / 9 / 431:  43%|████▎     | 432/1000 [19:23<25:29,  2.69s/it][Succeeded / Failed / Skipped / Total] 321 / 102 / 9 / 432:  43%|████▎     | 432/1000 [19:23<25:29,  2.69s/it]Filter the given connections . --> Filters connection list --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > [[connections]] ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[connections]] ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > [[collaborations]] ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[collaborations]] ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 427 ---------------------------------------------
Converts an int to a BitSet . --> Converts an int value into an array of integers . --> Socre: 1.0

[[[[Adv]]]]: public static BitSet [[toBitSet]] ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet [[byinthat]] ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 428 ---------------------------------------------
Create a peer - specific command . --> Creates a new call site --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[refrioncumpindr]] ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 429 ---------------------------------------------
Called when a remote address is received . --> Called when a connection is received --> Socre: 1.0

[[[[Adv]]]]: protected void oneway ( final Connection [[conn]] , final RemotingCommand [[request]] ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void oneway ( final Connection [[confield]] , final RemotingCommand [[command]] ) { try { [[confield]] . getChannel ( ) . writeAndFlush ( [[command]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[confield]] . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[confield]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[confield]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 430 ---------------------------------------------
Returns the value for the key . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 431 ---------------------------------------------
Log a info log --> Checks if the address is enabled --> Socre: 1.0

[[[[Adv]]]]: private void [[infoLog]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void [[areachurch]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 432 ---------------------------------------------
Returns boolean value for System property . --> callrouhol boolean . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBool]] ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property

[[[[Adv]]]]: public static boolean [[callrouhol]] ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 433 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 322 / 102 / 9 / 433:  43%|████▎     | 433/1000 [19:25<25:26,  2.69s/it][Succeeded / Failed / Skipped / Total] 322 / 102 / 9 / 433:  43%|████▎     | 434/1000 [19:26<25:20,  2.69s/it][Succeeded / Failed / Skipped / Total] 323 / 102 / 9 / 434:  43%|████▎     | 434/1000 [19:26<25:20,  2.69s/it][Succeeded / Failed / Skipped / Total] 324 / 102 / 9 / 435:  44%|████▎     | 435/1000 [19:26<25:15,  2.68s/it][Succeeded / Failed / Skipped / Total] 324 / 102 / 9 / 435:  44%|████▎     | 436/1000 [19:26<25:09,  2.68s/it][Succeeded / Failed / Skipped / Total] 325 / 102 / 9 / 436:  44%|████▎     | 436/1000 [19:26<25:09,  2.68s/it]Returns the property value for the given key . --> Returns null if not present --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[fixpotpalie]] ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 434 ---------------------------------------------
Is request timeout boolean . --> Returns true iff the current time should be written . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[andeftgrener]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 435 ---------------------------------------------
monitor the specified pool --> Determines whether there are any existing connection pools in the pool . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[monitor]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void [[at]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 436 ---------------------------------------------
Closes the connection to the service off connection . --> Check if there is already an already started datasource . --> Socre: 1.0

[[[[Adv]]]]: private void closeFreshSelectConnections ( Connection [[lastSelectConnect]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void closeFreshSelectConnections ( Connection [[fuluexyvaneuce]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[fuluexyvaneuce]] ) { if ( [[fuluexyvaneuce]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[fuluexyvaneuce]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[fuluexyvaneuce]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[fuluexyvaneuce]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[fuluexyvaneuce]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 326 / 102 / 9 / 437:  44%|████▎     | 437/1000 [19:28<25:05,  2.67s/it][Succeeded / Failed / Skipped / Total] 326 / 102 / 9 / 437:  44%|████▍     | 438/1000 [19:31<25:03,  2.67s/it][Succeeded / Failed / Skipped / Total] 327 / 102 / 9 / 438:  44%|████▍     | 438/1000 [19:31<25:03,  2.67s/it][Succeeded / Failed / Skipped / Total] 328 / 102 / 9 / 439:  44%|████▍     | 439/1000 [19:32<24:57,  2.67s/it][Succeeded / Failed / Skipped / Total] 328 / 102 / 9 / 439:  44%|████▍     | 440/1000 [19:33<24:54,  2.67s/it][Succeeded / Failed / Skipped / Total] 329 / 102 / 9 / 440:  44%|████▍     | 440/1000 [19:33<24:54,  2.67s/it][Succeeded / Failed / Skipped / Total] 330 / 102 / 9 / 441:  44%|████▍     | 441/1000 [19:34<24:48,  2.66s/it][Succeeded / Failed / Skipped / Total] 330 / 102 / 9 / 441:  44%|████▍     | 442/1000 [19:40<24:49,  2.67s/it][Succeeded / Failed / Skipped / Total] 331 / 102 / 9 / 442:  44%|████▍     | 442/1000 [19:40<24:49,  2.67s/it][Succeeded / Failed / Skipped / Total] 332 / 102 / 9 / 443:  44%|████▍     | 443/1000 [19:42<24:47,  2.67s/it][Succeeded / Failed / Skipped / Total] 332 / 102 / 9 / 443:  44%|████▍     | 444/1000 [19:44<24:43,  2.67s/it]Finds a random Connection . --> Updates a list of conns . --> Socre: 1.0

[[[[Adv]]]]: private Connection [[randomGet]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection [[bandwise]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 438 ---------------------------------------------
Converts ResponseCommand to Response object . --> Returns a bundle for the given ResponseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[bundlewruldlikelibflict]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 439 ---------------------------------------------
Returns the user processor for the given class name . --> Returns the UserProcessor of the given childiii --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . userProcessors . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[justusestaiverson]] ( String [[childiii]] ) { return StringUtils . isBlank ( [[childiii]] ) ? null : this . userProcessors . get ( [[childiii]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 440 ---------------------------------------------
Gets detail error message . --> Gets detailErrMsg . --> Socre: 1.0

[[[[Adv]]]]: private static String detailErrMsg ( String clientErrMsg , ResponseCommand [[responseCommand]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String detailErrMsg ( String clientErrMsg , ResponseCommand [[backmemoryuman]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[backmemoryuman]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 441 ---------------------------------------------
converts the ResponseCommand to a Throwable --> crackchnumled method --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[crackchnumled]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 442 ---------------------------------------------
Print a connection trace log --> Sets the sourcePort and target port . --> Socre: 1.0

[[[[Adv]]]]: public static void [[printConnectionTraceLog]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void [[aktraversisvelhog]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 443 ---------------------------------------------
Parse remote IP . --> kaidereout convert to string --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[kaidereoutpp]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 444 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 333 / 102 / 9 / 444:  44%|████▍     | 444/1000 [19:44<24:43,  2.67s/it][Succeeded / Failed / Skipped / Total] 334 / 102 / 9 / 445:  44%|████▍     | 445/1000 [19:50<24:44,  2.68s/it][Succeeded / Failed / Skipped / Total] 334 / 102 / 9 / 445:  45%|████▍     | 446/1000 [19:51<24:40,  2.67s/it][Succeeded / Failed / Skipped / Total] 335 / 102 / 9 / 446:  45%|████▍     | 446/1000 [19:51<24:40,  2.67s/it][Succeeded / Failed / Skipped / Total] 335 / 103 / 9 / 447:  45%|████▍     | 447/1000 [19:52<24:34,  2.67s/it][Succeeded / Failed / Skipped / Total] 335 / 103 / 9 / 447:  45%|████▍     | 448/1000 [19:55<24:32,  2.67s/it][Succeeded / Failed / Skipped / Total] 335 / 104 / 9 / 448:  45%|████▍     | 448/1000 [19:55<24:32,  2.67s/it][Succeeded / Failed / Skipped / Total] 336 / 104 / 9 / 449:  45%|████▍     | 449/1000 [19:55<24:27,  2.66s/it][Succeeded / Failed / Skipped / Total] 336 / 104 / 9 / 449:  45%|████▌     | 450/1000 [19:59<24:25,  2.67s/it][Succeeded / Failed / Skipped / Total] 337 / 104 / 9 / 450:  45%|████▌     | 450/1000 [19:59<24:25,  2.67s/it][Succeeded / Failed / Skipped / Total] 338 / 104 / 9 / 451:  45%|████▌     | 451/1000 [20:01<24:22,  2.66s/it][Succeeded / Failed / Skipped / Total] 338 / 104 / 9 / 451:  45%|████▌     | 452/1000 [20:01<24:17,  2.66s/it]Resolves an object from the given ResponseCommand . --> return immediately with status of receivedommer --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand [[responseCommand]] , String addr ) throws RemotingException { preProcess ( [[responseCommand]] , addr ) ; if ( [[responseCommand]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[responseCommand]] ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[responseCommand]] . getResponseStatus ( ) , addr , [[responseCommand]] . getId ( ) ) ; logger . warn ( msg ) ; if ( [[responseCommand]] . getCause ( ) != null ) { throw new InvokeException ( msg , [[responseCommand]] . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[combatrilputplemograph]] ( ResponseCommand [[receivedommerд]] , String addr ) throws RemotingException { preProcess ( [[receivedommerд]] , addr ) ; if ( [[receivedommerд]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[receivedommerд]] ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[receivedommerд]] . getResponseStatus ( ) , addr , [[receivedommerд]] . getId ( ) ) ; logger . warn ( msg ) ; if ( [[receivedommerд]] . getCause ( ) != null ) { throw new InvokeException ( msg , [[receivedommerд]] . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 445 ---------------------------------------------
Parse the local IP . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[polplop]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress [[locally]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[locally]] != null ) { return [[locally]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 446 ---------------------------------------------
Parse remote host name . --> cassumtherpated scan --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[cassumtherpatedlike]] ( final Channel [[line]] ) { if ( null == [[line]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[line]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
Parse a local address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[perplcorttraid]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Parse a remote address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[castyphdaldssar]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 449 ---------------------------------------------
Create a server exception . --> This method is not thread safe --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException [[createServerException]] ( Throwable t , String errMsg ) { String [[formattedErrMsg]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( [[formattedErrMsg]] ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException [[archivestardevantriver]] ( Throwable t , String errMsg ) { String [[uscmedरrimgs]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( [[uscmedरrimgs]] ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 450 ---------------------------------------------
Adds a connection to this group . --> Adds an access . --> Socre: 1.0

[[[[Adv]]]]: public void add ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . conns . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void add ( Connection [[access]] ) { markAccess ( ) ; if ( null == [[access]] ) { return ; } boolean res = this . conns . addIfAbsent ( [[access]] ) ; if ( res ) { [[access]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 451 ---------------------------------------------
Returns the connection . --> Connect to the snapshot . --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[connect]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
[Succeeded / Failed / Skipped / Total] 338 / 105 / 9 / 452:  45%|████▌     | 452/1000 [20:01<24:17,  2.66s/it][Succeeded / Failed / Skipped / Total] 338 / 106 / 9 / 453:  45%|████▌     | 453/1000 [20:01<24:11,  2.65s/it][Succeeded / Failed / Skipped / Total] 338 / 106 / 9 / 453:  45%|████▌     | 454/1000 [20:01<24:05,  2.65s/it][Succeeded / Failed / Skipped / Total] 338 / 107 / 9 / 454:  45%|████▌     | 454/1000 [20:01<24:05,  2.65s/it][Succeeded / Failed / Skipped / Total] 339 / 107 / 9 / 455:  46%|████▌     | 455/1000 [20:08<24:07,  2.66s/it][Succeeded / Failed / Skipped / Total] 339 / 107 / 9 / 455:  46%|████▌     | 456/1000 [20:09<24:02,  2.65s/it][Succeeded / Failed / Skipped / Total] 340 / 107 / 9 / 456:  46%|████▌     | 456/1000 [20:09<24:02,  2.65s/it][Succeeded / Failed / Skipped / Total] 341 / 107 / 9 / 457:  46%|████▌     | 457/1000 [20:13<24:01,  2.65s/it][Succeeded / Failed / Skipped / Total] 341 / 107 / 9 / 457:  46%|████▌     | 458/1000 [20:15<23:57,  2.65s/it][Succeeded / Failed / Skipped / Total] 342 / 107 / 9 / 458:  46%|████▌     | 458/1000 [20:15<23:57,  2.65s/it][Succeeded / Failed / Skipped / Total] 343 / 107 / 9 / 459:  46%|████▌     | 459/1000 [20:15<23:52,  2.65s/it][Succeeded / Failed / Skipped / Total] 343 / 107 / 9 / 459:  46%|████▌     | 460/1000 [20:15<23:47,  2.64s/it]--------------------------------------------- Result 452 ---------------------------------------------
Parse the remote port . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[rassorgramoffc]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 453 ---------------------------------------------
Returns the port of the given channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[bardmtimealoint]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[main]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[main]] != null ) { return [[main]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 454 ---------------------------------------------
Returns a EventLoopGroup for the specified threads . --> [[[FAILED]]]

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int [[nThreads]] , ThreadFactory [[threadFactory]] ) { return epollEnabled ? new EpollEventLoopGroup ( [[nThreads]] , [[threadFactory]] ) : new NioEventLoopGroup ( [[nThreads]] , [[threadFactory]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int [[alreadytheods]] , ThreadFactory [[vergee]] ) { return epollEnabled ? new EpollEventLoopGroup ( [[alreadytheods]] , [[vergee]] ) : new NioEventLoopGroup ( [[alreadytheods]] , [[vergee]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 455 ---------------------------------------------
Start the monitor . --> Starts the background thread . --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void [[a]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 456 ---------------------------------------------
Remove and close the connection . --> Countenedtrawrame . --> Socre: 1.0

[[[[Adv]]]]: public void [[removeAndTryClose]] ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . [[conns]] . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void [[countenedtrawrame]] ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . [[comts]] . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 457 ---------------------------------------------
Returns the CustomSerializer for the given command code . --> Returns null if unknown --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[bringcostafronttiales]] ( CommandCode [[studio]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[studio]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 458 ---------------------------------------------
Returns the CustomSerializer for the given class name . --> Returns givechitaleviotviewer --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[givechitaleviotviewer]] ( String [[personmal]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[personmal]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 459 ---------------------------------------------
Check if the remote address is connected . --> Set the remote host . --> Socre: 1.0

[[[[Adv]]]]: public boolean isConnected ( String remoteAddr ) { Url [[url]] = this . [[rpcRemoting]] . addressParser . parse ( remoteAddr ) ; return this . isConnected ( [[url]] ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean isConnected ( String remoteAddr ) { Url [[hostelm]] = this . [[rvdasenet]] . addressParser . parse ( remoteAddr ) ; return this . isConnected ( [[hostelm]] ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 460 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 344 / 107 / 9 / 460:  46%|████▌     | 460/1000 [20:15<23:47,  2.64s/it][Succeeded / Failed / Skipped / Total] 345 / 107 / 9 / 461:  46%|████▌     | 461/1000 [20:16<23:42,  2.64s/it][Succeeded / Failed / Skipped / Total] 345 / 107 / 9 / 461:  46%|████▌     | 462/1000 [20:19<23:40,  2.64s/it][Succeeded / Failed / Skipped / Total] 346 / 107 / 9 / 462:  46%|████▌     | 462/1000 [20:19<23:40,  2.64s/it][Succeeded / Failed / Skipped / Total] 347 / 107 / 9 / 463:  46%|████▋     | 463/1000 [20:20<23:35,  2.64s/it][Succeeded / Failed / Skipped / Total] 347 / 107 / 9 / 463:  46%|████▋     | 464/1000 [20:20<23:30,  2.63s/it][Succeeded / Failed / Skipped / Total] 348 / 107 / 9 / 464:  46%|████▋     | 464/1000 [20:20<23:30,  2.63s/it][Succeeded / Failed / Skipped / Total] 349 / 107 / 9 / 465:  46%|████▋     | 465/1000 [20:21<23:25,  2.63s/it][Succeeded / Failed / Skipped / Total] 349 / 107 / 9 / 465:  47%|████▋     | 466/1000 [20:22<23:20,  2.62s/it]Initializes the low water mark . --> Caller must be synchronized . --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[actptworkadtterroadman]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 461 ---------------------------------------------
Creates an Framedata object for the given Opcode . --> Constructs Framedata for 1 . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[cause]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 462 ---------------------------------------------
Register a custom serializer --> De - Fcalistic methods --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String className , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = classCustomSerializer . putIfAbsent ( className , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[deaclightbrecalistic]] ( String className , CustomSerializer [[bandize]] ) { CustomSerializer [[veᄉilialidae]] = classCustomSerializer . putIfAbsent ( className , [[bandize]] ) ; if ( [[veᄉilialidae]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + [[veᄉilialidae]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 463 ---------------------------------------------
Registers a custom serializer --> Registers customSerializer --> Socre: 1.0

[[[[Adv]]]]: public static void registerCustomSerializer ( CommandCode [[code]] , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = commandCustomSerializer . putIfAbsent ( [[code]] , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[code]] + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void registerCustomSerializer ( CommandCode [[line]] , CustomSerializer [[peculiarile]] ) { CustomSerializer [[caсuratute]] = commandCustomSerializer . putIfAbsent ( [[line]] , [[peculiarile]] ) ; if ( [[caсuratute]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[line]] + ", the custom serializer is: " + [[caсuratute]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 464 ---------------------------------------------
Determines if the channel is in the WebSocket channel . --> Checks if a given channel is alias . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[batch]] ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed

[[[[Adv]]]]: public static boolean [[alias]] ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 465 ---------------------------------------------
Validate UTF - 8 --> Validates UTF - 8 --> Socre: 1.0

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[payload]] , int mark ) throws InvalidDataException { try { [[payload]] . position ( [[payload]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[payload]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[payload]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[backbone]] , int mark ) throws InvalidDataException { try { [[backbone]] . position ( [[backbone]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[backbone]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[backbone]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 466 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 350 / 107 / 9 / 466:  47%|████▋     | 466/1000 [20:22<23:20,  2.62s/it][Succeeded / Failed / Skipped / Total] 351 / 107 / 9 / 467:  47%|████▋     | 467/1000 [20:22<23:14,  2.62s/it][Succeeded / Failed / Skipped / Total] 351 / 107 / 9 / 467:  47%|████▋     | 468/1000 [20:25<23:12,  2.62s/it][Succeeded / Failed / Skipped / Total] 352 / 107 / 9 / 468:  47%|████▋     | 468/1000 [20:25<23:12,  2.62s/it][Succeeded / Failed / Skipped / Total] 353 / 107 / 9 / 469:  47%|████▋     | 469/1000 [20:27<23:09,  2.62s/it][Succeeded / Failed / Skipped / Total] 353 / 107 / 9 / 469:  47%|████▋     | 470/1000 [20:27<23:03,  2.61s/it][Succeeded / Failed / Skipped / Total] 354 / 107 / 9 / 470:  47%|████▋     | 470/1000 [20:27<23:03,  2.61s/it][Succeeded / Failed / Skipped / Total] 355 / 107 / 9 / 471:  47%|████▋     | 471/1000 [20:29<23:01,  2.61s/it][Succeeded / Failed / Skipped / Total] 355 / 107 / 9 / 471:  47%|████▋     | 472/1000 [20:29<22:55,  2.61s/it][Succeeded / Failed / Skipped / Total] 356 / 107 / 9 / 472:  47%|████▋     | 472/1000 [20:29<22:55,  2.61s/it][Succeeded / Failed / Skipped / Total] 357 / 107 / 9 / 473:  47%|████▋     | 473/1000 [20:30<22:50,  2.60s/it][Succeeded / Failed / Skipped / Total] 357 / 107 / 9 / 473:  47%|████▋     | 474/1000 [20:33<22:48,  2.60s/it]Parse addresses to ip . --> Checks if there is a valid phone --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress [[socketAddress]] ) { final InetSocketAddress addrs = ( InetSocketAddress ) [[socketAddress]] ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[ansboldagerdriespothaustagram]] ( SocketAddress [[projectenddrose]] ) { final InetSocketAddress addrs = ( InetSocketAddress ) [[projectenddrose]] ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 467 ---------------------------------------------
Set the code . --> Draws an int . --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int code ) { this . code = code ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[drawclass]] ( int code ) { this . code = code ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 468 ---------------------------------------------
Checks if the given protocol is valid . --> ensteeplayeloiptlycom --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[ensteeplayeloiptlycom]] ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 469 ---------------------------------------------
Updates the message payload . --> set adjustmentidm . --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer [[pay]] = ByteBuffer . allocate ( 2 + by . length ) ; [[pay]] . put ( buf ) ; [[pay]] . put ( by ) ; [[pay]] . rewind ( ) ; super . setPayload ( [[pay]] ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[adjustmentparpalidm]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer [[shop]] = ByteBuffer . allocate ( 2 + by . length ) ; [[shop]] . put ( buf ) ; [[shop]] . put ( by ) ; [[shop]] . rewind ( ) ; super . setPayload ( [[shop]] ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 470 ---------------------------------------------
Translate a single frame check - size --> translateSingleFrame checkPacketSize --> Socre: 1.0

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int [[maxpacketsize]] , int realpacketsize ) throws IncompleteException { if ( [[maxpacketsize]] < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int [[excellerast]] , int realpacketsize ) throws IncompleteException { if ( [[excellerast]] < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 471 ---------------------------------------------
Process the binary frame --> agibinop message --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[agibinop]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 472 ---------------------------------------------
Logs the websocket error . --> On websocket message . --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[bookganeceguard]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 473 ---------------------------------------------
Translate single frame check length . --> Internal method used to correspondenceureex . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[correspondenceureextryreweuttidmit]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 474 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 358 / 107 / 9 / 474:  47%|████▋     | 474/1000 [20:33<22:48,  2.60s/it][Succeeded / Failed / Skipped / Total] 359 / 107 / 9 / 475:  48%|████▊     | 475/1000 [20:33<22:43,  2.60s/it][Succeeded / Failed / Skipped / Total] 359 / 107 / 9 / 475:  48%|████▊     | 476/1000 [20:35<22:40,  2.60s/it][Succeeded / Failed / Skipped / Total] 360 / 107 / 9 / 476:  48%|████▊     | 476/1000 [20:35<22:40,  2.60s/it][Succeeded / Failed / Skipped / Total] 361 / 107 / 9 / 477:  48%|████▊     | 477/1000 [20:38<22:37,  2.60s/it][Succeeded / Failed / Skipped / Total] 361 / 107 / 9 / 477:  48%|████▊     | 478/1000 [20:39<22:33,  2.59s/it][Succeeded / Failed / Skipped / Total] 362 / 107 / 9 / 478:  48%|████▊     | 478/1000 [20:39<22:33,  2.59s/it][Succeeded / Failed / Skipped / Total] 363 / 107 / 9 / 479:  48%|████▊     | 479/1000 [20:40<22:29,  2.59s/it][Succeeded / Failed / Skipped / Total] 363 / 107 / 9 / 479:  48%|████▊     | 480/1000 [20:41<22:25,  2.59s/it][Succeeded / Failed / Skipped / Total] 364 / 107 / 9 / 480:  48%|████▊     | 480/1000 [20:41<22:25,  2.59s/it][Succeeded / Failed / Skipped / Total] 365 / 107 / 9 / 481:  48%|████▊     | 481/1000 [20:44<22:23,  2.59s/it][Succeeded / Failed / Skipped / Total] 365 / 107 / 9 / 481:  48%|████▊     | 482/1000 [20:46<22:19,  2.59s/it]Process the text . --> Write websocket message --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl webSocketImpl , Framedata [[frame]] ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( [[frame]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[actualalface]] ( WebSocketImpl webSocketImpl , Framedata [[park]] ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( [[park]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 475 ---------------------------------------------
Generate final key . --> Computes the basiemtace . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[basetemtace]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 476 ---------------------------------------------
Process the current continuous frame --> generaldeewe11app . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[generaldeewe11app]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 477 ---------------------------------------------
Process the frame if necessary . --> This method implements advancedt dcesflua --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode [[curop]] ) throws InvalidDataException { if ( [[curop]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[advancedtowncesfluaareuinplex]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode [[systemrip]] ) throws InvalidDataException { if ( [[systemrip]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 478 ---------------------------------------------
Process the Close frame . --> Decflowload . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame [[cf]] = ( CloseFrame ) frame ; code = [[cf]] . getCloseCode ( ) ; reason = [[cf]] . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[byflowload]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame [[n]] = ( CloseFrame ) frame ; code = [[n]] . getCloseCode ( ) ; reason = [[n]] . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 479 ---------------------------------------------
Renames the first line . --> method to translateHandshakeHttpServer --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] [[firstLineTokens]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] [[byclasstriles]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 480 ---------------------------------------------
Get the size of the list . --> Computes how many bytes have been committed . --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[bookrynetwofsgstill]] ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 481 ---------------------------------------------
Translate the given line in the first line as an identifier . --> Getsbandstankleutampcant . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[getbandstankleutampcant]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 482 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 366 / 107 / 9 / 482:  48%|████▊     | 482/1000 [20:46<22:19,  2.59s/it][Succeeded / Failed / Skipped / Total] 367 / 107 / 9 / 483:  48%|████▊     | 483/1000 [20:46<22:14,  2.58s/it][Succeeded / Failed / Skipped / Total] 367 / 107 / 9 / 483:  48%|████▊     | 484/1000 [20:46<22:09,  2.58s/it][Succeeded / Failed / Skipped / Total] 367 / 107 / 10 / 484:  48%|████▊     | 484/1000 [20:46<22:09,  2.58s/it][Succeeded / Failed / Skipped / Total] 368 / 107 / 10 / 485:  48%|████▊     | 485/1000 [20:48<22:05,  2.57s/it][Succeeded / Failed / Skipped / Total] 368 / 107 / 10 / 485:  49%|████▊     | 486/1000 [20:48<22:00,  2.57s/it][Succeeded / Failed / Skipped / Total] 369 / 107 / 10 / 486:  49%|████▊     | 486/1000 [20:48<22:00,  2.57s/it]Process the current frame . --> after IPvac --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[afterdripac]] ( WebSocketImpl [[httpsmackydimelli]] , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[httpsmackydimelli]] . getWebSocketListener ( ) . onWebsocketMessage ( [[httpsmackydimelli]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[httpsmackydimelli]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[httpsmackydimelli]] . getWebSocketListener ( ) . onWebsocketMessage ( [[httpsmackydimelli]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[httpsmackydimelli]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 483 ---------------------------------------------
Closes the connection flush code . --> closureconrulinkweweted . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[closureconrulinkwewetedputsaut]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 484 ---------------------------------------------
Resets the websocket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 485 ---------------------------------------------
Check the max frames limit . --> beatlarfps object --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long [[totalSize]] = getByteBufferListSize ( ) ; if ( [[totalSize]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[totalSize]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[beatlarfpsct]] ( ) throws LimitExceededException { long [[countersized]] = getByteBufferListSize ( ) ; if ( [[countersized]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[countersized]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 486 ---------------------------------------------
Decodes the socket buffer . --> Bodge socket buffer . --> Socre: 1.0

[[[[Adv]]]]: public void [[decode]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void [[bodge]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 487 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 370 / 107 / 10 / 487:  49%|████▊     | 487/1000 [20:50<21:57,  2.57s/it][Succeeded / Failed / Skipped / Total] 370 / 107 / 10 / 487:  49%|████▉     | 488/1000 [20:51<21:52,  2.56s/it][Succeeded / Failed / Skipped / Total] 371 / 107 / 10 / 488:  49%|████▉     | 488/1000 [20:51<21:52,  2.56s/it][Succeeded / Failed / Skipped / Total] 372 / 107 / 10 / 489:  49%|████▉     | 489/1000 [20:51<21:48,  2.56s/it][Succeeded / Failed / Skipped / Total] 372 / 107 / 10 / 489:  49%|████▉     | 490/1000 [20:54<21:45,  2.56s/it][Succeeded / Failed / Skipped / Total] 373 / 107 / 10 / 490:  49%|████▉     | 490/1000 [20:54<21:45,  2.56s/it][Succeeded / Failed / Skipped / Total] 374 / 107 / 10 / 491:  49%|████▉     | 491/1000 [20:55<21:41,  2.56s/it][Succeeded / Failed / Skipped / Total] 374 / 107 / 10 / 491:  49%|████▉     | 492/1000 [20:55<21:36,  2.55s/it][Succeeded / Failed / Skipped / Total] 375 / 107 / 10 / 492:  49%|████▉     | 492/1000 [20:55<21:36,  2.55s/it][Succeeded / Failed / Skipped / Total] 375 / 107 / 11 / 493:  49%|████▉     | 493/1000 [20:56<21:31,  2.55s/it][Succeeded / Failed / Skipped / Total] 375 / 107 / 11 / 493:  49%|████▉     | 494/1000 [20:57<21:27,  2.55s/it]Writes the exception to the internal frame . --> closedtreddebandared . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[closedtreddebandaredevintustsaravearorn]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 488 ---------------------------------------------
Sends the given text . --> For debugging --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[bring]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[bring]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 489 ---------------------------------------------
Start the connect . --> F743 --> Socre: 1.0

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[fellowship]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 490 ---------------------------------------------
Returns the port . --> Method lelay . --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[skyplay]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 491 ---------------------------------------------
Send the appropriate handshake --> Sends a localHandshake request . --> Socre: 1.0

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client [[handshake]] = new HandshakeImpl1Client ( ) ; [[handshake]] . setResourceDescriptor ( path ) ; [[handshake]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { [[handshake]] . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( [[handshake]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client [[dayshallette]] = new HandshakeImpl1Client ( ) ; [[dayshallette]] . setResourceDescriptor ( path ) ; [[dayshallette]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { [[dayshallette]] . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( [[dayshallette]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 492 ---------------------------------------------
Get the contents of the buffer . --> Calculates dubytiesuperq --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer [[resultingByteBuffer]] ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; [[resultingByteBuffer]] = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { [[resultingByteBuffer]] . put ( buffer ) ; } } [[resultingByteBuffer]] . flip ( ) ; return [[resultingByteBuffer]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[estptweraferexbytleperflish]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer [[dubytiesuperq]] ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; [[dubytiesuperq]] = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { [[dubytiesuperq]] . put ( buffer ) ; } } [[dubytiesuperq]] . flip ( ) ; return [[dubytiesuperq]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 493 ---------------------------------------------
Called on websocketHandshake --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 494 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 376 / 107 / 11 / 494:  49%|████▉     | 494/1000 [20:57<21:27,  2.55s/it][Succeeded / Failed / Skipped / Total] 377 / 107 / 11 / 495:  50%|████▉     | 495/1000 [20:57<21:22,  2.54s/it][Succeeded / Failed / Skipped / Total] 377 / 107 / 11 / 495:  50%|████▉     | 496/1000 [20:57<21:18,  2.54s/it][Succeeded / Failed / Skipped / Total] 378 / 107 / 11 / 496:  50%|████▉     | 496/1000 [20:57<21:18,  2.54s/it][Succeeded / Failed / Skipped / Total] 378 / 107 / 12 / 497:  50%|████▉     | 497/1000 [20:57<21:13,  2.53s/it][Succeeded / Failed / Skipped / Total] 378 / 107 / 12 / 497:  50%|████▉     | 498/1000 [20:58<21:08,  2.53s/it][Succeeded / Failed / Skipped / Total] 378 / 107 / 13 / 498:  50%|████▉     | 498/1000 [20:58<21:08,  2.53s/it][Succeeded / Failed / Skipped / Total] 379 / 107 / 13 / 499:  50%|████▉     | 499/1000 [20:59<21:04,  2.52s/it][Succeeded / Failed / Skipped / Total] 379 / 107 / 13 / 499:  50%|█████     | 500/1000 [21:00<21:00,  2.52s/it]Generates an error message --> Generation of officegage --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer generateHttpResponseDueToError ( int [[errorCode]] ) { String [[errorCodeDescription]] ; switch ( [[errorCode]] ) { case 404 : [[errorCodeDescription]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[errorCodeDescription]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[errorCodeDescription]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[errorCodeDescription]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[errorCodeDescription]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer generateHttpResponseDueToError ( int [[officegage]] ) { String [[eesneslisium]] ; switch ( [[officegage]] ) { case 404 : [[eesneslisium]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[eesneslisium]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[eesneslisium]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[eesneslisium]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[eesneslisium]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 495 ---------------------------------------------
Sets the connection lost timer . --> Stop timer thread --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[bandkanniesftliattlemiuter]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 496 ---------------------------------------------
restart a connection lost timer --> Restart connectionLostTimer . --> Socre: 1.0

[[[[Adv]]]]: private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[conn]] : connections ) { executeConnectionLostDetection ( [[conn]] , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[bowis]] : connections ) { executeConnectionLostDetection ( [[bowis]] , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 497 ---------------------------------------------
Reads data from the socket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 498 ---------------------------------------------
Do the actual channel . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 499 ---------------------------------------------
Stop the connection lost timer . --> Perform processing . --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[boototesethingworkstister]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 500 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 380 / 107 / 13 / 500:  50%|█████     | 500/1000 [21:00<21:00,  2.52s/it][Succeeded / Failed / Skipped / Total] 381 / 107 / 13 / 501:  50%|█████     | 501/1000 [21:02<20:57,  2.52s/it][Succeeded / Failed / Skipped / Total] 381 / 107 / 13 / 501:  50%|█████     | 502/1000 [21:02<20:52,  2.52s/it][Succeeded / Failed / Skipped / Total] 381 / 107 / 14 / 502:  50%|█████     | 502/1000 [21:02<20:52,  2.52s/it][Succeeded / Failed / Skipped / Total] 381 / 107 / 15 / 503:  50%|█████     | 503/1000 [21:02<20:47,  2.51s/it][Succeeded / Failed / Skipped / Total] 381 / 107 / 15 / 503:  50%|█████     | 504/1000 [21:03<20:43,  2.51s/it][Succeeded / Failed / Skipped / Total] 382 / 107 / 15 / 504:  50%|█████     | 504/1000 [21:03<20:43,  2.51s/it][Succeeded / Failed / Skipped / Total] 383 / 107 / 15 / 505:  50%|█████     | 505/1000 [21:05<20:40,  2.51s/it][Succeeded / Failed / Skipped / Total] 383 / 107 / 15 / 505:  51%|█████     | 506/1000 [21:07<20:37,  2.51s/it][Succeeded / Failed / Skipped / Total] 383 / 108 / 15 / 506:  51%|█████     | 506/1000 [21:07<20:37,  2.51s/it][Succeeded / Failed / Skipped / Total] 383 / 108 / 16 / 507:  51%|█████     | 507/1000 [21:07<20:32,  2.50s/it][Succeeded / Failed / Skipped / Total] 383 / 108 / 16 / 507:  51%|█████     | 508/1000 [21:07<20:28,  2.50s/it]Starts the connection lost timer . --> Ends websocket . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[endcniusenisunmen]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 501 ---------------------------------------------
Stops this socket . --> Stop this InterFuture --> Socre: 1.0

[[[[Adv]]]]: public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[False]]" != "[[False]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[false]]" != "[[false]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 502 ---------------------------------------------
doEnsure single thread? --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 503 ---------------------------------------------
Close server . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 504 ---------------------------------------------
Sends a ping frame --> Called onWebsocket method --> Socre: 1.0

[[[[Adv]]]]: @ Override public void onWebsocketPing ( WebSocket [[conn]] , Framedata f ) { [[conn]] . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void onWebsocketPing ( WebSocket [[doop]] , Framedata f ) { [[doop]] . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 505 ---------------------------------------------
Handles a read . --> Reads the entry in the queue . --> Socre: 1.0

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl [[conn]] = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( [[conn]] . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , [[conn]] , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , [[conn]] , [[conn]] . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { [[conn]] . inQueue . put ( buf ) ; queue ( [[conn]] ) ; i . remove ( ) ; if ( [[conn]] . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) [[conn]] . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( [[conn]] ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl [[formate]] = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( [[formate]] . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , [[formate]] , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , [[formate]] , [[formate]] . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { [[formate]] . inQueue . put ( buf ) ; queue ( [[formate]] ) ; i . remove ( ) ; if ( [[formate]] . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) [[formate]] . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( [[formate]] ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 506 ---------------------------------------------
Returns the port of the server . --> [[[FAILED]]]

[[[[Adv]]]]: public int getPort ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int getPort ( ) { int [[region]] = getAddress ( ) . getPort ( ) ; if ( [[region]] == 0 && server != null ) { [[region]] = server . socket ( ) . getLocalPort ( ) ; } return [[region]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 507 ---------------------------------------------
Performs a broadcast operation . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 508 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 384 / 108 / 16 / 508:  51%|█████     | 508/1000 [21:07<20:28,  2.50s/it][Succeeded / Failed / Skipped / Total] 385 / 108 / 16 / 509:  51%|█████     | 509/1000 [21:08<20:23,  2.49s/it][Succeeded / Failed / Skipped / Total] 385 / 108 / 16 / 509:  51%|█████     | 510/1000 [21:09<20:19,  2.49s/it][Succeeded / Failed / Skipped / Total] 385 / 109 / 16 / 510:  51%|█████     | 510/1000 [21:09<20:19,  2.49s/it][Succeeded / Failed / Skipped / Total] 386 / 109 / 16 / 511:  51%|█████     | 511/1000 [21:09<20:15,  2.49s/it][Succeeded / Failed / Skipped / Total] 386 / 109 / 16 / 511:  51%|█████     | 512/1000 [21:10<20:10,  2.48s/it][Succeeded / Failed / Skipped / Total] 387 / 109 / 16 / 512:  51%|█████     | 512/1000 [21:10<20:10,  2.48s/it][Succeeded / Failed / Skipped / Total] 388 / 109 / 16 / 513:  51%|█████▏    | 513/1000 [21:11<20:07,  2.48s/it][Succeeded / Failed / Skipped / Total] 388 / 109 / 16 / 513:  51%|█████▏    | 514/1000 [21:15<20:05,  2.48s/it][Succeeded / Failed / Skipped / Total] 389 / 109 / 16 / 514:  51%|█████▏    | 514/1000 [21:15<20:05,  2.48s/it][Succeeded / Failed / Skipped / Total] 390 / 109 / 16 / 515:  52%|█████▏    | 515/1000 [21:17<20:02,  2.48s/it][Succeeded / Failed / Skipped / Total] 390 / 109 / 16 / 515:  52%|█████▏    | 516/1000 [21:18<19:59,  2.48s/it]Perform a write operation . --> Checks the connection status for the given key . --> Socre: 1.0

[[[[Adv]]]]: private void [[doWrite]] ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void [[aclight]] ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 509 ---------------------------------------------
Cancel the connection for the given timer . --> cancellationutelottigeet . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[cancellationutelottigeetleplex]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 510 ---------------------------------------------
Start persistence unit . --> [[[FAILED]]]

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[begin]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 511 ---------------------------------------------
Broadcasts the data to the given clients . --> Broadcasts the given data --> Socre: 1.0

[[[[Adv]]]]: public void broadcast ( byte [ ] data , Collection < WebSocket > [[clients]] ) { if ( data == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( data ) , [[clients]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( byte [ ] data , Collection < WebSocket > [[producers]] ) { if ( data == null || [[producers]] == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( data ) , [[producers]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 512 ---------------------------------------------
Starts the server socket . --> Attempts to dishteakltheryeswerattreaad . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[dishteakltheryeswerattreaad]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 513 ---------------------------------------------
Broadcasts a text to the server . --> Broadcasts clients . --> Socre: 1.0

[[[[Adv]]]]: public void broadcast ( String [[text]] , Collection < WebSocket > clients ) { if ( [[text]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( String [[field]] , Collection < WebSocket > clients ) { if ( [[field]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[field]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 514 ---------------------------------------------
fill the frames . --> Specifies Open frames . --> Socre: 1.0

[[[[Adv]]]]: private void [[fillFrames]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void [[bookfolds]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 515 ---------------------------------------------
Gets the socket . --> Handles a WebSocket request . --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket conn ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[likesatiline]] ( WebSocket conn ) { WebSocketImpl [[jily]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[jily]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 516 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 391 / 109 / 16 / 516:  52%|█████▏    | 516/1000 [21:18<19:59,  2.48s/it][Succeeded / Failed / Skipped / Total] 392 / 109 / 16 / 517:  52%|█████▏    | 517/1000 [21:18<19:54,  2.47s/it][Succeeded / Failed / Skipped / Total] 392 / 109 / 16 / 517:  52%|█████▏    | 518/1000 [21:21<19:52,  2.47s/it][Succeeded / Failed / Skipped / Total] 393 / 109 / 16 / 518:  52%|█████▏    | 518/1000 [21:21<19:52,  2.47s/it][Succeeded / Failed / Skipped / Total] 394 / 109 / 16 / 519:  52%|█████▏    | 519/1000 [21:22<19:48,  2.47s/it][Succeeded / Failed / Skipped / Total] 394 / 109 / 16 / 519:  52%|█████▏    | 520/1000 [21:26<19:47,  2.47s/it][Succeeded / Failed / Skipped / Total] 395 / 109 / 16 / 520:  52%|█████▏    | 520/1000 [21:26<19:47,  2.47s/it][Succeeded / Failed / Skipped / Total] 395 / 110 / 16 / 521:  52%|█████▏    | 521/1000 [21:26<19:43,  2.47s/it][Succeeded / Failed / Skipped / Total] 395 / 110 / 16 / 521:  52%|█████▏    | 522/1000 [21:26<19:38,  2.47s/it][Succeeded / Failed / Skipped / Total] 395 / 111 / 16 / 522:  52%|█████▏    | 522/1000 [21:26<19:38,  2.47s/it][Succeeded / Failed / Skipped / Total] 396 / 111 / 16 / 523:  52%|█████▏    | 523/1000 [21:27<19:34,  2.46s/it][Succeeded / Failed / Skipped / Total] 396 / 111 / 16 / 523:  52%|█████▏    | 524/1000 [21:32<19:34,  2.47s/it]Convert arguments to verifya buffer . --> Get theillgaorf . --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[bundlenangtatillgaorf]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 517 ---------------------------------------------
Transfer a ByteBuffer to another ByteBuffer --> Set the bridgemanerb8 . --> Socre: 1.0

[[[[Adv]]]]: public static int [[transferByteBuffer]] ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int [[bridgemanerb8]] ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 518 ---------------------------------------------
Gets a list of arguments . --> Gets a list of arguments --> Socre: 1.0

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > [[keys]] , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[keys]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > [[records]] , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[records]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 519 ---------------------------------------------
Gets the translation string . --> Get the current adgs --> Socre: 1.0

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , String key , Object ... [[args]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , String key , Object ... [[adgs]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[adgs]] ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 520 ---------------------------------------------
Returns whether the specified language key is defined at . --> Getter for the current language --> Socre: 1.0

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang lang , String key ) { return messages . isDefinedAt ( key , lang ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[worldidefectpatter]] ( play . api . i18n . Lang lang , String key ) { return messages . isDefinedAt ( key , lang ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 521 ---------------------------------------------
Adds a new transaction . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > block ) { [[withTransaction]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[bandredoncyverio]] ( Consumer < EntityManager > block ) { [[bandredoncyverio]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 522 ---------------------------------------------
Gets an EntityManagerFactory by name . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager em ( String [[name]] ) { EntityManagerFactory emf = emfs . get ( [[name]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager em ( String [[address]] ) { EntityManagerFactory emf = emfs . get ( [[address]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 523 ---------------------------------------------
Execute the given connection . --> F743 --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket webSocket , long [[minimumPongTime]] ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < [[minimumPongTime]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[executedhernascationinstredmotct]] ( WebSocket webSocket , long [[grimpoteme]] ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < [[grimpoteme]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 524 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 397 / 111 / 16 / 524:  52%|█████▏    | 524/1000 [21:32<19:34,  2.47s/it][Succeeded / Failed / Skipped / Total] 398 / 111 / 16 / 525:  52%|█████▎    | 525/1000 [21:33<19:30,  2.46s/it][Succeeded / Failed / Skipped / Total] 398 / 111 / 16 / 525:  53%|█████▎    | 526/1000 [21:34<19:26,  2.46s/it][Succeeded / Failed / Skipped / Total] 399 / 111 / 16 / 526:  53%|█████▎    | 526/1000 [21:34<19:26,  2.46s/it][Succeeded / Failed / Skipped / Total] 400 / 111 / 16 / 527:  53%|█████▎    | 527/1000 [21:35<19:22,  2.46s/it][Succeeded / Failed / Skipped / Total] 400 / 111 / 16 / 527:  53%|█████▎    | 528/1000 [21:37<19:19,  2.46s/it][Succeeded / Failed / Skipped / Total] 401 / 111 / 16 / 528:  53%|█████▎    | 528/1000 [21:37<19:19,  2.46s/it][Succeeded / Failed / Skipped / Total] 402 / 111 / 16 / 529:  53%|█████▎    | 529/1000 [21:39<19:16,  2.46s/it][Succeeded / Failed / Skipped / Total] 402 / 111 / 16 / 529:  53%|█████▎    | 530/1000 [21:39<19:12,  2.45s/it][Succeeded / Failed / Skipped / Total] 403 / 111 / 16 / 530:  53%|█████▎    | 530/1000 [21:39<19:12,  2.45s/it][Succeeded / Failed / Skipped / Total] 403 / 112 / 16 / 531:  53%|█████▎    | 531/1000 [21:39<19:08,  2.45s/it][Succeeded / Failed / Skipped / Total] 403 / 112 / 16 / 531:  53%|█████▎    | 532/1000 [21:41<19:05,  2.45s/it][Succeeded / Failed / Skipped / Total] 404 / 112 / 16 / 532:  53%|█████▎    | 532/1000 [21:41<19:05,  2.45s/it][Succeeded / Failed / Skipped / Total] 404 / 113 / 16 / 533:  53%|█████▎    | 533/1000 [21:42<19:01,  2.44s/it][Succeeded / Failed / Skipped / Total] 404 / 113 / 16 / 533:  53%|█████▎    | 534/1000 [21:45<18:58,  2.44s/it][Succeeded / Failed / Skipped / Total] 405 / 113 / 16 / 534:  53%|█████▎    | 534/1000 [21:45<18:58,  2.44s/it][Succeeded / Failed / Skipped / Total] 406 / 113 / 16 / 535:  54%|█████▎    | 535/1000 [21:45<18:54,  2.44s/it][Succeeded / Failed / Skipped / Total] 406 / 113 / 16 / 535:  54%|█████▎    | 536/1000 [21:46<18:51,  2.44s/it]Returns the given Guiceable module --> Returns the given Methodins --> Socre: 1.0

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... [[skins]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[skins]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 525 ---------------------------------------------
Returns the bindings for the given modules . --> Create an affiliation Distribution --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... modules ) { return [[bindings]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[affiliationm]] ( play . api . inject . Module ... modules ) { return [[affiliationm]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 526 ---------------------------------------------
Returns the Self of the given REPLACEME0 . --> Returns the Guice atemesf --> Socre: 1.0

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[atemesf]] ( play . api . inject . Binding < ? > ... [[atemesf]] ) { return [[atemesf]] ( Guiceable . bindings ( [[atemesf]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 527 ---------------------------------------------
Set language . --> This method is not thread - safe --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result [[result]] , Lang lang ) { return messages . setLang ( [[result]] . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[atleg]] ( Result [[conclusion]] , Lang lang ) { return messages . setLang ( [[conclusion]] . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 528 ---------------------------------------------
Returns the overrides for the given modules . --> Returns the overrides for the given media --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[modules]] ) { return overrides ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[arrays]] ) { return overrides ( Guiceable . [[arrays]] ( [[arrays]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 529 ---------------------------------------------
Returns the overrides for the given modules . --> Return a copy of the GuiceableModule --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[forwinem]] ( GuiceableModule ... [[commons]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[commons]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 530 ---------------------------------------------
Returns the overrides for the given bindings . --> Returns the overrides of the given ameses --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Binding < ? > ... [[bindings]] ) { return overrides ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Binding < ? > ... [[ameses]] ) { return overrides ( Guiceable . [[ameses]] ( [[ameses]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 531 ---------------------------------------------
Wraps the given request header . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader request ) { play . api . i18n . Messages [[msgs]] = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[favourite]] ( Http . RequestHeader request ) { play . api . i18n . Messages [[fts]] = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( [[fts]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 532 ---------------------------------------------
Disables the specified module classes . --> A convenience routine to customize the module --> Socre: 1.0

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[deize]] ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 533 ---------------------------------------------
Gets the in . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[defines]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 534 ---------------------------------------------
Create a new Messages . --> secondary list --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > [[candidates]] ) { Seq < Lang > cs = Scala . asScala ( [[candidates]] ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[secondary]] ( Collection < Lang > [[players]] ) { Seq < Lang > cs = Scala . asScala ( [[players]] ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 535 ---------------------------------------------
Static tuple . --> Static constructor . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] , B > Tuple < [[A]] , B > Tuple ( [[A]] a , B b ) { return new Tuple < [[A]] , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < [[out]] , B > Tuple < [[out]] , B > Tuple ( [[out]] a , B b ) { return new Tuple < [[out]] , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 536 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 407 / 113 / 16 / 536:  54%|█████▎    | 536/1000 [21:46<18:51,  2.44s/it][Succeeded / Failed / Skipped / Total] 408 / 113 / 16 / 537:  54%|█████▎    | 537/1000 [21:47<18:47,  2.43s/it][Succeeded / Failed / Skipped / Total] 408 / 113 / 16 / 537:  54%|█████▍    | 538/1000 [21:49<18:44,  2.43s/it][Succeeded / Failed / Skipped / Total] 408 / 114 / 16 / 538:  54%|█████▍    | 538/1000 [21:49<18:44,  2.43s/it][Succeeded / Failed / Skipped / Total] 408 / 115 / 16 / 539:  54%|█████▍    | 539/1000 [21:58<18:47,  2.45s/it][Succeeded / Failed / Skipped / Total] 408 / 115 / 16 / 539:  54%|█████▍    | 540/1000 [21:59<18:43,  2.44s/it][Succeeded / Failed / Skipped / Total] 408 / 116 / 16 / 540:  54%|█████▍    | 540/1000 [21:59<18:43,  2.44s/it][Succeeded / Failed / Skipped / Total] 409 / 116 / 16 / 541:  54%|█████▍    | 541/1000 [22:00<18:40,  2.44s/it][Succeeded / Failed / Skipped / Total] 409 / 116 / 16 / 541:  54%|█████▍    | 542/1000 [22:01<18:36,  2.44s/it][Succeeded / Failed / Skipped / Total] 410 / 116 / 16 / 542:  54%|█████▍    | 542/1000 [22:01<18:36,  2.44s/it][Succeeded / Failed / Skipped / Total] 410 / 117 / 16 / 543:  54%|█████▍    | 543/1000 [22:02<18:33,  2.44s/it][Succeeded / Failed / Skipped / Total] 410 / 117 / 16 / 543:  54%|█████▍    | 544/1000 [22:05<18:30,  2.44s/it][Succeeded / Failed / Skipped / Total] 411 / 117 / 16 / 544:  54%|█████▍    | 544/1000 [22:05<18:30,  2.44s/it][Succeeded / Failed / Skipped / Total] 412 / 117 / 16 / 545:  55%|█████▍    | 545/1000 [22:05<18:26,  2.43s/it][Succeeded / Failed / Skipped / Total] 412 / 117 / 16 / 545:  55%|█████▍    | 546/1000 [22:09<18:25,  2.43s/it]Gets theExisting file . --> Maintimecogging player --> Socre: 1.0

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[gaintimecoggingfylean]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 537 ---------------------------------------------
Returns a tuple with five arguments . --> Applies forward function to ah . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] , B , C , D , E > Tuple5 < [[A]] , B , C , D , E > Tuple5 ( [[A]] a , B b , C c , D d , E e ) { return new Tuple5 < [[A]] , B , C , D , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < [[ah]] , B , C , D , E > Tuple5 < [[ah]] , B , C , D , E > Tuple5 ( [[ah]] a , B b , C c , D d , E e ) { return new Tuple5 < [[ah]] , B , C , D , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 538 ---------------------------------------------
Executes the specified Request . --> [[[FAILED]]]

[[[[Adv]]]]: public CompletionStage < Result > call ( Request [[req]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > call ( Request [[emut]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 539 ---------------------------------------------
Generate a String representation of a string . --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > string ( String [[callbackName]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > string ( String [[dropcentermail]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[dropcentermail]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 540 ---------------------------------------------
Adds a new constraint validator . --> [[[FAILED]]]

[[[[Adv]]]]: public < T [[extends]] ConstraintValidator < ? , ? > > [[MappedConstraintValidatorFactory]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T [[functions]] ConstraintValidator < ? , ? > > [[topologicaluessamneondaditaui]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 541 ---------------------------------------------
Returns the executor for the given context . --> If profile is non - null --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext ec ) { ExecutionContext [[prepared]] = ec . prepare ( ) ; if ( [[prepared]] instanceof Executor ) { return ( Executor ) [[prepared]] ; } else { return [[prepared]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[veiceorist]] ( ExecutionContext ec ) { ExecutionContext [[profile]] = ec . prepare ( ) ; if ( [[profile]] instanceof Executor ) { return ( Executor ) [[profile]] ; } else { return [[profile]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 542 ---------------------------------------------
Gets the json . --> Retrieve the lukeson --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[lukeson]] ( String [[lineacnow]] ) { return Flow . of ( JsonNode . class ) . map ( [[lukeson]] -> { return ByteString . fromString ( Json . stringify ( [[lukeson]] ) ) ; } ) . via ( flow ( [[lineacnow]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 543 ---------------------------------------------
Create a new JPAConfig instance . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig of ( String [[name]] , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig of ( String [[call]] , String [[modelroot]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[call]] , [[modelroot]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 544 ---------------------------------------------
Creates a new instance of the given class . --> Create a new instance of art extension --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] [[extends]] ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[art]] [[extension]] ConstraintValidator < ? , ? > > [[art]] newInstance ( Class < [[art]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 545 ---------------------------------------------
Wraps a list of arguments . --> Gets the first non - null non - zero non - zero non - zero non - zero non - zero non - zero non - zero --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... args ) { List < T > [[out]] ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { [[out]] = ( List < T > ) args [ 0 ] ; } else { [[out]] = Arrays . asList ( args ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[trailerwrvestattherigenaredf]] ( final T ... args ) { List < T > [[outs]] ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { [[outs]] = ( List < T > ) args [ 0 ] ; } else { [[outs]] = Arrays . asList ( args ) ; } return [[outs]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
[Succeeded / Failed / Skipped / Total] 412 / 118 / 16 / 546:  55%|█████▍    | 546/1000 [22:09<18:25,  2.43s/it][Succeeded / Failed / Skipped / Total] 412 / 119 / 16 / 547:  55%|█████▍    | 547/1000 [22:18<18:28,  2.45s/it][Succeeded / Failed / Skipped / Total] 412 / 119 / 16 / 547:  55%|█████▍    | 548/1000 [22:19<18:24,  2.44s/it][Succeeded / Failed / Skipped / Total] 413 / 119 / 16 / 548:  55%|█████▍    | 548/1000 [22:19<18:24,  2.44s/it][Succeeded / Failed / Skipped / Total] 413 / 120 / 16 / 549:  55%|█████▍    | 549/1000 [22:22<18:22,  2.45s/it][Succeeded / Failed / Skipped / Total] 413 / 120 / 16 / 549:  55%|█████▌    | 550/1000 [22:24<18:19,  2.44s/it][Succeeded / Failed / Skipped / Total] 414 / 120 / 16 / 550:  55%|█████▌    | 550/1000 [22:24<18:19,  2.44s/it][Succeeded / Failed / Skipped / Total] 414 / 121 / 16 / 551:  55%|█████▌    | 551/1000 [22:24<18:15,  2.44s/it][Succeeded / Failed / Skipped / Total] 414 / 121 / 16 / 551:  55%|█████▌    | 552/1000 [22:26<18:12,  2.44s/it][Succeeded / Failed / Skipped / Total] 415 / 121 / 16 / 552:  55%|█████▌    | 552/1000 [22:26<18:12,  2.44s/it]--------------------------------------------- Result 546 ---------------------------------------------
Create a new JPAConfig instance from the given map . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[on]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 547 ---------------------------------------------
Creates a new JPAConfig instance . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[n1]] , String [[u1]] , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[n1]] , [[u1]] ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[call]] ( String [[national7]] , String [[la]] , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[national7]] , [[la]] ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 548 ---------------------------------------------
Logs the given request . --> loggingryitives --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[loggingryustrdd]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 549 ---------------------------------------------
Sends a request to the browser . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader [[request]] , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[request]] . method ( ) , [[request]] . uri ( ) , message , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader [[requested]] , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[requested]] . method ( ) , [[requested]] . uri ( ) , message , [[requested]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 550 ---------------------------------------------
Processes the given exception . --> alsoarhovewrc --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader request , Throwable exception ) { try { UsefulException [[usefulException]] = throwableToUsefulException ( exception ) ; logServerError ( request , [[usefulException]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , [[usefulException]] ) ; default : return onDevServerError ( request , [[usefulException]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[alsoarhovewrc]] ( RequestHeader request , Throwable exception ) { try { UsefulException [[valuableenedval]] = throwableToUsefulException ( exception ) ; logServerError ( request , [[valuableenedval]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , [[valuableenedval]] ) ; default : return onDevServerError ( request , [[valuableenedval]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 551 ---------------------------------------------
Renders a request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader request , String [[message]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[exceptionpretimea]] ( RequestHeader request , String [[script]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 552 ---------------------------------------------
Sends an error to the client . --> CompletionStage for ajc --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int [[statusCode]] , String [[message]] ) { if ( [[statusCode]] == 400 ) { return onBadRequest ( request , [[message]] ) ; } else if ( [[statusCode]] == 403 ) { return onForbidden ( request , [[message]] ) ; } else if ( [[statusCode]] == 404 ) { return onNotFound ( request , [[message]] ) ; } else if ( [[statusCode]] >= 400 && [[statusCode]] < 500 ) { return onOtherClientError ( request , [[statusCode]] , [[message]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[statusCode]] + ": " + [[message]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[ajclacariop]] ( RequestHeader request , int [[doomdict]] , String [[communication]] ) { if ( [[doomdict]] == 400 ) { return onBadRequest ( request , [[communication]] ) ; } else if ( [[doomdict]] == 403 ) { return onForbidden ( request , [[communication]] ) ; } else if ( [[doomdict]] == 404 ) { return onNotFound ( request , [[communication]] ) ; } else if ( [[doomdict]] >= 400 && [[doomdict]] < 500 ) { return onOtherClientError ( request , [[doomdict]] , [[communication]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[doomdict]] + ": " + [[communication]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 553 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 415 / 122 / 16 / 553:  55%|█████▌    | 553/1000 [22:27<18:09,  2.44s/it][Succeeded / Failed / Skipped / Total] 415 / 122 / 16 / 553:  55%|█████▌    | 554/1000 [22:29<18:06,  2.44s/it][Succeeded / Failed / Skipped / Total] 416 / 122 / 16 / 554:  55%|█████▌    | 554/1000 [22:29<18:06,  2.44s/it][Succeeded / Failed / Skipped / Total] 417 / 122 / 16 / 555:  56%|█████▌    | 555/1000 [22:35<18:07,  2.44s/it][Succeeded / Failed / Skipped / Total] 417 / 122 / 16 / 555:  56%|█████▌    | 556/1000 [22:36<18:03,  2.44s/it][Succeeded / Failed / Skipped / Total] 418 / 122 / 16 / 556:  56%|█████▌    | 556/1000 [22:36<18:03,  2.44s/it][Succeeded / Failed / Skipped / Total] 419 / 122 / 16 / 557:  56%|█████▌    | 557/1000 [22:37<17:59,  2.44s/it][Succeeded / Failed / Skipped / Total] 419 / 122 / 16 / 557:  56%|█████▌    | 558/1000 [22:40<17:57,  2.44s/it][Succeeded / Failed / Skipped / Total] 419 / 123 / 16 / 558:  56%|█████▌    | 558/1000 [22:40<17:57,  2.44s/it][Succeeded / Failed / Skipped / Total] 420 / 123 / 16 / 559:  56%|█████▌    | 559/1000 [22:41<17:53,  2.43s/it][Succeeded / Failed / Skipped / Total] 420 / 123 / 16 / 559:  56%|█████▌    | 560/1000 [22:45<17:52,  2.44s/it][Succeeded / Failed / Skipped / Total] 421 / 123 / 16 / 560:  56%|█████▌    | 560/1000 [22:45<17:52,  2.44s/it]Handles a request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader [[request]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader [[application]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[application]] . method ( ) , [[application]] . uri ( ) , [[application]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[application]] . method ( ) , [[application]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[application]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 554 ---------------------------------------------
OnProdServerError . --> Callback from an incoming request --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > onProdServerError ( RequestHeader request , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > onProdServerError ( RequestHeader request , UsefulException [[incident]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[incident]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 555 ---------------------------------------------
Creates a BuildDocHandler from a directory . --> Build the BuildDoc Handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File [[directory]] ) { FileRepository repo = new FilesystemRepository ( [[directory]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[totherecsalization]] ( File [[band]] ) { FileRepository repo = new FilesystemRepository ( [[band]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 556 ---------------------------------------------
Create a BuildDocHandler from a jar file . --> Build the template handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile jarFile , String base ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[vobuild]] ( JarFile jarFile , String base ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 557 ---------------------------------------------
Get throwableToUsefulException . --> powalyneet - 8 --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , throwable ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[powalyneetextulxiptive]] ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , throwable ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 558 ---------------------------------------------
OnDevServerError . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 559 ---------------------------------------------
Gets the accessible method . --> Tearicethesascingreth --> Socre: 1.0

[[[[Adv]]]]: public static Method [[getMatchingAccessibleMethod]] ( final Class < ? > cls , final String methodName , final Class < ? > ... [[parameterTypes]] ) { try { final Method method = cls . getMethod ( methodName , [[parameterTypes]] ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method [[takeearicethesascingrethaioper]] ( final Class < ? > cls , final String methodName , final Class < ? > ... [[clientbaseds]] ) { try { final Method method = cls . getMethod ( methodName , [[clientbaseds]] ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 560 ---------------------------------------------
Create a HttpEntity object . --> Link content = charset --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[linkcling]] ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 561 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 422 / 123 / 16 / 561:  56%|█████▌    | 561/1000 [22:46<17:49,  2.44s/it][Succeeded / Failed / Skipped / Total] 422 / 123 / 16 / 561:  56%|█████▌    | 562/1000 [22:47<17:45,  2.43s/it][Succeeded / Failed / Skipped / Total] 423 / 123 / 16 / 562:  56%|█████▌    | 562/1000 [22:47<17:45,  2.43s/it][Succeeded / Failed / Skipped / Total] 424 / 123 / 16 / 563:  56%|█████▋    | 563/1000 [22:48<17:42,  2.43s/it][Succeeded / Failed / Skipped / Total] 424 / 123 / 16 / 563:  56%|█████▋    | 564/1000 [22:50<17:39,  2.43s/it][Succeeded / Failed / Skipped / Total] 424 / 124 / 16 / 564:  56%|█████▋    | 564/1000 [22:50<17:39,  2.43s/it][Succeeded / Failed / Skipped / Total] 424 / 124 / 17 / 565:  56%|█████▋    | 565/1000 [22:50<17:35,  2.43s/it][Succeeded / Failed / Skipped / Total] 424 / 124 / 17 / 565:  57%|█████▋    | 566/1000 [22:52<17:32,  2.42s/it][Succeeded / Failed / Skipped / Total] 425 / 124 / 17 / 566:  57%|█████▋    | 566/1000 [22:52<17:32,  2.42s/it][Succeeded / Failed / Skipped / Total] 426 / 124 / 17 / 567:  57%|█████▋    | 567/1000 [22:54<17:29,  2.42s/it][Succeeded / Failed / Skipped / Total] 426 / 124 / 17 / 567:  57%|█████▋    | 568/1000 [22:55<17:26,  2.42s/it][Succeeded / Failed / Skipped / Total] 427 / 124 / 17 / 568:  57%|█████▋    | 568/1000 [22:55<17:26,  2.42s/it][Succeeded / Failed / Skipped / Total] 428 / 124 / 17 / 569:  57%|█████▋    | 569/1000 [22:57<17:23,  2.42s/it][Succeeded / Failed / Skipped / Total] 428 / 124 / 17 / 569:  57%|█████▋    | 570/1000 [22:57<17:19,  2.42s/it][Succeeded / Failed / Skipped / Total] 429 / 124 / 17 / 570:  57%|█████▋    | 570/1000 [22:57<17:19,  2.42s/it][Succeeded / Failed / Skipped / Total] 430 / 124 / 17 / 571:  57%|█████▋    | 571/1000 [23:01<17:17,  2.42s/it][Succeeded / Failed / Skipped / Total] 430 / 124 / 17 / 571:  57%|█████▋    | 572/1000 [23:02<17:14,  2.42s/it][Succeeded / Failed / Skipped / Total] 430 / 125 / 17 / 572:  57%|█████▋    | 572/1000 [23:02<17:14,  2.42s/it]Builds the Build doc handler from a jar file . --> notointdjarikerjk --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String [[base]] ) { return [[fromDirectoryAndJar]] ( directory , jarFile , [[base]] , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[notointdjarikerjk]] ( File directory , JarFile jarFile , String [[field]] ) { return [[notointdjarikerjk]] ( directory , jarFile , [[field]] , "[[note]]" != "[[note]]" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 562 ---------------------------------------------
Gets the status code . --> Adds status to the response --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , JsonNode content ) { return status ( status , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result status ( int [[banner]] , JsonNode content ) { return status ( status , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 563 ---------------------------------------------
Create HttpEntity from Content content . --> Geteth form body --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String charset ) { String body ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[formotetheth]] ( Content [[aspect]] , String charset ) { String body ; if ( [[aspect]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 564 ---------------------------------------------
Consume data . --> [[[FAILED]]]

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[sharedt]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 565 ---------------------------------------------
Returns the user . --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 566 ---------------------------------------------
Parses status content . --> Get the cargo --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[status]] , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result [[cargo]] ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[cargo]] , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 567 ---------------------------------------------
Sends the given content and returns the result . --> send response status --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , InputStream content , long [[contentLength]] ) { return status ( status ) . sendInputStream ( content , [[contentLength]] ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result status ( int status , InputStream content , long [[formatounnotage]] ) { return status ( status ) . sendInputStream ( content , [[formatounnotage]] ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 568 ---------------------------------------------
Gets the status . --> Returns flag on the response --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode [[content]] , JsonEncoding encoding ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( [[content]] , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[flag]] ( int status , JsonNode [[output]] , JsonEncoding encoding ) { if ( [[output]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[flag]] ( [[flag]] ) . sendJson ( [[output]] , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 569 ---------------------------------------------
Create HttpEntity chunked . --> log messages --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > [[data]] , Optional < String > contentType ) { return new Chunked ( [[data]] . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[logdriven]] ( Source < ByteString , ? > [[format]] , Optional < String > contentType ) { return new Chunked ( [[format]] . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 570 ---------------------------------------------
Generates a unique service . --> Call this method --> Socre: 1.0

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[single]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 571 ---------------------------------------------
Attaches a fragment . --> Mbeans --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[schoolheymear]] ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 572 ---------------------------------------------
Creates a new Lang object . --> [[[FAILED]]]

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > [[candidates]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[candidates]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[superior]] ( Collection < Lang > [[winners]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[winners]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 573 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 431 / 125 / 17 / 573:  57%|█████▋    | 573/1000 [23:03<17:11,  2.41s/it][Succeeded / Failed / Skipped / Total] 431 / 125 / 17 / 573:  57%|█████▋    | 574/1000 [23:06<17:08,  2.41s/it][Succeeded / Failed / Skipped / Total] 432 / 125 / 17 / 574:  57%|█████▋    | 574/1000 [23:06<17:08,  2.41s/it][Succeeded / Failed / Skipped / Total] 433 / 125 / 17 / 575:  57%|█████▊    | 575/1000 [23:06<17:04,  2.41s/it][Succeeded / Failed / Skipped / Total] 433 / 125 / 17 / 575:  58%|█████▊    | 576/1000 [23:06<17:00,  2.41s/it][Succeeded / Failed / Skipped / Total] 434 / 125 / 17 / 576:  58%|█████▊    | 576/1000 [23:06<17:00,  2.41s/it][Succeeded / Failed / Skipped / Total] 434 / 126 / 17 / 577:  58%|█████▊    | 577/1000 [23:10<16:59,  2.41s/it][Succeeded / Failed / Skipped / Total] 434 / 126 / 17 / 577:  58%|█████▊    | 578/1000 [23:12<16:56,  2.41s/it][Succeeded / Failed / Skipped / Total] 435 / 126 / 17 / 578:  58%|█████▊    | 578/1000 [23:12<16:56,  2.41s/it][Succeeded / Failed / Skipped / Total] 436 / 126 / 17 / 579:  58%|█████▊    | 579/1000 [23:13<16:53,  2.41s/it][Succeeded / Failed / Skipped / Total] 436 / 126 / 17 / 579:  58%|█████▊    | 580/1000 [23:18<16:52,  2.41s/it][Succeeded / Failed / Skipped / Total] 436 / 127 / 17 / 580:  58%|█████▊    | 580/1000 [23:18<16:52,  2.41s/it]Returns the absolute url of the request . --> Returns the altitudearla for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request request ) { return [[absoluteURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[altitudearla]] ( Http . Request request ) { return [[altitudearla]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 574 ---------------------------------------------
Returns the URL for the given request . --> Intercept the backbonetracingtorgl request --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request request ) { return [[webSocketURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[backbonetracingtorgl]] ( Http . Request request ) { return [[backbonetracingtorgl]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 575 ---------------------------------------------
Return the status of the file . --> Get the cache for the given profile --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , File [[content]] ) { return [[status]] ( [[status]] , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[johnston]] ( int status , File [[profile]] ) { return [[johnston]] ( [[johnston]] , [[profile]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 576 ---------------------------------------------
Creates the BuildDocHandler for the directory and jar files . --> Build thechejaridor --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File [[directory]] , JarFile jarFile , String base , boolean [[fallbackToJar]] ) { FileRepository fileRepo = new FilesystemRepository ( [[directory]] ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( [[fallbackToJar]] ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[toointchejaridorج]] ( File [[file]] , JarFile jarFile , String base , boolean [[drawmetとjer]] ) { FileRepository fileRepo = new FilesystemRepository ( [[file]] ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( [[drawmetとjer]] ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 577 ---------------------------------------------
Gets connection function . --> [[[FAILED]]]

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return block . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[border]] ) { try { return block . call ( [[border]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 578 ---------------------------------------------
Converts a JsonNode to a Class . --> Create an instance of the given class . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[an]] > [[an]] fromJson ( JsonNode json , Class < [[an]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 579 ---------------------------------------------
Convert an Object to JSON . --> Get the bawes expression --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[baweshow]] ( final Object [[code]] ) { try { return mapper ( ) . valueToTree ( [[code]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 580 ---------------------------------------------
Gets a connection runnable . --> [[[FAILED]]]

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[block]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[tentgenssion]] ( final ConnectionRunnable [[blocks]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[blocks]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 581 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 437 / 127 / 17 / 581:  58%|█████▊    | 581/1000 [23:19<16:49,  2.41s/it][Succeeded / Failed / Skipped / Total] 437 / 127 / 17 / 581:  58%|█████▊    | 582/1000 [23:20<16:45,  2.41s/it][Succeeded / Failed / Skipped / Total] 437 / 128 / 17 / 582:  58%|█████▊    | 582/1000 [23:20<16:45,  2.41s/it][Succeeded / Failed / Skipped / Total] 437 / 129 / 17 / 583:  58%|█████▊    | 583/1000 [23:20<16:41,  2.40s/it][Succeeded / Failed / Skipped / Total] 437 / 129 / 17 / 583:  58%|█████▊    | 584/1000 [23:25<16:41,  2.41s/it][Succeeded / Failed / Skipped / Total] 437 / 130 / 17 / 584:  58%|█████▊    | 584/1000 [23:25<16:41,  2.41s/it][Succeeded / Failed / Skipped / Total] 437 / 131 / 17 / 585:  58%|█████▊    | 585/1000 [23:26<16:37,  2.40s/it][Succeeded / Failed / Skipped / Total] 437 / 131 / 17 / 585:  59%|█████▊    | 586/1000 [23:28<16:35,  2.40s/it][Succeeded / Failed / Skipped / Total] 438 / 131 / 17 / 586:  59%|█████▊    | 586/1000 [23:28<16:35,  2.40s/it][Succeeded / Failed / Skipped / Total] 439 / 131 / 17 / 587:  59%|█████▊    | 587/1000 [23:29<16:31,  2.40s/it][Succeeded / Failed / Skipped / Total] 439 / 131 / 17 / 587:  59%|█████▉    | 588/1000 [23:32<16:29,  2.40s/it]Returns a canonical version of the given URL . --> Get the prefix of the given URL --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( comp ) ; else [[canonical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[symmetrical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[symmetrical]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[symmetrical]] . empty ( ) && [[symmetrical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[symmetrical]] . push ( comp ) ; else [[symmetrical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[symmetrical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 582 ---------------------------------------------
Parses a string into a JsonNode . --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode parse ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( String [[rr5]] ) { try { return mapper ( ) . readTree ( [[rr5]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 583 ---------------------------------------------
Parses the given InputStream as a JsonNode . --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[ladderline]] ( java . io . InputStream [[nrt]] ) { try { return mapper ( ) . readTree ( [[nrt]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 584 ---------------------------------------------
Build doc handler . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] [[baseDirs]] ) throws IOException { assert ( files . length == [[baseDirs]] . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = [[baseDirs]] [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] [[uxirs]] ) throws IOException { assert ( files . length == [[uxirs]] . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = [[uxirs]] [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 585 ---------------------------------------------
Constructs a Server for the given configuration mode . --> [[[FAILED]]]

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode mode , int port , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[classsulx]] ( Mode mode , int port , Function < BuiltInComponents , Router > [[channel]] ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( [[channel]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 586 ---------------------------------------------
Displayable constraint . --> presentationeredlfcol --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[presentationeredlfcollik]] ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[presentationeredlfcollik]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 587 ---------------------------------------------
Returns the next cron expression in milliseconds . --> Create a cron expression --> Socre: 1.0

[[[[Adv]]]]: public static long cronInterval ( String cron , Date [[date]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long cronInterval ( String cron , Date [[day]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[day]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 588 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 440 / 131 / 17 / 588:  59%|█████▉    | 588/1000 [23:32<16:29,  2.40s/it][Succeeded / Failed / Skipped / Total] 441 / 131 / 17 / 589:  59%|█████▉    | 589/1000 [23:35<16:27,  2.40s/it][Succeeded / Failed / Skipped / Total] 441 / 131 / 17 / 589:  59%|█████▉    | 590/1000 [23:37<16:25,  2.40s/it][Succeeded / Failed / Skipped / Total] 442 / 131 / 17 / 590:  59%|█████▉    | 590/1000 [23:37<16:25,  2.40s/it][Succeeded / Failed / Skipped / Total] 443 / 131 / 17 / 591:  59%|█████▉    | 591/1000 [23:37<16:21,  2.40s/it][Succeeded / Failed / Skipped / Total] 443 / 131 / 17 / 591:  59%|█████▉    | 592/1000 [23:41<16:19,  2.40s/it][Succeeded / Failed / Skipped / Total] 443 / 132 / 17 / 592:  59%|█████▉    | 592/1000 [23:41<16:19,  2.40s/it][Succeeded / Failed / Skipped / Total] 443 / 133 / 17 / 593:  59%|█████▉    | 593/1000 [23:41<16:15,  2.40s/it][Succeeded / Failed / Skipped / Total] 443 / 133 / 17 / 593:  59%|█████▉    | 594/1000 [23:42<16:12,  2.40s/it][Succeeded / Failed / Skipped / Total] 444 / 133 / 17 / 594:  59%|█████▉    | 594/1000 [23:42<16:12,  2.40s/it][Succeeded / Failed / Skipped / Total] 445 / 133 / 17 / 595:  60%|█████▉    | 595/1000 [23:44<16:09,  2.39s/it][Succeeded / Failed / Skipped / Total] 445 / 133 / 17 / 595:  60%|█████▉    | 596/1000 [23:46<16:07,  2.39s/it][Succeeded / Failed / Skipped / Total] 446 / 133 / 17 / 596:  60%|█████▉    | 596/1000 [23:46<16:07,  2.39s/it][Succeeded / Failed / Skipped / Total] 446 / 134 / 17 / 597:  60%|█████▉    | 597/1000 [23:46<16:03,  2.39s/it][Succeeded / Failed / Skipped / Total] 446 / 134 / 17 / 597:  60%|█████▉    | 598/1000 [23:49<16:01,  2.39s/it][Succeeded / Failed / Skipped / Total] 446 / 135 / 17 / 598:  60%|█████▉    | 598/1000 [23:49<16:01,  2.39s/it]Returns a relative relative string --> Entry point for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String [[startPath]] , String targetPath ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[main]] ( String [[gome]] , String targetPath ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 589 ---------------------------------------------
Returns the results of the request . --> Renders the results of the provided request --> Socre: 1.0

[[[[Adv]]]]: public static Result TODO ( Request [[request]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[request]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result TODO ( Request [[demand]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[demand]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 590 ---------------------------------------------
Parses a CronExpression . --> Masstehrocaax yieldt --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[masstehrocaaxvrage]] ( String [[juot]] ) { try { return new CronExpression ( [[juot]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[juot]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 591 ---------------------------------------------
Returns the application builder . --> Loads an application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context [[context]] ) { return initialBuilder . in ( [[context]] . environment ( ) ) . loadConfig ( [[context]] . initialConfig ( ) ) . overrides ( overrides ( [[context]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[craftsman]] ( ApplicationLoader . Context [[framework]] ) { return initialBuilder . in ( [[framework]] . environment ( ) ) . loadConfig ( [[framework]] . initialConfig ( ) ) . overrides ( overrides ( [[framework]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 592 ---------------------------------------------
Returns a qualified key with the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[ps]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 593 ---------------------------------------------
Retrieves the qualified with the given instance . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[java]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 594 ---------------------------------------------
Displays the given constraint . --> Methode d level quad --> Socre: 1.0

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > [[constraint]] ) { final Display [[displayAnnotation]] = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[displayAnnotation]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[displayAnnotation]] . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[stevalidconevir]] ( ConstraintDescriptor < ? > [[quad]] ) { final Display [[projectedandoographictment]] = [[quad]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[projectedandoographictment]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[projectedandoographictment]] . attributes ( ) ) . map ( attr -> [[quad]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 595 ---------------------------------------------
Adds a session . --> Set experiment for String --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String [[key]] , String value ) { [[session]] ( ) . put ( [[key]] , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[experiment]] ( String [[grace]] , String value ) { [[experiment]] ( ) . put ( [[grace]] , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 596 ---------------------------------------------
Sets a flash value . --> region > font --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String key , String [[value]] ) { [[flash]] ( ) . put ( key , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[font]] ( String key , String [[blank]] ) { [[font]] ( ) . put ( key , [[blank]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 597 ---------------------------------------------
Converts a supplier to a Binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[allows]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 598 ---------------------------------------------
Converts the given provider to a Binding . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[i]] ( final Provider < ? extends T > [[bearer]] ) { return underlying . to ( [[bearer]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 599 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 446 / 136 / 17 / 599:  60%|█████▉    | 599/1000 [23:50<15:57,  2.39s/it][Succeeded / Failed / Skipped / Total] 446 / 136 / 17 / 599:  60%|██████    | 600/1000 [23:54<15:56,  2.39s/it][Succeeded / Failed / Skipped / Total] 446 / 137 / 17 / 600:  60%|██████    | 600/1000 [23:54<15:56,  2.39s/it][Succeeded / Failed / Skipped / Total] 446 / 138 / 17 / 601:  60%|██████    | 601/1000 [23:54<15:52,  2.39s/it][Succeeded / Failed / Skipped / Total] 446 / 138 / 17 / 601:  60%|██████    | 602/1000 [23:55<15:48,  2.38s/it][Succeeded / Failed / Skipped / Total] 447 / 138 / 17 / 602:  60%|██████    | 602/1000 [23:55<15:48,  2.38s/it][Succeeded / Failed / Skipped / Total] 447 / 139 / 17 / 603:  60%|██████    | 603/1000 [24:00<15:48,  2.39s/it][Succeeded / Failed / Skipped / Total] 447 / 139 / 17 / 603:  60%|██████    | 604/1000 [24:01<15:45,  2.39s/it][Succeeded / Failed / Skipped / Total] 447 / 140 / 17 / 604:  60%|██████    | 604/1000 [24:01<15:45,  2.39s/it][Succeeded / Failed / Skipped / Total] 448 / 140 / 17 / 605:  60%|██████    | 605/1000 [24:02<15:41,  2.38s/it][Succeeded / Failed / Skipped / Total] 448 / 140 / 17 / 605:  61%|██████    | 606/1000 [24:07<15:40,  2.39s/it][Succeeded / Failed / Skipped / Total] 449 / 140 / 17 / 606:  61%|██████    | 606/1000 [24:07<15:40,  2.39s/it][Succeeded / Failed / Skipped / Total] 450 / 140 / 17 / 607:  61%|██████    | 607/1000 [24:07<15:37,  2.38s/it][Succeeded / Failed / Skipped / Total] 450 / 140 / 17 / 607:  61%|██████    | 608/1000 [24:11<15:36,  2.39s/it]Converts the given implementation into a Binding . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > to ( final Class < ? extends T > [[implementation]] ) { return underlying . to ( [[implementation]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > to ( final Class < ? extends T > [[ui]] ) { return underlying . to ( [[ui]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 600 ---------------------------------------------
Convert the given BindingKey to a Java Binding . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[ta]] ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 601 ---------------------------------------------
Sets the timeout of the given stage . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > stage , final long [[amount]] , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( [[amount]] , unit ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > stage , final long [[account]] , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( [[account]] , unit ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 602 ---------------------------------------------
Returns all the availables for the given application . --> Get all global languages --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[darr]] ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 603 ---------------------------------------------
Creates a new AhcWS client . --> [[[FAILED]]]

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient [[client]] = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( [[client]] , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient [[customer]] = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( [[customer]] , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 604 ---------------------------------------------
Create a provider for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > [[provision]] ) { return underlying . toProvider ( [[provision]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 605 ---------------------------------------------
Loads a config file . --> Create a new Guice ApplicationBuilder --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[env]] ) -> new play . api . Configuration ( load . apply ( new Environment ( [[env]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[cld]] ) -> new play . api . Configuration ( load . apply ( new Environment ( [[cld]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 606 ---------------------------------------------
Loads a module . --> Creates an environment variable --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[bandmasndaeimportror]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 607 ---------------------------------------------
Load a Guice application --> Load an application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... [[modules]] ) { return load ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... [[applications]] ) { return load ( Guiceable . [[applications]] ( [[applications]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 608 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 451 / 140 / 17 / 608:  61%|██████    | 608/1000 [24:11<15:36,  2.39s/it][Succeeded / Failed / Skipped / Total] 451 / 140 / 18 / 609:  61%|██████    | 609/1000 [24:11<15:32,  2.38s/it][Succeeded / Failed / Skipped / Total] 451 / 140 / 18 / 609:  61%|██████    | 610/1000 [24:12<15:28,  2.38s/it][Succeeded / Failed / Skipped / Total] 452 / 140 / 18 / 610:  61%|██████    | 610/1000 [24:12<15:28,  2.38s/it][Succeeded / Failed / Skipped / Total] 453 / 140 / 18 / 611:  61%|██████    | 611/1000 [24:12<15:24,  2.38s/it][Succeeded / Failed / Skipped / Total] 454 / 140 / 18 / 612:  61%|██████    | 612/1000 [24:12<15:20,  2.37s/it][Succeeded / Failed / Skipped / Total] 455 / 140 / 18 / 613:  61%|██████▏   | 613/1000 [24:12<15:16,  2.37s/it][Succeeded / Failed / Skipped / Total] 455 / 140 / 18 / 613:  61%|██████▏   | 614/1000 [24:18<15:16,  2.38s/it][Succeeded / Failed / Skipped / Total] 455 / 141 / 18 / 614:  61%|██████▏   | 614/1000 [24:18<15:16,  2.38s/it][Succeeded / Failed / Skipped / Total] 456 / 141 / 18 / 615:  62%|██████▏   | 615/1000 [24:20<15:14,  2.37s/it][Succeeded / Failed / Skipped / Total] 456 / 142 / 18 / 616:  62%|██████▏   | 616/1000 [24:26<15:14,  2.38s/it]Creates a SimpleEvolutions reader from the evolutions map . --> Evolution the adaptationrs --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[adaptationrs]] . EvolutionsReader [[caap]] ( Map < String , List < Evolution > > [[adaptationrs]] ) { return new SimpleEvolutionsReader ( [[adaptationrs]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 609 ---------------------------------------------
Create a Guice ApplicationBuilder --> [[[SKIPPED]]]

[[[[Adv]]]]: protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 610 ---------------------------------------------
Load the given bindings . --> Create a host --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... bindings ) { return [[load]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[host]] ( play . api . inject . Binding < ? > ... bindings ) { return [[host]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 611 ---------------------------------------------
Clean up evolutions . --> tile end sampling off --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[tileddavgltimese]] ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 612 ---------------------------------------------
Load the given Module array --> blast returns blast --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... modules ) { return [[load]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[blast]] ( play . api . inject . Module ... modules ) { return [[blast]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 613 ---------------------------------------------
Loads an application . --> Returns an immutable Guice Application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[cover]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 614 ---------------------------------------------
Creates a Evolutions reader for the default evolutions . --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[forDefault]] ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > [[map]] = new HashMap < String , List < Evolution > > ( ) ; [[map]] . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( [[map]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[byrnesu]] . EvolutionsReader [[beneord]] ( Evolution ... [[byrnesu]] ) { Map < String , List < Evolution > > [[export]] = new HashMap < String , List < Evolution > > ( ) ; [[export]] . put ( "default" , Arrays . asList ( [[byrnesu]] ) ) ; return fromMap ( [[export]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 615 ---------------------------------------------
Returns the current stack . --> Returns a new Deque instance --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[remgaf]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 616 ---------------------------------------------
Returns an EntityManager object . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( ) { Deque < EntityManager > [[ems]] = this . emStack ( "True" == "True" ) ; if ( [[ems]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[ems]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager [[ex]] ( ) { Deque < EntityManager > [[eyebrow]] = this . emStack ( "True" == "True" ) ; if ( [[eyebrow]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[eyebrow]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 617 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 456 / 143 / 18 / 617:  62%|██████▏   | 617/1000 [24:28<15:11,  2.38s/it][Succeeded / Failed / Skipped / Total] 456 / 143 / 18 / 617:  62%|██████▏   | 618/1000 [24:28<15:07,  2.38s/it][Succeeded / Failed / Skipped / Total] 456 / 144 / 18 / 618:  62%|██████▏   | 618/1000 [24:28<15:07,  2.38s/it][Succeeded / Failed / Skipped / Total] 456 / 144 / 18 / 618:  62%|██████▏   | 619/1000 [24:37<15:09,  2.39s/it][Succeeded / Failed / Skipped / Total] 457 / 144 / 18 / 619:  62%|██████▏   | 619/1000 [24:37<15:09,  2.39s/it][Succeeded / Failed / Skipped / Total] 457 / 144 / 18 / 619:  62%|██████▏   | 620/1000 [24:38<15:06,  2.38s/it][Succeeded / Failed / Skipped / Total] 457 / 145 / 18 / 620:  62%|██████▏   | 620/1000 [24:38<15:06,  2.38s/it][Succeeded / Failed / Skipped / Total] 457 / 145 / 18 / 620:  62%|██████▏   | 621/1000 [24:38<15:02,  2.38s/it][Succeeded / Failed / Skipped / Total] 457 / 146 / 18 / 621:  62%|██████▏   | 621/1000 [24:38<15:02,  2.38s/it][Succeeded / Failed / Skipped / Total] 457 / 146 / 18 / 621:  62%|██████▏   | 622/1000 [24:42<15:00,  2.38s/it][Succeeded / Failed / Skipped / Total] 458 / 146 / 18 / 622:  62%|██████▏   | 622/1000 [24:42<15:00,  2.38s/it][Succeeded / Failed / Skipped / Total] 458 / 146 / 18 / 622:  62%|██████▏   | 623/1000 [24:44<14:58,  2.38s/it][Succeeded / Failed / Skipped / Total] 459 / 146 / 18 / 623:  62%|██████▏   | 623/1000 [24:44<14:58,  2.38s/it][Succeeded / Failed / Skipped / Total] 460 / 146 / 18 / 624:  62%|██████▏   | 624/1000 [24:44<14:54,  2.38s/it][Succeeded / Failed / Skipped / Total] 460 / 146 / 18 / 624:  62%|██████▎   | 625/1000 [24:45<14:51,  2.38s/it]Creates a preferred Lang object . --> [[[FAILED]]]

[[[[Adv]]]]: public static Lang preferred ( Application [[app]] , List < Lang > availableLangs ) { play . api . i18n . Langs [[langs]] = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( [[langs]] . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang preferred ( Application [[setting]] , List < Lang > availableLangs ) { play . api . i18n . Langs [[lansb]] = [[setting]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( [[lansb]] . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 618 ---------------------------------------------
Encodes a cookie --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[buf]] = new StringBuilder ( ) ; encode ( [[buf]] , cookie ) ; return stripTrailingSeparator ( [[buf]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[biz]] = new StringBuilder ( ) ; encode ( [[biz]] , cookie ) ; return stripTrailingSeparator ( [[biz]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 619 ---------------------------------------------
Creates a new flow ref . --> Return additional 1redf --> Socre: 1.0

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > [[actorRef]] ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy [[overflowStrategy]] , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , [[overflowStrategy]] , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > [[additionalbredf]] ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy [[arbleedapaptgi]] , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , [[arbleedapaptgi]] , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 620 ---------------------------------------------
Fills the form with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[drop]] ( T [[result]] ) { if ( [[result]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[result]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 621 ---------------------------------------------
Returns a list of errors . --> [[[FAILED]]]

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[secureterraicollection]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 622 ---------------------------------------------
Convenience method for setting a flow . --> region beatwe Implementation --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , FlowIn , Out > Flow < [[In]] , Out , ? > [[bypassWith]] ( Function < [[In]] , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return [[bypassWith]] ( Flow . < [[In]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < [[like]] , FlowIn , Out > Flow < [[like]] , Out , ? > [[beatwe]] ( Function < [[like]] , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return [[beatwe]] ( Flow . < [[like]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 623 ---------------------------------------------
Returns the value of the given key . --> Returns n . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[n]] ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 624 ---------------------------------------------
Fills a DynamicForm with the given value . --> fill a Dynamic object --> Socre: 1.0

[[[[Adv]]]]: public DynamicForm fill ( Map < String , Object > [[value]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[value]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[value]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm fill ( Map < String , Object > [[destination]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[destination]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[destination]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 625 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 460 / 147 / 18 / 625:  62%|██████▎   | 625/1000 [24:45<14:51,  2.38s/it][Succeeded / Failed / Skipped / Total] 461 / 147 / 18 / 626:  63%|██████▎   | 626/1000 [24:48<14:49,  2.38s/it][Succeeded / Failed / Skipped / Total] 461 / 147 / 18 / 626:  63%|██████▎   | 627/1000 [24:48<14:45,  2.37s/it][Succeeded / Failed / Skipped / Total] 461 / 148 / 18 / 627:  63%|██████▎   | 627/1000 [24:48<14:45,  2.37s/it][Succeeded / Failed / Skipped / Total] 462 / 148 / 18 / 628:  63%|██████▎   | 628/1000 [24:49<14:42,  2.37s/it][Succeeded / Failed / Skipped / Total] 462 / 148 / 18 / 628:  63%|██████▎   | 629/1000 [24:49<14:38,  2.37s/it][Succeeded / Failed / Skipped / Total] 462 / 149 / 18 / 629:  63%|██████▎   | 629/1000 [24:49<14:38,  2.37s/it][Succeeded / Failed / Skipped / Total] 463 / 149 / 18 / 630:  63%|██████▎   | 630/1000 [24:49<14:34,  2.36s/it][Succeeded / Failed / Skipped / Total] 463 / 149 / 18 / 630:  63%|██████▎   | 631/1000 [24:50<14:31,  2.36s/it][Succeeded / Failed / Skipped / Total] 464 / 149 / 18 / 631:  63%|██████▎   | 631/1000 [24:50<14:31,  2.36s/it]Checks if the class array is assignable to the specified class array . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[isAssignable]] ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == "False" != "False" ) { return "False" != "False" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[adaeastaplex]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[adaeastaplex]] ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == "False" != "False" ) { return "False" != "False" ; } } return "[[liar]]" == "[[liar]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 626 ---------------------------------------------
Print T . --> Maps t to canvas --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[canvas]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[canvas]] . class ) ) { return conversion . convert ( t , [[canvas]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 627 ---------------------------------------------
This method is called when an EntityManager is started . --> [[[FAILED]]]

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[zurmacoc]] ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 628 ---------------------------------------------
Print a field --> Print an array --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > [[array]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 629 ---------------------------------------------
Parse the given text into an object of type T . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[т]] > [[т]] parse ( String text , Class < [[т]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 630 ---------------------------------------------
Convert an array of Objects to a list of Objects . --> demallerantolrup an array of Objects --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[demallerantolrupance]] ( Object [ ] [[lines]] ) { if ( [[lines]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[lines]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 631 ---------------------------------------------
Returns the value of the field . --> Parse the given text and return the art object . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[art]] > [[art]] parse ( Field field , String text ) { return ( [[art]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 632 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 465 / 149 / 18 / 632:  63%|██████▎   | 632/1000 [24:53<14:29,  2.36s/it][Succeeded / Failed / Skipped / Total] 465 / 149 / 18 / 632:  63%|██████▎   | 633/1000 [24:53<14:25,  2.36s/it][Succeeded / Failed / Skipped / Total] 465 / 150 / 18 / 633:  63%|██████▎   | 633/1000 [24:53<14:25,  2.36s/it][Succeeded / Failed / Skipped / Total] 466 / 150 / 18 / 634:  63%|██████▎   | 634/1000 [24:57<14:24,  2.36s/it][Succeeded / Failed / Skipped / Total] 466 / 150 / 18 / 634:  64%|██████▎   | 635/1000 [24:58<14:21,  2.36s/it][Succeeded / Failed / Skipped / Total] 467 / 150 / 18 / 635:  64%|██████▎   | 635/1000 [24:58<14:21,  2.36s/it][Succeeded / Failed / Skipped / Total] 468 / 150 / 18 / 636:  64%|██████▎   | 636/1000 [25:05<14:21,  2.37s/it][Succeeded / Failed / Skipped / Total] 468 / 150 / 18 / 636:  64%|██████▎   | 637/1000 [25:06<14:18,  2.36s/it][Succeeded / Failed / Skipped / Total] 469 / 150 / 18 / 637:  64%|██████▎   | 637/1000 [25:06<14:18,  2.36s/it]Returns a JSON representation of errors as a JSON object . --> on assarusoon --> Socre: 1.0

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[messages]] = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; [[messages]] . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { [[messages]] . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , [[messages]] ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[onssarusoon]] ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[programs]] = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; [[programs]] . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { [[programs]] . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , [[programs]] ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 633 ---------------------------------------------
Print the given type descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[album]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[album]] . class ) ) ) { return ( [[album]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[album]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[album]] . class ) ) { return conversion . convert ( t , [[album]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 634 ---------------------------------------------
Registers an optional source type . --> Registers the conversion . --> Socre: 1.0

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor [[targetType]] ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor [[baset]] ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 635 ---------------------------------------------
Selects the nodes for the specified node . --> designconds of a directory --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object node ) { return [[selectNodes]] ( path , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[designconds]] ( String path , Object node ) { return [[designconds]] ( path , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 636 ---------------------------------------------
Returns a MappedWebSocketAcceptor for a given type . --> Return a MappedWebSocketAcceptor --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , Out > MappedWebSocketAcceptor < [[In]] , Out > json ( Class < [[In]] > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < [[a]] , Out > MappedWebSocketAcceptor < [[a]] , Out > json ( Class < [[a]] > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 637 ---------------------------------------------
Convert an array to a Seq . --> Allocates haseqa --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] [[array]] ) { return [[toSeq]] ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[haseqa]] ( T [ ] [[add]] ) { return [[haseqa]] ( java . util . Arrays . asList ( [[add]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 638 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 470 / 150 / 18 / 638:  64%|██████▍   | 638/1000 [25:06<14:14,  2.36s/it][Succeeded / Failed / Skipped / Total] 470 / 150 / 18 / 638:  64%|██████▍   | 639/1000 [25:09<14:12,  2.36s/it][Succeeded / Failed / Skipped / Total] 470 / 151 / 18 / 639:  64%|██████▍   | 639/1000 [25:09<14:12,  2.36s/it][Succeeded / Failed / Skipped / Total] 471 / 151 / 18 / 640:  64%|██████▍   | 640/1000 [25:13<14:11,  2.37s/it][Succeeded / Failed / Skipped / Total] 471 / 151 / 18 / 640:  64%|██████▍   | 641/1000 [25:16<14:09,  2.37s/it][Succeeded / Failed / Skipped / Total] 472 / 151 / 18 / 641:  64%|██████▍   | 641/1000 [25:16<14:09,  2.37s/it][Succeeded / Failed / Skipped / Total] 472 / 152 / 18 / 642:  64%|██████▍   | 642/1000 [25:17<14:06,  2.36s/it][Succeeded / Failed / Skipped / Total] 472 / 152 / 18 / 642:  64%|██████▍   | 643/1000 [25:18<14:03,  2.36s/it][Succeeded / Failed / Skipped / Total] 472 / 153 / 18 / 643:  64%|██████▍   | 643/1000 [25:18<14:03,  2.36s/it][Succeeded / Failed / Skipped / Total] 472 / 154 / 18 / 644:  64%|██████▍   | 644/1000 [25:18<13:59,  2.36s/it][Succeeded / Failed / Skipped / Total] 472 / 154 / 18 / 644:  64%|██████▍   | 645/1000 [25:18<13:55,  2.35s/it][Succeeded / Failed / Skipped / Total] 473 / 154 / 18 / 645:  64%|██████▍   | 645/1000 [25:18<13:55,  2.35s/it]Converts java . util . List to Java converter . --> Decodes the given scale --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[buspeق]] ( java . util . List < T > [[scale]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[scale]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 639 ---------------------------------------------
Create a Seq from the array . --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[avdargged]] ( T ... [[lists]] ) { return toSeq ( [[lists]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 640 ---------------------------------------------
Checks if the given object is accessible . --> Checks to see if the given object is a valid executable --> Socre: 1.0

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "[[False]]" != "[[False]]" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "True" == "True" ) ; return "True" == "True" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "[[contrary]]" != "[[contrary]]" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "True" == "True" ) ; return "True" == "True" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 641 ---------------------------------------------
Get the cost of a primitive type . --> getPrimitive promotion cost --> Socre: 1.0

[[[[Adv]]]]: private static float getPrimitivePromotionCost ( final Class < ? > [[srcClass]] , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = [[srcClass]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float getPrimitivePromotionCost ( final Class < ? > [[swwcther]] , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = [[swwcther]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 642 ---------------------------------------------
Encode a cookie --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String [[value]] = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , [[value]] ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , [[value]] ) ; } else { add ( buf , name , [[value]] ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String [[designation]] = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , [[designation]] ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , [[designation]] ) ; } else { add ( buf , name , [[designation]] ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 643 ---------------------------------------------
Registers a formatter . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[cantens]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 644 ---------------------------------------------
Computes a single merge strategy . --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , [[FlowIn]] , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < [[FlowIn]] , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > [[mergeStrategy]] , Flow < [[FlowIn]] , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < [[FlowIn]] , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , [[linein]] , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < [[linein]] , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > [[unworkstiless]] , Flow < [[linein]] , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < [[linein]] , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 645 ---------------------------------------------
Returns the cost of the given executable array . --> Helper function to create a temporary location --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[aparaperlikensisdeliveritcep]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
[Succeeded / Failed / Skipped / Total] 474 / 154 / 18 / 646:  65%|██████▍   | 646/1000 [25:22<13:54,  2.36s/it][Succeeded / Failed / Skipped / Total] 474 / 154 / 18 / 646:  65%|██████▍   | 647/1000 [25:23<13:51,  2.36s/it][Succeeded / Failed / Skipped / Total] 475 / 154 / 18 / 647:  65%|██████▍   | 647/1000 [25:23<13:51,  2.36s/it][Succeeded / Failed / Skipped / Total] 475 / 155 / 18 / 648:  65%|██████▍   | 648/1000 [25:28<13:50,  2.36s/it][Succeeded / Failed / Skipped / Total] 475 / 155 / 18 / 648:  65%|██████▍   | 649/1000 [25:31<13:48,  2.36s/it][Succeeded / Failed / Skipped / Total] 476 / 155 / 18 / 649:  65%|██████▍   | 649/1000 [25:31<13:48,  2.36s/it][Succeeded / Failed / Skipped / Total] 477 / 155 / 18 / 650:  65%|██████▌   | 650/1000 [25:32<13:45,  2.36s/it][Succeeded / Failed / Skipped / Total] 477 / 155 / 18 / 650:  65%|██████▌   | 651/1000 [25:32<13:41,  2.35s/it][Succeeded / Failed / Skipped / Total] 477 / 155 / 19 / 651:  65%|██████▌   | 651/1000 [25:32<13:41,  2.35s/it]--------------------------------------------- Result 646 ---------------------------------------------
Gets the keys . --> Return a String by keys and arguments --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String [[by]] ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 647 ---------------------------------------------
Creates a histogram from the given arrays . --> Creates an empty array --> Socre: 1.0

[[[[Adv]]]]: public static ParallelSorter create ( Object [ ] arrays ) { Generator [[gen]] = new Generator ( ) ; [[gen]] . setArrays ( arrays ) ; return [[gen]] . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter create ( Object [ ] arrays ) { Generator [[draw]] = new Generator ( ) ; [[draw]] . setArrays ( arrays ) ; return [[draw]] . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 648 ---------------------------------------------
Creates a new WebSocket message . --> [[[FAILED]]]

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[grimcodutan]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[grimcodutan]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 649 ---------------------------------------------
Returns the value at the specified key . --> Convenience method for generating messages --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String key , Object ... [[args]] ) { return messagesApi . get ( lang , key , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[where]] ( String key , Object ... [[8gin]] ) { return messagesApi . get ( lang , key , [[8gin]] ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 650 ---------------------------------------------
Cast the Type to the Type --> Performs cast . --> Socre: 1.0

[[[[Adv]]]]: public void cast_numeric ( Type from , Type [[to]] ) { if ( from != [[to]] ) { if ( from == Type . DOUBLE_TYPE ) { if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else if ( from == Type . LONG_TYPE ) { if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else { if ( [[to]] == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( [[to]] == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( [[to]] == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void cast_numeric ( Type from , Type [[a]] ) { if ( from != [[a]] ) { if ( from == Type . DOUBLE_TYPE ) { if ( [[a]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( [[a]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , [[a]] ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( [[a]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( [[a]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , [[a]] ) ; } } else if ( from == Type . LONG_TYPE ) { if ( [[a]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( [[a]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , [[a]] ) ; } } else { if ( [[a]] == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( [[a]] == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( [[a]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( [[a]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( [[a]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( [[a]] == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 651 ---------------------------------------------
Visits a Java field . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 652 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 478 / 155 / 19 / 652:  65%|██████▌   | 652/1000 [25:37<13:40,  2.36s/it][Succeeded / Failed / Skipped / Total] 478 / 155 / 19 / 652:  65%|██████▌   | 653/1000 [25:37<13:36,  2.35s/it][Succeeded / Failed / Skipped / Total] 479 / 155 / 19 / 653:  65%|██████▌   | 653/1000 [25:37<13:36,  2.35s/it][Succeeded / Failed / Skipped / Total] 480 / 155 / 19 / 654:  65%|██████▌   | 654/1000 [25:38<13:34,  2.35s/it][Succeeded / Failed / Skipped / Total] 480 / 155 / 19 / 654:  66%|██████▌   | 655/1000 [25:42<13:32,  2.35s/it][Succeeded / Failed / Skipped / Total] 481 / 155 / 19 / 655:  66%|██████▌   | 655/1000 [25:42<13:32,  2.35s/it][Succeeded / Failed / Skipped / Total] 481 / 156 / 19 / 656:  66%|██████▌   | 656/1000 [25:43<13:29,  2.35s/it][Succeeded / Failed / Skipped / Total] 481 / 156 / 19 / 656:  66%|██████▌   | 657/1000 [25:45<13:26,  2.35s/it][Succeeded / Failed / Skipped / Total] 482 / 156 / 19 / 657:  66%|██████▌   | 657/1000 [25:45<13:26,  2.35s/it][Succeeded / Failed / Skipped / Total] 483 / 156 / 19 / 658:  66%|██████▌   | 658/1000 [25:49<13:25,  2.35s/it][Succeeded / Failed / Skipped / Total] 483 / 156 / 19 / 658:  66%|██████▌   | 659/1000 [25:51<13:22,  2.35s/it]Loads the argument at the given index . --> load_arg with given xl --> Socre: 1.0

[[[[Adv]]]]: public void load_arg ( int [[index]] ) { load_local ( state . argumentTypes [ [[index]] ] , state . localOffset + skipArgs ( [[index]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void load_arg ( int [[xl]] ) { load_local ( state . argumentTypes [ [[xl]] ] , state . localOffset + skipArgs ( [[xl]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 653 ---------------------------------------------
Chooses a GBer . --> at index et hi --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int index , int [[lo]] , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( [[lo]] , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[anunih]] ( int index , int [[et]] , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( [[et]] , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 654 ---------------------------------------------
Create a Database instance --> dewaroms implementation --> Socre: 1.0

[[[[Adv]]]]: public static Database [[createFrom]] ( String driver , String url , Map < String , ? extends Object > [[config]] ) { return [[createFrom]] ( "default" , driver , url , [[config]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[dewaroms]] ( String driver , String url , Map < String , ? extends Object > [[delix]] ) { return [[dewaroms]] ( "default" , driver , url , [[delix]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 655 ---------------------------------------------
Merges the specified comparator with the specified comparator --> fusionreees --> Socre: 1.0

[[[[Adv]]]]: public void [[mergeSort]] ( int index , int lo , int hi , Comparator [[cmp]] ) { chooseComparer ( index , [[cmp]] ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[fusionreee]] ( int index , int lo , int hi , Comparator [[cvm]] ) { chooseComparer ( index , [[cvm]] ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 656 ---------------------------------------------
Determines whether the type is a primitive type . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[zero_or_null]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[ingvirtualbytheplus]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 657 ---------------------------------------------
Unbox the given type . --> unxoulobant a Type --> Socre: 1.0

[[[[Adv]]]]: public void [[unbox_or_zero]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void [[unxoustheanant]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 658 ---------------------------------------------
null - safe method --> nullcmp method --> Socre: 1.0

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label [[oneNullHelper]] = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( [[oneNullHelper]] ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( [[oneNullHelper]] ) ; e . goTo ( end ) ; e . mark ( [[oneNullHelper]] ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label [[onoleanlarhld]] = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( [[onoleanlarhld]] ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( [[onoleanlarhld]] ) ; e . goTo ( end ) ; e . mark ( [[onoleanlarhld]] ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 659 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 484 / 156 / 19 / 659:  66%|██████▌   | 659/1000 [25:51<13:22,  2.35s/it][Succeeded / Failed / Skipped / Total] 484 / 156 / 20 / 660:  66%|██████▌   | 660/1000 [25:51<13:19,  2.35s/it][Succeeded / Failed / Skipped / Total] 484 / 156 / 20 / 660:  66%|██████▌   | 661/1000 [25:53<13:16,  2.35s/it][Succeeded / Failed / Skipped / Total] 485 / 156 / 20 / 661:  66%|██████▌   | 661/1000 [25:53<13:16,  2.35s/it]Process a CodeEmitter . --> industrialifenc Implementation --> Socre: 1.0

[[[[Adv]]]]: public static void [[process_array]] ( CodeEmitter e , Type type , ProcessArrayCallback [[callback]] ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; [[callback]] . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void [[industrialifenclave]] ( CodeEmitter e , Type type , ProcessArrayCallback [[calwindow]] ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; [[calwindow]] . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 660 ---------------------------------------------
Process a field name . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 661 ---------------------------------------------
Convenience method for serialization . --> catchampounds method --> Socre: 0.9999999999820136

[[[[Adv]]]]: public static void [[getMethods]] ( Class superclass , Class [ ] interfaces , List methods ) { [[getMethods]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[catchampounds]] ( Class superclass , Class [ ] interfaces , List methods ) { [[catchampounds]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 662 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 485 / 157 / 20 / 662:  66%|██████▌   | 662/1000 [25:54<13:13,  2.35s/it][Succeeded / Failed / Skipped / Total] 485 / 157 / 20 / 662:  66%|██████▋   | 663/1000 [25:55<13:10,  2.35s/it][Succeeded / Failed / Skipped / Total] 485 / 158 / 20 / 663:  66%|██████▋   | 663/1000 [25:55<13:10,  2.35s/it][Succeeded / Failed / Skipped / Total] 485 / 158 / 21 / 664:  66%|██████▋   | 664/1000 [25:55<13:07,  2.34s/it][Succeeded / Failed / Skipped / Total] 485 / 158 / 21 / 664:  66%|██████▋   | 665/1000 [25:56<13:03,  2.34s/it][Succeeded / Failed / Skipped / Total] 486 / 158 / 21 / 665:  66%|██████▋   | 665/1000 [25:56<13:03,  2.34s/it]Registers the given type descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Annotation]] , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Annotation]] > annotationType = ( Class < ? extends [[Annotation]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[basedicatory]] , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[basedicatory]] > annotationType = ( Class < ? extends [[basedicatory]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 663 ---------------------------------------------
Invokes the method . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[invoke]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[enteringruwl]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo [[abh]] = fastClassInfo ; return [[abh]] . f1 . invoke ( [[abh]] . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 664 ---------------------------------------------
Find methods . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 665 ---------------------------------------------
Sets the superclass . --> tes myigerport --> Socre: 1.0

[[[[Adv]]]]: public void [[setSuperclass]] ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . superclass = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void [[tesuigerport]] ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . superclass = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 666 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 486 / 159 / 21 / 666:  67%|██████▋   | 666/1000 [26:03<13:04,  2.35s/it][Succeeded / Failed / Skipped / Total] 486 / 159 / 21 / 666:  67%|██████▋   | 667/1000 [26:04<13:00,  2.34s/it][Succeeded / Failed / Skipped / Total] 487 / 159 / 21 / 667:  67%|██████▋   | 667/1000 [26:04<13:00,  2.34s/it][Succeeded / Failed / Skipped / Total] 488 / 159 / 21 / 668:  67%|██████▋   | 668/1000 [26:08<12:59,  2.35s/it][Succeeded / Failed / Skipped / Total] 488 / 159 / 21 / 668:  67%|██████▋   | 669/1000 [26:11<12:57,  2.35s/it][Succeeded / Failed / Skipped / Total] 489 / 159 / 21 / 669:  67%|██████▋   | 669/1000 [26:11<12:57,  2.35s/it][Succeeded / Failed / Skipped / Total] 489 / 160 / 21 / 670:  67%|██████▋   | 670/1000 [26:11<12:54,  2.35s/it][Succeeded / Failed / Skipped / Total] 489 / 160 / 21 / 670:  67%|██████▋   | 671/1000 [26:12<12:50,  2.34s/it][Succeeded / Failed / Skipped / Total] 490 / 160 / 21 / 671:  67%|██████▋   | 671/1000 [26:12<12:50,  2.34s/it][Succeeded / Failed / Skipped / Total] 491 / 160 / 21 / 672:  67%|██████▋   | 672/1000 [26:12<12:47,  2.34s/it][Succeeded / Failed / Skipped / Total] 491 / 160 / 21 / 672:  67%|██████▋   | 673/1000 [26:13<12:44,  2.34s/it]Adds a method . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[add]] ( Method [[method]] ) { [[add]] ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[access]] ( Method [[client]] ) { [[access]] ( ReflectUtils . getSignature ( [[client]] ) , ReflectUtils . getExceptionTypes ( [[client]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 667 ---------------------------------------------
Filters a list of constructors . --> canvaslikedsrages --> Socre: 1.0

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class [[sc]] , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( [[sc]] , "[[True]]" == "[[True]]" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[sc]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[canvaslikedsrages]] ( Class [[abs]] , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( [[abs]] , "[[again]]" == "[[again]]" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[abs]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 668 ---------------------------------------------
Reads a string . --> pageomix method --> Socre: 1.0

[[[[Adv]]]]: public static String [[readString]] ( final Path [[path]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[path]] , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String [[pageomix]] ( final Path [[read]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[read]] , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 669 ---------------------------------------------
Sets the naming policy . --> Fix public staticfoicyi --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy [[namingPolicy]] ) { if ( [[namingPolicy]] == null ) [[namingPolicy]] = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = [[namingPolicy]] ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[fixdatfoicyi]] ( NamingPolicy [[adoptionfinizi]] ) { if ( [[adoptionfinizi]] == null ) [[adoptionfinizi]] = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = [[adoptionfinizi]] ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 670 ---------------------------------------------
cardinality . --> [[[FAILED]]]

[[[[Adv]]]]: public int cardinality ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int cardinality ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 671 ---------------------------------------------
Returns the cost of the given class . --> callvercutstrarvraltricant --> Socre: 1.0

[[[[Adv]]]]: private static float [[getObjectTransformationCost]] ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float [[cost]] = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is [[null]], we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { [[cost]] += 1.5f ; } return [[cost]] ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float [[callvercutstrarvraltricant]] ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float [[expensive]] = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is [[blank]], we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { [[expensive]] += 1.5f ; } return [[expensive]] ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 672 ---------------------------------------------
Resolves all the classes . --> Transforms this class into a map --> Socre: 1.0

[[[[Adv]]]]: public Map [[resolveAll]] ( ) { Map resolved = new HashMap ( ) ; for ( Iterator [[entryIter]] = declToBridge . entrySet ( ) . iterator ( ) ; [[entryIter]] . hasNext ( ) ; ) { Map . Entry [[entry]] = ( Map . Entry ) [[entryIter]] . next ( ) ; Class owner = ( Class ) [[entry]] . getKey ( ) ; Set bridges = ( Set ) [[entry]] . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map [[radefront]] ( ) { Map resolved = new HashMap ( ) ; for ( Iterator [[oma]] = declToBridge . entrySet ( ) . iterator ( ) ; [[oma]] . hasNext ( ) ; ) { Map . Entry [[entries]] = ( Map . Entry ) [[oma]] . next ( ) ; Class owner = ( Class ) [[entries]] . getKey ( ) ; Set bridges = ( Set ) [[entries]] . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 673 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 492 / 160 / 21 / 673:  67%|██████▋   | 673/1000 [26:13<12:44,  2.34s/it][Succeeded / Failed / Skipped / Total] 493 / 160 / 21 / 674:  67%|██████▋   | 674/1000 [26:15<12:41,  2.34s/it][Succeeded / Failed / Skipped / Total] 493 / 160 / 21 / 674:  68%|██████▊   | 675/1000 [26:16<12:39,  2.34s/it][Succeeded / Failed / Skipped / Total] 493 / 161 / 21 / 675:  68%|██████▊   | 675/1000 [26:16<12:39,  2.34s/it][Succeeded / Failed / Skipped / Total] 494 / 161 / 21 / 676:  68%|██████▊   | 676/1000 [26:17<12:35,  2.33s/it][Succeeded / Failed / Skipped / Total] 494 / 161 / 21 / 676:  68%|██████▊   | 677/1000 [26:19<12:33,  2.33s/it][Succeeded / Failed / Skipped / Total] 495 / 161 / 21 / 677:  68%|██████▊   | 677/1000 [26:19<12:33,  2.33s/it][Succeeded / Failed / Skipped / Total] 495 / 162 / 21 / 678:  68%|██████▊   | 678/1000 [26:21<12:31,  2.33s/it][Succeeded / Failed / Skipped / Total] 495 / 162 / 21 / 678:  68%|██████▊   | 679/1000 [26:22<12:27,  2.33s/it][Succeeded / Failed / Skipped / Total] 496 / 162 / 21 / 679:  68%|██████▊   | 679/1000 [26:22<12:27,  2.33s/it][Succeeded / Failed / Skipped / Total] 497 / 162 / 21 / 680:  68%|██████▊   | 680/1000 [26:22<12:24,  2.33s/it][Succeeded / Failed / Skipped / Total] 497 / 162 / 21 / 680:  68%|██████▊   | 681/1000 [26:23<12:21,  2.32s/it][Succeeded / Failed / Skipped / Total] 497 / 163 / 21 / 681:  68%|██████▊   | 681/1000 [26:23<12:21,  2.32s/it][Succeeded / Failed / Skipped / Total] 498 / 163 / 21 / 682:  68%|██████▊   | 682/1000 [26:23<12:18,  2.32s/it][Succeeded / Failed / Skipped / Total] 498 / 163 / 21 / 682:  68%|██████▊   | 683/1000 [26:26<12:16,  2.32s/it][Succeeded / Failed / Skipped / Total] 498 / 164 / 21 / 683:  68%|██████▊   | 683/1000 [26:26<12:16,  2.32s/it][Succeeded / Failed / Skipped / Total] 498 / 165 / 21 / 684:  68%|██████▊   | 684/1000 [26:26<12:13,  2.32s/it][Succeeded / Failed / Skipped / Total] 498 / 165 / 21 / 684:  68%|██████▊   | 685/1000 [26:28<12:10,  2.32s/it]Create a new HttpRequest with the given destination . --> Create new proxy connects --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[connect]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest [[connects]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 674 ---------------------------------------------
Sets the host . --> Set the response body --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . host = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[neighbor]] ( final String [[server]] ) { this . host = [[neighbor]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[neighbor]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 675 ---------------------------------------------
Resolve a child path . --> [[[FAILED]]]

[[[[Adv]]]]: public static Path [[resolve]] ( final Path base , String [[child]] ) { if ( StringUtil . startsWithChar ( [[child]] , File . separatorChar ) ) { [[child]] = [[child]] . substring ( 1 ) ; } return base . resolve ( [[child]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[commit]] ( final Path base , String [[teacher]] ) { if ( StringUtil . startsWithChar ( [[teacher]] , File . separatorChar ) ) { [[teacher]] = [[teacher]] . substring ( 1 ) ; } return base . resolve ( [[teacher]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 676 ---------------------------------------------
Create a PUT request --> Create HttpRequest host with given destination --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[host]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 677 ---------------------------------------------
Create a DELETE request . --> Create an empty HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[elte]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 678 ---------------------------------------------
Creates a new HttpRequest with the given destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[hat]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 679 ---------------------------------------------
Create a new HTTP request --> Collect HttpRequest from source String --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[collect]] ( final String [[source]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[source]] ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 680 ---------------------------------------------
Creates a new request trace . --> Create an instance of HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[run]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 681 ---------------------------------------------
Create a new HttpRequest with the given destination string . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[neighbor]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 682 ---------------------------------------------
Create a new HttpRequest . --> Create ailot client --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[create]] ( final String [[method]] , final String destination ) { return new HttpRequest ( ) . [[method]] ( [[method]] . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest [[pilot]] ( final String [[client]] , final String destination ) { return new HttpRequest ( ) . [[client]] ( [[client]] . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 683 ---------------------------------------------
Create OPTIONS client options . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[vs]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 684 ---------------------------------------------
Creates a HEAD request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[session]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 685 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 499 / 165 / 21 / 685:  68%|██████▊   | 685/1000 [26:28<12:10,  2.32s/it][Succeeded / Failed / Skipped / Total] 500 / 165 / 21 / 686:  69%|██████▊   | 686/1000 [26:29<12:07,  2.32s/it][Succeeded / Failed / Skipped / Total] 500 / 165 / 21 / 686:  69%|██████▊   | 687/1000 [26:29<12:04,  2.31s/it][Succeeded / Failed / Skipped / Total] 500 / 166 / 21 / 687:  69%|██████▊   | 687/1000 [26:29<12:04,  2.31s/it][Succeeded / Failed / Skipped / Total] 501 / 166 / 21 / 688:  69%|██████▉   | 688/1000 [26:30<12:01,  2.31s/it][Succeeded / Failed / Skipped / Total] 501 / 166 / 21 / 688:  69%|██████▉   | 689/1000 [26:34<11:59,  2.31s/it][Succeeded / Failed / Skipped / Total] 502 / 166 / 21 / 689:  69%|██████▉   | 689/1000 [26:34<11:59,  2.31s/it][Succeeded / Failed / Skipped / Total] 503 / 166 / 21 / 690:  69%|██████▉   | 690/1000 [26:36<11:57,  2.31s/it][Succeeded / Failed / Skipped / Total] 503 / 166 / 21 / 690:  69%|██████▉   | 691/1000 [26:37<11:54,  2.31s/it][Succeeded / Failed / Skipped / Total] 504 / 166 / 21 / 691:  69%|██████▉   | 691/1000 [26:37<11:54,  2.31s/it][Succeeded / Failed / Skipped / Total] 505 / 166 / 21 / 692:  69%|██████▉   | 692/1000 [26:41<11:52,  2.31s/it][Succeeded / Failed / Skipped / Total] 505 / 166 / 21 / 692:  69%|██████▉   | 693/1000 [26:41<11:49,  2.31s/it][Succeeded / Failed / Skipped / Total] 505 / 167 / 21 / 693:  69%|██████▉   | 693/1000 [26:41<11:49,  2.31s/it][Succeeded / Failed / Skipped / Total] 506 / 167 / 21 / 694:  69%|██████▉   | 694/1000 [26:41<11:46,  2.31s/it][Succeeded / Failed / Skipped / Total] 506 / 167 / 21 / 694:  70%|██████▉   | 695/1000 [26:46<11:45,  2.31s/it]Adds the query map . --> Perform a query --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[entry]] : queryMap . entrySet ( ) ) { query . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[application]] : queryMap . entrySet ( ) ) { query . add ( [[application]] . getKey ( ) , [[application]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 686 ---------------------------------------------
Set the request path . --> Add an attribute --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[path]] ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[pipeline]] ( String [[v]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 687 ---------------------------------------------
Gets the query . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[jamiecory]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 688 ---------------------------------------------
Sets the Cookie list . --> Set cookie types --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder [[cookieString]] = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[cookieString]] . append ( "; " ) ; } first = "False" != "False" ; [[cookieString]] . append ( cookie . getName ( ) ) ; [[cookieString]] . append ( ' ' ) ; [[cookieString]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[cookieString]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder [[brickshaing]] = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[brickshaing]] . append ( "; " ) ; } first = "False" != "False" ; [[brickshaing]] . append ( cookie . getName ( ) ) ; [[brickshaing]] . append ( ' ' ) ; [[brickshaing]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[brickshaing]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 689 ---------------------------------------------
Add authentication . --> Set username and password --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[advanceditrideunicure]] ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 690 ---------------------------------------------
Sends and receive a function . --> Send and receive request --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[d]] > [[d]] sendAndReceive ( final Function < HttpResponse , [[d]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 691 ---------------------------------------------
Set query string . --> Set if decode is set --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest queryString ( final String [[queryString]] , final boolean decode ) { this . [[query]] = HttpUtil . parseQuery ( queryString , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest queryString ( final String [[destinationtrry]] , final boolean decode ) { this . [[m]] = HttpUtil . parseQuery ( queryString , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 692 ---------------------------------------------
Returns the host url . --> Get ausopenal --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand [[url]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[url]] . append ( protocol ) ; [[url]] . append ( "://" ) ; } if ( host != null ) { [[url]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[url]] . append ( ' ' ) ; [[url]] . append ( port ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[ausopenal]] ( ) { StringBand [[aalet]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[aalet]] . append ( protocol ) ; [[aalet]] . append ( "://" ) ; } if ( host != null ) { [[aalet]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[aalet]] . append ( ' ' ) ; [[aalet]] . append ( port ) ; } return [[aalet]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 693 ---------------------------------------------
Return the current buffer . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected Buffer [[buffer]] ( final boolean [[fullRequest]] ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer [[of]] ( final boolean [[issewl]] ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 694 ---------------------------------------------
Sets the host header . --> This method will be called to start the operation --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String hostPort = this . [[host]] ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[allthorloadger]] ( ) { String hostPort = this . [[fore]] ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 695 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 507 / 167 / 21 / 695:  70%|██████▉   | 695/1000 [26:46<11:45,  2.31s/it][Succeeded / Failed / Skipped / Total] 508 / 167 / 21 / 696:  70%|██████▉   | 696/1000 [26:47<11:42,  2.31s/it][Succeeded / Failed / Skipped / Total] 508 / 167 / 21 / 696:  70%|██████▉   | 697/1000 [26:51<11:40,  2.31s/it][Succeeded / Failed / Skipped / Total] 509 / 167 / 21 / 697:  70%|██████▉   | 697/1000 [26:51<11:40,  2.31s/it][Succeeded / Failed / Skipped / Total] 510 / 167 / 21 / 698:  70%|██████▉   | 698/1000 [26:52<11:37,  2.31s/it][Succeeded / Failed / Skipped / Total] 510 / 167 / 21 / 698:  70%|██████▉   | 699/1000 [26:54<11:35,  2.31s/it][Succeeded / Failed / Skipped / Total] 511 / 167 / 21 / 699:  70%|██████▉   | 699/1000 [26:54<11:35,  2.31s/it][Succeeded / Failed / Skipped / Total] 512 / 167 / 21 / 700:  70%|███████   | 700/1000 [26:55<11:32,  2.31s/it][Succeeded / Failed / Skipped / Total] 512 / 167 / 21 / 700:  70%|███████   | 701/1000 [26:56<11:29,  2.31s/it][Succeeded / Failed / Skipped / Total] 513 / 167 / 21 / 701:  70%|███████   | 701/1000 [26:56<11:29,  2.31s/it][Succeeded / Failed / Skipped / Total] 514 / 167 / 21 / 702:  70%|███████   | 702/1000 [26:59<11:27,  2.31s/it][Succeeded / Failed / Skipped / Total] 514 / 167 / 21 / 702:  70%|███████   | 703/1000 [27:02<11:25,  2.31s/it][Succeeded / Failed / Skipped / Total] 515 / 167 / 21 / 703:  70%|███████   | 703/1000 [27:02<11:25,  2.31s/it]Collect the action filters . --> gatheredollrationfedlarson --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[gatheredollrationfedlarson]] ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 696 ---------------------------------------------
Add one parameter to the query . --> Add a new parameter --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final String name1 , final Object value1 , final Object ... [[parameters]] ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int [[i]] = 0 ; [[i]] < [[parameters]] . length ; [[i]] += 2 ) { String name = [[parameters]] [ [[i]] ] . toString ( ) ; String value = [[parameters]] [ [[i]] + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest query ( final String name1 , final Object value1 , final Object ... [[types]] ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int [[being]] = 0 ; [[being]] < [[types]] . length ; [[being]] += 2 ) { String name = [[types]] [ [[being]] ] . toString ( ) ; String value = [[types]] [ [[being]] + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 697 ---------------------------------------------
Sets the bean property . --> Declarative Services method for settingter --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[iestopposeapirtie]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 698 ---------------------------------------------
Collects all action split . --> F743 - 5 --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[dcollionsvanredoser]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 699 ---------------------------------------------
Collects all the actionResults . --> Doificioneddrawstilla --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[doificioneddrawstilla]] ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 700 ---------------------------------------------
Collect all interceptors . --> The compilationventreindrand applies --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > [[interceptorValues]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[interceptorValues]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[compilationventreindrandemptora]] ( ) { final Collection < ? extends ActionInterceptor > [[arrowdiways]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[arrowdiways]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 701 ---------------------------------------------
Extract a property from the string --> Exports a property --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[exportindsweartance]] ( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 702 ---------------------------------------------
Returns a writer for writing . --> printout is null --> Socre: 1.0

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[printout]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 703 ---------------------------------------------
Gets object reference . --> List all transaction active Available transaction --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[listripublictherfin]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 704 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 515 / 168 / 21 / 704:  70%|███████   | 704/1000 [27:02<11:22,  2.30s/it][Succeeded / Failed / Skipped / Total] 515 / 168 / 21 / 704:  70%|███████   | 705/1000 [27:03<11:19,  2.30s/it][Succeeded / Failed / Skipped / Total] 516 / 168 / 21 / 705:  70%|███████   | 705/1000 [27:03<11:19,  2.30s/it][Succeeded / Failed / Skipped / Total] 517 / 168 / 21 / 706:  71%|███████   | 706/1000 [27:05<11:16,  2.30s/it][Succeeded / Failed / Skipped / Total] 517 / 168 / 21 / 706:  71%|███████   | 707/1000 [27:11<11:16,  2.31s/it][Succeeded / Failed / Skipped / Total] 517 / 169 / 21 / 707:  71%|███████   | 707/1000 [27:11<11:16,  2.31s/it][Succeeded / Failed / Skipped / Total] 518 / 169 / 21 / 708:  71%|███████   | 708/1000 [27:12<11:13,  2.31s/it][Succeeded / Failed / Skipped / Total] 518 / 169 / 21 / 708:  71%|███████   | 709/1000 [27:12<11:10,  2.30s/it][Succeeded / Failed / Skipped / Total] 519 / 169 / 21 / 709:  71%|███████   | 709/1000 [27:12<11:10,  2.30s/it][Succeeded / Failed / Skipped / Total] 520 / 169 / 21 / 710:  71%|███████   | 710/1000 [27:15<11:08,  2.30s/it][Succeeded / Failed / Skipped / Total] 520 / 169 / 21 / 710:  71%|███████   | 711/1000 [27:15<11:04,  2.30s/it][Succeeded / Failed / Skipped / Total] 521 / 169 / 21 / 711:  71%|███████   | 711/1000 [27:15<11:04,  2.30s/it][Succeeded / Failed / Skipped / Total] 521 / 170 / 21 / 712:  71%|███████   | 712/1000 [27:17<11:02,  2.30s/it][Succeeded / Failed / Skipped / Total] 521 / 170 / 21 / 712:  71%|███████▏  | 713/1000 [27:21<11:00,  2.30s/it]Gets the value of the named property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < [[T]] > [[T]] getProperty ( final Object bean , final String name ) { BeanProperty [[beanProperty]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } else { try { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < [[e]] > [[e]] getProperty ( final Object bean , final String name ) { BeanProperty [[huscompieness]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[huscompieness]] ) ; return ( [[e]] ) getIndexProperty ( [[huscompieness]] ) ; } else { try { resolveNestedProperties ( [[huscompieness]] ) ; return ( [[e]] ) getIndexProperty ( [[huscompieness]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 705 ---------------------------------------------
Returns the length of the given handler . --> likeexramklednyh --> Socre: 1.0

[[[[Adv]]]]: static int [[getExceptionTableLength]] ( final Handler firstHandler ) { int length = 0 ; Handler [[handler]] = firstHandler ; while ( [[handler]] != null ) { length ++ ; [[handler]] = [[handler]] . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int [[likeexviewklednyh]] ( final Handler firstHandler ) { int length = 0 ; Handler [[source]] = firstHandler ; while ( [[source]] != null ) { length ++ ; [[source]] = [[source]] . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 706 ---------------------------------------------
Set the object reference . --> Print an annotation to the map --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String [[name]] , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , object ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[printtopnamesevent]] ( final String [[call]] , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[call]] , object ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 707 ---------------------------------------------
Lookup the object reference . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[lookupObject]] ( final String ref ) { Object [[value]] = getObjectReference ( ref ) ; if ( [[value]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return [[value]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[stingingforpack]] ( final String ref ) { Object [[relation]] = getObjectReference ( ref ) ; if ( [[relation]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return [[relation]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 708 ---------------------------------------------
Registers a hint . --> tadlikestore --> Socre: 1.0

[[[[Adv]]]]: public void [[registerHint]] ( final String hint ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( hint ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[tadliketa]] ( final String hint ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( hint ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 709 ---------------------------------------------
Registers a table reference . --> Make a plaincastcon mem --> Socre: 1.0

[[[[Adv]]]]: public void [[registerTableReference]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[plaincastcondict]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 710 ---------------------------------------------
Finds a table descriptor by column name . --> Check forreedos by given columnRef --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[ded]] = entry . getValue ( ) . desc ; if ( [[ded]] . findByPropertyName ( columnRef ) != null ) { return [[ded]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[checktreedosposeori_clthrowux]] ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[elb]] = entry . getValue ( ) . desc ; if ( [[elb]] . findByPropertyName ( columnRef ) != null ) { return [[elb]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 711 ---------------------------------------------
Serialize value . --> Serialize a date --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext jsonContext , final T [[value]] ) { if ( jsonContext . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext jsonContext , final T [[date]] ) { if ( jsonContext . pushValue ( [[date]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 712 ---------------------------------------------
Returns the descriptor for the given table . --> [[[FAILED]]]

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[getlandsptrper]] ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 713 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 522 / 170 / 21 / 713:  71%|███████▏  | 713/1000 [27:21<11:00,  2.30s/it][Succeeded / Failed / Skipped / Total] 523 / 170 / 21 / 714:  71%|███████▏  | 714/1000 [27:24<10:58,  2.30s/it][Succeeded / Failed / Skipped / Total] 523 / 170 / 21 / 714:  72%|███████▏  | 715/1000 [27:25<10:55,  2.30s/it][Succeeded / Failed / Skipped / Total] 524 / 170 / 21 / 715:  72%|███████▏  | 715/1000 [27:25<10:55,  2.30s/it][Succeeded / Failed / Skipped / Total] 525 / 170 / 21 / 716:  72%|███████▏  | 716/1000 [27:26<10:53,  2.30s/it][Succeeded / Failed / Skipped / Total] 525 / 170 / 21 / 716:  72%|███████▏  | 717/1000 [27:27<10:50,  2.30s/it][Succeeded / Failed / Skipped / Total] 526 / 170 / 21 / 717:  72%|███████▏  | 717/1000 [27:27<10:50,  2.30s/it]Gets the alias . --> Draw a scaler by scalerex --> Socre: 1.0

[[[[Adv]]]]: public String [[getTableAlias]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[drawardchampset]] ( final String [[scalerex]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[r]] = tableRefs . get ( [[scalerex]] ) ; return [[r]] == null ? null : [[r]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 714 ---------------------------------------------
Inject attribute names . --> dilpublicstribotthes --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectAttributes]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void [[dilpublicstribotthes]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 715 ---------------------------------------------
Inject parameters . --> This method is used to call the getanotanresos method --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectParameters]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void [[thenotanotresos]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 716 ---------------------------------------------
Converts a property name to column name --> Exports camel camel camel and camel case --> Socre: 1.0

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[exportprdetecamianocdnuolomp]] ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 717 ---------------------------------------------
lookup table reference . --> douet --> Socre: 1.0

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String [[tableRef]] ) { DbEntityDescriptor [[ded]] = getTableDescriptor ( [[tableRef]] ) ; if ( [[ded]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[tableRef]] ) ; } return [[ded]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[doultarereack]] ( final String [[hallrie]] ) { DbEntityDescriptor [[prow]] = getTableDescriptor ( [[hallrie]] ) ; if ( [[prow]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[hallrie]] ) ; } return [[prow]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 718 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 527 / 170 / 21 / 718:  72%|███████▏  | 718/1000 [27:28<10:47,  2.30s/it][Succeeded / Failed / Skipped / Total] 527 / 170 / 21 / 718:  72%|███████▏  | 719/1000 [27:30<10:45,  2.30s/it][Succeeded / Failed / Skipped / Total] 527 / 171 / 21 / 719:  72%|███████▏  | 719/1000 [27:30<10:45,  2.30s/it][Succeeded / Failed / Skipped / Total] 528 / 171 / 21 / 720:  72%|███████▏  | 720/1000 [27:31<10:42,  2.29s/it][Succeeded / Failed / Skipped / Total] 528 / 171 / 21 / 720:  72%|███████▏  | 721/1000 [27:33<10:39,  2.29s/it][Succeeded / Failed / Skipped / Total] 529 / 171 / 21 / 721:  72%|███████▏  | 721/1000 [27:33<10:39,  2.29s/it][Succeeded / Failed / Skipped / Total] 529 / 172 / 21 / 722:  72%|███████▏  | 722/1000 [27:36<10:37,  2.29s/it][Succeeded / Failed / Skipped / Total] 529 / 172 / 21 / 722:  72%|███████▏  | 723/1000 [27:36<10:34,  2.29s/it]Convert column name to property name --> Gets the upper case columnName --> Socre: 1.0

[[[[Adv]]]]: public String [[convertColumnNameToPropertyName]] ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String [[beucurinsttatoprupriscase]] ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 719 ---------------------------------------------
Create a new wrapper instance --> [[[FAILED]]]

[[[[Adv]]]]: protected < R [[extends]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R [[extending]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 720 ---------------------------------------------
Convert column name to column name --> Calculates the best nu nucleotide --> Socre: 1.0

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[tieerosolimenabe]] ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 721 ---------------------------------------------
Returns the value of the specified type . --> Gets the current eu instance --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[E]] > [[E]] prepareGetValue ( final T t , final Class < [[E]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[E]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[eu]] > [[eu]] prepareGetValue ( final T t , final Class < [[eu]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[eu]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 722 ---------------------------------------------
Removes a range from start to end . --> [[[FAILED]]]

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int [[rangeEnd]] = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int [[altent]] = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 723 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 530 / 172 / 21 / 723:  72%|███████▏  | 723/1000 [27:36<10:34,  2.29s/it][Succeeded / Failed / Skipped / Total] 531 / 172 / 21 / 724:  72%|███████▏  | 724/1000 [27:39<10:32,  2.29s/it][Succeeded / Failed / Skipped / Total] 531 / 172 / 21 / 724:  72%|███████▎  | 725/1000 [27:42<10:30,  2.29s/it][Succeeded / Failed / Skipped / Total] 531 / 173 / 21 / 725:  72%|███████▎  | 725/1000 [27:42<10:30,  2.29s/it][Succeeded / Failed / Skipped / Total] 531 / 174 / 21 / 726:  73%|███████▎  | 726/1000 [27:42<10:27,  2.29s/it][Succeeded / Failed / Skipped / Total] 531 / 174 / 21 / 726:  73%|███████▎  | 727/1000 [27:46<10:25,  2.29s/it][Succeeded / Failed / Skipped / Total] 532 / 174 / 21 / 727:  73%|███████▎  | 727/1000 [27:46<10:25,  2.29s/it][Succeeded / Failed / Skipped / Total] 533 / 174 / 21 / 728:  73%|███████▎  | 728/1000 [27:46<10:22,  2.29s/it][Succeeded / Failed / Skipped / Total] 533 / 174 / 21 / 728:  73%|███████▎  | 729/1000 [27:46<10:19,  2.29s/it][Succeeded / Failed / Skipped / Total] 534 / 174 / 21 / 729:  73%|███████▎  | 729/1000 [27:46<10:19,  2.29s/it]Inject multipart files . --> dilvvrappsportsfres --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectUploadedFiles]] ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] [[paramValues]] = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < [[paramValues]] . length ; j ++ ) { final FileUpload paramValue = [[paramValues]] [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { [[paramValues]] [ j ] = null ; } } } final Object value = ( [[paramValues]] . length == 1 ? [[paramValues]] [ 0 ] : [[paramValues]] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void [[dilvrappsportsfres]] ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] [[permedblgles]] = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < [[permedblgles]] . length ; j ++ ) { final FileUpload paramValue = [[permedblgles]] [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { [[permedblgles]] [ j ] = null ; } } } final Object value = ( [[permedblgles]] . length == 1 ? [[permedblgles]] [ 0 ] : [[permedblgles]] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 724 ---------------------------------------------
Returns the part of the filename . --> Return null if not found --> Socre: 1.0

[[[[Adv]]]]: private static String [[doGetPath]] ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String [[generalantlink]] ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 725 ---------------------------------------------
Returns all of the wrappers . --> [[[FAILED]]]

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > [[set]] = new HashSet <> ( wrappers . size ( ) ) ; [[set]] . addAll ( wrappers . values ( ) ) ; return [[set]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[fallell]] ( ) { final Set < T > [[run]] = new HashSet <> ( wrappers . size ( ) ) ; [[run]] . addAll ( wrappers . values ( ) ) ; return [[run]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 726 ---------------------------------------------
Sets the action config . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[extensions]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 727 ---------------------------------------------
Registers a component . --> Register a component --> Socre: 1.0

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > [[madvocComponent]] ) { Objects . requireNonNull ( [[madvocComponent]] ) ; madvocComponents . add ( ClassConsumer . of ( [[madvocComponent]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > [[baddionornonance]] ) { Objects . requireNonNull ( [[baddionornonance]] ) ; madvocComponents . add ( ClassConsumer . of ( [[baddionornonance]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 728 ---------------------------------------------
Start the WebApp . --> started WebApp --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[started]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 729 ---------------------------------------------
Resolve a wrapper class . --> Get a canvas --> Socre: 1.0

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T [[wrapper]] = lookup ( wrapperClassName ) ; if ( [[wrapper]] == null ) { [[wrapper]] = createWrapper ( wrapperClass ) ; initializeWrapper ( [[wrapper]] ) ; wrappers . put ( wrapperClassName , [[wrapper]] ) ; } return [[wrapper]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[canvas]] ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T [[dlside]] = lookup ( wrapperClassName ) ; if ( [[dlside]] == null ) { [[dlside]] = createWrapper ( wrapperClass ) ; initializeWrapper ( [[dlside]] ) ; wrappers . put ( wrapperClassName , [[dlside]] ) ; } return [[dlside]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 730 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 535 / 174 / 21 / 730:  73%|███████▎  | 730/1000 [27:48<10:17,  2.29s/it][Succeeded / Failed / Skipped / Total] 535 / 174 / 21 / 730:  73%|███████▎  | 731/1000 [27:49<10:14,  2.28s/it][Succeeded / Failed / Skipped / Total] 535 / 175 / 21 / 731:  73%|███████▎  | 731/1000 [27:49<10:14,  2.28s/it][Succeeded / Failed / Skipped / Total] 536 / 175 / 21 / 732:  73%|███████▎  | 732/1000 [27:52<10:12,  2.28s/it][Succeeded / Failed / Skipped / Total] 536 / 175 / 21 / 732:  73%|███████▎  | 733/1000 [27:53<10:09,  2.28s/it][Succeeded / Failed / Skipped / Total] 537 / 175 / 21 / 733:  73%|███████▎  | 733/1000 [27:53<10:09,  2.28s/it][Succeeded / Failed / Skipped / Total] 538 / 175 / 21 / 734:  73%|███████▎  | 734/1000 [27:58<10:08,  2.29s/it][Succeeded / Failed / Skipped / Total] 538 / 175 / 21 / 734:  74%|███████▎  | 735/1000 [27:59<10:05,  2.29s/it][Succeeded / Failed / Skipped / Total] 539 / 175 / 21 / 735:  74%|███████▎  | 735/1000 [27:59<10:05,  2.29s/it]Store a value . --> region query --> Socre: 1.0

[[[[Adv]]]]: public void [[storeValue]] ( final PreparedStatement st , final int [[index]] , final Object value , final int dbSqlType ) throws SQLException { T [[t]] = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , [[index]] , [[t]] , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void [[bookjoe]] ( final PreparedStatement st , final int [[edge]] , final Object value , final int dbSqlType ) throws SQLException { T [[τ]] = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , [[edge]] , [[τ]] , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 731 ---------------------------------------------
Return the separators of the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[ventrtriesmostraft]] ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 732 ---------------------------------------------
Sets the default annotation . --> Registers the action configuration --> Socre: 1.0

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[configurationrewultn]] ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 733 ---------------------------------------------
Create relative path . --> Get a file from the baselane --> Socre: 1.0

[[[[Adv]]]]: public static String [[relativePath]] ( final String [[targetPath]] , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( [[targetPath]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[asschedule]] ( final String [[baselane]] , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( [[baselane]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 734 ---------------------------------------------
Register the MadvocComponents . --> Register the Madrovepaomppirented --> Socre: 1.0

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[bitadrovepaomppirented]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 735 ---------------------------------------------
Adds the list of excluded entries . --> Exposed for testing --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... [[excludedEntries]] ) { for ( final String excludedEntry : [[excludedEntries]] ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... [[freedencerent]] ) { for ( final String excludedEntry : [[freedencerent]] ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 736 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 540 / 175 / 21 / 736:  74%|███████▎  | 736/1000 [28:02<10:03,  2.29s/it][Succeeded / Failed / Skipped / Total] 540 / 175 / 21 / 736:  74%|███████▎  | 737/1000 [28:04<10:01,  2.29s/it][Succeeded / Failed / Skipped / Total] 541 / 175 / 21 / 737:  74%|███████▎  | 737/1000 [28:04<10:01,  2.29s/it][Succeeded / Failed / Skipped / Total] 541 / 176 / 21 / 738:  74%|███████▍  | 738/1000 [28:15<10:01,  2.30s/it][Succeeded / Failed / Skipped / Total] 541 / 176 / 21 / 738:  74%|███████▍  | 739/1000 [28:17<09:59,  2.30s/it][Succeeded / Failed / Skipped / Total] 541 / 177 / 21 / 739:  74%|███████▍  | 739/1000 [28:17<09:59,  2.30s/it][Succeeded / Failed / Skipped / Total] 541 / 177 / 21 / 739:  74%|███████▍  | 740/1000 [28:17<09:56,  2.29s/it][Succeeded / Failed / Skipped / Total] 541 / 178 / 21 / 740:  74%|███████▍  | 740/1000 [28:17<09:56,  2.29s/it][Succeeded / Failed / Skipped / Total] 541 / 178 / 21 / 740:  74%|███████▍  | 741/1000 [28:17<09:53,  2.29s/it][Succeeded / Failed / Skipped / Total] 541 / 179 / 21 / 741:  74%|███████▍  | 741/1000 [28:17<09:53,  2.29s/it][Succeeded / Failed / Skipped / Total] 541 / 179 / 21 / 741:  74%|███████▍  | 742/1000 [28:18<09:50,  2.29s/it]Splits the given filename . --> split the given baseway --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] split ( final String [[filename]] ) { String [[prefix]] = getPrefix ( [[filename]] ) ; if ( [[prefix]] == null ) { [[prefix]] = StringPool . EMPTY ; } int [[lastSeparatorIndex]] = indexOfLastSeparator ( [[filename]] ) ; int lastExtensionIndex = indexOfExtension ( [[filename]] ) ; String path ; String baseName ; String extension ; if ( [[lastSeparatorIndex]] == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = [[filename]] . substring ( [[prefix]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = [[filename]] . substring ( [[prefix]] . length ( ) , lastExtensionIndex ) ; extension = [[filename]] . substring ( lastExtensionIndex + 1 ) ; } } else { path = [[filename]] . substring ( [[prefix]] . length ( ) , [[lastSeparatorIndex]] + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = [[filename]] . substring ( [[prefix]] . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = [[filename]] . substring ( [[prefix]] . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = [[filename]] . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { [[prefix]] , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] split ( final String [[baseway]] ) { String [[gloss]] = getPrefix ( [[baseway]] ) ; if ( [[gloss]] == null ) { [[gloss]] = StringPool . EMPTY ; } int [[iosseprasreledxi]] = indexOfLastSeparator ( [[baseway]] ) ; int lastExtensionIndex = indexOfExtension ( [[baseway]] ) ; String path ; String baseName ; String extension ; if ( [[iosseprasreledxi]] == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = [[baseway]] . substring ( [[gloss]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = [[baseway]] . substring ( [[gloss]] . length ( ) , lastExtensionIndex ) ; extension = [[baseway]] . substring ( lastExtensionIndex + 1 ) ; } } else { path = [[baseway]] . substring ( [[gloss]] . length ( ) , [[iosseprasreledxi]] + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = [[baseway]] . substring ( [[gloss]] . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = [[baseway]] . substring ( [[gloss]] . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = [[baseway]] . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { [[gloss]] , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 737 ---------------------------------------------
Sets the list of included jars to apply . --> Set the bannerdari string --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String includedJar : [[includedJars]] ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[bannerworthrs]] ( final String ... [[bannerdari]] ) { for ( final String includedJar : [[bannerdari]] ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 738 ---------------------------------------------
Starts the file . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[path]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[path]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[it]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[distance]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[distance]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 739 ---------------------------------------------
Sets the list of included entries . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... includedEntries ) { for ( final String [[includedEntry]] : includedEntries ) { rulesEntries . include ( [[includedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[rejectenceins]] ( final String ... includedEntries ) { for ( final String [[asultis]] : includedEntries ) { rulesEntries . include ( [[asultis]] ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 740 ---------------------------------------------
Returns the scope type for the specified scope class . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[parameter]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 741 ---------------------------------------------
Scan the given paths . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[scanned]] ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 742 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 542 / 179 / 21 / 742:  74%|███████▍  | 742/1000 [28:18<09:50,  2.29s/it][Succeeded / Failed / Skipped / Total] 542 / 179 / 21 / 742:  74%|███████▍  | 743/1000 [28:18<09:47,  2.29s/it][Succeeded / Failed / Skipped / Total] 542 / 180 / 21 / 743:  74%|███████▍  | 743/1000 [28:18<09:47,  2.29s/it][Succeeded / Failed / Skipped / Total] 542 / 180 / 21 / 743:  74%|███████▍  | 744/1000 [28:19<09:44,  2.28s/it][Succeeded / Failed / Skipped / Total] 543 / 180 / 21 / 744:  74%|███████▍  | 744/1000 [28:19<09:44,  2.28s/it][Succeeded / Failed / Skipped / Total] 543 / 180 / 21 / 744:  74%|███████▍  | 745/1000 [28:22<09:42,  2.29s/it][Succeeded / Failed / Skipped / Total] 543 / 181 / 21 / 745:  74%|███████▍  | 745/1000 [28:22<09:42,  2.29s/it][Succeeded / Failed / Skipped / Total] 543 / 181 / 21 / 745:  75%|███████▍  | 746/1000 [28:27<09:41,  2.29s/it][Succeeded / Failed / Skipped / Total] 544 / 181 / 21 / 746:  75%|███████▍  | 746/1000 [28:27<09:41,  2.29s/it][Succeeded / Failed / Skipped / Total] 544 / 181 / 21 / 746:  75%|███████▍  | 747/1000 [28:33<09:40,  2.29s/it][Succeeded / Failed / Skipped / Total] 545 / 181 / 21 / 747:  75%|███████▍  | 747/1000 [28:33<09:40,  2.29s/it][Succeeded / Failed / Skipped / Total] 545 / 181 / 21 / 747:  75%|███████▍  | 748/1000 [28:36<09:38,  2.29s/it][Succeeded / Failed / Skipped / Total] 546 / 181 / 21 / 748:  75%|███████▍  | 748/1000 [28:36<09:38,  2.29s/it][Succeeded / Failed / Skipped / Total] 546 / 181 / 21 / 748:  75%|███████▍  | 749/1000 [28:37<09:35,  2.29s/it][Succeeded / Failed / Skipped / Total] 546 / 182 / 21 / 749:  75%|███████▍  | 749/1000 [28:37<09:35,  2.29s/it][Succeeded / Failed / Skipped / Total] 546 / 182 / 21 / 749:  75%|███████▌  | 750/1000 [28:37<09:32,  2.29s/it]Scan class files . --> joval method for subclasses --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanClassPath]] ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String [[filePath]] = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( [[filePath]] , CLASS_FILE_EXT ) ) { scanClassFile ( [[filePath]] , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( [[filePath]] , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void [[jovalpie]] ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String [[calledpod]] = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( [[calledpod]] , CLASS_FILE_EXT ) ) { scanClassFile ( [[calledpod]] , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( [[calledpod]] , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 743 ---------------------------------------------
Sets the list of class excluded . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... excludedJars ) { for ( final String [[excludedJar]] : excludedJars ) { rulesJars . exclude ( [[excludedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[causevipersa]] ( final String ... excludedJars ) { for ( final String [[beder]] : excludedJars ) { rulesJars . exclude ( [[beder]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 744 ---------------------------------------------
Create a new JtxTransaction --> This method initializes the JtxTransaction --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction [[createNewTransaction]] ( final JtxTransactionMode tm , final Object [[scope]] , final boolean active ) { return new DbJtxTransaction ( this , tm , [[scope]] , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction [[reatenxrassabs]] ( final JtxTransactionMode tm , final Object [[scale]] , final boolean active ) { return new DbJtxTransaction ( this , tm , [[scale]] , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 745 ---------------------------------------------
Returns the bytecode signature of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class type ) { final String [[name]] = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[name]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[dieysmalantrtitult]] ( final Class type ) { final String [[call]] = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[call]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 746 ---------------------------------------------
Creates a new scope for the given class . --> dorushswsoteshorva s --> Socre: 1.0

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > [[madvocScopeConsumer]] ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; [[madvocScopeConsumer]] . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > [[dorushswsoteshorva]] ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; [[dorushswsoteshorva]] . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 747 ---------------------------------------------
Copy the BeanUtilBean --> copies this BeanUtilBean --> Socre: 1.0

[[[[Adv]]]]: public void [[copy]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void [[copies]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 748 ---------------------------------------------
Returns the MadvocScope for the given class . --> Set allScopes --> Socre: 1.0

[[[[Adv]]]]: protected MadvocScope [[getOrInitScope]] ( final Class < ? extends MadvocScope > [[madvocScopeType]] ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( [[madvocScopeType]] ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope [[setrowpscope]] ( final Class < ? extends MadvocScope > [[batrecustywy]] ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( [[batrecustywy]] ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 749 ---------------------------------------------
Creates a copy of the given object . --> [[[FAILED]]]

[[[[Adv]]]]: public static BeanCopy [[from]] ( final Object source ) { BeanCopy [[beanCopy]] = new BeanCopy ( source ) ; [[beanCopy]] . isSourceMap = source instanceof Map ; return [[beanCopy]] ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy [[anonymous]] ( final Object source ) { BeanCopy [[andimv]] = new BeanCopy ( source ) ; [[andimv]] . isSourceMap = source instanceof Map ; return [[andimv]] ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 750 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 547 / 182 / 21 / 750:  75%|███████▌  | 750/1000 [28:37<09:32,  2.29s/it][Succeeded / Failed / Skipped / Total] 547 / 182 / 21 / 750:  75%|███████▌  | 751/1000 [28:42<09:31,  2.29s/it][Succeeded / Failed / Skipped / Total] 548 / 182 / 21 / 751:  75%|███████▌  | 751/1000 [28:42<09:31,  2.29s/it][Succeeded / Failed / Skipped / Total] 548 / 182 / 21 / 751:  75%|███████▌  | 752/1000 [28:43<09:28,  2.29s/it][Succeeded / Failed / Skipped / Total] 548 / 183 / 21 / 752:  75%|███████▌  | 752/1000 [28:43<09:28,  2.29s/it][Succeeded / Failed / Skipped / Total] 548 / 183 / 21 / 752:  75%|███████▌  | 753/1000 [28:44<09:25,  2.29s/it][Succeeded / Failed / Skipped / Total] 549 / 183 / 21 / 753:  75%|███████▌  | 753/1000 [28:44<09:25,  2.29s/it][Succeeded / Failed / Skipped / Total] 549 / 183 / 21 / 753:  75%|███████▌  | 754/1000 [28:55<09:26,  2.30s/it][Succeeded / Failed / Skipped / Total] 550 / 183 / 21 / 754:  75%|███████▌  | 754/1000 [28:55<09:26,  2.30s/it]Checks if the token is valid . --> Check that the session is valid --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > [[tokenSet]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( [[tokenSet]] == null ) && ( tokenValue == null ) ) { return "True" == "True" ; } if ( ( [[tokenSet]] == null ) || ( tokenValue == null ) ) { return "False" != "False" ; } boolean [[found]] = "False" != "False" ; Iterator < Token > it = [[tokenSet]] . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; [[found]] = "True" == "True" ; } } return [[found]] ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > [[σset]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( [[σset]] == null ) && ( tokenValue == null ) ) { return "True" == "True" ; } if ( ( [[σset]] == null ) || ( tokenValue == null ) ) { return "False" != "False" ; } boolean [[won]] = "False" != "False" ; Iterator < Token > it = [[σset]] . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; [[won]] = "True" == "True" ; } } return [[won]] ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 751 ---------------------------------------------
Assure size of the token set . --> Caller must be synchronized --> Socre: 1.0

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token [[tokenToRemove]] = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token [[token]] = iterator . next ( ) ; if ( [[token]] . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( [[token]] . validUntil < validUntilMin ) { validUntilMin = [[token]] . validUntil ; [[tokenToRemove]] = [[token]] ; } } if ( ( [[tokenToRemove]] != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( [[tokenToRemove]] ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token [[datateamver]] = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token [[infrastructure]] = iterator . next ( ) ; if ( [[infrastructure]] . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( [[infrastructure]] . validUntil < validUntilMin ) { validUntilMin = [[infrastructure]] . validUntil ; [[datateamver]] = [[infrastructure]] ; } } if ( ( [[datateamver]] != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( [[datateamver]] ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 752 ---------------------------------------------
Resolve a scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] Scope > S resolveScope ( final Class < S > scopeType ) { S [[scope]] = ( S ) scopes . get ( scopeType ) ; if ( [[scope]] == null ) { try { [[scope]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[scope]] ) ; scopes . put ( scopeType , [[scope]] ) ; } return [[scope]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[generic]] Scope > S resolveScope ( final Class < S > scopeType ) { S [[frame]] = ( S ) scopes . get ( scopeType ) ; if ( [[frame]] == null ) { try { [[frame]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[frame]] ) ; scopes . put ( scopeType , [[frame]] ) ; } return [[frame]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 753 ---------------------------------------------
Initialize the template . --> Initialize the entity --> Socre: 1.0

[[[[Adv]]]]: @ Override public void init ( final TemplateData [[templateData]] ) { super . init ( [[templateData]] ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = [[templateData]] . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } [[templateData]] . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData [[jmbatth]] ) { super . init ( [[jmbatth]] ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = [[jmbatth]] . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } [[jmbatth]] . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 754 ---------------------------------------------
Remove a specific bean . --> Sets the base class b --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[basebaade]] ( final Class [[b]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 755 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 551 / 183 / 21 / 755:  76%|███████▌  | 755/1000 [28:55<09:23,  2.30s/it][Succeeded / Failed / Skipped / Total] 551 / 183 / 21 / 755:  76%|███████▌  | 756/1000 [28:59<09:21,  2.30s/it][Succeeded / Failed / Skipped / Total] 551 / 184 / 21 / 756:  76%|███████▌  | 756/1000 [28:59<09:21,  2.30s/it][Succeeded / Failed / Skipped / Total] 552 / 184 / 21 / 757:  76%|███████▌  | 757/1000 [29:07<09:20,  2.31s/it][Succeeded / Failed / Skipped / Total] 552 / 184 / 21 / 757:  76%|███████▌  | 758/1000 [29:09<09:18,  2.31s/it][Succeeded / Failed / Skipped / Total] 553 / 184 / 21 / 758:  76%|███████▌  | 758/1000 [29:09<09:18,  2.31s/it][Succeeded / Failed / Skipped / Total] 553 / 184 / 21 / 758:  76%|███████▌  | 759/1000 [29:11<09:16,  2.31s/it]Returns a unique token for the given session . --> Implementation of precewrpelnet --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[prepareCsrfToken]] ( final HttpSession [[session]] , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) [[session]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; [[session]] . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean [[unique]] ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; [[unique]] = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! [[unique]] ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[precewrpelnet]] ( final HttpSession [[forum]] , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) [[forum]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; [[forum]] . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean [[primitive]] ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; [[primitive]] = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! [[primitive]] ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 756 ---------------------------------------------
Visit property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected boolean visitProperty ( String name , final Object [[value]] ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , [[value]] ) ; return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean visitProperty ( String name , final Object [[item]] ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , [[item]] ) ; return "[[prove]]" == "[[prove]]" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 757 ---------------------------------------------
Registers a new property InjectionPoint . --> designertvtaterealarties --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetitePropertyInjectionPoint]] ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void [[designertvtaterealartiesreinxtionpost]] ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 758 ---------------------------------------------
Returns the names for the specified bean type . --> Safely find beans Mececesh --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[resolveBeanNamesForType]] ( final Class type ) { String [ ] [[beanNames]] = beanCollections . get ( type ) ; if ( [[beanNames]] != null ) { return [[beanNames]] ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String [[beanName]] = entry . getKey ( ) ; list . add ( [[beanName]] ) ; } } if ( list . isEmpty ( ) ) { [[beanNames]] = StringPool . EMPTY_ARRAY ; } else { [[beanNames]] = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , [[beanNames]] ) ; return [[beanNames]] ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] [[solveecheagemasentress]] ( final Class type ) { String [ ] [[beanspiecesh]] = beanCollections . get ( type ) ; if ( [[beanspiecesh]] != null ) { return [[beanspiecesh]] ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String [[junmet]] = entry . getKey ( ) ; list . add ( [[junmet]] ) ; } } if ( list . isEmpty ( ) ) { [[beanspiecesh]] = StringPool . EMPTY_ARRAY ; } else { [[beanspiecesh]] = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , [[beanspiecesh]] ) ; return [[beanspiecesh]] ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 759 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 553 / 185 / 21 / 759:  76%|███████▌  | 759/1000 [29:11<09:16,  2.31s/it][Succeeded / Failed / Skipped / Total] 553 / 185 / 21 / 759:  76%|███████▌  | 760/1000 [29:11<09:13,  2.30s/it][Succeeded / Failed / Skipped / Total] 554 / 185 / 21 / 760:  76%|███████▌  | 760/1000 [29:11<09:13,  2.30s/it][Succeeded / Failed / Skipped / Total] 554 / 185 / 21 / 760:  76%|███████▌  | 761/1000 [29:18<09:12,  2.31s/it][Succeeded / Failed / Skipped / Total] 555 / 185 / 21 / 761:  76%|███████▌  | 761/1000 [29:18<09:12,  2.31s/it][Succeeded / Failed / Skipped / Total] 555 / 185 / 21 / 761:  76%|███████▌  | 762/1000 [29:23<09:10,  2.31s/it]Scan the given file . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[scanJarFile]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry [[zipEntry]] = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = [[zipEntry]] . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "[[True]]" == "[[True]]" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , [[zipEntry]] ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , [[zipEntry]] ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void [[countdufelo]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry [[openecrik]] = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = [[openecrik]] . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "[[free]]" == "[[free]]" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , [[openecrik]] ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , [[openecrik]] ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 760 ---------------------------------------------
Registers a set Injection point for the given property . --> Adds a property to the Mixotens --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteSetInjectionPoint]] ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void [[aspaixotensfaceire]] ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 761 ---------------------------------------------
Register a destroy methods --> Register a DestroyMethodPoint for a bean --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor [[md]] = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( [[md]] == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( [[md]] . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor [[du]] = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( [[du]] == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( [[du]] . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 762 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 556 / 185 / 21 / 762:  76%|███████▌  | 762/1000 [29:23<09:10,  2.31s/it][Succeeded / Failed / Skipped / Total] 556 / 185 / 21 / 762:  76%|███████▋  | 763/1000 [29:23<09:07,  2.31s/it][Succeeded / Failed / Skipped / Total] 556 / 185 / 22 / 763:  76%|███████▋  | 763/1000 [29:23<09:07,  2.31s/it][Succeeded / Failed / Skipped / Total] 556 / 185 / 22 / 763:  76%|███████▋  | 764/1000 [29:27<09:06,  2.31s/it][Succeeded / Failed / Skipped / Total] 557 / 185 / 22 / 764:  76%|███████▋  | 764/1000 [29:27<09:06,  2.31s/it][Succeeded / Failed / Skipped / Total] 557 / 185 / 22 / 764:  76%|███████▋  | 765/1000 [29:29<09:03,  2.31s/it][Succeeded / Failed / Skipped / Total] 558 / 185 / 22 / 765:  76%|███████▋  | 765/1000 [29:29<09:03,  2.31s/it][Succeeded / Failed / Skipped / Total] 558 / 185 / 22 / 765:  77%|███████▋  | 766/1000 [29:35<09:02,  2.32s/it]Registers a new injection point . --> This method can be used to create an instance of the Bean --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteCtorInjectionPoint]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + [[beanDefinition]] . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + [[beanDefinition]] . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; [[beanDefinition]] . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void [[soputitimcusctionception]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition [[anadefanity]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[anadefanity]] . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + [[anadefanity]] . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + [[anadefanity]] . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; [[anadefanity]] . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 763 ---------------------------------------------
Iterate over beanName --> [[[SKIPPED]]]

[[[[Adv]]]]: public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 764 ---------------------------------------------
Registers a method s injection point . --> iefedieetobdfprefinder --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteMethodInjectionPoint]] ( final String beanName , final String [[methodName]] , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[methodName]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + [[methodName]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[methodName]] , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + [[methodName]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void [[iefedieetobdfprefinder]] ( final String beanName , final String [[fieldterm]] , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[fieldterm]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + [[fieldterm]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[fieldterm]] , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + [[fieldterm]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 765 ---------------------------------------------
Register a provider . --> morganbettyf to the specified beanName --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String providerName , final String beanName , final String methodName , final Class [ ] [[arguments]] ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[arguments]] , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void [[morganbettyfondedf]] ( final String providerName , final String beanName , final String methodName , final Class [ ] [[argument]] ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[argument]] , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 766 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 558 / 186 / 22 / 766:  77%|███████▋  | 766/1000 [29:35<09:02,  2.32s/it][Succeeded / Failed / Skipped / Total] 558 / 186 / 22 / 766:  77%|███████▋  | 767/1000 [29:44<09:01,  2.33s/it][Succeeded / Failed / Skipped / Total] 558 / 187 / 22 / 767:  77%|███████▋  | 767/1000 [29:44<09:01,  2.33s/it][Succeeded / Failed / Skipped / Total] 558 / 187 / 22 / 767:  77%|███████▋  | 768/1000 [29:44<08:59,  2.32s/it][Succeeded / Failed / Skipped / Total] 559 / 187 / 22 / 768:  77%|███████▋  | 768/1000 [29:44<08:59,  2.32s/it][Succeeded / Failed / Skipped / Total] 559 / 187 / 22 / 768:  77%|███████▋  | 769/1000 [29:45<08:56,  2.32s/it][Succeeded / Failed / Skipped / Total] 559 / 188 / 22 / 769:  77%|███████▋  | 769/1000 [29:45<08:56,  2.32s/it][Succeeded / Failed / Skipped / Total] 559 / 188 / 22 / 769:  77%|███████▋  | 770/1000 [29:51<08:55,  2.33s/it][Succeeded / Failed / Skipped / Total] 559 / 189 / 22 / 770:  77%|███████▋  | 770/1000 [29:51<08:55,  2.33s/it][Succeeded / Failed / Skipped / Total] 559 / 189 / 22 / 770:  77%|███████▋  | 771/1000 [29:54<08:53,  2.33s/it][Succeeded / Failed / Skipped / Total] 560 / 189 / 22 / 771:  77%|███████▋  | 771/1000 [29:54<08:53,  2.33s/it][Succeeded / Failed / Skipped / Total] 560 / 189 / 22 / 771:  77%|███████▋  | 772/1000 [29:56<08:50,  2.33s/it]Register a bean definition . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[registerBean]] ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class [[type]] = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( [[type]] ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( [[type]] ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void [[aflaw]] ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class [[base]] = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( [[base]] ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( [[base]] ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 767 ---------------------------------------------
Define the parameters . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[samplepaometerfor]] ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 768 ---------------------------------------------
Register a provider --> canianbetisionap spring --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String [[providerName]] , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[providerName]] , md . getMethod ( ) ) ; providers . put ( [[providerName]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void [[canadianbetisionapvorper]] ( final String [[companycha]] , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[companycha]] , md . getMethod ( ) ) ; providers . put ( [[companycha]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 769 ---------------------------------------------
Register a bean with the given name and scope type . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > BeanDefinition < T > [[registerPetiteBean]] ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean [[define]] , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > [[comantceideat]] ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean [[end]] , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 770 ---------------------------------------------
Visit integer . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[pushInt]] ( final MethodVisitor mv , final int value ) { if ( value <= 5 ) { mv . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , value ) ; } else { mv . visitIntInsn ( SIPUSH , value ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void [[dilf]] ( final MethodVisitor mv , final int value ) { if ( value <= 5 ) { mv . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , value ) ; } else { mv . visitIntInsn ( SIPUSH , value ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 771 ---------------------------------------------
Intercept the action request . --> Intercept an ActionRequest --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long [[startTime]] = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - [[startTime]] ; printAfter ( [[actionRequest]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest [[actefwr]] ) throws Exception { printBefore ( [[actefwr]] ) ; long [[asi]] = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[actefwr]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - [[asi]] ; printAfter ( [[actefwr]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 772 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 561 / 189 / 22 / 772:  77%|███████▋  | 772/1000 [29:56<08:50,  2.33s/it][Succeeded / Failed / Skipped / Total] 561 / 189 / 22 / 772:  77%|███████▋  | 773/1000 [30:00<08:48,  2.33s/it][Succeeded / Failed / Skipped / Total] 562 / 189 / 22 / 773:  77%|███████▋  | 773/1000 [30:00<08:48,  2.33s/it][Succeeded / Failed / Skipped / Total] 562 / 189 / 22 / 773:  77%|███████▋  | 774/1000 [30:02<08:46,  2.33s/it][Succeeded / Failed / Skipped / Total] 563 / 189 / 22 / 774:  77%|███████▋  | 774/1000 [30:02<08:46,  2.33s/it][Succeeded / Failed / Skipped / Total] 563 / 189 / 22 / 774:  78%|███████▊  | 775/1000 [30:04<08:43,  2.33s/it][Succeeded / Failed / Skipped / Total] 564 / 189 / 22 / 775:  78%|███████▊  | 775/1000 [30:04<08:43,  2.33s/it][Succeeded / Failed / Skipped / Total] 564 / 189 / 22 / 775:  78%|███████▊  | 776/1000 [30:05<08:41,  2.33s/it][Succeeded / Failed / Skipped / Total] 564 / 190 / 22 / 776:  78%|███████▊  | 776/1000 [30:05<08:41,  2.33s/it][Succeeded / Failed / Skipped / Total] 564 / 190 / 22 / 776:  78%|███████▊  | 777/1000 [30:06<08:38,  2.32s/it][Succeeded / Failed / Skipped / Total] 565 / 190 / 22 / 777:  78%|███████▊  | 777/1000 [30:06<08:38,  2.32s/it][Succeeded / Failed / Skipped / Total] 565 / 190 / 22 / 777:  78%|███████▊  | 778/1000 [30:16<08:38,  2.33s/it][Succeeded / Failed / Skipped / Total] 566 / 190 / 22 / 778:  78%|███████▊  | 778/1000 [30:16<08:38,  2.33s/it][Succeeded / Failed / Skipped / Total] 566 / 190 / 22 / 778:  78%|███████▊  | 779/1000 [30:18<08:35,  2.33s/it][Succeeded / Failed / Skipped / Total] 567 / 190 / 22 / 779:  78%|███████▊  | 779/1000 [30:18<08:35,  2.33s/it][Succeeded / Failed / Skipped / Total] 567 / 190 / 22 / 779:  78%|███████▊  | 780/1000 [30:22<08:34,  2.34s/it]Resolve Java version . --> iyajivasuit --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int version ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[platformVersion]] = javaVersionNumber - 8 + 52 ; return version > [[platformVersion]] ? version : [[platformVersion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[iyajivasuit]] ( final int version ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[barn11]] = javaVersionNumber - 8 + 52 ; return version > [[barn11]] ? version : [[barn11]] ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 773 ---------------------------------------------
Concatenates a field name and its index . --> assistancefindercall method --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String name , final int [[index]] ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[assistancefindercall]] ( final String name , final int [[engine]] ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + [[engine]] ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 774 ---------------------------------------------
Returns a advice method name . --> advised with anonymous attributes --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String name , final int [[index]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[advisedtoheidetain]] ( final String name , final int [[anonymous]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[anonymous]] ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 775 ---------------------------------------------
Sets the argument index . --> If agyousew is null throws exception --> Socre: 1.0

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo methodInfo , final int [[argIndex]] ) { if ( ( [[argIndex]] < 1 ) || ( [[argIndex]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[argIndex]] ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[edurɡestinde]] ( final MethodInfo methodInfo , final int [[agyousew]] ) { if ( ( [[agyousew]] < 1 ) || ( [[agyousew]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[agyousew]] ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 776 ---------------------------------------------
Decodes a byte array . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[decode]] ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int [[sndx]] = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - [[sndx]] + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ [[sndx]] ++ ] ] << 18 | INV [ arr [ [[sndx]] ++ ] ] << 12 | INV [ arr [ [[sndx]] ++ ] ] << 6 | INV [ arr [ [[sndx]] ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { [[sndx]] += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; [[sndx]] <= endx - pad ; j ++ ) { i |= INV [ arr [ [[sndx]] ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] [[dardin]] ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int [[pndz]] = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - [[pndz]] + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ [[pndz]] ++ ] ] << 18 | INV [ arr [ [[pndz]] ++ ] ] << 12 | INV [ arr [ [[pndz]] ++ ] ] << 6 | INV [ arr [ [[pndz]] ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { [[pndz]] += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; [[pndz]] <= endx - pad ; j ++ ) { i |= INV [ arr [ [[pndz]] ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 777 ---------------------------------------------
Load the special method arguments . --> designscoviewintesas --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { [[mv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[designscoviewintesasgarps]] ( final MethodVisitor [[cv]] , final MethodInfo methodInfo ) { [[cv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[cv]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 778 ---------------------------------------------
Create a method signature key . --> Gets the netceinodlestadtest --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[netceinodlestadtestance]] ( final int access , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 779 ---------------------------------------------
Load arguments . --> ease number of non - zero non - zero non - zero --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadVirtualMethodArguments]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int [[i]] = 1 ; [[i]] <= methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( mv , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void [[easevrtearmmetergguisencies]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int [[id]] = 1 ; [[id]] <= methodInfo . getArgumentsCount ( ) ; [[id]] ++ ) { loadMethodArgument ( mv , methodInfo , [[id]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 780 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 568 / 190 / 22 / 780:  78%|███████▊  | 780/1000 [30:22<08:34,  2.34s/it][Succeeded / Failed / Skipped / Total] 568 / 190 / 22 / 780:  78%|███████▊  | 781/1000 [30:27<08:32,  2.34s/it][Succeeded / Failed / Skipped / Total] 569 / 190 / 22 / 781:  78%|███████▊  | 781/1000 [30:27<08:32,  2.34s/it][Succeeded / Failed / Skipped / Total] 569 / 190 / 22 / 781:  78%|███████▊  | 782/1000 [30:27<08:29,  2.34s/it][Succeeded / Failed / Skipped / Total] 570 / 190 / 22 / 782:  78%|███████▊  | 782/1000 [30:27<08:29,  2.34s/it][Succeeded / Failed / Skipped / Total] 570 / 190 / 22 / 782:  78%|███████▊  | 783/1000 [30:32<08:27,  2.34s/it][Succeeded / Failed / Skipped / Total] 571 / 190 / 22 / 783:  78%|███████▊  | 783/1000 [30:32<08:27,  2.34s/it][Succeeded / Failed / Skipped / Total] 571 / 190 / 22 / 783:  78%|███████▊  | 784/1000 [30:35<08:25,  2.34s/it][Succeeded / Failed / Skipped / Total] 572 / 190 / 22 / 784:  78%|███████▊  | 784/1000 [30:35<08:25,  2.34s/it][Succeeded / Failed / Skipped / Total] 572 / 190 / 22 / 784:  78%|███████▊  | 785/1000 [30:37<08:23,  2.34s/it]Helper to prepare the return value of a method . --> This method is used to handle partial partial checker --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , int varOffset ) { varOffset += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : mv . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( mv ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( mv ) ; break ; case ' ' : AsmUtil . valueOfShort ( mv ) ; break ; case ' ' : AsmUtil . valueOfInteger ( mv ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( mv ) ; break ; case ' ' : AsmUtil . valueOfLong ( mv ) ; break ; case ' ' : AsmUtil . valueOfFloat ( mv ) ; break ; case ' ' : AsmUtil . valueOfDouble ( mv ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[seeeddeadone]] ( final MethodVisitor mv , final MethodInfo [[varmanco]] , int varOffset ) { varOffset += [[varmanco]] . getAllArgumentsSize ( ) ; switch ( [[varmanco]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : mv . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( mv ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( mv ) ; break ; case ' ' : AsmUtil . valueOfShort ( mv ) ; break ; case ' ' : AsmUtil . valueOfInteger ( mv ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( mv ) ; break ; case ' ' : AsmUtil . valueOfLong ( mv ) ; break ; case ' ' : AsmUtil . valueOfFloat ( mv ) ; break ; case ' ' : AsmUtil . valueOfDouble ( mv ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 781 ---------------------------------------------
Store into array . --> superdevotectact method --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[superdevotectact]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 782 ---------------------------------------------
Loads the static method arguments . --> Assumes resultinifr is present --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] ) { for ( int i = 0 ; i < [[methodInfo]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , [[methodInfo]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[countsformricmaccovardimed]] ( final MethodVisitor mv , final MethodInfo [[resultinifr]] ) { for ( int i = 0 ; i < [[resultinifr]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , [[resultinifr]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 783 ---------------------------------------------
Method newArray method . --> implements the visitor to look for NEWARRAY --> Socre: 1.0

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[componentType]] ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[wasarsriver]] ( final MethodVisitor mv , final Class [[bimount]] ) { if ( [[bimount]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[bimount]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[bimount]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[bimount]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[bimount]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[bimount]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[bimount]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[bimount]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[bimount]] ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 784 ---------------------------------------------
Load method argument . --> Burdenjoocapertialer --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , final int index ) { int offset = [[methodInfo]] . getArgumentOffset ( index ) ; int type = [[methodInfo]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[burdenjoocapertialer]] ( final MethodVisitor mv , final MethodInfo [[candidaterinch]] , final int index ) { int offset = [[candidaterinch]] . getArgumentOffset ( index ) ; int type = [[candidaterinch]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 785 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 573 / 190 / 22 / 785:  78%|███████▊  | 785/1000 [30:37<08:23,  2.34s/it][Succeeded / Failed / Skipped / Total] 573 / 190 / 22 / 785:  79%|███████▊  | 786/1000 [30:41<08:21,  2.34s/it][Succeeded / Failed / Skipped / Total] 574 / 190 / 22 / 786:  79%|███████▊  | 786/1000 [30:41<08:21,  2.34s/it][Succeeded / Failed / Skipped / Total] 575 / 190 / 22 / 787:  79%|███████▊  | 787/1000 [30:41<08:18,  2.34s/it][Succeeded / Failed / Skipped / Total] 575 / 190 / 22 / 787:  79%|███████▉  | 788/1000 [30:42<08:15,  2.34s/it][Succeeded / Failed / Skipped / Total] 576 / 190 / 22 / 788:  79%|███████▉  | 788/1000 [30:42<08:15,  2.34s/it][Succeeded / Failed / Skipped / Total] 576 / 191 / 22 / 789:  79%|███████▉  | 789/1000 [30:46<08:13,  2.34s/it][Succeeded / Failed / Skipped / Total] 576 / 191 / 22 / 789:  79%|███████▉  | 790/1000 [30:49<08:11,  2.34s/it][Succeeded / Failed / Skipped / Total] 577 / 191 / 22 / 790:  79%|███████▉  | 790/1000 [30:49<08:11,  2.34s/it]Registers a new init method declaration . --> Gets the corresponding boxmatiseearmation --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteInitMethods]] ( final String [[beanName]] , final InitMethodInvocationStrategy invocationStrategy , String ... [[initMethodNames]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( [[initMethodNames]] == null ) { [[initMethodNames]] = StringPool . EMPTY_ARRAY ; } int [[total]] = [[initMethodNames]] . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ [[total]] ] ; int i ; for ( i = 0 ; i < [[initMethodNames]] . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( [[initMethodNames]] [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + [[initMethodNames]] [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void [[shopmatiseearmationcleurs]] ( final String [[boxmat]] , final InitMethodInvocationStrategy invocationStrategy , String ... [[thatitmontaadhids]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[boxmat]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( [[thatitmontaadhids]] == null ) { [[thatitmontaadhids]] = StringPool . EMPTY_ARRAY ; } int [[quantity]] = [[thatitmontaadhids]] . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ [[quantity]] ] ; int i ; for ( i = 0 ; i < [[thatitmontaadhids]] . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( [[thatitmontaadhids]] [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + [[thatitmontaadhids]] [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 786 ---------------------------------------------
Resolves RFC 39 token . --> Get the datatr Attachmentgrewarredcedef from the request --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest request ) { String [[header]] = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[header]] == null ) { return null ; } int ndx = [[header]] . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return [[header]] . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[datatrattergrewarredcedef]] ( final HttpServletRequest request ) { String [[protocol]] = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[protocol]] == null ) { return null ; } int ndx = [[protocol]] . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return [[protocol]] . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 787 ---------------------------------------------
Extract encoding from given contentType . --> Return adaptation of the altmenmodling --> Socre: 1.0

[[[[Adv]]]]: public static String extractEncoding ( final String [[contentType]] , String [[defaultEncoding]] ) { String [[encoding]] = extractEncoding ( [[contentType]] ) ; if ( [[encoding]] == null ) { if ( [[defaultEncoding]] == null ) { [[defaultEncoding]] = JoddCore . encoding ; } [[encoding]] = [[defaultEncoding]] ; } return [[encoding]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String extractEncoding ( final String [[bookimate]] , String [[altmenmodling]] ) { String [[adaptation]] = extractEncoding ( [[bookimate]] ) ; if ( [[adaptation]] == null ) { if ( [[altmenmodling]] == null ) { [[altmenmodling]] = JoddCore . encoding ; } [[adaptation]] = [[altmenmodling]] ; } return [[adaptation]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 788 ---------------------------------------------
Returns true if the flags contains a user flags . --> Gets true or false . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags [[flags]] ) { if ( [[flags]] == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = [[flags]] . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[flags]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[gettimelptloox]] ( Flags [[buses]] ) { if ( [[buses]] == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = [[buses]] . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[buses]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 789 ---------------------------------------------
Write a method argument . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[storeMethodArgument]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[azgoomotarxator]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 790 ---------------------------------------------
Require authentication . --> latchexunennilink --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse [[resp]] , final String realm ) throws IOException { [[resp]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[resp]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[latchexunennilink]] ( final HttpServletResponse [[asspress]] , final String realm ) throws IOException { [[asspress]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[asspress]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 791 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 578 / 191 / 22 / 791:  79%|███████▉  | 791/1000 [30:51<08:09,  2.34s/it][Succeeded / Failed / Skipped / Total] 578 / 191 / 22 / 791:  79%|███████▉  | 792/1000 [30:51<08:06,  2.34s/it][Succeeded / Failed / Skipped / Total] 579 / 191 / 22 / 792:  79%|███████▉  | 792/1000 [30:51<08:06,  2.34s/it][Succeeded / Failed / Skipped / Total] 580 / 191 / 22 / 793:  79%|███████▉  | 793/1000 [30:54<08:04,  2.34s/it][Succeeded / Failed / Skipped / Total] 580 / 191 / 22 / 793:  79%|███████▉  | 794/1000 [30:59<08:02,  2.34s/it][Succeeded / Failed / Skipped / Total] 581 / 191 / 22 / 794:  79%|███████▉  | 794/1000 [30:59<08:02,  2.34s/it][Succeeded / Failed / Skipped / Total] 582 / 191 / 22 / 795:  80%|███████▉  | 795/1000 [31:00<07:59,  2.34s/it][Succeeded / Failed / Skipped / Total] 582 / 191 / 22 / 795:  80%|███████▉  | 796/1000 [31:06<07:58,  2.34s/it][Succeeded / Failed / Skipped / Total] 583 / 191 / 22 / 796:  80%|███████▉  | 796/1000 [31:06<07:58,  2.34s/it][Succeeded / Failed / Skipped / Total] 584 / 191 / 22 / 797:  80%|███████▉  | 797/1000 [31:08<07:55,  2.34s/it][Succeeded / Failed / Skipped / Total] 584 / 191 / 22 / 797:  80%|███████▉  | 798/1000 [31:08<07:52,  2.34s/it][Succeeded / Failed / Skipped / Total] 585 / 191 / 22 / 798:  80%|███████▉  | 798/1000 [31:08<07:52,  2.34s/it]Prepare response . --> set the mime type body --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareResponse]] ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String [[extension]] = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( [[extension]] ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void [[srinsuntn]] ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String [[x]] = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( [[x]] ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 792 ---------------------------------------------
Store the context path . --> cargotranspressry --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void [[cargotranspressry]] ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 793 ---------------------------------------------
Reads a request from the request . --> Convert a HttpServletRequest to a String --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest request ) throws IOException { BufferedReader [[buff]] = request . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( [[buff]] , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[seeremactidefratverdian]] ( final HttpServletRequest request ) throws IOException { BufferedReader [[ask]] = request . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( [[ask]] , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 794 ---------------------------------------------
Prepare a file . --> Liefert einen Liefert ein Liefert ein --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse [[response]] , final File [[file]] , final String mimeType ) { if ( ! [[file]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[file]] ) ; } if ( [[file]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[file]] ) ; } prepareResponse ( [[response]] , [[file]] . getAbsolutePath ( ) , mimeType , ( int ) [[file]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[queuethft]] ( final HttpServletResponse [[request]] , final File [[collection]] , final String mimeType ) { if ( ! [[collection]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[collection]] ) ; } if ( [[collection]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[collection]] ) ; } prepareResponse ( [[request]] , [[collection]] . getAbsolutePath ( ) , mimeType , ( int ) [[collection]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 795 ---------------------------------------------
Store the context path --> cargop sandbox --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final ServletContext servletContext , final String [[contextPathVariableName]] ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void [[cargopromeoss]] ( final ServletContext servletContext , final String [[basememuruserpoint]] ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[basememuruserpoint]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 796 ---------------------------------------------
Invokes the given body . --> Method used to invoke the enteringru --> Socre: 1.0

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment [[body]] ) throws JspException { if ( [[body]] == null ) { return ; } try { [[body]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[enteringrukapatton]] ( final JspFragment [[face]] ) throws JspException { if ( [[face]] == null ) { return ; } try { [[face]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 797 ---------------------------------------------
Render the body . --> Render a single character sequence --> Socre: 1.0

[[[[Adv]]]]: public static char [ ] renderBody ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter [[writer]] = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , [[writer]] ) ; return [[writer]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] renderBody ( final JspFragment [[tail]] ) throws JspException { FastCharArrayWriter [[book]] = new FastCharArrayWriter ( ) ; invokeBody ( [[tail]] , [[book]] ) ; return [[book]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 798 ---------------------------------------------
Render the body to string . --> 3d Qoptiting an attribute --> Socre: 1.0

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[3dactoptiting]] ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 799 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 586 / 191 / 22 / 799:  80%|███████▉  | 799/1000 [31:15<07:51,  2.35s/it][Succeeded / Failed / Skipped / Total] 586 / 191 / 22 / 799:  80%|████████  | 800/1000 [31:16<07:49,  2.35s/it][Succeeded / Failed / Skipped / Total] 587 / 191 / 22 / 800:  80%|████████  | 800/1000 [31:16<07:49,  2.35s/it][Succeeded / Failed / Skipped / Total] 588 / 191 / 22 / 801:  80%|████████  | 801/1000 [31:17<07:46,  2.34s/it][Succeeded / Failed / Skipped / Total] 588 / 191 / 22 / 801:  80%|████████  | 802/1000 [31:23<07:44,  2.35s/it][Succeeded / Failed / Skipped / Total] 588 / 192 / 22 / 802:  80%|████████  | 802/1000 [31:23<07:44,  2.35s/it][Succeeded / Failed / Skipped / Total] 588 / 192 / 23 / 803:  80%|████████  | 803/1000 [31:23<07:42,  2.35s/it][Succeeded / Failed / Skipped / Total] 588 / 192 / 23 / 803:  80%|████████  | 804/1000 [31:26<07:39,  2.35s/it][Succeeded / Failed / Skipped / Total] 588 / 193 / 23 / 804:  80%|████████  | 804/1000 [31:26<07:39,  2.35s/it][Succeeded / Failed / Skipped / Total] 589 / 193 / 23 / 805:  80%|████████  | 805/1000 [31:32<07:38,  2.35s/it][Succeeded / Failed / Skipped / Total] 589 / 193 / 23 / 805:  81%|████████  | 806/1000 [31:36<07:36,  2.35s/it]Call destroy methods . --> drawreitgreethols method --> Socre: 1.0

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[drawreitgreethols]] ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 800 ---------------------------------------------
Invokes invoke initialization methods . --> Method to invoke the initialization of the InitMethod --> Socre: 1.0

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[iticgenglitrumplas]] ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 801 ---------------------------------------------
Creates a new bean instance . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[bydeseniconage]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 802 ---------------------------------------------
Retrieves all cookies . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookie [ ] [[getAllCookies]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie [[cookie]] : cookies ) { if ( [[cookie]] . getName ( ) . equals ( cookieName ) ) { list . add ( [[cookie]] ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] [[bigramcolorinhs]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie [[shop]] : cookies ) { if ( [[shop]] . getName ( ) . equals ( cookieName ) ) { list . add ( [[shop]] ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 803 ---------------------------------------------
Adds a new props entry . --> [[[SKIPPED]]]

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 804 ---------------------------------------------
Reads the content from the request . --> [[[FAILED]]]

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader [[bufferedReader]] = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { [[bufferedReader]] = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( [[bufferedReader]] , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( [[bufferedReader]] ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader [[roadizedravetor]] = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { [[roadizedravetor]] = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( [[roadizedravetor]] , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( [[roadizedravetor]] ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 805 ---------------------------------------------
Adds a base property . --> createdicateurpartly --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value , append ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[createdicateurpartly]] ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value , append ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 806 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 590 / 193 / 23 / 806:  81%|████████  | 806/1000 [31:36<07:36,  2.35s/it][Succeeded / Failed / Skipped / Total] 590 / 193 / 23 / 806:  81%|████████  | 807/1000 [31:37<07:33,  2.35s/it][Succeeded / Failed / Skipped / Total] 591 / 193 / 23 / 807:  81%|████████  | 807/1000 [31:37<07:33,  2.35s/it][Succeeded / Failed / Skipped / Total] 591 / 193 / 23 / 807:  81%|████████  | 808/1000 [31:41<07:31,  2.35s/it][Succeeded / Failed / Skipped / Total] 592 / 193 / 23 / 808:  81%|████████  | 808/1000 [31:41<07:31,  2.35s/it][Succeeded / Failed / Skipped / Total] 592 / 193 / 23 / 808:  81%|████████  | 809/1000 [31:42<07:29,  2.35s/it][Succeeded / Failed / Skipped / Total] 593 / 193 / 23 / 809:  81%|████████  | 809/1000 [31:42<07:29,  2.35s/it][Succeeded / Failed / Skipped / Total] 593 / 193 / 23 / 809:  81%|████████  | 810/1000 [31:46<07:27,  2.35s/it][Succeeded / Failed / Skipped / Total] 593 / 194 / 23 / 810:  81%|████████  | 810/1000 [31:46<07:27,  2.35s/it][Succeeded / Failed / Skipped / Total] 593 / 194 / 23 / 810:  81%|████████  | 811/1000 [31:48<07:24,  2.35s/it][Succeeded / Failed / Skipped / Total] 594 / 194 / 23 / 811:  81%|████████  | 811/1000 [31:48<07:24,  2.35s/it][Succeeded / Failed / Skipped / Total] 594 / 194 / 23 / 811:  81%|████████  | 812/1000 [31:52<07:22,  2.36s/it][Succeeded / Failed / Skipped / Total] 595 / 194 / 23 / 812:  81%|████████  | 812/1000 [31:52<07:22,  2.36s/it][Succeeded / Failed / Skipped / Total] 595 / 194 / 23 / 812:  81%|████████▏ | 813/1000 [31:52<07:19,  2.35s/it][Succeeded / Failed / Skipped / Total] 596 / 194 / 23 / 813:  81%|████████▏ | 813/1000 [31:52<07:19,  2.35s/it][Succeeded / Failed / Skipped / Total] 596 / 194 / 23 / 813:  81%|████████▏ | 814/1000 [31:52<07:17,  2.35s/it]Put profile properties . --> The createtroaflup --> Socre: 1.0

[[[[Adv]]]]: public void [[putProfileProperty]] ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void [[createtroaflupuvirtor]] ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 807 ---------------------------------------------
Inject parameters . --> Check if implicit param is enabled --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager [[paramManager]] , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[atputaminamers]] ( final ParamManager [[giwnibeh]] , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 808 ---------------------------------------------
Rewrite the action path . --> Return the count of the crosswriter --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[rewrite]] ( final HttpServletRequest [[servletRequest]] , final String [[actionPath]] , final String httpMethod ) { return [[actionPath]] ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[crosswriter]] ( final HttpServletRequest [[enivutlev]] , final String [[countermost]] , final String httpMethod ) { return [[countermost]] ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 809 ---------------------------------------------
Gets profile property . --> Create a PropsEntry for the specified key --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String profile , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[createwofortlaterosnerix]] ( final String profile , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 810 ---------------------------------------------
Adds a new header . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[addHeader]] ( final String name , final String value ) { List < String > [[valuesList]] = super . getAll ( name ) ; if ( [[valuesList]] . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; [[valuesList]] . add ( value ) ; super . addAll ( name , [[valuesList]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[accessstreamress]] ( final String name , final String value ) { List < String > [[totalsform]] = super . getAll ( name ) ; if ( [[totalsform]] . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; [[totalsform]] . add ( value ) ; super . addAll ( name , [[totalsform]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 811 ---------------------------------------------
Reads a 4 - byte integer from the stream . --> Returns the streamtord for the given byte array --> Socre: 1.0

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int [[off]] = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ [[off]] ] & 0xff ) ; [[off]] = ( [[off]] + 1 ) % data . length ; } offp [ 0 ] = [[off]] ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int [[line]] = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ [[line]] ] & 0xff ) ; [[line]] = ( [[line]] + 1 ) % data . length ; } offp [ 0 ] = [[line]] ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 812 ---------------------------------------------
Resolve a slash . --> Returned balance of profiles --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String [[value]] , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[balancemansles]] ( String [[designation]] , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 813 ---------------------------------------------
Copy the parameters to attributes . --> duplicate Lower doramwadages --> Socre: 1.0

[[[[Adv]]]]: public static void [[copyParamsToAttributes]] ( final HttpServletRequest [[servletRequest]] , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = [[servletRequest]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( paramName ) != null ) { continue ; } String [ ] [[paramValues]] = [[servletRequest]] . getParameterValues ( paramName ) ; [[paramValues]] = prepareParameters ( [[paramValues]] , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( [[paramValues]] == null ) { continue ; } [[servletRequest]] . setAttribute ( paramName , [[paramValues]] . length == 1 ? [[paramValues]] [ 0 ] : [[paramValues]] ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void [[duplicateamamedartrtricvemes]] ( final HttpServletRequest [[yerifpetorewan]] , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = [[yerifpetorewan]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( [[yerifpetorewan]] . getAttribute ( paramName ) != null ) { continue ; } String [ ] [[doramwadages]] = [[yerifpetorewan]] . getParameterValues ( paramName ) ; [[doramwadages]] = prepareParameters ( [[doramwadages]] , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( [[doramwadages]] == null ) { continue ; } [[yerifpetorewan]] . setAttribute ( paramName , [[doramwadages]] . length == 1 ? [[doramwadages]] [ 0 ] : [[doramwadages]] ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 814 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 597 / 194 / 23 / 814:  81%|████████▏ | 814/1000 [31:52<07:17,  2.35s/it][Succeeded / Failed / Skipped / Total] 597 / 194 / 23 / 814:  82%|████████▏ | 815/1000 [31:53<07:14,  2.35s/it][Succeeded / Failed / Skipped / Total] 597 / 195 / 23 / 815:  82%|████████▏ | 815/1000 [31:53<07:14,  2.35s/it][Succeeded / Failed / Skipped / Total] 597 / 195 / 23 / 815:  82%|████████▏ | 816/1000 [32:00<07:13,  2.35s/it][Succeeded / Failed / Skipped / Total] 598 / 195 / 23 / 816:  82%|████████▏ | 816/1000 [32:00<07:13,  2.35s/it][Succeeded / Failed / Skipped / Total] 598 / 195 / 23 / 816:  82%|████████▏ | 817/1000 [32:01<07:10,  2.35s/it][Succeeded / Failed / Skipped / Total] 599 / 195 / 23 / 817:  82%|████████▏ | 817/1000 [32:01<07:10,  2.35s/it][Succeeded / Failed / Skipped / Total] 599 / 195 / 23 / 817:  82%|████████▏ | 818/1000 [32:03<07:07,  2.35s/it][Succeeded / Failed / Skipped / Total] 600 / 195 / 23 / 818:  82%|████████▏ | 818/1000 [32:03<07:07,  2.35s/it][Succeeded / Failed / Skipped / Total] 600 / 195 / 23 / 818:  82%|████████▏ | 819/1000 [32:04<07:05,  2.35s/it][Succeeded / Failed / Skipped / Total] 601 / 195 / 23 / 819:  82%|████████▏ | 819/1000 [32:04<07:05,  2.35s/it][Succeeded / Failed / Skipped / Total] 601 / 195 / 23 / 819:  82%|████████▏ | 820/1000 [32:14<07:04,  2.36s/it][Succeeded / Failed / Skipped / Total] 602 / 195 / 23 / 820:  82%|████████▏ | 820/1000 [32:14<07:04,  2.36s/it][Succeeded / Failed / Skipped / Total] 602 / 195 / 23 / 820:  82%|████████▏ | 821/1000 [32:20<07:03,  2.36s/it]Prepares parameters . --> Return the param values in zeroicouta --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] [[prepareParameters]] ( final String [ ] paramValues , final boolean [[treatEmptyParamsAsNull]] , final boolean ignoreEmptyRequestParams ) { if ( [[treatEmptyParamsAsNull]] || ignoreEmptyRequestParams ) { int [[emptyCount]] = 0 ; int total = paramValues . length ; for ( int [[i]] = 0 ; [[i]] < paramValues . length ; [[i]] ++ ) { String paramValue = paramValues [ [[i]] ] ; if ( paramValue == null ) { [[emptyCount]] ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { [[emptyCount]] ++ ; if ( [[treatEmptyParamsAsNull]] ) { paramValue = null ; } } paramValues [ [[i]] ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( [[emptyCount]] == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] [[avoidpomeralrs]] ( final String [ ] paramValues , final boolean [[kissompiypocavesastneait]] , final boolean ignoreEmptyRequestParams ) { if ( [[kissompiypocavesastneait]] || ignoreEmptyRequestParams ) { int [[zeroicouta]] = 0 ; int total = paramValues . length ; for ( int [[of]] = 0 ; [[of]] < paramValues . length ; [[of]] ++ ) { String paramValue = paramValues [ [[of]] ] ; if ( paramValue == null ) { [[zeroicouta]] ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { [[zeroicouta]] ++ ; if ( [[kissompiypocavesastneait]] ) { paramValue = null ; } } paramValues [ [[of]] ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( [[zeroicouta]] == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 815 ---------------------------------------------
Checks if is get parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[isGetParameter]] ( final HttpServletRequest [[request]] , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = [[request]] . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String [[nameValuePair]] : nameValuePairs ) { if ( [[nameValuePair]] . startsWith ( name ) ) { return "[[True]]" == "[[True]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean [[waswellapsitor]] ( final HttpServletRequest [[invitation]] , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = [[invitation]] . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String [[brandweatheruneptiri]] : nameValuePairs ) { if ( [[brandweatheruneptiri]] . startsWith ( name ) ) { return "[[proof]]" == "[[proof]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 816 ---------------------------------------------
Resolves the action config . --> Lookup an ActionConfig --> Socre: 1.0

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[conquerremmentverfferv]] ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 817 ---------------------------------------------
Copy max bytes . --> copyMax method --> Socre: 1.0

[[[[Adv]]]]: public int copyMax ( final OutputStream out , final int [[maxBytes]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == [[maxBytes]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int copyMax ( final OutputStream out , final int [[subsinglethes]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == [[subsinglethes]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 818 ---------------------------------------------
Reads all bytes from the stream . --> copy all data --> Socre: 1.0

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int [[count]] = 0 ; while ( "[[True]]" == "[[True]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; [[count]] ++ ; } return [[count]] ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int [[data]] = 0 ; while ( "[[liar]]" == "[[liar]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; [[data]] ++ ; } return [[data]] ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 819 ---------------------------------------------
Extract a map from profiles to prefix . --> extract lead info --> Socre: 1.0

[[[[Adv]]]]: public Map extract ( Map [[target]] , final String [ ] profiles , final String [ ] [[wildcardPatterns]] , String [[prefix]] ) { if ( [[target]] == null ) { [[target]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map extract ( Map [[lead]] , final String [ ] profiles , final String [ ] [[rawdummyпttiies]] , String [[series]] ) { if ( [[lead]] == null ) { [[lead]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 820 ---------------------------------------------
Registers a method alias . --> dronntregnaralia --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues [[annotationValues]] , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( [[annotationValues]] ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[dronntregnaralia]] ( final ActionAnnotationValues [[recitementvarques]] , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( [[recitementvarques]] ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 821 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 603 / 195 / 23 / 821:  82%|████████▏ | 821/1000 [32:20<07:03,  2.36s/it][Succeeded / Failed / Skipped / Total] 603 / 195 / 23 / 821:  82%|████████▏ | 822/1000 [32:27<07:01,  2.37s/it][Succeeded / Failed / Skipped / Total] 604 / 195 / 23 / 822:  82%|████████▏ | 822/1000 [32:27<07:01,  2.37s/it][Succeeded / Failed / Skipped / Total] 604 / 195 / 23 / 822:  82%|████████▏ | 823/1000 [32:27<06:58,  2.37s/it][Succeeded / Failed / Skipped / Total] 604 / 195 / 24 / 823:  82%|████████▏ | 823/1000 [32:27<06:58,  2.37s/it][Succeeded / Failed / Skipped / Total] 604 / 195 / 24 / 823:  82%|████████▏ | 824/1000 [32:35<06:57,  2.37s/it][Succeeded / Failed / Skipped / Total] 604 / 196 / 24 / 824:  82%|████████▏ | 824/1000 [32:35<06:57,  2.37s/it][Succeeded / Failed / Skipped / Total] 604 / 196 / 24 / 824:  82%|████████▎ | 825/1000 [32:35<06:54,  2.37s/it][Succeeded / Failed / Skipped / Total] 605 / 196 / 24 / 825:  82%|████████▎ | 825/1000 [32:35<06:54,  2.37s/it][Succeeded / Failed / Skipped / Total] 605 / 196 / 24 / 825:  83%|████████▎ | 826/1000 [32:36<06:52,  2.37s/it][Succeeded / Failed / Skipped / Total] 605 / 197 / 24 / 826:  83%|████████▎ | 826/1000 [32:36<06:52,  2.37s/it][Succeeded / Failed / Skipped / Total] 605 / 197 / 24 / 826:  83%|████████▎ | 827/1000 [32:37<06:49,  2.37s/it][Succeeded / Failed / Skipped / Total] 606 / 197 / 24 / 827:  83%|████████▎ | 827/1000 [32:37<06:49,  2.37s/it][Succeeded / Failed / Skipped / Total] 606 / 197 / 24 / 827:  83%|████████▎ | 828/1000 [32:39<06:47,  2.37s/it][Succeeded / Failed / Skipped / Total] 606 / 198 / 24 / 828:  83%|████████▎ | 828/1000 [32:39<06:47,  2.37s/it][Succeeded / Failed / Skipped / Total] 606 / 198 / 24 / 828:  83%|████████▎ | 829/1000 [32:40<06:44,  2.36s/it]Read the package action path . --> readPackage actionPath --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] readPackageActionPath ( final Class [[actionClass]] ) { Package [[actionPackage]] = [[actionClass]] . getPackage ( ) ; final String [[actionPackageName]] = [[actionPackage]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] readPackageActionPath ( final Class [[extrachannel]] ) { Package [[actingwatchete]] = [[extrachannel]] . getPackage ( ) ; final String [[accountpackantcommand]] = [[actingwatchete]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 822 ---------------------------------------------
Read actionFilters . --> returns null if not found --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readsrilancebulinesst]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 823 ---------------------------------------------
Notifies the last modified time of the response . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 824 ---------------------------------------------
Read action interceptors . --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy [[interceptedBy]] = [[actionClassOrMethod]] . getAnnotation ( InterceptedBy . class ) ; if ( [[interceptedBy]] != null ) { result = [[interceptedBy]] . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[getptionalinstapexmptours]] ( final AnnotatedElement [[pushcdorebrom]] ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy [[antennabai]] = [[pushcdorebrom]] . getAnnotation ( InterceptedBy . class ) ; if ( [[antennabai]] != null ) { result = [[antennabai]] . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 825 ---------------------------------------------
Parses a method alias . --> For debugging --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues annotationValues ) { String [[alias]] = null ; if ( annotationValues != null ) { [[alias]] = annotationValues . alias ( ) ; } return [[alias]] ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[altschthdanty]] ( final ActionAnnotationValues annotationValues ) { String [[portrait]] = null ; if ( annotationValues != null ) { [[portrait]] = annotationValues . alias ( ) ; } return [[portrait]] ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 826 ---------------------------------------------
Parse action . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime [[parse]] ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime [[bernieser]] ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 827 ---------------------------------------------
Returns the advice for the specified class . --> Apply an object from the cache --> Socre: 1.0

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class [[adviceClass]] = cache . get ( targetClass ) ; if ( [[adviceClass]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class [[advise_]] = cache . get ( targetClass ) ; if ( [[advise_]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 828 ---------------------------------------------
Hash a password salt . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[hashpw]] ( String password , String [[salt]] ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , [[hashed]] ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( [[salt]] . charAt ( 0 ) != ' ' || [[salt]] . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( [[salt]] . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = [[salt]] . charAt ( 2 ) ; if ( minor != ' ' || [[salt]] . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String [[xpr]] ( String password , String [[butter]] ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , [[lyncheti]] ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( [[butter]] . charAt ( 0 ) != ' ' || [[butter]] . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( [[butter]] . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = [[butter]] . charAt ( 2 ) ; if ( minor != ' ' || [[butter]] . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 829 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 606 / 199 / 24 / 829:  83%|████████▎ | 829/1000 [32:40<06:44,  2.36s/it][Succeeded / Failed / Skipped / Total] 606 / 199 / 24 / 829:  83%|████████▎ | 830/1000 [32:43<06:42,  2.37s/it][Succeeded / Failed / Skipped / Total] 606 / 200 / 24 / 830:  83%|████████▎ | 830/1000 [32:43<06:42,  2.37s/it][Succeeded / Failed / Skipped / Total] 606 / 200 / 24 / 830:  83%|████████▎ | 831/1000 [32:46<06:39,  2.37s/it][Succeeded / Failed / Skipped / Total] 607 / 200 / 24 / 831:  83%|████████▎ | 831/1000 [32:46<06:39,  2.37s/it][Succeeded / Failed / Skipped / Total] 607 / 200 / 24 / 831:  83%|████████▎ | 832/1000 [32:50<06:37,  2.37s/it][Succeeded / Failed / Skipped / Total] 608 / 200 / 24 / 832:  83%|████████▎ | 832/1000 [32:50<06:37,  2.37s/it][Succeeded / Failed / Skipped / Total] 608 / 200 / 24 / 832:  83%|████████▎ | 833/1000 [32:59<06:36,  2.38s/it][Succeeded / Failed / Skipped / Total] 608 / 201 / 24 / 833:  83%|████████▎ | 833/1000 [32:59<06:36,  2.38s/it][Succeeded / Failed / Skipped / Total] 608 / 201 / 24 / 833:  83%|████████▎ | 834/1000 [33:01<06:34,  2.38s/it][Succeeded / Failed / Skipped / Total] 608 / 202 / 24 / 834:  83%|████████▎ | 834/1000 [33:01<06:34,  2.38s/it][Succeeded / Failed / Skipped / Total] 608 / 202 / 24 / 834:  84%|████████▎ | 835/1000 [33:02<06:31,  2.37s/it][Succeeded / Failed / Skipped / Total] 609 / 202 / 24 / 835:  84%|████████▎ | 835/1000 [33:02<06:31,  2.37s/it][Succeeded / Failed / Skipped / Total] 609 / 202 / 24 / 835:  84%|████████▎ | 836/1000 [33:03<06:29,  2.37s/it][Succeeded / Failed / Skipped / Total] 610 / 202 / 24 / 836:  84%|████████▎ | 836/1000 [33:03<06:29,  2.37s/it][Succeeded / Failed / Skipped / Total] 610 / 202 / 24 / 836:  84%|████████▎ | 837/1000 [33:04<06:26,  2.37s/it][Succeeded / Failed / Skipped / Total] 610 / 203 / 24 / 837:  84%|████████▎ | 837/1000 [33:04<06:26,  2.37s/it][Succeeded / Failed / Skipped / Total] 610 / 203 / 24 / 837:  84%|████████▍ | 838/1000 [33:08<06:24,  2.37s/it]Read method action path . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[datamegdaryr]] ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 830 ---------------------------------------------
Validates a plaintext --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String [[try_pw]] = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = [[try_pw]] . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String [[hitwypack]] = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = [[hitwypack]] . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 831 ---------------------------------------------
Inject target into proxy . --> confectcongespotpsunby method --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[confectcongespotpsunby]] ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 832 ---------------------------------------------
Find the generic type data . --> Return TypeData blesitthegemattch --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[blesitthegemattch]] ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 833 ---------------------------------------------
Visit annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String descriptor , final boolean [[visible]] ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , [[visible]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[picndedocting]] ( final String descriptor , final boolean [[presence]] ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , [[presence]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 834 ---------------------------------------------
Resolve a real name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[resolveRealName]] ( final String [[jsonName]] ) { if ( jsonNames == null ) { return [[jsonName]] ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , [[jsonName]] ) ; if ( jsonIndex == - 1 ) { return [[jsonName]] ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[analyzerilyma]] ( final String [[jacksochild]] ) { if ( jsonNames == null ) { return [[jacksochild]] ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , [[jacksochild]] ) ; if ( jsonIndex == - 1 ) { return [[jacksochild]] ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 835 ---------------------------------------------
Resolves the name of a field . --> Get the conclusionjosomnu --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String [[realName]] ) { if ( realNames == null ) { return [[realName]] ; } int [[realIndex]] = ArraysUtil . indexOf ( realNames , [[realName]] ) ; if ( [[realIndex]] == - 1 ) { return [[realName]] ; } return jsonNames [ [[realIndex]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[conclusionjosomnu]] ( final String [[productname]] ) { if ( realNames == null ) { return [[productname]] ; } int [[realbenformat]] = ArraysUtil . indexOf ( realNames , [[productname]] ) ; if ( [[realbenformat]] == - 1 ) { return [[productname]] ; } return jsonNames [ [[realbenformat]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 836 ---------------------------------------------
Lookup the type data for the given type . --> tumakerperadeda --> Socre: 1.0

[[[[Adv]]]]: public TypeData [[lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { if ( serializationSubclassAware ) { [[typeData]] = findSubclassTypeData ( [[type]] ) ; } if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } } return [[typeData]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData [[tumakerperadeda]] ( final Class [[model]] ) { TypeData [[criticalitative]] = typeDataMap . get ( [[model]] ) ; if ( [[criticalitative]] == null ) { if ( serializationSubclassAware ) { [[criticalitative]] = findSubclassTypeData ( [[model]] ) ; } if ( [[criticalitative]] == null ) { [[criticalitative]] = scanClassForAnnotations ( [[model]] ) ; typeDataMap . put ( [[model]] , [[criticalitative]] ) ; } } return [[criticalitative]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 837 ---------------------------------------------
Returns the type data for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: protected TypeData [[_lookupTypeData]] ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData [[capitaliandageara]] ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 838 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 611 / 203 / 24 / 838:  84%|████████▍ | 838/1000 [33:08<06:24,  2.37s/it][Succeeded / Failed / Skipped / Total] 611 / 203 / 24 / 838:  84%|████████▍ | 839/1000 [33:10<06:22,  2.37s/it][Succeeded / Failed / Skipped / Total] 612 / 203 / 24 / 839:  84%|████████▍ | 839/1000 [33:10<06:22,  2.37s/it][Succeeded / Failed / Skipped / Total] 612 / 203 / 24 / 839:  84%|████████▍ | 840/1000 [33:15<06:20,  2.38s/it][Succeeded / Failed / Skipped / Total] 613 / 203 / 24 / 840:  84%|████████▍ | 840/1000 [33:15<06:20,  2.38s/it][Succeeded / Failed / Skipped / Total] 613 / 203 / 24 / 840:  84%|████████▍ | 841/1000 [33:15<06:17,  2.37s/it][Succeeded / Failed / Skipped / Total] 614 / 203 / 24 / 841:  84%|████████▍ | 841/1000 [33:15<06:17,  2.37s/it][Succeeded / Failed / Skipped / Total] 614 / 203 / 24 / 841:  84%|████████▍ | 842/1000 [33:16<06:14,  2.37s/it][Succeeded / Failed / Skipped / Total] 614 / 204 / 24 / 842:  84%|████████▍ | 842/1000 [33:16<06:14,  2.37s/it][Succeeded / Failed / Skipped / Total] 614 / 204 / 24 / 842:  84%|████████▍ | 843/1000 [33:17<06:12,  2.37s/it][Succeeded / Failed / Skipped / Total] 615 / 204 / 24 / 843:  84%|████████▍ | 843/1000 [33:17<06:12,  2.37s/it][Succeeded / Failed / Skipped / Total] 615 / 204 / 24 / 843:  84%|████████▍ | 844/1000 [33:21<06:09,  2.37s/it][Succeeded / Failed / Skipped / Total] 616 / 204 / 24 / 844:  84%|████████▍ | 844/1000 [33:21<06:09,  2.37s/it][Succeeded / Failed / Skipped / Total] 616 / 204 / 24 / 844:  84%|████████▍ | 845/1000 [33:40<06:10,  2.39s/it][Succeeded / Failed / Skipped / Total] 617 / 204 / 24 / 845:  84%|████████▍ | 845/1000 [33:40<06:10,  2.39s/it][Succeeded / Failed / Skipped / Total] 617 / 204 / 24 / 845:  85%|████████▍ | 846/1000 [33:42<06:08,  2.39s/it][Succeeded / Failed / Skipped / Total] 617 / 205 / 24 / 846:  85%|████████▍ | 846/1000 [33:42<06:08,  2.39s/it][Succeeded / Failed / Skipped / Total] 617 / 205 / 24 / 846:  85%|████████▍ | 847/1000 [33:44<06:05,  2.39s/it]Returns the content of the file . --> F743 - 1 --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[coverfulel1ttenat]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 839 ---------------------------------------------
Copy bootstrap methods . --> Use reproducecaststat --> Socre: 1.0

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[reproducecaststatpthes]] ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 840 ---------------------------------------------
Resolve real name . --> Bridgethma is the same as the specified type --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class type , final String [[jsonName]] ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveRealName ( [[jsonName]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[bridgethma]] ( final Class type , final String [[jcstationgo]] ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveRealName ( [[jcstationgo]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 841 ---------------------------------------------
Resolves json name . --> region answerinson tag --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class type , final String name ) { TypeData [[typeData]] = lookupTypeData ( type ) ; return [[typeData]] . resolveJsonName ( name ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[answerinsonygirl]] ( final Class type , final String name ) { TypeData [[taggedana]] = lookupTypeData ( type ) ; return [[taggedana]] . resolveJsonName ( name ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 842 ---------------------------------------------
Puts constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[readantsbytesown]] ( final ByteVector [[above]] ) { [[above]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 843 ---------------------------------------------
Puts the bootstrap methods . --> gomaspropmap --> Socre: 1.0

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector [[output]] ) { if ( bootstrapMethods != null ) { [[output]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[gomaspropmapds]] ( final ByteVector [[engine]] ) { if ( bootstrapMethods != null ) { [[engine]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 844 ---------------------------------------------
Sets the major version and class . --> z - solidusner --> Socre: 1.0

[[[[Adv]]]]: int [[setMajorVersionAndClassName]] ( final int majorVersion , final String [[className]] ) { this . majorVersion = majorVersion ; this . className = [[className]] ; return addConstantClass ( [[className]] ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int [[zmaworkfworksatnergirl]] ( final int majorVersion , final String [[stylemaster]] ) { this . majorVersion = majorVersion ; this . className = [[stylemaster]] ; return addConstantClass ( [[stylemaster]] ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 845 ---------------------------------------------
Adds a constant . --> inengeter! --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodref]] ( final String [[owner]] , final String name , final String descriptor , final boolean [[isInterface]] ) { int tag = [[isInterface]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , [[owner]] , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[indexbenistantsredetrorg]] ( final String [[alex]] , final String name , final String descriptor , final boolean [[inengetervity]] ) { int tag = [[inengetervity]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , [[alex]] , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 846 ---------------------------------------------
Adds a constant field to this symbol table . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String owner , final String name , final String [[descriptor]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , [[descriptor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[bringcomingstatecreworffer]] ( final String owner , final String name , final String [[commandvanttor]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , [[commandvanttor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 847 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 618 / 205 / 24 / 847:  85%|████████▍ | 847/1000 [33:44<06:05,  2.39s/it][Succeeded / Failed / Skipped / Total] 618 / 205 / 24 / 847:  85%|████████▍ | 848/1000 [33:50<06:03,  2.39s/it][Succeeded / Failed / Skipped / Total] 619 / 205 / 24 / 848:  85%|████████▍ | 848/1000 [33:50<06:03,  2.39s/it][Succeeded / Failed / Skipped / Total] 619 / 205 / 24 / 848:  85%|████████▍ | 849/1000 [33:51<06:01,  2.39s/it][Succeeded / Failed / Skipped / Total] 619 / 206 / 24 / 849:  85%|████████▍ | 849/1000 [33:51<06:01,  2.39s/it][Succeeded / Failed / Skipped / Total] 619 / 206 / 24 / 849:  85%|████████▌ | 850/1000 [33:58<05:59,  2.40s/it][Succeeded / Failed / Skipped / Total] 619 / 207 / 24 / 850:  85%|████████▌ | 850/1000 [33:58<05:59,  2.40s/it][Succeeded / Failed / Skipped / Total] 619 / 207 / 24 / 850:  85%|████████▌ | 851/1000 [34:03<05:57,  2.40s/it][Succeeded / Failed / Skipped / Total] 620 / 207 / 24 / 851:  85%|████████▌ | 851/1000 [34:03<05:57,  2.40s/it][Succeeded / Failed / Skipped / Total] 620 / 207 / 24 / 851:  85%|████████▌ | 852/1000 [34:04<05:55,  2.40s/it]Adds a constant value to the constant pool . --> endepangtietgowelalett --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int [[index]] , final int tag , final int [[value]] ) { add ( new Entry ( [[index]] , tag , [[value]] , hash ( tag , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[endepangtietgowelalett]] ( final int [[alias]] , final int tag , final int [[destination]] ) { add ( new Entry ( [[alias]] , tag , [[destination]] , hash ( tag , [[destination]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 848 ---------------------------------------------
Add a long or double value . --> region > idonmMreent --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[idonmottyupptreent]] ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 849 ---------------------------------------------
Create an action runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime [[createActionRuntime]] ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition [[actionDefinition]] , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , [[actionDefinition]] , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime [[addrotionsredonet]] ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition [[actgefrter]] , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , [[actgefrter]] , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a constant reference . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantMemberReference]] ( final int [[index]] , final int tag , final String owner , final String [[name]] , final String descriptor ) { add ( new Entry ( [[index]] , tag , owner , [[name]] , descriptor , 0 , hash ( tag , owner , [[name]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[addedotepentomeroborroflow]] ( final int [[undo]] , final int tag , final String owner , final String [[a]] , final String descriptor ) { add ( new Entry ( [[undo]] , tag , owner , [[a]] , descriptor , 0 , hash ( tag , owner , [[a]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 851 ---------------------------------------------
Adds a constant name . --> Returns an ochrelragantarana --> Socre: 1.0

[[[[Adv]]]]: int [[addConstantNameAndType]] ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int [[hashCode]] = hash ( tag , name , descriptor ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[hashCode]] && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[ochrelragantaranaedmini]] ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int [[dictionarycha]] = hash ( tag , name , descriptor ) ; Entry entry = get ( [[dictionarycha]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[dictionarycha]] && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , [[dictionarycha]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 852 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 621 / 207 / 24 / 852:  85%|████████▌ | 852/1000 [34:04<05:55,  2.40s/it][Succeeded / Failed / Skipped / Total] 621 / 207 / 24 / 852:  85%|████████▌ | 853/1000 [34:09<05:53,  2.40s/it][Succeeded / Failed / Skipped / Total] 621 / 208 / 24 / 853:  85%|████████▌ | 853/1000 [34:09<05:53,  2.40s/it][Succeeded / Failed / Skipped / Total] 621 / 208 / 24 / 853:  85%|████████▌ | 854/1000 [34:19<05:52,  2.41s/it][Succeeded / Failed / Skipped / Total] 622 / 208 / 24 / 854:  85%|████████▌ | 854/1000 [34:19<05:52,  2.41s/it][Succeeded / Failed / Skipped / Total] 622 / 208 / 24 / 854:  86%|████████▌ | 855/1000 [34:21<05:49,  2.41s/it][Succeeded / Failed / Skipped / Total] 622 / 209 / 24 / 855:  86%|████████▌ | 855/1000 [34:21<05:49,  2.41s/it][Succeeded / Failed / Skipped / Total] 622 / 209 / 24 / 855:  86%|████████▌ | 856/1000 [34:23<05:47,  2.41s/it][Succeeded / Failed / Skipped / Total] 622 / 210 / 24 / 856:  86%|████████▌ | 856/1000 [34:23<05:47,  2.41s/it][Succeeded / Failed / Skipped / Total] 622 / 210 / 24 / 856:  86%|████████▌ | 857/1000 [34:23<05:44,  2.41s/it][Succeeded / Failed / Skipped / Total] 622 / 211 / 24 / 857:  86%|████████▌ | 857/1000 [34:23<05:44,  2.41s/it][Succeeded / Failed / Skipped / Total] 622 / 211 / 24 / 857:  86%|████████▌ | 858/1000 [34:30<05:42,  2.41s/it]Adds a constant reference to the constant pool . --> additionshearstityisce loss --> Socre: 1.0

[[[[Adv]]]]: private Entry [[addConstantMemberReference]] ( final int [[tag]] , final String [[owner]] , final String [[name]] , final String descriptor ) { int hashCode = hash ( [[tag]] , [[owner]] , [[name]] , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == hashCode && entry . owner . equals ( [[owner]] ) && entry . name . equals ( [[name]] ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( [[tag]] , addConstantClass ( [[owner]] ) . index , addConstantNameAndType ( [[name]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , [[owner]] , [[name]] , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry [[additionshearstityiscecodict]] ( final int [[i]] , final String [[own]] , final String [[ic]] , final String descriptor ) { int hashCode = hash ( [[i]] , [[own]] , [[ic]] , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[i]] && entry . hashCode == hashCode && entry . owner . equals ( [[own]] ) && entry . name . equals ( [[ic]] ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( [[i]] , addConstantClass ( [[own]] ) . index , addConstantNameAndType ( [[ic]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , [[i]] , [[own]] , [[ic]] , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a constant . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int [[hashCode]] = hash ( tag , value ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[hashCode]] && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int [[hatag]] = hash ( tag , value ) ; Entry entry = get ( [[hatag]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[hatag]] && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , [[hatag]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a constant . --> Add constantDynamic --> Socre: 1.0

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String [[descriptor]] , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol [[bootstrapMethod]] = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , [[descriptor]] , [[bootstrapMethod]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String [[detvatty]] , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol [[wasscapgapud]] = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , [[detvatty]] , [[wasscapgapud]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 855 ---------------------------------------------
Adds constant UTF - 8 . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int [[index]] , final String value ) { add ( new Entry ( [[index]] , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[exportjunstatpdo]] ( final int [[arrow]] , final String value ) { add ( new Entry ( [[arrow]] , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 856 ---------------------------------------------
Adds a UTF - 8 string to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: int [[addConstantUtf8]] ( final String value ) { int [[hashCode]] = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == Symbol . CONSTANT_UTF8_TAG && [[entry]] . hashCode == [[hashCode]] && [[entry]] . value . equals ( value ) ) { return [[entry]] . index ; } [[entry]] = [[entry]] . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[applyeauenuntfclass]] ( final String value ) { int [[fullfold]] = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry [[exit]] = get ( [[fullfold]] ) ; while ( [[exit]] != null ) { if ( [[exit]] . tag == Symbol . CONSTANT_UTF8_TAG && [[exit]] . hashCode == [[fullfold]] && [[exit]] . value . equals ( value ) ) { return [[exit]] . index ; } [[exit]] = [[exit]] . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , [[fullfold]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 857 ---------------------------------------------
Adds a constant name to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantNameAndType]] ( final int index , final String [[name]] , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , [[name]] , descriptor , hash ( tag , [[name]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[enterenraganitrandearclass]] ( final int index , final String [[book]] , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , [[book]] , descriptor , hash ( tag , [[book]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
[Succeeded / Failed / Skipped / Total] 623 / 211 / 24 / 858:  86%|████████▌ | 858/1000 [34:30<05:42,  2.41s/it][Succeeded / Failed / Skipped / Total] 623 / 211 / 24 / 858:  86%|████████▌ | 859/1000 [34:37<05:41,  2.42s/it][Succeeded / Failed / Skipped / Total] 623 / 212 / 24 / 859:  86%|████████▌ | 859/1000 [34:37<05:41,  2.42s/it][Succeeded / Failed / Skipped / Total] 623 / 212 / 24 / 859:  86%|████████▌ | 860/1000 [34:39<05:38,  2.42s/it][Succeeded / Failed / Skipped / Total] 624 / 212 / 24 / 860:  86%|████████▌ | 860/1000 [34:39<05:38,  2.42s/it][Succeeded / Failed / Skipped / Total] 624 / 212 / 24 / 860:  86%|████████▌ | 861/1000 [34:43<05:36,  2.42s/it][Succeeded / Failed / Skipped / Total] 625 / 212 / 24 / 861:  86%|████████▌ | 861/1000 [34:43<05:36,  2.42s/it][Succeeded / Failed / Skipped / Total] 625 / 212 / 24 / 861:  86%|████████▌ | 862/1000 [34:45<05:33,  2.42s/it][Succeeded / Failed / Skipped / Total] 626 / 212 / 24 / 862:  86%|████████▌ | 862/1000 [34:45<05:33,  2.42s/it][Succeeded / Failed / Skipped / Total] 626 / 212 / 24 / 862:  86%|████████▋ | 863/1000 [34:49<05:31,  2.42s/it][Succeeded / Failed / Skipped / Total] 627 / 212 / 24 / 863:  86%|████████▋ | 863/1000 [34:49<05:31,  2.42s/it][Succeeded / Failed / Skipped / Total] 627 / 212 / 24 / 863:  86%|████████▋ | 864/1000 [34:50<05:29,  2.42s/it]--------------------------------------------- Result 858 ---------------------------------------------
Add a constant method handle . --> prefixinpanemodotantoint --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodHandle]] ( final int [[referenceKind]] , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int [[tag]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[prefixinpanemodotantoint]] ( final int [[genericcomb]] , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int [[s]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a constant . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol [[addConstantLongOrDouble]] ( final int [[tag]] , final long value ) { int hashCode = hash ( [[tag]] , value ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == hashCode && [[entry]] . data == value ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } int index = constantPoolCount ; constantPool . putByte ( [[tag]] ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , [[tag]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[geteantentyintxoaful]] ( final int [[single]] , final long value ) { int hashCode = hash ( [[single]] , value ) ; Entry [[column]] = get ( hashCode ) ; while ( [[column]] != null ) { if ( [[column]] . tag == [[single]] && [[column]] . hashCode == hashCode && [[column]] . data == value ) { return [[column]] ; } [[column]] = [[column]] . next ; } int index = constantPoolCount ; constantPool . putByte ( [[single]] ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , [[single]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 860 ---------------------------------------------
Adds a constant . --> zrenaxtecducch Sch --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[zrenaxtecducchoadvoktjomountrilong]] ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 861 ---------------------------------------------
Adds a constant method handle . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMethodHandle]] ( final int index , final int referenceKind , final String owner , final String [[name]] , final String [[descriptor]] ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , [[name]] , [[descriptor]] , referenceKind ) ; add ( new Entry ( index , tag , owner , [[name]] , [[descriptor]] , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[additionsotesurtimetionunddlo]] ( final int index , final int referenceKind , final String owner , final String [[owner]] , final String [[duitert]] ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , [[owner]] , [[duitert]] , referenceKind ) ; add ( new Entry ( index , tag , owner , [[owner]] , [[duitert]] , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 862 ---------------------------------------------
Adds a string to the constant pool . --> i1juntridcce HTTP method --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8Reference]] ( final int [[index]] , final int [[tag]] , final String value ) { add ( new Entry ( [[index]] , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[i1juntridccefy]] ( final int [[tag]] , final int [[t]] , final String value ) { add ( new Entry ( [[tag]] , [[t]] , value , hash ( [[t]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 863 ---------------------------------------------
Adds a new constant . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int [[hashCode]] = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[assignlikepararadeviccalerverhernemicprover]] ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int [[big_]] = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , [[big_]] ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 864 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 628 / 212 / 24 / 864:  86%|████████▋ | 864/1000 [34:50<05:29,  2.42s/it][Succeeded / Failed / Skipped / Total] 628 / 212 / 24 / 864:  86%|████████▋ | 865/1000 [34:53<05:26,  2.42s/it][Succeeded / Failed / Skipped / Total] 629 / 212 / 24 / 865:  86%|████████▋ | 865/1000 [34:53<05:26,  2.42s/it][Succeeded / Failed / Skipped / Total] 629 / 212 / 24 / 865:  87%|████████▋ | 866/1000 [34:58<05:24,  2.42s/it][Succeeded / Failed / Skipped / Total] 629 / 213 / 24 / 866:  87%|████████▋ | 866/1000 [34:58<05:24,  2.42s/it][Succeeded / Failed / Skipped / Total] 629 / 213 / 24 / 866:  87%|████████▋ | 867/1000 [35:05<05:22,  2.43s/it][Succeeded / Failed / Skipped / Total] 630 / 213 / 24 / 867:  87%|████████▋ | 867/1000 [35:05<05:22,  2.43s/it][Succeeded / Failed / Skipped / Total] 630 / 214 / 24 / 868:  87%|████████▋ | 868/1000 [35:05<05:20,  2.43s/it][Succeeded / Failed / Skipped / Total] 630 / 214 / 24 / 868:  87%|████████▋ | 869/1000 [35:05<05:17,  2.42s/it][Succeeded / Failed / Skipped / Total] 630 / 215 / 24 / 869:  87%|████████▋ | 869/1000 [35:05<05:17,  2.42s/it][Succeeded / Failed / Skipped / Total] 631 / 215 / 24 / 870:  87%|████████▋ | 870/1000 [35:06<05:14,  2.42s/it][Succeeded / Failed / Skipped / Total] 631 / 215 / 24 / 870:  87%|████████▋ | 871/1000 [35:07<05:12,  2.42s/it][Succeeded / Failed / Skipped / Total] 632 / 215 / 24 / 871:  87%|████████▋ | 871/1000 [35:07<05:12,  2.42s/it]Removes all entries . --> Perform a post operation --> Socre: 1.0

[[[[Adv]]]]: public HttpMultiMap < V > [[clear]] ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > [[post]] ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 865 ---------------------------------------------
Adds a constant pool entry . --> tchlikemittrawin8 --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantUtf8Reference]] ( final int tag , final String value ) { int [[hashCode]] = hash ( tag , value ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[hashCode]] && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[tchlikemittrawin8xflict]] ( final int tag , final String value ) { int [[ashpass]] = hash ( tag , value ) ; Entry entry = get ( [[ashpass]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[ashpass]] && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , [[ashpass]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 866 ---------------------------------------------
Adds the relation type . --> [[[FAILED]]]

[[[[Adv]]]]: int addMergedType ( final int [[typeTableIndex1]] , final int [[typeTableIndex2]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int addMergedType ( final int [[classimateindectflags]] , final int [[languageofignpassred]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 867 ---------------------------------------------
Append a char buffer . --> append at end --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence csq , final int [[start]] , final int end ) { for ( int i = [[start]] ; i < end ; i ++ ) { append ( csq . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence csq , final int [[read]] , final int end ) { for ( int i = [[read]] ; i < end ; i ++ ) { append ( csq . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 868 ---------------------------------------------
Returns all entries from head . --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > [[all]] = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { [[all]] . add ( e ) ; e = e . after ; } return [[all]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[enter]] ( ) { List < Map . Entry < String , V > > [[art]] = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { [[art]] . add ( e ) ; e = e . after ; } return [[art]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 869 ---------------------------------------------
Adds the constant for the bootstrap method . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantInvokeDynamic]] ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[intjununitaloundwamet]] ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 870 ---------------------------------------------
Get all the values with the given name . --> keep equal for this designation --> Socre: 1.0

[[[[Adv]]]]: public List < V > [[getAll]] ( final String [[name]] ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( [[name]] ) ; int i = index ( h ) ; MapEntry < V > [[e]] = entries [ i ] ; while ( [[e]] != null ) { if ( [[e]] . hash == h && eq ( [[name]] , [[e]] . key ) ) { values . addFirst ( [[e]] . getValue ( ) ) ; } [[e]] = [[e]] . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > [[keepold]] ( final String [[designation]] ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( [[designation]] ) ; int i = index ( h ) ; MapEntry < V > [[o]] = entries [ i ] ; while ( [[o]] != null ) { if ( [[o]] . hash == h && eq ( [[designation]] , [[o]] . key ) ) { values . addFirst ( [[o]] . getValue ( ) ) ; } [[o]] = [[o]] . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 871 ---------------------------------------------
Grow the capacity . --> Sustain a given capacity --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int minCapacity ) { final int oldCapacity = buffer . length ; int [[newCapacity]] = oldCapacity << 1 ; if ( [[newCapacity]] - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[sustain]] ( final int minCapacity ) { final int oldCapacity = buffer . length ; int [[npercescy]] = oldCapacity << 1 ; if ( [[npercescy]] - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 872 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 632 / 216 / 24 / 872:  87%|████████▋ | 872/1000 [35:09<05:09,  2.42s/it][Succeeded / Failed / Skipped / Total] 632 / 216 / 24 / 872:  87%|████████▋ | 873/1000 [35:12<05:07,  2.42s/it][Succeeded / Failed / Skipped / Total] 633 / 216 / 24 / 873:  87%|████████▋ | 873/1000 [35:12<05:07,  2.42s/it][Succeeded / Failed / Skipped / Total] 633 / 217 / 24 / 874:  87%|████████▋ | 874/1000 [35:13<05:04,  2.42s/it][Succeeded / Failed / Skipped / Total] 633 / 217 / 24 / 874:  88%|████████▊ | 875/1000 [35:13<05:01,  2.42s/it][Succeeded / Failed / Skipped / Total] 634 / 217 / 24 / 875:  88%|████████▊ | 875/1000 [35:14<05:02,  2.42s/it][Succeeded / Failed / Skipped / Total] 634 / 218 / 24 / 876:  88%|████████▊ | 876/1000 [35:14<04:59,  2.41s/it][Succeeded / Failed / Skipped / Total] 634 / 218 / 24 / 876:  88%|████████▊ | 877/1000 [35:15<04:56,  2.41s/it][Succeeded / Failed / Skipped / Total] 635 / 218 / 24 / 877:  88%|████████▊ | 877/1000 [35:15<04:56,  2.41s/it][Succeeded / Failed / Skipped / Total] 636 / 218 / 24 / 878:  88%|████████▊ | 878/1000 [35:18<04:54,  2.41s/it][Succeeded / Failed / Skipped / Total] 636 / 218 / 24 / 878:  88%|████████▊ | 879/1000 [35:19<04:51,  2.41s/it][Succeeded / Failed / Skipped / Total] 637 / 218 / 24 / 879:  88%|████████▊ | 879/1000 [35:19<04:51,  2.41s/it]Adds the bootstrap method . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle [[bootstrapMethodHandle]] , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[assignmentbittrumpelohod]] ( final Handle [[aresmakmclortnetl]] , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 873 ---------------------------------------------
Create the first chain . --> This method is called when the bringithfronthavenlld S --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[bringithfronthavenlldavamponbase]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 874 ---------------------------------------------
Returns an iterator over the entries . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[iterator]] ( ) { final MapEntry [ ] [[e]] = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return [[e]] [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[next]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[next]] = [[e]] [ 0 ] ; [[e]] [ 0 ] = [[e]] [ 0 ] . after ; return [[next]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[thisamatric]] ( ) { final MapEntry [ ] [[he]] = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return [[he]] [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[alphabet]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[alphabet]] = [[he]] [ 0 ] ; [[he]] [ 0 ] = [[he]] [ 0 ] . after ; return [[alphabet]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 875 ---------------------------------------------
Pushes a field . --> Pushes a group --> Socre: 1.0

[[[[Adv]]]]: public Path push ( final CharSequence [[field]] ) { _push ( [[field]] ) ; if ( altPath != null ) { altPath . push ( [[field]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path push ( final CharSequence [[group]] ) { _push ( [[group]] ) ; if ( altPath != null ) { altPath . push ( [[group]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 876 ---------------------------------------------
Returns the hash code for the given name . --> [[[FAILED]]]

[[[[Adv]]]]: private int [[hash]] ( final String name ) { int h = 0 ; for ( int [[i]] = name . length ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { char c = name . charAt ( [[i]] ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int [[match]] ( final String name ) { int h = 0 ; for ( int [[he]] = name . length ( ) - 1 ; [[he]] >= 0 ; [[he]] -- ) { char c = name . charAt ( [[he]] ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 877 ---------------------------------------------
Visits an annotation . --> overrides the visitor to get the annotation description --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor [[visitAnnotation]] ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor [[takeposterakrd]] ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 878 ---------------------------------------------
Executes the proxy . --> Execute the path --> Socre: 1.0

[[[[Adv]]]]: public Object execute ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object [[next]] = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( [[next]] ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object execute ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object [[z]] = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( [[z]] ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 879 ---------------------------------------------
Parse a path . --> Returns the parlan for the given field --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[parlan]] ( final String [[field]] ) { return [[field]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[field]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 880 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 638 / 218 / 24 / 880:  88%|████████▊ | 880/1000 [35:23<04:49,  2.41s/it][Succeeded / Failed / Skipped / Total] 638 / 218 / 24 / 880:  88%|████████▊ | 881/1000 [35:24<04:46,  2.41s/it][Succeeded / Failed / Skipped / Total] 639 / 218 / 24 / 881:  88%|████████▊ | 881/1000 [35:24<04:46,  2.41s/it][Succeeded / Failed / Skipped / Total] 640 / 218 / 24 / 882:  88%|████████▊ | 882/1000 [35:27<04:44,  2.41s/it][Succeeded / Failed / Skipped / Total] 640 / 218 / 24 / 882:  88%|████████▊ | 883/1000 [35:29<04:42,  2.41s/it][Succeeded / Failed / Skipped / Total] 641 / 218 / 24 / 883:  88%|████████▊ | 883/1000 [35:29<04:42,  2.41s/it][Succeeded / Failed / Skipped / Total] 642 / 218 / 24 / 884:  88%|████████▊ | 884/1000 [35:33<04:40,  2.41s/it][Succeeded / Failed / Skipped / Total] 642 / 218 / 24 / 884:  88%|████████▊ | 885/1000 [35:34<04:37,  2.41s/it][Succeeded / Failed / Skipped / Total] 642 / 219 / 24 / 885:  88%|████████▊ | 885/1000 [35:34<04:37,  2.41s/it]Configure servlet context . --> civilterstour servlets --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[civilfiguettourvdluconcy]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 881 ---------------------------------------------
Visits the current tmd . --> Create the first tmd in the list --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[visitEnd]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void [[returnage]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[ip]] = 0 ; [[ip]] < tmd . proxyData . length ; [[ip]] ++ ) { tmd . selectCurrentProxy ( [[ip]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 882 ---------------------------------------------
Reads a property . --> checkfocantor method --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object source , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[checkfocantor]] ( final Object source , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 883 ---------------------------------------------
Creates a BeanDefinition . --> Create a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[originalType]] = type ; final ProxettaFactory [[builder]] = proxetta . proxy ( ) ; [[builder]] . setTarget ( type ) ; type = [[builder]] . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , [[originalType]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[originallytype]] = type ; final ProxettaFactory [[form]] = proxetta . proxy ( ) ; [[form]] . setTarget ( type ) ; type = [[form]] . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , [[originallytype]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 884 ---------------------------------------------
Adds the contents of the given map to this map . --> region > biter --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map t ) { for ( Object [[o]] : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) [[o]] ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[biter]] ( final Map t ) { for ( Object [[object]] : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) [[object]] ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 885 ---------------------------------------------
Create the method visitor for the first method that is being read . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , tmd . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[creatingwirdthirtplayingthfield]] ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , tmd . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 886 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 643 / 219 / 24 / 886:  89%|████████▊ | 886/1000 [35:36<04:34,  2.41s/it][Succeeded / Failed / Skipped / Total] 643 / 219 / 24 / 886:  89%|████████▊ | 887/1000 [35:41<04:32,  2.41s/it][Succeeded / Failed / Skipped / Total] 644 / 219 / 24 / 887:  89%|████████▊ | 887/1000 [35:41<04:32,  2.41s/it][Succeeded / Failed / Skipped / Total] 645 / 219 / 24 / 888:  89%|████████▉ | 888/1000 [35:42<04:30,  2.41s/it][Succeeded / Failed / Skipped / Total] 645 / 219 / 24 / 888:  89%|████████▉ | 889/1000 [35:43<04:27,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 219 / 24 / 889:  89%|████████▉ | 889/1000 [35:43<04:27,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 220 / 24 / 890:  89%|████████▉ | 890/1000 [35:43<04:24,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 220 / 24 / 890:  89%|████████▉ | 891/1000 [35:44<04:22,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 221 / 24 / 891:  89%|████████▉ | 891/1000 [35:44<04:22,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 222 / 24 / 892:  89%|████████▉ | 892/1000 [35:49<04:20,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 222 / 24 / 892:  89%|████████▉ | 893/1000 [35:50<04:17,  2.41s/it]Append a buffer . --> Convenience method for removing an array --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[annended]] ( final Buffer [[array]] ) { if ( [[array]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 887 ---------------------------------------------
Returns all the fields . --> A bereialdersmadinator implementation --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor [ ] [[getAllFieldDescriptors]] ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[index]] = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ [[index]] ] = fieldDescriptor ; [[index]] ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[allFields]] = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] [[bereialdersmadinator]] ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[age]] = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ [[age]] ] = fieldDescriptor ; [[age]] ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[everyfarms]] = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 888 ---------------------------------------------
Writes this object to the specified writer . --> This function is called from springo method --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final Writer writer ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable [[uploadable]] = ( Uploadable ) o ; InputStream inputStream = [[uploadable]] . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void [[springo]] ( final Writer writer ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable [[upperwled]] = ( Uploadable ) o ; InputStream inputStream = [[upperwled]] . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 889 ---------------------------------------------
Writes the input stream to the output stream . --> Opens a list of Uploadable --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[fastByteBuffer]] = ( FastByteBuffer ) o ; out . write ( [[fastByteBuffer]] . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , out ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void [[writething]] ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[flashlydebhav]] = ( FastByteBuffer ) o ; out . write ( [[flashlydebhav]] . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , out ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 890 ---------------------------------------------
Converts the given transaction mode into the isolation level . --> [[[FAILED]]]

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode txMode ) { final int [[isolation]] ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[isolation]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[isolation]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[isolation]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[isolation]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[isolation]] , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[reformncicoide]] ( final JtxTransactionMode txMode ) { final int [[alarm]] ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[alarm]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[alarm]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[alarm]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[alarm]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[alarm]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[alarm]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[alarm]] , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 891 ---------------------------------------------
Writes the Http progress listener to the OutputStream . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[closeode]] ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 892 ---------------------------------------------
Returns the string value for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getString]] ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[starttorck]] ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 893 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 646 / 223 / 24 / 893:  89%|████████▉ | 893/1000 [35:50<04:17,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 224 / 24 / 894:  89%|████████▉ | 894/1000 [35:54<04:15,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 224 / 24 / 894:  90%|████████▉ | 895/1000 [35:57<04:13,  2.41s/it][Succeeded / Failed / Skipped / Total] 646 / 225 / 24 / 895:  90%|████████▉ | 895/1000 [35:57<04:13,  2.41s/it][Succeeded / Failed / Skipped / Total] 647 / 225 / 24 / 896:  90%|████████▉ | 896/1000 [35:58<04:10,  2.41s/it][Succeeded / Failed / Skipped / Total] 647 / 225 / 24 / 896:  90%|████████▉ | 897/1000 [35:59<04:07,  2.41s/it][Succeeded / Failed / Skipped / Total] 648 / 225 / 24 / 897:  90%|████████▉ | 897/1000 [35:59<04:07,  2.41s/it][Succeeded / Failed / Skipped / Total] 648 / 226 / 24 / 898:  90%|████████▉ | 898/1000 [35:59<04:05,  2.40s/it][Succeeded / Failed / Skipped / Total] 648 / 226 / 24 / 898:  90%|████████▉ | 899/1000 [35:59<04:02,  2.40s/it][Succeeded / Failed / Skipped / Total] 648 / 227 / 24 / 899:  90%|████████▉ | 899/1000 [35:59<04:02,  2.40s/it][Succeeded / Failed / Skipped / Total] 648 / 228 / 24 / 900:  90%|█████████ | 900/1000 [36:01<04:00,  2.40s/it][Succeeded / Failed / Skipped / Total] 648 / 228 / 24 / 900:  90%|█████████ | 901/1000 [36:03<03:57,  2.40s/it][Succeeded / Failed / Skipped / Total] 649 / 228 / 24 / 901:  90%|█████████ | 901/1000 [36:03<03:57,  2.40s/it]Gets a value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[val]] = ( T ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[pal]] = ( T ) map . get ( key ) ; if ( [[pal]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[pal]] ) ; } if ( [[pal]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[pal]] ) ; } return [[pal]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 894 ---------------------------------------------
Get a long value . --> [[[FAILED]]]

[[[[Adv]]]]: public Long [[getLong]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long [[findlock]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 895 ---------------------------------------------
Returns the Integer value for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getInteger]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer [[stringcomtext]] ( final String [[minor]] ) { Number number = ( Number ) map . get ( [[minor]] ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 896 ---------------------------------------------
Updates the flags of a received email . --> review lemma --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[reviewmahilfaaver]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 897 ---------------------------------------------
Receives a set of messages . --> Receives messages from a EmailFilter --> Socre: 1.0

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[filter]] , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[filter]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[filter]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[band]] , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[band]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[band]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 898 ---------------------------------------------
Put a string value . --> [[[FAILED]]]

[[[[Adv]]]]: public JsonObject put ( final String key , final String [[value]] ) { Objects . requireNonNull ( key ) ; map . put ( key , [[value]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject put ( final String key , final String [[piece]] ) { Objects . requireNonNull ( key ) ; map . put ( key , [[piece]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 899 ---------------------------------------------
Retrieve a Double . --> [[[FAILED]]]

[[[[Adv]]]]: public Double [[getDouble]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[bigenac]] ( final String [[major]] ) { Number number = ( Number ) map . get ( [[major]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 900 ---------------------------------------------
Retrieves a Float . --> [[[FAILED]]]

[[[[Adv]]]]: public Float [[getFloat]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float [[buypleoca]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 901 ---------------------------------------------
Returns the alias of the given target . --> Returns the md of the given target string --> Socre: 1.0

[[[[Adv]]]]: protected String [[alias]] ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[md]] ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 902 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 650 / 228 / 24 / 902:  90%|█████████ | 902/1000 [36:11<03:55,  2.41s/it][Succeeded / Failed / Skipped / Total] 650 / 228 / 24 / 902:  90%|█████████ | 903/1000 [36:12<03:53,  2.41s/it][Succeeded / Failed / Skipped / Total] 651 / 228 / 24 / 903:  90%|█████████ | 903/1000 [36:12<03:53,  2.41s/it][Succeeded / Failed / Skipped / Total] 652 / 228 / 24 / 904:  90%|█████████ | 904/1000 [36:14<03:50,  2.41s/it][Succeeded / Failed / Skipped / Total] 652 / 228 / 24 / 904:  90%|█████████ | 905/1000 [36:14<03:48,  2.40s/it][Succeeded / Failed / Skipped / Total] 653 / 228 / 24 / 905:  90%|█████████ | 905/1000 [36:14<03:48,  2.40s/it][Succeeded / Failed / Skipped / Total] 653 / 229 / 24 / 906:  91%|█████████ | 906/1000 [36:16<03:45,  2.40s/it][Succeeded / Failed / Skipped / Total] 653 / 229 / 24 / 906:  91%|█████████ | 907/1000 [36:21<03:43,  2.41s/it][Succeeded / Failed / Skipped / Total] 654 / 229 / 24 / 907:  91%|█████████ | 907/1000 [36:21<03:43,  2.41s/it][Succeeded / Failed / Skipped / Total] 655 / 229 / 24 / 908:  91%|█████████ | 908/1000 [36:21<03:41,  2.40s/it][Succeeded / Failed / Skipped / Total] 655 / 229 / 24 / 908:  91%|█████████ | 909/1000 [36:22<03:38,  2.40s/it][Succeeded / Failed / Skipped / Total] 656 / 229 / 24 / 909:  91%|█████████ | 909/1000 [36:22<03:38,  2.40s/it][Succeeded / Failed / Skipped / Total] 657 / 229 / 24 / 910:  91%|█████████ | 910/1000 [36:25<03:36,  2.40s/it][Succeeded / Failed / Skipped / Total] 657 / 229 / 24 / 910:  91%|█████████ | 911/1000 [36:26<03:33,  2.40s/it]Sets the folder to use . --> Open a newmount event --> Socre: 1.0

[[[[Adv]]]]: public void [[useFolder]] ( final String [[folderName]] ) { closeFolderIfOpened ( folder ) ; try { this . folderName = [[folderName]] ; this . folder = getService ( ) . getFolder ( [[folderName]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[folderName]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void [[usingmountatter]] ( final String [[programmore]] ) { closeFolderIfOpened ( folder ) ; try { this . folderName = [[programmore]] ; this . folder = getService ( ) . getFolder ( [[programmore]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[programmore]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 903 ---------------------------------------------
Closes the Folder --> frontbookdevhafiized --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder [[folder]] ) { if ( [[folder]] != null ) { try { [[folder]] . close ( "[[True]]" == "[[True]]" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[frontbookdevhafiized]] ( final Folder [[collection]] ) { if ( [[collection]] != null ) { try { [[collection]] . close ( "[[back]]" == "[[back]]" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 904 ---------------------------------------------
Validates an action . --> Check if a fractionetfrivity is enabled --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[violations]] = vtor . getViolations ( ) ; return [[violations]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[fractionetfrivity]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[breach]] = vtor . getViolations ( ) ; return [[breach]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 905 ---------------------------------------------
Adds a new Violation . --> Prepare ajinolah --> Socre: 1.0

[[[[Adv]]]]: protected void [[addViolation]] ( final String name , final Object [[invalidValue]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , [[invalidValue]] ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[ajinolah]] ( final String name , final Object [[otherusual]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , [[otherusual]] ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 906 ---------------------------------------------
Get target stream . --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[zriit]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 907 ---------------------------------------------
Process the target class . --> Proxetta exception --> Socre: 1.0

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[device]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 908 ---------------------------------------------
Set the mime type as value . --> Sets the property data as a property . --> Socre: 1.0

[[[[Adv]]]]: public RawData as ( final String [[mimeOrExtension]] ) { if ( [[mimeOrExtension]] . contains ( StringPool . SLASH ) ) { this . [[mimeType]] = [[mimeOrExtension]] ; } else { this . [[mimeType]] = MimeTypes . getMimeType ( [[mimeOrExtension]] ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData as ( final String [[bimexporedkatii]] ) { if ( [[bimexporedkatii]] . contains ( StringPool . SLASH ) ) { this . [[mnmppy]] = [[bimexporedkatii]] ; } else { this . [[mnmppy]] = MimeTypes . getMimeType ( [[bimexporedkatii]] ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 909 ---------------------------------------------
Lookup a named parameter . --> Play a blank keyword --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( [[name]] ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[playsetdengsasaperation]] ( final String [[size]] ) { DbQueryNamedParameter [[ip]] = rootNP ; while ( [[ip]] != null ) { if ( [[ip]] . equalsName ( [[size]] ) ) { return [[ip]] ; } [[ip]] = [[ip]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 910 ---------------------------------------------
Create the proxy . --> capture the proxy --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[capture]] ( ) { process ( ) ; byte [ ] [[front]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[front]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[front]] ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 911 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 657 / 230 / 24 / 911:  91%|█████████ | 911/1000 [36:26<03:33,  2.40s/it][Succeeded / Failed / Skipped / Total] 657 / 231 / 24 / 912:  91%|█████████ | 912/1000 [36:28<03:31,  2.40s/it][Succeeded / Failed / Skipped / Total] 657 / 231 / 24 / 912:  91%|█████████▏| 913/1000 [36:29<03:28,  2.40s/it][Succeeded / Failed / Skipped / Total] 658 / 231 / 24 / 913:  91%|█████████▏| 913/1000 [36:29<03:28,  2.40s/it][Succeeded / Failed / Skipped / Total] 659 / 231 / 24 / 914:  91%|█████████▏| 914/1000 [36:31<03:26,  2.40s/it][Succeeded / Failed / Skipped / Total] 659 / 231 / 24 / 914:  92%|█████████▏| 915/1000 [36:32<03:23,  2.40s/it][Succeeded / Failed / Skipped / Total] 660 / 231 / 24 / 915:  92%|█████████▏| 915/1000 [36:32<03:23,  2.40s/it][Succeeded / Failed / Skipped / Total] 661 / 231 / 24 / 916:  92%|█████████▏| 916/1000 [36:32<03:21,  2.39s/it][Succeeded / Failed / Skipped / Total] 661 / 231 / 24 / 916:  92%|█████████▏| 917/1000 [36:33<03:18,  2.39s/it][Succeeded / Failed / Skipped / Total] 662 / 231 / 24 / 917:  92%|█████████▏| 917/1000 [36:33<03:18,  2.39s/it]Gets the target class . --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[setTarget]] ( final String [[targetName]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[targetName]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[targetName]] ) ; } targetClassName = [[targetName]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[targetName]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T [[zatalgent]] ( final String [[trackdicate]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[trackdicate]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[trackdicate]] ) ; } targetClassName = [[trackdicate]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[trackdicate]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 912 ---------------------------------------------
Get target object . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[setTarget]] ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[hetmidx]] ( final Class [[principal]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[principal]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[principal]] . getName ( ) ) ; } targetClass = [[principal]] ; targetClassName = [[principal]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[principal]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 913 ---------------------------------------------
Define the class . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[classLoader]] = proxetta . getClassLoader ( ) ; if ( [[classLoader]] == null ) { [[classLoader]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[classLoader]] == null ) && ( targetClass != null ) ) { [[classLoader]] = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , [[classLoader]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[discipline]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[baseshoa]] = proxetta . getClassLoader ( ) ; if ( [[baseshoa]] == null ) { [[baseshoa]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[baseshoa]] == null ) && ( targetClass != null ) ) { [[baseshoa]] = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , [[baseshoa]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 914 ---------------------------------------------
Converts a EmailAddress to a EmailAddress . --> Create a EmailAddress --> Socre: 1.0

[[[[Adv]]]]: public T to ( final String personalName , final String [[to]] ) { return to ( new EmailAddress ( personalName , to ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T to ( final String personalName , final String [[after]] ) { return to ( new EmailAddress ( personalName , to ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 915 ---------------------------------------------
Set the cc . --> Set a new EmailAddress --> Socre: 1.0

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[canvas]] ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 916 ---------------------------------------------
Add a Email address --> Create a new EmailAddress --> Socre: 1.0

[[[[Adv]]]]: public T from ( final String [[personalName]] , final String from ) { return from ( new EmailAddress ( [[personalName]] , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T from ( final String [[employeeche]] , final String from ) { return from ( new EmailAddress ( [[employeeche]] , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 917 ---------------------------------------------
Downloads the file content . --> streaming purchaseefmanaem --> Socre: 1.0

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String [[downloadFileName]] ) { this . downloadFileName = [[downloadFileName]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[streamingarchive]] ( final String [[purchaseefmanaem]] ) { this . downloadFileName = [[purchaseefmanaem]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[purchaseefmanaem]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 918 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 663 / 231 / 24 / 918:  92%|█████████▏| 918/1000 [36:35<03:16,  2.39s/it][Succeeded / Failed / Skipped / Total] 663 / 231 / 24 / 918:  92%|█████████▏| 919/1000 [36:35<03:13,  2.39s/it][Succeeded / Failed / Skipped / Total] 664 / 231 / 24 / 919:  92%|█████████▏| 919/1000 [36:35<03:13,  2.39s/it][Succeeded / Failed / Skipped / Total] 664 / 232 / 24 / 920:  92%|█████████▏| 920/1000 [36:35<03:10,  2.39s/it][Succeeded / Failed / Skipped / Total] 664 / 232 / 24 / 920:  92%|█████████▏| 921/1000 [36:37<03:08,  2.39s/it][Succeeded / Failed / Skipped / Total] 665 / 232 / 24 / 921:  92%|█████████▏| 921/1000 [36:37<03:08,  2.39s/it][Succeeded / Failed / Skipped / Total] 666 / 232 / 24 / 922:  92%|█████████▏| 922/1000 [36:41<03:06,  2.39s/it][Succeeded / Failed / Skipped / Total] 666 / 232 / 24 / 922:  92%|█████████▏| 923/1000 [36:43<03:03,  2.39s/it][Succeeded / Failed / Skipped / Total] 667 / 232 / 24 / 923:  92%|█████████▏| 923/1000 [36:43<03:03,  2.39s/it][Succeeded / Failed / Skipped / Total] 668 / 232 / 24 / 924:  92%|█████████▏| 924/1000 [36:45<03:01,  2.39s/it][Succeeded / Failed / Skipped / Total] 668 / 232 / 24 / 924:  92%|█████████▎| 925/1000 [36:47<02:58,  2.39s/it][Succeeded / Failed / Skipped / Total] 668 / 233 / 24 / 925:  92%|█████████▎| 925/1000 [36:47<02:58,  2.39s/it][Succeeded / Failed / Skipped / Total] 669 / 233 / 24 / 926:  93%|█████████▎| 926/1000 [36:49<02:56,  2.39s/it][Succeeded / Failed / Skipped / Total] 669 / 233 / 24 / 926:  93%|█████████▎| 927/1000 [36:50<02:54,  2.38s/it]Creates new instance of Proxetta class . --> region Proxetta --> Socre: 1.0

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class [[type]] = define ( ) ; try { return ClassUtil . newInstance ( [[type]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[backextries]] ( ) { Class [[design]] = define ( ) ; try { return ClassUtil . newInstance ( [[design]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 919 ---------------------------------------------
Returns the given REPLACEME0 . --> Get the address of the given REPLACEME0 --> Socre: 1.0

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . [[replyTo]] = ArraysUtil . join ( this . [[replyTo]] , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . [[matchode]] = ArraysUtil . join ( this . [[matchode]] , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 920 ---------------------------------------------
Append an address to the object . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[to]] ( final EmailAddress [[to]] ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[say]] ( final EmailAddress [[time]] ) { this . [[same]] = ArraysUtil . append ( this . [[same]] , [[say]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 921 ---------------------------------------------
Print debug folder . --> lowtypefrabipformle method --> Socre: 1.0

[[[[Adv]]]]: protected void [[dumpClassInDebugFolder]] ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void [[lowtypefrabipformle]] ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 922 ---------------------------------------------
Gets a property . --> Get nameuview --> Socre: 1.0

[[[[Adv]]]]: public static String get ( final String name , final String [[defaultValue]] ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[defaultValue]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String get ( final String name , final String [[nameuview]] ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[nameuview]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 923 ---------------------------------------------
Adds a header . --> format a string --> Socre: 1.0

[[[[Adv]]]]: public T [[header]] ( final String [[name]] , final String value ) { headers . put ( [[name]] , value ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[format]] ( final String [[key]] , final String value ) { headers . put ( [[key]] , value ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 924 ---------------------------------------------
Adds an html message . --> Set the JCR type --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String [[html]] , final String encoding ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[brandmisarade]] ( final String [[vr]] , final String encoding ) { return message ( new EmailMessage ( [[vr]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 925 ---------------------------------------------
Gets parameter names . --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[kescoreprometerrs]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 926 ---------------------------------------------
Serialize key value . --> Get the galjectful clickable --> Socre: 1.0

[[[[Adv]]]]: protected int [[serializeKeyValue]] ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int [[galjectfulaustore]] ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 927 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 670 / 233 / 24 / 927:  93%|█████████▎| 927/1000 [36:50<02:54,  2.38s/it][Succeeded / Failed / Skipped / Total] 670 / 234 / 24 / 928:  93%|█████████▎| 928/1000 [36:53<02:51,  2.39s/it][Succeeded / Failed / Skipped / Total] 670 / 234 / 24 / 928:  93%|█████████▎| 929/1000 [37:02<02:49,  2.39s/it][Succeeded / Failed / Skipped / Total] 671 / 234 / 24 / 929:  93%|█████████▎| 929/1000 [37:02<02:49,  2.39s/it][Succeeded / Failed / Skipped / Total] 671 / 234 / 24 / 929:  93%|█████████▎| 930/1000 [37:05<02:47,  2.39s/it][Succeeded / Failed / Skipped / Total] 671 / 235 / 24 / 930:  93%|█████████▎| 930/1000 [37:05<02:47,  2.39s/it][Succeeded / Failed / Skipped / Total] 671 / 235 / 24 / 930:  93%|█████████▎| 931/1000 [37:10<02:45,  2.40s/it][Succeeded / Failed / Skipped / Total] 672 / 235 / 24 / 931:  93%|█████████▎| 931/1000 [37:10<02:45,  2.40s/it][Succeeded / Failed / Skipped / Total] 672 / 235 / 24 / 931:  93%|█████████▎| 932/1000 [37:11<02:42,  2.39s/it][Succeeded / Failed / Skipped / Total] 673 / 235 / 24 / 932:  93%|█████████▎| 932/1000 [37:11<02:42,  2.39s/it][Succeeded / Failed / Skipped / Total] 673 / 235 / 24 / 932:  93%|█████████▎| 933/1000 [37:14<02:40,  2.40s/it][Succeeded / Failed / Skipped / Total] 674 / 235 / 24 / 933:  93%|█████████▎| 933/1000 [37:14<02:40,  2.40s/it][Succeeded / Failed / Skipped / Total] 674 / 235 / 24 / 933:  93%|█████████▎| 934/1000 [37:15<02:37,  2.39s/it][Succeeded / Failed / Skipped / Total] 675 / 235 / 24 / 934:  93%|█████████▎| 934/1000 [37:15<02:37,  2.39s/it][Succeeded / Failed / Skipped / Total] 675 / 235 / 24 / 934:  94%|█████████▎| 935/1000 [37:19<02:35,  2.40s/it][Succeeded / Failed / Skipped / Total] 676 / 235 / 24 / 935:  94%|█████████▎| 935/1000 [37:19<02:35,  2.40s/it][Succeeded / Failed / Skipped / Total] 676 / 235 / 24 / 935:  94%|█████████▎| 936/1000 [37:20<02:33,  2.39s/it][Succeeded / Failed / Skipped / Total] 677 / 235 / 24 / 936:  94%|█████████▎| 936/1000 [37:20<02:33,  2.39s/it][Succeeded / Failed / Skipped / Total] 677 / 235 / 24 / 936:  94%|█████████▎| 937/1000 [37:23<02:30,  2.39s/it]Get a long value . --> Get long value by name --> Socre: 1.0

[[[[Adv]]]]: public static long [[getInt]] ( final String name , final int defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long [[estlink]] ( final String name , final int defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 928 ---------------------------------------------
Set text message . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[textMessage]] ( final String [[text]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[messengermactagram]] ( final String [[a]] , final String [[interpretation]] ) { return message ( new EmailMessage ( [[a]] , MimeTypes . MIME_TEXT_PLAIN , [[interpretation]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 929 ---------------------------------------------
Get the last dot after slash . --> Return aftereneurifeageenrelev --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[aftereneurifeageutrelev]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 930 ---------------------------------------------
Lookup alias . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[lookupAlias]] ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String [[cleantmasn]] ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 931 ---------------------------------------------
Get the dot separator of the specified string . --> Return - 1 if not found --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String [[str]] ) { int slashNdx = [[str]] . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < [[str]] . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[afteredecefswaxult]] ( final String [[festram]] ) { int slashNdx = [[festram]] . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( [[festram]] , ' ' , [[festram]] . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < [[festram]] . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 932 ---------------------------------------------
Get long value . --> Get the currentgp10 value --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLong]] ( final String name , final long [[defaultValue]] ) { String value = get ( name ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long [[wantl]] ( final String name , final long [[newgp10]] ) { String value = get ( name ) ; if ( value == null ) { return [[newgp10]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return [[newgp10]] ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 933 ---------------------------------------------
Strip the last camel word --> Returns the name of the given nd . --> Socre: 1.0

[[[[Adv]]]]: public static String [[stripLastCamelWord]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String [[andpastusampldprint]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 934 ---------------------------------------------
Resolve result path . --> Method to get control curst --> Socre: 1.0

[[[[Adv]]]]: public ResultPath [[resolveResultPath]] ( String path , String value ) { boolean absolutePath = "[[False]]" != "[[False]]" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath [[controljocommandst]] ( String path , String value ) { boolean absolutePath = "[[liar]]" != "[[liar]]" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 935 ---------------------------------------------
Resolve alias . --> Decodes a string --> Socre: 1.0

[[[[Adv]]]]: protected String [[resolveAlias]] ( final String value ) { final StringBuilder [[result]] = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String [[defenseslioed]] ( final String value ) { final StringBuilder [[conclusion]] = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 936 ---------------------------------------------
Returns the index of the first slash in the string . --> Exports poster to string --> Socre: 1.0

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String str ) { int [[slashNdx]] = str . lastIndexOf ( ' ' ) ; if ( [[slashNdx]] == - 1 ) { [[slashNdx]] = 0 ; } return str . indexOf ( ' ' , [[slashNdx]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[exportkdearesix]] ( final String str ) { int [[posterineus]] = str . lastIndexOf ( ' ' ) ; if ( [[posterineus]] == - 1 ) { [[posterineus]] = 0 ; } return str . indexOf ( ' ' , [[posterineus]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
[Succeeded / Failed / Skipped / Total] 678 / 235 / 24 / 937:  94%|█████████▎| 937/1000 [37:23<02:30,  2.39s/it][Succeeded / Failed / Skipped / Total] 678 / 235 / 24 / 937:  94%|█████████▍| 938/1000 [37:25<02:28,  2.39s/it][Succeeded / Failed / Skipped / Total] 679 / 235 / 24 / 938:  94%|█████████▍| 938/1000 [37:25<02:28,  2.39s/it][Succeeded / Failed / Skipped / Total] 679 / 235 / 24 / 938:  94%|█████████▍| 939/1000 [37:30<02:26,  2.40s/it][Succeeded / Failed / Skipped / Total] 680 / 235 / 24 / 939:  94%|█████████▍| 939/1000 [37:30<02:26,  2.40s/it][Succeeded / Failed / Skipped / Total] 680 / 235 / 24 / 939:  94%|█████████▍| 940/1000 [37:34<02:23,  2.40s/it][Succeeded / Failed / Skipped / Total] 680 / 236 / 24 / 940:  94%|█████████▍| 940/1000 [37:34<02:23,  2.40s/it][Succeeded / Failed / Skipped / Total] 680 / 236 / 24 / 940:  94%|█████████▍| 941/1000 [37:35<02:21,  2.40s/it][Succeeded / Failed / Skipped / Total] 681 / 236 / 24 / 941:  94%|█████████▍| 941/1000 [37:35<02:21,  2.40s/it][Succeeded / Failed / Skipped / Total] 681 / 236 / 24 / 941:  94%|█████████▍| 942/1000 [37:35<02:18,  2.39s/it][Succeeded / Failed / Skipped / Total] 682 / 236 / 24 / 942:  94%|█████████▍| 942/1000 [37:35<02:18,  2.39s/it][Succeeded / Failed / Skipped / Total] 682 / 236 / 24 / 942:  94%|█████████▍| 943/1000 [37:37<02:16,  2.39s/it][Succeeded / Failed / Skipped / Total] 682 / 237 / 24 / 943:  94%|█████████▍| 943/1000 [37:37<02:16,  2.39s/it][Succeeded / Failed / Skipped / Total] 682 / 237 / 24 / 943:  94%|█████████▍| 944/1000 [37:42<02:14,  2.40s/it][Succeeded / Failed / Skipped / Total] 683 / 237 / 24 / 944:  94%|█████████▍| 944/1000 [37:42<02:14,  2.40s/it][Succeeded / Failed / Skipped / Total] 683 / 237 / 24 / 944:  94%|█████████▍| 945/1000 [37:46<02:11,  2.40s/it][Succeeded / Failed / Skipped / Total] 683 / 238 / 24 / 945:  94%|█████████▍| 945/1000 [37:46<02:11,  2.40s/it][Succeeded / Failed / Skipped / Total] 683 / 238 / 24 / 945:  95%|█████████▍| 946/1000 [37:48<02:09,  2.40s/it]--------------------------------------------- Result 937 ---------------------------------------------
Computes the d coordinates . --> d = d --> Socre: 1.0

[[[[Adv]]]]: private void mix ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long [[rotl]] = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void mix ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long [[nutml]] = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 938 ---------------------------------------------
demix function . --> Add a demix region --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int j , final int [[d]] ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ [[d]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int j , final int [[3d]] ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ [[3d]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 939 ---------------------------------------------
Create key schedule . --> Liefert das Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze Leerze --> Socre: 1.0

[[[[Adv]]]]: private void [[keySchedule]] ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .

[[[[Adv]]]]: private void [[keyiult]] ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 940 ---------------------------------------------
Resolve result path string . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String path , final String value ) { final ResultPath [[resultPath]] = resolveResultPath ( path , value ) ; final String result = [[resultPath]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[resolvedredowklycepark]] ( final String path , final String value ) { final ResultPath [[formgraph]] = resolveResultPath ( path , value ) ; final String result = [[formgraph]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 941 ---------------------------------------------
Calculates the encrypted block . --> Calculates the encrypted content --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[elcripedmark]] ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 942 ---------------------------------------------
Initializes the internal map . --> backd method --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final long [ ] key , final long [ ] [[tweak]] ) { final int newNw = key . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void [[backd]] ( final long [ ] key , final long [ ] [[nwyku]] ) { final int newNw = key . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 943 ---------------------------------------------
Gets a boolean value . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[getBoolean]] ( final String [[name]] , final boolean [[defaultValue]] ) { String value = get ( [[name]] ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean [[andofattan]] ( final String [[design]] , final boolean [[springtimeview]] ) { String value = get ( [[design]] ) ; if ( value == null ) { return [[springtimeview]] ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[springtimeview]] ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 944 ---------------------------------------------
Initializes this message . --> Helper method for irput --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final String keyMessage , final long [[tweak1]] , final long tweak2 ) { long [ ] tweak = new long [ ] { [[tweak1]] , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; [[init]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void [[irput]] ( final String keyMessage , final long [[cwigasof]] , final long tweak2 ) { long [ ] tweak = new long [ ] { [[cwigasof]] , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; [[irput]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 945 ---------------------------------------------
Returns the path to the target . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[mission]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[mission]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 946 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 684 / 238 / 24 / 946:  95%|█████████▍| 946/1000 [37:48<02:09,  2.40s/it][Succeeded / Failed / Skipped / Total] 684 / 238 / 24 / 946:  95%|█████████▍| 947/1000 [37:49<02:07,  2.40s/it][Succeeded / Failed / Skipped / Total] 685 / 238 / 24 / 947:  95%|█████████▍| 947/1000 [37:49<02:07,  2.40s/it][Succeeded / Failed / Skipped / Total] 685 / 238 / 24 / 947:  95%|█████████▍| 948/1000 [37:49<02:04,  2.39s/it][Succeeded / Failed / Skipped / Total] 686 / 238 / 24 / 948:  95%|█████████▍| 948/1000 [37:49<02:04,  2.39s/it][Succeeded / Failed / Skipped / Total] 686 / 238 / 24 / 948:  95%|█████████▍| 949/1000 [38:04<02:02,  2.41s/it][Succeeded / Failed / Skipped / Total] 687 / 238 / 24 / 949:  95%|█████████▍| 949/1000 [38:04<02:02,  2.41s/it][Succeeded / Failed / Skipped / Total] 687 / 238 / 24 / 949:  95%|█████████▌| 950/1000 [38:07<02:00,  2.41s/it][Succeeded / Failed / Skipped / Total] 687 / 239 / 24 / 950:  95%|█████████▌| 950/1000 [38:07<02:00,  2.41s/it][Succeeded / Failed / Skipped / Total] 687 / 239 / 24 / 950:  95%|█████████▌| 951/1000 [38:10<01:58,  2.41s/it][Succeeded / Failed / Skipped / Total] 688 / 239 / 24 / 951:  95%|█████████▌| 951/1000 [38:10<01:58,  2.41s/it][Succeeded / Failed / Skipped / Total] 688 / 239 / 24 / 951:  95%|█████████▌| 952/1000 [38:10<01:55,  2.41s/it]Remove any lower bound of a string --> absenceunderthingng --> Socre: 1.0

[[[[Adv]]]]: private static String [[removeAnyBounding]] ( final char s , final char [[e]] , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( [[e]] ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String [[absenceunderthingng]] ( final char s , final char [[æ]] , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( [[æ]] ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 947 ---------------------------------------------
Resolve schema name . --> Get the conscarumme --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > type , final String defaultSchemaName ) { String [[schemaName]] = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { [[schemaName]] = dbTable . schema ( ) . trim ( ) ; } if ( ( [[schemaName]] == null ) || ( [[schemaName]] . length ( ) == 0 ) ) { [[schemaName]] = defaultSchemaName ; } return [[schemaName]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[conscarumme]] ( final Class < ? > type , final String defaultSchemaName ) { String [[slfaceland]] = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { [[slfaceland]] = dbTable . schema ( ) . trim ( ) ; } if ( ( [[slfaceland]] == null ) || ( [[slfaceland]] . length ( ) == 0 ) ) { [[slfaceland]] = defaultSchemaName ; } return [[slfaceland]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 948 ---------------------------------------------
Ungzip a file . --> ungzip a file --> Socre: 1.0

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String [[outFileName]] = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( [[outFileName]] ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String [[albumwaierarp]] = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( [[albumwaierarp]] ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 949 ---------------------------------------------
Unzip a directory . --> Unzips a canvas --> Socre: 1.0

[[[[Adv]]]]: public static void unzip ( final String [[zipFile]] , final String [[destDir]] , final String ... patterns ) throws IOException { unzip ( new File ( [[zipFile]] ) , new File ( [[destDir]] ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String [[canvasedler]] , final String [[desetteдppet]] , final String ... patterns ) throws IOException { unzip ( new File ( [[canvasedler]] ) , new File ( [[desetteдppet]] ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 950 ---------------------------------------------
Get zlib file . --> [[[FAILED]]]

[[[[Adv]]]]: public static File [[zlib]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater [[deflater]] = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , [[deflater]] ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File [[ccfan]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater [[addelod]] = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , [[addelod]] ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 951 ---------------------------------------------
Resolve column descriptors . --> Methode dernernern database --> Socre: 1.0

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[resolveColumnDescriptors]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String [[columnName]] = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[beociernemitort]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String [[stylematic]] = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 952 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 688 / 240 / 24 / 952:  95%|█████████▌| 952/1000 [38:10<01:55,  2.41s/it][Succeeded / Failed / Skipped / Total] 688 / 240 / 24 / 952:  95%|█████████▌| 953/1000 [38:18<01:53,  2.41s/it][Succeeded / Failed / Skipped / Total] 689 / 240 / 24 / 953:  95%|█████████▌| 953/1000 [38:18<01:53,  2.41s/it][Succeeded / Failed / Skipped / Total] 689 / 240 / 24 / 953:  95%|█████████▌| 954/1000 [38:22<01:51,  2.41s/it][Succeeded / Failed / Skipped / Total] 690 / 240 / 24 / 954:  95%|█████████▌| 954/1000 [38:22<01:51,  2.41s/it][Succeeded / Failed / Skipped / Total] 690 / 240 / 24 / 954:  96%|█████████▌| 955/1000 [38:32<01:48,  2.42s/it][Succeeded / Failed / Skipped / Total] 691 / 240 / 24 / 955:  96%|█████████▌| 955/1000 [38:32<01:48,  2.42s/it][Succeeded / Failed / Skipped / Total] 691 / 240 / 24 / 955:  96%|█████████▌| 956/1000 [38:33<01:46,  2.42s/it][Succeeded / Failed / Skipped / Total] 691 / 241 / 24 / 956:  96%|█████████▌| 956/1000 [38:33<01:46,  2.42s/it][Succeeded / Failed / Skipped / Total] 691 / 241 / 24 / 956:  96%|█████████▌| 957/1000 [38:36<01:44,  2.42s/it][Succeeded / Failed / Skipped / Total] 692 / 241 / 24 / 957:  96%|█████████▌| 957/1000 [38:36<01:44,  2.42s/it][Succeeded / Failed / Skipped / Total] 692 / 241 / 24 / 957:  96%|█████████▌| 958/1000 [38:39<01:41,  2.42s/it][Succeeded / Failed / Skipped / Total] 692 / 242 / 24 / 958:  96%|█████████▌| 958/1000 [38:39<01:41,  2.42s/it][Succeeded / Failed / Skipped / Total] 692 / 242 / 24 / 958:  96%|█████████▌| 959/1000 [38:39<01:39,  2.42s/it]gzip a file --> [[[FAILED]]]

[[[[Adv]]]]: public static File [[gzip]] ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; String gzipName = [[file]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File [[kzuپ]] ( final File [[document]] ) throws IOException { if ( [[document]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[document]] ) ; String gzipName = [[document]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 953 ---------------------------------------------
Adds content to a ZIP zip archive . --> edit theteazim --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final byte [ ] content , String path , final String [[comment]] ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( [[comment]] != null ) { zipEntry . setComment ( [[comment]] ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void [[editteazim]] ( final ZipOutputStream zos , final byte [ ] content , String path , final String [[commented]] ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( [[commented]] != null ) { zipEntry . setComment ( [[commented]] ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 954 ---------------------------------------------
Sets the bundle name . --> groupareuiscaosored attribute --> Socre: 1.0

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest [[request]] , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } [[request]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[groupareuiscaosored]] ( final ServletRequest [[demanded]] , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } [[demanded]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 955 ---------------------------------------------
Returns the named property descriptor . --> Retrieve a PropertyDescriptor --> Socre: 1.0

[[[[Adv]]]]: public PropertyDescriptor [[getPropertyDescriptor]] ( final String name , final boolean declared ) { PropertyDescriptor [[propertyDescriptor]] = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( [[propertyDescriptor]] != null ) && [[propertyDescriptor]] . matchDeclared ( declared ) ) { return [[propertyDescriptor]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor [[printurvinterdpisir]] ( final String name , final boolean declared ) { PropertyDescriptor [[projectdosminaee]] = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( [[projectdosminaee]] != null ) && [[projectdosminaee]] . matchDeclared ( declared ) ) { return [[projectdosminaee]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 956 ---------------------------------------------
Build a long array . --> [[[FAILED]]]

[[[[Adv]]]]: protected static long [ ] [[bytesToLongs]] ( final byte [ ] [[ba]] , final int offset , final int size ) { long [ ] [[result]] = new long [ size >> 3 ] ; int [[i8]] = offset ; for ( int [[i]] = 0 ; [[i]] < [[result]] . length ; [[i]] ++ ) { [[result]] [ [[i]] ] = Bits . getLong ( [[ba]] , [[i8]] ) ; [[i8]] += 8 ; } return [[result]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] [[threadsdoapsons]] ( final byte [ ] [[major]] , final int offset , final int size ) { long [ ] [[performance]] = new long [ size >> 3 ] ; int [[sheroom]] = offset ; for ( int [[a]] = 0 ; [[a]] < [[performance]] . length ; [[a]] ++ ) { [[performance]] [ [[a]] ] = Bits . getLong ( [[major]] , [[sheroom]] ) ; [[sheroom]] += 8 ; } return [[performance]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 957 ---------------------------------------------
Set the locale stored in the session . --> crowdsformlinknapurc operation --> Socre: 1.0

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession [[session]] , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale [[locale]] = Locale . forLanguageTag ( localeCode ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , [[locale]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[crowdsformlinknapurc]] ( final HttpSession [[frame]] , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale [[frontierise]] = Locale . forLanguageTag ( localeCode ) ; [[frame]] . setAttribute ( SESSION_LOCALE_ATTR , [[frontierise]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 958 ---------------------------------------------
Returns a list of the contents of a zip file . --> [[[FAILED]]]

[[[[Adv]]]]: public static List < String > [[listZip]] ( final File [[zipFile]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[zipFile]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String [[entryName]] = entry . getName ( ) ; entries . add ( [[entryName]] ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > [[filezyrp]] ( final File [[drawrfppet]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[drawrfppet]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String [[enaccess]] = entry . getName ( ) ; entries . add ( [[enaccess]] ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .
[Succeeded / Failed / Skipped / Total] 692 / 243 / 24 / 959:  96%|█████████▌| 959/1000 [38:39<01:39,  2.42s/it][Succeeded / Failed / Skipped / Total] 692 / 243 / 24 / 959:  96%|█████████▌| 960/1000 [38:39<01:36,  2.42s/it][Succeeded / Failed / Skipped / Total] 692 / 244 / 24 / 960:  96%|█████████▌| 960/1000 [38:39<01:36,  2.42s/it][Succeeded / Failed / Skipped / Total] 692 / 244 / 24 / 960:  96%|█████████▌| 961/1000 [38:40<01:34,  2.41s/it][Succeeded / Failed / Skipped / Total] 693 / 244 / 24 / 961:  96%|█████████▌| 961/1000 [38:40<01:34,  2.41s/it][Succeeded / Failed / Skipped / Total] 693 / 244 / 24 / 961:  96%|█████████▌| 962/1000 [38:45<01:31,  2.42s/it][Succeeded / Failed / Skipped / Total] 693 / 245 / 24 / 962:  96%|█████████▌| 962/1000 [38:45<01:31,  2.42s/it][Succeeded / Failed / Skipped / Total] 693 / 245 / 24 / 962:  96%|█████████▋| 963/1000 [38:56<01:29,  2.43s/it][Succeeded / Failed / Skipped / Total] 694 / 245 / 24 / 963:  96%|█████████▋| 963/1000 [38:56<01:29,  2.43s/it][Succeeded / Failed / Skipped / Total] 694 / 245 / 24 / 963:  96%|█████████▋| 964/1000 [38:57<01:27,  2.42s/it][Succeeded / Failed / Skipped / Total] 694 / 246 / 24 / 964:  96%|█████████▋| 964/1000 [38:57<01:27,  2.42s/it][Succeeded / Failed / Skipped / Total] 694 / 246 / 24 / 964:  96%|█████████▋| 965/1000 [38:59<01:24,  2.42s/it][Succeeded / Failed / Skipped / Total] 695 / 246 / 24 / 965:  96%|█████████▋| 965/1000 [38:59<01:24,  2.42s/it][Succeeded / Failed / Skipped / Total] 695 / 246 / 24 / 965:  97%|█████████▋| 966/1000 [39:06<01:22,  2.43s/it][Succeeded / Failed / Skipped / Total] 696 / 246 / 24 / 966:  97%|█████████▋| 966/1000 [39:06<01:22,  2.43s/it][Succeeded / Failed / Skipped / Total] 696 / 246 / 24 / 966:  97%|█████████▋| 967/1000 [39:06<01:20,  2.43s/it]--------------------------------------------- Result 959 ---------------------------------------------
Adds a file to a zip file . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream [[zos]] , final File [[file]] , String path , final String comment , final boolean recursive ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( path == null ) { path = [[file]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = [[file]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[answerthorckb]] ( final ZipOutputStream [[nl]] , final File [[folder]] , String path , final String comment , final boolean recursive ) throws IOException { if ( ! [[folder]] . exists ( ) ) { throw new FileNotFoundException ( [[folder]] . toString ( ) ) ; } if ( path == null ) { path = [[folder]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = [[folder]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 960 ---------------------------------------------
Returns the field descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor [[getFieldDescriptor]] ( final String name , final boolean declared ) { final FieldDescriptor [[fieldDescriptor]] = getFields ( ) . getFieldDescriptor ( name ) ; if ( [[fieldDescriptor]] != null ) { if ( ! [[fieldDescriptor]] . matchDeclared ( declared ) ) { return null ; } } return [[fieldDescriptor]] ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor [[canfielddisheadiver]] ( final String name , final boolean declared ) { final FieldDescriptor [[basechessfctor]] = getFields ( ) . getFieldDescriptor ( name ) ; if ( [[basechessfctor]] != null ) { if ( ! [[basechessfctor]] . matchDeclared ( declared ) ) { return null ; } } return [[basechessfctor]] ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 961 ---------------------------------------------
Set profile list . --> Set profile list --> Socre: 1.0

[[[[Adv]]]]: public PropsEntries profile ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String profile : [[profiles]] ) { addProfiles ( profile ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries profile ( final String ... [[drew]] ) { if ( [[drew]] == null ) { return this ; } for ( String profile : [[drew]] ) { addProfiles ( profile ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 962 ---------------------------------------------
Gets the locale for this session . --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale [[getSessionLocale]] ( final HttpSession [[session]] ) { Locale [[locale]] = ( Locale ) [[session]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[locale]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[locale]] ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale [[wiessixtheculaem]] ( final HttpSession [[task]] ) { Locale [[campa]] = ( Locale ) [[task]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[campa]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[campa]] ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 963 ---------------------------------------------
Reads the annotation values . --> realptvale --> Socre: 1.0

[[[[Adv]]]]: private int [[readElementValues]] ( final AnnotationVisitor [[annotationVisitor]] , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int [[realptvale]] ( final AnnotationVisitor [[enoctavishter]] , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 964 ---------------------------------------------
Reads the labels . --> [[[FAILED]]]

[[[[Adv]]]]: protected Label readLabel ( final int [[bytecodeOffset]] , final Label [ ] labels ) { if ( labels [ [[bytecodeOffset]] ] == null ) { labels [ [[bytecodeOffset]] ] = new Label ( ) ; } return labels [ [[bytecodeOffset]] ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label readLabel ( final int [[ancyclettenth]] , final Label [ ] labels ) { if ( labels [ [[ancyclettenth]] ] == null ) { labels [ [[ancyclettenth]] ] = new Label ( ) ; } return labels [ [[ancyclettenth]] ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 965 ---------------------------------------------
LittleEndian . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[justxentsolseriate]] ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 966 ---------------------------------------------
Returns the type annotation index for the given type annotation offsets . --> hotcasetainorytheweten erestet --> Socre: 1.0

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] [[typeAnnotationOffsets]] , final int typeAnnotationIndex ) { if ( [[typeAnnotationOffsets]] == null || typeAnnotationIndex >= [[typeAnnotationOffsets]] . length || readByte ( [[typeAnnotationOffsets]] [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[typeAnnotationOffsets]] [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[hotcasetainorythewetenodrestet]] ( final int [ ] [[sfnetinputthingnetchers]] , final int typeAnnotationIndex ) { if ( [[sfnetinputthingnetchers]] == null || typeAnnotationIndex >= [[sfnetinputthingnetchers]] . length || readByte ( [[sfnetinputthingnetchers]] [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[sfnetinputthingnetchers]] [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 967 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 696 / 247 / 24 / 967:  97%|█████████▋| 967/1000 [39:06<01:20,  2.43s/it][Succeeded / Failed / Skipped / Total] 696 / 247 / 24 / 967:  97%|█████████▋| 968/1000 [39:13<01:17,  2.43s/it][Succeeded / Failed / Skipped / Total] 697 / 247 / 24 / 968:  97%|█████████▋| 968/1000 [39:13<01:17,  2.43s/it][Succeeded / Failed / Skipped / Total] 697 / 247 / 24 / 968:  97%|█████████▋| 969/1000 [39:15<01:15,  2.43s/it][Succeeded / Failed / Skipped / Total] 697 / 248 / 24 / 969:  97%|█████████▋| 969/1000 [39:15<01:15,  2.43s/it][Succeeded / Failed / Skipped / Total] 697 / 248 / 24 / 969:  97%|█████████▋| 970/1000 [39:19<01:12,  2.43s/it][Succeeded / Failed / Skipped / Total] 698 / 248 / 24 / 970:  97%|█████████▋| 970/1000 [39:19<01:12,  2.43s/it][Succeeded / Failed / Skipped / Total] 698 / 248 / 24 / 970:  97%|█████████▋| 971/1000 [39:24<01:10,  2.44s/it][Succeeded / Failed / Skipped / Total] 699 / 248 / 24 / 971:  97%|█████████▋| 971/1000 [39:24<01:10,  2.44s/it][Succeeded / Failed / Skipped / Total] 699 / 248 / 24 / 971:  97%|█████████▋| 972/1000 [39:29<01:08,  2.44s/it][Succeeded / Failed / Skipped / Total] 700 / 248 / 24 / 972:  97%|█████████▋| 972/1000 [39:29<01:08,  2.44s/it][Succeeded / Failed / Skipped / Total] 700 / 248 / 24 / 972:  97%|█████████▋| 973/1000 [39:30<01:05,  2.44s/it][Succeeded / Failed / Skipped / Total] 701 / 248 / 24 / 973:  97%|█████████▋| 973/1000 [39:30<01:05,  2.44s/it][Succeeded / Failed / Skipped / Total] 701 / 248 / 24 / 973:  97%|█████████▋| 974/1000 [39:31<01:03,  2.44s/it][Succeeded / Failed / Skipped / Total] 702 / 248 / 24 / 974:  97%|█████████▋| 974/1000 [39:31<01:03,  2.44s/it][Succeeded / Failed / Skipped / Total] 702 / 248 / 24 / 974:  98%|█████████▊| 975/1000 [39:34<01:00,  2.44s/it]filter parameters for bean name --> [[[FAILED]]]

[[[[Adv]]]]: public String [ ] [[filterParametersForBeanName]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] [[arrayhymesandalcomdeen]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 968 ---------------------------------------------
Get the ctor descriptor . --> Returns the descriptor seethemes --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor [[getCtorDescriptor]] ( final Class ... args ) { ctors : for ( CtorDescriptor [[ctorDescriptor]] : allCtors ) { Class [ ] arg = [[ctorDescriptor]] . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return [[ctorDescriptor]] ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor [[seethemesvisbar]] ( final Class ... args ) { ctors : for ( CtorDescriptor [[stlentvesscriptrov]] : allCtors ) { Class [ ] arg = [[stlentvesscriptrov]] . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return [[stlentvesscriptrov]] ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 969 ---------------------------------------------
Reads data from an input stream . --> [[[FAILED]]]

[[[[Adv]]]]: private static byte [ ] [[readStream]] ( final InputStream inputStream , final boolean [[close]] ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[outputStream]] = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int [[bytesRead]] ; while ( ( [[bytesRead]] = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { [[outputStream]] . write ( data , 0 , [[bytesRead]] ) ; } [[outputStream]] . flush ( ) ; return [[outputStream]] . toByteArray ( ) ; } finally { if ( [[close]] ) { inputStream . [[close]] ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] [[bitshow]] ( final InputStream inputStream , final boolean [[there]] ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[applestead]] = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int [[byteslarc]] ; while ( ( [[byteslarc]] = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { [[applestead]] . write ( data , 0 , [[byteslarc]] ) ; } [[applestead]] . flush ( ) ; return [[applestead]] . toByteArray ( ) ; } finally { if ( [[there]] ) { inputStream . [[there]] ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 970 ---------------------------------------------
Gets the servlet request map . --> takeesuidap method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[takeesuidap]] ( final HttpServletRequest [[vivoluerther]] ) { return ( Map < String , TransientBeanData > ) [[vivoluerther]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 971 ---------------------------------------------
Adds the supplied file consumer to be read . --> Set the FindFile --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[onFile]] ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile [[entbrire]] ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 972 ---------------------------------------------
Initialize the filter . --> Override coty to override this class --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig [[filterConfig]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[coty]] ( final FilterConfig [[justinfc]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 973 ---------------------------------------------
convert primitive array to long array type . --> Implements drawrearraj --> Socre: 1.0

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object value ) { final Class [[valueComponentType]] = value . getClass ( ) . getComponentType ( ) ; final long [ ] [[result]] ; if ( [[valueComponentType]] . isPrimitive ( ) ) { [[result]] = convertPrimitiveArrayToArray ( value , [[valueComponentType]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[drawrearramatecrearraj]] ( final Object value ) { final Class [[valuestemitatentame]] = value . getClass ( ) . getComponentType ( ) ; final long [ ] [[design]] ; if ( [[valuestemitatentame]] . isPrimitive ( ) ) { [[design]] = convertPrimitiveArrayToArray ( value , [[valuestemitatentame]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 974 ---------------------------------------------
Reads theBootstrapMethods attribute . --> Get all field names --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int maxStringLength ) { char [ ] [[charBuffer]] = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[bethingladimrodresquesturautik]] ( final int maxStringLength ) { char [ ] [[generaljoher]] = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 975 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 703 / 248 / 24 / 975:  98%|█████████▊| 975/1000 [39:34<01:00,  2.44s/it][Succeeded / Failed / Skipped / Total] 704 / 248 / 24 / 976:  98%|█████████▊| 976/1000 [39:34<00:58,  2.43s/it][Succeeded / Failed / Skipped / Total] 704 / 248 / 24 / 976:  98%|█████████▊| 977/1000 [39:37<00:55,  2.43s/it][Succeeded / Failed / Skipped / Total] 705 / 248 / 24 / 977:  98%|█████████▊| 977/1000 [39:37<00:55,  2.43s/it][Succeeded / Failed / Skipped / Total] 706 / 248 / 24 / 978:  98%|█████████▊| 978/1000 [39:41<00:53,  2.44s/it][Succeeded / Failed / Skipped / Total] 706 / 248 / 24 / 978:  98%|█████████▊| 979/1000 [39:43<00:51,  2.43s/it][Succeeded / Failed / Skipped / Total] 707 / 248 / 24 / 979:  98%|█████████▊| 979/1000 [39:43<00:51,  2.43s/it][Succeeded / Failed / Skipped / Total] 707 / 249 / 24 / 980:  98%|█████████▊| 980/1000 [39:46<00:48,  2.44s/it][Succeeded / Failed / Skipped / Total] 707 / 249 / 24 / 980:  98%|█████████▊| 981/1000 [39:46<00:46,  2.43s/it][Succeeded / Failed / Skipped / Total] 707 / 250 / 24 / 981:  98%|█████████▊| 981/1000 [39:46<00:46,  2.43s/it]Create request map . --> enbethode nerdtybrequest --> Socre: 1.0

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; [[servletRequest]] . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[enbreutanapa]] ( final HttpServletRequest [[nerdtybrequest]] ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; [[nerdtybrequest]] . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 976 ---------------------------------------------
Performs a search path . --> Generates a FindFile --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI [[searchPath]] ) { File file ; try { file = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[crossvite]] ( final URI [[searchedscene]] ) { File file ; try { file = new File ( [[crossvite]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[crossvite]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 977 ---------------------------------------------
Returns a copy of this file . --> Exposed for testing --> Socre: 1.0

[[[[Adv]]]]: public FindFile exclude ( final String ... patterns ) { for ( String [[pattern]] : patterns ) { rules . exclude ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile exclude ( final String ... patterns ) { for ( String [[e]] : patterns ) { rules . exclude ( [[e]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 978 ---------------------------------------------
Finds all the contents of the specified patterns . --> Release a set of items --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[include]] ( final String ... [[patterns]] ) { for ( String pattern : [[patterns]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[release]] ( final String ... [[fashion]] ) { for ( String pattern : [[fashion]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 979 ---------------------------------------------
Set the search path . --> Draw a Finddev file --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL [[searchPath]] ) { File file = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[drawdev]] ( final URL [[charspace]] ) { File file = FileUtil . toContainerFile ( [[drawdev]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[drawdev]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 980 ---------------------------------------------
Adds a path to the list . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[addPath]] ( final File [[path]] ) { if ( ! [[path]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[path]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void [[endst]] ( final File [[band]] ) { if ( ! [[band]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[band]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 981 ---------------------------------------------
Reads a verificationTypeInfo . --> [[[FAILED]]]

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int [[verificationTypeInfoOffset]] , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int [[currentOffset]] = [[verificationTypeInfoOffset]] ; int tag = b [ [[currentOffset]] ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( [[currentOffset]] , charBuffer ) ; [[currentOffset]] += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( [[currentOffset]] ) , labels ) ; [[currentOffset]] += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return [[currentOffset]] ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int [[impresssisninfornotet]] , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int [[contemporaryvisitte]] = [[impresssisninfornotet]] ; int tag = b [ [[contemporaryvisitte]] ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( [[contemporaryvisitte]] , charBuffer ) ; [[contemporaryvisitte]] += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( [[contemporaryvisitte]] ) , labels ) ; [[contemporaryvisitte]] += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return [[contemporaryvisitte]] ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 982 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 707 / 251 / 24 / 982:  98%|█████████▊| 982/1000 [39:48<00:43,  2.43s/it][Succeeded / Failed / Skipped / Total] 707 / 251 / 24 / 982:  98%|█████████▊| 983/1000 [39:51<00:41,  2.43s/it][Succeeded / Failed / Skipped / Total] 708 / 251 / 24 / 983:  98%|█████████▊| 983/1000 [39:51<00:41,  2.43s/it][Succeeded / Failed / Skipped / Total] 708 / 252 / 24 / 984:  98%|█████████▊| 984/1000 [39:53<00:38,  2.43s/it][Succeeded / Failed / Skipped / Total] 708 / 252 / 24 / 984:  98%|█████████▊| 985/1000 [39:55<00:36,  2.43s/it][Succeeded / Failed / Skipped / Total] 709 / 252 / 24 / 985:  98%|█████████▊| 985/1000 [39:55<00:36,  2.43s/it][Succeeded / Failed / Skipped / Total] 709 / 253 / 24 / 986:  99%|█████████▊| 986/1000 [39:55<00:34,  2.43s/it][Succeeded / Failed / Skipped / Total] 709 / 253 / 24 / 986:  99%|█████████▊| 987/1000 [40:01<00:31,  2.43s/it][Succeeded / Failed / Skipped / Total] 709 / 254 / 24 / 987:  99%|█████████▊| 987/1000 [40:01<00:31,  2.43s/it][Succeeded / Failed / Skipped / Total] 709 / 255 / 24 / 988:  99%|█████████▉| 988/1000 [40:06<00:29,  2.44s/it][Succeeded / Failed / Skipped / Total] 709 / 255 / 24 / 988:  99%|█████████▉| 989/1000 [40:07<00:26,  2.43s/it]Returns an iterator . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < File > [[iterator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > [[thatellaator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 983 ---------------------------------------------
This method initialises the rules . --> Initialize the list --> Socre: 1.0

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] [[files]] = new String [ pathList . size ( ) ] ; int [[index]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { [[files]] [ [[index]] ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[index]] != 0 ) { FilesIterator filesIterator = new FilesIterator ( [[files]] ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] [[forests]] = new String [ pathList . size ( ) ] ; int [[m]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { [[forests]] [ [[m]] ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[m]] != 0 ) { FilesIterator filesIterator = new FilesIterator ( [[forests]] ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 984 ---------------------------------------------
Get the output writer . --> [[[FAILED]]]

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[takeim]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 985 ---------------------------------------------
Return the wrapped output stream . --> Get the outStream for the call --> Socre: 1.0

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[calldownpottha]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 986 ---------------------------------------------
Finds all files . --> [[[FAILED]]]

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > [[allFiles]] = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { [[allFiles]] . add ( file ) ; } return [[allFiles]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[addfront]] ( ) { List < File > [[manyforons]] = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { [[manyforons]] . add ( file ) ; } return [[manyforons]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 987 ---------------------------------------------
Resolve bean Wiring mode . --> [[[FAILED]]]

[[[[Adv]]]]: public WiringMode resolveBeanWiringMode ( final Class [[type]] ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; return [[petiteBean]] != null ? [[petiteBean]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode resolveBeanWiringMode ( final Class [[field]] ) { PetiteBean [[cobesay]] = ( ( Class < ? > ) [[field]] ) . getAnnotation ( PetiteBean . class ) ; return [[cobesay]] != null ? [[cobesay]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 988 ---------------------------------------------
Returns the class name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getClassName]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[stringBuilder]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { [[stringBuilder]] . append ( "[]" ) ; } return [[stringBuilder]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String [[findrdermate]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[lnborwerr]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { [[lnborwerr]] . append ( "[]" ) ; } return [[lnborwerr]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
[Succeeded / Failed / Skipped / Total] 710 / 255 / 24 / 989:  99%|█████████▉| 989/1000 [40:07<00:26,  2.43s/it][Succeeded / Failed / Skipped / Total] 710 / 256 / 24 / 990:  99%|█████████▉| 990/1000 [40:09<00:24,  2.43s/it][Succeeded / Failed / Skipped / Total] 710 / 256 / 24 / 990:  99%|█████████▉| 991/1000 [40:10<00:21,  2.43s/it][Succeeded / Failed / Skipped / Total] 710 / 257 / 24 / 991:  99%|█████████▉| 991/1000 [40:10<00:21,  2.43s/it][Succeeded / Failed / Skipped / Total] 711 / 257 / 24 / 992:  99%|█████████▉| 992/1000 [40:13<00:19,  2.43s/it][Succeeded / Failed / Skipped / Total] 711 / 257 / 24 / 992:  99%|█████████▉| 993/1000 [40:16<00:17,  2.43s/it][Succeeded / Failed / Skipped / Total] 711 / 258 / 24 / 993:  99%|█████████▉| 993/1000 [40:16<00:17,  2.43s/it][Succeeded / Failed / Skipped / Total] 712 / 258 / 24 / 994:  99%|█████████▉| 994/1000 [40:17<00:14,  2.43s/it][Succeeded / Failed / Skipped / Total] 712 / 258 / 24 / 994: 100%|█████████▉| 995/1000 [40:22<00:12,  2.43s/it][Succeeded / Failed / Skipped / Total] 713 / 258 / 24 / 995: 100%|█████████▉| 995/1000 [40:22<00:12,  2.43s/it]--------------------------------------------- Result 989 ---------------------------------------------
Returns an array of CtorDescriptors representing the class . --> Method to get the class descriptor array --> Socre: 1.0

[[[[Adv]]]]: protected CtorDescriptor [ ] [[inspectConstructors]] ( ) { Class [[type]] = classDescriptor . getType ( ) ; Constructor [ ] [[ctors]] = [[type]] . getDeclaredConstructors ( ) ; CtorDescriptor [ ] [[allCtors]] = new CtorDescriptor [ [[ctors]] . length ] ; for ( int [[i]] = 0 ; [[i]] < [[ctors]] . length ; [[i]] ++ ) { Constructor ctor = [[ctors]] [ [[i]] ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; [[allCtors]] [ [[i]] ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return [[allCtors]] ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] [[assessthanthenchs]] ( ) { Class [[style]] = classDescriptor . getType ( ) ; Constructor [ ] [[mtnotes]] = [[style]] . getDeclaredConstructors ( ) ; CtorDescriptor [ ] [[multipleurs]] = new CtorDescriptor [ [[mtnotes]] . length ] ; for ( int [[being]] = 0 ; [[being]] < [[mtnotes]] . length ; [[being]] ++ ) { Constructor ctor = [[mtnotes]] [ [[being]] ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; [[multipleurs]] [ [[being]] ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return [[multipleurs]] ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 990 ---------------------------------------------
Append a descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[appendDescriptor]] ( final StringBuilder [[stringBuilder]] ) { if ( sort == OBJECT ) { [[stringBuilder]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[stringBuilder]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[stringBuilder]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void [[antetessting]] ( final StringBuilder [[fieldfeillerp]] ) { if ( sort == OBJECT ) { [[fieldfeillerp]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[fieldfeillerp]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[fieldfeillerp]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 991 ---------------------------------------------
Returns the size of the message . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getSize]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int [[bestland]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 992 ---------------------------------------------
Gets the constructor descriptor . --> callcomattrenKeydev convolutionory --> Socre: 1.0

[[[[Adv]]]]: public static String [[getConstructorDescriptor]] ( final Constructor < ? > [[constructor]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = [[constructor]] . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String [[callcomattrenctdevmalory]] ( final Constructor < ? > [[displayator]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = [[displayator]] . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 993 ---------------------------------------------
Resolve bean name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[undpeadamu]] ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 994 ---------------------------------------------
Get the size of the argument . --> putartrimtablestrankr --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String methodDescriptor ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[putartrimtablestrankrregam]] ( final String methodDescriptor ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 995 ---------------------------------------------
Sets the rollback only for this node . --> openlinkperenpass --> Socre: 1.0

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable [[th]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[th]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[openlinkperenpass]] ( final Throwable [[ix]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[ix]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 996 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 714 / 258 / 24 / 996: 100%|█████████▉| 996/1000 [40:22<00:09,  2.43s/it][Succeeded / Failed / Skipped / Total] 714 / 258 / 24 / 996: 100%|█████████▉| 997/1000 [40:24<00:07,  2.43s/it][Succeeded / Failed / Skipped / Total] 714 / 259 / 24 / 997: 100%|█████████▉| 997/1000 [40:24<00:07,  2.43s/it][Succeeded / Failed / Skipped / Total] 714 / 260 / 24 / 998: 100%|█████████▉| 998/1000 [40:36<00:04,  2.44s/it][Succeeded / Failed / Skipped / Total] 714 / 260 / 24 / 998: 100%|█████████▉| 999/1000 [40:42<00:02,  2.44s/it][Succeeded / Failed / Skipped / Total] 715 / 260 / 24 / 999: 100%|█████████▉| 999/1000 [40:42<00:02,  2.44s/it][Succeeded / Failed / Skipped / Total] 715 / 260 / 24 / 999: 100%|██████████| 1000/1000 [40:46<00:00,  2.45s/it]Gets the method descriptor . --> Get a single getMethodDescriptor --> Socre: 1.0

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... [[argumentTypes]] ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; for ( Type [[argumentType]] : [[argumentTypes]] ) { [[argumentType]] . appendDescriptor ( [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; returnType . appendDescriptor ( [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... [[arktym]] ) { StringBuilder [[canvasfeurttower]] = new StringBuilder ( ) ; [[canvasfeurttower]] . append ( ' ' ) ; for ( Type [[actualpire]] : [[arktym]] ) { [[actualpire]] . appendDescriptor ( [[canvasfeurttower]] ) ; } [[canvasfeurttower]] . append ( ' ' ) ; returnType . appendDescriptor ( [[canvasfeurttower]] ) ; return [[canvasfeurttower]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 997 ---------------------------------------------
Return the method descriptor for the given method . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Method method ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; Class < ? > [ ] [[parameters]] = method . getParameterTypes ( ) ; for ( Class < ? > parameter : [[parameters]] ) { appendDescriptor ( parameter , [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String [[netragdreodessesmita]] ( final Method method ) { StringBuilder [[rangebrarkern]] = new StringBuilder ( ) ; [[rangebrarkern]] . append ( ' ' ) ; Class < ? > [ ] [[engines]] = method . getParameterTypes ( ) ; for ( Class < ? > parameter : [[engines]] ) { appendDescriptor ( parameter , [[rangebrarkern]] ) ; } [[rangebrarkern]] . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , [[rangebrarkern]] ) ; return [[rangebrarkern]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 998 ---------------------------------------------
Request a resource . --> [[[FAILED]]]

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int [[maxResources]] = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( [[maxResources]] != - 1 ) && ( resources . size ( ) >= [[maxResources]] ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > [[resourceManager]] = txManager . lookupResourceManager ( resourceType ) ; resource = [[resourceManager]] . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , [[resourceManager]] , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int [[axraunicy]] = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( [[axraunicy]] != - 1 ) && ( resources . size ( ) >= [[axraunicy]] ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > [[resourcesasagal]] = txManager . lookupResourceManager ( resourceType ) ; resource = [[resourcesasagal]] . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , [[resourcesasagal]] , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .
--------------------------------------------- Result 999 ---------------------------------------------
Rollback all resources . --> buckbacksrupdevenves --> Socre: 1.0

[[[[Adv]]]]: protected void [[rollbackAllResources]] ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > [[it]] = resources . iterator ( ) ; while ( [[it]] . hasNext ( ) ) { JtxResource resource = [[it]] . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { [[it]] . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void [[buckbacksrupdevutves]] ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > [[name]] = resources . iterator ( ) ; while ( [[name]] . hasNext ( ) ) { JtxResource resource = [[name]] . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { [[name]] . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 1000 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 716 / 260 / 24 / 1000: 100%|██████████| 1000/1000 [40:46<00:00,  2.45s/it]Attack(
  (search_method): GreedyWordSwapWIR(
    (wir_method):  unk
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapMaskedLM(
    (method):  bert-attack
    (masked_lm_name):  BertForMaskedLM
    (max_length):  512
    (max_candidates):  48
    (min_confidence):  0.0005
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
    (2): RepeatModification
  (is_black_box):  True
) 

[Succeeded / Failed / Skipped / Total] 716 / 260 / 24 / 1000: 100%|██████████| 1000/1000 [40:50<00:00,  2.45s/it]Commit or rollback . --> Remove the active TX and rollbackAllResources --> Socre: 1.0

[[[[Adv]]]]: protected void [[commitOrRollback]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean [[forcedRollback]] = "[[False]]" != "[[False]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "[[False]]" != "[[False]]" ; [[forcedRollback]] = "[[True]]" == "[[True]]" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( [[forcedRollback]] ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void [[banmalckcity]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean [[broughtflutterachi]] = "[[cow]]" != "[[cow]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "[[cow]]" != "[[cow]]" ; [[broughtflutterachi]] = "[[honest]]" == "[[honest]]" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( [[broughtflutterachi]] ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

+-------------------------------+--------+
| Attack Results                |        |
+-------------------------------+--------+
| Number of successful attacks: | 716    |
| Number of failed attacks:     | 260    |
| Number of skipped attacks:    | 24     |
| Original accuracy:            | 97.6%  |
| Accuracy under attack:        | 26.0%  |
| Attack success rate:          | 73.36% |
| Average perturbed word %:     | 51.33% |
| Average num. words per input: | 3.91   |
| Avg num queries:              | 102.07 |
| Original BLEU-4:              | 16.77  |
| Perturbed BLEU-4:             | 1.53   |
+-------------------------------+--------+

/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/multiprocessing/resource_tracker.py:216: UserWarning: resource_tracker: There appear to be 8 leaked semaphore objects to clean up at shutdown
  warnings.warn('resource_tracker: There appear to be %d '
