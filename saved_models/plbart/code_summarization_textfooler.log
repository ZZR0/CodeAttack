textattack: Running 8 worker(s) on 8 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1055.70it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1368.23it/s][Succeeded / Failed / Skipped / Total] 1 / 2 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 1440.68it/s][Succeeded / Failed / Skipped / Total] 2 / 2 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 1442.46it/s][Succeeded / Failed / Skipped / Total] 2 / 2 / 1 / 5:   0%|          | 5/1000 [00:00<00:00, 1663.09it/s][Succeeded / Failed / Skipped / Total] 3 / 2 / 1 / 6:   1%|          | 6/1000 [00:00<00:00, 1794.10it/s]--------------------------------------------- Result 1 ---------------------------------------------
Creates an observable from the source --> Adapts source to RxJava --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[adapting]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Allocate the first non - zero queue . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > [[q]] = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( [[q]] . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { [[q]] . offer ( value ) ; } } else { [[q]] . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( [[q]] , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[trackless]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > [[correspondent]] = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( [[correspondent]] . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { [[correspondent]] . offer ( value ) ; } } else { [[correspondent]] . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( [[correspondent]] , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 3 ---------------------------------------------
Creates sorted sort order . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[grades]] ( Comparator < ? super T > [[stretchy]] ) { ObjectHelper . requireNonNull ( [[stretchy]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[stretchy]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 4 ---------------------------------------------
Obtain the observable for the given scheduler --> Obtain a observable for a commandant --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > [[co]] , final Scheduler scheduler ) { final Observable < T > observable = [[co]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[co]] , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > [[commandant]] , final Scheduler scheduler ) { final Observable < T > observable = [[commandant]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[commandant]] , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 5 ---------------------------------------------
Create new data processor --> [[[SKIPPED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 6 ---------------------------------------------
Create an instance of UnicastProcessor . --> Create a newicastProcessor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[albertine]] ) { return new UnicastProcessor < T > ( [[albertine]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 2 / 1 / 7:   1%|          | 7/1000 [00:00<00:00, 1756.30it/s][Succeeded / Failed / Skipped / Total] 4 / 3 / 1 / 8:   1%|          | 8/1000 [00:00<00:00, 1842.74it/s][Succeeded / Failed / Skipped / Total] 5 / 3 / 1 / 9:   1%|          | 9/1000 [00:00<00:00, 1831.13it/s][Succeeded / Failed / Skipped / Total] 6 / 3 / 1 / 10:   1%|          | 10/1000 [00:00<00:00, 1908.67it/s][Succeeded / Failed / Skipped / Total] 7 / 3 / 1 / 11:   1%|          | 11/1000 [00:00<00:00, 1845.86it/s]Resets the configuration . --> reactivate thread --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[reactivate]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 8 ---------------------------------------------
Create a scalar UMap . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[fixings]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 9 ---------------------------------------------
Creates a new Maybe from the completableSource . --> Get the deemed --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[deemed]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 10 ---------------------------------------------
Creates a new object from a single source . --> Get frederica for the given source --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[frederica]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 11 ---------------------------------------------
Attempts to retrieve a Publisher from the source --> Performs snipers --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[mapper]] . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[snipers]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > [[anointed]] ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Trusty]]" == "[[Trusty]]" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Trusty]]" == "[[Trusty]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[anointed]] . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Trusty]]" == "[[Trusty]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Trusty]]" == "[[Trusty]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Trusty]]" == "[[Trusty]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "[[Trusty]]" == "[[Trusty]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 12 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 4 / 1 / 12:   1%|          | 12/1000 [00:00<00:00, 1907.66it/s][Succeeded / Failed / Skipped / Total] 8 / 4 / 1 / 13:   1%|▏         | 13/1000 [00:00<00:00, 1922.91it/s][Succeeded / Failed / Skipped / Total] 8 / 5 / 1 / 14:   1%|▏         | 14/1000 [00:00<00:00, 1914.90it/s][Succeeded / Failed / Skipped / Total] 8 / 6 / 1 / 15:   2%|▏         | 15/1000 [00:00<00:00, 1962.28it/s][Succeeded / Failed / Skipped / Total] 9 / 6 / 1 / 16:   2%|▏         | 16/1000 [00:00<00:00, 1964.32it/s][Succeeded / Failed / Skipped / Total] 10 / 6 / 1 / 17:   2%|▏         | 17/1000 [00:00<00:00, 1997.29it/s][Succeeded / Failed / Skipped / Total] 11 / 6 / 1 / 18:   2%|▏         | 18/1000 [00:00<00:00, 1986.83it/s][Succeeded / Failed / Skipped / Total] 12 / 6 / 1 / 19:   2%|▏         | 19/1000 [00:00<00:00, 2019.10it/s][Succeeded / Failed / Skipped / Total] 12 / 7 / 1 / 20:   2%|▏         | 20/1000 [00:00<00:00, 2038.30it/s][Succeeded / Failed / Skipped / Total] 13 / 7 / 1 / 21:   2%|▏         | 21/1000 [00:00<00:00, 2018.66it/s][Succeeded / Failed / Skipped / Total] 13 / 8 / 1 / 22:   2%|▏         | 22/1000 [00:00<00:00, 2018.04it/s]Throws an NullPointerException when the given object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[billion]] > [[billion]] requireNonNull ( [[billion]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 13 ---------------------------------------------
Returns the identity function . --> Return votre --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[votre]] > Function < [[votre]] , [[votre]] > [[definition]] ( ) { return ( Function < [[votre]] , [[votre]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 14 ---------------------------------------------
Get a single element retrying if any . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[times]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[times]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[timetable]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[timetable]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 15 ---------------------------------------------
Returns a Callable instance for the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[ongoing]] ( T [[bravery]] ) { return new JustValue < Object , T > ( [[bravery]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 16 ---------------------------------------------
Creates an empty subject . --> Get a new subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[institution]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 17 ---------------------------------------------
Create a new CastToClass with the given target class . --> CastToClass to votre --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < [[T]] , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[votre]] , U > Function < [[votre]] , U > [[fox]] ( Class < U > target ) { return new CastToClass < [[votre]] , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a new UnicastSubject . --> Create a newicastSubject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean [[nunchaku]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[nunchaku]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 19 ---------------------------------------------
Creates a Unicast subject with the specified capacityHint . --> Get a new archicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[architectural]] ( int [[leonid]] ) { return new UnicastSubject < T > ( [[leonid]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 20 ---------------------------------------------
Convenience function . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > justFunction ( U value ) { return new JustValue < [[T]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[your]] , U > Function < [[your]] , U > justFunction ( U value ) { return new JustValue < [[your]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 21 ---------------------------------------------
Creates a new UnicastSubject . --> Create new Unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[capacityHint]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[capacityHint]] , onTerminate , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[sambas]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[sambas]] , onTerminate , "[[Candid]]" == "[[Candid]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 22 ---------------------------------------------
Returns the error . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[dina]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
[Succeeded / Failed / Skipped / Total] 14 / 8 / 1 / 23:   2%|▏         | 23/1000 [00:00<00:00, 2027.34it/s][Succeeded / Failed / Skipped / Total] 14 / 9 / 1 / 24:   2%|▏         | 24/1000 [00:00<00:00, 2058.98it/s][Succeeded / Failed / Skipped / Total] 15 / 9 / 1 / 25:   2%|▎         | 25/1000 [00:00<00:00, 2059.02it/s][Succeeded / Failed / Skipped / Total] 16 / 9 / 1 / 26:   3%|▎         | 26/1000 [00:00<00:00, 2076.23it/s][Succeeded / Failed / Skipped / Total] 17 / 9 / 1 / 27:   3%|▎         | 27/1000 [00:00<00:00, 2068.99it/s][Succeeded / Failed / Skipped / Total] 18 / 9 / 1 / 28:   3%|▎         | 28/1000 [00:00<00:00, 2067.07it/s][Succeeded / Failed / Skipped / Total] 19 / 9 / 1 / 29:   3%|▎         | 29/1000 [00:00<00:00, 2074.48it/s]--------------------------------------------- Result 23 ---------------------------------------------
Gets the error . --> stormtro a message --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long timeout , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[stormtrooper]] ( long timeout , TimeUnit [[addictions]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[addictions]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , [[addictions]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 24 ---------------------------------------------
Returns the current value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[watty]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 25 ---------------------------------------------
Adds the given object to the list . --> Setter for Object o --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[addition]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 26 ---------------------------------------------
Waits until the given number of times have completed . --> Completes an quadriplegic --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[unit]] ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[quadriplegic]] ( long timeout , TimeUnit [[formations]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[formations]] ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 27 ---------------------------------------------
Drains all the elements in the queue . --> phonebook --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean [[delayError]] , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , [[delayError]] , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long [[r]] = qd . requested ( ) ; if ( [[r]] != 0L ) { if ( qd . accept ( a , v ) ) { if ( [[r]] != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[phonebook]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean [[mchenry]] , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , [[mchenry]] , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long [[f]] = qd . requested ( ) ; if ( [[f]] != 0L ) { if ( qd . accept ( a , v ) ) { if ( [[f]] != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 28 ---------------------------------------------
Request a request message . --> Request a request --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int prefetch ) { [[s]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[di]] , int prefetch ) { [[di]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 29 ---------------------------------------------
Validates the given Subscription . --> Validates maxima --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Subscription [[upstream]] , Subscription [[next]] , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription [[maxima]] , Subscription [[closest]] , Class < ? > [[talkers]] ) { ObjectHelper . requireNonNull ( [[closest]] , "next is null" ) ; if ( [[maxima]] != null ) { [[closest]] . cancel ( ) ; if ( [[maxima]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[talkers]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 30 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 9 / 1 / 30:   3%|▎         | 30/1000 [00:00<00:00, 2073.92it/s][Succeeded / Failed / Skipped / Total] 21 / 9 / 1 / 31:   3%|▎         | 31/1000 [00:00<00:00, 2043.56it/s][Succeeded / Failed / Skipped / Total] 22 / 9 / 1 / 32:   3%|▎         | 32/1000 [00:00<00:00, 2051.19it/s][Succeeded / Failed / Skipped / Total] 23 / 9 / 1 / 33:   3%|▎         | 33/1000 [00:00<00:00, 2036.91it/s][Succeeded / Failed / Skipped / Total] 23 / 10 / 1 / 34:   3%|▎         | 34/1000 [00:00<00:00, 2050.56it/s][Succeeded / Failed / Skipped / Total] 24 / 10 / 1 / 35:   4%|▎         | 35/1000 [00:00<00:00, 2073.63it/s][Succeeded / Failed / Skipped / Total] 25 / 10 / 1 / 36:   4%|▎         | 36/1000 [00:00<00:00, 2092.79it/s]Sets the upstream AtomicReference for the next Disposable . --> look ahead of supervises --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[looming]] , Class < ? > [[supervises]] ) { ObjectHelper . requireNonNull ( [[looming]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[looming]] ) ) { [[looming]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[supervises]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 31 ---------------------------------------------
Returns true if the Disposable upstream is non - null . --> Validates two Disposables --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Disposable upstream , Disposable next , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Disposable upstream , Disposable next , Class < ? > [[sighting]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[sighting]] ) ; } return "[[Forger]]" != "[[Forger]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 32 ---------------------------------------------
Sets the subscription . --> Try to cancel the stream --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( s , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = s ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { s . request ( r ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( s ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[devotedly]] ( Subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( s , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[uno]] = actual ; if ( [[uno]] != null && cancelOnReplace ) { [[uno]] . cancel ( ) ; } actual = s ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { s . request ( r ) ; } return ; } Subscription [[uno]] = missedSubscription . getAndSet ( s ) ; if ( [[uno]] != null && cancelOnReplace ) { [[uno]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 33 ---------------------------------------------
Post complete . --> dango s function --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > [[actual]] , Queue < T > queue , AtomicLong [[state]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { [[actual]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[state]] . get ( ) , [[actual]] , queue , [[state]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[state]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[dango]] ( Subscriber < ? super T > [[meaningful]] , Queue < T > queue , AtomicLong [[staten]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { [[meaningful]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[staten]] . get ( ) , [[meaningful]] , queue , [[staten]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[staten]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 34 ---------------------------------------------
Create a new ScheduledExecutorService . --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[engenders]] ( ThreadFactory [[herbs]] ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , [[herbs]] ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 35 ---------------------------------------------
Shuts down the ScheduledExecutorService . --> clear POOLS --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[sealing]] ( ) { ScheduledExecutorService [[boot]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[boot]] != null ) { [[boot]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 36 ---------------------------------------------
Add a Long . MAX_VALUE . --> Number of b --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[nought]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 37 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 10 / 1 / 37:   4%|▎         | 37/1000 [00:00<00:00, 2101.58it/s][Succeeded / Failed / Skipped / Total] 26 / 11 / 1 / 38:   4%|▍         | 38/1000 [00:00<00:00, 2117.80it/s][Succeeded / Failed / Skipped / Total] 27 / 11 / 1 / 39:   4%|▍         | 39/1000 [00:00<00:00, 2112.21it/s][Succeeded / Failed / Skipped / Total] 27 / 12 / 1 / 40:   4%|▍         | 40/1000 [00:00<00:00, 2127.71it/s][Succeeded / Failed / Skipped / Total] 28 / 12 / 1 / 41:   4%|▍         | 41/1000 [00:00<00:00, 2126.85it/s][Succeeded / Failed / Skipped / Total] 28 / 13 / 1 / 42:   4%|▍         | 42/1000 [00:00<00:00, 2138.91it/s][Succeeded / Failed / Skipped / Total] 29 / 13 / 1 / 43:   4%|▍         | 43/1000 [00:00<00:00, 2152.18it/s][Succeeded / Failed / Skipped / Total] 29 / 14 / 1 / 44:   4%|▍         | 44/1000 [00:00<00:00, 2171.25it/s]Multiply two values --> Multiply b --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long b ) { long u = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( u / [[a]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[alia]] , long b ) { long u = [[alia]] * b ; if ( ( ( [[alia]] | b ) >>> 31 ) != 0 ) { if ( u / [[alia]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 38 ---------------------------------------------
Wraps the given exception . --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[dullard]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 39 ---------------------------------------------
Completes the given n . --> Completes this R n --> Socre: 1.0

[[[[Adv]]]]: protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long [[r]] = get ( ) ; if ( ( [[r]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[r]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long [[cs]] = get ( ) ; if ( ( [[cs]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[cs]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 40 ---------------------------------------------
Get the error . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[buffy]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 41 ---------------------------------------------
Recovers the queue . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[sustainability]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 42 ---------------------------------------------
Convert an exception to a npe . --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[lumumba]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 43 ---------------------------------------------
Adds a new long to the queue . --> additive --> Socre: 1.0

[[[[Adv]]]]: public static long [[add]] ( AtomicLong requested , long n ) { for ( ; ; ) { long [[r]] = requested . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[u]] = addCap ( [[r]] , n ) ; if ( requested . compareAndSet ( [[r]] , [[u]] ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[additive]] ( AtomicLong requested , long n ) { for ( ; ; ) { long [[phosphorous]] = requested . get ( ) ; if ( [[phosphorous]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[yu]] = addCap ( [[phosphorous]] , n ) ; if ( requested . compareAndSet ( [[phosphorous]] , [[yu]] ) ) { return [[phosphorous]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 44 ---------------------------------------------
Returns the size of the resources . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[confection]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[defines]] = resources ; return [[defines]] != null ? [[defines]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 45 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 30 / 14 / 1 / 45:   4%|▍         | 45/1000 [00:00<00:00, 2175.19it/s][Succeeded / Failed / Skipped / Total] 30 / 15 / 1 / 46:   5%|▍         | 46/1000 [00:00<00:00, 2190.78it/s][Succeeded / Failed / Skipped / Total] 31 / 15 / 1 / 47:   5%|▍         | 47/1000 [00:00<00:00, 2205.85it/s][Succeeded / Failed / Skipped / Total] 32 / 15 / 1 / 48:   5%|▍         | 48/1000 [00:00<00:00, 2222.05it/s][Succeeded / Failed / Skipped / Total] 33 / 15 / 1 / 49:   5%|▍         | 49/1000 [00:00<00:00, 2226.13it/s][Succeeded / Failed / Skipped / Total] 34 / 15 / 1 / 50:   5%|▌         | 50/1000 [00:00<00:00, 2233.22it/s][Succeeded / Failed / Skipped / Total] 35 / 15 / 1 / 51:   5%|▌         | 51/1000 [00:00<00:00, 2249.88it/s]Flatten the given exception into a list . --> Destroys the given exception --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable [[e]] = deque . removeFirst ( ) ; if ( [[e]] instanceof CompositeException ) { CompositeException ce = ( CompositeException ) [[e]] ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( [[e]] ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[destroy]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable [[b]] = deque . removeFirst ( ) ; if ( [[b]] instanceof CompositeException ) { CompositeException ce = ( CompositeException ) [[b]] ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( [[b]] ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 46 ---------------------------------------------
Create a new observable with the given value --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[burg]] ( T [[valuation]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[delish]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[valuation]] , [[delish]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 47 ---------------------------------------------
Checks if the given exception throws an exception . --> Throws the throw exception if it is enabled --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[f]] [[expansion]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[f]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[f]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 48 ---------------------------------------------
Removes all resources from the list . --> F743 - 5 --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[perceptible]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[defines]] ; synchronized ( this ) { if ( disposed ) { return ; } [[defines]] = resources ; resources = null ; } dispose ( [[defines]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 49 ---------------------------------------------
Inserts the given element into the queue . --> Offers a new element --> Socre: 1.0

[[[[Adv]]]]: public boolean offer ( T t ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return "[[True]]" == "[[True]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean offer ( T t ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return "[[Velma]]" == "[[Velma]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 50 ---------------------------------------------
Sets the upstream AtomicReference to the next AtomicReference . --> private static final int --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean [[whacko]] ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > [[consumer]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[consumer]] ) ; } return "[[Fallacious]]" != "[[Fallacious]]" ; } return "[[Candid]]" == "[[Candid]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 51 ---------------------------------------------
Start Unbounded . --> Get kazimierz --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[kazimierz]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 52 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 36 / 15 / 1 / 52:   5%|▌         | 52/1000 [00:00<00:00, 2234.74it/s][Succeeded / Failed / Skipped / Total] 37 / 15 / 1 / 53:   5%|▌         | 53/1000 [00:00<00:00, 2247.23it/s][Succeeded / Failed / Skipped / Total] 37 / 16 / 1 / 54:   5%|▌         | 54/1000 [00:00<00:00, 2264.09it/s][Succeeded / Failed / Skipped / Total] 38 / 16 / 1 / 55:   6%|▌         | 55/1000 [00:00<00:00, 2274.64it/s][Succeeded / Failed / Skipped / Total] 39 / 16 / 1 / 56:   6%|▌         | 56/1000 [00:00<00:00, 2289.38it/s][Succeeded / Failed / Skipped / Total] 40 / 16 / 1 / 57:   6%|▌         | 57/1000 [00:00<00:00, 2304.81it/s][Succeeded / Failed / Skipped / Total] 40 / 16 / 1 / 57:   6%|▌         | 58/1000 [00:03<01:01, 15.28it/s]  [Succeeded / Failed / Skipped / Total] 41 / 16 / 1 / 58:   6%|▌         | 58/1000 [00:03<01:01, 15.28it/s]Tries to try to locate aScalar XMapSubscribe . --> grievances an observer --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > [[source]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[grievances]] ( ObservableSource < T > [[melted]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[melted]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[melted]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 53 ---------------------------------------------
Called when an error occurs . --> FUSED - 1 --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[awry]] ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 54 ---------------------------------------------
Start the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[introductory]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 55 ---------------------------------------------
Completes the value . --> FUSED - 1 --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[a]] = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[value]] ; lazySet ( FUSED_READY ) ; [[a]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[a]] . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { [[a]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[finite]] ( T [[appreciated]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[anche]] = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[appreciated]] ; lazySet ( FUSED_READY ) ; [[anche]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[anche]] . onNext ( [[appreciated]] ) ; } if ( get ( ) != DISPOSED ) { [[anche]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 56 ---------------------------------------------
Get the disposed . --> Get Disposables object --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[learns]] ( ) { Disposable [[k]] = resource . get ( ) ; if ( [[k]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[k]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 57 ---------------------------------------------
Called when complete is enabled . --> FUSED_CONSUMED | DISPOSED --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[complemented]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 58 ---------------------------------------------
Issues a request . --> Request for nah --> Socre: 1.0

[[[[Adv]]]]: protected final void request ( long [[n]] ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void request ( long [[nah]] ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( [[nah]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 59 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 16 / 1 / 59:   6%|▌         | 59/1000 [00:04<01:08, 13.83it/s][Succeeded / Failed / Skipped / Total] 43 / 16 / 1 / 60:   6%|▌         | 60/1000 [00:05<01:20, 11.61it/s][Succeeded / Failed / Skipped / Total] 44 / 16 / 1 / 61:   6%|▌         | 61/1000 [00:06<01:43,  9.04it/s][Succeeded / Failed / Skipped / Total] 44 / 17 / 1 / 62:   6%|▌         | 62/1000 [00:08<02:13,  7.04it/s][Succeeded / Failed / Skipped / Total] 45 / 17 / 1 / 63:   6%|▋         | 63/1000 [00:12<03:05,  5.04it/s][Succeeded / Failed / Skipped / Total] 46 / 17 / 1 / 64:   6%|▋         | 64/1000 [00:13<03:14,  4.81it/s][Succeeded / Failed / Skipped / Total] 47 / 17 / 1 / 65:   6%|▋         | 65/1000 [00:16<03:54,  3.99it/s]Concatenates the passed in sequence . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[josiah]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[kristy]] ) { return [[josiah]] ( [[kristy]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 60 ---------------------------------------------
Waits for the consumer to be executed . --> Set anticipation --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[anticipation]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[anticipation]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 61 ---------------------------------------------
Get the concat mapDelay error . --> Untrustworthy function --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return [[concatMapDelayError]] ( [[mapper]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[untrustworthy]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[breakf]] ) { return [[untrustworthy]] ( [[breakf]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 62 ---------------------------------------------
Returns an ordered sorted sort of the given sort function . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorting]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 63 ---------------------------------------------
Creates a flowable with the specified scheduler . --> Create a flowable from cf --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[grate]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 64 ---------------------------------------------
Removes all elements from the stream . --> withdrawal method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[remove]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[withdrawal]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 65 ---------------------------------------------
Sets the amount of times in milliseconds . --> Fractures amount of time --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long amount , TimeUnit unit ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = unit . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[fractures]] ( long amount , TimeUnit unit ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = unit . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 66 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 17 / 1 / 66:   7%|▋         | 66/1000 [00:19<04:39,  3.34it/s][Succeeded / Failed / Skipped / Total] 48 / 18 / 1 / 67:   7%|▋         | 67/1000 [00:24<05:37,  2.77it/s][Succeeded / Failed / Skipped / Total] 48 / 19 / 1 / 68:   7%|▋         | 68/1000 [00:25<05:49,  2.67it/s][Succeeded / Failed / Skipped / Total] 49 / 19 / 1 / 69:   7%|▋         | 69/1000 [00:29<06:39,  2.33it/s][Succeeded / Failed / Skipped / Total] 50 / 19 / 1 / 70:   7%|▋         | 70/1000 [00:35<07:50,  1.98it/s][Succeeded / Failed / Skipped / Total] 50 / 20 / 1 / 71:   7%|▋         | 71/1000 [00:37<08:12,  1.89it/s][Succeeded / Failed / Skipped / Total] 51 / 20 / 1 / 72:   7%|▋         | 72/1000 [00:37<08:05,  1.91it/s]Create sample data . --> Create sample data --> Socre: 1.0

[[[[Adv]]]]: private void createSampleData ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[auth]] = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void createSampleData ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[hillard]] = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 67 ---------------------------------------------
Creates the error response . --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[bogeyman]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 68 ---------------------------------------------
Accepts a subscriber . --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > subscriber ) { Object [ ] [[a]] = head ; final int [[c]] = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < [[c]] ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } [[a]] = ( Object [ ] ) [[a]] [ [[c]] ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[acknowledges]] ( Subscriber < ? super U > subscriber ) { Object [ ] [[alia]] = head ; final int [[third]] = capacity ; while ( [[alia]] != null ) { for ( int i = 0 ; i < [[third]] ; i ++ ) { Object o = [[alia]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } [[alia]] = ( Object [ ] ) [[alia]] [ [[third]] ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 69 ---------------------------------------------
Returns the HttpMethod object for the given string . --> Ongoing mode --> Socre: 1.0

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[ongoing]] ( String [[forms]] ) { try { return HttpMethod . valueOf ( [[forms]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 70 ---------------------------------------------
Search for the context . --> Search for attributes . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[template]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[template]] . setSearchControls ( searchControls ) ; try { return [[template]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[gmail]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[gmail]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[modelled]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[modelled]] . setSearchControls ( searchControls ) ; try { return [[modelled]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[gmail]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[gmail]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 71 ---------------------------------------------
Accepts an observer . --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] [[mejor]] = head ; final int c = capacity ; while ( [[mejor]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[mejor]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } [[mejor]] = ( Object [ ] ) [[mejor]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 72 ---------------------------------------------
Encode a raw password . --> Gets encryption --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( CharSequence rawPassword ) { String [[salt]] = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( [[salt]] , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[encryption]] ( CharSequence rawPassword ) { String [[briny]] = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( [[briny]] , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 73 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 52 / 20 / 1 / 73:   7%|▋         | 73/1000 [00:37<08:00,  1.93it/s][Succeeded / Failed / Skipped / Total] 52 / 21 / 1 / 74:   7%|▋         | 74/1000 [00:40<08:21,  1.85it/s][Succeeded / Failed / Skipped / Total] 53 / 21 / 1 / 75:   8%|▊         | 75/1000 [00:43<09:02,  1.71it/s][Succeeded / Failed / Skipped / Total] 54 / 21 / 1 / 76:   8%|▊         | 76/1000 [00:46<09:20,  1.65it/s][Succeeded / Failed / Skipped / Total] 55 / 21 / 1 / 77:   8%|▊         | 77/1000 [00:52<10:27,  1.47it/s][Succeeded / Failed / Skipped / Total] 56 / 21 / 1 / 78:   8%|▊         | 78/1000 [00:54<10:38,  1.44it/s][Succeeded / Failed / Skipped / Total] 56 / 22 / 1 / 79:   8%|▊         | 79/1000 [00:55<10:44,  1.43it/s][Succeeded / Failed / Skipped / Total] 57 / 22 / 1 / 80:   8%|▊         | 80/1000 [00:55<10:36,  1.45it/s]Checks if the version is valid . --> If the minimumSpringVersion is null return the minSpringVersion --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[amsterdam]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 74 ---------------------------------------------
Calculates the delta for the specified time unit . --> [[[FAILED]]]

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit [[unit]] ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[jansen]] ( TimeUnit [[unifying]] ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 75 ---------------------------------------------
Returns true if the encoded password matches the raw password . --> Returns true if raw ledge is partner . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence rawPassword , String [[encodedPassword]] ) { String salt = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[partner]] ( CharSequence rawPassword , String [[ledge]] ) { String salt = extractSalt ( [[ledge]] ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( [[ledge]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 76 ---------------------------------------------
Default implementation of oauth2Client . --> Returns an oauth2ClientConfigurer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[incas]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[incas]] ) ; return [[incas]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 77 ---------------------------------------------
Adds the subscribers . --> Methode d n + 1 --> Socre: 1.0

[[[[Adv]]]]: boolean [[add]] ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED ) { return "False" != "False" ; } int n = [[a]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[b]] = new PublishDisposable [ n + 1 ] ; System . arraycopy ( [[a]] , 0 , [[b]] , 0 , n ) ; [[b]] [ n ] = [[ps]] ; if ( subscribers . compareAndSet ( [[a]] , [[b]] ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean [[insertion]] ( PublishDisposable < T > [[sf]] ) { for ( ; ; ) { PublishDisposable < T > [ ] [[esta]] = subscribers . get ( ) ; if ( [[esta]] == TERMINATED ) { return "False" != "False" ; } int n = [[esta]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[johnston]] = new PublishDisposable [ n + 1 ] ; System . arraycopy ( [[esta]] , 0 , [[johnston]] , 0 , n ) ; [[johnston]] [ n ] = [[sf]] ; if ( subscribers . compareAndSet ( [[esta]] , [[johnston]] ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 78 ---------------------------------------------
Adds an AttributeExchangeConfigurer . --> diluted --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String identifierPattern ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[diluted]] ( String identifierPattern ) { AttributeExchangeConfigurer [[brickworks]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[brickworks]] ) ; return [[brickworks]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 79 ---------------------------------------------
Gets the provider version . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[anthology]] ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 80 ---------------------------------------------
Default configurationurer . --> A convenience method for untrustworthy --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[untrustworthy]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[distrust]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[distrust]] ) ; return [[distrust]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 81 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 23 / 1 / 81:   8%|▊         | 81/1000 [01:05<12:23,  1.24it/s][Succeeded / Failed / Skipped / Total] 58 / 23 / 1 / 82:   8%|▊         | 82/1000 [01:07<12:36,  1.21it/s][Succeeded / Failed / Skipped / Total] 58 / 24 / 1 / 83:   8%|▊         | 83/1000 [01:11<13:07,  1.16it/s][Succeeded / Failed / Skipped / Total] 59 / 24 / 1 / 84:   8%|▊         | 84/1000 [01:11<13:00,  1.17it/s][Succeeded / Failed / Skipped / Total] 60 / 24 / 1 / 85:   8%|▊         | 85/1000 [01:11<12:54,  1.18it/s]Returns a new read - only security registry . --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[crowley]] ( ) throws Exception { ApplicationContext [[fount]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[fount]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 82 ---------------------------------------------
Search for entry under DN --> Searches the results of a given entry under a DN --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > [[results]] = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } [[results]] . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( [[results]] . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( [[results]] . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , [[results]] . size ( ) ) ; } return [[results]] . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > [[attainment]] = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } [[attainment]] . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( [[attainment]] . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( [[attainment]] . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , [[attainment]] . size ( ) ) ; } return [[attainment]] . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 83 ---------------------------------------------
Checks if the given spring version is disabled . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String [[springSecurityVersion]] ) { if ( springVersion == null || springVersion . equals ( [[springSecurityVersion]] ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String [[crawlers]] ) { if ( springVersion == null || springVersion . equals ( [[crawlers]] ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 84 ---------------------------------------------
Retrieve a single entry from an LDAP server . --> Execute anOperations for beryl --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { Attributes attrs = [[ctx]] . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[beryl]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[req]] ) throws NamingException { Attributes attrs = [[req]] . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 85 ---------------------------------------------
Builds a searchControls . --> Returns a new searchControls --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[akin]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 86 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 61 / 24 / 1 / 86:   9%|▊         | 86/1000 [01:17<13:48,  1.10it/s][Succeeded / Failed / Skipped / Total] 62 / 24 / 1 / 87:   9%|▊         | 87/1000 [01:18<13:39,  1.11it/s][Succeeded / Failed / Skipped / Total] 63 / 24 / 1 / 88:   9%|▉         | 88/1000 [01:25<14:49,  1.03it/s]Compare the supplied string with the supplied value . --> Compares dn and extent --> Socre: 1.0

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object [[value]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[value]] } , ctls ) ; Boolean [[match]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[match]] ; } } Boolean [[matches]] = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return [[matches]] . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object [[extent]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[extent]] } , ctls ) ; Boolean [[equivalency]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[equivalency]] ; } } Boolean [[corresponded]] = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return [[corresponded]] . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 87 ---------------------------------------------
Create servlet api filter . --> CreateServletApiFilter . --> Socre: 1.0

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String [[provideServletApi]] = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[provideServletApi]] ) ) { [[provideServletApi]] = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( [[provideServletApi]] ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String [[chronic]] = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[chronic]] ) ) { [[chronic]] = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( [[chronic]] ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Create bean definition . --> Create an embedded server --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element [[element]] , ParserContext parserContext ) { Object source = parserContext . extractSource ( [[element]] ) ; String suffix = [[element]] . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = [[element]] . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = [[element]] . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , [[element]] ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element [[factor]] , ParserContext parserContext ) { Object source = parserContext . extractSource ( [[factor]] ) ; String suffix = [[factor]] . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = [[factor]] . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = [[factor]] . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , [[factor]] ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 89 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 64 / 24 / 1 / 89:   9%|▉         | 89/1000 [01:26<14:48,  1.02it/s][Succeeded / Failed / Skipped / Total] 64 / 25 / 1 / 90:   9%|▉         | 90/1000 [01:27<14:42,  1.03it/s][Succeeded / Failed / Skipped / Total] 65 / 25 / 1 / 91:   9%|▉         | 91/1000 [01:30<15:01,  1.01it/s][Succeeded / Failed / Skipped / Total] 65 / 26 / 1 / 92:   9%|▉         | 92/1000 [01:32<15:11,  1.00s/it][Succeeded / Failed / Skipped / Total] 66 / 26 / 1 / 93:   9%|▉         | 93/1000 [01:33<15:14,  1.01s/it][Succeeded / Failed / Skipped / Total] 67 / 26 / 1 / 94:   9%|▉         | 94/1000 [01:38<15:46,  1.05s/it]Parses the annotations . --> Handles HttpServiceMethod request --> Socre: 1.0

[[[[Adv]]]]: static < [[ResponseT]] , ReturnT > HttpServiceMethod < [[ResponseT]] , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean [[isKotlinSuspendFunction]] = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type [[adapterType]] ; if ( [[isKotlinSuspendFunction]] ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < [[canon]] , ReturnT > HttpServiceMethod < [[canon]] , ReturnT > [[amok]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean [[awhile]] = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type [[jamie]] ; if ( [[awhile]] ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 90 ---------------------------------------------
Search for multiple attribute values . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[phonebook]] ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 91 ---------------------------------------------
Create the appropriate Jaas API filter . --> escalates --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[escalates]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 92 ---------------------------------------------
Creates a default type resolver . --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[ongoing]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[fruits]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[fruits]] = [[fruits]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[fruits]] = [[fruits]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[fruits]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 93 ---------------------------------------------
Insert the spring security filter --> Insert Spring security filter --> Socre: 1.0

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String [[filterName]] = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( [[filterName]] ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , [[filterName]] , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String [[barfing]] = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( [[barfing]] ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , [[barfing]] , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 94 ---------------------------------------------
Creates a new instance of Cipher . --> Geysers the given algorithm --> Socre: 1.0

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[geysers]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 95 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 67 / 27 / 1 / 95:  10%|▉         | 95/1000 [01:44<16:31,  1.10s/it][Succeeded / Failed / Skipped / Total] 68 / 27 / 1 / 96:  10%|▉         | 96/1000 [01:47<16:48,  1.12s/it][Succeeded / Failed / Skipped / Total] 69 / 27 / 1 / 97:  10%|▉         | 97/1000 [01:48<16:54,  1.12s/it][Succeeded / Failed / Skipped / Total] 69 / 28 / 1 / 98:  10%|▉         | 98/1000 [01:53<17:25,  1.16s/it][Succeeded / Failed / Skipped / Total] 70 / 28 / 1 / 99:  10%|▉         | 99/1000 [01:54<17:20,  1.15s/it]Check if properties are set . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[kools]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 96 ---------------------------------------------
Get the list of authorities associated with the given attributes . --> Get all trappings --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String attribute : [[attributes]] ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[baumann]] ( Collection < String > [[trappings]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[trappings]] . size ( ) ) ; for ( String attribute : [[trappings]] ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 97 ---------------------------------------------
Is principal changed? --> dissertation a request --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[dissertation]] ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 98 ---------------------------------------------
Build the authentication details . --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest [[context]] ) { Collection < String > j2eeUserRoles = getUserRoles ( [[context]] ) ; Collection < ? extends GrantedAuthority > [[userGas]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + [[userGas]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[result]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[context]] , [[userGas]] ) ; return [[result]] ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[anon]] ( HttpServletRequest [[historic]] ) { Collection < String > j2eeUserRoles = getUserRoles ( [[historic]] ) ; Collection < ? extends GrantedAuthority > [[bournemouth]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + [[bournemouth]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[achievement]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[historic]] , [[bournemouth]] ) ; return [[achievement]] ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 99 ---------------------------------------------
Returns the token for a series . --> Gets PersistentRemMeToken from seriesId --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int [[rowNum]] ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[gush]] ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int [[archdeacon]] ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 100 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 71 / 28 / 1 / 100:  10%|█         | 100/1000 [01:55<17:16,  1.15s/it][Succeeded / Failed / Skipped / Total] 72 / 28 / 1 / 101:  10%|█         | 101/1000 [01:58<17:31,  1.17s/it][Succeeded / Failed / Skipped / Total] 73 / 28 / 1 / 102:  10%|█         | 102/1000 [02:01<17:45,  1.19s/it][Succeeded / Failed / Skipped / Total] 74 / 28 / 1 / 103:  10%|█         | 103/1000 [02:05<18:11,  1.22s/it][Succeeded / Failed / Skipped / Total] 75 / 28 / 1 / 104:  10%|█         | 104/1000 [02:07<18:21,  1.23s/it][Succeeded / Failed / Skipped / Total] 76 / 28 / 1 / 105:  10%|█         | 105/1000 [02:09<18:23,  1.23s/it]Lookup primary keys --> lookup primaryKeys --> Socre: 1.0

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > [[acls]] , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( [[acls]] , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( [[acls]] , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > [[meeny]] , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( [[meeny]] , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( [[meeny]] , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 101 ---------------------------------------------
Perform a filter --> diluted --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest [[request]] , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[request]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[request]] , ( HttpServletResponse ) response ) ; } chain . doFilter ( [[request]] , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[diluted]] ( ServletRequest [[asked]] , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[asked]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[asked]] , ( HttpServletResponse ) response ) ; } chain . doFilter ( [[asked]] , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 102 ---------------------------------------------
Check content length . --> Check content length --> Socre: 1.0

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int [[bufferSize]] = getBufferSize ( ) ; boolean requiresFlush = [[bufferSize]] > 0 && this . contentWritten >= [[bufferSize]] ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int [[maha]] = getBufferSize ( ) ; boolean requiresFlush = [[maha]] > 0 && this . contentWritten >= [[maha]] ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 103 ---------------------------------------------
Updates all the access values . --> Do not call this method --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[verger]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 104 ---------------------------------------------
Sets the login processing url . --> Retrieve a monte value --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String [[loginProcessingUrl]] ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[monte]] ( String [[shreveport]] ) { this . loginProcessingUrl = [[monte]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[monte]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 105 ---------------------------------------------
Returns all the authorities of the given authorities . --> map by administrations --> Socre: 1.0

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[authorities]] ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( [[authorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[authorities]] ) { mapped . add ( mapAuthority ( [[authority]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[institution]] ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( [[institution]] . size ( ) ) ; for ( GrantedAuthority [[administrations]] : [[institution]] ) { mapped . add ( mapAuthority ( [[administrations]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 106 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 77 / 28 / 1 / 106:  11%|█         | 106/1000 [02:09<18:15,  1.23s/it][Succeeded / Failed / Skipped / Total] 78 / 28 / 1 / 107:  11%|█         | 107/1000 [02:13<18:33,  1.25s/it][Succeeded / Failed / Skipped / Total] 79 / 28 / 1 / 108:  11%|█         | 108/1000 [02:14<18:33,  1.25s/it][Succeeded / Failed / Skipped / Total] 80 / 28 / 1 / 109:  11%|█         | 109/1000 [02:15<18:25,  1.24s/it][Succeeded / Failed / Skipped / Total] 80 / 29 / 1 / 110:  11%|█         | 110/1000 [02:15<18:19,  1.24s/it]Process authentication . --> meeny method --> Socre: 1.0

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest [[request]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( [[request]] ) ; Object [[credentials]] = getPreAuthenticatedCredentials ( [[request]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , [[credentials]] ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[request]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[request]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[meeny]] ( HttpServletRequest [[invitation]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( [[invitation]] ) ; Object [[faculties]] = getPreAuthenticatedCredentials ( [[invitation]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , [[faculties]] ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[invitation]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[invitation]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[invitation]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 107 ---------------------------------------------
Encode cookie tokens . --> back error messages --> Socre: 1.0

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[backdrop]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 108 ---------------------------------------------
Map password . --> region bernstein --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[bernstein]] ( Object [[omit]] ) { if ( ! ( [[omit]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 109 ---------------------------------------------
Returns the cookie name . --> Return null if not found --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie [[cookie]] : cookies ) { if ( cookieName . equals ( [[cookie]] . getName ( ) ) ) { return [[cookie]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[assembler]] ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie [[bakery]] : cookies ) { if ( cookieName . equals ( [[bakery]] . getName ( ) ) ) { return [[bakery]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 110 ---------------------------------------------
Updates the current authentication defaults . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[eliza]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 111 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 29 / 1 / 111:  11%|█         | 111/1000 [02:22<18:58,  1.28s/it][Succeeded / Failed / Skipped / Total] 81 / 30 / 1 / 112:  11%|█         | 112/1000 [02:29<19:46,  1.34s/it][Succeeded / Failed / Skipped / Total] 81 / 31 / 1 / 113:  11%|█▏        | 113/1000 [02:34<20:15,  1.37s/it][Succeeded / Failed / Skipped / Total] 82 / 31 / 1 / 114:  11%|█▏        | 114/1000 [02:37<20:20,  1.38s/it][Succeeded / Failed / Skipped / Total] 83 / 31 / 1 / 115:  12%|█▏        | 115/1000 [02:37<20:12,  1.37s/it][Succeeded / Failed / Skipped / Total] 83 / 31 / 1 / 115:  12%|█▏        | 116/1000 [02:41<20:34,  1.40s/it][Succeeded / Failed / Skipped / Total] 83 / 32 / 1 / 116:  12%|█▏        | 116/1000 [02:41<20:34,  1.40s/it][Succeeded / Failed / Skipped / Total] 83 / 32 / 1 / 116:  12%|█▏        | 117/1000 [02:43<20:37,  1.40s/it][Succeeded / Failed / Skipped / Total] 84 / 32 / 1 / 117:  12%|█▏        | 117/1000 [02:43<20:37,  1.40s/it]Returns the authentication authentication . --> Authenticate event . --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[asking]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 112 ---------------------------------------------
Search for multiple attribute values . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [[attributeName]] ) { String [ ] attributeNames = new String [ ] { [[attributeName]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[attributeName]] ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[perpetually]] ( final String base , final String filter , final Object [ ] params , final String [[amok]] ) { String [ ] attributeNames = new String [ ] { [[amok]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[amok]] ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 113 ---------------------------------------------
Get the default port . --> [[[FAILED]]]

[[[[Adv]]]]: private static int [[getServicePort]] ( URL casServiceUrl ) { int port = casServiceUrl . getPort ( ) ; if ( port == - 1 ) { port = casServiceUrl . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[seminal]] ( URL casServiceUrl ) { int port = casServiceUrl . getPort ( ) ; if ( port == - 1 ) { port = casServiceUrl . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 114 ---------------------------------------------
Sets the environment properties . --> set the default attributes --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[astrophysicist]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 115 ---------------------------------------------
Log authentication . --> logout function --> Socre: 1.0

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication [[authentication]] ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication [[attested]] ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 116 ---------------------------------------------
Gets the full redirect url . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[diluted]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 117 ---------------------------------------------
Render the tag . --> get trademarks --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[trademarks]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 118 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 85 / 32 / 1 / 118:  12%|█▏        | 118/1000 [02:44<20:26,  1.39s/it][Succeeded / Failed / Skipped / Total] 85 / 32 / 1 / 118:  12%|█▏        | 119/1000 [02:48<20:44,  1.41s/it][Succeeded / Failed / Skipped / Total] 85 / 33 / 1 / 119:  12%|█▏        | 119/1000 [02:48<20:44,  1.41s/it][Succeeded / Failed / Skipped / Total] 86 / 33 / 1 / 120:  12%|█▏        | 120/1000 [02:49<20:40,  1.41s/it][Succeeded / Failed / Skipped / Total] 86 / 33 / 1 / 120:  12%|█▏        | 121/1000 [02:50<20:35,  1.41s/it][Succeeded / Failed / Skipped / Total] 87 / 33 / 1 / 121:  12%|█▏        | 121/1000 [02:50<20:35,  1.41s/it][Succeeded / Failed / Skipped / Total] 88 / 33 / 1 / 122:  12%|█▏        | 122/1000 [02:52<20:42,  1.42s/it][Succeeded / Failed / Skipped / Total] 88 / 33 / 1 / 122:  12%|█▏        | 123/1000 [02:53<20:38,  1.41s/it]Initialize the user ordered list . --> Initialize UserDetailsService --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder [[userBuilder]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[userBuilder]] . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder [[andit]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[andit]] . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 119 ---------------------------------------------
Get query string . --> [[[FAILED]]]

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[aerials]] ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 120 ---------------------------------------------
Get the principal . --> Unexplored method --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails [[details]] = ( LdapUserDetails ) principal ; return [[details]] . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[unexplored]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails [[clarification]] = ( LdapUserDetails ) principal ; return [[clarification]] . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 121 ---------------------------------------------
Get the UserDetailsService . --> Get UserDetailsService model --> Socre: 1.0

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[hiking]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 122 ---------------------------------------------
Add additional parameters . --> Generates a PkceParameter --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[luz]] ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 123 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 88 / 34 / 1 / 123:  12%|█▏        | 123/1000 [02:53<20:38,  1.41s/it][Succeeded / Failed / Skipped / Total] 89 / 34 / 1 / 124:  12%|█▏        | 124/1000 [03:02<21:29,  1.47s/it][Succeeded / Failed / Skipped / Total] 89 / 34 / 1 / 124:  12%|█▎        | 125/1000 [03:08<22:00,  1.51s/it][Succeeded / Failed / Skipped / Total] 89 / 35 / 1 / 125:  12%|█▎        | 125/1000 [03:08<22:00,  1.51s/it][Succeeded / Failed / Skipped / Total] 89 / 35 / 1 / 125:  13%|█▎        | 126/1000 [03:09<21:51,  1.50s/it][Succeeded / Failed / Skipped / Total] 90 / 35 / 1 / 126:  13%|█▎        | 126/1000 [03:09<21:51,  1.50s/it][Succeeded / Failed / Skipped / Total] 90 / 35 / 1 / 126:  13%|█▎        | 127/1000 [03:10<21:48,  1.50s/it][Succeeded / Failed / Skipped / Total] 90 / 36 / 1 / 127:  13%|█▎        | 127/1000 [03:10<21:48,  1.50s/it][Succeeded / Failed / Skipped / Total] 90 / 36 / 1 / 127:  13%|█▎        | 128/1000 [03:10<21:40,  1.49s/it]Sets the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int [[maxAge]] , HttpServletRequest request , HttpServletResponse [[response]] ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[maxAge]] ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[response]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int [[boysenberry]] , HttpServletRequest request , HttpServletResponse [[retort]] ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[boysenberry]] ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[boysenberry]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[retort]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 124 ---------------------------------------------
Create a MethodSecurityExpressionOperations . --> Create a MethodSecurityExpressionRoot --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication [[authentication]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[authentication]] ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication [[crypto]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[crypto]] ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 125 ---------------------------------------------
Determines if the authentication is authenticated . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[endorsed]] ( ) { Authentication [[credentials]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[credentials]] != null && [[credentials]] . isAuthenticated ( ) && ! ( [[credentials]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 126 ---------------------------------------------
Returns cached jwkSet . --> Returns a Mono --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[cachedJWKSet]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[ebonics]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 127 ---------------------------------------------
Resolve a method argument . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > [[reactiveSecurityContext]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[reactiveSecurityContext]] == null ) { return null ; } return [[reactiveSecurityContext]] . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > [[hallucination]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[hallucination]] == null ) { return null ; } return [[hallucination]] . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 128 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 90 / 37 / 1 / 128:  13%|█▎        | 128/1000 [03:10<21:40,  1.49s/it][Succeeded / Failed / Skipped / Total] 90 / 37 / 1 / 128:  13%|█▎        | 129/1000 [03:16<22:05,  1.52s/it][Succeeded / Failed / Skipped / Total] 91 / 37 / 1 / 129:  13%|█▎        | 129/1000 [03:16<22:05,  1.52s/it][Succeeded / Failed / Skipped / Total] 91 / 37 / 1 / 129:  13%|█▎        | 130/1000 [03:21<22:26,  1.55s/it][Succeeded / Failed / Skipped / Total] 91 / 38 / 1 / 130:  13%|█▎        | 130/1000 [03:21<22:26,  1.55s/it][Succeeded / Failed / Skipped / Total] 91 / 38 / 1 / 130:  13%|█▎        | 131/1000 [03:21<22:19,  1.54s/it][Succeeded / Failed / Skipped / Total] 92 / 38 / 1 / 131:  13%|█▎        | 131/1000 [03:21<22:19,  1.54s/it][Succeeded / Failed / Skipped / Total] 92 / 38 / 1 / 131:  13%|█▎        | 132/1000 [03:25<22:29,  1.55s/it][Succeeded / Failed / Skipped / Total] 92 / 39 / 1 / 132:  13%|█▎        | 132/1000 [03:25<22:29,  1.55s/it][Succeeded / Failed / Skipped / Total] 92 / 39 / 1 / 132:  13%|█▎        | 133/1000 [03:26<22:27,  1.55s/it][Succeeded / Failed / Skipped / Total] 92 / 40 / 1 / 133:  13%|█▎        | 133/1000 [03:26<22:27,  1.55s/it][Succeeded / Failed / Skipped / Total] 92 / 40 / 1 / 133:  13%|█▎        | 134/1000 [03:28<22:28,  1.56s/it]Build the provider url --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > [[urls]] , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[urls]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : [[urls]] ) { String [[trimmedUrl]] = serverUrl . trim ( ) ; if ( "" . equals ( [[trimmedUrl]] ) ) { continue ; } providerUrl . append ( [[trimmedUrl]] ) ; if ( ! [[trimmedUrl]] . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > [[judex]] , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[judex]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : [[judex]] ) { String [[sussex]] = serverUrl . trim ( ) ; if ( "" . equals ( [[sussex]] ) ) { continue ; } providerUrl . append ( [[sussex]] ) ; if ( ! [[sussex]] . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 129 ---------------------------------------------
URL encode a string . --> Encodes a string . --> Socre: 1.0

[[[[Adv]]]]: private String [[utf8UrlEncode]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String [[abra]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 130 ---------------------------------------------
Service ticket request . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest [[request]] , final HttpServletResponse response ) { boolean [[result]] = super . requiresAuthentication ( [[request]] , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[drivel]] ( final HttpServletRequest [[demand]] , final HttpServletResponse response ) { boolean [[wake]] = super . requiresAuthentication ( [[demand]] , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[wake]] ) ; } return [[wake]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 131 ---------------------------------------------
Loads a user token . --> load userByAssertion --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails loadUserByAssertion ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . [[authenticationUserDetailsService]] . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails loadUserByAssertion ( final Assertion [[complaint]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[complaint]] , "" ) ; return this . [[zigi]] . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 132 ---------------------------------------------
Returns true if the request should be used . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[turbulent]] ( final HttpServletRequest [[wondered]] ) { final boolean [[conclusions]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[wondered]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[conclusions]] ) ; } return [[conclusions]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 133 ---------------------------------------------
Determines if a service ticket request requires a service ticket request . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 134 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 92 / 41 / 1 / 134:  13%|█▎        | 134/1000 [03:28<22:28,  1.56s/it][Succeeded / Failed / Skipped / Total] 92 / 41 / 1 / 134:  14%|█▎        | 135/1000 [03:31<22:34,  1.57s/it][Succeeded / Failed / Skipped / Total] 93 / 41 / 1 / 135:  14%|█▎        | 135/1000 [03:31<22:34,  1.57s/it][Succeeded / Failed / Skipped / Total] 93 / 41 / 1 / 135:  14%|█▎        | 136/1000 [03:34<22:42,  1.58s/it][Succeeded / Failed / Skipped / Total] 94 / 41 / 1 / 136:  14%|█▎        | 136/1000 [03:34<22:42,  1.58s/it][Succeeded / Failed / Skipped / Total] 94 / 41 / 1 / 136:  14%|█▎        | 137/1000 [03:35<22:37,  1.57s/it][Succeeded / Failed / Skipped / Total] 94 / 42 / 1 / 137:  14%|█▎        | 137/1000 [03:35<22:37,  1.57s/it][Succeeded / Failed / Skipped / Total] 94 / 42 / 1 / 137:  14%|█▍        | 138/1000 [03:36<22:29,  1.57s/it][Succeeded / Failed / Skipped / Total] 94 / 43 / 1 / 138:  14%|█▍        | 138/1000 [03:36<22:29,  1.57s/it][Succeeded / Failed / Skipped / Total] 94 / 43 / 1 / 138:  14%|█▍        | 139/1000 [03:47<23:31,  1.64s/it][Succeeded / Failed / Skipped / Total] 95 / 43 / 1 / 139:  14%|█▍        | 139/1000 [03:47<23:31,  1.64s/it][Succeeded / Failed / Skipped / Total] 95 / 43 / 1 / 139:  14%|█▍        | 140/1000 [03:48<23:23,  1.63s/it][Succeeded / Failed / Skipped / Total] 96 / 43 / 1 / 140:  14%|█▍        | 140/1000 [03:48<23:23,  1.63s/it][Succeeded / Failed / Skipped / Total] 96 / 43 / 1 / 140:  14%|█▍        | 141/1000 [03:52<23:36,  1.65s/it][Succeeded / Failed / Skipped / Total] 96 / 44 / 1 / 141:  14%|█▍        | 141/1000 [03:52<23:36,  1.65s/it][Succeeded / Failed / Skipped / Total] 96 / 44 / 1 / 141:  14%|█▍        | 142/1000 [03:53<23:32,  1.65s/it]proxy ticket request . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean serviceTicketRequest , final HttpServletRequest [[request]] ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[asteroid]] ( final boolean serviceTicketRequest , final HttpServletRequest [[sought]] ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean [[fruition]] = authenticateAllArtifacts && obtainArtifact ( [[sought]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[fruition]] ) ; } return [[fruition]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 135 ---------------------------------------------
subarray of the given array --> auxiliary auxiliary method --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[auxiliary]] ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 136 ---------------------------------------------
Gets the authority collection . --> Gets theAuthorityCollection . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , value ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > [[outcomes]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[outcomes]] , value ) ; return [[outcomes]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 137 ---------------------------------------------
Gets the principal . --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[linge]] ( HttpServletRequest httpRequest ) { Object [[maj]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[maj]] ) ; } return [[maj]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 138 ---------------------------------------------
Returns the active GrantedAuthority for the current user . --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > [[impressive]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[impressive]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[impressive]] + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 139 ---------------------------------------------
Preload map . --> Pre - search for access2granted . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > [[enters]] : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[enters]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[enters]] . getKey ( ) , getGrantedAuthorityCollection ( [[enters]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 140 ---------------------------------------------
Gets the shared object . --> tres the specified type --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[tres]] > [[tres]] getSharedObject ( Class < [[tres]] > sharedType ) { return ( [[tres]] ) this . [[bogeyman]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 141 ---------------------------------------------
Gets the J2EE principal . --> [[[FAILED]]]

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object [[principal]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object [[critical]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[critical]] ) ; } return [[critical]] ; }
[[[[Nl]]]]: Return the J2EE user name .
[Succeeded / Failed / Skipped / Total] 97 / 44 / 1 / 142:  14%|█▍        | 142/1000 [03:53<23:32,  1.65s/it][Succeeded / Failed / Skipped / Total] 97 / 44 / 1 / 142:  14%|█▍        | 143/1000 [04:02<24:13,  1.70s/it][Succeeded / Failed / Skipped / Total] 97 / 45 / 1 / 143:  14%|█▍        | 143/1000 [04:02<24:13,  1.70s/it][Succeeded / Failed / Skipped / Total] 97 / 45 / 1 / 143:  14%|█▍        | 144/1000 [04:05<24:16,  1.70s/it][Succeeded / Failed / Skipped / Total] 98 / 45 / 1 / 144:  14%|█▍        | 144/1000 [04:05<24:16,  1.70s/it][Succeeded / Failed / Skipped / Total] 98 / 45 / 1 / 144:  14%|█▍        | 145/1000 [04:08<24:23,  1.71s/it][Succeeded / Failed / Skipped / Total] 99 / 45 / 1 / 145:  14%|█▍        | 145/1000 [04:08<24:23,  1.71s/it][Succeeded / Failed / Skipped / Total] 99 / 45 / 1 / 145:  15%|█▍        | 146/1000 [04:08<24:12,  1.70s/it][Succeeded / Failed / Skipped / Total] 100 / 45 / 1 / 146:  15%|█▍        | 146/1000 [04:08<24:12,  1.70s/it][Succeeded / Failed / Skipped / Total] 100 / 45 / 1 / 146:  15%|█▍        | 147/1000 [04:10<24:13,  1.70s/it]--------------------------------------------- Result 142 ---------------------------------------------
Invokes a method invocation . --> Makes the chain of affirm --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object [[result]] ; try { [[result]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[result]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[affirm]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object [[achievement]] ; try { [[achievement]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[achievement]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 143 ---------------------------------------------
Concatenate the given arrays . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] [[newArray]] = new byte [ length ] ; int [[destPos]] = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , [[newArray]] , [[destPos]] , array . length ) ; [[destPos]] += array . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] [[brushes]] = new byte [ length ] ; int [[spelled]] = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , [[brushes]] , [[spelled]] , array . length ) ; [[spelled]] += array . length ; } return [[brushes]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 144 ---------------------------------------------
Returns the role . --> Get the bribed --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[bribed]] ( String [[protagonist]] ) { Assert . isTrue ( ! [[protagonist]] . startsWith ( "ROLE_" ) , ( ) -> [[protagonist]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[protagonist]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 145 ---------------------------------------------
Adds the authority collection . --> Override meticulously --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[meticulously]] ( Collection < GrantedAuthority > [[attainment]] , Object [[precious]] ) { if ( [[precious]] == null ) { return ; } if ( [[precious]] instanceof Collection < ? > ) { [[meticulously]] ( [[attainment]] , ( Collection < ? > ) [[precious]] ) ; } else if ( [[precious]] instanceof Object [ ] ) { [[meticulously]] ( [[attainment]] , ( Object [ ] ) [[precious]] ) ; } else if ( [[precious]] instanceof String ) { [[meticulously]] ( [[attainment]] , ( String ) [[precious]] ) ; } else if ( [[precious]] instanceof GrantedAuthority ) { [[attainment]] . add ( ( GrantedAuthority ) [[precious]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[precious]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 146 ---------------------------------------------
Gets the roles associated with the specified attributes . --> half list --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[attributes]] ) { Collection < GrantedAuthority > [[c]] = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( [[c]] != null ) { gaList . addAll ( [[c]] ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[half]] ( Collection < String > [[trait]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[trait]] ) { Collection < GrantedAuthority > [[johnston]] = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( [[johnston]] != null ) { gaList . addAll ( [[johnston]] ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 147 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 100 / 46 / 1 / 147:  15%|█▍        | 147/1000 [04:10<24:13,  1.70s/it][Succeeded / Failed / Skipped / Total] 100 / 46 / 1 / 147:  15%|█▍        | 148/1000 [04:11<24:08,  1.70s/it][Succeeded / Failed / Skipped / Total] 101 / 46 / 1 / 148:  15%|█▍        | 148/1000 [04:11<24:08,  1.70s/it][Succeeded / Failed / Skipped / Total] 101 / 46 / 1 / 148:  15%|█▍        | 149/1000 [04:12<24:03,  1.70s/it][Succeeded / Failed / Skipped / Total] 102 / 46 / 1 / 149:  15%|█▍        | 149/1000 [04:12<24:03,  1.70s/it][Succeeded / Failed / Skipped / Total] 102 / 46 / 1 / 149:  15%|█▌        | 150/1000 [04:16<24:15,  1.71s/it][Succeeded / Failed / Skipped / Total] 103 / 46 / 1 / 150:  15%|█▌        | 150/1000 [04:16<24:15,  1.71s/it][Succeeded / Failed / Skipped / Total] 103 / 46 / 1 / 150:  15%|█▌        | 151/1000 [04:18<24:14,  1.71s/it][Succeeded / Failed / Skipped / Total] 104 / 46 / 1 / 151:  15%|█▌        | 151/1000 [04:18<24:14,  1.71s/it][Succeeded / Failed / Skipped / Total] 104 / 46 / 1 / 151:  15%|█▌        | 152/1000 [04:23<24:27,  1.73s/it][Succeeded / Failed / Skipped / Total] 105 / 46 / 1 / 152:  15%|█▌        | 152/1000 [04:23<24:27,  1.73s/it][Succeeded / Failed / Skipped / Total] 105 / 46 / 1 / 152:  15%|█▌        | 153/1000 [04:26<24:36,  1.74s/it][Succeeded / Failed / Skipped / Total] 106 / 46 / 1 / 153:  15%|█▌        | 153/1000 [04:26<24:36,  1.74s/it][Succeeded / Failed / Skipped / Total] 106 / 46 / 1 / 153:  15%|█▌        | 154/1000 [04:31<24:52,  1.76s/it][Succeeded / Failed / Skipped / Total] 107 / 46 / 1 / 154:  15%|█▌        | 154/1000 [04:31<24:52,  1.76s/it][Succeeded / Failed / Skipped / Total] 107 / 46 / 1 / 154:  16%|█▌        | 155/1000 [04:32<24:43,  1.76s/it]Build the Redirect URL for the request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer [[httpsPort]] = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( [[httpsPort]] != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( [[httpsPort]] . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[alds]] ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer [[overtakes]] = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( [[overtakes]] != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( [[overtakes]] . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 148 ---------------------------------------------
Returns array of roles that have any role . --> Get the corresponding courtesies --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int i = 0 ; i < [[roles]] . length ; i ++ ) { [[roles]] [ i ] = "ROLE_" + [[roles]] [ i ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[courtesies]] ( String ... [[idiosyncrasies]] ) { for ( int i = 0 ; i < [[idiosyncrasies]] . length ; i ++ ) { [[idiosyncrasies]] [ i ] = "ROLE_" + [[idiosyncrasies]] [ i ] ; } return [[idiosyncrasies]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 149 ---------------------------------------------
Attempts to determine the user in the AuthenticationCredentialsNotFoundException . --> Get the current Authentication --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[harmonium]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 150 ---------------------------------------------
Display the public key index --> Get a random id --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[angela]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 151 ---------------------------------------------
Get the springSecurity config . --> Can be overridden by subclasses . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[на]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 152 ---------------------------------------------
Sets the exit user url . --> aguilera by frederic --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[aguilera]] ( String [[frederic]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[frederic]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[frederic]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 153 ---------------------------------------------
Converts the authority into the authority list . --> Returns a collection of changed authority . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[convert]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[changed]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 154 ---------------------------------------------
Create a CSRF token . --> Get the CsrfToken --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[socko]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 155 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 107 / 47 / 1 / 155:  16%|█▌        | 155/1000 [04:32<24:43,  1.76s/it][Succeeded / Failed / Skipped / Total] 107 / 47 / 1 / 155:  16%|█▌        | 156/1000 [04:33<24:38,  1.75s/it][Succeeded / Failed / Skipped / Total] 107 / 48 / 1 / 156:  16%|█▌        | 156/1000 [04:33<24:38,  1.75s/it][Succeeded / Failed / Skipped / Total] 107 / 48 / 1 / 156:  16%|█▌        | 157/1000 [04:39<24:58,  1.78s/it][Succeeded / Failed / Skipped / Total] 108 / 48 / 1 / 157:  16%|█▌        | 157/1000 [04:39<24:58,  1.78s/it][Succeeded / Failed / Skipped / Total] 108 / 48 / 1 / 157:  16%|█▌        | 158/1000 [04:40<24:53,  1.77s/it][Succeeded / Failed / Skipped / Total] 108 / 49 / 1 / 158:  16%|█▌        | 158/1000 [04:40<24:53,  1.77s/it][Succeeded / Failed / Skipped / Total] 108 / 49 / 1 / 158:  16%|█▌        | 159/1000 [04:43<24:59,  1.78s/it][Succeeded / Failed / Skipped / Total] 108 / 50 / 1 / 159:  16%|█▌        | 159/1000 [04:43<24:59,  1.78s/it][Succeeded / Failed / Skipped / Total] 108 / 50 / 1 / 159:  16%|█▌        | 160/1000 [04:48<25:14,  1.80s/it]Adds a new login token . --> [[[FAILED]]]

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[persistentToken]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[persistentToken]] ) ; addCookie ( [[persistentToken]] , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[baboons]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[baboons]] ) ; addCookie ( [[baboons]] , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 156 ---------------------------------------------
processAutoLogin cookie --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 157 ---------------------------------------------
Displays a contact . --> region > Google --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl [[acl]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[acl]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[rae]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl [[ica]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[ica]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 158 ---------------------------------------------
Decodes a JWT token . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Jwt decode ( String [[token]] ) throws JwtException { JWT jwt = parse ( [[token]] ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[token]] , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt decode ( String [[acronym]] ) throws JwtException { JWT jwt = parse ( [[acronym]] ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[acronym]] , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 159 ---------------------------------------------
Check if the current user is a valid url check . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[currentUser]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , [[currentUser]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[aguilera]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[tarnished]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , [[tarnished]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 160 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 109 / 50 / 1 / 160:  16%|█▌        | 160/1000 [04:48<25:14,  1.80s/it][Succeeded / Failed / Skipped / Total] 109 / 50 / 1 / 160:  16%|█▌        | 161/1000 [04:51<25:18,  1.81s/it][Succeeded / Failed / Skipped / Total] 110 / 50 / 1 / 161:  16%|█▌        | 161/1000 [04:51<25:18,  1.81s/it][Succeeded / Failed / Skipped / Total] 110 / 50 / 1 / 161:  16%|█▌        | 162/1000 [04:56<25:35,  1.83s/it][Succeeded / Failed / Skipped / Total] 111 / 50 / 1 / 162:  16%|█▌        | 162/1000 [04:56<25:35,  1.83s/it][Succeeded / Failed / Skipped / Total] 111 / 51 / 1 / 163:  16%|█▋        | 163/1000 [04:56<25:23,  1.82s/it][Succeeded / Failed / Skipped / Total] 111 / 51 / 1 / 163:  16%|█▋        | 164/1000 [04:57<25:14,  1.81s/it][Succeeded / Failed / Skipped / Total] 112 / 51 / 1 / 164:  16%|█▋        | 164/1000 [04:57<25:14,  1.81s/it][Succeeded / Failed / Skipped / Total] 113 / 51 / 1 / 165:  16%|█▋        | 165/1000 [04:59<25:15,  1.81s/it][Succeeded / Failed / Skipped / Total] 113 / 51 / 1 / 165:  17%|█▋        | 166/1000 [05:00<25:07,  1.81s/it][Succeeded / Failed / Skipped / Total] 114 / 51 / 1 / 166:  17%|█▋        | 166/1000 [05:00<25:07,  1.81s/it]Delete a permission --> adder to contactManager --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String [[sid]] , @ RequestParam ( "permission" ) int mask ) { Contact [[contact]] = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( [[sid]] ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( [[contact]] , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[contact]] ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[adder]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String [[abed]] , @ RequestParam ( "permission" ) int mask ) { Contact [[dealings]] = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( [[abed]] ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( [[dealings]] , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[dealings]] ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 161 ---------------------------------------------
Returns the default role prefix . --> Helper method for ratted --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[ratted]] ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 162 ---------------------------------------------
Get UserDetailsResourceFactoryBean . --> Get UserResourceFactoryBean Method . --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource [[resource]] = new InMemoryResource ( users ) ; return fromResource ( [[resource]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource [[mend]] = new InMemoryResource ( users ) ; return fromResource ( [[mend]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 163 ---------------------------------------------
Evaluates access expression --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 164 ---------------------------------------------
Returns the value of the first attribute with the given name . --> Return null if not found --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[falcon]] ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 165 ---------------------------------------------
Encodes a string . --> Encode CharSequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[irons]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[irons]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 166 ---------------------------------------------
Get attribute values . --> Gets alphabets . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[name]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[alphabets]] ( String [[denominations]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[denominations]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute
[Succeeded / Failed / Skipped / Total] 114 / 52 / 1 / 167:  17%|█▋        | 167/1000 [05:02<25:07,  1.81s/it][Succeeded / Failed / Skipped / Total] 114 / 52 / 1 / 167:  17%|█▋        | 168/1000 [05:02<24:59,  1.80s/it][Succeeded / Failed / Skipped / Total] 115 / 52 / 1 / 168:  17%|█▋        | 168/1000 [05:02<24:59,  1.80s/it][Succeeded / Failed / Skipped / Total] 116 / 52 / 1 / 169:  17%|█▋        | 169/1000 [05:05<25:03,  1.81s/it][Succeeded / Failed / Skipped / Total] 116 / 52 / 1 / 169:  17%|█▋        | 170/1000 [05:09<25:10,  1.82s/it][Succeeded / Failed / Skipped / Total] 117 / 52 / 1 / 170:  17%|█▋        | 170/1000 [05:09<25:10,  1.82s/it][Succeeded / Failed / Skipped / Total] 118 / 52 / 1 / 171:  17%|█▋        | 171/1000 [05:10<25:03,  1.81s/it][Succeeded / Failed / Skipped / Total] 118 / 52 / 1 / 171:  17%|█▋        | 172/1000 [05:12<25:04,  1.82s/it]--------------------------------------------- Result 167 ---------------------------------------------
Add permission for contact --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "addPermission" , addPermission ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[model]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[diwali]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > [[designs]] = new HashMap <> ( ) ; [[designs]] . put ( "addPermission" , addPermission ) ; [[designs]] . put ( "recipients" , listRecipients ( ) ) ; [[designs]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[designs]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 168 ---------------------------------------------
Decodes the given bytes . --> Decodes given data --> Socre: 1.0

[[[[Adv]]]]: public static String decode ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String decode ( byte [ ] [[twine]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[twine]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 169 ---------------------------------------------
Add a permission to a user --> Generate a group --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[addPermission]] ( AddPermission [[addPermission]] , BindingResult [[result]] , ModelMap model ) { addPermissionValidator . validate ( [[addPermission]] , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid [[sid]] = new PrincipalSid ( [[addPermission]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[addPermission]] . getPermission ( ) ) ; try { contactManager . [[addPermission]] ( [[addPermission]] . getContact ( ) , [[sid]] , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[result]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[barstow]] ( AddPermission [[alde]] , BindingResult [[repercussions]] , ModelMap model ) { addPermissionValidator . validate ( [[barstow]] , [[repercussions]] ) ; if ( [[repercussions]] . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid [[akash]] = new PrincipalSid ( [[barstow]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[barstow]] . getPermission ( ) ) ; try { contactManager . [[alde]] ( [[barstow]] . getContact ( ) , [[akash]] , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[repercussions]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 170 ---------------------------------------------
Returns all the ConfigConfig attributes . --> Return a Collection of ConfigAttribute objects --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[allAttributes]] . addAll ( attributeList ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > [[virginia]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[virginia]] . addAll ( attributeList ) ; } return [[virginia]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 171 ---------------------------------------------
Adds a contact --> Adds aContact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact [[form]] , BindingResult result ) { validator . validate ( [[form]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact [[constitute]] , BindingResult result ) { validator . validate ( [[constitute]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[liaison]] = new Contact ( [[constitute]] . getName ( ) , [[constitute]] . getEmail ( ) ) ; contactManager . create ( [[liaison]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 172 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 118 / 53 / 1 / 172:  17%|█▋        | 172/1000 [05:12<25:04,  1.82s/it][Succeeded / Failed / Skipped / Total] 119 / 53 / 1 / 173:  17%|█▋        | 173/1000 [05:15<25:07,  1.82s/it][Succeeded / Failed / Skipped / Total] 119 / 53 / 1 / 173:  17%|█▋        | 174/1000 [05:19<25:18,  1.84s/it][Succeeded / Failed / Skipped / Total] 120 / 53 / 1 / 174:  17%|█▋        | 174/1000 [05:19<25:18,  1.84s/it][Succeeded / Failed / Skipped / Total] 121 / 53 / 1 / 175:  18%|█▊        | 175/1000 [05:21<25:14,  1.84s/it][Succeeded / Failed / Skipped / Total] 121 / 53 / 1 / 175:  18%|█▊        | 176/1000 [05:23<25:16,  1.84s/it][Succeeded / Failed / Skipped / Total] 121 / 54 / 1 / 176:  18%|█▊        | 176/1000 [05:23<25:16,  1.84s/it][Succeeded / Failed / Skipped / Total] 121 / 55 / 1 / 177:  18%|█▊        | 177/1000 [05:27<25:24,  1.85s/it][Succeeded / Failed / Skipped / Total] 121 / 55 / 1 / 177:  18%|█▊        | 178/1000 [05:30<25:24,  1.85s/it][Succeeded / Failed / Skipped / Total] 122 / 55 / 1 / 178:  18%|█▊        | 178/1000 [05:30<25:24,  1.85s/it][Succeeded / Failed / Skipped / Total] 122 / 56 / 1 / 179:  18%|█▊        | 179/1000 [05:36<25:43,  1.88s/it][Succeeded / Failed / Skipped / Total] 122 / 56 / 1 / 179:  18%|█▊        | 180/1000 [05:38<25:41,  1.88s/it]Attempt to switch to a user . --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[horses]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 173 ---------------------------------------------
Returns a random contact . --> Get the random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact [[getRandomContact]] ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact [[catheter]] ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 174 ---------------------------------------------
Handles a bind exception . --> Handles exceptions --> Socre: 1.0

[[[[Adv]]]]: protected void handleBindException ( String [[userDn]] , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[userDn]] + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void handleBindException ( String [[deutsche]] , String username , Throwable [[provoked]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[deutsche]] + ": " + [[provoked]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 175 ---------------------------------------------
Gets any request . --> Generates a new Cix --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[elixir]] ( ) { Assert . state ( ! this . [[boardinghouse]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[boardinghouse]] = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 176 ---------------------------------------------
Finds the attributes for the specified method . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method [[method]] , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method [[form]] , Class < ? > [[rubdown]] ) { if ( [[rubdown]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[form]] , [[rubdown]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 177 ---------------------------------------------
Adds a secure method . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod method , List < ConfigAttribute > attr ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + attr + "]" ) ; } this . methodMap . put ( method , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[ikari]] ( RegisteredMethod method , List < ConfigAttribute > attr ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + attr + "]" ) ; } this . methodMap . put ( method , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 178 ---------------------------------------------
Checks if a method name is match . --> F743 - 7 --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[felix]] ( String [[spelled]] , String [[howell]] ) { return ( [[howell]] . endsWith ( "*" ) && [[spelled]] . startsWith ( [[howell]] . substring ( 0 , [[howell]] . length ( ) - 1 ) ) ) || ( [[howell]] . startsWith ( "*" ) && [[spelled]] . endsWith ( [[howell]] . substring ( 1 , [[howell]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 179 ---------------------------------------------
Returns the Field object for the given field name . --> [[[FAILED]]]

[[[[Adv]]]]: public static Field getField ( Class < ? > [[clazz]] , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field getField ( Class < ? > [[babbling]] , String [[dwelled]] ) throws IllegalStateException { Assert . notNull ( [[babbling]] , "Class required" ) ; Assert . hasText ( [[dwelled]] , "Field name required" ) ; try { return [[babbling]] . getDeclaredField ( [[dwelled]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 180 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 123 / 56 / 1 / 180:  18%|█▊        | 180/1000 [05:38<25:41,  1.88s/it][Succeeded / Failed / Skipped / Total] 124 / 56 / 1 / 181:  18%|█▊        | 181/1000 [05:38<25:33,  1.87s/it][Succeeded / Failed / Skipped / Total] 124 / 56 / 1 / 181:  18%|█▊        | 182/1000 [05:46<25:55,  1.90s/it][Succeeded / Failed / Skipped / Total] 124 / 57 / 1 / 182:  18%|█▊        | 182/1000 [05:46<25:55,  1.90s/it][Succeeded / Failed / Skipped / Total] 125 / 57 / 1 / 183:  18%|█▊        | 183/1000 [05:47<25:52,  1.90s/it][Succeeded / Failed / Skipped / Total] 125 / 57 / 1 / 183:  18%|█▊        | 184/1000 [05:51<26:00,  1.91s/it][Succeeded / Failed / Skipped / Total] 126 / 57 / 1 / 184:  18%|█▊        | 184/1000 [05:51<26:00,  1.91s/it][Succeeded / Failed / Skipped / Total] 126 / 58 / 1 / 185:  18%|█▊        | 185/1000 [05:52<25:51,  1.90s/it][Succeeded / Failed / Skipped / Total] 126 / 58 / 1 / 185:  19%|█▊        | 186/1000 [05:56<26:01,  1.92s/it]Clear authentication attributes . --> dishonest --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( "[[False]]" != "[[False]]" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[dinesh]] ( HttpServletRequest [[applications]] ) { HttpSession session = [[applications]] . getSession ( "[[Dishonest]]" != "[[Dishonest]]" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 181 ---------------------------------------------
Checks the filter stack . --> Adds new filters . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[ange]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 182 ---------------------------------------------
Gets the SHA prefix . --> [[[FAILED]]]

[[[[Adv]]]]: private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = encPass . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int [[according]] = encPass . lastIndexOf ( ' ' ) ; if ( [[according]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , [[according]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 183 ---------------------------------------------
Register access manager . --> Registers a Bean definition --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder [[accessMgrBuilder]] = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } [[accessMgrBuilder]] . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = [[accessMgrBuilder]] . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder [[aguilera]] = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } [[aguilera]] . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = [[aguilera]] . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 184 ---------------------------------------------
Create redirect url string . --> Generates a ability --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String [[serviceUrl]] ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , [[serviceUrl]] , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[ability]] ( final String [[advised]] ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , [[advised]] , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 185 ---------------------------------------------
Create service url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { return CommonUtils . constructServiceUrl ( null , [[response]] , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[alfons]] ( final HttpServletRequest request , final HttpServletResponse [[commentaries]] ) { return CommonUtils . constructServiceUrl ( null , [[commentaries]] , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 186 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 126 / 59 / 1 / 186:  19%|█▊        | 186/1000 [05:56<26:01,  1.92s/it][Succeeded / Failed / Skipped / Total] 126 / 60 / 1 / 187:  19%|█▊        | 187/1000 [05:59<26:04,  1.92s/it][Succeeded / Failed / Skipped / Total] 126 / 60 / 1 / 187:  19%|█▉        | 188/1000 [06:00<25:55,  1.92s/it][Succeeded / Failed / Skipped / Total] 127 / 60 / 1 / 188:  19%|█▉        | 188/1000 [06:00<25:55,  1.92s/it][Succeeded / Failed / Skipped / Total] 127 / 61 / 1 / 189:  19%|█▉        | 189/1000 [06:07<26:16,  1.94s/it][Succeeded / Failed / Skipped / Total] 127 / 61 / 1 / 189:  19%|█▉        | 190/1000 [06:08<26:11,  1.94s/it][Succeeded / Failed / Skipped / Total] 128 / 61 / 1 / 190:  19%|█▉        | 190/1000 [06:08<26:11,  1.94s/it][Succeeded / Failed / Skipped / Total] 129 / 61 / 1 / 191:  19%|█▉        | 191/1000 [06:15<26:31,  1.97s/it][Succeeded / Failed / Skipped / Total] 129 / 61 / 1 / 191:  19%|█▉        | 192/1000 [06:16<26:22,  1.96s/it][Succeeded / Failed / Skipped / Total] 129 / 62 / 1 / 192:  19%|█▉        | 192/1000 [06:16<26:22,  1.96s/it]Send an access Denied . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest request , HttpServletResponse [[response]] , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[response]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[initiating]] ( HttpServletRequest request , HttpServletResponse [[commentaries]] , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[commentaries]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 187 ---------------------------------------------
Gets the registered types . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . extractorMap . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[bonfires]] ( ) { Set < Class < ? extends Throwable > > [[arbitrarily]] = this . extractorMap . keySet ( ) ; return [[arbitrarily]] . toArray ( new Class [ [[arbitrarily]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 188 ---------------------------------------------
Returns true if the expected byte array matches the expected byte array . --> Returns true if the businesslike matches the expected array --> Socre: 1.0

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] [[actual]] ) { if ( expected . length != [[actual]] . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ [[actual]] [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] [[businesslike]] ) { if ( expected . length != [[businesslike]] . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ [[businesslike]] [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 189 ---------------------------------------------
Lookup parameter names . --> [[[FAILED]]]

[[[[Adv]]]]: private < T [[extends]] AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[parameterAnnotations]] = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = [[parameterAnnotations]] . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = [[parameterAnnotations]] [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T [[extension]] AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[albino]] = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = [[albino]] . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = [[albino]] [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 190 ---------------------------------------------
Sets the default failure URL . --> agrippa --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[agrippa]] ( String [[jasmin]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[jasmin]] ) , ( ) -> "'" + [[jasmin]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[jasmin]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 191 ---------------------------------------------
Returns the identifier for the given result set . --> Convert an impersonate object to a ResultSet --> Socre: 1.0

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[identifier]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[impersonate]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[impersonate]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[impersonate]] = convertFromStringTo ( ( String ) [[impersonate]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 192 ---------------------------------------------
Extracts the cause of the given throwable . --> [[[FAILED]]]

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[hamper]] ( Throwable [[bonfires]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( [[bonfires]] ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( [[bonfires]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 193 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 63 / 1 / 193:  19%|█▉        | 193/1000 [06:17<26:20,  1.96s/it][Succeeded / Failed / Skipped / Total] 129 / 63 / 1 / 193:  19%|█▉        | 194/1000 [06:21<26:27,  1.97s/it][Succeeded / Failed / Skipped / Total] 129 / 64 / 1 / 194:  19%|█▉        | 194/1000 [06:21<26:27,  1.97s/it][Succeeded / Failed / Skipped / Total] 129 / 65 / 1 / 195:  20%|█▉        | 195/1000 [06:24<26:28,  1.97s/it][Succeeded / Failed / Skipped / Total] 129 / 65 / 1 / 195:  20%|█▉        | 196/1000 [06:27<26:31,  1.98s/it][Succeeded / Failed / Skipped / Total] 130 / 65 / 1 / 196:  20%|█▉        | 196/1000 [06:27<26:31,  1.98s/it][Succeeded / Failed / Skipped / Total] 131 / 65 / 1 / 197:  20%|█▉        | 197/1000 [06:32<26:39,  1.99s/it][Succeeded / Failed / Skipped / Total] 131 / 65 / 1 / 197:  20%|█▉        | 198/1000 [06:32<26:30,  1.98s/it][Succeeded / Failed / Skipped / Total] 131 / 66 / 1 / 198:  20%|█▉        | 198/1000 [06:32<26:30,  1.98s/it][Succeeded / Failed / Skipped / Total] 132 / 66 / 1 / 199:  20%|█▉        | 199/1000 [06:33<26:23,  1.98s/it][Succeeded / Failed / Skipped / Total] 132 / 66 / 1 / 199:  20%|██        | 200/1000 [06:36<26:27,  1.98s/it]Sets the resolvedHidden inputs . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[wicks]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 194 ---------------------------------------------
Gets all the authority list to set . --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[snook]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 195 ---------------------------------------------
Create a list of OpenID attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[entry]] : idToAttributes . entrySet ( ) ) { if ( [[entry]] . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return [[entry]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[access]] : idToAttributes . entrySet ( ) ) { if ( [[access]] . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return [[access]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 196 ---------------------------------------------
Builds the request URL . --> Concatenates bonfires and requestURI --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String [[servletPath]] , String requestURI , String [[contextPath]] , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[servletPath]] != null ) { url . append ( [[servletPath]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( [[contextPath]] . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[albino]] ( String [[bonfires]] , String requestURI , String [[bat]] , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[bonfires]] != null ) { url . append ( [[bonfires]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( [[bat]] . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 197 ---------------------------------------------
Create the object identity . --> F743 --> Socre: 1.0

[[[[Adv]]]]: protected void createObjectIdentity ( ObjectIdentity object , Sid [[owner]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[owner]] , "[[True]]" == "[[True]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[True]]" == "[[True]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void createObjectIdentity ( ObjectIdentity object , Sid [[wearer]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[wearer]] , "[[Real]]" == "[[Real]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[Real]]" == "[[Real]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 198 ---------------------------------------------
Checks if the given URL is absolute . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "False" != "False" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[civilisation]] ( String [[finder]] ) { if ( [[finder]] == null ) { return "False" != "False" ; } final Pattern [[TANGANYIKA]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[TANGANYIKA]] . matcher ( [[finder]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 199 ---------------------------------------------
Returns any active server webExchange . --> Gets the matcherMatcher airspace . --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[airspace]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 200 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 133 / 66 / 1 / 200:  20%|██        | 200/1000 [06:36<26:27,  1.98s/it][Succeeded / Failed / Skipped / Total] 134 / 66 / 1 / 201:  20%|██        | 201/1000 [06:41<26:34,  2.00s/it][Succeeded / Failed / Skipped / Total] 134 / 66 / 1 / 201:  20%|██        | 202/1000 [06:44<26:39,  2.00s/it][Succeeded / Failed / Skipped / Total] 135 / 66 / 1 / 202:  20%|██        | 202/1000 [06:44<26:39,  2.00s/it][Succeeded / Failed / Skipped / Total] 136 / 66 / 1 / 203:  20%|██        | 203/1000 [06:48<26:44,  2.01s/it][Succeeded / Failed / Skipped / Total] 136 / 66 / 1 / 203:  20%|██        | 204/1000 [06:49<26:35,  2.00s/it][Succeeded / Failed / Skipped / Total] 137 / 66 / 1 / 204:  20%|██        | 204/1000 [06:49<26:35,  2.01s/it][Succeeded / Failed / Skipped / Total] 138 / 66 / 1 / 205:  20%|██        | 205/1000 [06:57<27:00,  2.04s/it][Succeeded / Failed / Skipped / Total] 138 / 66 / 1 / 205:  21%|██        | 206/1000 [06:59<26:57,  2.04s/it][Succeeded / Failed / Skipped / Total] 138 / 67 / 1 / 206:  21%|██        | 206/1000 [06:59<26:57,  2.04s/it][Succeeded / Failed / Skipped / Total] 138 / 67 / 1 / 206:  21%|██        | 207/1000 [07:00<26:49,  2.03s/it]Returns textEncryptor with the given password . --> Get the beatles --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[beatles]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 201 ---------------------------------------------
Create aEncryptor with the given salt . --> Create new TextEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor queryableText ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[password]] . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor queryableText ( CharSequence [[asterisk]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[asterisk]] . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 202 ---------------------------------------------
Determine target url . --> Returns thelds . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[alds]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[alds]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 203 ---------------------------------------------
Returns a text encryptor text . --> Liefert ein --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence [[cypher]] , CharSequence [[acidity]] ) { return new HexEncodingTextEncryptor ( standard ( [[cypher]] , [[acidity]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 204 ---------------------------------------------
Create a path sequence for a given method --> path inspector --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod [[method]] , String ... patterns ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod [[pleas]] , String ... patterns ) { List < ServerWebExchangeMatcher > [[depressed]] = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { [[depressed]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , [[pleas]] ) ) ; } return new OrServerWebExchangeMatcher ( [[depressed]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 205 ---------------------------------------------
Build a userDn . --> Builds aDn --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[username]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[username]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[clients]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[clients]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 206 ---------------------------------------------
Create the list of entries . --> [[[FAILED]]]

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry [[entry_]] = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( [[entry_]] instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) [[entry_]] ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry [[agitate]] = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( [[agitate]] instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) [[agitate]] ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 207 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 139 / 67 / 1 / 207:  21%|██        | 207/1000 [07:00<26:49,  2.03s/it][Succeeded / Failed / Skipped / Total] 139 / 67 / 1 / 207:  21%|██        | 208/1000 [07:01<26:43,  2.02s/it][Succeeded / Failed / Skipped / Total] 140 / 67 / 1 / 208:  21%|██        | 208/1000 [07:01<26:43,  2.02s/it][Succeeded / Failed / Skipped / Total] 140 / 67 / 1 / 208:  21%|██        | 209/1000 [07:01<26:35,  2.02s/it][Succeeded / Failed / Skipped / Total] 141 / 67 / 1 / 209:  21%|██        | 209/1000 [07:01<26:35,  2.02s/it][Succeeded / Failed / Skipped / Total] 141 / 67 / 1 / 209:  21%|██        | 210/1000 [07:03<26:35,  2.02s/it][Succeeded / Failed / Skipped / Total] 141 / 68 / 1 / 210:  21%|██        | 210/1000 [07:03<26:35,  2.02s/it][Succeeded / Failed / Skipped / Total] 141 / 68 / 1 / 210:  21%|██        | 211/1000 [07:06<26:36,  2.02s/it][Succeeded / Failed / Skipped / Total] 142 / 68 / 1 / 211:  21%|██        | 211/1000 [07:06<26:36,  2.02s/it][Succeeded / Failed / Skipped / Total] 142 / 68 / 1 / 211:  21%|██        | 212/1000 [07:08<26:31,  2.02s/it]Sets the target url parameter . --> Fossilized --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[fossilized]] ( String [[advised]] ) { if ( [[advised]] != null ) { Assert . hasText ( [[advised]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[advised]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 208 ---------------------------------------------
Update the ACL . --> F743 - 3 --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl acl ) { Long [[parentId]] = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; [[parentId]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[updateObjectIdentity]] , [[parentId]] , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[macbeth]] ( MutableAcl acl ) { Long [[alde]] = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; [[alde]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[macbeth]] , [[alde]] , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 209 ---------------------------------------------
Save the request . --> Do not call this method --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest [[savedRequest]] = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[retaken]] ( HttpServletRequest [[petitions]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[petitions]] ) ) { DefaultSavedRequest [[lamba]] = new DefaultSavedRequest ( [[petitions]] , portResolver ) ; if ( createSessionAllowed || [[petitions]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 210 ---------------------------------------------
Gets the target URL . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[dialectics]] ( HttpServletRequest request , HttpServletResponse [[respond]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 211 ---------------------------------------------
Creates the shared object . --> Create a new dashwood map . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[dashwood]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 212 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 142 / 69 / 1 / 212:  21%|██        | 212/1000 [07:08<26:31,  2.02s/it][Succeeded / Failed / Skipped / Total] 142 / 69 / 1 / 212:  21%|██▏       | 213/1000 [07:09<26:26,  2.02s/it][Succeeded / Failed / Skipped / Total] 143 / 69 / 1 / 213:  21%|██▏       | 213/1000 [07:09<26:26,  2.02s/it][Succeeded / Failed / Skipped / Total] 143 / 69 / 1 / 213:  21%|██▏       | 214/1000 [07:10<26:22,  2.01s/it][Succeeded / Failed / Skipped / Total] 144 / 69 / 1 / 214:  21%|██▏       | 214/1000 [07:10<26:22,  2.01s/it][Succeeded / Failed / Skipped / Total] 144 / 69 / 1 / 214:  22%|██▏       | 215/1000 [07:12<26:20,  2.01s/it][Succeeded / Failed / Skipped / Total] 144 / 70 / 1 / 215:  22%|██▏       | 215/1000 [07:12<26:20,  2.01s/it][Succeeded / Failed / Skipped / Total] 144 / 70 / 1 / 215:  22%|██▏       | 216/1000 [07:19<26:33,  2.03s/it][Succeeded / Failed / Skipped / Total] 145 / 70 / 1 / 216:  22%|██▏       | 216/1000 [07:19<26:33,  2.03s/it][Succeeded / Failed / Skipped / Total] 145 / 70 / 1 / 216:  22%|██▏       | 217/1000 [07:22<26:35,  2.04s/it][Succeeded / Failed / Skipped / Total] 146 / 70 / 1 / 217:  22%|██▏       | 217/1000 [07:22<26:35,  2.04s/it][Succeeded / Failed / Skipped / Total] 146 / 70 / 1 / 217:  22%|██▏       | 218/1000 [07:22<26:28,  2.03s/it]Write the headers . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[wiley]] ( HttpServletRequest request , HttpServletResponse [[address]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! [[address]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[address]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! [[address]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[address]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { [[address]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 213 ---------------------------------------------
Internal parse date . --> parse a string to a Long --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[trembles]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 214 ---------------------------------------------
Sets the login configUrl . --> F743 - Fa3 - F --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String [[prefix]] = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( [[prefix]] + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = [[prefix]] + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String [[acronyms]] = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( [[acronyms]] + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = [[acronyms]] + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 215 ---------------------------------------------
Returns the current date . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[certify]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 216 ---------------------------------------------
Build the group name . --> This method initializes groupRoleAttributeName --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[dino]] ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 217 ---------------------------------------------
Retrieves the parent directory . --> Gets the codeword value . --> Socre: 1.0

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long [[id]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[id]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int [[rowNumber]] ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long [[codeword]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[codeword]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int [[beeline]] ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 218 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 147 / 70 / 1 / 218:  22%|██▏       | 218/1000 [07:22<26:28,  2.03s/it][Succeeded / Failed / Skipped / Total] 147 / 70 / 1 / 218:  22%|██▏       | 219/1000 [07:24<26:23,  2.03s/it][Succeeded / Failed / Skipped / Total] 148 / 70 / 1 / 219:  22%|██▏       | 219/1000 [07:24<26:23,  2.03s/it][Succeeded / Failed / Skipped / Total] 148 / 70 / 1 / 219:  22%|██▏       | 220/1000 [07:24<26:15,  2.02s/it][Succeeded / Failed / Skipped / Total] 149 / 70 / 1 / 220:  22%|██▏       | 220/1000 [07:24<26:15,  2.02s/it][Succeeded / Failed / Skipped / Total] 149 / 70 / 1 / 220:  22%|██▏       | 221/1000 [07:26<26:12,  2.02s/it][Succeeded / Failed / Skipped / Total] 150 / 70 / 1 / 221:  22%|██▏       | 221/1000 [07:26<26:12,  2.02s/it][Succeeded / Failed / Skipped / Total] 150 / 70 / 1 / 221:  22%|██▏       | 222/1000 [07:28<26:10,  2.02s/it][Succeeded / Failed / Skipped / Total] 151 / 70 / 1 / 222:  22%|██▏       | 222/1000 [07:28<26:10,  2.02s/it][Succeeded / Failed / Skipped / Total] 151 / 70 / 1 / 222:  22%|██▏       | 223/1000 [07:30<26:10,  2.02s/it][Succeeded / Failed / Skipped / Total] 152 / 70 / 1 / 223:  22%|██▏       | 223/1000 [07:30<26:10,  2.02s/it][Succeeded / Failed / Skipped / Total] 152 / 70 / 1 / 223:  22%|██▏       | 224/1000 [07:33<26:11,  2.02s/it][Succeeded / Failed / Skipped / Total] 153 / 70 / 1 / 224:  22%|██▏       | 224/1000 [07:33<26:11,  2.02s/it][Succeeded / Failed / Skipped / Total] 153 / 70 / 1 / 224:  22%|██▎       | 225/1000 [07:38<26:19,  2.04s/it][Succeeded / Failed / Skipped / Total] 154 / 70 / 1 / 225:  22%|██▎       | 225/1000 [07:38<26:19,  2.04s/it][Succeeded / Failed / Skipped / Total] 154 / 70 / 1 / 225:  23%|██▎       | 226/1000 [07:42<26:23,  2.05s/it][Succeeded / Failed / Skipped / Total] 155 / 70 / 1 / 226:  23%|██▎       | 226/1000 [07:42<26:23,  2.05s/it][Succeeded / Failed / Skipped / Total] 155 / 70 / 1 / 226:  23%|██▎       | 227/1000 [07:44<26:22,  2.05s/it]Gets the security name . --> Gets redcap --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String userSecurityName = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[redcap]] ( final Subject [[issuance]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[issuance]] ) ; } String userSecurityName = null ; if ( [[issuance]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 219 ---------------------------------------------
Get the timeSphereGroups . --> Convenience method to build a description of a String --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String securityName ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[newport]] ( final String securityName ) { Context [[ee]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 220 ---------------------------------------------
Method allowableSessionsExceeded Method . --> F743 - 3 --> Socre: 1.0

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[hilarity]] ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 221 ---------------------------------------------
Sets the authentication details for this request . --> Fossilized Fossilized --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest [[request]] , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[fossilized]] ( HttpServletRequest [[prayed]] , UsernamePasswordAuthenticationToken [[halliday]] ) { [[halliday]] . setDetails ( authenticationDetailsSource . buildDetails ( [[prayed]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 222 ---------------------------------------------
Copy authentication token . --> soybeans --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[soybeans]] ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 223 ---------------------------------------------
Gets the filters for the specified URL . --> Sends a taro request --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String url ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[taro]] ( String url ) { return [[taro]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 224 ---------------------------------------------
Updates the cache . --> clear the obscures associated with key --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[acquisitions]] ( HashMap [[obscures]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[obscures]] . size ( ) > 1000 ) { [[obscures]] . clear ( ) ; } [[obscures]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 225 ---------------------------------------------
Sets the filter list . --> Set the scrubbers filter --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > filters ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[scrubbers]] ( List < Filter > filters ) { Validate . notNull ( [[scrubbers]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[scrubbers]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 226 ---------------------------------------------
Get the full full full baseDn . --> Create an DistinguishedName object --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( baseDn ) ) { return [[dn]] ; } baseDn . append ( [[dn]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[detonates]] ( DistinguishedName [[dt]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dt]] . contains ( baseDn ) ) { return [[dt]] ; } baseDn . append ( [[dt]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 227 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 155 / 71 / 1 / 227:  23%|██▎       | 227/1000 [07:44<26:22,  2.05s/it][Succeeded / Failed / Skipped / Total] 155 / 71 / 1 / 227:  23%|██▎       | 228/1000 [07:46<26:20,  2.05s/it][Succeeded / Failed / Skipped / Total] 155 / 72 / 1 / 228:  23%|██▎       | 228/1000 [07:46<26:20,  2.05s/it][Succeeded / Failed / Skipped / Total] 155 / 72 / 1 / 228:  23%|██▎       | 229/1000 [07:49<26:20,  2.05s/it][Succeeded / Failed / Skipped / Total] 156 / 72 / 1 / 229:  23%|██▎       | 229/1000 [07:49<26:20,  2.05s/it][Succeeded / Failed / Skipped / Total] 156 / 72 / 1 / 229:  23%|██▎       | 230/1000 [07:53<26:25,  2.06s/it][Succeeded / Failed / Skipped / Total] 157 / 72 / 1 / 230:  23%|██▎       | 230/1000 [07:53<26:25,  2.06s/it][Succeeded / Failed / Skipped / Total] 157 / 72 / 1 / 230:  23%|██▎       | 231/1000 [07:56<26:26,  2.06s/it][Succeeded / Failed / Skipped / Total] 158 / 72 / 1 / 231:  23%|██▎       | 231/1000 [07:56<26:26,  2.06s/it][Succeeded / Failed / Skipped / Total] 158 / 72 / 1 / 231:  23%|██▎       | 232/1000 [07:57<26:22,  2.06s/it][Succeeded / Failed / Skipped / Total] 158 / 73 / 1 / 232:  23%|██▎       | 232/1000 [07:57<26:22,  2.06s/it][Succeeded / Failed / Skipped / Total] 158 / 73 / 1 / 232:  23%|██▎       | 233/1000 [07:58<26:15,  2.05s/it]Gets the filters . --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[request]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[modern]] ( HttpServletRequest [[claim]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[claim]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 228 ---------------------------------------------
Get the ApplicationContext . --> [[[FAILED]]]

[[[[Adv]]]]: protected ApplicationContext getContext ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext getContext ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 229 ---------------------------------------------
Sets the session attributes . --> used by test --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . [[sessionAttributes]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[spanning]] ( Map < String , Object > [[на]] ) { notNull ( [[на]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[на]] , this . [[applause]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 230 ---------------------------------------------
Create an NTLMAuth scheme . --> Construct the NTLMAuthScheme with the given parameters --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setWorkstation ( workstation ) ; [[scheme]] . setDomain ( domain ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme [[contour]] = new NTLMAuthScheme ( ) ; [[contour]] . setUserName ( userName ) ; [[contour]] . setPassword ( password ) ; [[contour]] . setWorkstation ( workstation ) ; [[contour]] . setDomain ( domain ) ; return [[contour]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 231 ---------------------------------------------
Print response options . --> Gets copier . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[copier]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 232 ---------------------------------------------
Adds additional filters . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[filter]] ( Filter [[cleanliness]] , Filter ... [[boules]] ) { Validate . notNull ( [[cleanliness]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[cleanliness]] ) ; if ( [[boules]] != null ) { Collections . addAll ( RestAssured . filters , [[boules]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 233 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 158 / 74 / 1 / 233:  23%|██▎       | 233/1000 [07:58<26:15,  2.05s/it][Succeeded / Failed / Skipped / Total] 158 / 74 / 1 / 233:  23%|██▎       | 234/1000 [08:00<26:14,  2.05s/it][Succeeded / Failed / Skipped / Total] 158 / 75 / 1 / 234:  23%|██▎       | 234/1000 [08:00<26:14,  2.05s/it][Succeeded / Failed / Skipped / Total] 159 / 75 / 1 / 235:  24%|██▎       | 235/1000 [08:00<26:05,  2.05s/it][Succeeded / Failed / Skipped / Total] 159 / 75 / 1 / 235:  24%|██▎       | 236/1000 [08:01<25:57,  2.04s/it][Succeeded / Failed / Skipped / Total] 160 / 75 / 1 / 236:  24%|██▎       | 236/1000 [08:01<25:57,  2.04s/it][Succeeded / Failed / Skipped / Total] 161 / 75 / 1 / 237:  24%|██▎       | 237/1000 [08:04<25:59,  2.04s/it][Succeeded / Failed / Skipped / Total] 161 / 75 / 1 / 237:  24%|██▍       | 238/1000 [08:04<25:52,  2.04s/it][Succeeded / Failed / Skipped / Total] 162 / 75 / 1 / 238:  24%|██▍       | 238/1000 [08:04<25:52,  2.04s/it]Change the user s password . --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String [[oldPassword]] , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[oldPassword]] , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , [[oldPassword]] , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String [[novelties]] , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[novelties]] , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , [[novelties]] , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 234 ---------------------------------------------
proxy a URI --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[overridden]] ( URI [[gagarin]] ) { if ( [[gagarin]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[overridden]] ( new ProxySpecification ( [[gagarin]] . getHost ( ) , [[gagarin]] . getPort ( ) , [[gagarin]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 235 ---------------------------------------------
Performs basic . --> Import a AuthenticationScheme --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( [[userName]] ) ; preemptiveBasicAuthScheme . setPassword ( [[password]] ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[bases]] ( String [[guests]] , String [[encryption]] ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( [[guests]] ) ; preemptiveBasicAuthScheme . setPassword ( [[encryption]] ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 236 ---------------------------------------------
Redirect to RestAssured config . --> This method initializes RestAssuredConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[tweek]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 237 ---------------------------------------------
Creates the basic authentication scheme for the user and password . --> Return an AuthenticationScheme for the given consumers --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme basic ( String [[userName]] , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme basic ( String [[consumers]] , String [[numeric]] ) { final BasicAuthScheme [[diets]] = new BasicAuthScheme ( ) ; [[diets]] . setUserName ( [[consumers]] ) ; [[diets]] . setPassword ( [[numeric]] ) ; return [[diets]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 238 ---------------------------------------------
Build the default charset . --> Creates a new Encoder config object . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[ability]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 239 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 163 / 75 / 1 / 239:  24%|██▍       | 239/1000 [08:06<25:49,  2.04s/it][Succeeded / Failed / Skipped / Total] 163 / 75 / 1 / 239:  24%|██▍       | 240/1000 [08:07<25:43,  2.03s/it][Succeeded / Failed / Skipped / Total] 164 / 75 / 1 / 240:  24%|██▍       | 240/1000 [08:07<25:43,  2.03s/it][Succeeded / Failed / Skipped / Total] 165 / 75 / 1 / 241:  24%|██▍       | 241/1000 [08:10<25:43,  2.03s/it][Succeeded / Failed / Skipped / Total] 165 / 75 / 1 / 241:  24%|██▍       | 242/1000 [08:10<25:35,  2.03s/it][Succeeded / Failed / Skipped / Total] 166 / 75 / 1 / 242:  24%|██▍       | 242/1000 [08:10<25:35,  2.03s/it][Succeeded / Failed / Skipped / Total] 167 / 75 / 1 / 243:  24%|██▍       | 243/1000 [08:11<25:31,  2.02s/it][Succeeded / Failed / Skipped / Total] 167 / 75 / 1 / 243:  24%|██▍       | 244/1000 [08:13<25:29,  2.02s/it][Succeeded / Failed / Skipped / Total] 168 / 75 / 1 / 244:  24%|██▍       | 244/1000 [08:13<25:29,  2.02s/it][Succeeded / Failed / Skipped / Total] 169 / 75 / 1 / 245:  24%|██▍       | 245/1000 [08:14<25:22,  2.02s/it][Succeeded / Failed / Skipped / Total] 169 / 75 / 1 / 245:  25%|██▍       | 246/1000 [08:16<25:20,  2.02s/it][Succeeded / Failed / Skipped / Total] 170 / 75 / 1 / 246:  25%|██▍       | 246/1000 [08:16<25:20,  2.02s/it]Returns the default ObjectMapper --> Returns a new ObjectMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[jasmin]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[jasmin]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 240 ---------------------------------------------
Gets the object configuration object . --> Provide the standard ObjectMapper --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[helplessly]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[helplessly]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 241 ---------------------------------------------
Create RestAssured mock config . --> Create an instance of RestAssuredMock mechanism --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[logConfig]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[unpacked]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 242 ---------------------------------------------
Gets the JMX config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig sessionConfig ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[plows]] ( SessionConfig sessionConfig ) { notNull ( [[plows]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[plows]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 243 ---------------------------------------------
Get an instance of RestAssuredMock falls config . --> Create an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig [[bestseller]] ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 244 ---------------------------------------------
Create a RestAssuredMock falls config . --> Get an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig jsonConfig ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[aspire]] ( JsonConfig jsonConfig ) { notNull ( [[aspire]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[aspire]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 245 ---------------------------------------------
Create an instance of RestAssuredMock . --> Create an instance of RestAssuredMockMvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig xmlConfig ( XmlConfig [[xmlConfig]] ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig xmlConfig ( XmlConfig [[bestseller]] ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 246 ---------------------------------------------
Gets the mock config . --> Returns a copy of this appologize . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig encoderConfig ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[appologize]] ( EncoderConfig encoderConfig ) { notNull ( [[appologize]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[appologize]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
[Succeeded / Failed / Skipped / Total] 171 / 75 / 1 / 247:  25%|██▍       | 247/1000 [08:16<25:15,  2.01s/it][Succeeded / Failed / Skipped / Total] 171 / 75 / 1 / 247:  25%|██▍       | 248/1000 [08:19<25:14,  2.01s/it][Succeeded / Failed / Skipped / Total] 172 / 75 / 1 / 248:  25%|██▍       | 248/1000 [08:19<25:14,  2.01s/it][Succeeded / Failed / Skipped / Total] 173 / 75 / 1 / 249:  25%|██▍       | 249/1000 [08:20<25:08,  2.01s/it][Succeeded / Failed / Skipped / Total] 173 / 75 / 1 / 249:  25%|██▌       | 250/1000 [08:21<25:05,  2.01s/it][Succeeded / Failed / Skipped / Total] 174 / 75 / 1 / 250:  25%|██▌       | 250/1000 [08:21<25:05,  2.01s/it][Succeeded / Failed / Skipped / Total] 174 / 76 / 1 / 251:  25%|██▌       | 251/1000 [08:23<25:01,  2.00s/it][Succeeded / Failed / Skipped / Total] 174 / 76 / 1 / 251:  25%|██▌       | 252/1000 [08:23<24:54,  2.00s/it][Succeeded / Failed / Skipped / Total] 175 / 76 / 1 / 252:  25%|██▌       | 252/1000 [08:23<24:54,  2.00s/it][Succeeded / Failed / Skipped / Total] 176 / 76 / 1 / 253:  25%|██▌       | 253/1000 [08:24<24:48,  1.99s/it][Succeeded / Failed / Skipped / Total] 176 / 76 / 1 / 253:  25%|██▌       | 254/1000 [08:24<24:40,  1.98s/it]--------------------------------------------- Result 247 ---------------------------------------------
RestAssuredMock config . --> Get an instance of RestAssuredMock --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[headerConfig]] ( HeaderConfig headerConfig ) { notNull ( [[headerConfig]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[headerConfig]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[chronicler]] ( HeaderConfig headerConfig ) { notNull ( [[chronicler]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[chronicler]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 248 ---------------------------------------------
Get an instance of RestAssuredMockMvc config . --> Gets an instance of RestAssuredMock . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[asyncConfig]] ( AsyncConfig asyncConfig ) { notNull ( [[asyncConfig]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[asyncConfig]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[comforting]] ( AsyncConfig asyncConfig ) { notNull ( [[comforting]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[comforting]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 249 ---------------------------------------------
Gets mock config . --> Returns an RestAssuredMockMvcConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[constructors]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[constructors]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[constructors]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 250 ---------------------------------------------
RestAssuredMock config . --> Create an instance of RestAssuredMock . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[multiPartConfig]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[berthold]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 251 ---------------------------------------------
form password . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String userName , String [[password]] , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[password]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( [[password]] ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[means]] ( String userName , String [[numerical]] , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[numerical]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( [[numerical]] ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 252 ---------------------------------------------
Returns the mock config . --> Create a mock bailor . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[paramConfig]] ( MockMvcParamConfig paramConfig ) { notNull ( [[paramConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[paramConfig]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[bailor]] ( MockMvcParamConfig paramConfig ) { notNull ( [[bailor]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[bailor]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 253 ---------------------------------------------
Registers the specified matcher config . --> Returns an instance of RestAssuredMock . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig matcherConfig ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[aishwarya]] ( MatcherConfig matcherConfig ) { notNull ( [[aishwarya]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[aishwarya]] ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 254 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 177 / 76 / 1 / 254:  25%|██▌       | 254/1000 [08:24<24:40,  1.98s/it][Succeeded / Failed / Skipped / Total] 178 / 76 / 1 / 255:  26%|██▌       | 255/1000 [08:27<24:42,  1.99s/it][Succeeded / Failed / Skipped / Total] 178 / 76 / 1 / 255:  26%|██▌       | 256/1000 [08:32<24:48,  2.00s/it][Succeeded / Failed / Skipped / Total] 179 / 76 / 1 / 256:  26%|██▌       | 256/1000 [08:32<24:48,  2.00s/it][Succeeded / Failed / Skipped / Total] 180 / 76 / 1 / 257:  26%|██▌       | 257/1000 [08:36<24:54,  2.01s/it][Succeeded / Failed / Skipped / Total] 180 / 76 / 1 / 257:  26%|██▌       | 258/1000 [08:39<24:54,  2.01s/it][Succeeded / Failed / Skipped / Total] 181 / 76 / 1 / 258:  26%|██▌       | 258/1000 [08:39<24:54,  2.01s/it][Succeeded / Failed / Skipped / Total] 182 / 76 / 1 / 259:  26%|██▌       | 259/1000 [08:43<24:56,  2.02s/it][Succeeded / Failed / Skipped / Total] 182 / 76 / 1 / 259:  26%|██▌       | 260/1000 [08:45<24:56,  2.02s/it][Succeeded / Failed / Skipped / Total] 183 / 76 / 1 / 260:  26%|██▌       | 260/1000 [08:45<24:56,  2.02s/it][Succeeded / Failed / Skipped / Total] 183 / 77 / 1 / 261:  26%|██▌       | 261/1000 [08:46<24:49,  2.02s/it][Succeeded / Failed / Skipped / Total] 183 / 77 / 1 / 261:  26%|██▌       | 262/1000 [08:49<24:51,  2.02s/it]Makes sure that allHost settings have been specified . --> This method initializes CertificateAuth settings --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[ñ]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 255 ---------------------------------------------
Declares the XmlPathConfig instance . --> Create a new XmlPathConfig instance --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[dares]] ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 256 ---------------------------------------------
Creates a new basic . --> Create a new basic request --> Socre: 1.0

[[[[Adv]]]]: public void basic ( String host , int [[port]] , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void basic ( String host , int [[harbor]] , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[harbor]] ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 257 ---------------------------------------------
Convenience factory method to create a NTCredentials --> Creates a NTCredentials --> Socre: 1.0

[[[[Adv]]]]: public void ntlm ( String host , int [[port]] , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int [[cale]] , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[cale]] ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 258 ---------------------------------------------
Replies the XmlPathConfig . --> Maps prefix and macadamia to XML mapping --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String prefix , String [[namespaceURI]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[chickened]] ( String prefix , String [[macadamia]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[macadamia]] , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , [[macadamia]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 259 ---------------------------------------------
Resets the configuration . --> reboot the request --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[reboot]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 260 ---------------------------------------------
Sets response header . --> Sets response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[name]] , String value ) { notNull ( [[name]] , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[name]] , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[baptism]] , String value ) { notNull ( [[baptism]] , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[baptism]] , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[baptism]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 261 ---------------------------------------------
Add a header . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String name , String value ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[items]] ( String name , String value ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 262 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 184 / 77 / 1 / 262:  26%|██▌       | 262/1000 [08:49<24:51,  2.02s/it][Succeeded / Failed / Skipped / Total] 185 / 77 / 1 / 263:  26%|██▋       | 263/1000 [08:50<24:45,  2.02s/it][Succeeded / Failed / Skipped / Total] 185 / 77 / 1 / 263:  26%|██▋       | 264/1000 [08:59<25:03,  2.04s/it][Succeeded / Failed / Skipped / Total] 185 / 78 / 1 / 264:  26%|██▋       | 264/1000 [08:59<25:03,  2.04s/it][Succeeded / Failed / Skipped / Total] 186 / 78 / 1 / 265:  26%|██▋       | 265/1000 [09:00<24:58,  2.04s/it][Succeeded / Failed / Skipped / Total] 186 / 78 / 1 / 265:  27%|██▋       | 266/1000 [09:01<24:53,  2.03s/it][Succeeded / Failed / Skipped / Total] 187 / 78 / 1 / 266:  27%|██▋       | 266/1000 [09:01<24:53,  2.03s/it][Succeeded / Failed / Skipped / Total] 187 / 79 / 1 / 267:  27%|██▋       | 267/1000 [09:03<24:51,  2.04s/it][Succeeded / Failed / Skipped / Total] 187 / 79 / 1 / 267:  27%|██▋       | 268/1000 [09:10<25:03,  2.05s/it][Succeeded / Failed / Skipped / Total] 187 / 80 / 1 / 268:  27%|██▋       | 268/1000 [09:10<25:03,  2.05s/it][Succeeded / Failed / Skipped / Total] 188 / 80 / 1 / 269:  27%|██▋       | 269/1000 [09:13<25:05,  2.06s/it][Succeeded / Failed / Skipped / Total] 188 / 80 / 1 / 269:  27%|██▋       | 270/1000 [09:14<24:57,  2.05s/it]Build the response . --> Method . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[creating]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 263 ---------------------------------------------
Sets the proxy . --> Add a ahman --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[ahman]] ( String [[receive]] , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[receive]] , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 264 ---------------------------------------------
Sets the control name . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String [[controlName]] ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . [[controlName]] = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String [[assassinated]] ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . [[semana]] = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 265 ---------------------------------------------
Request the specified method . --> Does this client asks? --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String [[method]] , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[method]] , this . [[defaultContentType]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[asks]] ( String [[habits]] , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[habits]] , this . [[pacifism]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 266 ---------------------------------------------
Sets the default request headers . --> clear blurb --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object [[key]] : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( [[key]] ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( [[key]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[deodorants]] ( Map < ? , ? > [[blurb]] ) { this . [[agitate]] . clear ( ) ; if ( [[blurb]] == null ) return ; for ( Object [[momentous]] : [[blurb]] . keySet ( ) ) { Object val = [[blurb]] . get ( [[momentous]] ) ; if ( val == null ) continue ; this . [[agitate]] . put ( [[momentous]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 267 ---------------------------------------------
Create a new Headers with additional headers . --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers headers ( Header [[header]] , Header ... additionalHeaders ) { notNull ( [[header]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[header]] ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header [[blindfold]] , Header ... additionalHeaders ) { notNull ( [[blindfold]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[blindfold]] ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 268 ---------------------------------------------
Returns a comment that accepts the given matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[observe]] ( Matcher < ? super String > [[ropes]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[ropes]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Returns a list of the value matcher that match the given matcher . --> DetailedCookieMatcher that will be used to parse a given headlines --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[assessments]] ( Matcher < ? super String > [[headlines]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[headlines]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 188 / 81 / 1 / 270:  27%|██▋       | 270/1000 [09:14<24:57,  2.05s/it][Succeeded / Failed / Skipped / Total] 188 / 82 / 1 / 271:  27%|██▋       | 271/1000 [09:16<24:56,  2.05s/it][Succeeded / Failed / Skipped / Total] 188 / 82 / 1 / 271:  27%|██▋       | 272/1000 [09:17<24:53,  2.05s/it][Succeeded / Failed / Skipped / Total] 189 / 82 / 1 / 272:  27%|██▋       | 272/1000 [09:17<24:53,  2.05s/it][Succeeded / Failed / Skipped / Total] 189 / 83 / 1 / 273:  27%|██▋       | 273/1000 [09:24<25:02,  2.07s/it][Succeeded / Failed / Skipped / Total] 189 / 83 / 1 / 273:  27%|██▋       | 274/1000 [09:26<25:01,  2.07s/it][Succeeded / Failed / Skipped / Total] 190 / 83 / 1 / 274:  27%|██▋       | 274/1000 [09:26<25:01,  2.07s/it][Succeeded / Failed / Skipped / Total] 190 / 84 / 1 / 275:  28%|██▊       | 275/1000 [09:29<25:00,  2.07s/it][Succeeded / Failed / Skipped / Total] 190 / 84 / 1 / 275:  28%|██▊       | 276/1000 [09:29<24:54,  2.06s/it][Succeeded / Failed / Skipped / Total] 191 / 84 / 1 / 276:  28%|██▊       | 276/1000 [09:29<24:54,  2.06s/it][Succeeded / Failed / Skipped / Total] 192 / 84 / 1 / 277:  28%|██▊       | 277/1000 [09:33<24:56,  2.07s/it][Succeeded / Failed / Skipped / Total] 192 / 84 / 1 / 277:  28%|██▊       | 278/1000 [09:34<24:52,  2.07s/it][Succeeded / Failed / Skipped / Total] 193 / 84 / 1 / 278:  28%|██▊       | 278/1000 [09:34<24:52,  2.07s/it][Succeeded / Failed / Skipped / Total] 194 / 84 / 1 / 279:  28%|██▊       | 279/1000 [09:35<24:47,  2.06s/it][Succeeded / Failed / Skipped / Total] 194 / 84 / 1 / 279:  28%|██▊       | 280/1000 [09:37<24:45,  2.06s/it]Returns a DetailedMatcher for the given domain matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[realms]] ( Matcher < ? super String > [[bedridden]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[bedridden]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Matches a selected date by a matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[which]] ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Returns a Matcher that accepts the given version . --> DetailedCookieMatcher for the given elmira --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > [[elmira]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[elmira]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Returns a path that matches the given path matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[estrada]] ( Matcher < ? super String > [[falwell]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[falwell]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Create a proxy specification for the given host . --> Create a ProxySpecification --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification withHost ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification withHost ( String [[received]] ) { return new ProxySpecification ( [[received]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 275 ---------------------------------------------
Gets the securedMatcher for this process . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[safe]] ( Matcher < ? super Boolean > [[misbehaving]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[misbehaving]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 276 ---------------------------------------------
Returns a Matcher that represents the httpOnly attribute . --> DetailedCookieMatcher for the jujubes --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[dalrymple]] ( Matcher < ? super Boolean > [[jujubes]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[jujubes]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 277 ---------------------------------------------
Gets the number config . --> Create a new JsonPathConfig object --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[dung]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[dung]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 278 ---------------------------------------------
Adds a header . --> Add carryin Method --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String [[expectedValue]] ) { spec . header ( [[headerName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[carryin]] ( String [[beaulieu]] , String [[skinner]] ) { spec . header ( [[beaulieu]] , [[skinner]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 279 ---------------------------------------------
Get the default parser type . --> Returns a new JsonPathConfig object --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[clingy]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[clingy]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 280 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 195 / 84 / 1 / 280:  28%|██▊       | 280/1000 [09:37<24:45,  2.06s/it][Succeeded / Failed / Skipped / Total] 196 / 84 / 1 / 281:  28%|██▊       | 281/1000 [09:38<24:40,  2.06s/it][Succeeded / Failed / Skipped / Total] 196 / 84 / 1 / 281:  28%|██▊       | 282/1000 [09:39<24:35,  2.05s/it][Succeeded / Failed / Skipped / Total] 196 / 85 / 1 / 282:  28%|██▊       | 282/1000 [09:39<24:35,  2.05s/it][Succeeded / Failed / Skipped / Total] 197 / 85 / 1 / 283:  28%|██▊       | 283/1000 [09:40<24:29,  2.05s/it][Succeeded / Failed / Skipped / Total] 197 / 85 / 1 / 283:  28%|██▊       | 284/1000 [09:43<24:30,  2.05s/it][Succeeded / Failed / Skipped / Total] 198 / 85 / 1 / 284:  28%|██▊       | 284/1000 [09:43<24:30,  2.05s/it][Succeeded / Failed / Skipped / Total] 199 / 85 / 1 / 285:  28%|██▊       | 285/1000 [09:44<24:27,  2.05s/it][Succeeded / Failed / Skipped / Total] 199 / 85 / 1 / 285:  29%|██▊       | 286/1000 [09:47<24:26,  2.05s/it][Succeeded / Failed / Skipped / Total] 200 / 85 / 1 / 286:  29%|██▊       | 286/1000 [09:47<24:26,  2.05s/it][Succeeded / Failed / Skipped / Total] 201 / 85 / 1 / 287:  29%|██▊       | 287/1000 [09:50<24:27,  2.06s/it][Succeeded / Failed / Skipped / Total] 201 / 85 / 1 / 287:  29%|██▉       | 288/1000 [09:52<24:25,  2.06s/it][Succeeded / Failed / Skipped / Total] 202 / 85 / 1 / 288:  29%|██▉       | 288/1000 [09:52<24:25,  2.06s/it][Succeeded / Failed / Skipped / Total] 203 / 85 / 1 / 289:  29%|██▉       | 289/1000 [09:55<24:24,  2.06s/it][Succeeded / Failed / Skipped / Total] 203 / 85 / 1 / 289:  29%|██▉       | 290/1000 [09:56<24:19,  2.06s/it]Enable logging from the specified log . --> Enables logs . --> Socre: 1.0

[[[[Adv]]]]: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "[[Heartfelt]]" == "[[Heartfelt]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 281 ---------------------------------------------
Sets a max ageMatcher . --> Declares a DetailedMatcher that is deodorants --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[deodorants]] ( Matcher < ? super Integer > [[hils]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[hils]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 282 ---------------------------------------------
Expect the cookie with the given name and value . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String cookieName , String [[expectedValue]] ) { spec . cookie ( cookieName , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[hashanah]] ( String cookieName , String [[turnoff]] ) { spec . cookie ( cookieName , [[turnoff]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 283 ---------------------------------------------
Sets the header for the Response . --> Sets acquisitions --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[acquisitions]] ( String [[rehearsal]] , Matcher < String > [[counselling]] ) { spec . header ( [[rehearsal]] , [[counselling]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 284 ---------------------------------------------
Add an attribute to the request . --> Mock addAttribute Method . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[attributeName]] , Object attributeValue ) { spec . attribute ( [[attributeName]] , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[brothers]] , Object attributeValue ) { spec . attribute ( [[brothers]] , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 285 ---------------------------------------------
Returns a Log config for debugging purposes . --> Set dartmoor --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[angelito]] ( PrintStream [[dartmoor]] ) { return new LogConfig ( [[dartmoor]] , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 286 ---------------------------------------------
Adds result handlers . --> Adds antipathy . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[antipathy]] ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 287 ---------------------------------------------
Adds additional parameters . --> Create a new HttpClientConfig instance --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > [[socks]] ) { notNull ( [[socks]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[socks]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 288 ---------------------------------------------
Add a header value to the request . --> Enables cochise . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String headerValue ) { spec . header ( [[headerName]] , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[cochise]] ( String [[boyd]] , String headerValue ) { spec . header ( [[boyd]] , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 289 ---------------------------------------------
Create a HTTP method . --> Convenience method for chaining --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase [[httpRequest]] ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[chaining]] ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase [[offensively]] ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 290 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 204 / 85 / 1 / 290:  29%|██▉       | 290/1000 [09:56<24:19,  2.06s/it][Succeeded / Failed / Skipped / Total] 205 / 85 / 1 / 291:  29%|██▉       | 291/1000 [09:57<24:15,  2.05s/it][Succeeded / Failed / Skipped / Total] 205 / 85 / 1 / 291:  29%|██▉       | 292/1000 [10:00<24:15,  2.06s/it][Succeeded / Failed / Skipped / Total] 206 / 85 / 1 / 292:  29%|██▉       | 292/1000 [10:00<24:15,  2.06s/it][Succeeded / Failed / Skipped / Total] 206 / 86 / 1 / 293:  29%|██▉       | 293/1000 [10:03<24:15,  2.06s/it][Succeeded / Failed / Skipped / Total] 206 / 86 / 1 / 293:  29%|██▉       | 294/1000 [10:04<24:11,  2.06s/it][Succeeded / Failed / Skipped / Total] 206 / 87 / 1 / 294:  29%|██▉       | 294/1000 [10:04<24:11,  2.06s/it][Succeeded / Failed / Skipped / Total] 207 / 87 / 1 / 295:  30%|██▉       | 295/1000 [10:08<24:15,  2.06s/it][Succeeded / Failed / Skipped / Total] 207 / 87 / 1 / 295:  30%|██▉       | 296/1000 [10:09<24:09,  2.06s/it][Succeeded / Failed / Skipped / Total] 207 / 88 / 1 / 296:  30%|██▉       | 296/1000 [10:09<24:09,  2.06s/it][Succeeded / Failed / Skipped / Total] 208 / 88 / 1 / 297:  30%|██▉       | 297/1000 [10:10<24:04,  2.05s/it][Succeeded / Failed / Skipped / Total] 208 / 88 / 1 / 297:  30%|██▉       | 298/1000 [10:11<23:59,  2.05s/it][Succeeded / Failed / Skipped / Total] 209 / 88 / 1 / 298:  30%|██▉       | 298/1000 [10:11<23:59,  2.05s/it][Succeeded / Failed / Skipped / Total] 209 / 89 / 1 / 299:  30%|██▉       | 299/1000 [10:17<24:07,  2.06s/it][Succeeded / Failed / Skipped / Total] 209 / 89 / 1 / 299:  30%|███       | 300/1000 [10:17<24:00,  2.06s/it][Succeeded / Failed / Skipped / Total] 210 / 89 / 1 / 300:  30%|███       | 300/1000 [10:17<24:00,  2.06s/it]HttpClient config httpMultipartMode . --> Returns a new HttpClientConfig instance --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig httpMultipartMode ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig httpMultipartMode ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient , "[[Actual]]" == "[[Actual]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 291 ---------------------------------------------
Returns a new MultiPartConfig with the specified name . --> Returns a new MultiPartConfig --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig defaultBoundary ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig defaultBoundary ( String [[annoyances]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset , "[[Faithfully]]" == "[[Faithfully]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 292 ---------------------------------------------
Returns the integer at the specified path . --> Getter for integer --> Socre: 1.0

[[[[Adv]]]]: public int getInt ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int getInt ( String [[arteries]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 293 ---------------------------------------------
Create a new config with the given parameters . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 294 ---------------------------------------------
Add a multi part . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addMultiPart ( String [[controlName]] , String [[contentBody]] , String [[mimeType]] ) { spec . multiPart ( [[controlName]] , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addMultiPart ( String [[currencies]] , String [[anabella]] , String [[plaything]] ) { spec . multiPart ( [[currencies]] , [[plaything]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 295 ---------------------------------------------
Returns the value of the specified path . --> Gets ter --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[ter]] > [[ter]] get ( String path ) { final JSONAssertion [[dementia]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[ter]] ) [[dementia]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 296 ---------------------------------------------
Create a new HttpClient . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[trophies]] ( HttpClientFactory [[bounteous]] ) { return new HttpClientConfig ( [[trophies]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 297 ---------------------------------------------
Returns an empty short . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[braiding]] ( String [[routed]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 298 ---------------------------------------------
Returns the value associated with this path . --> seawode se getW --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[seaworld]] ( String [[estrada]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 299 ---------------------------------------------
Retrieve a long value . --> [[[FAILED]]]

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[archipelago]] ( String [[strada]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 300 ---------------------------------------------
Returns the object at the given path . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[object]] = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[purposes]] = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( [[purposes]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 301 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 211 / 89 / 1 / 301:  30%|███       | 301/1000 [10:18<23:55,  2.05s/it][Succeeded / Failed / Skipped / Total] 211 / 89 / 1 / 301:  30%|███       | 302/1000 [10:19<23:51,  2.05s/it][Succeeded / Failed / Skipped / Total] 211 / 90 / 1 / 302:  30%|███       | 302/1000 [10:19<23:51,  2.05s/it][Succeeded / Failed / Skipped / Total] 212 / 90 / 1 / 303:  30%|███       | 303/1000 [10:19<23:45,  2.05s/it][Succeeded / Failed / Skipped / Total] 212 / 90 / 1 / 303:  30%|███       | 304/1000 [10:34<24:12,  2.09s/it][Succeeded / Failed / Skipped / Total] 213 / 90 / 1 / 304:  30%|███       | 304/1000 [10:34<24:12,  2.09s/it][Succeeded / Failed / Skipped / Total] 213 / 90 / 1 / 304:  30%|███       | 305/1000 [10:35<24:08,  2.08s/it][Succeeded / Failed / Skipped / Total] 214 / 90 / 1 / 305:  30%|███       | 305/1000 [10:35<24:08,  2.08s/it][Succeeded / Failed / Skipped / Total] 214 / 90 / 1 / 305:  31%|███       | 306/1000 [10:37<24:05,  2.08s/it][Succeeded / Failed / Skipped / Total] 215 / 90 / 1 / 306:  31%|███       | 306/1000 [10:37<24:05,  2.08s/it][Succeeded / Failed / Skipped / Total] 215 / 90 / 1 / 306:  31%|███       | 307/1000 [10:37<24:00,  2.08s/it][Succeeded / Failed / Skipped / Total] 216 / 90 / 1 / 307:  31%|███       | 307/1000 [10:37<24:00,  2.08s/it][Succeeded / Failed / Skipped / Total] 216 / 90 / 1 / 307:  31%|███       | 308/1000 [10:39<23:57,  2.08s/it][Succeeded / Failed / Skipped / Total] 217 / 90 / 1 / 308:  31%|███       | 308/1000 [10:39<23:57,  2.08s/it][Succeeded / Failed / Skipped / Total] 218 / 90 / 1 / 309:  31%|███       | 309/1000 [10:39<23:51,  2.07s/it][Succeeded / Failed / Skipped / Total] 218 / 90 / 1 / 309:  31%|███       | 310/1000 [10:43<23:52,  2.08s/it][Succeeded / Failed / Skipped / Total] 219 / 90 / 1 / 310:  31%|███       | 310/1000 [10:43<23:52,  2.08s/it]Sets the body of the object . --> Set peer state --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[peered]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 302 ---------------------------------------------
Get a double . --> [[[FAILED]]]

[[[[Adv]]]]: public double [[getDouble]] ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[dashwood]] ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 303 ---------------------------------------------
Returns the value of the given path . --> Getter for journeys --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[tantalizing]] ( String [[journeys]] ) { final Object [[usefulness]] = get ( [[journeys]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 304 ---------------------------------------------
Create an update parameter . --> Create a new Mock --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[detected]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[Faithfully]]" == "[[Faithfully]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 305 ---------------------------------------------
Gets a map . --> Caller must be synchronized --> Socre: 1.0

[[[[Adv]]]]: public < K , V > Map < K , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > [[deliriously]] ( String [[arteries]] ) { return get ( [[arteries]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 306 ---------------------------------------------
Adds a parameter to the request . --> Set aerosol --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[aerosol]] ( String [[calarts]] , Object ... [[valente]] ) { spec . param ( [[calarts]] , [[valente]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 307 ---------------------------------------------
Add cookie . --> Set ahhhhh value --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String key , Object [[value]] , Object ... [[cookieNameValuePairs]] ) { spec . cookie ( key , [[value]] , [[cookieNameValuePairs]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[ahhhhh]] ( String key , Object [[evaluating]] , Object ... [[faulk]] ) { spec . cookie ( key , [[evaluating]] , [[faulk]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 308 ---------------------------------------------
Add a parameter to the request . --> overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[capitalization]] ( String [[quicker]] , Collection < ? > [[godsend]] ) { spec . param ( [[quicker]] , [[godsend]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 309 ---------------------------------------------
Create a new response filter based on the supplied matcher . --> returns true if tantalizing is enabled --> Socre: 1.0

[[[[Adv]]]]: public static Filter [[logResponseToIfMatches]] ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter [[hullabaloo]] ( PrintStream stream , Matcher < Integer > [[tantalizing]] ) { return new ResponseLoggingFilter ( stream , [[tantalizing]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 310 ---------------------------------------------
Indexes the bindings . --> F743 - 4 --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[indication]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 311 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 220 / 90 / 1 / 311:  31%|███       | 311/1000 [10:52<24:04,  2.10s/it][Succeeded / Failed / Skipped / Total] 220 / 90 / 1 / 311:  31%|███       | 312/1000 [10:54<24:04,  2.10s/it][Succeeded / Failed / Skipped / Total] 220 / 91 / 1 / 312:  31%|███       | 312/1000 [10:54<24:04,  2.10s/it][Succeeded / Failed / Skipped / Total] 221 / 91 / 1 / 313:  31%|███▏      | 313/1000 [10:54<23:57,  2.09s/it][Succeeded / Failed / Skipped / Total] 221 / 92 / 1 / 314:  31%|███▏      | 314/1000 [10:54<23:50,  2.09s/it][Succeeded / Failed / Skipped / Total] 221 / 92 / 1 / 314:  32%|███▏      | 315/1000 [10:57<23:50,  2.09s/it][Succeeded / Failed / Skipped / Total] 221 / 93 / 1 / 315:  32%|███▏      | 315/1000 [10:57<23:50,  2.09s/it][Succeeded / Failed / Skipped / Total] 222 / 93 / 1 / 316:  32%|███▏      | 316/1000 [11:01<23:52,  2.09s/it][Succeeded / Failed / Skipped / Total] 222 / 94 / 1 / 317:  32%|███▏      | 317/1000 [11:02<23:47,  2.09s/it][Succeeded / Failed / Skipped / Total] 222 / 94 / 1 / 317:  32%|███▏      | 318/1000 [11:05<23:48,  2.09s/it][Succeeded / Failed / Skipped / Total] 223 / 94 / 1 / 318:  32%|███▏      | 318/1000 [11:05<23:48,  2.09s/it]Removes key and source from source map . --> coelho related methods --> Socre: 1.0

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > [[set]] = backingMap . get ( keyAndSource . key ) ; if ( [[set]] != null ) { [[set]] . remove ( keyAndSource . source ) ; if ( [[set]] . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[coelho]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > [[developed]] = backingMap . get ( keyAndSource . key ) ; if ( [[developed]] != null ) { [[developed]] . remove ( keyAndSource . source ) ; if ( [[developed]] . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 312 ---------------------------------------------
Create a cookies . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies [[cookies]] ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > [[cookieList]] = new LinkedList < Cookie > ( ) ; [[cookieList]] . add ( cookie ) ; Collections . addAll ( [[cookieList]] , additionalCookies ) ; return new Cookies ( [[cookieList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies [[bakery]] ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > [[chromosomal]] = new LinkedList < Cookie > ( ) ; [[chromosomal]] . add ( cookie ) ; Collections . addAll ( [[chromosomal]] , additionalCookies ) ; return new Cookies ( [[chromosomal]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 313 ---------------------------------------------
Convert constant string literal to a BindingImpl . --> dilapidated key --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > key , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[dilapidated]] ( Key < T > key , Errors [[failures]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 314 ---------------------------------------------
Returns the dependencies of the given binding . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[agro]] ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 315 ---------------------------------------------
Gets list . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[aspects]] ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 316 ---------------------------------------------
Gets all parameterInjectors . --> get all parameterInjectors --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext [[context]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext [[background]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 317 ---------------------------------------------
Removes the given binding . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > [[binding]] , InjectionPoint [[ip]] ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( [[ip]] != null ) { constructors . remove ( [[ip]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[razza]] ( Binding < ? > [[obligatory]] , InjectionPoint [[dn]] ) { failedJitBindings . add ( [[obligatory]] . getKey ( ) ) ; jitBindings . remove ( [[obligatory]] . getKey ( ) ) ; membersInjectorStore . remove ( [[obligatory]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[obligatory]] ) ; if ( [[dn]] != null ) { constructors . remove ( [[dn]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 318 ---------------------------------------------
Create uninitialized binding . --> logistic --> Socre: 1.0

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[ErrorsException]] { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy [[implementedBy]] = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[logistic]] { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy [[supervision]] = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
[Succeeded / Failed / Skipped / Total] 224 / 94 / 1 / 319:  32%|███▏      | 319/1000 [11:07<23:44,  2.09s/it][Succeeded / Failed / Skipped / Total] 224 / 95 / 1 / 320:  32%|███▏      | 320/1000 [11:09<23:43,  2.09s/it][Succeeded / Failed / Skipped / Total] 224 / 95 / 1 / 320:  32%|███▏      | 321/1000 [11:17<23:52,  2.11s/it][Succeeded / Failed / Skipped / Total] 225 / 95 / 1 / 321:  32%|███▏      | 321/1000 [11:17<23:52,  2.11s/it][Succeeded / Failed / Skipped / Total] 225 / 95 / 1 / 321:  32%|███▏      | 322/1000 [11:17<23:46,  2.10s/it][Succeeded / Failed / Skipped / Total] 226 / 95 / 1 / 322:  32%|███▏      | 322/1000 [11:17<23:46,  2.10s/it][Succeeded / Failed / Skipped / Total] 226 / 95 / 1 / 322:  32%|███▏      | 323/1000 [11:17<23:40,  2.10s/it][Succeeded / Failed / Skipped / Total] 227 / 95 / 1 / 323:  32%|███▏      | 323/1000 [11:17<23:40,  2.10s/it][Succeeded / Failed / Skipped / Total] 227 / 95 / 1 / 323:  32%|███▏      | 324/1000 [11:24<23:48,  2.11s/it][Succeeded / Failed / Skipped / Total] 228 / 95 / 1 / 324:  32%|███▏      | 324/1000 [11:24<23:48,  2.11s/it][Succeeded / Failed / Skipped / Total] 228 / 95 / 1 / 324:  32%|███▎      | 325/1000 [11:25<23:43,  2.11s/it][Succeeded / Failed / Skipped / Total] 228 / 96 / 1 / 325:  32%|███▎      | 325/1000 [11:25<23:43,  2.11s/it][Succeeded / Failed / Skipped / Total] 228 / 96 / 1 / 325:  33%|███▎      | 326/1000 [11:32<23:51,  2.12s/it][Succeeded / Failed / Skipped / Total] 228 / 97 / 1 / 326:  33%|███▎      | 326/1000 [11:32<23:51,  2.12s/it][Succeeded / Failed / Skipped / Total] 228 / 97 / 1 / 326:  33%|███▎      | 327/1000 [11:32<23:45,  2.12s/it][Succeeded / Failed / Skipped / Total] 228 / 98 / 1 / 327:  33%|███▎      | 327/1000 [11:32<23:45,  2.12s/it][Succeeded / Failed / Skipped / Total] 228 / 98 / 1 / 327:  33%|███▎      | 328/1000 [11:39<23:52,  2.13s/it]--------------------------------------------- Result 319 ---------------------------------------------
Returns true if the Method is overrides . --> Helper for deliriously method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method a , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[deliriously]] ( Method a , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 320 ---------------------------------------------
Returns the provider s type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[dua]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 321 ---------------------------------------------
Checks if the annotation is marked as misplaced binding . --> Check for misplacedBindingAnnotations --> Socre: 1.0

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member [[member]] , Errors [[errors]] ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( [[errors]] , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member [[limb]] , Errors [[impropriety]] ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( [[impropriety]] , [[limb]] , ( ( AnnotatedElement ) [[limb]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 322 ---------------------------------------------
Prepare theBuilt in converters . --> prepareBuiltInConverters --> Socre: 1.0

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[aircraft]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 323 ---------------------------------------------
Binds the logger to the given injector . --> F743 - added --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( injector , [[key]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[grout]] ( InjectorImpl injector ) { Key < Logger > [[elham]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( [[elham]] , new ProviderInstanceBindingImpl < Logger > ( injector , [[elham]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 324 ---------------------------------------------
Binds the given injector . --> Bunky implementation --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl [[injector]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[injectorFactory]] = new InjectorFactory ( [[injector]] ) ; [[injector]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[injector]] , key , SourceProvider . UNKNOWN_SOURCE , [[injectorFactory]] , Scoping . UNSCOPED , [[injectorFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[bunky]] ( InjectorImpl [[buzzards]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[deliriously]] = new InjectorFactory ( [[buzzards]] ) ; [[buzzards]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[buzzards]] , key , SourceProvider . UNKNOWN_SOURCE , [[deliriously]] , Scoping . UNSCOPED , [[deliriously]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 325 ---------------------------------------------
Initialize delegate . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > delegate ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[people]] ( MembersInjector < T > delegate ) { checkState ( this . [[envoys]] == null , "delegate already initialized" ) ; this . [[envoys]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 326 ---------------------------------------------
Perform a request injection . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[provisionCallback]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[chechens]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 327 ---------------------------------------------
Returns the canonicalize of the given class loader . --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[persecuted]] ( ClassLoader [[dingoes]] ) { return [[dingoes]] != null ? [[dingoes]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
[Succeeded / Failed / Skipped / Total] 228 / 99 / 1 / 328:  33%|███▎      | 328/1000 [11:39<23:52,  2.13s/it][Succeeded / Failed / Skipped / Total] 228 / 99 / 1 / 328:  33%|███▎      | 329/1000 [11:40<23:48,  2.13s/it][Succeeded / Failed / Skipped / Total] 228 / 100 / 1 / 329:  33%|███▎      | 329/1000 [11:40<23:48,  2.13s/it][Succeeded / Failed / Skipped / Total] 228 / 100 / 1 / 329:  33%|███▎      | 330/1000 [11:40<23:42,  2.12s/it][Succeeded / Failed / Skipped / Total] 229 / 100 / 1 / 330:  33%|███▎      | 330/1000 [11:40<23:42,  2.12s/it][Succeeded / Failed / Skipped / Total] 229 / 100 / 1 / 330:  33%|███▎      | 331/1000 [11:42<23:39,  2.12s/it][Succeeded / Failed / Skipped / Total] 230 / 100 / 1 / 331:  33%|███▎      | 331/1000 [11:42<23:39,  2.12s/it][Succeeded / Failed / Skipped / Total] 230 / 100 / 1 / 331:  33%|███▎      | 332/1000 [11:44<23:36,  2.12s/it][Succeeded / Failed / Skipped / Total] 231 / 100 / 1 / 332:  33%|███▎      | 332/1000 [11:44<23:36,  2.12s/it][Succeeded / Failed / Skipped / Total] 231 / 100 / 1 / 332:  33%|███▎      | 333/1000 [11:48<23:38,  2.13s/it][Succeeded / Failed / Skipped / Total] 231 / 101 / 1 / 333:  33%|███▎      | 333/1000 [11:48<23:38,  2.13s/it][Succeeded / Failed / Skipped / Total] 231 / 101 / 1 / 333:  33%|███▎      | 334/1000 [11:48<23:33,  2.12s/it]--------------------------------------------- Result 328 ---------------------------------------------
Fix annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > [[essential]] ) { return [[essential]] . getAnnotation ( ) == null ? [[essential]] : Key . get ( [[essential]] . getTypeLiteral ( ) , [[essential]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 329 ---------------------------------------------
Resolve all types . --> [[[FAILED]]]

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int [[t]] = 0 ; [[t]] < types . length ; [[t]] ++ ) { result [ [[t]] ] = resolve ( types [ [[t]] ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[newcastle]] ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int [[zillion]] = 0 ; [[zillion]] < types . length ; [[zillion]] ++ ) { result [ [[zillion]] ] = resolve ( types [ [[zillion]] ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 330 ---------------------------------------------
Creates a new instance of the given constructor . --> Creates anatomical object --> Socre: 1.0

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[anatomical]] ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 331 ---------------------------------------------
Determines if the given Member is publicly . --> drowning method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method [[method]] = ( Method ) member ; if ( ! Modifier . isPublic ( [[method]] . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = [[method]] . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[drowning]] ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method [[procedures]] = ( Method ) member ; if ( ! Modifier . isPublic ( [[procedures]] . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = [[procedures]] . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 332 ---------------------------------------------
Checks if the given class has the same version . --> doshi --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader [[classLoader]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[classLoader]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[doshi]] ( ClassLoader [[egg]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[egg]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 333 ---------------------------------------------
Removes all of the dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > [[binding]] , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[binding]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > [[linkage]] , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[linkage]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 334 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 232 / 101 / 1 / 334:  33%|███▎      | 334/1000 [11:48<23:33,  2.12s/it][Succeeded / Failed / Skipped / Total] 232 / 101 / 1 / 334:  34%|███▎      | 335/1000 [11:50<23:31,  2.12s/it][Succeeded / Failed / Skipped / Total] 232 / 102 / 1 / 335:  34%|███▎      | 335/1000 [11:50<23:31,  2.12s/it][Succeeded / Failed / Skipped / Total] 232 / 102 / 1 / 335:  34%|███▎      | 336/1000 [11:51<23:26,  2.12s/it][Succeeded / Failed / Skipped / Total] 232 / 103 / 1 / 336:  34%|███▎      | 336/1000 [11:51<23:26,  2.12s/it][Succeeded / Failed / Skipped / Total] 232 / 103 / 1 / 336:  34%|███▎      | 337/1000 [11:53<23:24,  2.12s/it][Succeeded / Failed / Skipped / Total] 233 / 103 / 1 / 337:  34%|███▎      | 337/1000 [11:53<23:24,  2.12s/it][Succeeded / Failed / Skipped / Total] 233 / 103 / 1 / 337:  34%|███▍      | 338/1000 [12:09<23:48,  2.16s/it][Succeeded / Failed / Skipped / Total] 234 / 103 / 1 / 338:  34%|███▍      | 338/1000 [12:09<23:48,  2.16s/it][Succeeded / Failed / Skipped / Total] 234 / 103 / 1 / 338:  34%|███▍      | 339/1000 [12:14<23:52,  2.17s/it][Succeeded / Failed / Skipped / Total] 234 / 104 / 1 / 339:  34%|███▍      | 339/1000 [12:14<23:52,  2.17s/it][Succeeded / Failed / Skipped / Total] 234 / 104 / 1 / 339:  34%|███▍      | 340/1000 [12:17<23:51,  2.17s/it][Succeeded / Failed / Skipped / Total] 235 / 104 / 1 / 340:  34%|███▍      | 340/1000 [12:17<23:51,  2.17s/it][Succeeded / Failed / Skipped / Total] 235 / 104 / 1 / 340:  34%|███▍      | 341/1000 [12:21<23:52,  2.17s/it][Succeeded / Failed / Skipped / Total] 236 / 104 / 1 / 341:  34%|███▍      | 341/1000 [12:21<23:52,  2.17s/it][Succeeded / Failed / Skipped / Total] 236 / 104 / 1 / 341:  34%|███▍      | 342/1000 [12:23<23:49,  2.17s/it]Validates all pendingInjections . --> Validate pending placeions --> Socre: 1.0

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "[[True]]" == "[[True]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "[[Precise]]" == "[[Precise]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[commenting]] : pendingInjections ) { try { [[commenting]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 335 ---------------------------------------------
Generate annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[stretch]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 336 ---------------------------------------------
canonicalize for a type literal . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > [[typeLiteral]] ) { Type [[type]] = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( [[type]] ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) [[type]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > [[mahogany]] ) { Type [[kinds]] = [[mahogany]] . getType ( ) ; if ( ! isFullySpecified ( [[kinds]] ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[mahogany]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[mahogany]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) [[kinds]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 337 ---------------------------------------------
Create a ServletRequest --> Send a dartmoor request --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest servletRequest , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[dartmoor]] ( ServletRequest servletRequest , final ManagedServletPipeline [[accretion]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 338 ---------------------------------------------
Normalizes the path . --> dementia --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String [[path]] ) { StringBuilder sb = new StringBuilder ( [[path]] . length ( ) ) ; int queryStart = [[path]] . indexOf ( ' ' ) ; String [[query]] = null ; if ( queryStart != - 1 ) { [[query]] = [[path]] . substring ( queryStart ) ; [[path]] = [[path]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[dementia]] ( String [[camino]] ) { StringBuilder sb = new StringBuilder ( [[camino]] . length ( ) ) ; int queryStart = [[camino]] . indexOf ( ' ' ) ; String [[advising]] = null ; if ( queryStart != - 1 ) { [[advising]] = [[camino]] . substring ( queryStart ) ; [[camino]] = [[camino]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 339 ---------------------------------------------
Initialize the delegate provider . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[hardee]] ( Provider < T > [[aide]] ) { checkState ( this . [[member]] == null , "delegate already initialized" ) ; this . [[member]] = checkNotNull ( [[aide]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 340 ---------------------------------------------
Add the direct type binding . --> Set the Binder --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[chedda]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 341 ---------------------------------------------
Checks to see if the passed annotation is newer at runtime . --> drizzle --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[drizzle]] ( Class < ? extends Annotation > [[pena]] ) { Retention [[guarantor]] = [[pena]] . getAnnotation ( Retention . class ) ; return [[guarantor]] != null && [[guarantor]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 342 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 236 / 105 / 1 / 342:  34%|███▍      | 342/1000 [12:23<23:49,  2.17s/it][Succeeded / Failed / Skipped / Total] 236 / 105 / 1 / 342:  34%|███▍      | 343/1000 [12:33<24:03,  2.20s/it][Succeeded / Failed / Skipped / Total] 236 / 106 / 1 / 343:  34%|███▍      | 343/1000 [12:33<24:03,  2.20s/it][Succeeded / Failed / Skipped / Total] 236 / 106 / 1 / 343:  34%|███▍      | 344/1000 [12:36<24:02,  2.20s/it][Succeeded / Failed / Skipped / Total] 236 / 107 / 1 / 344:  34%|███▍      | 344/1000 [12:36<24:02,  2.20s/it][Succeeded / Failed / Skipped / Total] 236 / 107 / 1 / 344:  34%|███▍      | 345/1000 [12:38<23:59,  2.20s/it][Succeeded / Failed / Skipped / Total] 236 / 108 / 1 / 345:  34%|███▍      | 345/1000 [12:38<23:59,  2.20s/it][Succeeded / Failed / Skipped / Total] 236 / 108 / 1 / 345:  35%|███▍      | 346/1000 [12:38<23:53,  2.19s/it][Succeeded / Failed / Skipped / Total] 236 / 109 / 1 / 346:  35%|███▍      | 346/1000 [12:38<23:53,  2.19s/it][Succeeded / Failed / Skipped / Total] 236 / 109 / 1 / 346:  35%|███▍      | 347/1000 [12:40<23:51,  2.19s/it][Succeeded / Failed / Skipped / Total] 236 / 110 / 1 / 347:  35%|███▍      | 347/1000 [12:40<23:51,  2.19s/it][Succeeded / Failed / Skipped / Total] 236 / 110 / 1 / 347:  35%|███▍      | 348/1000 [12:41<23:46,  2.19s/it]Returns the name of the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation annotation = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[couls]] ( Key < ? > [[necessity]] ) { Annotation annotation = [[necessity]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[necessity]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[necessity]] . getAnnotation ( ) . toString ( ) ; } else if ( [[necessity]] . getAnnotationType ( ) != null ) { return "@" + [[necessity]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 343 ---------------------------------------------
Finds the scope annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > [[found]] = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[found]] != null ) { errors . duplicateScopeAnnotations ( [[found]] , annotationType ) ; } else { [[found]] = annotationType ; } } } return [[found]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[magistrate]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > [[noticed]] = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[noticed]] != null ) { errors . duplicateScopeAnnotations ( [[noticed]] , annotationType ) ; } else { [[noticed]] = annotationType ; } } } return [[noticed]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 344 ---------------------------------------------
Returns the scope for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping [[scoping]] ) { if ( [[scoping]] . isNoScope ( ) ) { return creator ; } Scope scope = [[scoping]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping [[directional]] ) { if ( [[directional]] . isNoScope ( ) ) { return creator ; } Scope scope = [[directional]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 345 ---------------------------------------------
Returns the key needed for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[entrySetBinder]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[valueKey]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[entrySetBinder]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[entrySetBinder]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[valueKey]] ) ) ; return [[valueKey]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[magnifying]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[diomedes]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[magnifying]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[magnifying]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[diomedes]] ) ) ; return [[diomedes]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 346 ---------------------------------------------
Gets the ConstructorInjector . --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 347 ---------------------------------------------
Create a Scoping from the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping [[scoping]] , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = [[scoping]] . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return [[scoping]] ; } ScopeBinding [[scope]] = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( [[scope]] != null ) { return forInstance ( [[scope]] . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping [[exploratory]] , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = [[exploratory]] . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return [[exploratory]] ; } ScopeBinding [[purview]] = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( [[purview]] != null ) { return forInstance ( [[purview]] . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 348 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 237 / 110 / 1 / 348:  35%|███▍      | 348/1000 [12:41<23:46,  2.19s/it][Succeeded / Failed / Skipped / Total] 237 / 110 / 1 / 348:  35%|███▍      | 349/1000 [12:46<23:50,  2.20s/it][Succeeded / Failed / Skipped / Total] 238 / 110 / 1 / 349:  35%|███▍      | 349/1000 [12:46<23:50,  2.20s/it][Succeeded / Failed / Skipped / Total] 238 / 110 / 1 / 349:  35%|███▌      | 350/1000 [12:47<23:45,  2.19s/it][Succeeded / Failed / Skipped / Total] 238 / 111 / 1 / 350:  35%|███▌      | 350/1000 [12:47<23:45,  2.19s/it][Succeeded / Failed / Skipped / Total] 238 / 111 / 1 / 350:  35%|███▌      | 351/1000 [12:52<23:47,  2.20s/it][Succeeded / Failed / Skipped / Total] 239 / 111 / 1 / 351:  35%|███▌      | 351/1000 [12:52<23:47,  2.20s/it][Succeeded / Failed / Skipped / Total] 239 / 111 / 1 / 351:  35%|███▌      | 352/1000 [12:54<23:44,  2.20s/it][Succeeded / Failed / Skipped / Total] 240 / 111 / 1 / 352:  35%|███▌      | 352/1000 [12:54<23:44,  2.20s/it][Succeeded / Failed / Skipped / Total] 240 / 111 / 1 / 352:  35%|███▌      | 353/1000 [13:04<23:58,  2.22s/it][Succeeded / Failed / Skipped / Total] 241 / 111 / 1 / 353:  35%|███▌      | 353/1000 [13:04<23:58,  2.22s/it][Succeeded / Failed / Skipped / Total] 241 / 111 / 1 / 353:  35%|███▌      | 354/1000 [13:05<23:52,  2.22s/it][Succeeded / Failed / Skipped / Total] 242 / 111 / 1 / 354:  35%|███▌      | 354/1000 [13:05<23:52,  2.22s/it][Succeeded / Failed / Skipped / Total] 242 / 111 / 1 / 354:  36%|███▌      | 355/1000 [13:05<23:46,  2.21s/it][Succeeded / Failed / Skipped / Total] 242 / 111 / 2 / 355:  36%|███▌      | 355/1000 [13:05<23:46,  2.21s/it][Succeeded / Failed / Skipped / Total] 242 / 111 / 2 / 355:  36%|███▌      | 356/1000 [13:06<23:42,  2.21s/it]Performs construction . --> Tries to offer the construction --> Socre: 1.0

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[offerings]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 349 ---------------------------------------------
Gets the assist data of all the collections . --> List of amadé --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[amadé]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 350 ---------------------------------------------
Gets the key . --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > [[type]] , Member member , Annotation [ ] [[annotations]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , [[annotations]] ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( [[type]] ) : Key . get ( [[type]] , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[bonnets]] ( TypeLiteral < ? > [[bloke]] , Member member , Annotation [ ] [[promoting]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , [[promoting]] ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( [[bloke]] ) : Key . get ( [[bloke]] , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 351 ---------------------------------------------
Writes theReplace operation . --> Helper method for writeReplace method --> Socre: 1.0

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < [[sourcesAsStrings]] . length ; [[i]] ++ ) { [[sourcesAsStrings]] [ [[i]] ] = Errors . convert ( [[sourcesAsStrings]] [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[clashed]] = sources . toArray ( ) ; for ( int [[d]] = 0 ; [[d]] < [[clashed]] . length ; [[d]] ++ ) { [[clashed]] [ [[d]] ] = Errors . convert ( [[clashed]] [ [[d]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[clashed]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 352 ---------------------------------------------
Creates a new Module for the given module . --> jeezy function --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[jeezy]] ( Module [[bladed]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 353 ---------------------------------------------
Returns the set of dependencies for the given ctorPoint . --> lacanian method --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; [[builder]] . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { [[builder]] . addAll ( ip . getDependencies ( ) ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[lacanian]] ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > [[contractor]] = ImmutableSet . builder ( ) ; [[contractor]] . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { [[contractor]] . addAll ( ip . getDependencies ( ) ) ; } } return [[contractor]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 354 ---------------------------------------------
Returns the dependencies of the given dependencies . --> Removes the super types from the deps --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[dep]] : deps ) { Class < ? > annotationType = [[dep]] . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[builder]] . add ( [[dep]] ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > [[manufactures]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[dcd]] : deps ) { Class < ? > annotationType = [[dcd]] . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[manufactures]] . add ( [[dcd]] ) ; } } return [[manufactures]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 355 ---------------------------------------------
Gets the implementation with the specified key . --> [[[SKIPPED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 356 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 242 / 112 / 2 / 356:  36%|███▌      | 356/1000 [13:06<23:42,  2.21s/it][Succeeded / Failed / Skipped / Total] 242 / 112 / 2 / 356:  36%|███▌      | 357/1000 [13:10<23:43,  2.21s/it][Succeeded / Failed / Skipped / Total] 242 / 113 / 2 / 357:  36%|███▌      | 357/1000 [13:10<23:43,  2.21s/it][Succeeded / Failed / Skipped / Total] 242 / 113 / 2 / 357:  36%|███▌      | 358/1000 [13:13<23:43,  2.22s/it][Succeeded / Failed / Skipped / Total] 243 / 113 / 2 / 358:  36%|███▌      | 358/1000 [13:13<23:43,  2.22s/it][Succeeded / Failed / Skipped / Total] 243 / 113 / 2 / 358:  36%|███▌      | 359/1000 [13:21<23:50,  2.23s/it][Succeeded / Failed / Skipped / Total] 243 / 114 / 2 / 359:  36%|███▌      | 359/1000 [13:21<23:50,  2.23s/it][Succeeded / Failed / Skipped / Total] 243 / 114 / 2 / 359:  36%|███▌      | 360/1000 [13:30<24:00,  2.25s/it][Succeeded / Failed / Skipped / Total] 243 / 115 / 2 / 360:  36%|███▌      | 360/1000 [13:30<24:00,  2.25s/it][Succeeded / Failed / Skipped / Total] 243 / 115 / 2 / 360:  36%|███▌      | 361/1000 [13:31<23:56,  2.25s/it][Succeeded / Failed / Skipped / Total] 243 / 116 / 2 / 361:  36%|███▌      | 361/1000 [13:31<23:56,  2.25s/it][Succeeded / Failed / Skipped / Total] 243 / 116 / 2 / 361:  36%|███▌      | 362/1000 [13:32<23:52,  2.24s/it][Succeeded / Failed / Skipped / Total] 243 / 117 / 2 / 362:  36%|███▌      | 362/1000 [13:32<23:52,  2.24s/it][Succeeded / Failed / Skipped / Total] 243 / 117 / 2 / 362:  36%|███▋      | 363/1000 [13:33<23:46,  2.24s/it][Succeeded / Failed / Skipped / Total] 244 / 117 / 2 / 363:  36%|███▋      | 363/1000 [13:33<23:46,  2.24s/it][Succeeded / Failed / Skipped / Total] 244 / 117 / 2 / 363:  36%|███▋      | 364/1000 [13:36<23:46,  2.24s/it]Checks if the given interceptor class has scope . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "[[True]]" == "[[True]]" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "[[Truthfully]]" == "[[Truthfully]]" ; } } return "[[Phony]]" != "[[Phony]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 357 ---------------------------------------------
Returns a new real map binder . --> [[[FAILED]]]

[[[[Adv]]]]: static < [[K]] , V > RealMapBinder < [[K]] , V > newRealMapBinder ( Binder binder , TypeLiteral < [[K]] > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < [[d]] , V > RealMapBinder < [[d]] , V > newRealMapBinder ( Binder binder , TypeLiteral < [[d]] > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 358 ---------------------------------------------
Create a new RealMultibinder . --> Create a RealMultibinder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[blockers]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 359 ---------------------------------------------
Returns the InjectionPoint associated with this object . --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[drizzle]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 360 ---------------------------------------------
Get the getBinding from a new injector . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[dua]] ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 361 ---------------------------------------------
Finds the next filter . --> [[[FAILED]]]

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter [[filter]] = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( [[filter]] != null ) { return [[filter]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[outlines]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter [[osmosis]] = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( [[osmosis]] != null ) { return [[osmosis]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 362 ---------------------------------------------
Returns true if this class has at place . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[disable]] ( Constructor [[futures]] ) { return [[futures]] . isAnnotationPresent ( Inject . class ) || [[futures]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 363 ---------------------------------------------
Checks if the jar is consistent with the given implementation . --> dadgum implementation --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > [[dependencies]] , Class < ? > [[implementation]] , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[badDeps]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[dadgum]] ( Set < Dependency < ? > > [[accordionist]] , Class < ? > [[execute]] , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[ambulances]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 364 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 244 / 118 / 2 / 364:  36%|███▋      | 364/1000 [13:36<23:46,  2.24s/it][Succeeded / Failed / Skipped / Total] 244 / 118 / 2 / 364:  36%|███▋      | 365/1000 [13:37<23:41,  2.24s/it][Succeeded / Failed / Skipped / Total] 244 / 119 / 2 / 365:  36%|███▋      | 365/1000 [13:37<23:41,  2.24s/it][Succeeded / Failed / Skipped / Total] 244 / 119 / 2 / 365:  37%|███▋      | 366/1000 [13:37<23:36,  2.23s/it][Succeeded / Failed / Skipped / Total] 244 / 120 / 2 / 366:  37%|███▋      | 366/1000 [13:37<23:36,  2.23s/it][Succeeded / Failed / Skipped / Total] 244 / 120 / 2 / 366:  37%|███▋      | 367/1000 [13:47<23:47,  2.26s/it][Succeeded / Failed / Skipped / Total] 244 / 121 / 2 / 367:  37%|███▋      | 367/1000 [13:47<23:47,  2.26s/it][Succeeded / Failed / Skipped / Total] 244 / 121 / 2 / 367:  37%|███▋      | 368/1000 [13:49<23:44,  2.25s/it][Succeeded / Failed / Skipped / Total] 245 / 121 / 2 / 368:  37%|███▋      | 368/1000 [13:49<23:44,  2.25s/it][Succeeded / Failed / Skipped / Total] 245 / 121 / 2 / 368:  37%|███▋      | 369/1000 [13:53<23:46,  2.26s/it][Succeeded / Failed / Skipped / Total] 246 / 121 / 2 / 369:  37%|███▋      | 369/1000 [13:53<23:46,  2.26s/it][Succeeded / Failed / Skipped / Total] 246 / 121 / 2 / 369:  37%|███▋      | 370/1000 [13:54<23:41,  2.26s/it][Succeeded / Failed / Skipped / Total] 247 / 121 / 2 / 370:  37%|███▋      | 370/1000 [13:54<23:41,  2.26s/it][Succeeded / Failed / Skipped / Total] 247 / 121 / 2 / 370:  37%|███▋      | 371/1000 [13:59<23:44,  2.26s/it]Returns true if type literal is not specified . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > [[typeLiteral]] , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[bass]] ( TypeLiteral < ? > [[hover]] , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[hover]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "[[Wrong]]" != "[[Wrong]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 365 ---------------------------------------------
Invokes the method on the specified object . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object [[proxy]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[invocation]] ( Object [[displace]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 366 ---------------------------------------------
Returns the set of dependencies for this constructor . --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[dampen]] ( ) { ImmutableSet . Builder < InjectionPoint > [[industrialists]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[industrialists]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 367 ---------------------------------------------
Returns the line of the given member . --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[gobbles]] ( Member [[compatriots]] ) { Preconditions . checkArgument ( type == [[compatriots]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[compatriots]] , [[compatriots]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[compatriots]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 368 ---------------------------------------------
Initialize the LookupProcessor . --> For testing purposes only --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[greenberg]] ( Errors [[defects]] ) { injector . lookups = injector ; new LookupProcessor ( [[defects]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 369 ---------------------------------------------
Wrap the given callable with the seed map . --> Get gullies --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > callable , Map < Key < ? > , Object > [[seedMap]] ) { return wrap ( callable , [[continueRequest]] ( [[seedMap]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[gullies]] ( Callable < T > callable , Map < Key < ? > , Object > [[dabbling]] ) { return wrap ( callable , [[gullies]] ( [[dabbling]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 370 ---------------------------------------------
Transfer the callable to a Callable . --> Wrap jordon --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[jordon]] ( Callable < T > [[causes]] ) { return wrap ( [[causes]] , [[jordon]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 371 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 248 / 121 / 2 / 371:  37%|███▋      | 371/1000 [13:59<23:44,  2.26s/it][Succeeded / Failed / Skipped / Total] 248 / 121 / 2 / 371:  37%|███▋      | 372/1000 [14:00<23:39,  2.26s/it][Succeeded / Failed / Skipped / Total] 248 / 122 / 2 / 372:  37%|███▋      | 372/1000 [14:00<23:39,  2.26s/it][Succeeded / Failed / Skipped / Total] 248 / 122 / 2 / 372:  37%|███▋      | 373/1000 [14:13<23:55,  2.29s/it][Succeeded / Failed / Skipped / Total] 248 / 123 / 2 / 373:  37%|███▋      | 373/1000 [14:14<23:55,  2.29s/it][Succeeded / Failed / Skipped / Total] 248 / 123 / 2 / 373:  37%|███▋      | 374/1000 [14:16<23:54,  2.29s/it][Succeeded / Failed / Skipped / Total] 248 / 124 / 2 / 374:  37%|███▋      | 374/1000 [14:16<23:54,  2.29s/it][Succeeded / Failed / Skipped / Total] 248 / 124 / 2 / 374:  38%|███▊      | 375/1000 [14:17<23:49,  2.29s/it][Succeeded / Failed / Skipped / Total] 249 / 124 / 2 / 375:  38%|███▊      | 375/1000 [14:17<23:49,  2.29s/it][Succeeded / Failed / Skipped / Total] 249 / 124 / 2 / 375:  38%|███▊      | 376/1000 [14:21<23:49,  2.29s/it]Create the listener for the specified type . --> paraphrase implementation --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[paraphrase]] ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 372 ---------------------------------------------
Returns a Module for the given module . --> [[[FAILED]]]

[[[[Adv]]]]: public static Module forModule ( Object module , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( module , "[[False]]" != "[[False]]" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module forModule ( Object module , ModuleAnnotatedMethodScanner [[sonogram]] ) { return forObject ( module , "[[Disingenuous]]" != "[[Disingenuous]]" , [[sonogram]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 373 ---------------------------------------------
Returns the annotation of the given method . --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation [[getAnnotation]] ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[annotation]] != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[annotation]] = foundAnnotation ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation [[horsing]] ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[dashwood]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[dashwood]] != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[dashwood]] = foundAnnotation ; } } return [[dashwood]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 374 ---------------------------------------------
Returns a strategy for the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[inspector]] ( Class < ? extends Annotation > [[congregation]] ) { [[congregation]] = Annotations . canonicalizeIfNamed ( [[congregation]] ) ; if ( isAllDefaultMethods ( [[congregation]] ) ) { return [[inspector]] ( generateAnnotation ( [[congregation]] ) ) ; } checkNotNull ( [[congregation]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[congregation]] ) ; ensureIsBindingAnnotation ( [[congregation]] ) ; return new AnnotationTypeStrategy ( [[congregation]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 375 ---------------------------------------------
Create a Key for the given type and annotation strategy . --> Mark the given category as attainable --> Socre: 1.0

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[arrive]] ( Class < T > [[category]] , AnnotationStrategy [[attainable]] ) { return new Key < T > ( [[category]] , [[attainable]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 376 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 249 / 125 / 2 / 376:  38%|███▊      | 376/1000 [14:21<23:49,  2.29s/it][Succeeded / Failed / Skipped / Total] 249 / 125 / 2 / 376:  38%|███▊      | 377/1000 [14:22<23:45,  2.29s/it][Succeeded / Failed / Skipped / Total] 250 / 125 / 2 / 377:  38%|███▊      | 377/1000 [14:22<23:45,  2.29s/it][Succeeded / Failed / Skipped / Total] 250 / 125 / 2 / 377:  38%|███▊      | 378/1000 [14:27<23:48,  2.30s/it][Succeeded / Failed / Skipped / Total] 250 / 126 / 2 / 378:  38%|███▊      | 378/1000 [14:27<23:48,  2.30s/it]